<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml"><!-- Mirrored from tools.ietf.org/html/rfc4862 by HTTrack Website Copier/3.x [XR&CO'2013], Sat, 07 Jun 2014 20:18:45 GMT --><!-- Added by HTTrack --><head><meta content="text/html;charset=utf-8" http-equiv="content-type"/><!-- /Added by HTTrack -->

    <meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
    <meta content="index,follow" name="robots"/>
    <meta content="rfcmarkup version 1.107" name="creator"/>
    <link href="http://purl.org/dc/elements/1.1/" rel="schema.DC"/>
<meta content="rfc2462" name="DC.Relation.Replaces"/>
<meta content="urn:ietf:rfc:4862" name="DC.Identifier"/>
<meta content="September, 2007" name="DC.Date.Issued"/>
<meta content="Narten, Thomas" name="DC.Creator"/>
<meta content="Thomson, Susan" name="DC.Creator"/>
<meta content="Jinmei, Tatuya" name="DC.Creator"/>
<meta content="This document specifies the steps a host takes in deciding how to\nautoconfigure its interfaces in IP version 6. The autoconfiguration\nprocess includes generating a link-local address, generating global\naddresses via stateless address autoconfiguration, and the Duplicate\nAddress Detection procedure to verify the uniqueness of the addresses\non a link. [STANDARDS-TRACK]" name="DC.Description.Abstract"/>
<meta content="IPv6 Stateless Address Autoconfiguration" name="DC.Title"/>

    <link href="http://tools.ietf.org/images/rfc.png" rel="icon" type="image/png"/>
    <link href="http://tools.ietf.org/images/rfc.png" rel="shortcut icon" type="image/png"/>
    <title>RFC 4862 - IPv6 Stateless Address Autoconfiguration</title>
    
    
    <style type="text/css">
	body {
	    margin: 0px 8px;
            font-size: 1em;
	}
        h1, h2, h3, h4, h5, h6, .h1, .h2, .h3, .h4, .h5, .h6 {
	    font-weight: bold;
            line-height: 0pt;
            display: inline;
            white-space: pre;
            font-family: monospace;
            font-size: 1em;
	    font-weight: bold;
        }
        pre {
            font-size: 1em;
            margin-top: 0px;
            margin-bottom: 0px;
        }
	.pre {
	    white-space: pre;
	    font-family: monospace;
	}
	.header{
	    font-weight: bold;
	}
        .newpage {
            page-break-before: always;
        }
        .invisible {
            text-decoration: none;
            color: white;
        }
        a.selflink {
          color: black;
          text-decoration: none;
        }
        @media print {
            body {
                font-family: monospace;
                font-size: 10.5pt;
            }
            h1, h2, h3, h4, h5, h6 {
                font-size: 1em;
            }
        
            a:link, a:visited {
                color: inherit;
                text-decoration: none;
            }
            .noprint {
                display: none;
            }
        }
	@media screen {
	    .grey, .grey a:link, .grey a:visited {
		color: #777;
	    }
            .docinfo {
                background-color: #EEE;
            }
            .top {
                border-top: 7px solid #EEE;
            }
            .bgwhite  { background-color: white; }
            .bgred    { background-color: #F44; }
            .bggrey   { background-color: #666; }
            .bgbrown  { background-color: #840; }            
            .bgorange { background-color: #FA0; }
            .bgyellow { background-color: #EE0; }
            .bgmagenta{ background-color: #F4F; }
            .bgblue   { background-color: #66F; }
            .bgcyan   { background-color: #4DD; }
            .bggreen  { background-color: #4F4; }

            .legend   { font-size: 90%; }
            .cplate   { font-size: 70%; border: solid grey 1px; }
	}
    </style>
    <!--[if IE]>
    <style>
    body {
       font-size: 13px;
       margin: 10px 10px;
    }
    </style>
    <![endif]-->

    <script type="text/javascript"><!--
    function addHeaderTags() {
	var spans = document.getElementsByTagName("span");
	for (var i=0; i < spans.length; i++) {
	    var elem = spans[i];
	    if (elem) {
		var level = elem.getAttribute("class");
                if (level == "h1" || level == "h2" || level == "h3" || level == "h4" || level == "h5" || level == "h6") {
                    elem.innerHTML = "<"+level+">"+elem.innerHTML+"</"+level+">";		
                }
	    }
	}
    }
    var legend_html = "Colour legend:<br />      <table>         <tr><td>Unknown:</td>                   <td><span class='cplate bgwhite'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft:</td>                     <td><span class='cplate bgred'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Informational:</td>             <td><span class='cplate bgorange'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Experimental:</td>              <td><span class='cplate bgyellow'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Best Common Practice:</td>      <td><span class='cplate bgmagenta'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Proposed Standard:</td>         <td><span class='cplate bgblue'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft Standard (old designation):</td> <td><span class='cplate bgcyan'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Internet Standard:</td>         <td><span class='cplate bggreen'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Historic:</td>                  <td><span class='cplate bggrey'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Obsolete:</td>                  <td><span class='cplate bgbrown'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>     </table>";
    function showElem(id) {
        var elem = document.getElementById(id);
        elem.innerHTML = eval(id+"_html");
        elem.style.visibility='visible';
    }
    function hideElem(id) {
        var elem = document.getElementById(id);
        elem.style.visibility='hidden';        
        elem.innerHTML = "";
    }
    // -->
    </script>
</head>
<body onload="addHeaderTags()">
   <div style="height: 13px;">
      <div class="pre noprint docinfo bgcyan" onclick="showElem('legend');" onmouseout="hideElem('legend')" onmouseover="this.style.cursor='pointer';" style="height: 6px; position: absolute;" title="Click for colour legend.">                                                                        </div>
      <div class="docinfo noprint pre legend" id="legend" onmouseout="hideElem('legend');" onmouseover="showElem('legend');" style="position:absolute; top: 4px; left: 4ex; visibility:hidden; background-color: white; padding: 4px 9px 5px 7px; border: solid #345 1px; ">
      </div>
   </div>
<span class="pre noprint docinfo top">[<a href="index.html" title="Document search and retrieval page">Docs</a>] [<a href="http://tools.ietf.org/rfc/rfc4862.txt" title="Plaintext version of this document">txt</a>|<a href="http://tools.ietf.org/pdf/rfc4862" title="PDF version of this document">pdf</a>] [<a href="http://tools.ietf.org/html/draft-ietf-ipv6-rfc2462bis" title="draft-ietf-ipv6-rfc2462bis">draft-ietf-ipv6-r...</a>] [<a href="http://tools.ietf.org/rfcdiff?difftype=--hwdiff&amp;url2=rfc4862" title="Inline diff (wdiff)">Diff1</a>] [<a href="http://tools.ietf.org/rfcdiff?url2=rfc4862" title="Side-by-side diff">Diff2</a>]                 </span><br/>
<span class="pre noprint docinfo">                                                                        </span><br/>
<span class="pre noprint docinfo">                                                          DRAFT STANDARD</span><br/>
<span class="pre noprint docinfo">                                                                        </span><br/>
<pre>Network Working Group                                         S. Thomson
Request for Comments: 4862                                         Cisco
Obsoletes: <a href="rfc2462.html">2462</a>                                                T. Narten
Category: Standards Track                                            IBM
                                                               T. Jinmei
                                                                 Toshiba
                                                          September 2007


                <span class="h1">IPv6 Stateless Address Autoconfiguration</span>

Status of This Memo

   This document specifies an Internet standards track protocol for the
   Internet community, and requests discussion and suggestions for
   improvements.  Please refer to the current edition of the "Internet
   Official Protocol Standards" (STD 1) for the standardization state
   and status of this protocol.  Distribution of this memo is unlimited.

Abstract

   This document specifies the steps a host takes in deciding how to
   autoconfigure its interfaces in IP version 6.  The autoconfiguration
   process includes generating a link-local address, generating global
   addresses via stateless address autoconfiguration, and the Duplicate
   Address Detection procedure to verify the uniqueness of the addresses
   on a link.
























<span class="grey">Thomson, et al.             Standards Track                     [Page 1]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-2" id="page-2" name="page-2"> </a>
<span class="grey"><a href="rfc4862.html">RFC 4862</a>        IPv6 Stateless Address Autoconfiguration  September 2007</span>


Table of Contents

   <a href="#section-1">1</a>.  Introduction . . . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-3">3</a>
   <a href="#section-2">2</a>.  Terminology  . . . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-4">4</a>
     <a href="#section-2.1">2.1</a>.  Requirements . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-7">7</a>
   <a href="#section-3">3</a>.  Design Goals . . . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-7">7</a>
   <a href="#section-4">4</a>.  Protocol Overview  . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-8">8</a>
     <a href="#section-4.1">4.1</a>.  Site Renumbering . . . . . . . . . . . . . . . . . . . . .  <a href="#page-9">9</a>
   <a href="#section-5">5</a>.  Protocol Specification . . . . . . . . . . . . . . . . . . . . <a href="#page-10">10</a>
     <a href="#section-5.1">5.1</a>.  Node Configuration Variables . . . . . . . . . . . . . . . <a href="#page-10">10</a>
     <a href="#section-5.2">5.2</a>.  Autoconfiguration-Related Structures . . . . . . . . . . . <a href="#page-11">11</a>
     <a href="#section-5.3">5.3</a>.  Creation of Link-Local Addresses . . . . . . . . . . . . . <a href="#page-11">11</a>
     <a href="#section-5.4">5.4</a>.  Duplicate Address Detection  . . . . . . . . . . . . . . . <a href="#page-12">12</a>
       <a href="#section-5.4.1">5.4.1</a>.  Message Validation . . . . . . . . . . . . . . . . . . <a href="#page-14">14</a>
       <a href="#section-5.4.2">5.4.2</a>.  Sending Neighbor Solicitation Messages . . . . . . . . <a href="#page-14">14</a>
       <a href="#section-5.4.3">5.4.3</a>.  Receiving Neighbor Solicitation Messages . . . . . . . <a href="#page-15">15</a>
       <a href="#section-5.4.4">5.4.4</a>.  Receiving Neighbor Advertisement Messages  . . . . . . <a href="#page-16">16</a>
       <a href="#section-5.4.5">5.4.5</a>.  When Duplicate Address Detection Fails . . . . . . . . <a href="#page-17">17</a>
     <a href="#section-5.5">5.5</a>.  Creation of Global Addresses . . . . . . . . . . . . . . . <a href="#page-17">17</a>
       <a href="#section-5.5.1">5.5.1</a>.  Soliciting Router Advertisements . . . . . . . . . . . <a href="#page-18">18</a>
       <a href="#section-5.5.2">5.5.2</a>.  Absence of Router Advertisements . . . . . . . . . . . <a href="#page-18">18</a>
       <a href="#section-5.5.3">5.5.3</a>.  Router Advertisement Processing  . . . . . . . . . . . <a href="#page-18">18</a>
       <a href="#section-5.5.4">5.5.4</a>.  Address Lifetime Expiry  . . . . . . . . . . . . . . . <a href="#page-20">20</a>
     <a href="#section-5.6">5.6</a>.  Configuration Consistency  . . . . . . . . . . . . . . . . <a href="#page-21">21</a>
     <a href="#section-5.7">5.7</a>.  Retaining Configured Addresses for Stability . . . . . . . <a href="#page-22">22</a>
   <a href="#section-6">6</a>.  Security Considerations  . . . . . . . . . . . . . . . . . . . <a href="#page-22">22</a>
   <a href="#section-7">7</a>.  Acknowledgements . . . . . . . . . . . . . . . . . . . . . . . <a href="#page-23">23</a>
   <a href="#section-8">8</a>.  References . . . . . . . . . . . . . . . . . . . . . . . . . . <a href="#page-23">23</a>
     <a href="#section-8.1">8.1</a>.  Normative References . . . . . . . . . . . . . . . . . . . <a href="#page-23">23</a>
     <a href="#section-8.2">8.2</a>.  Informative References . . . . . . . . . . . . . . . . . . <a href="#page-23">23</a>
   <a href="#appendix-A">Appendix A</a>.  Loopback Suppression and Duplicate Address
                Detection . . . . . . . . . . . . . . . . . . . . . . <a href="#page-25">25</a>
   <a href="#appendix-B">Appendix B</a>.  Changes since <a href="rfc1971.html">RFC 1971</a>  . . . . . . . . . . . . . . . <a href="#page-26">26</a>
   <a href="#appendix-C">Appendix C</a>.  Changes since <a href="rfc2462.html">RFC 2462</a>  . . . . . . . . . . . . . . . <a href="#page-27">27</a>

















<span class="grey">Thomson, et al.             Standards Track                     [Page 2]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-3" id="page-3" name="page-3"> </a>
<span class="grey"><a href="rfc4862.html">RFC 4862</a>        IPv6 Stateless Address Autoconfiguration  September 2007</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/1.%20%20Introduction"></a><a class="selflink" href="#section-1" name="section-1">1</a>.  Introduction</span>

   This document specifies the steps a host takes in deciding how to
   autoconfigure its interfaces in IP version 6 (IPv6).  The
   autoconfiguration process includes generating a link-local address,
   generating global addresses via stateless address autoconfiguration,
   and the Duplicate Address Detection procedure to verify the
   uniqueness of the addresses on a link.

   The IPv6 stateless autoconfiguration mechanism requires no manual
   configuration of hosts, minimal (if any) configuration of routers,
   and no additional servers.  The stateless mechanism allows a host to
   generate its own addresses using a combination of locally available
   information and information advertised by routers.  Routers advertise
   prefixes that identify the subnet(s) associated with a link, while
   hosts generate an "interface identifier" that uniquely identifies an
   interface on a subnet.  An address is formed by combining the two.
   In the absence of routers, a host can only generate link-local
   addresses.  However, link-local addresses are sufficient for allowing
   communication among nodes attached to the same link.

   The stateless approach is used when a site is not particularly
   concerned with the exact addresses hosts use, so long as they are
   unique and properly routable.  On the other hand, Dynamic Host
   Configuration Protocol for IPv6 (DHCPv6) [<a href="rfc3315.html" title='"Dynamic Host Configuration Protocol for IPv6 (DHCPv6)"'>RFC3315</a>] is used when a
   site requires tighter control over exact address assignments.  Both
   stateless address autoconfiguration and DHCPv6 may be used
   simultaneously.

   IPv6 addresses are leased to an interface for a fixed (possibly
   infinite) length of time.  Each address has an associated lifetime
   that indicates how long the address is bound to an interface.  When a
   lifetime expires, the binding (and address) become invalid and the
   address may be reassigned to another interface elsewhere in the
   Internet.  To handle the expiration of address bindings gracefully,
   an address goes through two distinct phases while assigned to an
   interface.  Initially, an address is "preferred", meaning that its
   use in arbitrary communication is unrestricted.  Later, an address
   becomes "deprecated" in anticipation that its current interface
   binding will become invalid.  While an address is in a deprecated
   state, its use is discouraged, but not strictly forbidden.  New
   communication (e.g., the opening of a new TCP connection) should use
   a preferred address when possible.  A deprecated address should be
   used only by applications that have been using it and would have
   difficulty switching to another address without a service disruption.






<span class="grey">Thomson, et al.             Standards Track                     [Page 3]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-4" id="page-4" name="page-4"> </a>
<span class="grey"><a href="rfc4862.html">RFC 4862</a>        IPv6 Stateless Address Autoconfiguration  September 2007</span>


   To ensure that all configured addresses are likely to be unique on a
   given link, nodes run a "duplicate address detection" algorithm on
   addresses before assigning them to an interface.  The Duplicate
   Address Detection algorithm is performed on all addresses,
   independently of whether they are obtained via stateless
   autoconfiguration or DHCPv6.  This document defines the Duplicate
   Address Detection algorithm.

   The autoconfiguration process specified in this document applies only
   to hosts and not routers.  Since host autoconfiguration uses
   information advertised by routers, routers will need to be configured
   by some other means.  However, it is expected that routers will
   generate link-local addresses using the mechanism described in this
   document.  In addition, routers are expected to successfully pass the
   Duplicate Address Detection procedure described in this document on
   all addresses prior to assigning them to an interface.

   <a href="#section-2">Section 2</a> provides definitions for terminology used throughout this
   document.  <a href="#section-3">Section 3</a> describes the design goals that lead to the
   current autoconfiguration procedure.  <a href="#section-4">Section 4</a> provides an overview
   of the protocol, while <a href="#section-5">Section 5</a> describes the protocol in detail.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/2.%20%20Terminology"></a><a class="selflink" href="#section-2" name="section-2">2</a>.  Terminology</span>

   IP -  Internet Protocol Version 6.  The terms IPv4 and IPv6 are used
      only in contexts where necessary to avoid ambiguity.

   node -  a device that implements IP.

   router -  a node that forwards IP packets not explicitly addressed to
      itself.

   host -  any node that is not a router.

   upper layer -  a protocol layer immediately above IP.  Examples are
      transport protocols such as TCP and UDP, control protocols such as
      ICMP, routing protocols such as OSPF, and Internet or lower-layer
      protocols being "tunneled" over (i.e., encapsulated in) IP such as
      IPX, AppleTalk, or IP itself.

   link -  a communication facility or medium over which nodes can
      communicate at the link layer, i.e., the layer immediately below
      IP.  Examples are Ethernets (simple or bridged); PPP links; X.25,
      Frame Relay, or ATM networks; and Internet (or higher) layer
      "tunnels", such as tunnels over IPv4 or IPv6 itself.  The protocol
      described in this document will be used on all types of links
      unless specified otherwise in the link-type-specific document
      describing how to operate IP on the link in line with [<a href="rfc4861.html" title='"Neighbor Discovery for IP version 6 (IPv6)"'>RFC4861</a>].



<span class="grey">Thomson, et al.             Standards Track                     [Page 4]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-5" id="page-5" name="page-5"> </a>
<span class="grey"><a href="rfc4862.html">RFC 4862</a>        IPv6 Stateless Address Autoconfiguration  September 2007</span>


   interface -  a node's attachment to a link.

   packet -  an IP header plus payload.

   address -  an IP-layer identifier for an interface or a set of
      interfaces.

   unicast address -  an identifier for a single interface.  A packet
      sent to a unicast address is delivered to the interface identified
      by that address.

   multicast address -  an identifier for a set of interfaces (typically
      belonging to different nodes).  A packet sent to a multicast
      address is delivered to all interfaces identified by that address.

   anycast address -  an identifier for a set of interfaces (typically
      belonging to different nodes).  A packet sent to an anycast
      address is delivered to one of the interfaces identified by that
      address (the "nearest" one, according to the routing protocol's
      measure of distance).  See [<a href="rfc4291.html" title='"IP Version 6 Addressing Architecture"'>RFC4291</a>].

   solicited-node multicast address -  a multicast address to which
      Neighbor Solicitation messages are sent.  The algorithm for
      computing the address is given in [<a href="rfc4291.html" title='"IP Version 6 Addressing Architecture"'>RFC4291</a>].

   link-layer address -  a link-layer identifier for an interface.
      Examples include IEEE 802 addresses for Ethernet links and E.164
      addresses for Integrated Services Digital Network (ISDN) links.

   link-local address -  an address having link-only scope that can be
      used to reach neighboring nodes attached to the same link.  All
      interfaces have a link-local unicast address.

   global address -  an address with unlimited scope.

   communication -  any packet exchange among nodes that requires that
      the address of each node used in the exchange remain the same for
      the duration of the packet exchange.  Examples are a TCP
      connection or a UDP request-response.

   tentative address -  an address whose uniqueness on a link is being
      verified, prior to its assignment to an interface.  A tentative
      address is not considered assigned to an interface in the usual
      sense.  An interface discards received packets addressed to a
      tentative address, but accepts Neighbor Discovery packets related
      to Duplicate Address Detection for the tentative address.





<span class="grey">Thomson, et al.             Standards Track                     [Page 5]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-6" id="page-6" name="page-6"> </a>
<span class="grey"><a href="rfc4862.html">RFC 4862</a>        IPv6 Stateless Address Autoconfiguration  September 2007</span>


   preferred address -  an address assigned to an interface whose use by
      upper-layer protocols is unrestricted.  Preferred addresses may be
      used as the source (or destination) address of packets sent from
      (or to) the interface.

   deprecated address -  An address assigned to an interface whose use
      is discouraged, but not forbidden.  A deprecated address should no
      longer be used as a source address in new communications, but
      packets sent from or to deprecated addresses are delivered as
      expected.  A deprecated address may continue to be used as a
      source address in communications where switching to a preferred
      address causes hardship to a specific upper-layer activity (e.g.,
      an existing TCP connection).

   valid address -  a preferred or deprecated address.  A valid address
      may appear as the source or destination address of a packet, and
      the Internet routing system is expected to deliver packets sent to
      a valid address to their intended recipients.

   invalid address -  an address that is not assigned to any interface.
      A valid address becomes invalid when its valid lifetime expires.
      Invalid addresses should not appear as the destination or source
      address of a packet.  In the former case, the Internet routing
      system will be unable to deliver the packet; in the latter case,
      the recipient of the packet will be unable to respond to it.

   preferred lifetime -  the length of time that a valid address is
      preferred (i.e., the time until deprecation).  When the preferred
      lifetime expires, the address becomes deprecated.

   valid lifetime -  the length of time an address remains in the valid
      state (i.e., the time until invalidation).  The valid lifetime
      must be greater than or equal to the preferred lifetime.  When the
      valid lifetime expires, the address becomes invalid.

   interface identifier -  a link-dependent identifier for an interface
      that is (at least) unique per link [<a href="rfc4291.html" title='"IP Version 6 Addressing Architecture"'>RFC4291</a>].  Stateless address
      autoconfiguration combines an interface identifier with a prefix
      to form an address.  From address autoconfiguration's perspective,
      an interface identifier is a bit string of known length.  The
      exact length of an interface identifier and the way it is created
      is defined in a separate link-type specific document that covers
      issues related to the transmission of IP over a particular link
      type (e.g., [<a href="rfc2464.html" title='"Transmission of IPv6 Packets over Ethernet Networks"'>RFC2464</a>]).  Note that the address architecture
      [<a href="rfc4291.html" title='"IP Version 6 Addressing Architecture"'>RFC4291</a>] also defines the length of the interface identifiers for
      some set of addresses, but the two sets of definitions must be
      consistent.  In many cases, the identifier will be derived from
      the interface's link-layer address.



<span class="grey">Thomson, et al.             Standards Track                     [Page 6]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-7" id="page-7" name="page-7"> </a>
<span class="grey"><a href="rfc4862.html">RFC 4862</a>        IPv6 Stateless Address Autoconfiguration  September 2007</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/2.1.%20%20Requirements"></a><a class="selflink" href="#section-2.1" name="section-2.1">2.1</a>.  Requirements</span>

   The keywords MUST, MUST NOT, REQUIRED, SHALL, SHALL NOT, SHOULD,
   SHOULD NOT, RECOMMENDED, MAY, and OPTIONAL, when they appear in this
   document, are to be interpreted as described in [<a href="rfc2119.html" title='"Key words for use in RFCs to Indicate Requirement Levels"'>RFC2119</a>].

   Note that this document intentionally limits the use of the keywords
   to the protocol specification (<a href="#section-5">Section 5</a>).

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/3.%20%20Design%20Goals"></a><a class="selflink" href="#section-3" name="section-3">3</a>.  Design Goals</span>

   Stateless autoconfiguration is designed with the following goals in
   mind:

   o  Manual configuration of individual machines before connecting them
      to the network should not be required.  Consequently, a mechanism
      is needed that allows a host to obtain or create unique addresses
      for each of its interfaces.  Address autoconfiguration assumes
      that each interface can provide a unique identifier for that
      interface (i.e., an "interface identifier").  In the simplest
      case, an interface identifier consists of the interface's link-
      layer address.  An interface identifier can be combined with a
      prefix to form an address.

   o  Small sites consisting of a set of machines attached to a single
      link should not require the presence of a DHCPv6 server or router
      as a prerequisite for communicating.  Plug-and-play communication
      is achieved through the use of link-local addresses.  Link-local
      addresses have a well-known prefix that identifies the (single)
      shared link to which a set of nodes attach.  A host forms a link-
      local address by appending an interface identifier to the link-
      local prefix.

   o  A large site with multiple networks and routers should not require
      the presence of a DHCPv6 server for address configuration.  In
      order to generate global addresses, hosts must determine the
      prefixes that identify the subnets to which they attach.  Routers
      generate periodic Router Advertisements that include options
      listing the set of active prefixes on a link.

   o  Address configuration should facilitate the graceful renumbering
      of a site's machines.  For example, a site may wish to renumber
      all of its nodes when it switches to a new network service
      provider.  Renumbering is achieved through the leasing of
      addresses to interfaces and the assignment of multiple addresses
      to the same interface.  Lease lifetimes provide the mechanism
      through which a site phases out old prefixes.  The assignment of
      multiple addresses to an interface provides for a transition



<span class="grey">Thomson, et al.             Standards Track                     [Page 7]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-8" id="page-8" name="page-8"> </a>
<span class="grey"><a href="rfc4862.html">RFC 4862</a>        IPv6 Stateless Address Autoconfiguration  September 2007</span>


      period during which both a new address and the one being phased
      out work simultaneously.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/4.%20%20Protocol%20Overview"></a><a class="selflink" href="#section-4" name="section-4">4</a>.  Protocol Overview</span>

   This section provides an overview of the typical steps that take
   place when an interface autoconfigures itself.  Autoconfiguration is
   performed only on multicast-capable links and begins when a
   multicast-capable interface is enabled, e.g., during system startup.
   Nodes (both hosts and routers) begin the autoconfiguration process by
   generating a link-local address for the interface.  A link-local
   address is formed by appending an identifier of the interface to the
   well-known link-local prefix [<a href="rfc4291.html" title='"IP Version 6 Addressing Architecture"'>RFC4291</a>].

   Before the link-local address can be assigned to an interface and
   used, however, a node must attempt to verify that this "tentative"
   address is not already in use by another node on the link.
   Specifically, it sends a Neighbor Solicitation message containing the
   tentative address as the target.  If another node is already using
   that address, it will return a Neighbor Advertisement saying so.  If
   another node is also attempting to use the same address, it will send
   a Neighbor Solicitation for the target as well.  The exact number of
   times the Neighbor Solicitation is (re)transmitted and the delay time
   between consecutive solicitations is link-specific and may be set by
   system management.

   If a node determines that its tentative link-local address is not
   unique, autoconfiguration stops and manual configuration of the
   interface is required.  To simplify recovery in this case, it should
   be possible for an administrator to supply an alternate interface
   identifier that overrides the default identifier in such a way that
   the autoconfiguration mechanism can then be applied using the new
   (presumably unique) interface identifier.  Alternatively, link-local
   and other addresses will need to be configured manually.

   Once a node ascertains that its tentative link-local address is
   unique, it assigns the address to the interface.  At this point, the
   node has IP-level connectivity with neighboring nodes.  The remaining
   autoconfiguration steps are performed only by hosts; the
   (auto)configuration of routers is beyond the scope of this document.

   The next phase of autoconfiguration involves obtaining a Router
   Advertisement or determining that no routers are present.  If routers
   are present, they will send Router Advertisements that specify what
   sort of autoconfiguration a host can do.  Note that the DHCPv6
   service for address configuration may still be available even if no
   routers are present.




<span class="grey">Thomson, et al.             Standards Track                     [Page 8]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-9" id="page-9" name="page-9"> </a>
<span class="grey"><a href="rfc4862.html">RFC 4862</a>        IPv6 Stateless Address Autoconfiguration  September 2007</span>


   Routers send Router Advertisements periodically, but the delay
   between successive advertisements will generally be longer than a
   host performing autoconfiguration will want to wait [<a href="rfc4861.html" title='"Neighbor Discovery for IP version 6 (IPv6)"'>RFC4861</a>].  To
   obtain an advertisement quickly, a host sends one or more Router
   Solicitations to the all-routers multicast group.

   Router Advertisements also contain zero or more Prefix Information
   options that contain information used by stateless address
   autoconfiguration to generate global addresses.  It should be noted
   that a host may use both stateless address autoconfiguration and
   DHCPv6 simultaneously.  One Prefix Information option field, the
   "autonomous address-configuration flag", indicates whether or not the
   option even applies to stateless autoconfiguration.  If it does,
   additional option fields contain a subnet prefix, together with
   lifetime values, indicating how long addresses created from the
   prefix remain preferred and valid.

   Because routers generate Router Advertisements periodically, hosts
   will continually receive new advertisements.  Hosts process the
   information contained in each advertisement as described above,
   adding to and refreshing information received in previous
   advertisements.

   By default, all addresses should be tested for uniqueness prior to
   their assignment to an interface for safety.  The test should
   individually be performed on all addresses obtained manually, via
   stateless address autoconfiguration, or via DHCPv6.  To accommodate
   sites that believe the overhead of performing Duplicate Address
   Detection outweighs its benefits, the use of Duplicate Address
   Detection can be disabled through the administrative setting of a
   per-interface configuration flag.

   To speed the autoconfiguration process, a host may generate its link-
   local address (and verify its uniqueness) in parallel with waiting
   for a Router Advertisement.  Because a router may delay responding to
   a Router Solicitation for a few seconds, the total time needed to
   complete autoconfiguration can be significantly longer if the two
   steps are done serially.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.1.%20%20Site%20Renumbering"></a><a class="selflink" href="#section-4.1" name="section-4.1">4.1</a>.  Site Renumbering</span>

   Address leasing facilitates site renumbering by providing a mechanism
   to time-out addresses assigned to interfaces in hosts.  At present,
   upper-layer protocols such as TCP provide no support for changing
   end-point addresses while a connection is open.  If an end-point
   address becomes invalid, existing connections break and all





<span class="grey">Thomson, et al.             Standards Track                     [Page 9]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-10" id="page-10" name="page-10"> </a>
<span class="grey"><a href="rfc4862.html">RFC 4862</a>        IPv6 Stateless Address Autoconfiguration  September 2007</span>


   communication to the invalid address fails.  Even when applications
   use UDP as a transport protocol, addresses must generally remain the
   same during a packet exchange.

   Dividing valid addresses into preferred and deprecated categories
   provides a way of indicating to upper layers that a valid address may
   become invalid shortly and that future communication using the
   address will fail, should the address's valid lifetime expire before
   communication ends.  To avoid this scenario, higher layers should use
   a preferred address (assuming one of sufficient scope exists) to
   increase the likelihood that an address will remain valid for the
   duration of the communication.  It is up to system administrators to
   set appropriate prefix lifetimes in order to minimize the impact of
   failed communication when renumbering takes place.  The deprecation
   period should be long enough that most, if not all, communications
   are using the new address at the time an address becomes invalid.

   The IP layer is expected to provide a means for upper layers
   (including applications) to select the most appropriate source
   address given a particular destination and possibly other
   constraints.  An application may choose to select the source address
   itself before starting a new communication or may leave the address
   unspecified, in which case, the upper networking layers will use the
   mechanism provided by the IP layer to choose a suitable address on
   the application's behalf.

   Detailed address selection rules are beyond the scope of this
   document and are described in [<a href="rfc3484.html" title='"Default Address Selection for Internet Protocol version 6 (IPv6)"'>RFC3484</a>].

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/5.%20%20Protocol%20Specification"></a><a class="selflink" href="#section-5" name="section-5">5</a>.  Protocol Specification</span>

   Autoconfiguration is performed on a per-interface basis on multicast-
   capable interfaces.  For multihomed hosts, autoconfiguration is
   performed independently on each interface.  Autoconfiguration applies
   primarily to hosts, with two exceptions.  Routers are expected to
   generate a link-local address using the procedure outlined below.  In
   addition, routers perform Duplicate Address Detection on all
   addresses prior to assigning them to an interface.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.1.%20%20Node%20Configuration%20Variables"></a><a class="selflink" href="#section-5.1" name="section-5.1">5.1</a>.  Node Configuration Variables</span>

   A node MUST allow the following autoconfiguration-related variable to
   be configured by system management for each multicast-capable
   interface:







<span class="grey">Thomson, et al.             Standards Track                    [Page 10]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-11" id="page-11" name="page-11"> </a>
<span class="grey"><a href="rfc4862.html">RFC 4862</a>        IPv6 Stateless Address Autoconfiguration  September 2007</span>


   DupAddrDetectTransmits  The number of consecutive Neighbor
      Solicitation messages sent while performing Duplicate Address
      Detection on a tentative address.  A value of zero indicates that
      Duplicate Address Detection is not performed on tentative
      addresses.  A value of one indicates a single transmission with no
      follow-up retransmissions.

      Default: 1, but may be overridden by a link-type specific value in
      the document that covers issues related to the transmission of IP
      over a particular link type (e.g., [<a href="rfc2464.html" title='"Transmission of IPv6 Packets over Ethernet Networks"'>RFC2464</a>]).

      Autoconfiguration also assumes the presence of the variable
      RetransTimer as defined in [<a href="rfc4861.html" title='"Neighbor Discovery for IP version 6 (IPv6)"'>RFC4861</a>].  For autoconfiguration
      purposes, RetransTimer specifies the delay between consecutive
      Neighbor Solicitation transmissions performed during Duplicate
      Address Detection (if DupAddrDetectTransmits is greater than 1),
      as well as the time a node waits after sending the last Neighbor
      Solicitation before ending the Duplicate Address Detection
      process.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.2.%20%20Autoconfiguration-Related%20Structures"></a><a class="selflink" href="#section-5.2" name="section-5.2">5.2</a>.  Autoconfiguration-Related Structures</span>

   Beyond the formation of a link-local address and use of Duplicate
   Address Detection, how routers (auto)configure their interfaces is
   beyond the scope of this document.

   A host maintains a list of addresses together with their
   corresponding lifetimes.  The address list contains both
   autoconfigured addresses and those configured manually.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.3.%20%20Creation%20of%20Link-Local%20Addresses"></a><a class="selflink" href="#section-5.3" name="section-5.3">5.3</a>.  Creation of Link-Local Addresses</span>

   A node forms a link-local address whenever an interface becomes
   enabled.  An interface may become enabled after any of the following
   events:

   -  The interface is initialized at system startup time.

   -  The interface is reinitialized after a temporary interface failure
      or after being temporarily disabled by system management.

   -  The interface attaches to a link for the first time.  This
      includes the case where the attached link is dynamically changed
      due to a change of the access point of wireless networks.







<span class="grey">Thomson, et al.             Standards Track                    [Page 11]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-12" id="page-12" name="page-12"> </a>
<span class="grey"><a href="rfc4862.html">RFC 4862</a>        IPv6 Stateless Address Autoconfiguration  September 2007</span>


   -  The interface becomes enabled by system management after having
      been administratively disabled.

   A link-local address is formed by combining the well-known link-local
   prefix FE80::0 [<a href="rfc4291.html" title='"IP Version 6 Addressing Architecture"'>RFC4291</a>] (of appropriate length) with an interface
   identifier as follows:

   1.  The left-most 'prefix length' bits of the address are those of
       the link-local prefix.

   2.  The bits in the address to the right of the link-local prefix are
       set to all zeroes.

   3.  If the length of the interface identifier is N bits, the right-
       most N bits of the address are replaced by the interface
       identifier.

   If the sum of the link-local prefix length and N is larger than 128,
   autoconfiguration fails and manual configuration is required.  The
   length of the interface identifier is defined in a separate link-
   type-specific document, which should also be consistent with the
   address architecture [<a href="rfc4291.html" title='"IP Version 6 Addressing Architecture"'>RFC4291</a>] (see <a href="#section-2">Section 2</a>).  These documents will
   carefully define the length so that link-local addresses can be
   autoconfigured on the link.

   A link-local address has an infinite preferred and valid lifetime; it
   is never timed out.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.4.%20%20Duplicate%20Address%20Detection"></a><a class="selflink" href="#section-5.4" name="section-5.4">5.4</a>.  Duplicate Address Detection</span>

   Duplicate Address Detection MUST be performed on all unicast
   addresses prior to assigning them to an interface, regardless of
   whether they are obtained through stateless autoconfiguration,
   DHCPv6, or manual configuration, with the following exceptions:

   -  An interface whose DupAddrDetectTransmits variable is set to zero
      does not perform Duplicate Address Detection.

   -  Duplicate Address Detection MUST NOT be performed on anycast
      addresses (note that anycast addresses cannot syntactically be
      distinguished from unicast addresses).

   -  Each individual unicast address SHOULD be tested for uniqueness.
      Note that there are implementations deployed that only perform
      Duplicate Address Detection for the link-local address and skip
      the test for the global address that uses the same interface
      identifier as that of the link-local address.  Whereas this
      document does not invalidate such implementations, this kind of



<span class="grey">Thomson, et al.             Standards Track                    [Page 12]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-13" id="page-13" name="page-13"> </a>
<span class="grey"><a href="rfc4862.html">RFC 4862</a>        IPv6 Stateless Address Autoconfiguration  September 2007</span>


      "optimization" is NOT RECOMMENDED, and new implementations MUST
      NOT do that optimization.  This optimization came from the
      assumption that all of an interface's addresses are generated from
      the same identifier.  However, the assumption does actually not
      stand; new types of addresses have been introduced where the
      interface identifiers are not necessarily the same for all unicast
      addresses on a single interface [<a href="rfc4941.html" title='"Privacy Extensions for Stateless Address Autoconfiguration in IPv6"'>RFC4941</a>] [<a href="rfc3972.html" title='"Cryptographically Generated Addresses (CGA)"'>RFC3972</a>].  Requiring
      that Duplicate Address Detection be performed for all unicast
      addresses will make the algorithm robust for the current and
      future special interface identifiers.

   The procedure for detecting duplicate addresses uses Neighbor
   Solicitation and Advertisement messages as described below.  If a
   duplicate address is discovered during the procedure, the address
   cannot be assigned to the interface.  If the address is derived from
   an interface identifier, a new identifier will need to be assigned to
   the interface, or all IP addresses for the interface will need to be
   manually configured.  Note that the method for detecting duplicates
   is not completely reliable, and it is possible that duplicate
   addresses will still exist (e.g., if the link was partitioned while
   Duplicate Address Detection was performed).

   An address on which the Duplicate Address Detection procedure is
   applied is said to be tentative until the procedure has completed
   successfully.  A tentative address is not considered "assigned to an
   interface" in the traditional sense.  That is, the interface must
   accept Neighbor Solicitation and Advertisement messages containing
   the tentative address in the Target Address field, but processes such
   packets differently from those whose Target Address matches an
   address assigned to the interface.  Other packets addressed to the
   tentative address should be silently discarded.  Note that the "other
   packets" include Neighbor Solicitation and Advertisement messages
   that have the tentative (i.e., unicast) address as the IP destination
   address and contain the tentative address in the Target Address
   field.  Such a case should not happen in normal operation, though,
   since these messages are multicasted in the Duplicate Address
   Detection procedure.

   It should also be noted that Duplicate Address Detection must be
   performed prior to assigning an address to an interface in order to
   prevent multiple nodes from using the same address simultaneously.
   If a node begins using an address in parallel with Duplicate Address
   Detection, and another node is already using the address, the node
   performing Duplicate Address Detection will erroneously process
   traffic intended for the other node, resulting in such possible
   negative consequences as the resetting of open TCP connections.





<span class="grey">Thomson, et al.             Standards Track                    [Page 13]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-14" id="page-14" name="page-14"> </a>
<span class="grey"><a href="rfc4862.html">RFC 4862</a>        IPv6 Stateless Address Autoconfiguration  September 2007</span>


   The following subsections describe specific tests a node performs to
   verify an address's uniqueness.  An address is considered unique if
   none of the tests indicate the presence of a duplicate address within
   RetransTimer milliseconds after having sent DupAddrDetectTransmits
   Neighbor Solicitations.  Once an address is determined to be unique,
   it may be assigned to an interface.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/5.4.1.%20%20Message%20Validation"></a><a class="selflink" href="#section-5.4.1" name="section-5.4.1">5.4.1</a>.  Message Validation</span>

   A node MUST silently discard any Neighbor Solicitation or
   Advertisement message that does not pass the validity checks
   specified in [<a href="rfc4861.html" title='"Neighbor Discovery for IP version 6 (IPv6)"'>RFC4861</a>].  A Neighbor Solicitation or Advertisement
   message that passes these validity checks is called a valid
   solicitation or valid advertisement, respectively.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/5.4.2.%20%20Sending%20Neighbor%20Solicitation%20Messages"></a><a class="selflink" href="#section-5.4.2" name="section-5.4.2">5.4.2</a>.  Sending Neighbor Solicitation Messages</span>

   Before sending a Neighbor Solicitation, an interface MUST join the
   all-nodes multicast address and the solicited-node multicast address
   of the tentative address.  The former ensures that the node receives
   Neighbor Advertisements from other nodes already using the address;
   the latter ensures that two nodes attempting to use the same address
   simultaneously should detect each other's presence.

   To check an address, a node sends DupAddrDetectTransmits Neighbor
   Solicitations, each separated by RetransTimer milliseconds.  The
   solicitation's Target Address is set to the address being checked,
   the IP source is set to the unspecified address, and the IP
   destination is set to the solicited-node multicast address of the
   target address.

   If the Neighbor Solicitation is going to be the first message sent
   from an interface after interface (re)initialization, the node SHOULD
   delay joining the solicited-node multicast address by a random delay
   between 0 and MAX_RTR_SOLICITATION_DELAY as specified in [<a href="rfc4861.html" title='"Neighbor Discovery for IP version 6 (IPv6)"'>RFC4861</a>].
   This serves to alleviate congestion when many nodes start up on the
   link at the same time, such as after a power failure, and may help to
   avoid race conditions when more than one node is trying to solicit
   for the same address at the same time.

   Even if the Neighbor Solicitation is not going to be the first
   message sent, the node SHOULD delay joining the solicited-node
   multicast address by a random delay between 0 and
   MAX_RTR_SOLICITATION_DELAY if the address being checked is configured
   by a router advertisement message sent to a multicast address.  The
   delay will avoid similar congestion when multiple nodes are going to
   configure addresses by receiving the same single multicast router
   advertisement.



<span class="grey">Thomson, et al.             Standards Track                    [Page 14]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-15" id="page-15" name="page-15"> </a>
<span class="grey"><a href="rfc4862.html">RFC 4862</a>        IPv6 Stateless Address Autoconfiguration  September 2007</span>


   Note that when a node joins a multicast address, it typically sends a
   Multicast Listener Discovery (MLD) report message [<a href="rfc2710.html" title='"Multicast Listener Discovery (MLD) for IPv6"'>RFC2710</a>] [<a href="rfc3810.html" title='"Multicast Listener Discovery Version 2 (MLDv2) for IPv6"'>RFC3810</a>]
   for the multicast address.  In the case of Duplicate Address
   Detection, the MLD report message is required in order to inform MLD-
   snooping switches, rather than routers, to forward multicast packets.
   In the above description, the delay for joining the multicast address
   thus means delaying transmission of the corresponding MLD report
   message.  Since the MLD specifications do not request a random delay
   to avoid race conditions, just delaying Neighbor Solicitation would
   cause congestion by the MLD report messages.  The congestion would
   then prevent the MLD-snooping switches from working correctly and, as
   a result, prevent Duplicate Address Detection from working.  The
   requirement to include the delay for the MLD report in this case
   avoids this scenario.  [<a href="rfc3590.html" title='"Source Address Selection for the Multicast Listener Discovery (MLD) Protocol"'>RFC3590</a>] also talks about some interaction
   issues between Duplicate Address Detection and MLD, and specifies
   which source address should be used for the MLD report in this case.

   In order to improve the robustness of the Duplicate Address Detection
   algorithm, an interface MUST receive and process datagrams sent to
   the all-nodes multicast address or solicited-node multicast address
   of the tentative address during the delay period.  This does not
   necessarily conflict with the requirement that joining the multicast
   group be delayed.  In fact, in some cases it is possible for a node
   to start listening to the group during the delay period before MLD
   report transmission.  It should be noted, however, that in some link-
   layer environments, particularly with MLD-snooping switches, no
   multicast reception will be available until the MLD report is sent.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/5.4.3.%20%20Receiving%20Neighbor%20Solicitation%20Messages"></a><a class="selflink" href="#section-5.4.3" name="section-5.4.3">5.4.3</a>.  Receiving Neighbor Solicitation Messages</span>

   On receipt of a valid Neighbor Solicitation message on an interface,
   node behavior depends on whether or not the target address is
   tentative.  If the target address is not tentative (i.e., it is
   assigned to the receiving interface), the solicitation is processed
   as described in [<a href="rfc4861.html" title='"Neighbor Discovery for IP version 6 (IPv6)"'>RFC4861</a>].  If the target address is tentative, and
   the source address is a unicast address, the solicitation's sender is
   performing address resolution on the target; the solicitation should
   be silently ignored.  Otherwise, processing takes place as described
   below.  In all cases, a node MUST NOT respond to a Neighbor
   Solicitation for a tentative address.

   If the source address of the Neighbor Solicitation is the unspecified
   address, the solicitation is from a node performing Duplicate Address
   Detection.  If the solicitation is from another node, the tentative
   address is a duplicate and should not be used (by either node).  If
   the solicitation is from the node itself (because the node loops back
   multicast packets), the solicitation does not indicate the presence
   of a duplicate address.



<span class="grey">Thomson, et al.             Standards Track                    [Page 15]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-16" id="page-16" name="page-16"> </a>
<span class="grey"><a href="rfc4862.html">RFC 4862</a>        IPv6 Stateless Address Autoconfiguration  September 2007</span>


   Implementer's Note: many interfaces provide a way for upper layers to
   selectively enable and disable the looping back of multicast packets.
   The details of how such a facility is implemented may prevent
   Duplicate Address Detection from working correctly.  See <a href="#appendix-A">Appendix A</a>
   for further discussion.

   The following tests identify conditions under which a tentative
   address is not unique:

   -  If a Neighbor Solicitation for a tentative address is received
      before one is sent, the tentative address is a duplicate.  This
      condition occurs when two nodes run Duplicate Address Detection
      simultaneously, but transmit initial solicitations at different
      times (e.g., by selecting different random delay values before
      joining the solicited-node multicast address and transmitting an
      initial solicitation).

   -  If the actual number of Neighbor Solicitations received exceeds
      the number expected based on the loopback semantics (e.g., the
      interface does not loop back the packet, yet one or more
      solicitations was received), the tentative address is a duplicate.
      This condition occurs when two nodes run Duplicate Address
      Detection simultaneously and transmit solicitations at roughly the
      same time.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/5.4.4.%20%20Receiving%20Neighbor%20Advertisement%20Messages"></a><a class="selflink" href="#section-5.4.4" name="section-5.4.4">5.4.4</a>.  Receiving Neighbor Advertisement Messages</span>

   On receipt of a valid Neighbor Advertisement message on an interface,
   node behavior depends on whether the target address is tentative or
   matches a unicast or anycast address assigned to the interface:

   1.  If the target address is tentative, the tentative address is not
       unique.

   2.  If the target address matches a unicast address assigned to the
       receiving interface, it would possibly indicate that the address
       is a duplicate but it has not been detected by the Duplicate
       Address Detection procedure (recall that Duplicate Address
       Detection is not completely reliable).  How to handle such a case
       is beyond the scope of this document.

   3.  Otherwise, the advertisement is processed as described in
       [<a href="rfc4861.html" title='"Neighbor Discovery for IP version 6 (IPv6)"'>RFC4861</a>].








<span class="grey">Thomson, et al.             Standards Track                    [Page 16]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-17" id="page-17" name="page-17"> </a>
<span class="grey"><a href="rfc4862.html">RFC 4862</a>        IPv6 Stateless Address Autoconfiguration  September 2007</span>


<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/5.4.5.%20%20When%20Duplicate%20Address%20Detection%20Fails"></a><a class="selflink" href="#section-5.4.5" name="section-5.4.5">5.4.5</a>.  When Duplicate Address Detection Fails</span>

   A tentative address that is determined to be a duplicate as described
   above MUST NOT be assigned to an interface, and the node SHOULD log a
   system management error.

   If the address is a link-local address formed from an interface
   identifier based on the hardware address, which is supposed to be
   uniquely assigned (e.g., EUI-64 for an Ethernet interface), IP
   operation on the interface SHOULD be disabled.  By disabling IP
   operation, the node will then:

   -  not send any IP packets from the interface,

   -  silently drop any IP packets received on the interface, and

   -  not forward any IP packets to the interface (when acting as a
      router or processing a packet with a Routing header).

   In this case, the IP address duplication probably means duplicate
   hardware addresses are in use, and trying to recover from it by
   configuring another IP address will not result in a usable network.
   In fact, it probably makes things worse by creating problems that are
   harder to diagnose than just disabling network operation on the
   interface; the user will see a partially working network where some
   things work, and other things do not.

   On the other hand, if the duplicate link-local address is not formed
   from an interface identifier based on the hardware address, which is
   supposed to be uniquely assigned, IP operation on the interface MAY
   be continued.

   Note: as specified in <a href="#section-2">Section 2</a>, "IP" means "IPv6" in the above
   description.  While the background rationale about hardware address
   is independent of particular network protocols, its effect on other
   protocols is beyond the scope of this document.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.5.%20%20Creation%20of%20Global%20Addresses"></a><a class="selflink" href="#section-5.5" name="section-5.5">5.5</a>.  Creation of Global Addresses</span>

   Global addresses are formed by appending an interface identifier to a
   prefix of appropriate length.  Prefixes are obtained from Prefix
   Information options contained in Router Advertisements.  Creation of
   global addresses as described in this section SHOULD be locally
   configurable.  However, the processing described below MUST be
   enabled by default.






<span class="grey">Thomson, et al.             Standards Track                    [Page 17]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-18" id="page-18" name="page-18"> </a>
<span class="grey"><a href="rfc4862.html">RFC 4862</a>        IPv6 Stateless Address Autoconfiguration  September 2007</span>


<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/5.5.1.%20%20Soliciting%20Router%20Advertisements"></a><a class="selflink" href="#section-5.5.1" name="section-5.5.1">5.5.1</a>.  Soliciting Router Advertisements</span>

   Router Advertisements are sent periodically to the all-nodes
   multicast address.  To obtain an advertisement quickly, a host sends
   out Router Solicitations as described in [<a href="rfc4861.html" title='"Neighbor Discovery for IP version 6 (IPv6)"'>RFC4861</a>].

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/5.5.2.%20%20Absence%20of%20Router%20Advertisements"></a><a class="selflink" href="#section-5.5.2" name="section-5.5.2">5.5.2</a>.  Absence of Router Advertisements</span>

   Even if a link has no routers, the DHCPv6 service to obtain addresses
   may still be available, and hosts may want to use the service.  From
   the perspective of autoconfiguration, a link has no routers if no
   Router Advertisements are received after having sent a small number
   of Router Solicitations as described in [<a href="rfc4861.html" title='"Neighbor Discovery for IP version 6 (IPv6)"'>RFC4861</a>].

   Note that it is possible that there is no router on the link in this
   sense, but there is a node that has the ability to forward packets.
   In this case, the forwarding node's address must be manually
   configured in hosts to be able to send packets off-link, since the
   only mechanism to configure the default router's address
   automatically is the one using Router Advertisements.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/5.5.3.%20%20Router%20Advertisement%20Processing"></a><a class="selflink" href="#section-5.5.3" name="section-5.5.3">5.5.3</a>.  Router Advertisement Processing</span>

   For each Prefix-Information option in the Router Advertisement:

    a)  If the Autonomous flag is not set, silently ignore the Prefix
      Information option.

    b)  If the prefix is the link-local prefix, silently ignore the
      Prefix Information option.

    c)  If the preferred lifetime is greater than the valid lifetime,
      silently ignore the Prefix Information option.  A node MAY wish to
      log a system management error in this case.

    d)  If the prefix advertised is not equal to the prefix of an
      address configured by stateless autoconfiguration already in the
      list of addresses associated with the interface (where "equal"
      means the two prefix lengths are the same and the first prefix-
      length bits of the prefixes are identical), and if the Valid
      Lifetime is not 0, form an address (and add it to the list) by
      combining the advertised prefix with an interface identifier of
      the link as follows:

      |            128 - N bits               |       N bits           |
      +---------------------------------------+------------------------+
      |            link prefix                |  interface identifier  |
      +----------------------------------------------------------------+



<span class="grey">Thomson, et al.             Standards Track                    [Page 18]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-19" id="page-19" name="page-19"> </a>
<span class="grey"><a href="rfc4862.html">RFC 4862</a>        IPv6 Stateless Address Autoconfiguration  September 2007</span>


      If the sum of the prefix length and interface identifier length
      does not equal 128 bits, the Prefix Information option MUST be
      ignored.  An implementation MAY wish to log a system management
      error in this case.  The length of the interface identifier is
      defined in a separate link-type specific document, which should
      also be consistent with the address architecture [<a href="rfc4291.html" title='"IP Version 6 Addressing Architecture"'>RFC4291</a>] (see
      <a href="#section-2">Section 2</a>).

      It is the responsibility of the system administrator to ensure
      that the lengths of prefixes contained in Router Advertisements
      are consistent with the length of interface identifiers for that
      link type.  It should be noted, however, that this does not mean
      the advertised prefix length is meaningless.  In fact, the
      advertised length has non-trivial meaning for on-link
      determination in [<a href="rfc4861.html" title='"Neighbor Discovery for IP version 6 (IPv6)"'>RFC4861</a>] where the sum of the prefix length and
      the interface identifier length may not be equal to 128.  Thus, it
      should be safe to validate the advertised prefix length here, in
      order to detect and avoid a configuration error specifying an
      invalid prefix length in the context of address autoconfiguration.

      Note that a future revision of the address architecture [<a href="rfc4291.html" title='"IP Version 6 Addressing Architecture"'>RFC4291</a>]
      and a future link-type-specific document, which will still be
      consistent with each other, could potentially allow for an
      interface identifier of length other than the value defined in the
      current documents.  Thus, an implementation should not assume a
      particular constant.  Rather, it should expect any lengths of
      interface identifiers.

      If an address is formed successfully and the address is not yet in
      the list, the host adds it to the list of addresses assigned to
      the interface, initializing its preferred and valid lifetime
      values from the Prefix Information option.  Note that the check
      against the prefix performed at the beginning of this step cannot
      always detect the address conflict in the list.  It could be
      possible that an address already in the list, configured either
      manually or by DHCPv6, happens to be identical to the newly
      created address, whereas such a case should be atypical.

    e)  If the advertised prefix is equal to the prefix of an address
      configured by stateless autoconfiguration in the list, the
      preferred lifetime of the address is reset to the Preferred
      Lifetime in the received advertisement.  The specific action to
      perform for the valid lifetime of the address depends on the Valid
      Lifetime in the received advertisement and the remaining time to
      the valid lifetime expiration of the previously autoconfigured
      address.  We call the remaining time "RemainingLifetime" in the
      following discussion:




<span class="grey">Thomson, et al.             Standards Track                    [Page 19]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-20" id="page-20" name="page-20"> </a>
<span class="grey"><a href="rfc4862.html">RFC 4862</a>        IPv6 Stateless Address Autoconfiguration  September 2007</span>


      1.  If the received Valid Lifetime is greater than 2 hours or
          greater than RemainingLifetime, set the valid lifetime of the
          corresponding address to the advertised Valid Lifetime.

      2.  If RemainingLifetime is less than or equal to 2 hours, ignore
          the Prefix Information option with regards to the valid
          lifetime, unless the Router Advertisement from which this
          option was obtained has been authenticated (e.g., via Secure
          Neighbor Discovery [<a href="rfc3971.html" title='"SEcure Neighbor Discovery (SEND)"'>RFC3971</a>]).  If the Router Advertisement
          was authenticated, the valid lifetime of the corresponding
          address should be set to the Valid Lifetime in the received
          option.

      3.  Otherwise, reset the valid lifetime of the corresponding
          address to 2 hours.

      The above rules address a specific denial-of-service attack in
      which a bogus advertisement could contain prefixes with very small
      Valid Lifetimes.  Without the above rules, a single
      unauthenticated advertisement containing bogus Prefix Information
      options with short Valid Lifetimes could cause all of a node's
      addresses to expire prematurely.  The above rules ensure that
      legitimate advertisements (which are sent periodically) will
      "cancel" the short Valid Lifetimes before they actually take
      effect.

      Note that the preferred lifetime of the corresponding address is
      always reset to the Preferred Lifetime in the received Prefix
      Information option, regardless of whether the valid lifetime is
      also reset or ignored.  The difference comes from the fact that
      the possible attack for the preferred lifetime is relatively
      minor.  Additionally, it is even undesirable to ignore the
      preferred lifetime when a valid administrator wants to deprecate a
      particular address by sending a short preferred lifetime (and the
      valid lifetime is ignored by accident).

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/5.5.4.%20%20Address%20Lifetime%20Expiry"></a><a class="selflink" href="#section-5.5.4" name="section-5.5.4">5.5.4</a>.  Address Lifetime Expiry</span>

   A preferred address becomes deprecated when its preferred lifetime
   expires.  A deprecated address SHOULD continue to be used as a source
   address in existing communications, but SHOULD NOT be used to
   initiate new communications if an alternate (non-deprecated) address
   of sufficient scope can easily be used instead.

   Note that the feasibility of initiating new communication using a
   non-deprecated address may be an application-specific decision, as
   only the application may have knowledge about whether the (now)
   deprecated address was (or still is) in use by the application.  For



<span class="grey">Thomson, et al.             Standards Track                    [Page 20]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-21" id="page-21" name="page-21"> </a>
<span class="grey"><a href="rfc4862.html">RFC 4862</a>        IPv6 Stateless Address Autoconfiguration  September 2007</span>


   example, if an application explicitly specifies that the protocol
   stack use a deprecated address as a source address, the protocol
   stack must accept that; the application might request it because that
   IP address is used in higher-level communication and there might be a
   requirement that the multiple connections in such a grouping use the
   same pair of IP addresses.

   IP and higher layers (e.g., TCP, UDP) MUST continue to accept and
   process datagrams destined to a deprecated address as normal since a
   deprecated address is still a valid address for the interface.  In
   the case of TCP, this means TCP SYN segments sent to a deprecated
   address are responded to using the deprecated address as a source
   address in the corresponding SYN-ACK (if the connection would
   otherwise be allowed).

   An implementation MAY prevent any new communication from using a
   deprecated address, but system management MUST have the ability to
   disable such a facility, and the facility MUST be disabled by
   default.

   Other subtle cases should also be noted about source address
   selection.  For example, the above description does not clarify which
   address should be used between a deprecated, smaller-scope address
   and a non-deprecated, sufficient scope address.  The details of the
   address selection including this case are described in [<a href="rfc3484.html" title='"Default Address Selection for Internet Protocol version 6 (IPv6)"'>RFC3484</a>] and
   are beyond the scope of this document.

   An address (and its association with an interface) becomes invalid
   when its valid lifetime expires.  An invalid address MUST NOT be used
   as a source address in outgoing communications and MUST NOT be
   recognized as a destination on a receiving interface.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.6.%20%20Configuration%20Consistency"></a><a class="selflink" href="#section-5.6" name="section-5.6">5.6</a>.  Configuration Consistency</span>

   It is possible for hosts to obtain address information using both
   stateless autoconfiguration and DHCPv6 since both may be enabled at
   the same time.  It is also possible that the values of other
   configuration parameters, such as MTU size and hop limit, will be
   learned from both Router Advertisements and DHCPv6.  If the same
   configuration information is provided by multiple sources, the value
   of this information should be consistent.  However, it is not
   considered a fatal error if information received from multiple
   sources is inconsistent.  Hosts accept the union of all information
   received via Neighbor Discovery and DHCPv6.

   If inconsistent information is learned from different sources, an
   implementation may want to give information learned securely
   precedence over information learned without protection.  For



<span class="grey">Thomson, et al.             Standards Track                    [Page 21]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-22" id="page-22" name="page-22"> </a>
<span class="grey"><a href="rfc4862.html">RFC 4862</a>        IPv6 Stateless Address Autoconfiguration  September 2007</span>


   instance, <a href="rfc3971.html#section-8">Section8 of [RFC3971]</a> discusses how to deal with
   information learned through Secure Neighbor Discovery conflicting
   with information learned through plain Neighbor Discovery.  The same
   discussion can apply to the preference between information learned
   through plain Neighbor Discovery and information learned via secured
   DHCPv6, and so on.

   In any case, if there is no security difference, the most recently
   obtained values SHOULD have precedence over information learned
   earlier.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.7.%20%20Retaining%20Configured%20Addresses%20for%20Stability"></a><a class="selflink" href="#section-5.7" name="section-5.7">5.7</a>.  Retaining Configured Addresses for Stability</span>

   An implementation that has stable storage may want to retain
   addresses in the storage when the addresses were acquired using
   stateless address autoconfiguration.  Assuming the lifetimes used are
   reasonable, this technique implies that a temporary outage (less than
   the valid lifetime) of a router will never result in losing a global
   address of the node even if the node were to reboot.  When this
   technique is used, it should also be noted that the expiration times
   of the preferred and valid lifetimes must be retained, in order to
   prevent the use of an address after it has become deprecated or
   invalid.

   Further details on this kind of extension are beyond the scope of
   this document.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/6.%20%20Security%20Considerations"></a><a class="selflink" href="#section-6" name="section-6">6</a>.  Security Considerations</span>

   Stateless address autoconfiguration allows a host to connect to a
   network, configure an address, and start communicating with other
   nodes without ever registering or authenticating itself with the
   local site.  Although this allows unauthorized users to connect to
   and use a network, the threat is inherently present in the Internet
   architecture.  Any node with a physical attachment to a network can
   generate an address (using a variety of ad hoc techniques) that
   provides connectivity.

   The use of stateless address autoconfiguration and Duplicate Address
   Detection opens up the possibility of several denial-of-service
   attacks.  For example, any node can respond to Neighbor Solicitations
   for a tentative address, causing the other node to reject the address
   as a duplicate.  A separate document [<a href="rfc3756.html" title='"IPv6 Neighbor Discovery (ND) Trust Models and Threats"'>RFC3756</a>] discusses details
   about these attacks, which can be addressed with the Secure Neighbor
   Discovery protocol [<a href="rfc3971.html" title='"SEcure Neighbor Discovery (SEND)"'>RFC3971</a>].  It should also be noted that [<a href="rfc3756.html" title='"IPv6 Neighbor Discovery (ND) Trust Models and Threats"'>RFC3756</a>]
   points out that the use of IP security is not always feasible
   depending on network environments.




<span class="grey">Thomson, et al.             Standards Track                    [Page 22]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-23" id="page-23" name="page-23"> </a>
<span class="grey"><a href="rfc4862.html">RFC 4862</a>        IPv6 Stateless Address Autoconfiguration  September 2007</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/7.%20%20Acknowledgements"></a><a class="selflink" href="#section-7" name="section-7">7</a>.  Acknowledgements</span>

   Thomas Narten and Susan Thompson were the authors of RFCs 1971 and
   2462.  For this revision of the RFC, Tatuya Jinmei was the sole
   editor.

   The authors of <a href="rfc2461.html">RFC 2461</a> would like to thank the members of both the
   IPNG (which is now IPV6) and ADDRCONF working groups for their input.
   In particular, thanks to Jim Bound, Steve Deering, Richard Draves,
   and Erik Nordmark.  Thanks also goes to John Gilmore for alerting the
   WG of the "0 Lifetime Prefix Advertisement" denial-of-service attack
   vulnerability; this document incorporates changes that address this
   vulnerability.

   A number of people have contributed to identifying issues with <a href="rfc2461.html">RFC</a>
   <a href="rfc2461.html">2461</a> and to proposing resolutions to the issues as reflected in this
   version of the document.  In addition to those listed above, the
   contributors include Jari Arkko, James Carlson, Brian E.  Carpenter,
   Gregory Daley, Elwyn Davies, Ralph Droms, Jun-ichiro Itojun Hagino,
   Christian Huitema, Suresh Krishnan, Soohong Daniel Park, Markku
   Savela, Pekka Savola, Hemant Singh, Bernie Volz, Margaret Wasserman,
   and Vlad Yasevich.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/8.%20%20References"></a><a class="selflink" href="#section-8" name="section-8">8</a>.  References</span>

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/8.1.%20%20Normative%20References"></a><a class="selflink" href="#section-8.1" name="section-8.1">8.1</a>.  Normative References</span>

   [<a id="ref-RFC2464" name="ref-RFC2464">RFC2464</a>]     Crawford, M., "Transmission of IPv6 Packets over
                 Ethernet Networks", <a href="rfc2464.html">RFC 2464</a>, December 1998.

   [<a id="ref-RFC2119" name="ref-RFC2119">RFC2119</a>]     Bradner, S., "Key words for use in RFCs to Indicate
                 Requirement Levels", <a href="http://tools.ietf.org/html/bcp14">BCP 14</a>, <a href="rfc2119.html">RFC 2119</a>, March 1997.

   [<a id="ref-RFC4291" name="ref-RFC4291">RFC4291</a>]     Hinden, R. and S. Deering, "IP Version 6 Addressing
                 Architecture", <a href="rfc4291.html">RFC 4291</a>, February 2006.

   [<a id="ref-RFC4861" name="ref-RFC4861">RFC4861</a>]     Narten, T., Nordmark, E., Simpson, W., and H. Soliman,
                 "Neighbor Discovery for IP version 6 (IPv6)", <a href="rfc4861.html">RFC 4861</a>,
                 September 2007.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/8.2.%20%20Informative%20References"></a><a class="selflink" href="#section-8.2" name="section-8.2">8.2</a>.  Informative References</span>

   [<a id="ref-RFC3315" name="ref-RFC3315">RFC3315</a>]     Droms, R., Bound, J., Volz, B., Lemon, T., Perkins, C.,
                 and M. Carney, "Dynamic Host Configuration Protocol for
                 IPv6 (DHCPv6)", <a href="rfc3315.html">RFC 3315</a>, July 2003.

   [<a id="ref-RFC3484" name="ref-RFC3484">RFC3484</a>]     Draves, R., "Default Address Selection for Internet
                 Protocol version 6 (IPv6)", <a href="rfc3484.html">RFC 3484</a>, February 2003.



<span class="grey">Thomson, et al.             Standards Track                    [Page 23]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-24" id="page-24" name="page-24"> </a>
<span class="grey"><a href="rfc4862.html">RFC 4862</a>        IPv6 Stateless Address Autoconfiguration  September 2007</span>


   [<a id="ref-RFC4941" name="ref-RFC4941">RFC4941</a>]     Narten, T., Draves, R., and S. Krishnan, "Privacy
                 Extensions for Stateless Address Autoconfiguration in
                 IPv6", <a href="rfc4941.html">RFC 4941</a>, September 2007.

   [<a id="ref-RFC3972" name="ref-RFC3972">RFC3972</a>]     Aura, T., "Cryptographically Generated Addresses
                 (CGA)", <a href="rfc3972.html">RFC 3972</a>, March 2005.

   [<a id="ref-RFC2710" name="ref-RFC2710">RFC2710</a>]     Deering, S., Fenner, W., and B. Haberman, "Multicast
                 Listener Discovery (MLD) for IPv6", <a href="rfc2710.html">RFC 2710</a>,
                 October 1999.

   [<a id="ref-RFC3810" name="ref-RFC3810">RFC3810</a>]     Vida, R. and L. Costa, "Multicast Listener Discovery
                 Version 2 (MLDv2) for IPv6", <a href="rfc3810.html">RFC 3810</a>, June 2004.

   [<a id="ref-RFC3590" name="ref-RFC3590">RFC3590</a>]     Haberman, B., "Source Address Selection for the
                 Multicast Listener Discovery (MLD) Protocol", <a href="rfc3590.html">RFC 3590</a>,
                 September 2003.

   [<a id="ref-RFC3971" name="ref-RFC3971">RFC3971</a>]     Arkko, J., Kempf, J., Zill, B., and P. Nikander,
                 "SEcure Neighbor Discovery (SEND)", <a href="rfc3971.html">RFC 3971</a>,
                 March 2005.

   [<a id="ref-RFC3756" name="ref-RFC3756">RFC3756</a>]     Nikander, P., Kempf, J., and E. Nordmark, "IPv6
                 Neighbor Discovery (ND) Trust Models and Threats",
                 <a href="rfc3756.html">RFC 3756</a>, May 2004.

   [<a id="ref-RFC1112" name="ref-RFC1112">RFC1112</a>]     Deering, S., "Host extensions for IP multicasting",
                 STD 5, <a href="rfc1112.html">RFC 1112</a>, August 1989.

   [<a id="ref-IEEE802.11" name="ref-IEEE802.11">IEEE802.11</a>]  IEEE, "Wireless LAN Medium Access Control (MAC) and
                 Physical Layer (PHY) Specifications", ANSI/IEEE
                 STd 802.11, August 1999.



















<span class="grey">Thomson, et al.             Standards Track                    [Page 24]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-25" id="page-25" name="page-25"> </a>
<span class="grey"><a href="rfc4862.html">RFC 4862</a>        IPv6 Stateless Address Autoconfiguration  September 2007</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/Appendix%20A.%20%20Loopback%20Suppression%20and%20Duplicate%20Address%20Detection"></a><a class="selflink" href="#appendix-A" name="appendix-A">Appendix A</a>.  Loopback Suppression and Duplicate Address Detection</span>

   Determining whether a received multicast solicitation was looped back
   to the sender or actually came from another node is implementation-
   dependent.  A problematic case occurs when two interfaces attached to
   the same link happen to have the same identifier and link-layer
   address, and they both send out packets with identical contents at
   roughly the same time (e.g., Neighbor Solicitations for a tentative
   address as part of Duplicate Address Detection messages).  Although a
   receiver will receive both packets, it cannot determine which packet
   was looped back and which packet came from the other node simply by
   comparing packet contents (i.e., the contents are identical).  In
   this particular case, it is not necessary to know precisely which
   packet was looped back and which was sent by another node; if one
   receives more solicitations than were sent, the tentative address is
   a duplicate.  However, the situation may not always be this
   straightforward.

   The IPv4 multicast specification [<a href="rfc1112.html" title='"Host extensions for IP multicasting"'>RFC1112</a>] recommends that the
   service interface provide a way for an upper-layer protocol to
   inhibit local delivery of packets sent to a multicast group that the
   sending host is a member of.  Some applications know that there will
   be no other group members on the same host, and suppressing loopback
   prevents them from having to receive (and discard) the packets they
   themselves send out.  A straightforward way to implement this
   facility is to disable loopback at the hardware level (if supported
   by the hardware), with packets looped back (if requested) by
   software.  On interfaces in which the hardware itself suppresses
   loopbacks, a node running Duplicate Address Detection simply counts
   the number of Neighbor Solicitations received for a tentative address
   and compares them with the number expected.  If there is a mismatch,
   the tentative address is a duplicate.

   In those cases where the hardware cannot suppress loopbacks, however,
   one possible software heuristic to filter out unwanted loopbacks is
   to discard any received packet whose link-layer source address is the
   same as the receiving interface's.  There is even a link-layer
   specification that requires that any such packets be discarded
   [<a href="#ref-IEEE802.11" title='"Wireless LAN Medium Access Control (MAC) and Physical Layer (PHY) Specifications"'>IEEE802.11</a>].  Unfortunately, use of that criteria also results in
   the discarding of all packets sent by another node using the same
   link-layer address.  Duplicate Address Detection will fail on
   interfaces that filter received packets in this manner:

   o  If a node performing Duplicate Address Detection discards received
      packets that have the same source link-layer address as the
      receiving interface, it will also discard packets from other nodes
      that also use the same link-layer address, including Neighbor
      Advertisement and Neighbor Solicitation messages required to make



<span class="grey">Thomson, et al.             Standards Track                    [Page 25]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-26" id="page-26" name="page-26"> </a>
<span class="grey"><a href="rfc4862.html">RFC 4862</a>        IPv6 Stateless Address Autoconfiguration  September 2007</span>


      Duplicate Address Detection work correctly.  This particular
      problem can be avoided by temporarily disabling the software
      suppression of loopbacks while a node performs Duplicate Address
      Detection, if it is possible to disable the suppression.

   o  If a node that is already using a particular IP address discards
      received packets that have the same link-layer source address as
      the interface, it will also discard Duplicate Address Detection-
      related Neighbor Solicitation messages sent by another node that
      also use the same link-layer address.  Consequently, Duplicate
      Address Detection will fail, and the other node will configure a
      non-unique address.  Since it is generally impossible to know when
      another node is performing Duplicate Address Detection, this
      scenario can be avoided only if software suppression of loopback
      is permanently disabled.

   Thus, to perform Duplicate Address Detection correctly in the case
   where two interfaces are using the same link-layer address, an
   implementation must have a good understanding of the interface's
   multicast loopback semantics, and the interface cannot discard
   received packets simply because the source link-layer address is the
   same as the interface's.  It should also be noted that a link-layer
   specification can conflict with the condition necessary to make
   Duplicate Address Detection work.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/Appendix%20B.%20%20Changes%20since%20RFC%201971"></a><a class="selflink" href="#appendix-B" name="appendix-B">Appendix B</a>.  Changes since <a href="rfc1971.html">RFC 1971</a></span>

   o  Changed document to use term "interface identifier" rather than
      "interface token" for consistency with other IPv6 documents.

   o  Clarified definition of deprecated address to make clear it is OK
      to continue sending to or from deprecated addresses.

   o  Added rules to <a href="#section-5.5.3">Section 5.5.3</a> Router Advertisement processing to
      address potential denial-of-service attack when prefixes are
      advertised with very short Lifetimes.

   o  Clarified wording in <a href="#section-5.5.4">Section 5.5.4</a> to make clear that all upper
      layer protocols must process (i.e., send and receive) packets sent
      to deprecated addresses.











<span class="grey">Thomson, et al.             Standards Track                    [Page 26]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-27" id="page-27" name="page-27"> </a>
<span class="grey"><a href="rfc4862.html">RFC 4862</a>        IPv6 Stateless Address Autoconfiguration  September 2007</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/Appendix%20C.%20%20Changes%20since%20RFC%202462"></a><a class="selflink" href="#appendix-C" name="appendix-C">Appendix C</a>.  Changes since <a href="rfc2462.html">RFC 2462</a></span>

   Major changes that can affect existing implementations:

   o  Specified that a node performing Duplicate Address Detection delay
      joining the solicited-node multicast group, not just delay sending
      Neighbor Solicitations, explaining the detailed reason.

   o  Added a requirement for a random delay before sending Neighbor
      Solicitations for Duplicate Address Detection if the address being
      checked is configured by a multicasted Router Advertisements.

   o  Clarified that on failure of Duplicate Address Detection, IP
      network operation should be disabled and that the rule should
      apply when the hardware address is supposed to be unique.

   Major clarifications:

   o  Clarified how the length of interface identifiers should be
      determined, described the relationship with the prefix length
      advertised in Router Advertisements, and avoided using a
      particular length hard-coded in this document.

   o  Clarified the processing of received neighbor advertisements while
      performing Duplicate Address Detection.

   o  Removed the text regarding the M and O flags, considering the
      maturity of implementations and operational experiences.
      ManagedFlag and OtherConfigFlag were removed accordingly.  (Note
      that this change does not mean the use of these flags is
      deprecated.)

   o  Avoided the wording of "stateful configuration", which is known to
      be quite confusing, and simply used "DHCPv6" wherever appropriate.

   o  Recommended to perform Duplicate Address Detection for all unicast
      addresses more strongly, considering a variety of different
      interface identifiers, while keeping care of existing
      implementations.

   o  Clarified wording in <a href="#section-5.5.4">Section 5.5.4</a> to make clear that a deprecated
      address specified by an application can be used for any
      communication.

   o  Clarified the prefix check described in <a href="#section-5.5.3">Section 5.5.3</a> using more
      appropriate terms and that the check is done against the prefixes
      of addresses configured by stateless autoconfiguration.




<span class="grey">Thomson, et al.             Standards Track                    [Page 27]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-28" id="page-28" name="page-28"> </a>
<span class="grey"><a href="rfc4862.html">RFC 4862</a>        IPv6 Stateless Address Autoconfiguration  September 2007</span>


   o  Changed the references to the IP security Authentication Header to
      references to <a href="rfc3971.html">RFC 3971</a> (Secure Neighbor Discovery).  Also revised
      the Security Considerations section with a reference to <a href="rfc3756.html">RFC 3756</a>.

   o  Added a note when an implementation uses stable storage for
      autoconfigured addresses.

   o  Added consideration about preference between inconsistent
      information sets, one from a secured source and the other learned
      without protection.

   Other miscellaneous clarifications:

   o  Removed references to site-local and revised wording around the
      keyword.

   o  Removed redundant code in denial-of-service protection in
      <a href="#section-5.5.3">Section 5.5.3</a>.

   o  Clarified that a unicasted Neighbor Solicitation or Advertisement
      should be discarded while performing Duplicate Address Detection.

   o  Noted in <a href="#section-5.3">Section 5.3</a> that an interface can be considered as
      becoming enabled when a wireless access point changes.



























<span class="grey">Thomson, et al.             Standards Track                    [Page 28]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-29" id="page-29" name="page-29"> </a>
<span class="grey"><a href="rfc4862.html">RFC 4862</a>        IPv6 Stateless Address Autoconfiguration  September 2007</span>


Authors' Addresses

   Susan Thomson
   Cisco Systems

   EMail: sethomso@cisco.com


   Thomas Narten
   IBM Corporation
   P.O. Box 12195
   Research Triangle Park, NC  27709-2195
   USA

   Phone: +1 919-254-7798
   EMail: narten@us.ibm.com


   Tatuya Jinmei
   Corporate Research &amp; Development Center, Toshiba Corporation
   1 Komukai Toshiba-cho, Saiwai-ku
   Kawasaki-shi, Kanagawa  212-8582
   Japan

   Phone: +81 44-549-2230
   EMail: jinmei@isl.rdc.toshiba.co.jp

























<span class="grey">Thomson, et al.             Standards Track                    [Page 29]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-30" id="page-30" name="page-30"> </a>
<span class="grey"><a href="rfc4862.html">RFC 4862</a>        IPv6 Stateless Address Autoconfiguration  September 2007</span>


Full Copyright Statement

   Copyright (C) The IETF Trust (2007).

   This document is subject to the rights, licenses and restrictions
   contained in <a href="http://tools.ietf.org/html/bcp78">BCP 78</a>, and except as set forth therein, the authors
   retain all their rights.

   This document and the information contained herein are provided on an
   "AS IS" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS
   OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST AND
   THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS
   OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF
   THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED
   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.

Intellectual Property

   The IETF takes no position regarding the validity or scope of any
   Intellectual Property Rights or other rights that might be claimed to
   pertain to the implementation or use of the technology described in
   this document or the extent to which any license under such rights
   might or might not be available; nor does it represent that it has
   made any independent effort to identify any such rights.  Information
   on the procedures with respect to rights in RFC documents can be
   found in <a href="http://tools.ietf.org/html/bcp78">BCP 78</a> and <a href="http://tools.ietf.org/html/bcp79">BCP 79</a>.

   Copies of IPR disclosures made to the IETF Secretariat and any
   assurances of licenses to be made available, or the result of an
   attempt made to obtain a general license or permission for the use of
   such proprietary rights by implementers or users of this
   specification can be obtained from the IETF on-line IPR repository at
   <a href="http://www.ietf.org/ipr">http://www.ietf.org/ipr</a>.

   The IETF invites any interested party to bring to its attention any
   copyrights, patents or patent applications, or other proprietary
   rights that may cover technology that may be required to implement
   this standard.  Please address the information to the IETF at
   ietf-ipr@ietf.org.












Thomson, et al.             Standards Track                    [Page 30]

</pre><br/>
<span class="noprint"><small><small>Html markup produced by rfcmarkup 1.107, available from
<a href="http://tools.ietf.org/tools/rfcmarkup/">http://tools.ietf.org/tools/rfcmarkup/</a>
</small></small></span>



</body><!-- Mirrored from tools.ietf.org/html/rfc4862 by HTTrack Website Copier/3.x [XR&CO'2013], Sat, 07 Jun 2014 20:18:45 GMT --></html>