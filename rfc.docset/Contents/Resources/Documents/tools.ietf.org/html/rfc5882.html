<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml"><head profile="http://dublincore.org/documents/2008/08/04/dc-html/">
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
    <meta content="index,follow" name="robots"/>
    <meta content="rfcmarkup version 1.106" name="creator"/>
    <link href="http://purl.org/dc/elements/1.1/" rel="schema.DC"/>
<meta content="urn:ietf:rfc:5882" name="DC.Identifier"/>
<meta content="This document describes the generic application of the Bidirectional\nForwarding Detection (BFD) protocol. [STANDARDS-TRACK]" name="DC.Description.Abstract"/>
<meta content="Katz, Dave" name="DC.Creator"/>
<meta content="Ward, David" name="DC.Creator"/>
<meta content="June, 2010" name="DC.Date.Issued"/>
<meta content="Generic Application of Bidirectional Forwarding Detection (BFD)" name="DC.Title"/>

    <link href="http://tools.ietf.org/images/rfc.png" rel="icon" type="image/png"/>
    <link href="http://tools.ietf.org/images/rfc.png" rel="shortcut icon" type="image/png"/>
    <title>RFC 5882 - Generic Application of Bidirectional Forwarding Detection (BFD)</title>
    
    
    <style type="text/css">
	body {
	    margin: 0px 8px;
            font-size: 1em;
	}
        h1, h2, h3, h4, h5, h6, .h1, .h2, .h3, .h4, .h5, .h6 {
	    font-weight: bold;
            line-height: 0pt;
            display: inline;
            white-space: pre;
            font-family: monospace;
            font-size: 1em;
	    font-weight: bold;
        }
        pre {
            font-size: 1em;
            margin-top: 0px;
            margin-bottom: 0px;
        }
	.pre {
	    white-space: pre;
	    font-family: monospace;
	}
	.header{
	    font-weight: bold;
	}
        .newpage {
            page-break-before: always;
        }
        .invisible {
            text-decoration: none;
            color: white;
        }
        a.selflink {
          color: black;
          text-decoration: none;
        }
        @media print {
            body {
                font-family: monospace;
                font-size: 10.5pt;
            }
            h1, h2, h3, h4, h5, h6 {
                font-size: 1em;
            }
        
            a:link, a:visited {
                color: inherit;
                text-decoration: none;
            }
            .noprint {
                display: none;
            }
        }
	@media screen {
	    .grey, .grey a:link, .grey a:visited {
		color: #777;
	    }
            .docinfo {
                background-color: #EEE;
            }
            .top {
                border-top: 7px solid #EEE;
            }
            .bgwhite  { background-color: white; }
            .bgred    { background-color: #F44; }
            .bggrey   { background-color: #666; }
            .bgbrown  { background-color: #840; }            
            .bgorange { background-color: #FA0; }
            .bgyellow { background-color: #EE0; }
            .bgmagenta{ background-color: #F4F; }
            .bgblue   { background-color: #66F; }
            .bgcyan   { background-color: #4DD; }
            .bggreen  { background-color: #4F4; }

            .legend   { font-size: 90%; }
            .cplate   { font-size: 70%; border: solid grey 1px; }
	}
    </style>
    <!--[if IE]>
    <style>
    body {
       font-size: 13px;
       margin: 10px 10px;
    }
    </style>
    <![endif]-->

    <script type="text/javascript"><!--
    function addHeaderTags() {
	var spans = document.getElementsByTagName("span");
	for (var i=0; i < spans.length; i++) {
	    var elem = spans[i];
	    if (elem) {
		var level = elem.getAttribute("class");
                if (level == "h1" || level == "h2" || level == "h3" || level == "h4" || level == "h5" || level == "h6") {
                    elem.innerHTML = "<"+level+">"+elem.innerHTML+"</"+level+">";		
                }
	    }
	}
    }
    var legend_html = "Colour legend:<br />      <table>         <tr><td>Unknown:</td>                   <td><span class='cplate bgwhite'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft:</td>                     <td><span class='cplate bgred'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Informational:</td>             <td><span class='cplate bgorange'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Experimental:</td>              <td><span class='cplate bgyellow'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Best Common Practice:</td>      <td><span class='cplate bgmagenta'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Proposed Standard:</td>         <td><span class='cplate bgblue'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft Standard (old designation):</td> <td><span class='cplate bgcyan'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Internet Standard:</td>         <td><span class='cplate bggreen'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Historic:</td>                  <td><span class='cplate bggrey'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Obsolete:</td>                  <td><span class='cplate bgbrown'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>     </table>";
    function showElem(id) {
        var elem = document.getElementById(id);
        elem.innerHTML = eval(id+"_html");
        elem.style.visibility='visible';
    }
    function hideElem(id) {
        var elem = document.getElementById(id);
        elem.style.visibility='hidden';        
        elem.innerHTML = "";
    }
    // -->
    </script>
</head>
<body onload="addHeaderTags()">
   <div style="height: 13px;">
      <div class="pre noprint docinfo bgblue" onclick="showElem('legend');" onmouseout="hideElem('legend')" onmouseover="this.style.cursor='pointer';" style="height: 6px; position: absolute;" title="Click for colour legend.">                                                                        </div>
      <div class="docinfo noprint pre legend" id="legend" onmouseout="hideElem('legend');" onmouseover="showElem('legend');" style="position:absolute; top: 4px; left: 4ex; visibility:hidden; background-color: white; padding: 4px 9px 5px 7px; border: solid #345 1px; ">
      </div>
   </div>
<span class="pre noprint docinfo top">[<a href="index.html" title="Document search and retrieval page">Docs</a>] [<a href="http://tools.ietf.org/rfc/rfc5882.txt" title="Plaintext version of this document">txt</a>|<a href="http://tools.ietf.org/pdf/rfc5882" title="PDF version of this document">pdf</a>] [<a href="http://tools.ietf.org/html/draft-ietf-bfd-generic" title="draft-ietf-bfd-generic">draft-ietf-bfd-ge...</a>] [<a href="http://tools.ietf.org/rfcdiff?difftype=--hwdiff&amp;url2=rfc5882" title="Inline diff (wdiff)">Diff1</a>] [<a href="http://tools.ietf.org/rfcdiff?url2=rfc5882" title="Side-by-side diff">Diff2</a>] [<a href="https://datatracker.ietf.org/ipr/search/?option=rfc_search&amp;rfc_search=5882" title="IPR disclosures related to this document">IPR</a>]           </span><br/>
<span class="pre noprint docinfo">                                                                        </span><br/>
<span class="pre noprint docinfo">                                                       PROPOSED STANDARD</span><br/>
<span class="pre noprint docinfo">                                                                        </span><br/>
<pre>Internet Engineering Task Force (IETF)                           D. Katz
Request for Comments: 5882                                       D. Ward
Category: Standards Track                               Juniper Networks
ISSN: 2070-1721                                                June 2010


    <span class="h1">Generic Application of Bidirectional Forwarding Detection (BFD)</span>

Abstract

   This document describes the generic application of the Bidirectional
   Forwarding Detection (BFD) protocol.

Status of This Memo

   This is an Internet Standards Track document.

   This document is a product of the Internet Engineering Task Force
   (IETF).  It represents the consensus of the IETF community.  It has
   received public review and has been approved for publication by the
   Internet Engineering Steering Group (IESG).  Further information on
   Internet Standards is available in <a href="rfc5741.html#section-2">SectionÂ 2 of RFC 5741</a>.

   Information about the current status of this document, any errata,
   and how to provide feedback on it may be obtained at
   <a href="http://www.rfc-editor.org/info/rfc5882">http://www.rfc-editor.org/info/rfc5882</a>.

Copyright Notice

   Copyright (c) 2010 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to <a href="http://tools.ietf.org/html/bcp78">BCP 78</a> and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (<a href="http://trustee.ietf.org/license-info">http://trustee.ietf.org/license-info</a>) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in <a href="#section-4">Section 4</a>.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.










<span class="grey">Katz &amp; Ward                  Standards Track                    [Page 1]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-2" id="page-2" name="page-2"> </a>
<span class="grey"><a href="rfc5882.html">RFC 5882</a>               Generic Application of BFD              June 2010</span>


Table of Contents

   <a href="#section-1">1</a>. Introduction ....................................................<a href="#page-3">3</a>
      <a href="#section-1.1">1.1</a>. Conventions Used in This Document ..........................<a href="#page-3">3</a>
   <a href="#section-2">2</a>. Overview ........................................................<a href="#page-3">3</a>
   <a href="#section-3">3</a>. Basic Interaction between BFD Sessions and Clients ..............<a href="#page-4">4</a>
      <a href="#section-3.1">3.1</a>. Session State Hysteresis ...................................<a href="#page-4">4</a>
      <a href="#section-3.2">3.2</a>. AdminDown State ............................................<a href="#page-5">5</a>
      <a href="#section-3.3">3.3</a>. Hitless Establishment/Reestablishment of BFD State .........<a href="#page-5">5</a>
   <a href="#section-4">4</a>. Control Protocol Interactions ...................................<a href="#page-6">6</a>
      <a href="#section-4.1">4.1</a>. Adjacency Establishment ....................................<a href="#page-6">6</a>
      <a href="#section-4.2">4.2</a>. Reaction to BFD Session State Changes ......................<a href="#page-7">7</a>
           <a href="#section-4.2.1">4.2.1</a>. Control Protocols with a Single Data Protocol .......<a href="#page-7">7</a>
           <a href="#section-4.2.2">4.2.2</a>. Control Protocols with Multiple Data Protocols ......<a href="#page-8">8</a>
      <a href="#section-4.3">4.3</a>. Interactions with Graceful Restart Mechanisms ..............<a href="#page-8">8</a>
           <a href="#section-4.3.1">4.3.1</a>. BFD Fate Independent of the Control Plane ...........<a href="#page-9">9</a>
           <a href="#section-4.3.2">4.3.2</a>. BFD Shares Fate with the Control Plane ..............<a href="#page-9">9</a>
      <a href="#section-4.4">4.4</a>. Interactions with Multiple Control Protocols ..............<a href="#page-10">10</a>
   <a href="#section-5">5</a>. Interactions with Non-Protocol Functions .......................<a href="#page-10">10</a>
   <a href="#section-6">6</a>. Data Protocols and Demultiplexing ..............................<a href="#page-11">11</a>
   <a href="#section-7">7</a>. Multiple Link Subnetworks ......................................<a href="#page-11">11</a>
      <a href="#section-7.1">7.1</a>. Complete Decoupling .......................................<a href="#page-12">12</a>
      <a href="#section-7.2">7.2</a>. Layer N-1 Hints ...........................................<a href="#page-12">12</a>
      <a href="#section-7.3">7.3</a>. Aggregating BFD Sessions ..................................<a href="#page-12">12</a>
      <a href="#section-7.4">7.4</a>. Combinations of Scenarios .................................<a href="#page-12">12</a>
   <a href="#section-8">8</a>. Other Application Issues .......................................<a href="#page-13">13</a>
   <a href="#section-9">9</a>. Interoperability Issues ........................................<a href="#page-13">13</a>
   <a href="#section-10">10</a>. Specific Protocol Interactions (Non-Normative) ................<a href="#page-13">13</a>
      <a href="#section-10.1">10.1</a>. BFD Interactions with OSPFv2, OSPFv3, and IS-IS ..........<a href="#page-14">14</a>
           <a href="#section-10.1.1">10.1.1</a>. Session Establishment .............................<a href="#page-14">14</a>
           <a href="#section-10.1.2">10.1.2</a>. Reaction to BFD State Changes .....................<a href="#page-14">14</a>
           <a href="#section-10.1.3">10.1.3</a>. OSPF Virtual Links ................................<a href="#page-15">15</a>
      <a href="#section-10.2">10.2</a>. Interactions with BGP ....................................<a href="#page-15">15</a>
      <a href="#section-10.3">10.3</a>. Interactions with RIP ....................................<a href="#page-15">15</a>
   <a href="#section-11">11</a>. Security Considerations .......................................<a href="#page-16">16</a>
   <a href="#section-12">12</a>. References ....................................................<a href="#page-16">16</a>
      <a href="#section-12.1">12.1</a>. Normative References .....................................<a href="#page-16">16</a>
      <a href="#section-12.2">12.2</a>. Informative References ...................................<a href="#page-16">16</a>













<span class="grey">Katz &amp; Ward                  Standards Track                    [Page 2]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-3" id="page-3" name="page-3"> </a>
<span class="grey"><a href="rfc5882.html">RFC 5882</a>               Generic Application of BFD              June 2010</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/1.%20%20Introduction"></a><a class="selflink" href="#section-1" name="section-1">1</a>.  Introduction</span>

   The Bidirectional Forwarding Detection [<a href="#ref-BFD" title='"Bidirectional Forwarding Detection"'>BFD</a>] protocol provides a
   liveness detection mechanism that can be utilized by other network
   components for which their integral liveness mechanisms are either
   too slow, inappropriate, or nonexistent.  Other documents have
   detailed the use of BFD with specific encapsulations ([<a href="#ref-BFD-1HOP" title='"Bidirectional Forwarding Detection (BFD) for IPv4 and IPv6 (Single Hop)"'>BFD-1HOP</a>]
   [<a href="#ref-BFD-MULTI" title='"Bidirectional Forwarding Detection (BFD) for Multihop Paths"'>BFD-MULTI</a>] [<a href="#ref-BFD-MPLS" title='"Bidirectional Forwarding Detection (BFD) for MPLS Label Switched Paths (LSPs)"'>BFD-MPLS</a>]).  As the utility of BFD has become
   understood, there have been calls to specify BFD interactions with a
   growing list of network functions.  Rather than producing a long
   series of short documents on the application of BFD, it seemed
   worthwhile to describe the interactions between BFD and other network
   functions ("BFD clients") in a broad way.

   This document describes the generic application of BFD.  Specific
   protocol applications are provided for illustrative purposes.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/1.1.%20Conventions%20Used%20in%20This%20Document"></a><a class="selflink" href="#section-1.1" name="section-1.1">1.1</a>. Conventions Used in This Document</span>

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in <a href="rfc2119.html">RFC 2119</a> [<a href="#ref-KEYWORDS" title='"Key words for use in RFCs to Indicate Requirement Levels"'>KEYWORDS</a>].

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/2.%20%20Overview"></a><a class="selflink" href="#section-2" name="section-2">2</a>.  Overview</span>

   The Bidirectional Forwarding Detection (BFD) specification defines a
   protocol with simple and specific semantics.  Its sole purpose is to
   verify connectivity between a pair of systems, for a particular data
   protocol across a path (which may be of any technology, length, or
   OSI layer).  The promptness of the detection of a path failure can be
   controlled by trading off protocol overhead and system load with
   detection times.

   BFD is *not* intended to directly provide control protocol liveness
   information; those protocols have their own means and vagaries.
   Rather, control protocols can use the services provided by BFD to
   inform their operation.  BFD can be viewed as a service provided by
   the layer in which it is running.

   The service interface with BFD is straightforward.  The application
   supplies session parameters (neighbor address, time parameters,
   protocol options), and BFD provides the session state, of which the
   most interesting transitions are to and from the Up state.  The
   application is expected to bootstrap the BFD session, as BFD has no
   discovery mechanism.






<span class="grey">Katz &amp; Ward                  Standards Track                    [Page 3]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-4" id="page-4" name="page-4"> </a>
<span class="grey"><a href="rfc5882.html">RFC 5882</a>               Generic Application of BFD              June 2010</span>


   An implementation SHOULD establish only a single BFD session per data
   protocol path, regardless of the number of applications that wish to
   utilize it.  There is no additional value in having multiple BFD
   sessions to the same endpoints.  If multiple applications request
   different session parameters, it is a local issue as to how to
   resolve the parameter conflicts.  BFD in turn will notify all
   applications bound to a session when a session state change occurs.

   BFD should be viewed as having an advisory role to the protocol or
   protocols or other network functions with which it is interacting,
   which will then use their own mechanisms to effect any state
   transitions.  The interaction is very much at arm's length, which
   keeps things simple and decoupled.  In particular, BFD explicitly
   does not carry application-specific information, partly for
   architectural reasons and partly because BFD may have curious and
   unpredictable latency characteristics and as such makes a poor
   transport mechanism.

   It is important to remember that the interaction between BFD and its
   client applications has essentially no interoperability issues,
   because BFD is acting in an advisory nature (similar to hardware
   signaling the loss of light on a fiber optic circuit, for example)
   and existing mechanisms in the client applications are used in
   reaction to BFD events.  In fact, BFD may interact with only one of a
   pair of systems for a particular client application without any ill
   effect.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/3.%20%20Basic%20Interaction%20between%20BFD%20Sessions%20and%20Clients"></a><a class="selflink" href="#section-3" name="section-3">3</a>.  Basic Interaction between BFD Sessions and Clients</span>

   The interaction between a BFD session and its associated client
   applications is, for the most part, an implementation issue that is
   outside the scope of this specification.  However, it is useful to
   describe some mechanisms that implementors may use in order to
   promote full-featured implementations.  One way of modeling this
   interaction is to create an adaptation layer between the BFD state
   machine and the client applications.  The adaptation layer is
   cognizant of both the internals of the BFD implementation and the
   requirements of the clients.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.1.%20%20Session%20State%20Hysteresis"></a><a class="selflink" href="#section-3.1" name="section-3.1">3.1</a>.  Session State Hysteresis</span>

   A BFD session can be tightly coupled to its client applications;  for
   example, any transition out of the Up state could cause signaling to
   the clients to take failure action.  However, in some cases, this may
   not always be the best course of action.






<span class="grey">Katz &amp; Ward                  Standards Track                    [Page 4]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-5" id="page-5" name="page-5"> </a>
<span class="grey"><a href="rfc5882.html">RFC 5882</a>               Generic Application of BFD              June 2010</span>


   Implementors may choose to hide rapid Up/Down/Up transitions of the
   BFD session from its clients.  This is useful in order to support
   process restarts without necessitating complex protocol mechanisms,
   for example.

   As such, a system MAY choose not to notify clients if a BFD session
   transitions from Up to Down state, and returns to Up state, if it
   does so within a reasonable period of time (the length of which is
   outside the scope of this specification).  If the BFD session does
   not return to Up state within that time frame, the clients SHOULD be
   notified that a session failure has occurred.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.2.%20%20AdminDown%20State"></a><a class="selflink" href="#section-3.2" name="section-3.2">3.2</a>.  AdminDown State</span>

   The AdminDown mechanism in BFD is intended to signal that the BFD
   session is being taken down for administrative purposes, and the
   session state is not indicative of the liveness of the data path.

   Therefore, a system SHOULD NOT indicate a connectivity failure to a
   client if either the local session state or the remote session state
   (if known) transitions to AdminDown, so long as that client has
   independent means of liveness detection (typically, control
   protocols).

   If a client does not have any independent means of liveness
   detection, a system SHOULD indicate a connectivity failure to a
   client, and assume the semantics of Down state, if either the local
   or remote session state transitions to AdminDown.  Otherwise, the
   client will not be able to determine whether the path is viable, and
   unfortunate results may occur.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.3.%20%20Hitless%20Establishment%2FReestablishment%20of%20BFD%20State"></a><a class="selflink" href="#section-3.3" name="section-3.3">3.3</a>.  Hitless Establishment/Reestablishment of BFD State</span>

   It is useful to be able to configure a BFD session between a pair of
   systems without impacting the state of any clients that will be
   associated with that session.  Similarly, it is useful for BFD state
   to be reestablished without perturbing associated clients when all
   BFD state is lost (such as in process restart situations).  This
   interacts with the clients' ability to establish their state
   independent of BFD.

   The BFD state machine transitions that occur in the process of
   bringing up a BFD session in such situations SHOULD NOT cause a
   connectivity failure notification to the clients.







<span class="grey">Katz &amp; Ward                  Standards Track                    [Page 5]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-6" id="page-6" name="page-6"> </a>
<span class="grey"><a href="rfc5882.html">RFC 5882</a>               Generic Application of BFD              June 2010</span>


   A client that is capable of establishing its state prior to the
   configuration or restarting of a BFD session MAY do so if
   appropriate.  The means to do so is outside of the scope of this
   specification.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/4.%20%20Control%20Protocol%20Interactions"></a><a class="selflink" href="#section-4" name="section-4">4</a>.  Control Protocol Interactions</span>

   Very common client applications of BFD are control protocols, such as
   routing protocols.  The object, when BFD interacts with a control
   protocol, is to advise the control protocol of the connectivity of
   the data protocol.  In the case of routing protocols, for example,
   this allows the connectivity failure to trigger the rerouting of
   traffic around the failed path more quickly than the native detection
   mechanisms.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.1.%20%20Adjacency%20Establishment"></a><a class="selflink" href="#section-4.1" name="section-4.1">4.1</a>.  Adjacency Establishment</span>

   If the session state on either the local or remote system (if known)
   is AdminDown, BFD has been administratively disabled, and the
   establishment of a control protocol adjacency MUST be allowed.

   BFD sessions are typically bootstrapped by the control protocol,
   using the mechanism (discovery, configuration) used by the control
   protocol to find neighbors.  Note that it is possible in some failure
   scenarios for the network to be in a state such that the control
   protocol is capable of coming up, but the BFD session cannot be
   established, and, more particularly, data cannot be forwarded.  To
   avoid this situation, it would be beneficial not to allow the control
   protocol to establish a neighbor adjacency.  However, this would
   preclude the operation of the control protocol in an environment in
   which not all systems support BFD.

   Therefore, the establishment of control protocol adjacencies SHOULD
   be blocked if both systems are willing to establish a BFD session but
   a BFD session cannot be established.  One method for determining that
   both systems are willing to establish a BFD session is if the control
   protocol carries explicit signaling of this fact.  If there is no
   explicit signaling, the willingness to establish a BFD session may be
   determined by means outside the scope of this specification.

   If it is believed that the neighboring system does not support BFD,
   the establishment of a control protocol adjacency SHOULD NOT be
   blocked.

   The setting of BFD's various timing parameters and modes are not
   subject to standardization.  Note that all protocols sharing a
   session will operate using the same parameters.  The mechanism for
   choosing the parameters among those desired by the various protocols



<span class="grey">Katz &amp; Ward                  Standards Track                    [Page 6]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-7" id="page-7" name="page-7"> </a>
<span class="grey"><a href="rfc5882.html">RFC 5882</a>               Generic Application of BFD              June 2010</span>


   is outside the scope of this specification.  It is generally useful
   to choose the parameters resulting in the shortest Detection Time; a
   particular client application can always apply hysteresis to the
   notifications from BFD if it desires longer Detection Times.

   Note that many control protocols assume full connectivity between all
   systems on multiaccess media such as LANs.  If BFD is running on only
   a subset of systems on such a network, and adjacency establishment is
   blocked by the absence of a BFD session, the assumptions of the
   control protocol may be violated, with unpredictable results.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.2.%20%20Reaction%20to%20BFD%20Session%20State%20Changes"></a><a class="selflink" href="#section-4.2" name="section-4.2">4.2</a>.  Reaction to BFD Session State Changes</span>

   If a BFD session transitions from Up state to AdminDown, or the
   session transitions from Up to Down because the remote system is
   indicating that the session is in state AdminDown, clients SHOULD NOT
   take any control protocol action.

   For other transitions from Up to Down state, the mechanism by which
   the control protocol reacts to a path failure signaled by BFD depends
   on the capabilities of the protocol, as specified in the following
   subsections.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/4.2.1.%20%20Control%20Protocols%20with%20a%20Single%20Data%20Protocol"></a><a class="selflink" href="#section-4.2.1" name="section-4.2.1">4.2.1</a>.  Control Protocols with a Single Data Protocol</span>

   A control protocol that is tightly bound to a single failing data
   protocol SHOULD take action to ensure that data traffic is no longer
   directed to the failing path.  Note that this should not be
   interpreted as BFD replacing the control protocol liveness mechanism,
   if any, as the control protocol may rely on mechanisms not verified
   by BFD (multicast, for instance) so BFD most likely cannot detect all
   failures that would impact the control protocol.  However, a control
   protocol MAY choose to use BFD session state information to more
   rapidly detect an impending control protocol failure, particularly if
   the control protocol operates in-band (over the data protocol).

   Therefore, when a BFD session transitions from Up to Down, action
   SHOULD be taken in the control protocol to signal the lack of
   connectivity for the path over which BFD is running.  If the control
   protocol has an explicit mechanism for announcing path state, a
   system SHOULD use that mechanism rather than impacting the
   connectivity of the control protocol, particularly if the control
   protocol operates out-of-band from the failed data protocol.
   However, if such a mechanism is not available, a control protocol
   timeout SHOULD be emulated for the associated neighbor.






<span class="grey">Katz &amp; Ward                  Standards Track                    [Page 7]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-8" id="page-8" name="page-8"> </a>
<span class="grey"><a href="rfc5882.html">RFC 5882</a>               Generic Application of BFD              June 2010</span>


<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/4.2.2.%20%20Control%20Protocols%20with%20Multiple%20Data%20Protocols"></a><a class="selflink" href="#section-4.2.2" name="section-4.2.2">4.2.2</a>.  Control Protocols with Multiple Data Protocols</span>

   Slightly different mechanisms are used if the control protocol
   supports the routing of multiple data protocols, depending on whether
   the control protocol supports separate topologies for each data
   protocol.

<span class="h5"><a class="dashAnchor" name="//apple_ref/Section/4.2.2.1.%20%20Shared%20Topologies"></a><a class="selflink" href="#section-4.2.2.1" name="section-4.2.2.1">4.2.2.1</a>.  Shared Topologies</span>

   With a shared topology, if one of the data protocols fails (as
   signaled by the associated BFD session), it is necessary to consider
   the path to have failed for all data protocols.  Otherwise, there is
   no way for the control protocol to turn away traffic for the failed
   data protocol (and such traffic would be black-holed indefinitely).

   Therefore, when a BFD session transitions from Up to Down, action
   SHOULD be taken in the control protocol to signal the lack of
   connectivity for the path in the topology corresponding to the BFD
   session.  If this cannot be signaled otherwise, a control protocol
   timeout SHOULD be emulated for the associated neighbor.

<span class="h5"><a class="dashAnchor" name="//apple_ref/Section/4.2.2.2.%20%20Independent%20Topologies"></a><a class="selflink" href="#section-4.2.2.2" name="section-4.2.2.2">4.2.2.2</a>.  Independent Topologies</span>

   With individual routing topologies for each data protocol, only the
   failed data protocol needs to be rerouted around the failed path.

   Therefore, when a BFD session transitions from Up to Down, action
   SHOULD be taken in the control protocol to signal the lack of
   connectivity for the path in the topology over which BFD is running.
   Generally, this can be done without impacting the connectivity of
   other topologies (since otherwise it is very difficult to support
   separate topologies for multiple data protocols).

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.3.%20%20Interactions%20with%20Graceful%20Restart%20Mechanisms"></a><a class="selflink" href="#section-4.3" name="section-4.3">4.3</a>.  Interactions with Graceful Restart Mechanisms</span>

   A number of control protocols support Graceful Restart mechanisms,
   including IS-IS [<a href="#ref-ISIS-GRACE" title='"Restart Signaling for IS-IS"'>ISIS-GRACE</a>], OSPF [<a href="#ref-OSPF-GRACE" title='"Graceful OSPF Restart"'>OSPF-GRACE</a>], and BGP [<a href="#ref-BGP-GRACE" title='"Graceful Restart Mechanism for BGP"'>BGP-GRACE</a>].
   These mechanisms are designed to allow a control protocol to restart
   without perturbing network connectivity state (lest it appear that
   the system and/or all of its links had failed).  They are predicated
   on the existence of a separate forwarding plane that does not
   necessarily share fate with the control plane in which the routing
   protocols operate.  In particular, the assumption is that the
   forwarding plane can continue to function while the protocols restart
   and sort things out.

   BFD implementations announce via the Control Plane Independent "C"
   bit whether or not BFD shares fate with the control plane.  This



<span class="grey">Katz &amp; Ward                  Standards Track                    [Page 8]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-9" id="page-9" name="page-9"> </a>
<span class="grey"><a href="rfc5882.html">RFC 5882</a>               Generic Application of BFD              June 2010</span>


   information is used to determine the actions to be taken in
   conjunction with Graceful Restart.  If BFD does not share its fate
   with the control plane on either system, it can be used to determine
   whether Graceful Restart in a control protocol is NOT viable (the
   forwarding plane is not operating).

   If the control protocol has a Graceful Restart mechanism, BFD may be
   used in conjunction with this mechanism.  The interaction between BFD
   and the control protocol depends on the capabilities of the control
   protocol and whether or not BFD shares fate with the control plane.
   In particular, it may be desirable for a BFD session failure to abort
   the Graceful Restart process and allow the failure to be visible to
   the network.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/4.3.1.%20%20BFD%20Fate%20Independent%20of%20the%20Control%20Plane"></a><a class="selflink" href="#section-4.3.1" name="section-4.3.1">4.3.1</a>.  BFD Fate Independent of the Control Plane</span>

   If BFD is implemented in the forwarding plane and does not share fate
   with the control plane on either system (the "C" bit is set in the
   BFD Control packets in both directions), control protocol restarts
   should not affect the BFD session.  In this case, a BFD session
   failure implies that data can no longer be forwarded, so any Graceful
   Restart in progress at the time of the BFD session failure SHOULD be
   aborted in order to avoid black holes, and a topology change SHOULD
   be signaled in the control protocol.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/4.3.2.%20%20BFD%20Shares%20Fate%20with%20the%20Control%20Plane"></a><a class="selflink" href="#section-4.3.2" name="section-4.3.2">4.3.2</a>.  BFD Shares Fate with the Control Plane</span>

   If BFD shares fate with the control plane on either system (the "C"
   bit is clear in either direction), a BFD session failure cannot be
   disentangled from other events taking place in the control plane.  In
   many cases, the BFD session will fail as a side effect of the restart
   taking place.  As such, it would be best to avoid aborting any
   Graceful Restart taking place, if possible (since otherwise BFD and
   Graceful Restart cannot coexist).

   There is some risk in doing so, since a simultaneous failure or
   restart of the forwarding plane will not be detected, but this is
   always an issue when BFD shares fate with the control plane.

<span class="h5"><a class="dashAnchor" name="//apple_ref/Section/4.3.2.1.%20%20Control%20Protocols%20with%20Planned%20Restart%20Signaling"></a><a class="selflink" href="#section-4.3.2.1" name="section-4.3.2.1">4.3.2.1</a>.  Control Protocols with Planned Restart Signaling</span>

   Some control protocols can signal a planned restart prior to the
   restart taking place.  In this case, if a BFD session failure occurs
   during the restart, such a planned restart SHOULD NOT be aborted and
   the session failure SHOULD NOT result in a topology change being
   signaled in the control protocol.





<span class="grey">Katz &amp; Ward                  Standards Track                    [Page 9]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-10" id="page-10" name="page-10"> </a>
<span class="grey"><a href="rfc5882.html">RFC 5882</a>               Generic Application of BFD              June 2010</span>


<span class="h5"><a class="dashAnchor" name="//apple_ref/Section/4.3.2.2.%20%20Control%20Protocols%20without%20Planned%20Restart%20Signaling"></a><a class="selflink" href="#section-4.3.2.2" name="section-4.3.2.2">4.3.2.2</a>.  Control Protocols without Planned Restart Signaling</span>

   Control protocols that cannot signal a planned restart depend on the
   recently restarted system to signal the Graceful Restart prior to the
   control protocol adjacency timeout.  In most cases, whether the
   restart is planned or unplanned, it is likely that the BFD session
   will time out prior to the onset of Graceful Restart, in which case a
   topology change SHOULD be signaled in the control protocol as
   specified in <a href="#section-3.2">Section 3.2</a>.

   However, if the restart is in fact planned, an implementation MAY
   adjust the BFD session timing parameters prior to restarting in such
   a way that the Detection Time in each direction is longer than the
   restart period of the control protocol, providing the restarting
   system the same opportunity to enter Graceful Restart as it would
   have without BFD.  The restarting system SHOULD NOT send any BFD
   Control packets until there is a high likelihood that its neighbors
   know a Graceful Restart is taking place, as the first BFD Control
   packet will cause the BFD session to fail.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.4.%20%20Interactions%20with%20Multiple%20Control%20Protocols"></a><a class="selflink" href="#section-4.4" name="section-4.4">4.4</a>.  Interactions with Multiple Control Protocols</span>

   If multiple control protocols wish to establish BFD sessions with the
   same remote system for the same data protocol, all MUST share a
   single BFD session.

   If hierarchical or dependent layers of control protocols are in use
   (say, OSPF and Internal BGP (IBGP)), it may not be useful for more
   than one of them to interact with BFD.  In this example, because IBGP
   is dependent on OSPF for its routing information, the faster failure
   detection relayed to IBGP may actually be detrimental.  The cost of a
   peer state transition is high in BGP, and OSPF will naturally heal
   the path through the network if it were to receive the failure
   detection.

   In general, it is best for the protocol at the lowest point in the
   hierarchy to interact with BFD, and then to use existing interactions
   between the control protocols to effect changes as necessary.  This
   will provide the fastest possible failure detection and recovery in a
   network.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/5.%20%20Interactions%20with%20Non-Protocol%20Functions"></a><a class="selflink" href="#section-5" name="section-5">5</a>.  Interactions with Non-Protocol Functions</span>

   BFD session status may be used to affect other system functions that
   are not protocol based (for example, static routes).  If the path to
   a remote system fails, it may be desirable to avoid passing traffic





<span class="grey">Katz &amp; Ward                  Standards Track                   [Page 10]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-11" id="page-11" name="page-11"> </a>
<span class="grey"><a href="rfc5882.html">RFC 5882</a>               Generic Application of BFD              June 2010</span>


   to that remote system, so the local system may wish to take internal
   measures to accomplish this (such as withdrawing a static route and
   withdrawing that route from routing protocols).

   If it is known, or presumed, that the remote system is BFD capable
   and the BFD session is not in Up state, appropriate action SHOULD be
   taken (such as withdrawing a static route).

   If it is known, or presumed, that the remote system does not support
   BFD, action such as withdrawing a static route SHOULD NOT be taken.

   Bootstrapping of the BFD session in the non-protocol case is likely
   to be derived from configuration information.

   There is no need to exchange endpoints or discriminator values via
   any mechanism other than configuration (via Operational Support
   Systems or any other means) as the endpoints must be known and
   configured by the same means.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/6.%20%20Data%20Protocols%20and%20Demultiplexing"></a><a class="selflink" href="#section-6" name="section-6">6</a>.  Data Protocols and Demultiplexing</span>

   BFD is intended to protect a single "data protocol" and is
   encapsulated within that protocol.  A pair of systems may have
   multiple BFD sessions over the same topology if they support (and are
   encapsulated by) different protocols.  For example, if two systems
   have IPv4 and IPv6 running across the same link between them, these
   are considered two separate paths and require two separate BFD
   sessions.

   This same technique is used for more fine-grained paths.  For
   example, if multiple differentiated services [<a href="#ref-DIFFSERV" title='"Definition of the Differentiated Services Field (DS Field) in the IPv4 and IPv6 Headers"'>DIFFSERV</a>] are being
   operated over IPv4, an independent BFD session may be run for each
   service level.  The BFD Control packets must be marked in the same
   way as the data packets, partly to ensure as much fate sharing as
   possible between BFD and data traffic, and also to demultiplex the
   initial packet if the discriminator values have not been exchanged.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/7.%20%20Multiple%20Link%20Subnetworks"></a><a class="selflink" href="#section-7" name="section-7">7</a>.  Multiple Link Subnetworks</span>

   A number of technologies exist for aggregating multiple parallel
   links at layer N-1 and treating them as a single link at layer N.
   BFD may be used in a number of ways to protect the path at layer N.
   The exact mechanism used is outside the scope of this specification.
   However, this section provides examples of some possible deployment
   scenarios.  Other scenarios are possible and are not precluded.






<span class="grey">Katz &amp; Ward                  Standards Track                   [Page 11]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-12" id="page-12" name="page-12"> </a>
<span class="grey"><a href="rfc5882.html">RFC 5882</a>               Generic Application of BFD              June 2010</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/7.1.%20%20Complete%20Decoupling"></a><a class="selflink" href="#section-7.1" name="section-7.1">7.1</a>.  Complete Decoupling</span>

   The simplest approach is to simply run BFD over the layer N path,
   with no interaction with the layer N-1 mechanisms.  Doing so assumes
   that the layer N-1 mechanism will deal with connectivity issues in
   individual layer N-1 links.  BFD will declare a failure in the layer
   N path only when the session times out.

   This approach will work whether or not the layer N-1 neighbor is the
   same as the layer N neighbor.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/7.2.%20%20Layer%20N-1%20Hints"></a><a class="selflink" href="#section-7.2" name="section-7.2">7.2</a>.  Layer N-1 Hints</span>

   A slightly more intelligent approach than complete decoupling is to
   have the layer N-1 mechanism inform the layer N BFD when the
   aggregated link is no longer viable.  In this case, the BFD session
   will detect the failure more rapidly, as it need not wait for the
   session to time out.  This is analogous to triggering a session
   failure based on the hardware-detected failure of a single link.

   This approach will also work whether or not the layer N-1 neighbor is
   the same as the layer N neighbor.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/7.3.%20%20Aggregating%20BFD%20Sessions"></a><a class="selflink" href="#section-7.3" name="section-7.3">7.3</a>.  Aggregating BFD Sessions</span>

   Another approach would be to use BFD on each layer N-1 link and to
   aggregate the state of the multiple sessions into a single indication
   to the layer N clients.  This approach has the advantage that it is
   independent of the layer N-1 technology.  However, this approach only
   works if the layer N neighbor is the same as the layer N-1 neighbor
   (a single hop at layer N-1).

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/7.4.%20%20Combinations%20of%20Scenarios"></a><a class="selflink" href="#section-7.4" name="section-7.4">7.4</a>.  Combinations of Scenarios</span>

   Combinations of more than one of the scenarios listed above (or
   others) may be useful in some cases.  For example, if the layer N
   neighbor is not directly connected at layer N-1, a system might run a
   BFD session across each layer N-1 link to the immediate layer N-1
   neighbor and then run another BFD session to the layer N neighbor.
   The aggregate state of the layer N-1 BFD sessions could be used to
   trigger a layer N BFD session failure.










<span class="grey">Katz &amp; Ward                  Standards Track                   [Page 12]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-13" id="page-13" name="page-13"> </a>
<span class="grey"><a href="rfc5882.html">RFC 5882</a>               Generic Application of BFD              June 2010</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/8.%20%20Other%20Application%20Issues"></a><a class="selflink" href="#section-8" name="section-8">8</a>.  Other Application Issues</span>

   BFD can provide liveness detection for functions related to
   Operations, Administration, and Maintenance (OAM) in tunneling and
   pseudowire protocols.  Running BFD inside the tunnel is recommended,
   as it exercises more aspects of the path.  One way to accommodate
   this is to address BFD packets based on the tunnel endpoints,
   assuming that they are numbered.

   If a planned outage is to take place on a path over which BFD is run,
   it is preferable to take down the BFD session by going into AdminDown
   state prior to the outage.  The system asserting AdminDown SHOULD do
   so for at least one Detection Time in order to ensure that the remote
   system is aware of it.

   Similarly, if BFD is to be deconfigured from a system, it is
   desirable not to trigger any client application action.  Simply
   ceasing the transmission of BFD Control packets will cause the remote
   system to detect a session failure.  In order to avoid this, the
   system on which BFD is being deconfigured SHOULD put the session into
   AdminDown state and maintain this state for a Detection Time to
   ensure that the remote system is aware of it.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/9.%20%20Interoperability%20Issues"></a><a class="selflink" href="#section-9" name="section-9">9</a>.  Interoperability Issues</span>

   The BFD protocol itself is designed so that it will always
   interoperate at a basic level; asynchronous mode is mandatory and is
   always available, and other modes and functions are negotiated at run
   time.  Since the service provided by BFD is identical regardless of
   the variants used, the particular choice of BFD options has no
   bearing on interoperability.

   The interaction between BFD and other protocols and control functions
   is very loosely coupled.  The actions taken are based on existing
   mechanisms in those protocols and functions, so interoperability
   problems are very unlikely unless BFD is applied in contradictory
   ways (such as a BFD session failure causing one implementation to go
   down and another implementation to come up).  In fact, BFD may be
   advising one system for a particular control function but not the
   other; the only impact of this would be potentially asymmetric
   control protocol failure detection.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/10.%20%20Specific%20Protocol%20Interactions%20%28Non-Normative%29"></a><a class="selflink" href="#section-10" name="section-10">10</a>.  Specific Protocol Interactions (Non-Normative)</span>

   As noted above, there are no interoperability concerns regarding
   interactions between BFD and control protocols.  However, there is
   enough concern and confusion in this area so that it is worthwhile to
   provide examples of interactions with specific protocols.



<span class="grey">Katz &amp; Ward                  Standards Track                   [Page 13]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-14" id="page-14" name="page-14"> </a>
<span class="grey"><a href="rfc5882.html">RFC 5882</a>               Generic Application of BFD              June 2010</span>


   Since the interactions do not affect interoperability, they are non-
   normative.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/10.1.%20%20BFD%20Interactions%20with%20OSPFv2%2C%20OSPFv3%2C%20and%20IS-IS"></a><a class="selflink" href="#section-10.1" name="section-10.1">10.1</a>.  BFD Interactions with OSPFv2, OSPFv3, and IS-IS</span>

   The two versions of OSPF ([<a href="#ref-OSPFv2" title='"OSPF Version 2"'>OSPFv2</a>] and [<a href="#ref-OSPFv3" title='"OSPF for IPv6"'>OSPFv3</a>]), as well as IS-IS
   [<a href="#ref-ISIS" title='"Use of OSI IS-IS for routing in TCP/IP and dual environments"'>ISIS</a>], all suffer from an architectural limitation, namely that
   their Hello protocols are limited in the granularity of their failure
   detection times.  In particular, OSPF has a minimum detection time of
   two seconds, and IS-IS has a minimum detection time of one second.

   BFD may be used to achieve arbitrarily small detection times for
   these protocols by supplementing the Hello protocols used in each
   case.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/10.1.1.%20%20Session%20Establishment"></a><a class="selflink" href="#section-10.1.1" name="section-10.1.1">10.1.1</a>.  Session Establishment</span>

   The most obvious choice for triggering BFD session establishment with
   these protocols would be to use the discovery mechanism inherent in
   the Hello protocols in OSPF and IS-IS to bootstrap the establishment
   of the BFD session.  Any BFD sessions established to support OSPF and
   IS-IS across a single IP hop must operate in accordance with
   [<a href="#ref-BFD-1HOP" title='"Bidirectional Forwarding Detection (BFD) for IPv4 and IPv6 (Single Hop)"'>BFD-1HOP</a>].

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/10.1.2.%20%20Reaction%20to%20BFD%20State%20Changes"></a><a class="selflink" href="#section-10.1.2" name="section-10.1.2">10.1.2</a>.  Reaction to BFD State Changes</span>

   The basic mechanisms are covered in <a href="#section-3">Section 3</a> above.  At this time,
   OSPFv2 and OSPFv3 carry routing information for a single data
   protocol (IPv4 and IPv6, respectively) so when it is desired to
   signal a topology change after a BFD session failure, this should be
   done by tearing down the corresponding OSPF neighbor.

   IS-IS may be used to support only one data protocol, or multiple data
   protocols.  [<a href="#ref-ISIS" title='"Use of OSI IS-IS for routing in TCP/IP and dual environments"'>ISIS</a>] specifies a common topology for multiple data
   protocols, but work is under way to support multiple topologies.  If
   multiple topologies are used to support multiple data protocols (or
   multiple classes of service of the same data protocol), the topology-
   specific path associated with a failing BFD session should no longer
   be advertised in IS-IS Label Switched Paths (LSPs) in order to signal
   a lack of connectivity.  Otherwise, a failing BFD session should be
   signaled by simulating an IS-IS adjacency failure.

   OSPF has a planned restart signaling mechanism, whereas IS-IS does
   not.  The appropriate mechanisms outlined in <a href="#section-3.3">Section 3.3</a> should be
   used.






<span class="grey">Katz &amp; Ward                  Standards Track                   [Page 14]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-15" id="page-15" name="page-15"> </a>
<span class="grey"><a href="rfc5882.html">RFC 5882</a>               Generic Application of BFD              June 2010</span>


<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/10.1.3.%20%20OSPF%20Virtual%20Links"></a><a class="selflink" href="#section-10.1.3" name="section-10.1.3">10.1.3</a>.  OSPF Virtual Links</span>

   If it is desired to use BFD for failure detection of OSPF Virtual
   Links, the mechanism described in [<a href="#ref-BFD-MULTI" title='"Bidirectional Forwarding Detection (BFD) for Multihop Paths"'>BFD-MULTI</a>] MUST be used, since
   OSPF Virtual Links may traverse an arbitrary number of hops.  BFD
   authentication SHOULD be used and is strongly encouraged.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/10.2.%20%20Interactions%20with%20BGP"></a><a class="selflink" href="#section-10.2" name="section-10.2">10.2</a>.  Interactions with BGP</span>

   BFD may be useful with External Border Gateway Protocol (EBGP)
   sessions [<a href="#ref-BGP" title='"A Border Gateway Protocol 4 (BGP-4)"'>BGP</a>] in order to more rapidly trigger topology changes in
   the face of path failure.  As noted in <a href="#section-4.4">Section 4.4</a>, it is generally
   unwise for IBGP sessions to interact with BFD if the underlying IGP
   is already doing so.

   EBGP sessions being advised by BFD may establish either a one-hop
   [<a href="#ref-BFD-1HOP" title='"Bidirectional Forwarding Detection (BFD) for IPv4 and IPv6 (Single Hop)"'>BFD-1HOP</a>] or a multihop [<a href="#ref-BFD-MULTI" title='"Bidirectional Forwarding Detection (BFD) for Multihop Paths"'>BFD-MULTI</a>] session, depending on whether or
   not the neighbor is immediately adjacent.  The BFD session should be
   established to the BGP neighbor (as opposed to any other Next Hop
   advertised in BGP).  BFD authentication SHOULD be used and is
   strongly encouraged.

   [<a id="ref-BGP-GRACE" name="ref-BGP-GRACE">BGP-GRACE</a>] describes a Graceful Restart mechanism for BGP.  If
   Graceful Restart is not taking place on an EBGP session, and the
   corresponding BFD session fails, the EBGP session should be torn down
   in accordance with <a href="#section-3.2">Section 3.2</a>.  If Graceful Restart is taking place,
   the basic procedures in <a href="#section-4.3">Section 4.3</a> apply.  BGP Graceful Restart does
   not signal planned restarts, so <a href="#section-4.3.2.2">Section 4.3.2.2</a> applies.  If Graceful
   Restart is aborted due to the rules described in <a href="#section-4.3">Section 4.3</a>, the
   "receiving speaker" should act as if the "restart timer" expired (as
   described in [<a href="#ref-BGP-GRACE" title='"Graceful Restart Mechanism for BGP"'>BGP-GRACE</a>]).

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/10.3.%20%20Interactions%20with%20RIP"></a><a class="selflink" href="#section-10.3" name="section-10.3">10.3</a>.  Interactions with RIP</span>

   The Routing Information Protocol (RIP) [<a href="#ref-RIP" title='"RIP Version 2"'>RIP</a>] is somewhat unique in
   that, at least as specified, neighbor adjacency state is not stored
   per se.  Rather, installed routes contain a next hop address, which
   in most cases is the address of the advertising neighbor (but may not
   be).

   In the case of RIP, when the BFD session associated with a neighbor
   fails, an expiration of the "timeout" timer for each route installed
   from the neighbor (for which the neighbor is the next hop) should be
   simulated.

   Note that if a BFD session fails, and a route is received from that
   neighbor with a next hop address that is not the address of the
   neighbor itself, the route will linger until it naturally times out



<span class="grey">Katz &amp; Ward                  Standards Track                   [Page 15]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-16" id="page-16" name="page-16"> </a>
<span class="grey"><a href="rfc5882.html">RFC 5882</a>               Generic Application of BFD              June 2010</span>


   (after 180 seconds).  However, if an implementation keeps track of
   all of the routes received from each neighbor, all of the routes from
   the neighbor corresponding to the failed BFD session should be timed
   out, regardless of the next hop specified therein, and thereby
   avoiding the lingering route problem.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/11.%20%20Security%20Considerations"></a><a class="selflink" href="#section-11" name="section-11">11</a>.  Security Considerations</span>

   This specification does not raise any additional security issues
   beyond those of the specifications referred to in the list of
   normative references.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/12.%20%20References"></a><a class="selflink" href="#section-12" name="section-12">12</a>.  References</span>

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/12.1.%20%20Normative%20References"></a><a class="selflink" href="#section-12.1" name="section-12.1">12.1</a>.  Normative References</span>

   [<a id="ref-BFD" name="ref-BFD">BFD</a>]        Katz, D. and D. Ward, "Bidirectional Forwarding
                Detection", <a href="rfc5880.html">RFC 5880</a>, June 2010.

   [<a id="ref-BFD-1HOP" name="ref-BFD-1HOP">BFD-1HOP</a>]   Katz, D. and D. Ward,"Bidirectional Forwarding Detection
                (BFD) for IPv4 and IPv6 (Single Hop)", <a href="rfc5881.html">RFC 5881</a>, June
                2010.

   [<a id="ref-BFD-MPLS" name="ref-BFD-MPLS">BFD-MPLS</a>]   Aggarwal, R., Kompella, K., Nadeau, T., and G. Swallow,
                "Bidirectional Forwarding Detection (BFD) for MPLS Label
                Switched Paths (LSPs)", <a href="rfc5884.html">RFC 5884</a>, June 2010.

   [<a id="ref-BFD-MULTI" name="ref-BFD-MULTI">BFD-MULTI</a>]  Katz, D. and D. Ward, "Bidirectional Forwarding
                Detection (BFD) for Multihop Paths", <a href="rfc5883.html">RFC 5883</a>, June
                2010.

   [<a id="ref-KEYWORDS" name="ref-KEYWORDS">KEYWORDS</a>]   Bradner, S., "Key words for use in RFCs to Indicate
                Requirement Levels", <a href="http://tools.ietf.org/html/bcp14">BCP 14</a>, <a href="rfc2119.html">RFC 2119</a>, March 1997.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/12.2.%20%20Informative%20References"></a><a class="selflink" href="#section-12.2" name="section-12.2">12.2</a>.  Informative References</span>

   [<a id="ref-BGP" name="ref-BGP">BGP</a>]        Rekhter, Y., Ed., Li, T., Ed., and S. Hares, Ed., "A
                Border Gateway Protocol 4 (BGP-4)", <a href="rfc4271.html">RFC 4271</a>, January
                2006.

   [<a id="ref-BGP-GRACE" name="ref-BGP-GRACE">BGP-GRACE</a>]  Sangli, S., Chen, E., Fernando, R., Scudder, J., and Y.
                Rekhter, "Graceful Restart Mechanism for BGP", <a href="rfc4724.html">RFC 4724</a>,
                January 2007.

   [<a id="ref-DIFFSERV" name="ref-DIFFSERV">DIFFSERV</a>]   Nichols, K., Blake, S., Baker, F., and D. Black,
                "Definition of the Differentiated Services Field (DS
                Field) in the IPv4 and IPv6 Headers", <a href="rfc2474.html">RFC 2474</a>, December
                1998.



<span class="grey">Katz &amp; Ward                  Standards Track                   [Page 16]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-17" id="page-17" name="page-17"> </a>
<span class="grey"><a href="rfc5882.html">RFC 5882</a>               Generic Application of BFD              June 2010</span>


   [<a id="ref-ISIS" name="ref-ISIS">ISIS</a>]       Callon, R., "Use of OSI IS-IS for routing in TCP/IP and
                dual environments", <a href="rfc1195.html">RFC 1195</a>, December 1990.

   [<a id="ref-ISIS-GRACE" name="ref-ISIS-GRACE">ISIS-GRACE</a>] Shand, M. and L. Ginsberg, "Restart Signaling for
                IS-IS", <a href="rfc5306.html">RFC 5306</a>, October 2008.

   [<a id="ref-OSPFv2" name="ref-OSPFv2">OSPFv2</a>]     Moy, J., "OSPF Version 2", STD 54, <a href="rfc2328.html">RFC 2328</a>, April 1998.

   [<a id="ref-OSPFv3" name="ref-OSPFv3">OSPFv3</a>]     Coltun, R., Ferguson, D., Moy, J., and A. Lindem, "OSPF
                for IPv6", <a href="rfc5340.html">RFC 5340</a>, July 2008.

   [<a id="ref-OSPF-GRACE" name="ref-OSPF-GRACE">OSPF-GRACE</a>] Moy, J., Pillay-Esnault, P., and A. Lindem, "Graceful
                OSPF Restart", <a href="rfc3623.html">RFC 3623</a>, November 2003.

   [<a id="ref-RIP" name="ref-RIP">RIP</a>]        Malkin, G., "RIP Version 2", STD 56, <a href="rfc2453.html">RFC 2453</a>, November
                1998.

Authors' Addresses

   Dave Katz
   Juniper Networks
   1194 N. Mathilda Ave.
   Sunnyvale, CA  94089-1206
   USA

   Phone: +1-408-745-2000
   EMail: dkatz@juniper.net


   Dave Ward
   Juniper Networks
   1194 N. Mathilda Ave.
   Sunnyvale, CA  94089-1206
   USA

   Phone: +1-408-745-2000
   EMail: dward@juniper.net














Katz &amp; Ward                  Standards Track                   [Page 17]

</pre><br/>
<span class="noprint"><small><small>Html markup produced by rfcmarkup 1.106, available from
<a href="http://tools.ietf.org/tools/rfcmarkup/">http://tools.ietf.org/tools/rfcmarkup/</a>
</small></small></span>


<meta content="text/html;charset=utf-8" http-equiv="content-type"/><!-- /Added by HTTrack -->

</body><!-- Mirrored from tools.ietf.org/html/rfc5882 by HTTrack Website Copier/3.x [XR&CO'2010], Wed, 19 Mar 2014 18:36:00 GMT --><!-- Added by HTTrack --></html>