<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml"><head profile="http://dublincore.org/documents/2008/08/04/dc-html/">
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
    <meta content="index,follow" name="robots"/>
    <meta content="rfcmarkup version 1.107" name="creator"/>
    <link href="http://purl.org/dc/elements/1.1/" rel="schema.DC"/>
<meta content="rfc2280" name="DC.Relation.Replaces"/>
<meta content="urn:ietf:rfc:2622" name="DC.Identifier"/>
<meta content="June, 1999" name="DC.Date.Issued"/>
<meta content="Villamizar, Curtis" name="DC.Creator"/>
<meta content="Bates, Tony" name="DC.Creator"/>
<meta content="Meyer, David" name="DC.Creator"/>
<meta content="Karrenberg, Daniel" name="DC.Creator"/>
<meta content="Terpstra, Marten" name="DC.Creator"/>
<meta content="Gerich, Elise" name="DC.Creator"/>
<meta content="Alaettinoglu, Cengiz" name="DC.Creator"/>
<meta content="Kessens, David" name="DC.Creator"/>
<meta content="RPSL allows a network operator to be able to specify routing policies\nat various levels in the Internet hierarchy; for example at the\nAutonomous System (AS) level. At the same time, policies can be\nspecified with sufficient detail in RPSL so that low level router\nconfigurations can be generated from them. RPSL is extensible; new\nrouting protocols and new protocol features can be introduced at any\ntime. [STANDARDS-TRACK]" name="DC.Description.Abstract"/>
<meta content="Routing Policy Specification Language (RPSL)" name="DC.Title"/>

    <link href="http://tools.ietf.org/images/rfc.png" rel="icon" type="image/png"/>
    <link href="http://tools.ietf.org/images/rfc.png" rel="shortcut icon" type="image/png"/>
    <title>RFC 2622 - Routing Policy Specification Language (RPSL)</title>
    
    
    <style type="text/css">
	body {
	    margin: 0px 8px;
            font-size: 1em;
	}
        h1, h2, h3, h4, h5, h6, .h1, .h2, .h3, .h4, .h5, .h6 {
	    font-weight: bold;
            line-height: 0pt;
            display: inline;
            white-space: pre;
            font-family: monospace;
            font-size: 1em;
	    font-weight: bold;
        }
        pre {
            font-size: 1em;
            margin-top: 0px;
            margin-bottom: 0px;
        }
	.pre {
	    white-space: pre;
	    font-family: monospace;
	}
	.header{
	    font-weight: bold;
	}
        .newpage {
            page-break-before: always;
        }
        .invisible {
            text-decoration: none;
            color: white;
        }
        a.selflink {
          color: black;
          text-decoration: none;
        }
        @media print {
            body {
                font-family: monospace;
                font-size: 10.5pt;
            }
            h1, h2, h3, h4, h5, h6 {
                font-size: 1em;
            }
        
            a:link, a:visited {
                color: inherit;
                text-decoration: none;
            }
            .noprint {
                display: none;
            }
        }
	@media screen {
	    .grey, .grey a:link, .grey a:visited {
		color: #777;
	    }
            .docinfo {
                background-color: #EEE;
            }
            .top {
                border-top: 7px solid #EEE;
            }
            .bgwhite  { background-color: white; }
            .bgred    { background-color: #F44; }
            .bggrey   { background-color: #666; }
            .bgbrown  { background-color: #840; }            
            .bgorange { background-color: #FA0; }
            .bgyellow { background-color: #EE0; }
            .bgmagenta{ background-color: #F4F; }
            .bgblue   { background-color: #66F; }
            .bgcyan   { background-color: #4DD; }
            .bggreen  { background-color: #4F4; }

            .legend   { font-size: 90%; }
            .cplate   { font-size: 70%; border: solid grey 1px; }
	}
    </style>
    <!--[if IE]>
    <style>
    body {
       font-size: 13px;
       margin: 10px 10px;
    }
    </style>
    <![endif]-->

    <script type="text/javascript"><!--
    function addHeaderTags() {
	var spans = document.getElementsByTagName("span");
	for (var i=0; i < spans.length; i++) {
	    var elem = spans[i];
	    if (elem) {
		var level = elem.getAttribute("class");
                if (level == "h1" || level == "h2" || level == "h3" || level == "h4" || level == "h5" || level == "h6") {
                    elem.innerHTML = "<"+level+">"+elem.innerHTML+"</"+level+">";		
                }
	    }
	}
    }
    var legend_html = "Colour legend:<br />      <table>         <tr><td>Unknown:</td>                   <td><span class='cplate bgwhite'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft:</td>                     <td><span class='cplate bgred'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Informational:</td>             <td><span class='cplate bgorange'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Experimental:</td>              <td><span class='cplate bgyellow'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Best Common Practice:</td>      <td><span class='cplate bgmagenta'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Proposed Standard:</td>         <td><span class='cplate bgblue'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft Standard (old designation):</td> <td><span class='cplate bgcyan'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Internet Standard:</td>         <td><span class='cplate bggreen'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Historic:</td>                  <td><span class='cplate bggrey'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Obsolete:</td>                  <td><span class='cplate bgbrown'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>     </table>";
    function showElem(id) {
        var elem = document.getElementById(id);
        elem.innerHTML = eval(id+"_html");
        elem.style.visibility='visible';
    }
    function hideElem(id) {
        var elem = document.getElementById(id);
        elem.style.visibility='hidden';        
        elem.innerHTML = "";
    }
    // -->
    </script>
</head>
<body onload="addHeaderTags()">
   <div style="height: 13px;">
      <div class="pre noprint docinfo bgblue" onclick="showElem('legend');" onmouseout="hideElem('legend')" onmouseover="this.style.cursor='pointer';" style="height: 6px; position: absolute;" title="Click for colour legend.">                                                                        </div>
      <div class="docinfo noprint pre legend" id="legend" onmouseout="hideElem('legend');" onmouseover="showElem('legend');" style="position:absolute; top: 4px; left: 4ex; visibility:hidden; background-color: white; padding: 4px 9px 5px 7px; border: solid #345 1px; ">
      </div>
   </div>
<span class="pre noprint docinfo top">[<a href="index.html" title="Document search and retrieval page">Docs</a>] [<a href="http://tools.ietf.org/rfc/rfc2622.txt" title="Plaintext version of this document">txt</a>|<a href="http://tools.ietf.org/pdf/rfc2622" title="PDF version of this document">pdf</a>] [<a href="http://tools.ietf.org/html/draft-ietf-rps-rpsl-v2" title="draft-ietf-rps-rpsl-v2">draft-ietf-rps-rp...</a>] [<a href="http://tools.ietf.org/rfcdiff?difftype=--hwdiff&amp;url2=rfc2622" title="Inline diff (wdiff)">Diff1</a>] [<a href="http://tools.ietf.org/rfcdiff?url2=rfc2622" title="Side-by-side diff">Diff2</a>]                 </span><br/>
<span class="pre noprint docinfo">                                                                        </span><br/>
<span class="pre noprint docinfo">Updated by: <a href="rfc4012.html">4012</a>                                       PROPOSED STANDARD</span><br/>
<span class="pre noprint docinfo">                                                                        </span><br/>
<pre>Network Working Group                                   C. Alaettinoglu
Request for Comments: 2622           USC/Information Sciences Institute
Obsoletes: <a href="rfc2280.html">2280</a>                                           C. Villamizar
Category: Standards Track                                 Avici Systems
                                                              E. Gerich
                                                        At Home Network
                                                             D. Kessens
                                                   Qwest Communications
                                                               D. Meyer
                                                   University of Oregon
                                                               T. Bates
                                                          Cisco Systems
                                                          D. Karrenberg
                                                               RIPE NCC
                                                            M. Terpstra
                                                           Bay Networks
                                                              June 1999


              <span class="h1">Routing Policy Specification Language (RPSL)</span>

Status of this Memo

   This document specifies an Internet standards track protocol for the
   Internet community, and requests discussion and suggestions for
   improvements.  Please refer to the current edition of the "Internet
   Official Protocol Standards" (STD 1) for the standardization state
   and status of this protocol.  Distribution of this memo is unlimited.

Copyright Notice

   Copyright (C) The Internet Society (1999).  All Rights Reserved.

Abstract

   RPSL allows a network operator to be able to specify routing policies
   at various levels in the Internet hierarchy; for example at the
   Autonomous System (AS) level.  At the same time, policies can be
   specified with sufficient detail in RPSL so that low level router
   configurations can be generated from them.  RPSL is extensible; new
   routing protocols and new protocol features can be introduced at any
   time.









<span class="grey">Alaettinoglu, et al.        Standards Track                     [Page 1]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-2" id="page-2" name="page-2"> </a>
<span class="grey"><a href="rfc2622.html">RFC 2622</a>                          RPSL                         June 1999</span>


Table of Contents

   1 Introduction                                                      3
   2 RPSL Names, Reserved Words, and Representation                    4
   3 Contact Information                                               7
     <a href="#section-3.1">3.1</a> mntner Class . . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-7">7</a>
     <a href="#section-3.2">3.2</a> person Class . . . . . . . . . . . . . . . . . . . . . . . . <a href="#page-10">10</a>
     <a href="#section-3.3">3.3</a> role Class . . . . . . . . . . . . . . . . . . . . . . . . . <a href="#page-11">11</a>
   4 route Class                                                      12
   5 Set Classes                                                      13
     <a href="#section-5.1">5.1</a> as-set Class . . . . . . . . . . . . . . . . . . . . . . . . <a href="#page-14">14</a>
     <a href="#section-5.2">5.2</a> route-set Class. . . . . . . . . . . . . . . . . . . . . . . <a href="#page-15">15</a>
     <a href="#section-5.3">5.3</a> Predefined Set Objects . . . . . . . . . . . . . . . . . . . <a href="#page-17">17</a>
     <a href="#section-5.4">5.4</a> Filters and filter-set Class . . . . . . . . . . . . . . . . <a href="#page-17">17</a>
     <a href="#section-5.5">5.5</a> rtr-set Class. . . . . . . . . . . . . . . . . . . . . . . . <a href="#page-22">22</a>
     <a href="#section-5.6">5.6</a> Peerings and peering-set Class . . . . . . . . . . . . . . . <a href="#page-24">24</a>
   6 aut-num Class                                                    27
     <a href="#section-6.1">6.1</a> import Attribute:  Import Policy Specification . . . . . . . <a href="#page-27">27</a>
       <a href="#section-6.1.1">6.1.1</a> Action Specification . . . . . . . . . . . . . . . . . . <a href="#page-28">28</a>
     <a href="#section-6.2">6.2</a> export Attribute:  Export Policy Specification . . . . . . . <a href="#page-29">29</a>
      6.3 Other Routing Protocols, Multi-Protocol Routing Protocols,
       and Injecting Routes Between Protocols . . . . . . . . . . . . <a href="#page-29">29</a>
     <a href="#section-6.4">6.4</a> Ambiguity Resolution . . . . . . . . . . . . . . . . . . . . <a href="#page-31">31</a>
     <a href="#section-6.5">6.5</a> default Attribute: Default Policy Specification  . . . . . . <a href="#page-33">33</a>
     <a href="#section-6.6">6.6</a> Structured Policy Specification. . . . . . . . . . . . . . . <a href="#page-33">33</a>
   7 dictionary Class                                                 37
     7.1 Initial RPSL Dictionary and Example Policy Actions and
       Filters. . . . . . . . . . . . . . . . . . . . . . . . . . . . <a href="#page-41">41</a>
   8 Advanced route Class                                             45
     <a href="#section-8.1">8.1</a> Specifying Aggregate Routes. . . . . . . . . . . . . . . . . <a href="#page-45">45</a>
       8.1.1Interaction with policies in aut-num class. . . . . . . . <a href="#page-49">49</a>
       8.1.2Ambiguity resolution with overlapping aggregates. . . . . <a href="#page-50">50</a>
     <a href="#section-8.2">8.2</a> Specifying Static Routes . . . . . . . . . . . . . . . . . . <a href="#page-52">52</a>
   9 inet-rtr Class                                                   52
   10 Extending RPSL                                                  54
     <a href="#section-10.1">10.1</a> Extensions by changing the dictionary class . . . . . . . . <a href="#page-54">54</a>
     <a href="#section-10.2">10.2</a> Extensions by adding new attributes to existing classes . . <a href="#page-55">55</a>
     <a href="#section-10.3">10.3</a> Extensions by adding new classes  . . . . . . . . . . . . . <a href="#page-55">55</a>
     10.4 Extensions by changing the syntax of existing RPSL
        attributes. . . . . . . . . . . . . . . . . . . . . . . . . . <a href="#page-55">55</a>
   11 Security Considerations                                         56
   12 Acknowledgements                                                56
   References                                                         56
   A Routing Registry Sites                                           59
   B Grammar Rules                                                    59
   C Changes from <a href="rfc2280.html">RFC 2280</a>                                            67
   D Authors' Addresses                                               68
   Full Copyright Statement                                           69



<span class="grey">Alaettinoglu, et al.        Standards Track                     [Page 2]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-3" id="page-3" name="page-3"> </a>
<span class="grey"><a href="rfc2622.html">RFC 2622</a>                          RPSL                         June 1999</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/1%20Introduction"></a><a class="selflink" href="#section-1" name="section-1">1</a> Introduction</span>

   This memo is the reference document for the Routing Policy
   Specification Language (RPSL).  RPSL allows a network operator to be
   able to specify routing policies at various levels in the Internet
   hierarchy; for example at the Autonomous System (AS) level.  At the
   same time, policies can be specified with sufficient detail in RPSL
   so that low level router configurations can be generated from them.
   RPSL is extensible; new routing protocols and new protocol features
   can be introduced at any time.

   RPSL is a replacement for the current Internet policy specification
   language known as RIPE-181 [<a href="#ref-6" title=" M. Terpstra">6</a>] or <a href="rfc1786.html">RFC-1786</a> [<a href="#ref-7" title='" Representation of IP Routing Policies in a Routing Registry"'>7</a>].  RIPE-81 [<a href="#ref-8" title="P. Lothberg">8</a>] was the
   first language deployed in the Internet for specifying routing
   policies.  It was later replaced by RIPE-181 [<a href="#ref-6" title=" M. Terpstra">6</a>].  Through
   operational use of RIPE-181 it has become apparent that certain
   policies cannot be specified and a need for an enhanced and more
   generalized language is needed.  RPSL addresses RIPE-181's
   limitations.

   RPSL was designed so that a view of the global routing policy can be
   contained in a single cooperatively maintained distributed database
   to improve the integrity of Internet's routing.  RPSL is not designed
   to be a router configuration language.  RPSL is designed so that
   router configurations can be generated from the description of the
   policy for one autonomous system (aut-num class) combined with the
   description of a router (inet-rtr class), mainly providing router ID,
   autonomous system number of the router, interfaces and peers of the
   router, and combined with a global database mappings from AS sets to
   ASes (as-set class), and from origin ASes and route sets to route
   prefixes (route and route-set classes).  The accurate population of
   the RPSL database can help contribute toward such goals as router
   configurations that protect against accidental (or malicious)
   distribution of inaccurate routing information, verification of
   Internet's routing, and aggregation boundaries beyond a single AS.

   RPSL is object oriented; that is, objects contain pieces of policy
   and administrative information.  These objects are registered in the
   Internet Routing Registry (IRR) by the authorized organizations.  The
   registration process is beyond the scope of this document.  Please
   refer to [<a href="#ref-1">1</a>, <a href="#ref-17" title='"Domain names - concepts and facilities"'>17</a>, <a href="#ref-4" title="D. Meyer">4</a>] for more details on the IRR.

   In the following sections, we present the classes that are used to
   define various policy and administrative objects.  The "mntner" class
   defines entities authorized to add, delete and modify a set of
   objects.  The "person" and "role" classes describes technical and
   administrative contact personnel.  Autonomous systems (ASes) are
   specified using the "aut-num" class.  Routes are specified using the



<span class="grey">Alaettinoglu, et al.        Standards Track                     [Page 3]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-4" id="page-4" name="page-4"> </a>
<span class="grey"><a href="rfc2622.html">RFC 2622</a>                          RPSL                         June 1999</span>


   "route" class.  Sets of objects can be defined using the "as-set",
   "route-set", "filter-set", "peering-set", and "rtr-set" classes.  The
   "dictionary" class provides the extensibility to the language.  The
   "inet-rtr" class is used to specify routers.  Many of these classes
   were originally defined in earlier documents [<a href="#ref-6" title=" M. Terpstra">6</a>, <a href="#ref-13" title="Netherlands">13</a>, <a href="#ref-16" title="Netherlands">16</a>, <a href="#ref-12" title="RIPE">12</a>, <a href="#ref-5" title=" Netherlands">5</a>] and
   have all been enhanced.

   This document is self-contained.  However, the reader is encouraged
   to read RIPE-181 [<a href="#ref-7" title='" Representation of IP Routing Policies in a Routing Registry"'>7</a>] and the associated documents [<a href="#ref-13" title="Netherlands">13</a>, <a href="#ref-16" title="Netherlands">16</a>, <a href="#ref-12" title="RIPE">12</a>, <a href="#ref-5" title=" Netherlands">5</a>] as
   they provide significant background as to the motivation and
   underlying principles behind RIPE-181 and consequently, RPSL. For a
   tutorial on RPSL, the reader should read the RPSL applications
   document [<a href="#ref-4" title="D. Meyer">4</a>].

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/2%20RPSL%20Names%2C%20Reserved%20Words%2C%20and%20Representation"></a><a class="selflink" href="#section-2" name="section-2">2</a> RPSL Names, Reserved Words, and Representation</span>

   Each class has a set of attributes which store a piece of information
   about the objects of the class.  Attributes can be mandatory or
   optional: A mandatory attribute has to be defined for all objects of
   the class; optional attributes can be skipped.  Attributes can also
   be single or multiple valued.  Each object is uniquely identified by
   a set of attributes, referred to as the class "key".

   The value of an attribute has a type.  The following types are most
   widely used.  Note that RPSL is case insensitive and only the
   characters from the ASCII character set can be used.

   &lt;object-name&gt;
      Many objects in RPSL have a name.  An &lt;object-name&gt; is made up of
      letters, digits, the character underscore "_", and the character
      hyphen "-"; the first character of a name must be a letter, and
      the last character of a name must be a letter or a digit.  The
      following words are reserved by RPSL, and they can not be used as
      names:

          any as-any rs-any peeras
          and or not
          atomic from to at action accept announce except refine
          networks into inbound outbound

      Names starting with certain prefixes are reserved for certain
      object types.  Names starting with "as-" are reserved for as set
      names.  Names starting with "rs-" are reserved for route set
      names.  Names starting with "rtrs-" are reserved for router set
      names.  Names starting with "fltr-" are reserved for filter set
      names.  Names starting with "prng-" are reserved for peering set
      names.




<span class="grey">Alaettinoglu, et al.        Standards Track                     [Page 4]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-5" id="page-5" name="page-5"> </a>
<span class="grey"><a href="rfc2622.html">RFC 2622</a>                          RPSL                         June 1999</span>


   &lt;as-number&gt; An AS number x is represented as the string "ASx".  That
      is, the AS 226 is represented as AS226.

   &lt;ipv4-address&gt; An IPv4 address is represented as a sequence of four
      integers in the range from 0 to 255 separated by the character dot
      ".".  For example, 128.9.128.5 represents a valid IPv4 address.
      In the rest of this document, we may refer to IPv4 addresses as IP
      addresses.

   &lt;address-prefix&gt; An address prefix is represented as an IPv4 address
      followed by the character slash "/" followed by an integer in the
      range from 0 to 32.  The following are valid address prefixes:
      128.9.128.5/32, 128.9.0.0/16, 0.0.0.0/0; and the following address
      prefixes are invalid:  0/0, 128.9/16 since 0 or 128.9 are not
      strings containing four integers.

   &lt;address-prefix-range&gt; An address prefix range is an address prefix
      followed by an optional range operator.  The range operators are:

   ^- is the exclusive more specifics operator; it stands for the more
      specifics of the address prefix excluding the address prefix
      itself.  For example, 128.9.0.0/16^- contains all the more
      specifics of 128.9.0.0/16 excluding 128.9.0.0/16.

   ^+ is the inclusive more specifics operator; it stands for the more
      specifics of the address prefix including the address prefix
      itself.  For example, 5.0.0.0/8^+ contains all the more specifics
      of 5.0.0.0/8 including 5.0.0.0/8.

   ^n where n is an integer, stands for all the length n specifics of
      the address prefix.  For example, 30.0.0.0/8^16 contains all the
      more specifics of 30.0.0.0/8 which are of length 16 such as
      30.9.0.0/16.

   ^n-m where n and m are integers, stands for all the length n to
      length m specifics of the address prefix.  For example,
      30.0.0.0/8^24-32 contains all the more specifics of 30.0.0.0/8
      which are of length 24 to 32 such as 30.9.9.96/28.

   Range operators can also be applied to address prefix sets.  In this
   case, they distribute over the members of the set.  For example, for
   a route-set (defined later) rs-foo, rs-foo^+ contains all the
   inclusive more specifics of all the prefixes in rs-foo.

   It is an error to follow a range operator with another one (e.g.
   30.0.0.0/8^24-28^+ is an error).  However, a range operator can be
   applied to an address prefix set that has address prefix ranges in it
   (e.g. {30.0.0.0/8^24-28}^27-30 is not an error).  In this case, the



<span class="grey">Alaettinoglu, et al.        Standards Track                     [Page 5]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-6" id="page-6" name="page-6"> </a>
<span class="grey"><a href="rfc2622.html">RFC 2622</a>                          RPSL                         June 1999</span>


   outer operator ^n-m distributes over the inner operator ^k-l and
   becomes the operator ^max(n,k)-m if m is greater than or equal to
   max(n,k), or otherwise, the prefix is deleted from the set.  Note
   that the operator ^n is equivalent to ^n-n; prefix/l^+ is equivalent
   to prefix/l^l-32; prefix/l^- is equivalent to prefix/l^(l+1)-32;
   {prefix/l^n-m}^+ is equivalent to {prefix/l^n-32}; and {prefix/l^n-
   m}^- is equivalent to {prefix/l^(n+1)-32}.  For example,

                {128.9.0.0/16^+}^-     == {128.9.0.0/16^-}
                {128.9.0.0/16^-}^+     == {128.9.0.0/16^-}
                {128.9.0.0/16^17}^24   == {128.9.0.0/16^24}
                {128.9.0.0/16^20-24}^26-28 == {128.9.0.0/16^26-28}
                {128.9.0.0/16^20-24}^22-28 == {128.9.0.0/16^22-28}
                {128.9.0.0/16^20-24}^18-28 == {128.9.0.0/16^20-28}
                {128.9.0.0/16^20-24}^18-22 == {128.9.0.0/16^20-22}
                {128.9.0.0/16^20-24}^18-19 == {}

   &lt;date&gt;
      A date is represented as an eight digit integer of the form
      YYYYMMDD where YYYY represents the year, MM represents the month
      of the year (01 through 12), and DD represents the day of the
      month (01 through 31).  All dates are in UTC unless otherwise
      specified.  For example, June 24, 1996 is represented as 19960624.

   &lt;email-address&gt;is as described in <a href="rfc822.html">RFC-822</a> [<a href="#ref-10" title='"Standard for ARPA Internet Text Messages"'>10</a>].

   &lt;dns-name&gt;is as described in <a href="rfc1034.html">RFC-1034</a> [<a href="#ref-17" title='"Domain names - concepts and facilities"'>17</a>].

   &lt;nic-handle&gt; is a uniquely assigned identifier word used by routing,
      address allocation, and other registries to unambiguously refer to
      contact information.  Person and role classes map NIC handles to
      actual person names, and contact information.

   &lt;free-form&gt;is a sequence of ASCII characters.

   &lt;X-name&gt; is a name of an object of type X. That is &lt;mntner-name&gt; is a
      name of a mntner object.

   &lt;registry-name&gt; is a name of an IRR registry.  The routing registries
      are listed in <a href="#appendix-A">Appendix A</a>.

   A value of an attribute may also be a list of one of these types.  A
   list is represented by separating the list members by commas ",".
   For example, "AS1, AS2, AS3, AS4" is a list of AS numbers.  Note that
   being list valued and being multiple valued are orthogonal.  A
   multiple valued attribute has more than one value, each of which may
   or may not be a list.  On the other hand a single valued attribute
   may have a list value.



<span class="grey">Alaettinoglu, et al.        Standards Track                     [Page 6]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-7" id="page-7" name="page-7"> </a>
<span class="grey"><a href="rfc2622.html">RFC 2622</a>                          RPSL                         June 1999</span>


   An RPSL object is textually represented as a list of attribute-value
   pairs.  Each attribute-value pair is written on a separate line.  The
   attribute name starts at column 0, followed by character ":" and
   followed by the value of the attribute.  The attribute which has the
   same name as the object's class should be specified first.  The
   object's representation ends when a blank line is encountered.  An
   attribute's value can be split over multiple lines, by having a
   space, a tab or a plus ('+') character as the first character of the
   continuation lines.  The character "+" for line continuation allows
   attribute values to contain blank lines.  More spaces may optionally
   be used after the continuation character to increase readability.
   The order of attribute-value pairs is significant.

   An object's description may contain comments.  A comment can be
   anywhere in an object's definition, it starts at the first "#"
   character on a line and ends at the first end-of-line character.
   White space characters can be used to improve readability.

   An integer can be specified using (1) the C programming language
   notation (e.g. 1, 12345); (2) sequence of four 1-octet integers (in
   the range from 0 to 255) separated by the character dot "."  (e.g.
   1.1.1.1, 255.255.0.0), in this case a 4-octet integer is formed by
   concatenating these 1-octet integers in the most significant to least
   significant order; (3) sequence of two 2-octet integers (in the range
   from 0 to 65535) separated by the character colon ":" (e.g. 3561:70,
   3582:10), in this case a 4-octet integer is formed by concatenating
   these 2-octet integers in the most significant to least significant
   order.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/3%20Contact%20Information"></a><a class="selflink" href="#section-3" name="section-3">3</a> Contact Information</span>

   The mntner, person and role classes, admin-c, tech-c, mnt-by,
   changed, and source attributes of all classes describe contact
   information.  The mntner class also specifies authenticaiton
   information required to create, delete and update other objects.
   These classes do not specify routing policies and each registry may
   have different or additional requirements on them.  Here we present
   the common denominator for completeness which is the RIPE database
   implementation [<a href="#ref-16" title="Netherlands">16</a>].  Please consult your routing registry for the
   latest specification of these classes and attributes.  The "Routing
   Policy System Security" document [<a href="#ref-20" title="S. Murphy">20</a>] describes the authenticaiton
   and authorization model in more detail.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.1%20mntner%20Class"></a><a class="selflink" href="#section-3.1" name="section-3.1">3.1</a> mntner Class</span>

   The mntner class specifies authenticaiton information required to
   create, delete and update RPSL objects.  A provider, before he/she
   can create RPSL objects, first needs to create a mntner object.  The



<span class="grey">Alaettinoglu, et al.        Standards Track                     [Page 7]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-8" id="page-8" name="page-8"> </a>
<span class="grey"><a href="rfc2622.html">RFC 2622</a>                          RPSL                         June 1999</span>


   attributes of the mntner class are shown in Figure 1.  The mntner
   class was first described in [<a href="#ref-13" title="Netherlands">13</a>].

   The mntner attribute is mandatory and is the class key.  Its value is
   an RPSL name.  The auth attribute specifies the scheme that will be
   used to identify and authenticate update requests from this
   maintainer.  It has the following syntax:

   auth: &lt;scheme-id&gt; &lt;auth-info&gt;

   E.g.
          auth: NONE

  Attribute  Value                   Type
  mntner     &lt;object-name&gt;           mandatory, single-valued, class key
  descr      &lt;free-form&gt;             mandatory, single-valued
  auth       see description in text mandatory, multi-valued
  upd-to     &lt;email-address&gt;         mandatory, multi-valued
  mnt-nfy    &lt;email-address&gt;         optional, multi-valued
  tech-c     &lt;nic-handle&gt;            mandatory, multi-valued
  admin-c    &lt;nic-handle&gt;            optional, multi-valued
  remarks    &lt;free-form&gt;             optional, multi-valued
  notify     &lt;email-address&gt;         optional, multi-valued
  mnt-by     list of &lt;mntner-name&gt;   mandatory, multi-valued
  changed    &lt;email-address&gt; &lt;date&gt;  mandatory, multi-valued
  source     &lt;registry-name&gt;         mandatory, single-valued


                     Figure 1:  mntner Class Attributes


          auth: CRYPT-PW dhjsdfhruewf
          auth: MAIL-FROM .*@ripe\.net

   The &lt;scheme-id&gt;'s currently defined are: NONE, MAIL-FROM, PGP-KEY and
   CRYPT-PW. The &lt;auth-info&gt; is additional information required by a
   particular scheme: in the case of MAIL-FROM, it is a regular
   expression matching valid email addresses; in the case of CRYPT-PW,
   it is a password in UNIX crypt format; and in the case of PGP-KEY, it
   is a pointer to key-certif object [<a href="#ref-22" title='"PGP authentication for ripe database updates"'>22</a>] containing the PGP public key
   of the user.  If multiple auth attributes are specified, an update
   request satisfying any one of them is authenticated to be from the
   maintainer.

   The upd-to attribute is an email address.  On an unauthorized update
   attempt of an object maintained by this maintainer, an email message
   will be sent to this address.  The mnt-nfy attribute is an email
   address.  A notification message will be forwarded to this email



<span class="grey">Alaettinoglu, et al.        Standards Track                     [Page 8]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-9" id="page-9" name="page-9"> </a>
<span class="grey"><a href="rfc2622.html">RFC 2622</a>                          RPSL                         June 1999</span>


   address whenever an object maintained by this maintainer is added,
   changed or deleted.

   The descr attribute is a short, free-form textual description of the
   object.  The tech-c attribute is a technical contact NIC handle.
   This is someone to be contacted for technical problems such as
   misconfiguration.  The admin-c attribute is an administrative contact
   NIC handle.  The remarks attribute is a free text explanation or
   clarification.  The notify attribute is an email address to which
   notifications of changes to this object should be sent.  The mnt-by
   attribute is a list of mntner object names.  The authorization for
   changes to this object is governed by any of the maintainer objects
   referenced.  The changed attribute documents who last changed this
   object, and when this change was made.  Its syntax has the following
   form:

   changed: &lt;email-address&gt; &lt;YYYYMMDD&gt;

   E.g.
   changed: johndoe@terabit-labs.nn 19900401

   The &lt;email-address&gt; identifies the person who made the last change.
   &lt;YYYYMMDD&gt; is the date of the change.  The source attribute specifies
   the registry where the object is registered.  Figure 2 shows an
   example mntner object.  In the example, UNIX crypt format password
   authentication is used.

   mntner:      RIPE-NCC-MNT
   descr:       RIPE-NCC Maintainer
   admin-c:     DK58
   tech-c:      OPS4-RIPE
   upd-to:      ops@ripe.net
   mnt-nfy:     ops-fyi@ripe.net
   auth:        CRYPT-PW lz1A7/JnfkTtI
   mnt-by:      RIPE-NCC-MNT
   changed:     ripe-dbm@ripe.net 19970820
   source:      RIPE


                    Figure 2:  An example mntner object.

   The descr, tech-c, admin-c, remarks, notify, mnt-by, changed and
   source attributes are attributes of all RPSL classes.  Their syntax,
   semantics, and mandatory, optional, multi-valued, or single-valued
   status are the same for for all RPSL classes.  Only exception to this
   is the admin-c attribute which is mandatory for the aut-num class.
   We do not further discuss them in other sections.




<span class="grey">Alaettinoglu, et al.        Standards Track                     [Page 9]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-10" id="page-10" name="page-10"> </a>
<span class="grey"><a href="rfc2622.html">RFC 2622</a>                          RPSL                         June 1999</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.2%20person%20Class"></a><a class="selflink" href="#section-3.2" name="section-3.2">3.2</a> person Class</span>

   A person class is used to describe information about people.  Even
   though it does not describe routing policy, we still describe it here
   briefly since many policy objects make reference to person objects.
   The person class was first described in [<a href="#ref-15" title=" Netherlands">15</a>].

   The attributes of the person class are shown in Figure 3.  The person
   attribute is the full name of the person.  The phone and the fax-no
   attributes have the following syntax:

      phone: +&lt;country-code&gt; &lt;city&gt; &lt;subscriber&gt; [ext. &lt;extension&gt;]

   E.g.:
      phone: +31 20 12334676

  Attribute  Value                   Type
  person     &lt;free-form&gt;             mandatory, single-valued
  nic-hdl    &lt;nic-handle&gt;            mandatory, single-valued, class key
  address    &lt;free-form&gt;             mandatory, multi-valued
  phone      see description in text mandatory, multi-valued
  fax-no     same as phone           optional, multi-valued
  e-mail     &lt;email-address&gt;         mandatory, multi-valued


                     Figure 3:  person Class Attributes


      phone: +44 123 987654 ext. 4711

   Figure 4 shows an example person object.

   person:      Daniel Karrenberg
   address:     RIPE Network Coordination Centre (NCC)
   address:     Singel 258
   address:     NL-1016 AB  Amsterdam
   address:     Netherlands
   phone:       +31 20 535 4444
   fax-no:      +31 20 535 4445
   e-mail:      Daniel.Karrenberg@ripe.net
   nic-hdl:     DK58
   changed:     Daniel.Karrenberg@ripe.net 19970616
   source:      RIPE


                    Figure 4:  An example person object.





<span class="grey">Alaettinoglu, et al.        Standards Track                    [Page 10]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-11" id="page-11" name="page-11"> </a>
<span class="grey"><a href="rfc2622.html">RFC 2622</a>                          RPSL                         June 1999</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.3%20role%20Class"></a><a class="selflink" href="#section-3.3" name="section-3.3">3.3</a> role Class</span>

   The role class is similar to the person object.  However, instead of
   describing a human being, it describes a role performed by one or
   more human beings.  Examples include help desks, network monitoring
   centers, system administrators, etc.  Role object is particularly
   useful since often a person performing a role may change, however the
   role itself remains.

   The attributes of the role class are shown in Figure 5.  The nic-hdl
   attributes of the person and role classes share the same name space.
   The trouble attribute of role object may contain additional contact
   information to be used when a problem arises in any object that
   references this role object.  Figure 6 shows an example role object.

  Attribute  Value                    Type
  role       &lt;free-form&gt;              mandatory, single-valued
  nic-hdl    &lt;nic-handle&gt;             mandatory, single-valued,
                                      class key
  trouble    &lt;free-form&gt;              optional, multi-valued
  address    &lt;free-form&gt;              mandatory, multi-valued
  phone      see description in text  mandatory, multi-valued
  fax-no     same as phone            optional, multi-valued
  e-mail     &lt;email-address&gt;          mandatory, multi-valued


                      Figure 5:  role Class Attributes


   role:        RIPE NCC Operations
   trouble:
   address:     Singel 258
   address:     1016 AB Amsterdam
   address:     The Netherlands
   phone:       +31 20 535 4444
   fax-no:      +31 20 545 4445
   e-mail:      ops@ripe.net
   admin-c:     CO19-RIPE
   tech-c:      RW488-RIPE
   tech-c:      JLSD1-RIPE
   nic-hdl:     OPS4-RIPE
   notify:      ops@ripe.net
   changed:     roderik@ripe.net 19970926
   source:      RIPE


                     Figure 6:  An example role object.




<span class="grey">Alaettinoglu, et al.        Standards Track                    [Page 11]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-12" id="page-12" name="page-12"> </a>
<span class="grey"><a href="rfc2622.html">RFC 2622</a>                          RPSL                         June 1999</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/4%20route%20Class"></a><a class="selflink" href="#section-4" name="section-4">4</a> route Class</span>

   Each interAS route (also referred to as an interdomain route)
   originated by an AS is specified using a route object.  The
   attributes of the route class are shown in Figure 7.  The route
   attribute is the address prefix of the route and the origin attribute
   is the AS number of the AS that originates the route into the interAS
   routing system.  The route and origin attribute pair is the class
   key.

   Figure 8 shows examples of four route objects (we do not include
   contact attributes such as admin-c, tech-c for brevity).  Note that
   the last two route objects have the same address prefix, namely
   128.8.0.0/16.  However, they are different route objects since they
   are originated by different ASes (i.e. they have different keys).

   Attribute     Value                      Type
   route         &lt;address-prefix&gt;           mandatory, single-valued,
                                            class key
   origin        &lt;as-number&gt;                mandatory, single-valued,
                                            class key
   member-of     list of &lt;route-set-names&gt;  optional, multi-valued
                 see <a href="#section-5">Section 5</a>
   inject        see <a href="#section-8">Section 8</a>              optional, multi-valued
   components    see <a href="#section-8">Section 8</a>              optional, single-valued
   aggr-bndry    see <a href="#section-8">Section 8</a>              optional, single-valued
   aggr-mtd      see <a href="#section-8">Section 8</a>              optional, single-valued
   export-comps  see <a href="#section-8">Section 8</a>              optional, single-valued
   holes         see <a href="#section-8">Section 8</a>              optional, multi-valued


                        Figure 7:  route Class Attributes


      route: 128.9.0.0/16
      origin: AS226

      route: 128.99.0.0/16
      origin: AS226

      route: 128.8.0.0/16
      origin: AS1

      route: 128.8.0.0/16
      origin: AS2

                             Figure 8:  Route Objects




<span class="grey">Alaettinoglu, et al.        Standards Track                    [Page 12]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-13" id="page-13" name="page-13"> </a>
<span class="grey"><a href="rfc2622.html">RFC 2622</a>                          RPSL                         June 1999</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/5%20Set%20Classes"></a><a class="selflink" href="#section-5" name="section-5">5</a> Set Classes</span>

   To specify policies, it is often useful to define sets of objects.
   For this purpose we define as-set, route-set, rtr-set, filter-set,
   and peering-set classes.  These classes define a named set.  The
   members of these sets can be specified either directly by listing
   them in the sets' definition, or indirectly by having member objects
   refer to the sets' names, or a combination of both methods.

   A set's name is an rpsl word with the following restrictions: All
   as-set names start with prefix "as-".  All route-set names start with
   prefix "rs-".  All rtr-set names start with prefix "rtrs-".  All
   filter-set names start with prefix "fltr-".  All peering-set names
   start with prefix "prng-".  For example, as-foo is a valid as-set
   name.

   Set names can also be hierarchical.  A hierarchical set name is a
   sequence of set names and AS numbers separated by colons ":".  At
   least one component of such a name must be an actual set name (i.e.
   start with one of the prefixes above).  All the set name components
   of an hierarchical name has to be of the same type.  For example, the
   following names are valid: AS1:AS-CUSTOMERS, AS1:RS-EXPORT:AS2, RS-
   EXCEPTIONS:RS-BOGUS.

   The purpose of an hierarchical set name is to partition the set name
   space so that the maintainers of the set X1 controls the whole set
   name space underneath, i.e. X1:...:Xn-1.  Thus, a set object with
   name X1:...:Xn-1:Xn can only be created by the maintainer of the
   object with name X1:...:Xn-1.  That is, only the maintainer of AS1
   can create a set with name AS1:AS-FOO; and only the maintainer of
   AS1:AS-FOO can create a set with name AS1:AS-FOO:AS-BAR. Please see
   RPS Security Document [<a href="#ref-20" title="S. Murphy">20</a>] for details.



















<span class="grey">Alaettinoglu, et al.        Standards Track                    [Page 13]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-14" id="page-14" name="page-14"> </a>
<span class="grey"><a href="rfc2622.html">RFC 2622</a>                          RPSL                         June 1999</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.1%20as-set%20Class"></a><a class="selflink" href="#section-5.1" name="section-5.1">5.1</a> as-set Class</span>

   The attributes of the as-set class are shown in Figure 9.  The as-set
   attribute defines the name of the set.  It is an RPSL name that
   starts with "as-".  The members attribute lists the members of the
   set.  The members attribute is a list of AS numbers, or other as-set
   names.

      Attribute    Value                    Type
      as-set       &lt;object-name&gt;            mandatory, single-valued,
                                            class key
      members      list of &lt;as-numbers&gt; or  optional, multi-valued
                   &lt;as-set-names&gt;
      mbrs-by-ref  list of &lt;mntner-names&gt;   optional, multi-valued


                     Figure 9:  as-set Class Attributes

   Figure 10 presents two as-set objects.  The set as-foo contains two
   ASes, namely AS1 and AS2.  The set as-bar contains the members of the
   set as-foo and AS3, that is it contains AS1, AS2, AS3.  The set as-
   empty contains no members.

 as-set: as-foo           as-set: as-bar                as-set: as-empty
 members: AS1, AS2        members: AS3, as-foo


                        Figure 10:  as-set objects.

   The mbrs-by-ref attribute is a list of maintainer names or the
   keyword ANY.  If this attribute is used, the AS set also includes
   ASes whose aut-num objects are registered by one of these maintainers
   and whose member-of attribute refers to the name of this AS set.  If
   the value of a mbrs-by-ref attribute is ANY, any AS object referring
   to the AS set is a member of the set.  If the mbrs-by-ref attribute
   is missing, only the ASes listed in the members attribute are members
   of the set.

    as-set: as-foo
    members: AS1, AS2
    mbrs-by-ref: MNTR-ME

    aut-num: AS3                          aut-num: AS4
    member-of: as-foo                     member-of: as-foo
    mnt-by: MNTR-ME                       mnt-by: MNTR-OTHER


                           Figure 11:  as-set objects.



<span class="grey">Alaettinoglu, et al.        Standards Track                    [Page 14]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-15" id="page-15" name="page-15"> </a>
<span class="grey"><a href="rfc2622.html">RFC 2622</a>                          RPSL                         June 1999</span>


   Figure 11 presents an example as-set object that uses the mbrs-by-ref
   attribute.  The set as-foo contains AS1, AS2 and AS3.  AS4 is not a
   member of the set as-foo even though the aut-num object references
   as-foo.  This is because MNTR-OTHER is not listed in the as-foo's
   mbrs-by-ref attribute.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.2%20route-set%20Class"></a><a class="selflink" href="#section-5.2" name="section-5.2">5.2</a> route-set Class</span>

   The attributes of the route-set class are shown in Figure 12.  The
   route-set attribute defines the name of the set.  It is an RPSL name
   that starts with "rs-".  The members attribute lists the members of
   the set.  The members attribute is a list of address prefixes or
   other route-set names.  Note that, the route-set class is a set of
   route prefixes, not of RPSL route objects.

 Attribute    Value                              Type
 route-set    &lt;object-name&gt;                      mandatory,
                                                 single-valued,
                                                 class key
 members      list of &lt;address-prefix-range&gt; or  optional, multi-valued
              &lt;route-set-name&gt; or
              &lt;route-set-name&gt;&lt;range-operator&gt;
 mbrs-by-ref  list of &lt;mntner-names&gt;             optional, multi-valued


                   Figure 12:  route-set Class Attributes

   Figure 13 presents some example route-set objects.  The set rs-foo
   contains two address prefixes, namely 128.9.0.0/16 and 128.9.0.0/24.
   The set rs-bar contains the members of the set rs-foo and the address
   prefix 128.7.0.0/16.

   An address prefix or a route-set name in a members attribute can be
   optionally followed by a range operator.  For example, the following
   set:

   route-set: rs-foo
   members: 128.9.0.0/16, 128.9.0.0/24

   route-set: rs-bar
   members: 128.7.0.0/16, rs-foo


                       Figure 13:  route-set Objects







<span class="grey">Alaettinoglu, et al.        Standards Track                    [Page 15]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-16" id="page-16" name="page-16"> </a>
<span class="grey"><a href="rfc2622.html">RFC 2622</a>                          RPSL                         June 1999</span>


   route-set: rs-bar
   members: 5.0.0.0/8^+, 30.0.0.0/8^24-32, rs-foo^+

   contains all the more specifics of 5.0.0.0/8 including 5.0.0.0/8, all
   the more specifics of 30.0.0.0/8 which are of length 24 to 32 such as
   30.9.9.96/28, and all the more specifics of address prefixes in route
   set rs-foo.

   The mbrs-by-ref attribute is a list of maintainer names or the
   keyword ANY.  If this attribute is used, the route set also includes
   address prefixes whose route objects are registered by one of these
   maintainers and whose member-of attribute refers to the name of this
   route set.  If the value of a mbrs-by-ref attribute is ANY, any route
   object referring to the route set name is a member.  If the mbrs-by-
   ref attribute is missing, only the address prefixes listed in the
   members attribute are members of the set.


   route-set: rs-foo
   mbrs-by-ref: MNTR-ME, MNTR-YOU

   route-set: rs-bar
   members: 128.7.0.0/16
   mbrs-by-ref: MNTR-YOU

   route: 128.9.0.0/16
   origin: AS1
   member-of: rs-foo
   mnt-by: MNTR-ME

   route: 128.8.0.0/16
   origin: AS2
   member-of: rs-foo, rs-bar
   mnt-by: MNTR-YOU


                       Figure 14:  route-set objects.

   Figure 14 presents example route-set objects that use the mbrs-by-ref
   attribute.  The set rs-foo contains two address prefixes, namely
   128.8.0.0/16 and 128.9.0.0/16 since the route objects for
   128.8.0.0/16 and 128.9.0.0/16 refer to the set name rs-foo in their
   member-of attribute.  The set rs-bar contains the address prefixes
   128.7.0.0/16 and 128.8.0.0/16.  The route 128.7.0.0/16 is explicitly
   listed in the members attribute of rs-bar, and the route object for
   128.8.0.0/16 refer to the set name rs-bar in its member-of attribute.





<span class="grey">Alaettinoglu, et al.        Standards Track                    [Page 16]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-17" id="page-17" name="page-17"> </a>
<span class="grey"><a href="rfc2622.html">RFC 2622</a>                          RPSL                         June 1999</span>


   Note that, if an address prefix is listed in a members attribute of a
   route set, it is a member of that route set.  The route object
   corresponding to this address prefix does not need to contain a
   member-of attribute referring to this set name.  The member-of
   attribute of the route class is an additional mechanism for
   specifying the members indirectly.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.3%20Predefined%20Set%20Objects"></a><a class="selflink" href="#section-5.3" name="section-5.3">5.3</a> Predefined Set Objects</span>

   In a context that expects a route set (e.g.  members attribute of the
   route-set class), an AS number ASx defines the set of routes that are
   originated by ASx; and an as-set AS-X defines the set of routes that
   are originated by the ASes in AS-X. A route p is said to be
   originated by ASx if there is a route object for p with ASx as the
   value of the origin attribute.  For example, in Figure 15, the route
   set rs-special contains 128.9.0.0/16, routes of AS1 and AS2, and
   routes of the ASes in AS set AS-FOO.

   route-set: rs-special
   members: 128.9.0.0/16, AS1, AS2, AS-FOO


          Figure 15:  Use of AS numbers and AS sets in route sets.

   The set rs-any contains all routes registered in IRR. The set as-any
   contains all ASes registered in IRR.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.4%20Filters%20and%20filter-set%20Class"></a><a class="selflink" href="#section-5.4" name="section-5.4">5.4</a> Filters and filter-set Class</span>

   The attributes of the filter-set class are shown in Figure 16.  A
   filter-set object defines a set of routes that are matched by its
   filter.  The filter-set attribute defines the name of the filter.  It
   is an RPSL name that starts with "fltr-".

       Attribute   Value         Type
       filter-set  &lt;object-name&gt; mandatory, single-valued, class key
       filter      &lt;filter&gt;      mandatory, single-valued

                    Figure 16:  filter Class Attributes

      filter-set: fltr-foo
      filter: { 5.0.0.0/8, 6.0.0.0/8 }

      filter-set: fltr-bar
      filter: (AS1 or fltr-foo) and &lt;AS2&gt;

                      Figure 17:  filter-set objects.




<span class="grey">Alaettinoglu, et al.        Standards Track                    [Page 17]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-18" id="page-18" name="page-18"> </a>
<span class="grey"><a href="rfc2622.html">RFC 2622</a>                          RPSL                         June 1999</span>


   The filter attribute defines the set's policy filter.  A policy
   filter is a logical expression which when applied to a set of routes
   returns a subset of these routes.  We say that the policy filter
   matches the subset returned.  The policy filter can match routes
   using any BGP path attribute, such as the destination address prefix
   (or NLRI), AS-path, or community attributes.

   The policy filters can be composite by using the operators AND, OR,
   and NOT.  The following policy filters can be used to select a subset
   of routes:

   ANY
      The keyword ANY matches all routes.

   Address-Prefix Set This is an explicit list of address prefixes
      enclosed in braces '{' and '}'.  The policy filter matches the set
      of routes whose destination address-prefix is in the set.  For
      example:

        { 0.0.0.0/0 }
        { 128.9.0.0/16, 128.8.0.0/16, 128.7.128.0/17, 5.0.0.0/8 }
        { }


   An address prefix can be optionally followed by a range operator
   (i.e.

      { 5.0.0.0/8^+, 128.9.0.0/16^-, 30.0.0.0/8^16, 30.0.0.0/8^24-32 }


   contains all the more specifics of 5.0.0.0/8 including 5.0.0.0/8, all
   the more specifics of 128.9.0.0/16 excluding 128.9.0.0/16, all the
   more specifics of 30.0.0.0/8 which are of length 16 such as
   30.9.0.0/16, and all the more specifics of 30.0.0.0/8 which are of
   length 24 to 32 such as 30.9.9.96/28.

   Route Set Name  A route set name matches the set of routes that are
   members of the set.  A route set name may be a name of a route-set
   object, an AS number, or a name of an as-set object (AS numbers and
   as-set names implicitly define route sets; please see <a href="#section-5.3">Section 5.3</a>).
   For example:

      aut-num: AS1
      import: from AS2 accept AS2
      import: from AS2 accept AS-FOO
      import: from AS2 accept RS-FOO





<span class="grey">Alaettinoglu, et al.        Standards Track                    [Page 18]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-19" id="page-19" name="page-19"> </a>
<span class="grey"><a href="rfc2622.html">RFC 2622</a>                          RPSL                         June 1999</span>


   The keyword PeerAS can be used instead of the AS number of the peer
   AS.  PeerAS is particularly useful when the peering is specified
   using an AS expression.  For example:

      as-set: AS-FOO
      members: AS2, AS3

      aut-num: AS1
      import: from AS-FOO accept PeerAS

   is same as:

      aut-num: AS1
      import: from AS2 accept AS2
      import: from AS3 accept AS3

   A route set name can also be followed by one of the operators '^-',
   '^+', example, { 5.0.0.0/8, 6.0.0.0/8 }^+ equals { 5.0.0.0/8^+,
   6.0.0.0/8^+ }, and AS1^- equals all the exclusive more specifics of
   routes originated by AS1.

   AS Path Regular Expressions
      An AS-path regular expression can be used as a policy filter by
      enclosing the expression in `&lt;' and `&gt;'.  An AS-path policy filter
      matches the set of routes which traverses a sequence of ASes
      matched by the AS-path regular expression.  A router can check
      this using the AS_PATH attribute in the Border Gateway Protocol
      [<a href="#ref-19" title='"A Border Gateway Protocol 4 (BGP-4)"'>19</a>], or the RD_PATH attribute in the Inter-Domain Routing
      Protocol [<a href="#ref-18" title="4:61--80">18</a>].

      AS-path Regular Expressions are POSIX compliant regular
      expressions over the alphabet of AS numbers.  The regular
      expression constructs are as follows:

   ASN
      where ASN is an AS number.  ASN matches the AS-path that is of
      length 1 and contains the corresponding AS number (e.g.  AS-path
      regular expression AS1 matches the AS-path "1").

      The keyword PeerAS can be used instead of the AS number of the
      peer AS.

   AS-set
      where AS-set is an AS set name.  AS-set matches the AS-paths that
      is matched by one of the ASes in the AS-set.

   .
      matches the AS-paths matched by any AS number.



<span class="grey">Alaettinoglu, et al.        Standards Track                    [Page 19]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-20" id="page-20" name="page-20"> </a>
<span class="grey"><a href="rfc2622.html">RFC 2622</a>                          RPSL                         June 1999</span>


   [<a id="ref-..." name="ref-...">...</a>]
      is an AS number set.  It matches the AS-paths matched by the AS
      numbers listed between the brackets.  The AS numbers in the set
      are separated by white space characters.  If a `-' is used between
      two AS numbers in this set, all AS numbers between the two AS
      numbers are included in the set.  If an as-set name is listed, all
      AS numbers in the as-set are included.

   [^...]
      is a complemented AS number set.  It matches any AS-path which is
      not matched by the AS numbers in the set.

   ^
      Matches the empty string at the beginning of an AS-path.

   $
      Matches the empty string at the end of an AS-path.

   We next list the regular expression operators in the decreasing order
   of evaluation.  These operators are left associative, i.e. performed
   left to right.

   Unary postfix operators * + ?  {m} {m,n} {m,}
      For a regular expression A, A* matches zero or more occurrences of
      A; A+ matches one or more occurrences of A; A?  matches zero or
      one occurrence of A; A{m} matches m occurrence of A; A{m,n}
      matches m to n occurrence of A; A{m,} matches m or more occurrence
      of A. For example, [AS1 AS2]{2} matches AS1 AS1, AS1 AS2, AS2 AS1,
      and AS2 AS2.

   Unary postfix operators ~* ~+ ~{m} ~{m,n} ~{m,}
      These operators have similar functionality as the corresponding
      operators listed above, but all occurrences of the regular
      expression has to match the same pattern.  For example, [AS1
      AS2]~{2} matches AS1 AS1 and AS2 AS2, but it does not match AS1
      AS2 and AS2 AS1.

   Binary catenation operator
      This is an implicit operator and exists between two regular
      expressions A and B when no other explicit operator is specified.
      The resulting expression A B matches an AS-path if A matches some
      prefix of the AS-path and B matches the rest of the AS-path.

   Binary alternative (or) operator |
      For a regular expressions A and B, A | B matches any AS-path that
      is matched by A or B.





<span class="grey">Alaettinoglu, et al.        Standards Track                    [Page 20]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-21" id="page-21" name="page-21"> </a>
<span class="grey"><a href="rfc2622.html">RFC 2622</a>                          RPSL                         June 1999</span>


   Parenthesis can be used to override the default order of evaluation.
   White spaces can be used to increase readability.

   The following are examples of AS-path filters:

   &lt;AS3&gt;
   &lt;^AS1&gt;
   &lt;AS2$&gt;
   &lt;^AS1 AS2 AS3$&gt;
   &lt;^AS1 .* AS2$&gt;.

   The first example matches any route whose AS-path contains AS3, the
   second matches routes whose AS-path starts with AS1, the third
   matches routes whose AS-path ends with AS2, the fourth matches routes
   whose AS-path is exactly "1 2 3", and the fifth matches routes whose
   AS-path starts with AS1 and ends in AS2 with any number of AS numbers
   in between.

   Composite Policy Filters The following operators (in decreasing order
   of evaluation) can be used to form composite policy filters:


   NOT Given a policy filter x, NOT x matches the set of routes that
       are not matched by x.  That is it is the negation of policy
       filter x.

   AND Given two policy filters x and y, x AND y matches the intersection
       of the routes that are matched by x and that are matched by y.

   OR  Given two policy filters x and y, x OR y matches the union of the
       routes that are matched by x and that are matched by y.

   Note that an OR operator can be implicit, that is `x y' is equivalent
   to `x OR y'.

  E.g.
    NOT {128.9.0.0/16, 128.8.0.0/16}
    AS226 AS227 OR AS228
    AS226 AND NOT {128.9.0.0/16}
    AS226 AND {0.0.0.0/0^0-18}

   The first example matches any route except 128.9.0.0/16 and
   128.8.0.0/16.  The second example matches the routes of AS226, AS227
   and AS228.  The third example matches the routes of AS226 except
   128.9.0.0/16.  The fourth example matches the routes of AS226 whose
   length are not longer than 18.





<span class="grey">Alaettinoglu, et al.        Standards Track                    [Page 21]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-22" id="page-22" name="page-22"> </a>
<span class="grey"><a href="rfc2622.html">RFC 2622</a>                          RPSL                         June 1999</span>


   Routing Policy Attributes Policy filters can also use the values of
   other attributes for comparison.  The attributes whose values can be
   used in policy filters are specified in the RPSL dictionary.  Please
   refer to <a href="#section-7">Section 7</a> for details.  An example using the the BGP
   community attribute is shown below:

    aut-num: AS1
    export: to AS2 announce AS1 AND NOT community(NO_EXPORT)

   Filters using the routing policy attributes defined in the dictionary
   are evaluated before evaluating the operators AND, OR and NOT.

   Filter Set Name
      A filter set name matches the set of routes that are matched by
      its filter attribute.  Note that the filter attribute of a filter
      set, can recursively refer to other filter set names.  For example
      in Figure 17, fltr-foo matches { 5.0.0.0/8, 6.0.0.0/8 }, and
      fltr-bar matches AS1'S routes or { 5.0.0.0/8, 6.0.0.0/8 } if their
      as path contained AS2.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.5%20rtr-set%20Class"></a><a class="selflink" href="#section-5.5" name="section-5.5">5.5</a> rtr-set Class</span>

   The attributes of the rtr-set class are shown in Figure 18.  The
   rtr-set attribute defines the name of the set.  It is an RPSL name
   that starts with "rtrs-".  The members attribute lists the members of
   the set.  The members attribute is a list of inet-rtr names,
   ipv4_addresses or other rtr-set names.

    Attribute    Value                        Type
    rtr-set      &lt;object-name&gt;                mandatory, single-valued,
                                              class key
    members      list of &lt;inet-rtr-names&gt; or  optional, multi-valued
                 &lt;rtr-set-names&gt;
                 or &lt;ipv4_addresses&gt;
    mbrs-by-ref  list of &lt;mntner-names&gt;       optional, multi-valued


                    Figure 18:  rtr-set Class Attributes













<span class="grey">Alaettinoglu, et al.        Standards Track                    [Page 22]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-23" id="page-23" name="page-23"> </a>
<span class="grey"><a href="rfc2622.html">RFC 2622</a>                          RPSL                         June 1999</span>


   Figure 19 presents two rtr-set objects.  The set rtrs-foo contains
   two routers, namely rtr1.isp.net and rtr2.isp.net.  The set rtrs-bar
   contains the members of the set rtrs-foo and rtr3.isp.net, that is it
   contains rtr1.isp.net, rtr2.isp.net, rtr3.isp.net.

 rtr-set: rtrs-foo                     rtr-set: rtrs-bar
 members: rtr1.isp.net, rtr2.isp.net   members: rtr3.isp.net, rtrs-foo


                        Figure 19:  rtr-set objects.

   The mbrs-by-ref attribute is a list of maintainer names or the
   keyword ANY.  If this attribute is used, the router set also includes
   routers whose inet-rtr objects are registered by one of these
   maintainers and whose member-of attribute refers to the name of this
   router set.  If the value of a mbrs-by-ref attribute is ANY, any
   inet-rtr object referring to the router set is a member of the set.
   If the mbrs-by-ref attribute is missing, only the routers listed in
   the members attribute are members of the set.

       rtr-set: rtrs-foo
       members: rtr1.isp.net, rtr2.isp.net
       mbrs-by-ref: MNTR-ME

       inet-rtr: rtr3.isp.net
       local-as: as1
       ifaddr: 1.1.1.1 masklen 30
       member-of: rtrs-foo
       mnt-by: MNTR-ME


                              Figure 20:  rtr-set objects.

   Figure 20 presents an example rtr-set object that uses the mbrs-by-
   ref attribute.  The set rtrs-foo contains rtr1.isp.net, rtr2.isp.net
   and rtr3.isp.net.















<span class="grey">Alaettinoglu, et al.        Standards Track                    [Page 23]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-24" id="page-24" name="page-24"> </a>
<span class="grey"><a href="rfc2622.html">RFC 2622</a>                          RPSL                         June 1999</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.6%20Peerings%20and%20peering-set%20Class"></a><a class="selflink" href="#section-5.6" name="section-5.6">5.6</a> Peerings and peering-set Class</span>

   The attributes of the peering-set class are shown in Figure 21.  A
   peering-set object defines a set of peerings that are listed in its
   peering attributes.  The peering-set attribute defines the name of
   the set.  It is an RPSL name that starts with "prng-".

      Attribute    Value          Type
      peering-set  &lt;object-name&gt;  mandatory, single-valued, class key
      peering      &lt;peering&gt;      mandatory, multi-valued

                    Figure 21:  filter Class Attributes

   The peering attribute defines a peering that can be used for
   importing or

     ----------------------                   ----------------------
     |            7.7.7.1 |-------|   |-------| 7.7.7.2            |
     |                    |     ========      |                    |
     |   AS1              |      EX1  |-------| 7.7.7.3     AS2    |
     |                    |                   |                    |
     |            9.9.9.1 |------       ------| 9.9.9.2            |
     ----------------------     |       |     ----------------------
                               ===========
                                   |    EX2
     ----------------------        |
     |            9.9.9.3 |---------
     |                    |
     |   AS3              |
     ----------------------

  Figure 22: Example topology consisting of three ASes, AS1, AS2, and
        AS3; two exchange points, EX1 and EX2; and six routers.

   exporting routes.
      In describing peerings, we are going to use the topology of Figure
      22.  In this topology, there are three ASes, AS1, AS2, and AS3;
      two exchange points, EX1 and EX2; and six routers.  Routers
      connected to the same exchange point peer with each other and
      exchange routing information.  That is, 7.7.7.1, 7.7.7.2 and
      7.7.7.3 peer with each other; 9.9.9.1, 9.9.9.2 and 9.9.9.3 peer
      with each other.

      The syntax of a peering specification is:

      &lt;as-expression&gt; [&lt;router-expression-1&gt;] [at &lt;router-expression-2&gt;]
     | &lt;peering-set-name&gt;




<span class="grey">Alaettinoglu, et al.        Standards Track                    [Page 24]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-25" id="page-25" name="page-25"> </a>
<span class="grey"><a href="rfc2622.html">RFC 2622</a>                          RPSL                         June 1999</span>


      where &lt;as-expression&gt; is an expression over AS numbers and AS sets
      using operators AND, OR, and EXCEPT, and &lt;router-expression-1&gt; and
      &lt;router-expression-2&gt; are expressions over router IP addresses,
      inet-rtr names, and rtr-set names using operators AND, OR, and
      EXCEPT.  The binary "EXCEPT" operator is the set subtraction
      operator and has the same precedence as the operator AND (it is
      semantically equivalent to "AND NOT" combination).  That is "(AS1
      OR AS2) EXCEPT AS2" equals "AS1".

      This form identifies all the peerings between any local router in
      &lt;router-expression-2&gt; to any of their peer routers in &lt;router-
      expression-1&gt; in the ASes in &lt;as-expression&gt;.  If &lt;router-
      expression-2&gt; is not specified, it defaults to all routers of the
      local AS that peer with ASes in &lt;as-expression&gt;.  If &lt;router-
      expression-1&gt; is not specified, it defaults to all routers of the
      peer ASes in &lt;as-expression&gt; that peer with the local AS.

      If a &lt;peering-set-name&gt; is used, the peerings are listed in the
      corresponding peering-set object.  Note that the peering-set
      objects can be recursive.

      Many special forms of this general peering specification is
      possible.  The following examples illustrate the most common
      cases, using the import attribute of the aut-num class.  In the
      following example 7.7.7.1 imports 128.9.0.0/16 from 7.7.7.2.

 (1) aut-num: AS1
     import: from AS2 7.7.7.2 at 7.7.7.1 accept { 128.9.0.0/16 }

   In the following example 7.7.7.1 imports 128.9.0.0/16 from 7.7.7.2
   and 7.7.7.3.

 (2) aut-num: AS1
     import: from AS2 at 7.7.7.1 accept { 128.9.0.0/16 }


   In the following example 7.7.7.1 imports 128.9.0.0/16 from 7.7.7.2
   and 7.7.7.3, and 9.9.9.1 imports 128.9.0.0/16 from 9.9.9.2.

 (3) aut-num: AS1
     import: from AS2 accept { 128.9.0.0/16 }

   In the following example 9.9.9.1 imports 128.9.0.0/16 from 9.9.9.2
   and 9.9.9.3.







<span class="grey">Alaettinoglu, et al.        Standards Track                    [Page 25]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-26" id="page-26" name="page-26"> </a>
<span class="grey"><a href="rfc2622.html">RFC 2622</a>                          RPSL                         June 1999</span>


 (4) as-set: AS-FOO
     members: AS2, AS3

     aut-num: AS1
     import: from AS-FOO      at 9.9.9.1 accept { 128.9.0.0/16 }

   In the following example 9.9.9.1 imports 128.9.0.0/16 from 9.9.9.2
   and 9.9.9.3, and 7.7.7.1 imports 128.9.0.0/16 from 7.7.7.2 and
   7.7.7.3.

 (5) aut-num: AS1
     import: from AS-FOO                 accept { 128.9.0.0/16 }

   In the following example AS1 imports 128.9.0.0/16 from AS3 at router
   9.9.9.1

 (6) aut-num: AS1
     import: from AS-FOO and not AS2 at not 7.7.7.1
             accept { 128.9.0.0/16 }

   This is because "AS-FOO and not AS2" equals AS3 and "not 7.7.7.1"
   equals 9.9.9.1.

   In the following example 9.9.9.1 imports 128.9.0.0/16 from 9.9.9.2
   and 9.9.9.3.

 (7) peering-set: prng-bar
     peering: AS1 at 9.9.9.1

     peering-set: prng-foo
     peering: prng-bar
     peering: AS2 at 9.9.9.1

     aut-num: AS1
     import: from prng-foo accept { 128.9.0.0/16 }
















<span class="grey">Alaettinoglu, et al.        Standards Track                    [Page 26]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-27" id="page-27" name="page-27"> </a>
<span class="grey"><a href="rfc2622.html">RFC 2622</a>                          RPSL                         June 1999</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/6%20aut-num%20Class"></a><a class="selflink" href="#section-6" name="section-6">6</a> aut-num Class</span>

   Routing policies are specified using the aut-num class.  The
   attributes of the aut-num class are shown in Figure 23.  The value of
   the aut-num attribute is the AS number of the AS described by this
   object.  The as-name attribute is a symbolic name (in RPSL name
   syntax) of the AS. The import, export and default routing policies of
   the AS are specified using import, export and default attributes
   respectively.

   Attribute  Value                  Type
   aut-num    &lt;as-number&gt;            mandatory, single-valued, class key
   as-name    &lt;object-name&gt;          mandatory, single-valued
   member-of  list of &lt;as-set-names&gt; optional, multi-valued
   import     see <a href="#section-6.1">Section 6.1</a>        optional, multi valued
   export     see <a href="#section-6.2">Section 6.2</a>        optional, multi valued
   default    see <a href="#section-6.5">Section 6.5</a>        optional, multi valued

                    Figure 23:  aut-num Class Attributes

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/6.1%20import%20Attribute%3A"></a><a class="selflink" href="#section-6.1" name="section-6.1">6.1</a> import Attribute:  </span>Import Policy Specification

   In RPSL, an import policy is divided into import policy expressions.
   Each import policy expression is specified using an import attribute.
   The import attribute has the following syntax (we will extend this
   syntax later in Sections <a href="#section-6.3">6.3</a> and <a href="#section-6.6">6.6</a>):

   import: from &lt;peering-1&gt; [action &lt;action-1&gt;]
            . . .
            from &lt;peering-N&gt; [action &lt;action-N&gt;]
            accept &lt;filter&gt;

   The action specification is optional.  The semantics of an import
   attribute is as follows: the set of routes that are matched by
   &lt;filter&gt; are imported from all the peers in &lt;peerings&gt;; while
   importing routes at &lt;peering-M&gt;, &lt;action-M&gt; is executed.

  E.g.
    aut-num: AS1
    import: from AS2 action pref = 1; accept { 128.9.0.0/16 }

   This example states that the route 128.9.0.0/16 is accepted from AS2
   with preference 1.  We already presented how peerings (see <a href="#section-5.6">Section</a>
   <a href="#section-5.6">5.6</a>) and filters (see <a href="#section-5.4">Section 5.4</a>) are specified.  We next present
   how to specify actions.






<span class="grey">Alaettinoglu, et al.        Standards Track                    [Page 27]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-28" id="page-28" name="page-28"> </a>
<span class="grey"><a href="rfc2622.html">RFC 2622</a>                          RPSL                         June 1999</span>


<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/6.1.1%20Action%20Specification"></a><a class="selflink" href="#section-6.1.1" name="section-6.1.1">6.1.1</a> Action Specification</span>

   Policy actions in RPSL either set or modify route attributes, such as
   assigning a preference to a route, adding a BGP community to the BGP
   community path attribute, or setting the MULTI-EXIT-DISCRIMINATOR
   attribute.  Policy actions can also instruct routers to perform
   special operations, such as route flap damping.

   The routing policy attributes whose values can be modified in policy
   actions are specified in the RPSL dictionary.  Please refer to
   <a href="#section-7">Section 7</a> for a list of these attributes.  Each action in RPSL is
   terminated by the semicolon character (';').  It is possible to form
   composite policy actions by listing them one after the other.  In a
   composite policy action, the actions are executed left to right.  For
   example,

 aut-num: AS1
 import: from AS2
         action pref = 10; med = 0; community.append(10250, 3561:10);
         accept { 128.9.0.0/16 }

   sets pref to 10, med to 0, and then appends 10250 and 3561:10 to the
   BGP community path attribute.  The pref attribute is the inverse of
   the local-pref attribute (i.e. local-pref == 65535 - pref).  A route
   with a local-pref attribute is always preferred over a route without
   one.

 aut-num: AS1
 import: from AS2 action pref = 1;
         from AS3 action pref = 2;
         accept AS4

   The above example states that AS4's routes are accepted from AS2 with
   preference 1, and from AS3 with preference 2 (routes with lower
   integer preference values are preferred over routes with higher
   integer preference values).

 aut-num: AS1
 import: from AS2 7.7.7.2 at 7.7.7.1 action pref = 1;
         from AS2                    action pref = 2;
         accept AS4

   The above example states that AS4's routes are accepted from AS2 on
   peering 7.7.7.1-7.7.7.2 with preference 1, and on any other peering
   with AS2 with preference 2.






<span class="grey">Alaettinoglu, et al.        Standards Track                    [Page 28]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-29" id="page-29" name="page-29"> </a>
<span class="grey"><a href="rfc2622.html">RFC 2622</a>                          RPSL                         June 1999</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/6.2%20export%20Attribute%3A"></a><a class="selflink" href="#section-6.2" name="section-6.2">6.2</a> export Attribute:  </span>Export Policy Specification

   Similarly, an export policy expression is specified using an export
   attribute.  The export attribute has the following syntax:

    export: to &lt;peering-1&gt; [action &lt;action-1&gt;]
            . . .
            to &lt;peering-N&gt; [action &lt;action-N&gt;]
            announce &lt;filter&gt;

   The action specification is optional.  The semantics of an export
   attribute is as follows:  the set of routes that are matched by
   &lt;filter&gt; are exported to all the peers specified in &lt;peerings&gt;; while
   exporting routes at &lt;peering-M&gt;, &lt;action-M&gt; is executed.

  E.g.
    aut-num: AS1
    export: to AS2 action med = 5; community .= { 70 };
            announce AS4

   In this example, AS4's routes are announced to AS2 with the med
   attribute's value set to 5 and community 70 added to the community
   list.

   Example:

    aut-num: AS1
    export: to AS-FOO announce ANY

   In this example, AS1 announces all of its routes to the ASes in the
   set AS-FOO.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/6.3%20Other%20Routing%20Protocols%2C%20Multi-Protocol%20Routing%20Protocols%2C%20and"></a><a class="selflink" href="#section-6.3" name="section-6.3">6.3</a> Other Routing Protocols, Multi-Protocol Routing Protocols, and</span>
<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/Injecting%20Routes%20Between%20Protocols"></a>   Injecting Routes Between Protocols</span>

   The more complete syntax of the import and export attributes are as
   follows:

    import: [protocol &lt;protocol-1&gt;] [into &lt;protocol-2&gt;]
            from &lt;peering-1&gt; [action &lt;action-1&gt;]
            . . .
            from &lt;peering-N&gt; [action &lt;action-N&gt;]
            accept &lt;filter&gt;
    export: [protocol &lt;protocol-1&gt;] [into &lt;protocol-2&gt;]
            to &lt;peering-1&gt; [action &lt;action-1&gt;]
            . . .
            to &lt;peering-N&gt; [action &lt;action-N&gt;]
            announce &lt;filter&gt;



<span class="grey">Alaettinoglu, et al.        Standards Track                    [Page 29]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-30" id="page-30" name="page-30"> </a>
<span class="grey"><a href="rfc2622.html">RFC 2622</a>                          RPSL                         June 1999</span>


   Where the optional protocol specifications can be used for specifying
   policies for other routing protocols, or for injecting routes of one
   protocol into another protocol, or for multi-protocol routing
   policies.  The valid protocol names are defined in the dictionary.
   The &lt;protocol-1&gt; is the name of the protocol whose routes are being
   exchanged.  The &lt;protocol-2&gt; is the name of the protocol which is
   receiving these routes.  Both &lt;protocol-1&gt; and &lt;protocol-2&gt; default
   to the Internet Exterior Gateway Protocol, currently BGP.

   In the following example, all interAS routes are injected into RIP.

 aut-num: AS1
 import: from AS2 accept AS2
 export: protocol BGP4 into RIP
         to AS1 announce ANY

   In the following example, AS1 accepts AS2's routes including any more
   specifics of AS2's routes, but does not inject these extra more
   specific routes into OSPF.

 aut-num: AS1
 import: from AS2 accept AS2^+
 export: protocol BGP4 into OSPF
         to AS1 announce AS2

   In the following example, AS1 injects its static routes (routes which
   are members of the set AS1:RS-STATIC-ROUTES) to the interAS routing
   protocol and appends AS1 twice to their AS paths.

 aut-num: AS1
 import: protocol STATIC into BGP4
         from AS1 action aspath.prepend(AS1, AS1);
         accept AS1:RS-STATIC-ROUTES

   In the following example, AS1 imports different set of unicast routes
   for multicast reverse path forwarding from AS2:

 aut-num: AS1
 import: from AS2 accept AS2
 import: protocol IDMR
         from AS2 accept AS2:RS-RPF-ROUTES










<span class="grey">Alaettinoglu, et al.        Standards Track                    [Page 30]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-31" id="page-31" name="page-31"> </a>
<span class="grey"><a href="rfc2622.html">RFC 2622</a>                          RPSL                         June 1999</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/6.4%20Ambiguity%20Resolution"></a><a class="selflink" href="#section-6.4" name="section-6.4">6.4</a> Ambiguity Resolution</span>

   It is possible that the same peering can be covered by more that one
   peering specification in a policy expression.  For example:

 aut-num: AS1
 import: from AS2 7.7.7.2 at 7.7.7.1 action pref = 2;
         from AS2 7.7.7.2 at 7.7.7.1 action pref = 1;
         accept AS4

   This is not an error, though definitely not desirable.  To break the
   ambiguity, the action corresponding to the first peering
   specification is used.  That is the routes are accepted with
   preference 2.  We call this rule as the specification-order rule.

   Consider the example:

 aut-num: AS1
 import: from AS2                    action pref = 2;
         from AS2 7.7.7.2 at 7.7.7.1 action pref = 1; dpa = 5;
         accept AS4

   where both peering specifications cover the peering 7.7.7.1-7.7.7.2,
   though the second one covers it more specifically.  The specification
   order rule still applies, and only the action "pref = 2" is executed.
   In fact, the second peering-action pair has no use since the first
   peering-action pair always covers it.  If the intended policy was to
   accept these routes with preference 1 on this particular peering and
   with preference 2 in all other peerings, the user should have
   specified:

 aut-num: AS1
 import: from AS2 7.7.7.2 at 7.7.7.1 action pref = 1; dpa = 5;
         from AS2                    action pref = 2;
         accept AS4

   It is also possible that more than one policy expression can cover
   the same set of routes for the same peering.  For example:

 aut-num: AS1
 import: from AS2 action pref = 2; accept AS4
 import: from AS2 action pref = 1; accept AS4

   In this case, the specification-order rule is still used.  That is,
   AS4's routes are accepted from AS2 with preference 2.  If the filters
   were overlapping but not exactly the same:





<span class="grey">Alaettinoglu, et al.        Standards Track                    [Page 31]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-32" id="page-32" name="page-32"> </a>
<span class="grey"><a href="rfc2622.html">RFC 2622</a>                          RPSL                         June 1999</span>


 aut-num: AS1
 import: from AS2 action pref = 2; accept AS4
 import: from AS2 action pref = 1; accept AS4 OR AS5

   the AS4's routes are accepted from AS2 with preference 2 and however
   AS5's routes are also accepted, but with preference 1.

   We next give the general specification order rule for the benefit of
   the RPSL implementors.  Consider two policy expressions:

 aut-num: AS1
 import: from peerings-1 action action-1 accept filter-1
 import: from peerings-2 action action-2 accept filter-2

   The above policy expressions are equivalent to the following three
   expressions where there is no ambiguity:

 aut-num: AS1
 import: from peerings-1 action action-1 accept filter-1
 import: from peerings-3 action action-2 accept filter-2 AND NOT filter-1
 import: from peerings-4 action action-2 accept filter-2

   where peerings-3 are those that are covered by both peerings-1 and
   peerings-2, and peerings-4 are those that are covered by peerings-2
   but not by peerings-1 ("filter-2 AND NOT filter-1" matches the routes
   that are matched by filter-2 but not by filter-1).

   Example:

 aut-num: AS1
 import: from AS2 7.7.7.2 at 7.7.7.1
         action pref = 2;
         accept {128.9.0.0/16}
 import: from AS2
         action pref = 1;
         accept {128.9.0.0/16, 75.0.0.0/8}

   Lets consider two peerings with AS2, 7.7.7.1-7.7.7.2 and 9.9.9.1-
   9.9.9.2.  Both policy expressions cover 7.7.7.1-7.7.7.2.  On this
   peering, the route 128.9.0.0/16 is accepted with preference 2, and
   the route 75.0.0.0/8 is accepted with preference 1.  The peering
   9.9.9.1-9.9.9.2 is only covered by the second policy expressions.
   Hence, both the route 128.9.0.0/16 and the route 75.0.0.0/8 are
   accepted with preference 1 on peering 9.9.9.1-9.9.9.2.

   Note that the same ambiguity resolution rules also apply to export
   and default policy expressions.




<span class="grey">Alaettinoglu, et al.        Standards Track                    [Page 32]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-33" id="page-33" name="page-33"> </a>
<span class="grey"><a href="rfc2622.html">RFC 2622</a>                          RPSL                         June 1999</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/6.5%20default%20Attribute%3A"></a><a class="selflink" href="#section-6.5" name="section-6.5">6.5</a> default Attribute:  </span>Default Policy Specification

   Default routing policies are specified using the default attribute.
   The default attribute has the following syntax:

    default: to &lt;peering&gt; [action &lt;action&gt;] [networks &lt;filter&gt;]

   The &lt;action&gt; and &lt;filter&gt; specifications are optional.  The semantics
   are as follows:  The &lt;peering&gt; specification indicates the AS (and
   the router if present) is being defaulted to; the &lt;action&gt;
   specification, if present, indicates various attributes of
   defaulting, for example a relative preference if multiple defaults
   are specified; and the &lt;filter&gt; specifications, if present, is a
   policy filter.  A router only uses the default policy if it received
   the routes matched by &lt;filter&gt; from this peer.

   In the following example, AS1 defaults to AS2 for routing.

 aut-num: AS1
 default: to AS2

   In the following example, router 7.7.7.1 in AS1 defaults to router
   7.7.7.2 in AS2.

 aut-num: AS1
 default: to AS2 7.7.7.2 at 7.7.7.1

   In the following example, AS1 defaults to AS2 and AS3, but prefers
   AS2 over AS3.

 aut-num: AS1
 default: to AS2 action pref = 1;
 default: to AS3 action pref = 2;

   In the following example, AS1 defaults to AS2 and uses 128.9.0.0/16
   as the default network.

 aut-num: AS1
 default: to AS2 networks { 128.9.0.0/16 }

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/6.6%20Structured%20Policy%20Specification"></a><a class="selflink" href="#section-6.6" name="section-6.6">6.6</a> Structured Policy Specification</span>

   The import and export policies can be structured.  We only reccomend
   structured policies to advanced RPSL users.  Please feel free to skip
   this section.

   The syntax for a structured policy specification is the following:




<span class="grey">Alaettinoglu, et al.        Standards Track                    [Page 33]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-34" id="page-34" name="page-34"> </a>
<span class="grey"><a href="rfc2622.html">RFC 2622</a>                          RPSL                         June 1999</span>


   &lt;import-factor&gt; ::= from &lt;peering-1&gt; [action &lt;action-1&gt;]
                       . . .
                       from &lt;peering-N&gt; [action &lt;action-N&gt;]
                       accept &lt;filter&gt;;

   &lt;import-term&gt; ::=  &lt;import-factor&gt; |
                      LEFT-BRACE
                      &lt;import-factor&gt;
                      . . .
                      &lt;import-factor&gt;
                      RIGHT-BRACE

   &lt;import-expression&gt; ::= &lt;import-term&gt;                            |
                           &lt;import-term&gt; EXCEPT &lt;import-expression&gt; |
                           &lt;import-term&gt; REFINE &lt;import-expression&gt;

   import: [protocol &lt;protocol1&gt;] [into &lt;protocol2&gt;]
           &lt;import-expression&gt;

   Please note the semicolon at the end of an &lt;import-factor&gt;.  If the
   policy specification is not structured (as in all the examples in
   other sections), this semicolon is optional.  The syntax and
   semantics for an &lt;import-factor&gt; is already defined in <a href="#section-6.1">Section 6.1</a>.

   An &lt;import-term&gt; is either a sequence of &lt;import-factor&gt;'s enclosed
   within matching braces (i.e. `{' and `}') or just a single &lt;import-
   factor&gt;.  The semantics of an &lt;import-term&gt; is the union of &lt;import-
   factor&gt;'s using the specification order rule.  An &lt;import-expression&gt;
   is either a single &lt;import-term&gt; or an &lt;import-term&gt; followed by one
   of the keywords "except" and "refine", followed by another &lt;import-
   expression&gt;.  Note that our definition allows nested expressions.
   Hence there can be exceptions to exceptions, refinements to
   refinements, or even refinements to exceptions, and so on.

   The semantics for the except operator is as follows: The result of an
   except operation is another &lt;import-term&gt;.  The resulting policy set
   contains the policies of the right hand side but their filters are
   modified to only include the routes also matched by the left hand
   side.  The policies of the left hand side are included afterwards and
   their filters are modified to exclude the routes matched by the right
   hand side.  Please note that the filters are modified during this
   process but the actions are copied verbatim.  When there are multiple
   levels of nesting, the operations (both except and refine) are
   performed right to left.







<span class="grey">Alaettinoglu, et al.        Standards Track                    [Page 34]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-35" id="page-35" name="page-35"> </a>
<span class="grey"><a href="rfc2622.html">RFC 2622</a>                          RPSL                         June 1999</span>


   Consider the following example:

 import: from AS1 action pref = 1; accept as-foo;
         except {
            from AS2 action pref = 2; accept AS226;
            except {
               from AS3 action pref = 3; accept {128.9.0.0/16};
            }
         }

   where the route 128.9.0.0/16 is originated by AS226, and AS226 is a
   member of the as set as-foo.  In this example, the route 128.9.0.0/16
   is accepted from AS3, any other route (not 128.9.0.0/16) originated
   by AS226 is accepted from AS2, and any other ASes' routes in as-foo
   is accepted from AS1.

   We can come to the same conclusion using the algebra defined above.
   Consider the inner exception specification:

   from AS2 action pref = 2; accept AS226;
   except {
      from AS3 action pref = 3; accept {128.9.0.0/16};
   }


 is equivalent to


  {
   from AS3 action pref = 3; accept AS226 AND {128.9.0.0/16};
   from AS2 action pref = 2; accept AS226 AND NOT {128.9.0.0/16};
  }


 Hence, the original expression is equivalent to:


 import: from AS1 action pref = 1; accept as-foo;
         except {
            from AS3 action pref = 3; accept AS226 AND {128.9.0.0/16};
            from AS2 action pref = 2; accept AS226 AND NOT {128.9.0.0/16};
         }


 which is equivalent to


import: {



<span class="grey">Alaettinoglu, et al.        Standards Track                    [Page 35]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-36" id="page-36" name="page-36"> </a>
<span class="grey"><a href="rfc2622.html">RFC 2622</a>                          RPSL                         June 1999</span>


   from AS3 action pref = 3;
            accept as-foo AND AS226 AND {128.9.0.0/16};
   from AS2 action pref = 2;
            accept as-foo AND AS226 AND NOT {128.9.0.0/16};
   from AS1 action pref = 1;
            accept as-foo AND NOT
              (AS226 AND NOT {128.9.0.0/16} OR AS226 AND {128.9.0.0/16});
   }


 Since AS226 is in as-foo and 128.9.0.0/16 is in AS226, it simplifies
 to:


import: {
          from AS3 action pref = 3; accept {128.9.0.0/16};
          from AS2 action pref = 2; accept AS226 AND NOT {128.9.0.0/16};
          from AS1 action pref = 1; accept as-foo AND NOT AS226;
        }

   In the case of the refine operator, the resulting set is constructed
   by taking the cartasian product of the two sides as follows:  for
   each policy l in the left hand side and for each policy r in the
   right hand side, the peerings of the resulting policy are the
   peerings common to both r and l; the filter of the resulting policy
   is the intersection of l's filter and r's filter; and action of the
   resulting policy is l's action followed by r's action.  If there are
   no common peerings, or if the intersection of filters is empty, a
   resulting policy is not generated.

   Consider the following example:

 import: { from AS-ANY action pref = 1; accept community(3560:10);
           from AS-ANY action pref = 2; accept community(3560:20);
         } refine {
            from AS1 accept AS1;
            from AS2 accept AS2;
            from AS3 accept AS3;
         }

   Here, any route with community 3560:10 is assigned a preference of 1
   and any route with community 3560:20 is assigned a preference of 2
   regardless of whom they are imported from.  However, only AS1's
   routes are imported from AS1, and only AS2's routes are imported from
   AS2, and only AS3's routes are imported form AS3, and no routes are
   imported from any other AS. We can reach the same conclusion using
   the above algebra.  That is, our example is equivalent to:




<span class="grey">Alaettinoglu, et al.        Standards Track                    [Page 36]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-37" id="page-37" name="page-37"> </a>
<span class="grey"><a href="rfc2622.html">RFC 2622</a>                          RPSL                         June 1999</span>


 import: {
   from AS1 action pref = 1; accept community(3560:10) AND AS1;
   from AS1 action pref = 2; accept community(3560:20) AND AS1;
   from AS2 action pref = 1; accept community(3560:10) AND AS2;
   from AS2 action pref = 2; accept community(3560:20) AND AS2;
   from AS3 action pref = 1; accept community(3560:10) AND AS3;
   from AS3 action pref = 2; accept community(3560:20) AND AS3;
 }

   Note that the common peerings between "from AS1" and "from AS-ANY"
   are those peerings in "from AS1".  Even though we do not formally
   define "common peerings", it is straight forward to deduce the
   definition from the definitions of peerings (please see <a href="#section-5.6">Section 5.6</a>).

   Consider the following example:

 import: {
   from AS-ANY action med = 0; accept {0.0.0.0/0^0-18};
   } refine {
        from AS1 at 7.7.7.1 action pref = 1; accept AS1;
        from AS1            action pref = 2; accept AS1;
     }

   where only routes of length 0 to 18 are accepted and med's value is
   set to 0 to disable med's effect for all peerings; In addition, from
   AS1 only AS1's routes are imported, and AS1's routes imported at
   7.7.7.1 are preferred over other peerings.  This is equivalent to:

 import: {
      from AS1 at 7.7.7.1 action med=0; pref=1; accept {0.0.0.0/0^0-
18} AND AS1;
    from  AS1             action med=0; pref=2; accept {0.0.0.0/0^0-
18} AND AS1;
 }

   The above syntax and semantics also apply equally to structured
   export policies with "from" replaced with "to" and "accept" is
   replaced with "announce".

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/7%20dictionary%20Class"></a><a class="selflink" href="#section-7" name="section-7">7</a> dictionary Class</span>

   The dictionary class provides extensibility to RPSL. Dictionary
   objects define routing policy attributes, types, and routing
   protocols.  Routing policy attributes, henceforth called rp-
   attributes, may correspond to actual protocol attributes, such as the
   BGP path attributes (e.g. community, dpa, and AS-path), or they may
   correspond to router features (e.g. BGP route flap damping).  As new
   protocols, new protocol attributes, or new router features are



<span class="grey">Alaettinoglu, et al.        Standards Track                    [Page 37]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-38" id="page-38" name="page-38"> </a>
<span class="grey"><a href="rfc2622.html">RFC 2622</a>                          RPSL                         June 1999</span>


   introduced, the dictionary object is updated to include appropriate
   rp-attribute and protocol definitions.

   An rp-attribute is an abstract class; that is a data representation
   is not available.  Instead, they are accessed through access methods.
   For example, the rp-attribute for the BGP AS-path attribute is called
   aspath; and it has an access method called prepend which stuffs extra
   AS numbers to the AS-path attributes.  Access methods can take
   arguments.  Arguments are strongly typed.  For example, the method
   prepend above takes AS numbers as arguments.

   Once an rp-attribute is defined in the dictionary, it can be used to
   describe policy filters and actions.  Policy analysis tools are
   required to fetch the dictionary object and recognize newly defined
   rp-attributes, types, and protocols.  The analysis tools may
   approximate policy analyses on rp-attributes that they do not
   understand:  a filter method may always match, and an action method
   may always perform no-operation.  Analysis tools may even download
   code to perform appropriate operations using mechanisms outside the
   scope of RPSL.

   We next describe the syntax and semantics of the dictionary class.
   This description is not essential for understanding dictionary
   objects (but it is essential for creating one).  Please feel free to
   skip to the RPSL Initial Dictionary subsection (<a href="#section-7.1">Section 7.1</a>).

   The attributes of the dictionary class are shown in Figure 24.  The
   dictionary attribute is the name of the dictionary object, obeying
   the RPSL naming rules.  There can be many dictionary objects, however
   there is always one well-known dictionary object "RPSL". All tools
   use this dictionary by default.

 Attribute     Value                   Type
 dictionary    &lt;object-name&gt;           mandatory, single-valued,
                                       class key
 rp-attribute  see description in text optional, multi valued
 typedef       see description in text optional, multi valued
 protocol      see description in text optional, multi valued

                  Figure 24:  dictionary Class Attributes

   The rp-attribute attribute has the following syntax:

   rp-attribute: &lt;name&gt;
      &lt;method-1&gt;(&lt;type-1-1&gt;, ..., &lt;type-1-N1&gt; [, "..."])
      ...
      &lt;method-M&gt;(&lt;type-M-1&gt;, ..., &lt;type-M-NM&gt; [, "..."])




<span class="grey">Alaettinoglu, et al.        Standards Track                    [Page 38]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-39" id="page-39" name="page-39"> </a>
<span class="grey"><a href="rfc2622.html">RFC 2622</a>                          RPSL                         June 1999</span>


   where &lt;name&gt; is the name of the rp-attribute; and &lt;method-i&gt; is the
   name of an access method for the rp-attribute, taking Ni arguments
   where the j-th argument is of type &lt;type-i-j&gt;.  A method name is
   either an RPSL name or one of the operators defined in Figure 25.
   The operator methods with the exception of operator() and operator[]
   can take only one argument.

   operator=           operator==
   operator&lt;&lt;=         operator&lt;
   operator&gt;&gt;=         operator&gt;
   operator+=          operator&gt;=
   operator-=          operator&lt;=
   operator*=          operator!=
   operator/=          operator()
   operator.=          operator[]


                           Figure 25:  Operators

   An rp-attribute can have many methods defined for it.  Some of the
   methods may even have the same name, in which case their arguments
   are of different types.  If the argument list is followed by "...",
   the method takes a variable number of arguments.  In this case, the
   actual arguments after the Nth argument are of type &lt;type-N&gt;.

   Arguments are strongly typed.  A &lt;type&gt; in RPSL is either a
   predefined type, a union type, a list type, or a dictionary defined
   type.  The predefined types are listed in Figure 26.

   integer[lower, upper]              ipv4_address
   real[lower, upper]                 address_prefix
   enum[name, name, ...]              address_prefix_range
   string                             dns_name
   boolean                            filter
   rpsl_word                          as_set_name
   free_text                          route_set_name
   email                              rtr_set_name
   as_number                          filter_set_name
                                      peering_set_name


                        Figure 26:  Predefined Types

   The integer and the real predefined types can be followed by a lower
   and an upper bound to specify the set of valid values of the
   argument.  The range specification is optional.  We use the ANSI C
   language conventions for representing integer, real and string
   values.  The enum type is followed by a list of RPSL names which are



<span class="grey">Alaettinoglu, et al.        Standards Track                    [Page 39]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-40" id="page-40" name="page-40"> </a>
<span class="grey"><a href="rfc2622.html">RFC 2622</a>                          RPSL                         June 1999</span>


   the valid values of the type.  The boolean type can take the values
   true or false.  as_number, ipv4_address, address_prefix and dns_name
   types are as in <a href="#section-2">Section 2</a>.  filter type is a policy filter as in
   <a href="#section-6">Section 6</a>.  The value of filter type is suggested to be enclosed in
   parenthesis.

   The syntax of a union type is as follows:

    union &lt;type-1&gt;, ... , &lt;type-N&gt;

   where &lt;type-i&gt; is an RPSL type.  The union type is either of the
   types &lt;type-1&gt; through &lt;type-N&gt; (analogous to unions in C[14]).

   The syntax of a list type is as follows:

   list [&lt;min_elems&gt;:&lt;max_elems&gt;] of &lt;type&gt;

   In this case, the list elements are of &lt;type&gt; and the list contains
   at least &lt;min_elems&gt; and at most &lt;max_elems&gt; elements.  The size
   specification is optional.  If it is not specified, there is no
   restriction in the number of list elements.  A value of a list type
   is represented as a sequence of elements separated by the character
   "," and enclosed by the characters "{" and "}".

   The typedef attribute in the dictionary defines named types as
   follows:

   typedef: &lt;name&gt; &lt;type&gt;

   where &lt;name&gt; is a name for type &lt;type&gt;.  typedef attribute is
   paticularly useful when the type defined is not a predefined type
   (e.g. list of unions, list of lists, etc.).

   A protocol attribute of the dictionary class defines a protocol and a
   set of peering parameters for that protocol (which are used in inet-
   rtr class in <a href="#section-9">Section 9</a>).  Its syntax is as follows:

   protocol: &lt;name&gt;
    MANDATORY | OPTIONAL &lt;parameter-1&gt;(&lt;type-1-1&gt;,...,
                         &lt;type-1-N1&gt; [,"..."])
      ...
    MANDATORY | OPTIONAL &lt;parameter-M&gt;(&lt;type-M-1&gt;,...,
                         &lt;type-M-NM&gt; [,"..."])

   where &lt;name&gt; is the name of the protocol; MANDATORY and OPTIONAL are
   keywords; and &lt;parameter-i&gt; is a peering parameter for this protocol,
   taking Ni many arguments.  The syntax and semantics of the arguments
   are as in the rp-attribute.  If the keyword MANDATORY is used, the



<span class="grey">Alaettinoglu, et al.        Standards Track                    [Page 40]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-41" id="page-41" name="page-41"> </a>
<span class="grey"><a href="rfc2622.html">RFC 2622</a>                          RPSL                         June 1999</span>


   parameter is mandatory and needs to be specified for each peering of
   this protocol.  If the keyword OPTIONAL is used, the parameter can be
   skipped.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/7.1%20Initial%20RPSL%20Dictionary%20and%20Example%20Policy%20Actions%20and%20Filters"></a><a class="selflink" href="#section-7.1" name="section-7.1">7.1</a> Initial RPSL Dictionary and Example Policy Actions and Filters</span>

dictionary:   RPSL
rp-attribute: # preference, smaller values represent higher preferences
              pref
              operator=(integer[0, 65535])
rp-attribute: # BGP multi_exit_discriminator attribute
              med
              # to set med to 10: med = 10;
              # to set med to the IGP metric: med = igp_cost;
              operator=(union integer[0, 65535], enum[igp_cost])
rp-attribute: # BGP destination preference attribute (dpa)
              dpa
              operator=(integer[0, 65535])
rp-attribute: # BGP aspath attribute
              aspath
              # prepends AS numbers from last to first order
              prepend(as_number, ...)
typedef:      # a community value in RPSL is either
              #  - a 4 byte integer (ok to use 3561:70 notation)
              #  - internet, no_export, no_advertise (see <a href="rfc1997.html">RFC-1997</a>)
              community_elm union
                  integer[1, 4294967295],
                  enum[internet, no_export, no_advertise],
typedef:      # list of community values { 40, no_export, 3561:70 }
              community_list list of community_elm
rp-attribute: # BGP community attribute
              community
              # set to a list of communities
              operator=(community_list)
              # append community values
              operator.=(community_list)
              append(community_elm, ...)
              # delete community values
              delete(community_elm, ...)
              # a filter: true if one of community values is contained
              contains(community_elm, ...)
              # shortcut to contains: community(no_export, 3561:70)
              operator()(community_elm, ...)
              # order independent equality comparison
              operator==(community_list)
rp-attribute: # next hop router in a static route
              next-hop
              # to set to 7.7.7.7: next-hop = 7.7.7.7;



<span class="grey">Alaettinoglu, et al.        Standards Track                    [Page 41]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-42" id="page-42" name="page-42"> </a>
<span class="grey"><a href="rfc2622.html">RFC 2622</a>                          RPSL                         June 1999</span>


              # to set to router's own address: next-hop = self;
              operator=(union ipv4_address, enum[self])
rp-attribute: # cost of a static route
              cost
              operator=(integer[0, 65535])
protocol: BGP4
          # as number of the peer router
          MANDATORY asno(as_number)
          # enable flap damping
          OPTIONAL flap_damp()
          OPTIONAL flap_damp(integer[0,65535],
                             # penalty per flap
                             integer[0,65535],
                             # penalty value for supression
                             integer[0,65535],
                             # penalty value for reuse
                             integer[0,65535],
                             # halflife in secs when up
                             integer[0,65535],
                             # halflife in secs when down
                             integer[0,65535])
                             # maximum penalty
protocol: OSPF
protocol: RIP
protocol: IGRP
protocol: IS-IS
protocol: STATIC
protocol: RIPng
protocol: DVMRP
protocol: PIM-DM
protocol: PIM-SM
protocol: CBT
protocol: MOSPF


                        Figure 27:  RPSL Dictionary

   Figure 27 shows the initial RPSL dictionary.  It has seven rp-
   attributes:  pref to assign local preference to the routes accepted;
   med to assign a value to the MULTI_EXIT_DISCRIMINATOR BGP attribute;
   dpa to assign a value to the DPA BGP attribute; aspath to prepend a
   value to the AS_PATH BGP attribute; community to assign a value to or
   to check the value of the community BGP attribute; next-hop to assign
   next hop routers to static routes; and cost to assign a cost to
   static routes.  The dictionary defines two types:  community_elm and
   community_list.  community_elm type is either a 4-byte unsigned
   integer, or one of the keywords internet, no_export or no_advertise
   (defined in [<a href="#ref-9" title='"BGP Communities Attribute"'>9</a>]).  An integer can be specified using two 2-byte



<span class="grey">Alaettinoglu, et al.        Standards Track                    [Page 42]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-43" id="page-43" name="page-43"> </a>
<span class="grey"><a href="rfc2622.html">RFC 2622</a>                          RPSL                         June 1999</span>


   integers seperated by ":"  to partition the community number space so
   that a provider can use its AS number as the first two bytes, and
   assigns a semantics of its choice to the last two bytes.

   The initial dictionary (Figure 27) defines only options for the
   Border Gateway Protocol:  asno and flap_damp.  The mandatory asno
   option is the AS number of the peer router.  The optional flap_damp
   option instructs the router to damp route flaps [<a href="#ref-21" title='"BGP Route Flap Damping"'>21</a>] when importing
   routes from the peer router.

   It can be specified with or without parameters.  If parameters are
   missing, they default to:

   flap_damp(1000, 2000, 750, 900, 900, 20000)

   That is, a penalty of 1000 is assigned at each route flap, the route
   is suppressed when penalty reaches 2000.  The penalty is reduced in
   half after 15 minutes (900 seconds) of stability regardless of
   whether the route is up or down.  A supressed route is reused when
   the penalty falls below 750.  The maximum penalty a route can be
   assigned is 20,000 (i.e. the maximum suppress time after a route
   becomes stable is about 75 minutes).  These parameters are consistent
   with the default flap damping parameters in several routers.

Policy Actions and Filters Using RP-Attributes

   The syntax of a policy action or a filter using an rp-attribute x is
   as follows:

    x.method(arguments)
    x "op" argument

   where method is a method and "op" is an operator method of the rp-
   attribute x.  If an operator method is used in specifying a composite
   policy filter, it evaluates earlier than the composite policy filter
   operators (i.e. AND, OR, NOT, and implicit or operator).

   The pref rp-attribute can be assigned a positive integer as follows:

   pref = 10;

   The med rp-attribute can be assigned either a positive integer or the
   word "igp_cost" as follows:

   med = 0;
   med = igp_cost;

   The dpa rp-attribute can be assigned a positive integer as follows:



<span class="grey">Alaettinoglu, et al.        Standards Track                    [Page 43]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-44" id="page-44" name="page-44"> </a>
<span class="grey"><a href="rfc2622.html">RFC 2622</a>                          RPSL                         June 1999</span>


   dpa = 100;

   The BGP community attribute is list-valued, that is it is a list of
   4-byte integers each representing a "community".  The following
   examples demonstrate how to add communities to this rp-attribute:

   community .= { 100 };
   community .= { NO_EXPORT };
   community .= { 3561:10 };

   In the last case, a 4-byte integer is constructed where the more
   significant two bytes equal 3561 and the less significant two bytes
   equal 10.  The following examples demonstrate how to delete
   communities from the community rp-attribute:

   community.delete(100, NO_EXPORT, 3561:10);

   Filters that use the community rp-attribute can be defined as
   demonstrated by the following examples:

   community.contains(100, NO_EXPORT, 3561:10);
   community(100, NO_EXPORT, 3561:10);             # shortcut

   The community rp-attribute can be set to a list of communities as
   follows:

   community = {100, NO_EXPORT, 3561:10, 200};
   community = {};

   In this first case, the community rp-attribute contains the
   communities 100, NO_EXPORT, 3561:10, and 200.  In the latter case,
   the community rp-attribute is cleared.  The community rp-attribute
   can be compared against a list of communities as follows:

   community == {100, NO_EXPORT, 3561:10, 200};   # exact match

   To influence the route selection, the BGP as_path rp-attribute can be
   made longer by prepending AS numbers to it as follows:

   aspath.prepend(AS1);
   aspath.prepend(AS1, AS1, AS1);

   The following examples are invalid:

   med = -50;                     # -50 is not in the range
   med = igp;                     # igp is not one of the enum values
   med.assign(10);                # method assign is not defined
   community.append(AS3561:20);   # the first argument should be 3561



<span class="grey">Alaettinoglu, et al.        Standards Track                    [Page 44]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-45" id="page-45" name="page-45"> </a>
<span class="grey"><a href="rfc2622.html">RFC 2622</a>                          RPSL                         June 1999</span>


   Figure 28 shows a more advanced example using the rp-attribute
   community.  In this example, AS3561 bases its route selection
   preference on the community attribute.  Other ASes may indirectly
   affect AS3561's route selection by including the appropriate
   communities in their route announcements.

    aut-num: AS1
    export: to AS2 action community.={3561:90};
            to AS3 action community.={3561:80};
            announce AS1

    as-set: AS3561:AS-PEERS
    members: AS2, AS3

    aut-num: AS3561
    import: from AS3561:AS-PEERS
            action pref = 10;
            accept community(3561:90)
    import: from AS3561:AS-PEERS
            action pref = 20;
            accept community(3561:80)
    import: from AS3561:AS-PEERS
            action pref = 20;
            accept community(3561:70)
    import: from AS3561:AS-PEERS
            action pref = 0;
            accept ANY


           Figure 28:  Policy example using the community rp-attribute.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/8%20Advanced%20route%20Class"></a><a class="selflink" href="#section-8" name="section-8">8</a> Advanced route Class</span>

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/8.1%20Specifying%20Aggregate%20Routes"></a><a class="selflink" href="#section-8.1" name="section-8.1">8.1</a> Specifying Aggregate Routes</span>

   The components, aggr-bndry, aggr-mtd, export-comps, inject, and holes
   attributes are used for specifying aggregate routes [<a href="#ref-11" title='"Classless Inter- Domain Routing (CIDR): an Address Assignment and Aggregation Strategy"'>11</a>].  A route
   object specifies an aggregate route if any of these attributes, with
   the exception of inject, is specified.  The origin attribute for an
   aggregate route is the AS performing the aggregation, i.e. the
   aggregator AS. In this section, we used the term "aggregate" to refer
   to the route generated, the term "component" to refer to the routes
   used to generate the path attributes of the aggregate, and the term
   "more specifics" to refer to any route which is a more specific of
   the aggregate regardless of whether it was used to form the path
   attributes.





<span class="grey">Alaettinoglu, et al.        Standards Track                    [Page 45]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-46" id="page-46" name="page-46"> </a>
<span class="grey"><a href="rfc2622.html">RFC 2622</a>                          RPSL                         June 1999</span>


   The components attribute defines what component routes are used to
   form the aggregate.  Its syntax is as follows:

   components: [ATOMIC] [[&lt;filter&gt;] [protocol &lt;protocol&gt; &lt;filter&gt; ...]]

   where &lt;protocol&gt; is a routing protocol name such as BGP4, OSPF or RIP
   (valid names are defined in the dictionary) and &lt;filter&gt; is a policy
   expression.  The routes that match one of these filters and are
   learned from the corresponding protocol are used to form the
   aggregate.  If &lt;protocol&gt; is omitted, it defaults to any protocol.
   &lt;filter&gt; implicitly contains an "AND" term with the more specifics of
   the aggregate so that only the component routes are selected.  If the
   keyword ATOMIC is used, the aggregation is done atomically [<a href="#ref-11" title='"Classless Inter- Domain Routing (CIDR): an Address Assignment and Aggregation Strategy"'>11</a>].  If
   a &lt;filter&gt; is not specified it defaults to more specifics.  If the
   components attribute is missing, all more specifics without the
   ATOMIC keyword is used.

   route: 128.8.0.0/15
   origin: AS1
   components: &lt;^AS2&gt;

   route: 128.8.0.0/15
   origin: AS1
   components: protocol BGP4 {128.8.0.0/16^+}
               protocol OSPF {128.9.0.0/16^+}


                  Figure 29:  Two aggregate route objects.

   Figure 29 shows two route objects.  In the first example, more
   specifics of 128.8.0.0/15 with AS paths starting with AS2 are
   aggregated.  In the second example, some routes learned from BGP and
   some routes learned form OSPF are aggregated.

   The aggr-bndry attribute is an AS expression over AS numbers and sets
   (see <a href="#section-5.6">Section 5.6</a>).  The result defines the set of ASes which form the
   aggregation boundary.  If the aggr-bndry attribute is missing, the
   origin AS is the sole aggregation boundary.  Outside the aggregation
   boundary, only the aggregate is exported and more specifics are
   suppressed.  However, within the boundary, the more specifics are
   also exchanged.

   The aggr-mtd attribute specifies how the aggregate is generated.  Its
   syntax is as follows:

  aggr-mtd: inbound
          | outbound [&lt;as-expression&gt;]




<span class="grey">Alaettinoglu, et al.        Standards Track                    [Page 46]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-47" id="page-47" name="page-47"> </a>
<span class="grey"><a href="rfc2622.html">RFC 2622</a>                          RPSL                         June 1999</span>


   where &lt;as-expression&gt; is an expression over AS numbers and sets (see
   <a href="#section-5.6">Section 5.6</a>).  If &lt;as-expression&gt; is missing, it defaults to AS-ANY.
   If outbound aggregation is specified, the more specifics of the
   aggregate will be present within the AS and the aggregate will be
   formed at all inter-AS boundaries with ASes in &lt;as-expression&gt; before
   export, except for ASes that are within the aggregating boundary
   (i.e. aggr-bndry is enforced regardless of &lt;as-expression&gt;).  If
   inbound aggregation is specified, the aggregate is formed at all
   inter-AS boundaries prior to importing routes into the aggregator AS.
   Note that &lt;as-expression&gt; can not be specified with inbound
   aggregation.  If aggr-mtd attribute is missing, it defaults to
   "outbound AS-ANY".

   route:      128.8.0.0/15            route:      128.8.0.0/15
   origin:     AS1                     origin:     AS2
   components: {128.8.0.0/15^-}        components: {128.8.0.0/15^-}
   aggr-bndry: AS1 OR AS2              aggr-bndry: AS1 OR AS2
   aggr-mtd:   outbound AS-ANY         aggr-mtd:   outbound AS-ANY


             Figure 30:  Outbound multi-AS aggregation example.

   Figure 30 shows an example of an outbound aggregation.  In this
   example, AS1 and AS2 are coordinating aggregation and announcing only
   the less specific 128.8.0.0/15 to outside world, but exchanging more
   specifics between each other.  This form of aggregation is useful
   when some of the components are within AS1 and some are within AS2.

   When a set of routes are aggregated, the intent is to export only the
   aggregate route and suppress exporting of the more specifics outside
   the aggregation boundary.  However, to satisfy certain policy and
   topology constraints (e.g. a multi-homed component), it is often
   required to export some of the components.  The export-comps
   attribute equals an RPSL filter that matches the more specifics that
   need to be exported outside the aggregation boundary.  If this
   attribute is missing, more specifics are not exported outside the
   aggregation boundary.  Note that, the export-comps filter contains an
   implicit "AND" term with the more specifics of the aggregate.

   Figure 31 shows an example of an outbound aggregation.  In this
   example, the more specific 128.8.8.0/24 is exported outside AS1 in
   addition to the aggregate.  This is useful, when 128.8.8.0/24 is
   multi-homed site to AS1 with some other AS.








<span class="grey">Alaettinoglu, et al.        Standards Track                    [Page 47]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-48" id="page-48" name="page-48"> </a>
<span class="grey"><a href="rfc2622.html">RFC 2622</a>                          RPSL                         June 1999</span>


      route:      128.8.0.0/15
      origin:     AS1
      components: {128.8.0.0/15^-}
      aggr-mtd:   outbound AS-ANY
      export-comps: {128.8.8.0/24}


             Figure 31:  Outbound aggregation with export exception.

   The inject attribute specifies which routers perform the aggregation
   and when they perform it.  Its syntax is as follow:

  inject: [at &lt;router-expression&gt;] ...
          [action &lt;action&gt;]
          [upon &lt;condition&gt;]

   where &lt;action&gt; is an action specification (see <a href="#section-6.1.1">Section 6.1.1</a>),
   &lt;condition&gt; is a boolean expression described below, and &lt;router-
   expression&gt; is as described in <a href="#section-5.6">Section 5.6</a>.

   All routers in &lt;router-expression&gt; and in the aggregator AS perform
   the aggregation.  If a &lt;router-expression&gt; is not specified, all
   routers inside the aggregator AS perform the aggregation.  The
   &lt;action&gt; specification may set path attributes of the aggregate, such
   as assign a preferences to the aggregate.

   The upon clause is a boolean condition.  The aggregate is generated
   if and only if this condition is true.  &lt;condition&gt; is a boolean
   expression using the logical operators AND and OR (i.e. operator NOT
   is not allowed) over:

   HAVE-COMPONENTS { list of prefixes }
   EXCLUDE { list of prefixes }
   STATIC

   The list of prefixes in HAVE-COMPONENTS can only be more specifics of
   the aggregate.  It evaluates to true when all the prefixes listed are
   present in the routing table of the aggregating router.  The list can
   also include prefix ranges (i.e. using operators ^-, ^+, ^n, and ^n-
   m).  In this case, at least one prefix from each prefix range needs
   to be present in the routing table for the condition to be true.  The
   list of prefixes in EXCLUDE can be arbitrary.  It evaluates to true
   when none of the prefixes listed is present in the routing table.
   The list can also include prefix ranges, and no prefix in that range
   should be present in the routing table.  The keyword static always
   evaluates to true.  If no upon clause is specified the aggregate is
   generated if an only if there is a component in the routing table
   (i.e. a more specific that matches the filter in the components



<span class="grey">Alaettinoglu, et al.        Standards Track                    [Page 48]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-49" id="page-49" name="page-49"> </a>
<span class="grey"><a href="rfc2622.html">RFC 2622</a>                          RPSL                         June 1999</span>


   attribute).

   route:      128.8.0.0/15
   origin:     AS1
   components: {128.8.0.0/15^-}
   aggr-mtd:   outbound AS-ANY
   inject:     at 1.1.1.1 action dpa = 100;
   inject:     at 1.1.1.2 action dpa = 110;

   route:      128.8.0.0/15
   origin:     AS1
   components: {128.8.0.0/15^-}
   aggr-mtd:   outbound AS-ANY
   inject:     upon HAVE-COMPONENTS {128.8.0.0/16, 128.9.0.0/16}
   holes:      128.8.8.0/24


                      Figure 32:  Examples of inject.

   Figure 32 shows two examples.  In the first case, the aggregate is
   injected at two routers each one setting the dpa path attribute
   differently.  In the second case, the aggregate is generated only if
   both 128.8.0.0/16 and 128.9.0.0/16 are present in the routing table,
   as opposed to the first case where the presence of just one of them
   is sufficient for injection.

   The holes attribute lists the component address prefixes which are
   not reachable through the aggregate route (perhaps that part of the
   address space is unallocated).  The holes attribute is useful for
   diagnosis purposes.  In Figure 32, the second example has a hole,
   namely 128.8.8.0/24.  This may be due to a customer changing
   providers and taking this part of the address space with it.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/8.1.1%20Interaction%20with%20policies%20in%20aut-num%20class"></a><a class="selflink" href="#section-8.1.1" name="section-8.1.1">8.1.1</a> Interaction with policies in aut-num class</span>

   An aggregate formed is announced to other ASes only if the export
   policies of the AS allows exporting the aggregate.  When the
   aggregate is formed, the more specifics are suppressed from being
   exported except to the ASes in aggr-bndry and except the components
   in export-comps.  For such exceptions to happen, the export policies
   of the AS should explicitly allow exporting of these exceptions.

   If an aggregate is not formed (due to the upon clause), then the more
   specifics of the aggregate can be exported to other ASes, but only if
   the export policies of the AS allows it.  In other words, before a
   route (aggregate or more specific) is exported it is filtered twice,
   once based on the route objects, and once based on the export
   policies of the AS.



<span class="grey">Alaettinoglu, et al.        Standards Track                    [Page 49]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-50" id="page-50" name="page-50"> </a>
<span class="grey"><a href="rfc2622.html">RFC 2622</a>                          RPSL                         June 1999</span>


   route:        128.8.0.0/16
   origin:       AS1

   route:        128.9.0.0/16
   origin:       AS1

   route:        128.8.0.0/15
   origin:       AS1
   aggr-bndry:   AS1 or AS2 or AS3
   aggr-mtd:     outbound AS3 or AS4 or AS5
   components:   {128.8.0.0/16, 128.9.0.0/16}
   inject:       upon HAVE-COMPONENTS {128.9.0.0/16, 128.8.0.0/16}

   aut-num: AS1
   export:  to AS2 announce AS1
   export:  to AS3 announce AS1 and not {128.9.0.0/16}
   export:  to AS4 announce AS1
   export:  to AS5 announce AS1
   export:  to AS6 announce AS1


          Figure 33:  Interaction with policies in aut-num class.

   In Figure 33 shows an interaction example.  By examining the route
   objects, the more specifics 128.8.0.0/16 and 128.9.0.0/16 should be
   exchanged between AS1, AS2 and AS3 (i.e. the aggregation boundary).
   Outbound aggregation is done to AS4 and AS5 and not to AS3, since AS3
   is in the aggregation boundary.  The aut-num object allows exporting
   both components to AS2, but only the component 128.8.0.0/16 to AS3.
   The aggregate can only be formed if both components are available.
   In this case, only the aggregate is announced to AS4 and AS5.
   However, if one of the components is not available the aggregate will
   not be formed, and any available component or more specific will be
   exported to AS4 and AS5.  Regardless of aggregation is performed or
   not, only the more specifics will be exported to AS6 (it is not
   listed in the aggr-mtd attribute).

   When doing an inbound aggregation, configuration generators may
   eliminating the aggregation statements on routers where import policy
   of the AS prohibits importing of any more specifics.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/8.1.2%20Ambiguity%20resolution%20with%20overlapping%20aggregates"></a><a class="selflink" href="#section-8.1.2" name="section-8.1.2">8.1.2</a> Ambiguity resolution with overlapping aggregates</span>

   When several aggregate routes are specified and they overlap, i.e.
   one is less specific of the other, they must be evaluated more
   specific to less specific order.  When an outbound aggregation is
   performed for a peer, the aggregate and the components listed in the
   export-comps attribute for that peer are available for generating the



<span class="grey">Alaettinoglu, et al.        Standards Track                    [Page 50]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-51" id="page-51" name="page-51"> </a>
<span class="grey"><a href="rfc2622.html">RFC 2622</a>                          RPSL                         June 1999</span>


   next less specific aggregate.  The components that are not specified
   in the export-comps attribute are not available.  A route is
   exportable to an AS if it is the least specific aggregate exportable
   to that AS or it is listed in the export-comps attribute of an
   exportable route.  Note that this is a recursive definition.

   route:        128.8.0.0/15
   origin:       AS1
   aggr-bndry:   AS1 or AS2
   aggr-mtd:     outbound
   inject:       upon HAVE-COMPONENTS {128.8.0.0/16, 128.9.0.0/16}

   route:        128.10.0.0/15
   origin:       AS1
   aggr-bndry:   AS1 or AS3
   aggr-mtd:     outbound
   inject:       upon HAVE-COMPONENTS {128.10.0.0/16, 128.11.0.0/16}
   export-comps: {128.11.0.0/16}

   route:        128.8.0.0/14
   origin:       AS1
   aggr-bndry:   AS1 or AS2 or AS3
   aggr-mtd:     outbound
   inject:       upon HAVE-COMPONENTS {128.8.0.0/15, 128.10.0.0/15}
   export-comps: {128.10.0.0/15}


                   Figure 34:  Overlapping aggregations.

   In Figure 34, AS1 together with AS2 aggregates 128.8.0.0/16 and
   128.9.0.0/16 into 128.8.0.0/15.  Together with AS3, AS1 aggregates
   128.10.0.0/16 and 128.11.0.0/16 into 128.10.0.0/15.  But altogether
   they aggregate these four routes into 128.8.0.0/14.  Assuming all
   four components are available, a router in AS1 for an outside AS, say
   AS4, will first generate 128.8.0.0/15 and 128.10.0.0/15.  This will
   make 128.8.0.0/15, 128.10.0.0/15 and its exception 128.11.0.0/16
   available for generating 128.8.0.0/14.  The router will then generate
   128.8.0.0/14 from these three routes.  Hence for AS4, 128.8.0.0/14
   and its exception 128.10.0.0/15 and its exception 128.11.0.0/16 will
   be exportable.

   For AS2, a router in AS1 will only generate 128.10.0.0/15.  Hence,
   128.10.0.0/15 and its exception 128.11.0.0/16 will be exportable.
   Note that 128.8.0.0/16 and 128.9.0.0/16 are also exportable since
   they did not participate in an aggregate exportable to AS2.






<span class="grey">Alaettinoglu, et al.        Standards Track                    [Page 51]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-52" id="page-52" name="page-52"> </a>
<span class="grey"><a href="rfc2622.html">RFC 2622</a>                          RPSL                         June 1999</span>


   Similarly, for AS3, a router in AS1 will only generate 128.8.0.0/15.
   In this case 128.8.0.0/15, 128.10.0.0/16, 128.11.0.0/16 are
   exportable.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/8.2%20Specifying%20Static%20Routes"></a><a class="selflink" href="#section-8.2" name="section-8.2">8.2</a> Specifying Static Routes</span>

   The inject attribute can be used to specify static routes by using
   "upon static" as the condition:

  inject: [at &lt;router-expression&gt;] ...
          [action &lt;action&gt;]
          upon static

   In this case, the routers in &lt;router-expression&gt; executes the
   &lt;action&gt; and injects the route to the interAS routing system
   statically.  &lt;action&gt; may set certain route attributes such as a
   next-hop router or a cost.

   In the following example, the router 7.7.7.1 injects the route
   128.7.0.0/16.  The next-hop routers (in this example, there are two
   next-hop routers) for this route are 7.7.7.2 and 7.7.7.3 and the
   route has a cost of 10 over 7.7.7.2 and 20 over 7.7.7.3.

   route:  128.7.0.0/16
   origin: AS1
   inject: at 7.7.7.1 action next-hop = 7.7.7.2; cost = 10; upon static
   inject: at 7.7.7.1 action next-hop = 7.7.7.3; cost = 20; upon static

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/9%20inet-rtr%20Class"></a><a class="selflink" href="#section-9" name="section-9">9</a> inet-rtr Class</span>

Routers are specified using the inet-rtr class.  The attributes of the
inet-rtr class are shown in Figure 35.  The inet-rtr attribute is a valid
DNS name of the router described.  Each alias attribute, if present, is a
canonical DNS name for the router.  The local-as attribute specifies the AS
number of the AS which owns/operates this router.

  Attribute  Value                    Type
  inet-rtr   &lt;dns-name&gt;               mandatory, single-valued, class key
  alias      &lt;dns-name&gt;               optional, multi-valued
  local-as   &lt;as-number&gt;              mandatory, single-valued
  ifaddr     see description in text  mandatory, multi-valued
  peer       see description in text  optional, multi-valued
  member-of  list of &lt;rtr-set-names&gt;  optional, multi-valued


                   Figure 35:  inet-rtr Class Attributes





<span class="grey">Alaettinoglu, et al.        Standards Track                    [Page 52]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-53" id="page-53" name="page-53"> </a>
<span class="grey"><a href="rfc2622.html">RFC 2622</a>                          RPSL                         June 1999</span>


   The value of an ifaddr attribute has the following syntax:

   &lt;ipv4-address&gt; masklen &lt;integer&gt; [action &lt;action&gt;]

   The IP address and the mask length are mandatory for each interface.
   Optionally an action can be specified to set other parameters of this
   interface.

   Figure 36 presents an example inet-rtr object.  The name of the
   router is "amsterdam.ripe.net".  "amsterdam1.ripe.net" is a canonical
   name for the router.  The router is connected to 4 networks.  Its IP
   addresses and mask lengths in those networks are specified in the
   ifaddr attributes.

    inet-rtr: Amsterdam.ripe.net
    alias:    amsterdam1.ripe.net
    local-as: AS3333
    ifaddr:   192.87.45.190 masklen 24
    ifaddr:   192.87.4.28   masklen 24
    ifaddr:   193.0.0.222   masklen 27
    ifaddr:   193.0.0.158   masklen 27
    peer:     BGP4 192.87.45.195 asno(AS3334), flap_damp()


                           Figure 36:  inet-rtr Objects

   Each peer attribute, if present, specifies a protocol peering with
   another router.  The value of a peer attribute has the following
   syntax:

     &lt;protocol&gt; &lt;ipv4-address&gt;      &lt;options&gt;
   | &lt;protocol&gt; &lt;inet-rtr-name&gt;     &lt;options&gt;
   | &lt;protocol&gt; &lt;rtr-set-name&gt;      &lt;options&gt;
   | &lt;protocol&gt; &lt;peering-set-name&gt;  &lt;options&gt;

   where &lt;protocol&gt; is a protocol name, &lt;ipv4-address&gt; is the IP address
   of the peer router, and &lt;options&gt; is a comma separated list of
   peering options for &lt;protocol&gt;.  Instead of the peer's IP address,
   its inet-rtr-name can be used.  Possible protocol names and
   attributes are defined in the dictionary (please see <a href="#section-7">Section 7</a>).  In
   the above example, the router has a BGP peering with the router
   192.87.45.195 in AS3334 and turns the flap damping on when importing
   routes from this router.

   Instead of a single peer, a group of peers can be specified by using
   the &lt;rtr-set-name&gt; and &lt;peering-set-name&gt; forms.  If &lt;peering-set-
   name&gt; form is being used only the peerings in the corresponding
   peering set that are with this router are included.  Figure 37 shows



<span class="grey">Alaettinoglu, et al.        Standards Track                    [Page 53]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-54" id="page-54" name="page-54"> </a>
<span class="grey"><a href="rfc2622.html">RFC 2622</a>                          RPSL                         June 1999</span>


   an example inet-rtr object with peering groups.

    rtr-set: rtrs-ibgp-peers
    members: 1.1.1.1, 2.2.2.2, 3.3.3.3

    peering-set: prng-ebgp-peers
    peering: AS3334 192.87.45.195
    peering: AS3335 192.87.45.196

    inet-rtr: Amsterdam.ripe.net
    alias:    amsterdam1.ripe.net
    local-as: AS3333
    ifaddr:   192.87.45.190 masklen 24
    ifaddr:   192.87.4.28   masklen 24
    ifaddr:   193.0.0.222   masklen 27
    ifaddr:   193.0.0.158   masklen 27
    peer:     BGP4 rtrs-ibgp-peers asno(AS3333), flap_damp()
    peer:     BGP4 prng-ebgp-peers asno(PeerAS), flap_damp()


                 Figure 37:  inet-rtr Object with peering groups

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/10%20Extending%20RPSL"></a><a class="selflink" href="#section-10" name="section-10">10</a> Extending RPSL</span>

   Our experience with earlier routing policy languages and data formats
   (PRDB [<a href="#ref-2" title="Ann Arbor">2</a>], RIPE-81 [<a href="#ref-8" title="P. Lothberg">8</a>], and RIPE-181 [<a href="#ref-7" title='" Representation of IP Routing Policies in a Routing Registry"'>7</a>]) taught us that RPSL had to
   be extensible.  As a result, extensibility was a primary design goal
   for RPSL.  New routing protocols or new features to existing routing
   protocols can be easily handled using RPSL's dictionary class.  New
   classes or new attributes to the existing classes can also be added.

   This section provides guidelines for extending RPSL. These guidelines
   are designed with an eye toward maintaining backward compatibility
   with existing tools and databases.  We next list the available
   options for extending RPSL from the most preferred to the least
   preferred order.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/10.1%20Extensions%20by%20changing%20the%20dictionary%20class"></a><a class="selflink" href="#section-10.1" name="section-10.1">10.1</a> Extensions by changing the dictionary class</span>

   The dictionary class is the primary mechanism provided to extend
   RPSL.  Dictionary objects define routing policy attributes, types,
   and routing protocols.

   We recommend updating the RPSL dictionary to include appropriate rp-
   attribute and protocol definitions as new path attributes or router
   features are introduced.  For example, in an earlier version of the
   RPSL document, it was only possible to specify that a router performs
   route flap damping on a peer, but it was not possible to specify the



<span class="grey">Alaettinoglu, et al.        Standards Track                    [Page 54]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-55" id="page-55" name="page-55"> </a>
<span class="grey"><a href="rfc2622.html">RFC 2622</a>                          RPSL                         June 1999</span>


   parameters of route flap damping.  Later the parameters were added by
   changing the dictionary.

   When changing the dictionary, full compatibility should be
   maintained.  For example, in our flap damping case, we made the
   parameter specification optional in case this level of detail was not
   desired by some ISPs.  This also achieved compatibility.  Any object
   registered without the parameters will continue to be valid.  Any
   tool based on RPSL is expected to do a default action on routing
   policy attributes that they do not understand (e.g. issue a warning
   and otherwise ignore).  Hence, old tools upon encountering a flap
   damping specification with parameters will ignore the parameters.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/10.2%20Extensions%20by%20adding%20new%20attributes%20to%20existing%20classes"></a><a class="selflink" href="#section-10.2" name="section-10.2">10.2</a> Extensions by adding new attributes to existing classes</span>

   New attributes can be added to any class.  To ensure full
   compatibility, new attributes should not contradict the semantics of
   the objects they are attached to.  Any tool that uses the IRR should
   be designed so that it ignores attributes that it doesn't understand.
   Most existing tools adhere to this design principle.

   We recommend adding new attributes to existing classes when a new
   aspect of a class is discovered.  For example, RPSL route class
   extends its RIPE-181 predecessor by including several new attributes
   that enable aggregate and static route specification.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/10.3%20Extensions%20by%20adding%20new%20classes"></a><a class="selflink" href="#section-10.3" name="section-10.3">10.3</a> Extensions by adding new classes</span>

   New classes can be added to RPSL to store new types of policy data.
   Providing full compatibility is straight forward as long as existing
   classes are still understood.  Since a tool should only query the IRR
   for the classes that it understand, full compatibility should not be
   a problem in this case.

   Before adding a new class, one should question if the information
   contained in the objects of the new class could have better belonged
   to some other class.  For example, if the geographic location of a
   router needs to be stored in IRR, it may be tempting to add a new
   class called, say router-location class.  However, the information
   better belongs to the inet-rtr class, perhaps in a new attribute
   called location.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/10.4%20Extensions%20by%20changing%20the%20syntax%20of%20existing%20RPSL%20attributes"></a><a class="selflink" href="#section-10.4" name="section-10.4">10.4</a> Extensions by changing the syntax of existing RPSL attributes</span>

   If all of the methods described above fail to provide the desired
   extension, it may be necessary to change the syntax of RPSL. Any
   change in RPSL syntax must provide backwards compatibility, and
   should be considered only as a last resort since full compatibility



<span class="grey">Alaettinoglu, et al.        Standards Track                    [Page 55]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-56" id="page-56" name="page-56"> </a>
<span class="grey"><a href="rfc2622.html">RFC 2622</a>                          RPSL                         June 1999</span>


   may not be achievable.  However, we require that the old syntax to be
   still valid.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/11%20Security%20Considerations"></a><a class="selflink" href="#section-11" name="section-11">11</a> Security Considerations</span>

   This document describes RPSL, a language for expressing routing
   policies.  The language defines a maintainer (mntner class) object
   which is the entity which controls or "maintains" the objects stored
   in a database expressed by RPSL. Requests from maintainers can be
   authenticated with various techniques as defined by the "auth"
   attribute of the maintainer object.

   The exact protocols used by IRR's to communicate RPSL objects is
   beyond the scope of this document, but it is envisioned that several
   techniques may be used, ranging from interactive query/update
   protocols to store and forward protocols similar to or based on
   electronic mail (or even voice telephone calls).  Regardless of which
   protocols are used in a given situation, it is expected that
   appropriate security techniques such as IPSEC, TLS or PGP/MIME will
   be utilized.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/12%20Acknowledgements"></a><a class="selflink" href="#section-12" name="section-12">12</a> Acknowledgements</span>

   We would like to thank Jessica Yu, Randy Bush, Alan Barrett, Bill
   Manning, Sue Hares, Ramesh Govindan, Kannan Varadhan, Satish Kumar,
   Craig Labovitz, Rusty Eddy, David J. LeRoy, David Whipple, Jon
   Postel, Deborah Estrin, Elliot Schwartz, Joachim Schmitz, Mark Prior,
   Tony Przygienda, David Woodgate, Rob Coltun, Sanjay Wadhwa, Ardas
   Cilingiroglu, and the participants of the IETF RPS Working Group for
   various comments and suggestions.

References

   [<a id="ref-1" name="ref-1">1</a>] Internet routing registry. procedures.
       <a href="http://www.ra.net/RADB.tools.docs/">http://www.ra.net/RADB.tools.docs/</a>,
       <a href="http://www.ripe.net/db/doc.html">http://www.ripe.net/db/doc.html</a>.

   [<a id="ref-2" name="ref-2">2</a>] Nsfnet policy routing database (prdb). Maintained by MERIT
       Network Inc., Ann Arbor, Michigan. Contents available from
       nic.merit.edu.:/nsfnet/announced.networks/nets.tag.now by
       anonymous ftp.

   [<a id="ref-3" name="ref-3">3</a>] Alaettinouglu, C., Bates, T., Gerich, E., Karrenberg, D., Meyer,
       D., Terpstra, M. and C. Villamizer, "Routing Policy Specification
       Language (RPSL)", <a href="rfc2280.html">RFC 2280</a>, January 1998.






<span class="grey">Alaettinoglu, et al.        Standards Track                    [Page 56]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-57" id="page-57" name="page-57"> </a>
<span class="grey"><a href="rfc2622.html">RFC 2622</a>                          RPSL                         June 1999</span>


   [<a id="ref-4" name="ref-4">4</a>] C. Alaettinouglu, D. Meyer, and J. Schmitz. Application of
       routing policy specification language (rpsl) on the internet.
       Work in Progress.

   [<a id="ref-5" name="ref-5">5</a>] T. Bates. Specifying an `internet router' in the routing
       registry.  Technical Report RIPE-122, RIPE, RIPE NCC, Amsterdam,
       Netherlands, October 1994.

   [<a id="ref-6" name="ref-6">6</a>] T. Bates, E. Gerich, L. Joncheray, J-M. Jouanigot, D. Karrenberg,
       M. Terpstra, and J. Yu. Representation of ip routing policies in
       a routing registry. Technical Report ripe-181, RIPE, RIPE NCC,
       Amsterdam, Netherlands, October 1994.

   [<a id="ref-7" name="ref-7">7</a>] Bates, T., Gerich, E., Joncheray, L., Jouanigot, J-M.,
       Karrenberg, D., Terpstra, M. and J. Yu, " Representation of IP
       Routing Policies in a Routing Registry", <a href="rfc1786.html">RFC 1786</a>, March 1995.

   [<a id="ref-8" name="ref-8">8</a>] T. Bates, J-M. Jouanigot, D. Karrenberg, P. Lothberg, and M.
       Terpstra.  Representation of ip routing policies in the ripe
       database. Technical Report ripe-81, RIPE, RIPE NCC, Amsterdam,
       Netherlands, February 1993.

   [<a id="ref-9" name="ref-9">9</a>] Chandra, R., Traina, P. and T. Li, "BGP Communities Attribute",
       <a href="rfc1997.html">RFC 1997</a>, August 1996.

  [<a id="ref-10" name="ref-10">10</a>] Crocker, D., "Standard for ARPA Internet Text Messages", STD 11,
       <a href="rfc822.html">RFC 822</a>, August 1982.

  [<a id="ref-11" name="ref-11">11</a>] Fuller, V., Li, T., Yu, J. and K. Varadhan, "Classless Inter-
       Domain Routing (CIDR): an Address Assignment and Aggregation
       Strategy", <a href="rfc1519.html">RFC 1519</a>, September 1993.

  [<a id="ref-12" name="ref-12">12</a>] D. Karrenberg and T. Bates. Description of inter-as networks in
       the ripe routing registry. Technical Report RIPE-104, RIPE, RIPE
       NCC, Amsterdam, Netherlands, December 1993.

  [<a id="ref-13" name="ref-13">13</a>] D. Karrenberg and M. Terpstra. Authorisation and notification of
       changes in the ripe database. Technical Report ripe-120, RIPE,
       RIPE NCC, Amsterdam, Netherlands, October 1994.

  [<a id="ref-14" name="ref-14">14</a>] B. W. Kernighan and D. M. Ritchie. The C Programming Language.
       Prentice-Hall, 1978.

  [<a id="ref-15" name="ref-15">15</a>] A. Lord and M. Terpstra. Ripe database template for networks and
       persons. Technical Report ripe-119, RIPE, RIPE NCC, Amsterdam,
       Netherlands, October 1994.





<span class="grey">Alaettinoglu, et al.        Standards Track                    [Page 57]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-58" id="page-58" name="page-58"> </a>
<span class="grey"><a href="rfc2622.html">RFC 2622</a>                          RPSL                         June 1999</span>


  [<a id="ref-16" name="ref-16">16</a>] A. M. R. Magee. Ripe ncc database documentation. Technical Report
       RIPE-157, RIPE, RIPE NCC, Amsterdam, Netherlands, May 1997.

  [<a id="ref-17" name="ref-17">17</a>] Mockapetris, P., "Domain names - concepts and facilities", STD
       13, <a href="rfc1034.html">RFC 1034</a>, November 1987.

  [<a id="ref-18" name="ref-18">18</a>] Y. Rekhter. Inter-domain routing protocol (idrp). Journal of
       Internetworking Research and Experience, 4:61--80, 1993.

  [<a id="ref-19" name="ref-19">19</a>] Rekhter Y. and T. Li, "A Border Gateway Protocol 4 (BGP-4)", <a href="rfc1771.html">RFC</a>
       <a href="rfc1771.html">1771</a>, March 1995.

  [<a id="ref-20" name="ref-20">20</a>] C. Villamizar, C. Alaettinouglu, D. Meyer, S. Murphy, and C.
       Orange.  Routing policy system security", Work in Progress.

  [<a id="ref-21" name="ref-21">21</a>] Villamizar, C., Chandra, R. and R. Govindan, "BGP Route Flap
       Damping", <a href="rfc2439.html">RFC 2439</a>, November 1998.

  [<a id="ref-22" name="ref-22">22</a>] J. Zsako, <a href="http://www.google.com/search?sitesearch=tools.ietf.org%2Fhtml%2F&amp;q=inurl:draft-+%22PGP+authentication+for+ripe+database+updates%22" style="text-decoration: none">"PGP authentication for ripe database updates"</a>, Work in
       Progress.































<span class="grey">Alaettinoglu, et al.        Standards Track                    [Page 58]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-59" id="page-59" name="page-59"> </a>
<span class="grey"><a href="rfc2622.html">RFC 2622</a>                          RPSL                         June 1999</span>


<span class="h1"><a class="selflink" href="#appendix-A" name="appendix-A">A</a> Routing Registry Sites</span>

   The set of routing registries as of November 1996 are RIPE, RADB,
   CANet, MCI and ANS. You may contact one of these registries to find
   out the current list of registries.

<span class="h1"><a class="selflink" href="#appendix-B" name="appendix-B">B</a> Grammar Rules</span>

   In this section we provide formal grammar rules for RPSL. Basic data
   types are defined in <a href="#section-2">Section 2</a>.  We do not provide formal grammar
   rules for attributes whose values are of basic types or list of basic
   types.  The rules are written using the input language of GNU Bison
   parser.  Hence, they can be cut and pasted to that program.

//**** Generic Attributes **********************************************

changed_attribute: ATTR_CHANGED TKN_EMAIL TKN_INT

//**** aut-num class ***************************************************

//// as_expression /////////////////////////////////////////////////////

opt_as_expression:
| as_expression

as_expression: as_expression OP_OR as_expression_term
| as_expression_term

as_expression_term: as_expression_term OP_AND as_expression_factor
| as_expression_term KEYW_EXCEPT as_expression_factor
| as_expression_factor

as_expression_factor: '(' as_expression ')'
| as_expression_operand

as_expression_operand: TKN_ASNO
| TKN_ASNAME

//// router_expression /////////////////////////////////////////////////

opt_router_expression:
| router_expression

opt_router_expression_with_at:
| KEYW_AT router_expression

router_expression: router_expression OP_OR router_expression_term
| router_expression_term



<span class="grey">Alaettinoglu, et al.        Standards Track                    [Page 59]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-60" id="page-60" name="page-60"> </a>
<span class="grey"><a href="rfc2622.html">RFC 2622</a>                          RPSL                         June 1999</span>


router_expression_term: router_expression_term OP_AND
                        router_expression_factor
| router_expression_term KEYW_EXCEPT router_expression_factor
| router_expression_factor

router_expression_factor: '(' router_expression ')'
| router_expression_operand

router_expression_operand: TKN_IPV4
| TKN_DNS
| TKN_RTRSNAME

//// peering ///////////////////////////////////////////////////////////

peering: as_expression opt_router_expression opt_router_expression_with_at
| TKN_PRNGNAME

//// action ////////////////////////////////////////////////////////////

opt_action:
| KEYW_ACTION action

action: single_action
| action single_action
single_action: TKN_RP_ATTR '.' TKN_WORD '(' generic_list ')' ';'
| TKN_RP_ATTR TKN_OPERATOR list_item ';'
| TKN_RP_ATTR '(' generic_list ')' ';'
| TKN_RP_ATTR '[' generic_list ']' ';'
| ';'

//// filter ////////////////////////////////////////////////////////////

filter: filter OP_OR filter_term
| filter filter_term %prec OP_OR
| filter_term

filter_term : filter_term OP_AND filter_factor
| filter_factor

filter_factor :  OP_NOT filter_factor
| '(' filter ')'
| filter_operand

filter_operand: KEYW_ANY
| '&lt;' filter_aspath '&gt;'
| filter_rp_attribute
| TKN_FLTRNAME
| filter_prefix



<span class="grey">Alaettinoglu, et al.        Standards Track                    [Page 60]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-61" id="page-61" name="page-61"> </a>
<span class="grey"><a href="rfc2622.html">RFC 2622</a>                          RPSL                         June 1999</span>


filter_prefix: filter_prefix_operand OP_MS
|  filter_prefix_operand

filter_prefix_operand: TKN_ASNO
| KEYW_PEERAS
| TKN_ASNAME
| TKN_RSNAME
| '{' opt_filter_prefix_list '}'

opt_filter_prefix_list:
| filter_prefix_list

filter_prefix_list: filter_prefix_list_prefix
| filter_prefix_list ',' filter_prefix_list_prefix

filter_prefix_list_prefix: TKN_PRFXV4
| TKN_PRFXV4RNG

filter_aspath: filter_aspath '|' filter_aspath_term
| filter_aspath_term

filter_aspath_term: filter_aspath_term filter_aspath_closure
| filter_aspath_closure

filter_aspath_closure: filter_aspath_closure '*'
| filter_aspath_closure '?'
| filter_aspath_closure '+'
| filter_aspath_factor

filter_aspath_factor: '^'
| '$'
| '(' filter_aspath ')'
| filter_aspath_no

filter_aspath_no: TKN_ASNO
| KEYW_PEERAS
| TKN_ASNAME
| '.'
| '[' filter_aspath_range ']'
| '[' '^' filter_aspath_range ']'

filter_aspath_range:
| filter_aspath_range TKN_ASNO
| filter_aspath_range KEYW_PEERAS
| filter_aspath_range '.'
| filter_aspath_range TKN_ASNO '-' TKN_ASNO
| filter_aspath_range TKN_ASNAME




<span class="grey">Alaettinoglu, et al.        Standards Track                    [Page 61]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-62" id="page-62" name="page-62"> </a>
<span class="grey"><a href="rfc2622.html">RFC 2622</a>                          RPSL                         June 1999</span>


filter_rp_attribute: TKN_RP_ATTR '.' TKN_WORD '(' generic_list ')'
| TKN_RP_ATTR TKN_OPERATOR list_item
| TKN_RP_ATTR '(' generic_list ')'
| TKN_RP_ATTR '[' generic_list ']'

//// peering action pair ///////////////////////////////////////////////

import_peering_action_list: KEYW_FROM peering opt_action
| import_peering_action_list KEYW_FROM peering opt_action

export_peering_action_list: KEYW_TO peering opt_action
| export_peering_action_list KEYW_TO peering opt_action

//// import/export factor //////////////////////////////////////////////

import_factor: import_peering_action_list KEYW_ACCEPT filter

import_factor_list: import_factor ';'
| import_factor_list import_factor ';'

export_factor: export_peering_action_list KEYW_ANNOUNCE filter

export_factor_list: export_factor ';'
| export_factor_list export_factor ';'

//// import/export term ////////////////////////////////////////////////

import_term: import_factor ';'
| '{' import_factor_list '}'

export_term: export_factor ';'
| '{' export_factor_list '}'

//// import/export expression //////////////////////////////////////////

import_expression: import_term
| import_term KEYW_REFINE import_expression
| import_term KEYW_EXCEPT import_expression

export_expression: export_term
| export_term KEYW_REFINE export_expression
| export_term KEYW_EXCEPT export_expression

//// protocol ///////////////////////////////////////////////////////////

opt_protocol_from:
| KEYW_PROTOCOL tkn_word




<span class="grey">Alaettinoglu, et al.        Standards Track                    [Page 62]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-63" id="page-63" name="page-63"> </a>
<span class="grey"><a href="rfc2622.html">RFC 2622</a>                          RPSL                         June 1999</span>


opt_protocol_into:
| KEYW_INTO tkn_word

//**** import/export attributes ****************************************

import_attribute: ATTR_IMPORT
| ATTR_IMPORT opt_protocol_from opt_protocol_into import_factor

export_attribute: ATTR_EXPORT
| ATTR_EXPORT opt_protocol_from opt_protocol_into export_factor

opt_default_filter:
| KEYW_NETWORKS filter

default_attribute: ATTR_DEFAULT KEYW_TO peering

filter_attribute: ATTR_FILTER filter

peering_attribute: ATTR_PEERING peering

//**** inet-rtr class **************************************************

ifaddr_attribute: ATTR_IFADDR TKN_IPV4 KEYW_MASKLEN TKN_INT opt_action

//// peer attribute ////////////////////////////////////////////////////

opt_peer_options:
| peer_options

peer_options: peer_option
| peer_options ',' peer_option

peer_option: tkn_word '(' generic_list ')'

peer_id: TKN_IPV4
| TKN_DNS
| TKN_RTRSNAME
| TKN_PRNGNAME

peer_attribute: ATTR_PEER tkn_word peer_id opt_peer_options

//**** route class *****************************************************

aggr_bndry_attribute: ATTR_AGGR_BNDRY as_expression

aggr_mtd_attribute: ATTR_AGGR_MTD KEYW_INBOUND
| ATTR_AGGR_MTD KEYW_OUTBOUND opt_as_expression




<span class="grey">Alaettinoglu, et al.        Standards Track                    [Page 63]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-64" id="page-64" name="page-64"> </a>
<span class="grey"><a href="rfc2622.html">RFC 2622</a>                          RPSL                         June 1999</span>


//// inject attribute //////////////////////////////////////////////////

opt_inject_expression:
| KEYW_UPON inject_expression

inject_expression: inject_expression OP_OR inject_expression_term
| inject_expression_term

inject_expression_term: inject_expression_term OP_AND
                        inject_expression_factor
| inject_expression_factor

inject_expression_factor: '(' inject_expression ')'
| inject_expression_operand

inject_expression_operand: KEYW_STATIC
| KEYW_HAVE_COMPONENTS '{' opt_filter_prefix_list '}'
| KEYW_EXCLUDE '{' opt_filter_prefix_list '}'

inject_attribute: ATTR_INJECT opt_router_expression_with_at opt_action
                              opt_inject_expression

//// components attribute //////////////////////////////////////////////

opt_atomic:
| KEYW_ATOMIC

components_list:
| filter
| components_list KEYW_PROTOCOL tkn_word filter

components_attribute: ATTR_COMPONENTS opt_atomic components_list

//**** route-set *******************************************************

opt_rs_members_list: /* empty list */
| rs_members_list

rs_members_list: rs_member
| rs_members_list ',' rs_member

rs_member: TKN_ASNO
| TKN_ASNO OP_MS
| TKN_ASNAME
| TKN_ASNAME OP_MS
| TKN_RSNAME
| TKN_RSNAME OP_MS
| TKN_PRFXV4



<span class="grey">Alaettinoglu, et al.        Standards Track                    [Page 64]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-65" id="page-65" name="page-65"> </a>
<span class="grey"><a href="rfc2622.html">RFC 2622</a>                          RPSL                         June 1999</span>


| TKN_PRFXV4RNG

rs_members_attribute: ATTR_RS_MEMBERS opt_rs_members_list

//**** dictionary ******************************************************

rpattr_attribute: ATTR_RP_ATTR TKN_WORD methods
| ATTR_RP_ATTR TKN_RP_ATTR methods

methods: method
| methods method

method: TKN_WORD '(' ')'
| TKN_WORD '(' typedef_type_list ')'
| TKN_WORD '(' typedef_type_list ',' TKN_3DOTS ')'
| KEYW_OPERATOR TKN_OPERATOR '(' typedef_type_list ')'
| KEYW_OPERATOR TKN_OPERATOR '(' typedef_type_list ',' TKN_3DOTS ')'

//// typedef attribute  ////////////////////////////////////////////////

typedef_attribute: ATTR_TYPEDEF TKN_WORD typedef_type

typedef_type_list: typedef_type
| typedef_type_list ',' typedef_type

typedef_type: KEYW_UNION typedef_type_list
| KEYW_RANGE KEYW_OF typedef_type
| TKN_WORD
| TKN_WORD '[' TKN_INT ',' TKN_INT ']'
| TKN_WORD '[' TKN_REAL ',' TKN_REAL ']'
| TKN_WORD '[' enum_list ']'
| KEYW_LIST '[' TKN_INT ':' TKN_INT ']' KEYW_OF typedef_type
| KEYW_LIST KEYW_OF typedef_type

enum_list: tkn_word
| enum_list ',' tkn_word

//// protocol attribute ////////////////////////////////////////////////

protocol_attribute: ATTR_PROTOCOL tkn_word protocol_options

protocol_options:
| protocol_options protocol_option

protocol_option: KEYW_MANDATORY method
| KEYW_OPTIONAL method

//**** Token Definitions ***********************************************



<span class="grey">Alaettinoglu, et al.        Standards Track                    [Page 65]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-66" id="page-66" name="page-66"> </a>
<span class="grey"><a href="rfc2622.html">RFC 2622</a>                          RPSL                         June 1999</span>


//// flex macros used in token definitions /////////////////////////////
INT            [[:digit:]]+
SINT           [+-]?{INT}
REAL           [+-]?{INT}?\.{INT}({WS}*E{WS}*[+-]?{INT})?
NAME           [[:alpha:]]([[:alnum:]_-]*[[:alnum:]])?
ASNO           AS{INT}
ASNAME         AS-[[:alnum:]_-]*[[:alnum:]]
RSNAME         RS-[[:alnum:]_-]*[[:alnum:]]
RTRSNAME       RTRS-[[:alnum:]_-]*[[:alnum:]]
PRNGNAME       PRNG-[[:alnum:]_-]*[[:alnum:]]
FLTRNAME       FLTR-[[:alnum:]_-]*[[:alnum:]]
IPV4           [0-9]+(\.[0-9]+){3,3}
PRFXV4         {IPV4}\/[0-9]+
PRFXV4RNG      {PRFXV4}("^+"|"^-"|"^"{INT}|"^"{INT}-{INT})
ENAMECHAR      [^()&lt;&gt;,;:\\\"\.[\] \t\r]
ENAME          ({ENAMECHAR}+(\.{ENAMECHAR}+)*\.?)|(\"[^\"@\\\r\n]+\")
DNAME          [[:alnum:]_-]+
//// Token Definitions ////////////////////////////////////////////////
TKN_INT         {SINT}
TKN_INT         {INT}:{INT}             if each {INT} is two octets
TKN_INT         {INT}.{INT}.{INT}.{INT} if each {INT} is one octet
TKN_REAL        {REAL}
TKN_STRING      Same as in programming language C
TKN_IPV4        {IPV4}
TKN_PRFXV4      {PRFXV4}
TKN_PRFXV4RNG   {PRFXV4RNG}
TKN_ASNO        {ASNO}
TKN_ASNAME      (({ASNO}|peeras|{ASNAME}):)*{ASNAME}\
                (:({ASNO}|peeras|{ASNAME}))*
TKN_RSNAME      (({ASNO}|peeras|{RSNAME}):)*{RSNAME}\
                (:({ASNO}|peeras|{RSNAME}))*
TKN_RTRSNAME    (({ASNO}|peeras|{RTRSNAME}):)*{RTRSNAME}\
                (:({ASNO}|peeras|{RTRSNAME}))*
TKN_PRNGNAME    (({ASNO}|peeras|{PRNGNAME}):)*{PRNGNAME}\
                (:({ASNO}|peeras|{PRNGNAME}))*
TKN_FLTRNAME    (({ASNO}|peeras|{FLTRNAME}):)*{FLTRNAME}\
                (:({ASNO}|peeras|{FLTRNAME}))*
TKN_BOOLEAN     true|false
TKN_RP_ATTR     {NAME} if defined in dictionary
TKN_WORD        {NAME}
TKN_DNS         {DNAME}("."{DNAME})+
TKN_EMAIL       {ENAME}@({DNAME}("."{DNAME})+|{IPV4})









<span class="grey">Alaettinoglu, et al.        Standards Track                    [Page 66]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-67" id="page-67" name="page-67"> </a>
<span class="grey"><a href="rfc2622.html">RFC 2622</a>                          RPSL                         June 1999</span>


<span class="h1"><a class="selflink" href="#appendix-C" name="appendix-C">C</a> Changes from <a href="rfc2280.html">RFC 2280</a></span>

   <a href="rfc2280.html">RFC 2280</a> [<a href="#ref-3" title='"Routing Policy Specification Language (RPSL)"'>3</a>] contains an earlier version of RPSL. This section
   summarizes the changes since then.  They are as follows:

  o  It is now possible to write integers as sequence of four 1-octet
     integers (e.g. 1.1.1.1) or as sequence of two 2-octet integers
     (e.g.  3561:70).  Please see <a href="#section-2">Section 2</a>.

  o  The definition of address prefix range is extended so that an
     address prefix is also an address prefix range.  Please see <a href="#section-2">Section</a>
     <a href="#section-2">2</a>.

  o  The semantics for a range operator applied to a set containing
     address prefix ranges is defined (e.g. {30.0.0.0/8^24-28}^27-30).
     Please see <a href="#section-2">Section 2</a>.

  o  All dates are now in UTC. Please see <a href="#section-2">Section 2</a>.

  o  Plus ('+') character is added to space and tab characters to split
     an attribute's value to multiple lines (i.e. by starting the
     following lines with a space, a tab or a plus ('+') character).
     Please see <a href="#section-2">Section 2</a>.

  o  The withdrawn attribute of route class is removed from the
     language.

  o  filter-set class is introduced.  Please see <a href="#section-5.4">Section 5.4</a>.

  o  rtr-set class is introduced.  Please see <a href="#section-5.5">Section 5.5</a>.

  o  peering-set class is introduced.  Please see <a href="#section-5.6">Section 5.6</a>.

  o  Filters can now refer to filter-set names.  Please see <a href="#section-5.4">Section 5.4</a>.

  o  Peerings can now refer to peering-set, rtr-set names.  Both local
     and peer routers can be specified using router expressions.  Please
     see <a href="#section-5.6">Section 5.6</a>.

  o  The peer attribute of the inet-rtr class can refer to peering-set,
     rtr-set names.  Please see <a href="#section-9">Section 9</a>.

  o  The syntax and semantics of union, and list types and typedef
     attribute have changed.  Please see <a href="#section-7">Section 7</a>.

  o  In the initial dictionary, the typedef attribute defining the
     community_elm, rp-attribute defining the community attribute has
     changed.  Please see <a href="#section-7">Section 7</a>.



<span class="grey">Alaettinoglu, et al.        Standards Track                    [Page 67]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-68" id="page-68" name="page-68"> </a>
<span class="grey"><a href="rfc2622.html">RFC 2622</a>                          RPSL                         June 1999</span>


  o  Guideliness for extending RPSL is added.  Please see <a href="#section-10">Section 10</a>.

  o  Formal grammar rules are added.  Please see <a href="#appendix-B">Appendix B</a>.

<span class="h1"><a class="selflink" href="#appendix-D" name="appendix-D">D</a> Authors' Addresses</span>

   Cengiz Alaettinoglu
   USC/Information Sciences Institute

   EMail: cengiz@isi.edu

   Curtis Villamizar
   Avici Systems

   EMail: curtis@avici.com

   Elise Gerich
   At Home Network

   EMail: epg@home.net

   David Kessens
   Qwest Communications

   EMail: David.Kessens@qwest.net

   David Meyer
   University of Oregon

   EMail: meyer@antc.uoregon.edu

   Tony Bates
   Cisco Systems, Inc.

   EMail: tbates@cisco.com

   Daniel Karrenberg
   RIPE NCC

   EMail: dfk@ripe.net

   Marten Terpstra
   c/o Bay Networks, Inc.

   EMail: marten@BayNetworks.com






<span class="grey">Alaettinoglu, et al.        Standards Track                    [Page 68]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-69" id="page-69" name="page-69"> </a>
<span class="grey"><a href="rfc2622.html">RFC 2622</a>                          RPSL                         June 1999</span>


Full Copyright Statement

   Copyright (C) The Internet Society (1999).  All Rights Reserved.

   This document and translations of it may be copied and furnished to
   others, and derivative works that comment on or otherwise explain it
   or assist in its implmentation may be prepared, copied, published and
   distributed, in whole or in part, without restriction of any kind,
   provided that the above copyright notice and this paragraph are
   included on all such copies and derivative works.  However, this
   document itself may not be modified in any way, such as by removing
   the copyright notice or references to the Internet Society or other
   Internet organizations, except as needed for the purpose of developing
   Internet standards in which case the procedures for copyrights defined
   in the Internet Standards process must be followed, or as required to
   translate it into languages other than English.

   The limited permissions granted above are perpetual and will not be
   revoked by the Internet Society or its successors or assigns.

   This document and the information contained herein is provided on an
   "AS IS" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING
   TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT
   NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN
   WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF
   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.

Acknowledgement

   Funding for the RFC Editor function is currently provided by the
   Internet Society.




















Alaettinoglu, et al.        Standards Track                    [Page 69]

</pre><br/>
<span class="noprint"><small><small>Html markup produced by rfcmarkup 1.107, available from
<a href="http://tools.ietf.org/tools/rfcmarkup/">http://tools.ietf.org/tools/rfcmarkup/</a>
</small></small></span>


<meta content="text/html;charset=utf-8" http-equiv="content-type"/><!-- /Added by HTTrack -->

</body><!-- Mirrored from tools.ietf.org/html/rfc2622 by HTTrack Website Copier/3.x [XR&CO'2010], Wed, 19 Mar 2014 18:45:56 GMT --><!-- Added by HTTrack --></html>