<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head profile="http://dublincore.org/documents/2008/08/04/dc-html/">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="robots" content="index,follow" />
    <meta name="creator" content="rfcmarkup version 1.107" />
    <link rel="schema.DC" href="http://purl.org/dc/elements/1.1/" />
<meta name="DC.Identifier" content="urn:ietf:rfc:167" />
<meta name="DC.Creator" content="Winett, J.M." />
<meta name="DC.Creator" content="Metcalfe, R.M." />
<meta name="DC.Creator" content="Bhushan, A.K." />
<meta name="DC.Date.Issued" content="May, 1971" />
<meta name="DC.Title" content="Socket conventions reconsidered" />

    <link rel="icon" href="http://tools.ietf.org/images/rfc.png" type="image/png" />
    <link rel="shortcut icon" href="http://tools.ietf.org/images/rfc.png" type="image/png" />
    <title>RFC 167 - Socket conventions reconsidered</title>
    
    
    <style type="text/css">
	body {
	    margin: 0px 8px;
            font-size: 1em;
	}
        h1, h2, h3, h4, h5, h6, .h1, .h2, .h3, .h4, .h5, .h6 {
	    font-weight: bold;
            line-height: 0pt;
            display: inline;
            white-space: pre;
            font-family: monospace;
            font-size: 1em;
	    font-weight: bold;
        }
        pre {
            font-size: 1em;
            margin-top: 0px;
            margin-bottom: 0px;
        }
	.pre {
	    white-space: pre;
	    font-family: monospace;
	}
	.header{
	    font-weight: bold;
	}
        .newpage {
            page-break-before: always;
        }
        .invisible {
            text-decoration: none;
            color: white;
        }
        a.selflink {
          color: black;
          text-decoration: none;
        }
        @media print {
            body {
                font-family: monospace;
                font-size: 10.5pt;
            }
            h1, h2, h3, h4, h5, h6 {
                font-size: 1em;
            }
        
            a:link, a:visited {
                color: inherit;
                text-decoration: none;
            }
            .noprint {
                display: none;
            }
        }
	@media screen {
	    .grey, .grey a:link, .grey a:visited {
		color: #777;
	    }
            .docinfo {
                background-color: #EEE;
            }
            .top {
                border-top: 7px solid #EEE;
            }
            .bgwhite  { background-color: white; }
            .bgred    { background-color: #F44; }
            .bggrey   { background-color: #666; }
            .bgbrown  { background-color: #840; }            
            .bgorange { background-color: #FA0; }
            .bgyellow { background-color: #EE0; }
            .bgmagenta{ background-color: #F4F; }
            .bgblue   { background-color: #66F; }
            .bgcyan   { background-color: #4DD; }
            .bggreen  { background-color: #4F4; }

            .legend   { font-size: 90%; }
            .cplate   { font-size: 70%; border: solid grey 1px; }
	}
    </style>
    <!--[if IE]>
    <style>
    body {
       font-size: 13px;
       margin: 10px 10px;
    }
    </style>
    <![endif]-->

    <script type="text/javascript"><!--
    function addHeaderTags() {
	var spans = document.getElementsByTagName("span");
	for (var i=0; i < spans.length; i++) {
	    var elem = spans[i];
	    if (elem) {
		var level = elem.getAttribute("class");
                if (level == "h1" || level == "h2" || level == "h3" || level == "h4" || level == "h5" || level == "h6") {
                    elem.innerHTML = "<"+level+">"+elem.innerHTML+"</"+level+">";		
                }
	    }
	}
    }
    var legend_html = "Colour legend:<br />      <table>         <tr><td>Unknown:</td>                   <td><span class='cplate bgwhite'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft:</td>                     <td><span class='cplate bgred'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Informational:</td>             <td><span class='cplate bgorange'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Experimental:</td>              <td><span class='cplate bgyellow'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Best Common Practice:</td>      <td><span class='cplate bgmagenta'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Proposed Standard:</td>         <td><span class='cplate bgblue'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft Standard (old designation):</td> <td><span class='cplate bgcyan'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Internet Standard:</td>         <td><span class='cplate bggreen'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Historic:</td>                  <td><span class='cplate bggrey'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Obsolete:</td>                  <td><span class='cplate bgbrown'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>     </table>";
    function showElem(id) {
        var elem = document.getElementById(id);
        elem.innerHTML = eval(id+"_html");
        elem.style.visibility='visible';
    }
    function hideElem(id) {
        var elem = document.getElementById(id);
        elem.style.visibility='hidden';        
        elem.innerHTML = "";
    }
    // -->
    </script>
</head>
<body onload="addHeaderTags()">
   <div style="height: 13px;">
      <div onmouseover="this.style.cursor='pointer';"
         onclick="showElem('legend');"
         onmouseout="hideElem('legend')"
	 style="height: 6px; position: absolute;"
         class="pre noprint docinfo bgwhite"
         title="Click for colour legend." >                                                                        </div>
      <div id="legend"
           class="docinfo noprint pre legend"
           style="position:absolute; top: 4px; left: 4ex; visibility:hidden; background-color: white; padding: 4px 9px 5px 7px; border: solid #345 1px; "
           onmouseover="showElem('legend');"
           onmouseout="hideElem('legend');">
      </div>
   </div>
<span class="pre noprint docinfo top">[<a href="index.html" title="Document search and retrieval page">Docs</a>] [<a href="http://tools.ietf.org/rfc/rfc167.txt" title="Plaintext version of this document">txt</a>|<a href="http://tools.ietf.org/pdf/rfc167" title="PDF version of this document">pdf</a>]                                                        </span><br />
<span class="pre noprint docinfo">                                                                        </span><br />
<span class="pre noprint docinfo">                                                                        </span><br />
<span class="pre noprint docinfo">                                                                        </span><br />
<pre>
                         Network Working Group
                        Request for Comment #167
                               NIC #6784



                    Socket Conventions Reconsidered



                          Athay Bhushan (MAC)
                         Bob Metcalfe (Harvard)
                            Joel Winett (LL)

                              24 May 1971



                          <span class="h1">Category: C1, C3, C8</span>
                        <span class="h1">Related RFCs: #147, #129</span>
                    <span class="h1">Related Functional Documents: #1</span>






























<span class="grey">                                                                [Page 1]</span>
</pre><!--NewPage--><pre class='newpage'><a name="page-2" id="page-2" href="#page-2" class="invisible"> </a>
<span class="grey"><a href="rfc167.html">RFC 167</a>                                  Socket Conventions Reconsidered</span>


The current NCP Protocol says nothing about how hosts should assign
socket numbers to process ports, except that the low-order bit is to
specify socket gender (i.e., send or receive). Two recent proposals call
for additional network-wide conventions on the 32-bit socket-number. The
first proposal asks that a portion of the socket number be reserved for
a network-unique user number for accounting and access control. The
second proposal asks that the high-order 16 bits of the socket number be
zero to assist smaller hosts in reducing the space required for socket
number tables.

It is recommended that both of these proposals be set aside.  Because a
large perturbation of the current NCP Protocol is required to provide
adequate handles for accounting and access control, and because the
socket number is already underpowered for its use, it is recommended
that both proposals be set aside until serious consideration can be
given to a major NCP Protocol overhaul.

DISCUSSION

The socket number, as it is used in the current NCP Protocol is a small
number with a big function. It will probably be found that a
substantially more powerful identification mechanism (e.g., a
hierarchical naming scheme with arbitrarily long names) is required to
satisfactorily manipulate process ports. Two features of such a
mechanism will be (1) that it treats accounting and access control with
the respect they deserve, and (2) that it is part of a simpler NCP
Protocol more easily implemented under the existing size and complexity
restrictions of smaller hosts.

Socket numbers are process port identifiers used in establishing
connections between processes. It is essential that they be UNIQUE to
avoid ambiguity during connection. It is important that their assignment
to specific processes be REPEATABLE for reconnection on a regular basis.

To assure that process port identifiers are unique and repeatable it is
necessary to subject their allocation to access controls.  The simplest
of access controls assuring uniqueness is that provided by NCPs which
check their tables of active connections for duplication when a process
requests the use of a specific socket number.

There is real difficulty in constructing schemes for allowing socket
number assignments to be repeatable. Some socket numbers are to be
universally known and associated with processes operating with specified
protocols (e.g., a logger socket, an RJB socket, a file transfer
socket). Other socket numbers might not be universally known, but given
to their users in a transmission over a universally known socket (e.g.,
the socket pair specified by the transmission over the logger socket
using the Initial Connection Protocol (ICP)).  Concurrently running



<span class="grey">                                                                [Page 2]</span>
</pre><!--NewPage--><pre class='newpage'><a name="page-3" id="page-3" href="#page-3" class="invisible"> </a>
<span class="grey"><a href="rfc167.html">RFC 167</a>                                  Socket Conventions Reconsidered</span>


instances of a program will require distinct process port identifiers.
Therefore, socket numbers will in general need to be dynamically
assigned via some system controlled allocation function.

There are a number of ways of providing for potentially repeatable
socket number assignments. One bad way is to have the NCP keep a list of
all assigned socket numbers with some indication of who is permitted to
use them and for how long -- like keeping track of magnetic tape reels.
If there were few available socket numbers (e.g., 16 bits worth) this
bad method or one comparably distasteful and logistically foreboding
would have to be adopted.  With an abundance of socket numbers it is
possible, using sparse socket number assignment, to devise simple
algorithms for deciding whether a socket numbers being requested by a
process can be allocated freely. Such algorithms might take into account
(1) the dynamic status of the socket (i.e., its association with a
currently active connection), (2) its reserved status as a standard
service port address, and (3) its access control attributes in relation
to those of the requesting process.

One good strategy for controlling socket numbers is to partition the
full socket space at a host among its network users. Under this scheme a
user could be assured of having the repeatable use of his partition.  It
might also be helpful to designate a utility partition for use in socket
number allocations where repeatability is not essential. Such socket
numbers could be selected from the utility partition by some clever
construction on the date and time.

It will often be the case that a program will be written to use several
connections. Remembering that this program might find itself being
executed concurrently by several processes belonging to several users,
it might be convenient to code with socket tags which are to be extended
with runtime user and process identifier fields.

Socket numbers will tend to be viewed -- should be viewed -- as having
three fields: a user field to assist in providing repeatability, a
process field to assure uniqueness for concurrent instances of a
program, and a tag field to enable the convenient referencing of
multiple connections to a single process.

Although fields will be helpful in dealing with socket number
allocation, it is not essential that such field designations be uniform
over the network. In all network transactions the 32-bit socket number
is handled with its 8-bit host number. Thus, if hosts are able to
maintain uniqueness and repeatability internally, socket numbers in the
network as a whole will also be unique and repeatable.  If a host fails
to do so, only connections with that offending host are affected.





<span class="grey">                                                                [Page 3]</span>
</pre><!--NewPage--><pre class='newpage'><a name="page-4" id="page-4" href="#page-4" class="invisible"> </a>
<span class="grey"><a href="rfc167.html">RFC 167</a>                                  Socket Conventions Reconsidered</span>


Because the size, use, and character of systems on the network are so
varied, it would be difficult if not impossible to come up with an
agreed upon particular division of the 32-bit socket number.  Hosts have
different internal restrictions on the number of users, processes per
user, and connections per process they will permit.

It has been suggested that it may not be necessary to maintain socket
uniqueness. It is contended that there is really no significant use made
of the socket number after a connection has been established. The only
reason a host must now save a socket number for the life of a connection
is to include it in the CLOSE of that connection. If such is really the
case, then the NCP Protocol might be improved by inventing a new CLOSE
which uses the host-line pair associated with the connection. Hosts
which are short on space could then forget a socket number immediately
after successful connection.

       [ This RFC was put into machine readable form for entry ]
        [ into the online RFC archives by Thomas Nielsen 5/97 ]

































                                                                [Page 4]

</pre><br />
<span class="noprint"><small><small>Html markup produced by rfcmarkup 1.107, available from
<a href="http://tools.ietf.org/tools/rfcmarkup/">http://tools.ietf.org/tools/rfcmarkup/</a>
</small></small></span>
</body>
<!-- Mirrored from tools.ietf.org/html/rfc167 by HTTrack Website Copier/3.x [XR&CO'2010], Wed, 19 Mar 2014 18:55:28 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
</html>
