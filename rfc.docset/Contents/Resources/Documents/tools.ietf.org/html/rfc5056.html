<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml"><head profile="http://dublincore.org/documents/2008/08/04/dc-html/">
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
    <meta content="index,follow" name="robots"/>
    <meta content="rfcmarkup version 1.107" name="creator"/>
    <link href="http://purl.org/dc/elements/1.1/" rel="schema.DC"/>
<meta content="draft-ietf-nfsv4-channel-bindings" name="DC.Relation.Replaces"/>
<meta content="urn:ietf:rfc:5056" name="DC.Identifier"/>
<meta content="November, 2007" name="DC.Date.Issued"/>
<meta content="Nicolas Williams &lt;nicolas.williams@sun.com&gt;" name="DC.Creator"/>
<meta content="The concept of channel binding allows applications to establish that\nthe two end-points of a secure channel at one network layer are the\nsame as at a higher layer by binding authentication at the higher\nlayer to the channel at the lower layer. This allows applications to\ndelegate session protection to lower layers, which has various\nperformance benefits.  This document discusses and formalizes the\nconcept of channel binding to secure channels. [STANDARDS-TRACK]" name="DC.Description.Abstract"/>
<meta content="On the Use of Channel Bindings to Secure Channels" name="DC.Title"/>

    <link href="http://tools.ietf.org/images/rfc.png" rel="icon" type="image/png"/>
    <link href="http://tools.ietf.org/images/rfc.png" rel="shortcut icon" type="image/png"/>
    <title>RFC 5056 - On the Use of Channel Bindings to Secure Channels</title>
    
    
    <style type="text/css">
	body {
	    margin: 0px 8px;
            font-size: 1em;
	}
        h1, h2, h3, h4, h5, h6, .h1, .h2, .h3, .h4, .h5, .h6 {
	    font-weight: bold;
            line-height: 0pt;
            display: inline;
            white-space: pre;
            font-family: monospace;
            font-size: 1em;
	    font-weight: bold;
        }
        pre {
            font-size: 1em;
            margin-top: 0px;
            margin-bottom: 0px;
        }
	.pre {
	    white-space: pre;
	    font-family: monospace;
	}
	.header{
	    font-weight: bold;
	}
        .newpage {
            page-break-before: always;
        }
        .invisible {
            text-decoration: none;
            color: white;
        }
        a.selflink {
          color: black;
          text-decoration: none;
        }
        @media print {
            body {
                font-family: monospace;
                font-size: 10.5pt;
            }
            h1, h2, h3, h4, h5, h6 {
                font-size: 1em;
            }
        
            a:link, a:visited {
                color: inherit;
                text-decoration: none;
            }
            .noprint {
                display: none;
            }
        }
	@media screen {
	    .grey, .grey a:link, .grey a:visited {
		color: #777;
	    }
            .docinfo {
                background-color: #EEE;
            }
            .top {
                border-top: 7px solid #EEE;
            }
            .bgwhite  { background-color: white; }
            .bgred    { background-color: #F44; }
            .bggrey   { background-color: #666; }
            .bgbrown  { background-color: #840; }            
            .bgorange { background-color: #FA0; }
            .bgyellow { background-color: #EE0; }
            .bgmagenta{ background-color: #F4F; }
            .bgblue   { background-color: #66F; }
            .bgcyan   { background-color: #4DD; }
            .bggreen  { background-color: #4F4; }

            .legend   { font-size: 90%; }
            .cplate   { font-size: 70%; border: solid grey 1px; }
	}
    </style>
    <!--[if IE]>
    <style>
    body {
       font-size: 13px;
       margin: 10px 10px;
    }
    </style>
    <![endif]-->

    <script type="text/javascript"><!--
    function addHeaderTags() {
	var spans = document.getElementsByTagName("span");
	for (var i=0; i < spans.length; i++) {
	    var elem = spans[i];
	    if (elem) {
		var level = elem.getAttribute("class");
                if (level == "h1" || level == "h2" || level == "h3" || level == "h4" || level == "h5" || level == "h6") {
                    elem.innerHTML = "<"+level+">"+elem.innerHTML+"</"+level+">";		
                }
	    }
	}
    }
    var legend_html = "Colour legend:<br />      <table>         <tr><td>Unknown:</td>                   <td><span class='cplate bgwhite'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft:</td>                     <td><span class='cplate bgred'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Informational:</td>             <td><span class='cplate bgorange'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Experimental:</td>              <td><span class='cplate bgyellow'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Best Common Practice:</td>      <td><span class='cplate bgmagenta'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Proposed Standard:</td>         <td><span class='cplate bgblue'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft Standard (old designation):</td> <td><span class='cplate bgcyan'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Internet Standard:</td>         <td><span class='cplate bggreen'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Historic:</td>                  <td><span class='cplate bggrey'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Obsolete:</td>                  <td><span class='cplate bgbrown'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>     </table>";
    function showElem(id) {
        var elem = document.getElementById(id);
        elem.innerHTML = eval(id+"_html");
        elem.style.visibility='visible';
    }
    function hideElem(id) {
        var elem = document.getElementById(id);
        elem.style.visibility='hidden';        
        elem.innerHTML = "";
    }
    // -->
    </script>
</head>
<body onload="addHeaderTags()">
   <div style="height: 13px;">
      <div class="pre noprint docinfo bgblue" onclick="showElem('legend');" onmouseout="hideElem('legend')" onmouseover="this.style.cursor='pointer';" style="height: 6px; position: absolute;" title="Click for colour legend.">                                                                        </div>
      <div class="docinfo noprint pre legend" id="legend" onmouseout="hideElem('legend');" onmouseover="showElem('legend');" style="position:absolute; top: 4px; left: 4ex; visibility:hidden; background-color: white; padding: 4px 9px 5px 7px; border: solid #345 1px; ">
      </div>
   </div>
<span class="pre noprint docinfo top">[<a href="index.html" title="Document search and retrieval page">Docs</a>] [<a href="http://tools.ietf.org/rfc/rfc5056.txt" title="Plaintext version of this document">txt</a>|<a href="http://tools.ietf.org/pdf/rfc5056" title="PDF version of this document">pdf</a>] [<a href="http://tools.ietf.org/html/draft-williams-on-channel-binding" title="draft-williams-on-channel-binding">draft-williams-on...</a>] [<a href="http://tools.ietf.org/rfcdiff?difftype=--hwdiff&amp;url2=rfc5056" title="Inline diff (wdiff)">Diff1</a>] [<a href="http://tools.ietf.org/rfcdiff?url2=rfc5056" title="Side-by-side diff">Diff2</a>] [<a href="http://www.rfc-editor.org/errata_search.php?rfc=5056">Errata</a>]        </span><br/>
<span class="pre noprint docinfo">                                                                        </span><br/>
<span class="pre noprint docinfo">                                                       PROPOSED STANDARD</span><br/>
<span class="pre noprint docinfo">                                                            <span style="color: #C00;">Errata Exist</span></span><br/>
<pre>Network Working Group                                        N. Williams
Request for Comments: 5056                                           Sun
Category: Standards Track                                  November 2007


           <span class="h1">On the Use of Channel Bindings to Secure Channels</span>

Status of This Memo

   This document specifies an Internet standards track protocol for the
   Internet community, and requests discussion and suggestions for
   improvements.  Please refer to the current edition of the "Internet
   Official Protocol Standards" (STD 1) for the standardization state
   and status of this protocol.  Distribution of this memo is unlimited.

Abstract

   The concept of channel binding allows applications to establish that
   the two end-points of a secure channel at one network layer are the
   same as at a higher layer by binding authentication at the higher
   layer to the channel at the lower layer.  This allows applications to
   delegate session protection to lower layers, which has various
   performance benefits.

   This document discusses and formalizes the concept of channel binding
   to secure channels.

























<span class="grey">Williams                    Standards Track                     [Page 1]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-2" id="page-2" name="page-2"> </a>
<span class="grey"><a href="rfc5056.html">RFC 5056</a>                  On Channel Bindings              November 2007</span>


Table of Contents

   <a href="#section-1">1</a>. Introduction ....................................................<a href="#page-3">3</a>
      <a href="#section-1.1">1.1</a>. Conventions Used in This Document ..........................<a href="#page-4">4</a>
   <a href="#section-2">2</a>. Definitions .....................................................<a href="#page-4">4</a>
      <a href="#section-2.1">2.1</a>. Properties of Channel Binding ..............................<a href="#page-6">6</a>
      <a href="#section-2.2">2.2</a>. EAP Channel Binding ........................................<a href="#page-9">9</a>
   <a href="#section-3">3</a>. Authentication and Channel Binding Semantics ...................<a href="#page-10">10</a>
      <a href="#section-3.1">3.1</a>. The GSS-API and Channel Binding ...........................<a href="#page-10">10</a>
      <a href="#section-3.2">3.2</a>. SASL and Channel Binding ..................................<a href="#page-11">11</a>
   <a href="#section-4">4</a>. Channel Bindings Specifications ................................<a href="#page-11">11</a>
      <a href="#section-4.1">4.1</a>. Examples of Unique Channel Bindings .......................<a href="#page-11">11</a>
      <a href="#section-4.2">4.2</a>. Examples of End-Point Channel Bindings ....................<a href="#page-12">12</a>
   <a href="#section-5">5</a>. Uses of Channel Binding ........................................<a href="#page-12">12</a>
   <a href="#section-6">6</a>. Benefits of Channel Binding to Secure Channels .................<a href="#page-14">14</a>
   <a href="#section-7">7</a>. IANA Considerations ............................................<a href="#page-15">15</a>
      <a href="#section-7.1">7.1</a>. Registration Procedure ....................................<a href="#page-15">15</a>
      <a href="#section-7.2">7.2</a>. Comments on Channel Bindings Registrations ................<a href="#page-16">16</a>
      <a href="#section-7.3">7.3</a>. Change Control ............................................<a href="#page-17">17</a>
   <a href="#section-8">8</a>. Security Considerations ........................................<a href="#page-17">17</a>
      8.1. Non-Unique Channel Bindings and Channel Binding
           Re-Establishment ..........................................<a href="#page-18">18</a>
   <a href="#section-9">9</a>. References .....................................................<a href="#page-19">19</a>
      <a href="#section-9.1">9.1</a>. Normative References ......................................<a href="#page-19">19</a>
      <a href="#section-9.2">9.2</a>. Informative References ....................................<a href="#page-19">19</a>
   <a href="#appendix-A">Appendix A</a>. Acknowledgments .......................................<a href="#page-22">22</a>

























<span class="grey">Williams                    Standards Track                     [Page 2]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-3" id="page-3" name="page-3"> </a>
<span class="grey"><a href="rfc5056.html">RFC 5056</a>                  On Channel Bindings              November 2007</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/1.%20%20Introduction"></a><a class="selflink" href="#section-1" name="section-1">1</a>.  Introduction</span>

   In a number of situations, it is useful for an application to be able
   to handle authentication within the application layer, while
   simultaneously being able to utilize session or transport security at
   a lower network layer.  For example, IPsec [<a href="rfc4301.html" title='"Security Architecture for the Internet Protocol"'>RFC4301</a>] [<a href="rfc4303.html" title='"IP Encapsulating Security Payload (ESP)"'>RFC4303</a>]
   [<a href="rfc4302.html" title='"IP Authentication Header"'>RFC4302</a>] is amenable to being accelerated in hardware to handle very
   high link speeds, but IPsec key exchange protocols and the IPsec
   architecture are not as amenable to use as a security mechanism
   within applications, particularly applications that have users as
   clients.  A method of combining security at both layers is therefore
   attractive.  To enable this to be done securely, it is necessary to
   "bind" the mechanisms together -- so as to avoid man-in-the-middle
   vulnerabilities and enable the mechanisms to be integrated in a
   seamless way.  This is the objective of "Channel Bindings".

   The term "channel binding", as used in this document, derives from
   the Generic Security Service Application Program Interface (GSS-API)
   [<a href="rfc2743.html" title='"Generic Security Service Application Program Interface Version 2, Update 1"'>RFC2743</a>], which has a channel binding facility that was intended for
   binding GSS-API authentication to secure channels at lower network
   layers.  The purpose and benefits of the GSS-API channel binding
   facility were not discussed at length, and some details were left
   unspecified.  Now we find that this concept can be very useful,
   therefore we begin with a generalization and formalization of
   "channel binding" independent of the GSS-API.

   Although inspired by and derived from the GSS-API, the notion of
   channel binding described herein is not at all limited to use by GSS-
   API applications.  We envision use of channel binding by applications
   that utilize other security frameworks, such as Simple Authentication
   and Security Layer (SASL) [<a href="rfc4422.html" title='"Simple Authentication and Security Layer (SASL)"'>RFC4422</a>] and even protocols that provide
   their own authentication mechanisms (e.g., the Key Distribution
   Center (KDC) exchanges of Kerberos V [<a href="rfc4120.html" title='"The Kerberos Network Authentication Service (V5)"'>RFC4120</a>]).  We also envision
   use of the notion of channel binding in the analysis of security
   protocols.

   The main goal of channel binding is to be able to delegate
   cryptographic session protection to network layers below the
   application in hopes of being able to better leverage hardware
   implementations of cryptographic protocols.  <a href="#section-5">Section 5</a> describes some
   intended uses of channel binding.  Also, some applications may
   benefit by reducing the amount of active cryptographic state, thus
   reducing overhead in accessing such state and, therefore, the impact
   of security on latency.







<span class="grey">Williams                    Standards Track                     [Page 3]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-4" id="page-4" name="page-4"> </a>
<span class="grey"><a href="rfc5056.html">RFC 5056</a>                  On Channel Bindings              November 2007</span>


   The critical security problem to solve in order to achieve such
   delegation of session protection is ensuring that there is no man-
   in-the-middle (MITM), from the point of view the application, at the
   lower network layer to which session protection is to be delegated.

   There may well be an MITM, particularly if either the lower network
   layer provides no authentication or there is no strong connection
   between the authentication or principals used at the application and
   those used at the lower network layer.

   Even if such MITM attacks seem particularly difficult to effect, the
   attacks must be prevented for certain applications to be able to make
   effective use of technologies such as IPsec [<a href="rfc2401.html" title='"Security Architecture for the Internet Protocol"'>RFC2401</a>] [<a href="rfc4301.html" title='"Security Architecture for the Internet Protocol"'>RFC4301</a>] or
   HTTP with TLS [<a href="rfc4346.html" title='"The Transport Layer Security (TLS) Protocol Version 1.1"'>RFC4346</a>] in certain contexts (e.g., when there is no
   authentication to speak of, or when one node's set of trust anchors
   is too weak to believe that it can authenticate its peers).
   Additionally, secure channels that are susceptible to MITM attacks
   because they provide no useful end-point authentication are useful
   when combined with application-layer authentication (otherwise they
   are only somewhat "better than nothing" -- see Better Than Nothing
   Security (BTNS) [<a href="#ref-BTNS-AS" title='"Problem and Applicability Statement for Better Than Nothing Security (BTNS)"'>BTNS-AS</a>]).

   For example, Internet Small Computer Systems Interface (iSCSI)
   [<a href="rfc3720.html" title='"Internet Small Computer Systems Interface (iSCSI)"'>RFC3720</a>] provides for application-layer authentication (e.g., using
   Kerberos V), but relies on IPsec for transport protection; iSCSI does
   not provide a binding between the two. iSCSI initiators have to be
   careful to make sure that the name of the server authenticated at the
   application layer and the name of the peer at the IPsec layer match
   -- an informal form of channel binding.

   This document describes a solution: the use of "channel binding" to
   bind authentication at application layers to secure sessions at lower
   layers in the network stack.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/1.1.%20%20Conventions%20Used%20in%20This%20Document"></a><a class="selflink" href="#section-1.1" name="section-1.1">1.1</a>.  Conventions Used in This Document</span>

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in [<a href="rfc2119.html" title='"Key words for use in RFCs to Indicate Requirement Levels"'>RFC2119</a>].

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/2.%20%20Definitions"></a><a class="selflink" href="#section-2" name="section-2">2</a>.  Definitions</span>

   o  Secure channel: a packet, datagram, octet stream connection, or
      sequence of connections between two end-points that affords
      cryptographic integrity and, optionally, confidentiality to data
      exchanged over it.  We assume that the channel is secure -- if an
      attacker can successfully cryptanalyze a channel's session keys,
      for example, then the channel is not secure.



<span class="grey">Williams                    Standards Track                     [Page 4]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-5" id="page-5" name="page-5"> </a>
<span class="grey"><a href="rfc5056.html">RFC 5056</a>                  On Channel Bindings              November 2007</span>


   o  Channel binding: the process of establishing that no man-in-the-
      middle exists between two end-points that have been authenticated
      at one network layer but are using a secure channel at a lower
      network layer.  This term is used as a noun.

   o  Channel bindings: [See historical note below.]

         Generally, some data that "names" a channel or one or both of
         its end-points such that if this data can be shown, at a higher
         network layer, to be the same at both ends of a channel, then
         there are no MITMs between the two end-points at that higher
         network layer.  This term is used as a noun.

         More formally, there are two types of channel bindings:

         +  unique channel bindings:

            channel bindings that name a channel in a cryptographically
            secure manner and uniquely in time;

         +  end-point channel bindings:

            channel bindings that name the authenticated end-points, or
            even a single end-point, of a channel which are, in turn,
            securely bound to the channel, but which do not identify a
            channel uniquely in time.

   o  Cryptographic binding: (e.g., "cryptographically bound") a
      cryptographic operation that causes an object, such as a private
      encryption or signing key, or an established secure channel, to
      "speak for" [<a href="#ref-Lampson91" title='"Authentication in Distributed Systems: Theory and Practive"'>Lampson91</a>] some principal, such as a user, a
      computer, etcetera.  For example, a Public Key Infrastructure for
      X.509 Certificates (PKIX) certificate binds a private key to the
      name of a principal in the trust domain of the certificate's
      issuer such that a possessor of said private key can act on behalf
      of the user (or other entity) named by the certificate.

      Cryptographic bindings are generally asymmetric in nature (not to
      be confused with symmetric or asymmetric key cryptography) in that
      an object is rendered capable of standing for another, but the
      reverse is not usually the case (we don't say that a user speaks
      for their private keys, but we do say that the user's private keys
      speak for the user).

   Note that there may be many instances of "cryptographic binding" in
   an application of channel binding.  The credentials that authenticate
   principals at the application layer bind private or secret keys to
   the identities of those principals, such that said keys speak for



<span class="grey">Williams                    Standards Track                     [Page 5]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-6" id="page-6" name="page-6"> </a>
<span class="grey"><a href="rfc5056.html">RFC 5056</a>                  On Channel Bindings              November 2007</span>


   them.  A secure channel typically consists of symmetric session keys
   used to provide confidentiality and integrity protection to data sent
   over the channel; each end-point's session keys speak for that end-
   point of the channel.  Finally, each end-point of a channel bound to
   authentication at the application layer speaks for the principal
   authenticated at the application layer on the same side of the
   channel.

   The terms defined above have been in use for many years and have been
   taken to mean, at least in some contexts, what is stated below.
   Unfortunately this means that "channel binding" can refer to the
   channel binding operation and, sometimes to the name of a channel,
   and "channel bindings" -- a difference of only one letter --
   generally refers to the name of a channel.

   Note that the Extensible Authentication Protocol (EAP) [<a href="rfc3748.html" title='"Extensible Authentication Protocol (EAP)"'>RFC3748</a>] uses
   "channel binding" to refer to a facility that may appear to be
   similar to the one decribed here, but it is, in fact, quite
   different.  See <a href="#section-2.2">Section 2.2</a> for mode details.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/2.1.%20%20Properties%20of%20Channel%20Binding"></a><a class="selflink" href="#section-2.1" name="section-2.1">2.1</a>.  Properties of Channel Binding</span>

   Applications, authentication frameworks (e.g., the GSS-API, SASL),
   security mechanisms (e.g., the Kerberos V GSS-API mechanism
   [<a href="rfc1964.html" title='"The Kerberos Version 5 GSS-API Mechanism"'>RFC1964</a>]), and secure channels must meet the requirements and should
   follow the recommendations that are listed below.

   Requirements:

   o  In order to use channel binding, applications MUST verify that the
      same channel bindings are observed at either side of the channel.
      To do this, the application MUST use an authentication protocol at
      the application layer to authenticate one, the other, or both
      application peers (one at each end of the channel).

      *  If the authentication protocol used by the application supports
         channel binding, the application SHOULD use it.

      *  An authentication protocol that supports channel binding MUST
         provide an input slot in its API for a "handle" to the channel,
         or its channel bindings.

      *  If the authentication protocol does not support a channel
         binding operation, but provides a "security layer" with at
         least integrity protection, then the application MUST use the
         authentication protocol's integrity protection facilities to
         exchange channel bindings, or cryptographic hashes thereof.




<span class="grey">Williams                    Standards Track                     [Page 6]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-7" id="page-7" name="page-7"> </a>
<span class="grey"><a href="rfc5056.html">RFC 5056</a>                  On Channel Bindings              November 2007</span>


      *  The name of the type of channel binding MUST be used by the
         application and/or authentication protocol to avoid ambiguity
         about which of several possible types of channels is being
         bound.  If nested instances of the same type of channel are
         available, then the innermost channel MUST be used.

   o  Specifications of channel bindings for any secure channels MUST
      provide for a single, canonical octet string encoding of the
      channel bindings.  Under this framework, channel bindings MUST
      start with the channel binding unique prefix followed by a colon
      (ASCII 0x3A).

   o  The channel bindings for a given type of secure channel MUST be
      constructed in such a way that an MITM could not easily force the
      channel bindings of a given channel to match those of another.

   o  Unique channel bindings MUST bind not only the key exchange for
      the secure channel, but also any negotiations and authentication
      that may have taken place to establish the channel.

   o  End-point channel bindings MUST be bound into the secure channel
      and all its negotiations.  For example, a public key as an end-
      point channel binding should be used to verify a signature of such
      negotiations (or to encrypt them), including the initial key
      exchange and negotiation messages for that channel -- such a key
      would then be bound into the channel.  A certificate name as end-
      point channel binding could also be bound into the channel in a
      similar way, though in the case of a certificate name, the binding
      also depends on the strength of the authentication of that name
      (that is, the validation of the certificate, the trust anchors,
      the algorithms used in the certificate path construction and
      validation, etcetera).

   o  End-point channel bindings MAY be identifiers (e.g., certificate
      names) that must be authenticated through some infrastructure,
      such as a public key infrastructure (PKI).  In such cases,
      applications MUST ensure that the channel provides adequate
      authentication of such identifiers (e.g., that the certificate
      validation policy and trust anchors used by the channel satisfy
      the application's requirements).  To avoid implementation
      difficulties in addressing this requirement, applications SHOULD
      use cryptographic quantities as end-point channel bindings, such
      as certificate-subject public keys.

   o  Applications that desire confidentiality protection MUST use
      application-layer session protection services for confidentiality
      protection when the bound channel does not provide confidentiality
      protection.



<span class="grey">Williams                    Standards Track                     [Page 7]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-8" id="page-8" name="page-8"> </a>
<span class="grey"><a href="rfc5056.html">RFC 5056</a>                  On Channel Bindings              November 2007</span>


   o  The integrity of a secure channel MUST NOT be weakened should
      their channel bindings be revealed to an attacker.  That is, the
      construction of the channel bindings for any type of secure
      channel MUST NOT leak secret information about the channel.  End-
      point channel bindings, however, MAY leak information about the
      end-points of the channel (e.g., their names).

   o  The channel binding operation MUST be at least integrity protected
      in the security mechanism used at the application layer.

   o  Authentication frameworks and mechanisms that support channel
      binding MUST communicate channel binding failure to applications.

   o  Applications MUST NOT send sensitive information, requiring
      confidentiality protection, over the underlying channel prior to
      completing the channel binding operation.

   Recommendations:

   o  End-point channel bindings where the end-points are meaningful
      names SHOULD NOT be used when the channel does not provide
      confidentiality protection and privacy protection is desired.
      Alternatively, channels that export such channel bindings SHOULD
      provide for the use of a digest and SHOULD NOT introduce new
      digest/hash agility problems as a result.

   Options:

   o  Authentication frameworks and mechanisms that support channel
      binding MAY fail to establish authentication if channel binding
      fails.

   o  Applications MAY send information over the underlying channel and
      without integrity protection from the application-layer
      authentication protocol prior to completing the channel binding
      operation if such information requires only integrity protection.
      This could be useful for optimistic negotiations.

   o  A security mechanism MAY exchange integrity-protected channel
      bindings.

   o  A security mechanism MAY exchange integrity-protected digests of
      channel bindings.  Such mechanisms SHOULD provide for hash/digest
      agility.

   o  A security mechanism MAY use channel bindings in key exchange,
      authentication, or key derivation, prior to the exchange of
      "authenticator" messages.



<span class="grey">Williams                    Standards Track                     [Page 8]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-9" id="page-9" name="page-9"> </a>
<span class="grey"><a href="rfc5056.html">RFC 5056</a>                  On Channel Bindings              November 2007</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/2.2.%20%20EAP%20Channel%20Binding"></a><a class="selflink" href="#section-2.2" name="section-2.2">2.2</a>.  EAP Channel Binding</span>

   This section is informative.  This document does not update EAP
   [<a href="rfc3748.html" title='"Extensible Authentication Protocol (EAP)"'>RFC3748</a>], it neither normatively describes, nor does it impose
   requirements on any aspect of EAP or EAP methods.

   EAP [<a href="rfc3748.html" title='"Extensible Authentication Protocol (EAP)"'>RFC3748</a>] includes a concept of channel binding described as
   follows:

      The communication within an EAP method of integrity-protected
      channel properties such as endpoint identifiers which can be
      compared to values communicated via out of band mechanisms (such
      as via a AAA or lower layer protocol).

   <a href="rfc3748.html#section-7.15">Section 7.15 of [RFC3748]</a> describes the problem as one where a
   Network Access Server (NAS) (a.k.a. "authenticator") may lie to the
   peer (client) and cause the peer to make incorrect authorization
   decisions (e.g., as to what traffic may transit through the NAS).
   This is not quite like the purpose of generic channel binding (MITM
   detection).

   <a href="rfc3748.html#section-7.15">Section 7.15 of [RFC3748]</a> calls for "a protected exchange of channel
   properties such as endpoint identifiers" such that "it is possible to
   match the channel properties provided by the authenticator via out-
   of-band mechanisms against those exchanged within the EAP method".

   This has sometimes been taken to be very similar to the generic
   notion of channel binding provided here.  However, there is a very
   subtle difference between the two concepts of channel binding that
   makes it much too difficult to put forth requirements and
   recommendations that apply to both.  The difference is about the
   lower-layer channel:

   o  In the generic channel binding case, the identities of either end
      of this channel are irrelevant to anything other than the
      construction of a name for that channel, in which case the
      identities of the channel's end-points must be established a
      priori.

   o  Whereas in the EAP case, the identity of the NAS end of the
      channel, and even security properties of the channel itself, may
      be established during or after authentication of the EAP peer to
      the EAP server.

   In other words: there is a fundamental difference in mechanics
   (timing of lower-layer channel establishment) and in purpose
   (authentication of lower-layer channel properties for authorization
   purposes vs. MITM detection).



<span class="grey">Williams                    Standards Track                     [Page 9]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-10" id="page-10" name="page-10"> </a>
<span class="grey"><a href="rfc5056.html">RFC 5056</a>                  On Channel Bindings              November 2007</span>


   After some discussion we have concluded that there is no simple way
   to obtain requirements and recommendations that apply to both generic
   and EAP channel binding.  Therefore, EAP is out of the scope of this
   document.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/3.%20%20Authentication%20and%20Channel%20Binding%20Semantics"></a><a class="selflink" href="#section-3" name="section-3">3</a>.  Authentication and Channel Binding Semantics</span>

   Some authentication frameworks and/or mechanisms provide for channel
   binding, such as the GSS-API and some GSS-API mechanisms, whereas
   others may not, such as SASL (however, ongoing work is adding channel
   binding support to SASL).  Semantics may vary with respect to
   negotiation, how the binding occurs, and handling of channel binding
   failure (see below).

   Where suitable channel binding facilities are not provided,
   application protocols MAY include a separate, protected exchange of
   channel bindings.  In order to do this, the application-layer
   authentication service must provide message protection services (at
   least integrity protection).

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.1.%20%20The%20GSS-API%20and%20Channel%20Binding"></a><a class="selflink" href="#section-3.1" name="section-3.1">3.1</a>.  The GSS-API and Channel Binding</span>

   The GSS-API [<a href="rfc2743.html" title='"Generic Security Service Application Program Interface Version 2, Update 1"'>RFC2743</a>] provides for the use of channel binding during
   initialization of GSS-API security contexts, though GSS-API
   mechanisms are not required to support this facility.

   This channel binding facility is described in [<a href="rfc2743.html" title='"Generic Security Service Application Program Interface Version 2, Update 1"'>RFC2743</a>] and
   [<a href="rfc2744.html" title='"Generic Security Service API Version 2 : C-bindings"'>RFC2744</a>].

   GSS-API mechanisms must fail security context establishment when
   channel binding fails, and the GSS-API provides no mechanism for the
   negotiation of channel binding.  As a result GSS-API applications
   must agree a priori, through negotiation or otherwise, on the use of
   channel binding.

   Fortunately, it is possible to design GSS-API pseudo-mechanisms that
   simply wrap around existing mechanisms for the purpose of allowing
   applications to negotiate the use of channel binding within their
   existing methods for negotiating GSS-API mechanisms.  For example,
   NFSv4 [<a href="rfc3530.html" title='"Network File System (NFS) version 4 Protocol"'>RFC3530</a>] provides its own GSS-API mechanism negotiation, as
   does the SSHv2 protocol [<a href="rfc4462.html" title='"Generic Security Service Application Program Interface (GSS-API) Authentication and Key Exchange for the Secure Shell (SSH) Protocol"'>RFC4462</a>].  Such pseudo-mechanisms are being
   proposed separately, see [<a href="#ref-STACKABLE" title='"Stackable Generic Security Service Pseudo-Mechanisms"'>STACKABLE</a>].









<span class="grey">Williams                    Standards Track                    [Page 10]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-11" id="page-11" name="page-11"> </a>
<span class="grey"><a href="rfc5056.html">RFC 5056</a>                  On Channel Bindings              November 2007</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.2.%20%20SASL%20and%20Channel%20Binding"></a><a class="selflink" href="#section-3.2" name="section-3.2">3.2</a>.  SASL and Channel Binding</span>

   SASL [<a href="rfc4422.html" title='"Simple Authentication and Security Layer (SASL)"'>RFC4422</a>] does not yet provide for the use of channel binding
   during initialization of SASL contexts.

   Work is ongoing [<a href="#ref-SASL-GS2" title='"Using GSS-API Mechanisms in SASL: The GS2 Mechanism Family"'>SASL-GS2</a>] to specify how SASL, particularly its new
   bridge to the GSS-API, performs channel binding.  SASL will likely
   differ from the GSS-API in its handling of channel binding failure
   (i.e., when there may be an MITM) in that channel binding
   success/failure will only affect the negotiation of SASL security
   layers.  That is, when channel binding succeeds, SASL should select
   no security layers, leaving session cryptographic protection to the
   secure channel that SASL authentication has been bound to.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/4.%20%20Channel%20Bindings%20Specifications"></a><a class="selflink" href="#section-4" name="section-4">4</a>.  Channel Bindings Specifications</span>

   Channel bindings for various types of secure channels are not
   described herein.  Some channel bindings specifications can be found
   in:

   +--------------------+----------------------------------------------+
   | Secure Channel     | Reference                                    |
   | Type               |                                              |
   +--------------------+----------------------------------------------+
   | SSHv2              | [<a href="#ref-SSH-CB" title='"Channel Binding Identifiers for Secure Shell Channels"'>SSH-CB</a>]                                     |
   |                    |                                              |
   | TLS                | [<a href="#ref-TLS-CB" title='"Unique Channel Bindings for TLS"'>TLS-CB</a>]                                     |
   |                    |                                              |
   | IPsec              | There is no specification for IPsec channel  |
   |                    | bindings yet, but the IETF Better Than       |
   |                    | Nothing Security (BTNS) WG is working to     |
   |                    | specify IPsec channels, and possibly IPsec   |
   |                    | channel bindings.                            |
   +--------------------+----------------------------------------------+

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.1.%20%20Examples%20of%20Unique%20Channel%20Bindings"></a><a class="selflink" href="#section-4.1" name="section-4.1">4.1</a>.  Examples of Unique Channel Bindings</span>

   The following text is not normative, but is here to show how one
   might construct channel bindings for various types of secure
   channels.

   For SSHv2 [<a href="rfc4251.html" title='"The Secure Shell (SSH) Protocol Architecture"'>RFC4251</a>] the SSHv2 session ID should suffice as it is a
   cryptographic binding of all relevant SSHv2 connection parameters:
   key exchange and negotiation.

   The TLS [<a href="rfc4346.html" title='"The Transport Layer Security (TLS) Protocol Version 1.1"'>RFC4346</a>] session ID is simply assigned by the server.  As
   such, the TLS session ID does not have the required properties to be
   useful as a channel binding because any MITM, posing as the server,



<span class="grey">Williams                    Standards Track                    [Page 11]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-12" id="page-12" name="page-12"> </a>
<span class="grey"><a href="rfc5056.html">RFC 5056</a>                  On Channel Bindings              November 2007</span>


   can simply assign the same session ID to the victim client as the
   server assigned to the MITM.  Instead, the initial, unencrypted TLS
   finished messages (the client's, the server's, or both) are
   sufficient as they are the output of the TLS pseudo-random function,
   keyed with the session key, applied to all handshake material.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.2.%20%20Examples%20of%20End-Point%20Channel%20Bindings"></a><a class="selflink" href="#section-4.2" name="section-4.2">4.2</a>.  Examples of End-Point Channel Bindings</span>

   The following text is not normative, but is here to show how one
   might construct channel bindings for various types of secure
   channels.

   For SSHv2 [<a href="rfc4251.html" title='"The Secure Shell (SSH) Protocol Architecture"'>RFC4251</a>] the SSHv2 host public key, when present, should
   suffice as it is used to sign the algorithm suite negotiation and
   Diffie-Hellman key exchange; as long the client observes the host
   public key that corresponds to the private host key that the server
   used, then there cannot be an MITM in the SSHv2 connection.  Note
   that not all SSHv2 key exchanges use host public keys; therefore,
   this channel bindings construction is not as useful as the one given
   in <a href="#section-4.1">Section 4.1</a>.

   For TLS [<a href="rfc4346.html" title='"The Transport Layer Security (TLS) Protocol Version 1.1"'>RFC4346</a>]the server certificate should suffice for the same
   reasons as above.  Again, not all TLS cipher suites involve server
   certificates; therefore, the utility of this construction of channel
   bindings is limited to scenarios where server certificates are
   commonly used.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/5.%20%20Uses%20of%20Channel%20Binding"></a><a class="selflink" href="#section-5" name="section-5">5</a>.  Uses of Channel Binding</span>

   Uses for channel binding identified so far:

   o  Delegating session cryptographic protection to layers where
      hardware can reasonably be expected to support relevant
      cryptographic protocols:

      *  NFSv4 [<a href="rfc3530.html" title='"Network File System (NFS) version 4 Protocol"'>RFC3530</a>] with Remote Direct Data Placement (RDDP)
         [<a href="#ref-NFS-DDP" title='"NFS Direct Data Placement"'>NFS-DDP</a>] for zero-copy reception where network interface
         controllers (NICs) support RDDP.  Cryptographic session
         protection would be delegated to Encapsulating Security Payload
         (ESP) [<a href="rfc4303.html" title='"IP Encapsulating Security Payload (ESP)"'>RFC4303</a>] / Authentication Headers (AHs) [<a href="rfc4302.html" title='"IP Authentication Header"'>RFC4302</a>].

      *  iSCSI [<a href="rfc3720.html" title='"Internet Small Computer Systems Interface (iSCSI)"'>RFC3720</a>] with Remote Direct Memory Access (RDMA)
         [<a href="rfc5046.html" title='"Internet Small Computer System Interface (iSCSI) Extensions for Remote Direct Memory Access (RDMA)"'>RFC5046</a>].  Cryptographic session protection would be delegated
         to ESP/AH.

      *  HTTP with TLS [<a href="rfc2817.html" title='"Upgrading to TLS Within HTTP/1.1"'>RFC2817</a>] [<a href="rfc2818.html" title='"HTTP Over TLS"'>RFC2818</a>].  In situations involving
         proxies, users may want to bind authentication to a TLS channel
         between the last client-side proxy and the first server-side



<span class="grey">Williams                    Standards Track                    [Page 12]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-13" id="page-13" name="page-13"> </a>
<span class="grey"><a href="rfc5056.html">RFC 5056</a>                  On Channel Bindings              November 2007</span>


         proxy ("concentrator").  There is ongoing work to expand the
         set of choices for end-to-end authentication at the HTTP layer,
         that, coupled with channel binding to TLS, would allow for
         proxies while not forgoing protection over public internets.

   o  Reducing the number of live cryptographic contexts that an
      application must maintain:

      *  NFSv4 [<a href="rfc3530.html" title='"Network File System (NFS) version 4 Protocol"'>RFC3530</a>] multiplexes multiple users onto individual
         connections.  Each user is authenticated separately, and users'
         remote procedure calls (RPCs) are protected with per-user GSS-
         API security contexts.  This means that large timesharing
         clients must often maintain many cryptographic contexts per-
         NFSv4 connection.  With channel binding to IPsec, they could
         maintain a much smaller number of cryptographic contexts per-
         NFSv4 connection, thus reducing memory pressure and
         interactions with cryptographic hardware.

   For example, applications that wish to use RDDP to achieve zero-copy
   semantics on reception may use a network layer understood by NICs to
   offload delivery of application data into pre-arranged memory
   buffers.  Note that in order to obtain zero-copy reception semantics
   either application data has to be in cleartext relative to this RDDP
   layer, or the RDDP implementation must know how to implement
   cryptographic session protection protocols used at the application
   layer.

   There are a multitude of application-layer cryptographic session
   protection protocols available.  It is not reasonable to expect that
   NICs should support many such protocols.  Further, some application
   protocols may maintain many cryptographic session contexts per-
   connection (for example, NFSv4 does).  It is thought to be simpler to
   push the cryptographic session protection down the network stack (to
   IPsec), and yet be able to produce NICs that offload other operations
   (i.e., TCP/IP, ESP/AH, and DDP), than it would be to add support in
   the NIC for the many session cryptographic protection protocols in
   use in common applications at the application layer.














<span class="grey">Williams                    Standards Track                    [Page 13]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-14" id="page-14" name="page-14"> </a>
<span class="grey"><a href="rfc5056.html">RFC 5056</a>                  On Channel Bindings              November 2007</span>


   The following figure shows how the various network layers are
   related:

      +---------------------+
      | Application layer   |&lt;---+
      |                     |&lt;-+ |  In cleartext, relative
      +---------------------+  | |  to each other.
      | RDDP                |&lt;---+
      +---------------------+  |
      | TCP/SCTP            |&lt;-+
      +---------------------+  | Channel binding of app-layer
      | ESP/AH              |&lt;-+ authentication to IPsec
      +---------------------+
      | IP                  |
      +---------------------+
      | ...                 |
      +---------------------+

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/6.%20%20Benefits%20of%20Channel%20Binding%20to%20Secure%20Channels"></a><a class="selflink" href="#section-6" name="section-6">6</a>.  Benefits of Channel Binding to Secure Channels</span>

   The use of channel binding to delegate session cryptographic
   protection include:

   o  Performance improvements by avoiding double protection of
      application data in cases where IPsec is in use and applications
      provide their own secure channels.

   o  Performance improvements by leveraging hardware-accelerated IPsec.

   o  Performance improvements by allowing RDDP hardware offloading to
      be integrated with IPsec hardware acceleration.

         Where protocols layered above RDDP use privacy protection, RDDP
         offload cannot be done.  Thus, by using channel binding to
         IPsec, the privacy protection is moved to IPsec, which is
         layered below RDDP.  So, RDDP can address application protocol
         data that's in cleartext relative to the RDDP headers.

   o  Latency improvements for applications that multiplex multiple
      users onto a single channel, such as NFS with RPCSEC_GSS
      [<a href="rfc2203.html" title='"RPCSEC_GSS Protocol Specification"'>RFC2203</a>].

   Delegation of session cryptographic protection to IPsec requires
   features not yet specified.  There is ongoing work to specify:

   o  IPsec channels [<a href="#ref-CONN-LATCH" title='"IPsec Channels: Connection Latching"'>CONN-LATCH</a>];





<span class="grey">Williams                    Standards Track                    [Page 14]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-15" id="page-15" name="page-15"> </a>
<span class="grey"><a href="rfc5056.html">RFC 5056</a>                  On Channel Bindings              November 2007</span>


   o  Application programming interfaces (APIs) related to IPsec
      channels [<a href="#ref-BTNS-IPSEC" title='"Requirements for an IPsec API"'>BTNS-IPSEC</a>];

   o  Channel bindings for IPsec channels;

   o  Low infrastructure IPsec authentication [<a href="#ref-BTNS-CORE" title='"Better-Than-Nothing- Security: An Unauthenticated Mode of IPsec"'>BTNS-CORE</a>].

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/7.%20%20IANA%20Considerations"></a><a class="selflink" href="#section-7" name="section-7">7</a>.  IANA Considerations</span>

   IANA has created a new registry for channel bindings specifications
   for various types of channels.

   The purpose of this registry is not only to ensure uniqueness of
   values used to name channel bindings, but also to provide a
   definitive reference to technical specifications detailing each
   channel binding available for use on the Internet.

   There is no naming convention for channel bindings: any string
   composed of US-ASCII alphanumeric characters, period ('.'), and dash
   ('-') will suffice.

   The procedure detailed in <a href="#section-7.1">Section 7.1</a> is to be used for registration
   of a value naming a specific individual mechanism.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/7.1.%20%20Registration%20Procedure"></a><a class="selflink" href="#section-7.1" name="section-7.1">7.1</a>.  Registration Procedure</span>

   Registration of a new channel binding requires expert review as
   defined in <a href="http://tools.ietf.org/html/bcp26">BCP 26</a> [<a href="rfc2434.html" title='"Guidelines for Writing an IANA Considerations Section in RFCs"'>RFC2434</a>].

   Registration of a channel binding is requested by filling in the
   following template:

   o  Subject: Registration of channel binding X

   o  Channel binding unique prefix (name):

   o  Channel binding type: (One of "unique" or "end-point")

   o  Channel type: (e.g., TLS, IPsec, SSH, etc.)

   o  Published specification (recommended, optional):

   o  Channel binding is secret (requires confidentiality protection):
      yes/no

   o  Description (optional if a specification is given; required if no
      published specification is specified):




<span class="grey">Williams                    Standards Track                    [Page 15]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-16" id="page-16" name="page-16"> </a>
<span class="grey"><a href="rfc5056.html">RFC 5056</a>                  On Channel Bindings              November 2007</span>


   o  Intended usage: (one of COMMON, LIMITED USE, or OBSOLETE)

   o  Person and email address to contact for further information:

   o  Owner/Change controller name and email address:

   o  Expert reviewer name and contact information: (leave blank)

   o  Note: (Any other information that the author deems relevant may be
      added here.)

   and sending it via electronic mail to &lt;channel-binding@ietf.org&gt; (a
   public mailing list) and carbon copying IANA at &lt;iana@iana.org&gt;.
   After allowing two weeks for community input on the mailing list to
   be determined, an expert will determine the appropriateness of the
   registration request and either approve or disapprove the request
   with notice to the requestor, the mailing list, and IANA.

   If the expert approves registration, it adds her/his name to the
   submitted registration.

   The expert has the primary responsibility of making sure that channel
   bindings for IETF specifications go through the IETF consensus
   process and that prefixes are unique.

   The review should focus on the appropriateness of the requested
   channel binding for the proposed use, the appropriateness of the
   proposed prefix, and correctness of the channel binding type in the
   registration.  The scope of this request review may entail
   consideration of relevant aspects of any provided technical
   specification, such as their IANA Considerations section.  However,
   this review is narrowly focused on the appropriateness of the
   requested registration and not on the overall soundness of any
   provided technical specification.

   Authors are encouraged to pursue community review by posting the
   technical specification as an Internet-Draft and soliciting comment
   by posting to appropriate IETF mailing lists.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/7.2.%20%20Comments%20on%20Channel%20Bindings%20Registrations"></a><a class="selflink" href="#section-7.2" name="section-7.2">7.2</a>.  Comments on Channel Bindings Registrations</span>

   Comments on registered channel bindings should first be sent to the
   "owner" of the channel bindings and to the channel binding mailing
   list.

   Submitters of comments may, after a reasonable attempt to contact the
   owner, request IANA to attach their comment to the channel binding
   type registration itself by sending mail to &lt;iana@iana.org&gt;.  At



<span class="grey">Williams                    Standards Track                    [Page 16]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-17" id="page-17" name="page-17"> </a>
<span class="grey"><a href="rfc5056.html">RFC 5056</a>                  On Channel Bindings              November 2007</span>


   IANA's sole discretion, IANA may attach the comment to the channel
   bindings registration.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/7.3.%20%20Change%20Control"></a><a class="selflink" href="#section-7.3" name="section-7.3">7.3</a>.  Change Control</span>

   Once a channel bindings registration has been published by IANA, the
   author may request a change to its definition.  The change request
   follows the same procedure as the registration request.

   The owner of a channel bindings may pass responsibility for the
   channel bindings to another person or agency by informing IANA; this
   can be done without discussion or review.

   The IESG may reassign responsibility for a channel bindings
   registration.  The most common case of this will be to enable changes
   to be made to mechanisms where the author of the registration has
   died, has moved out of contact, or is otherwise unable to make
   changes that are important to the community.

   Channel bindings registrations may not be deleted; mechanisms that
   are no longer believed appropriate for use can be declared OBSOLETE
   by a change to their "intended usage" field.  Such channel bindings
   will be clearly marked in the lists published by IANA.

   The IESG is considered to be the owner of all channel bindings that
   are on the IETF standards track.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/8.%20%20Security%20Considerations"></a><a class="selflink" href="#section-8" name="section-8">8</a>.  Security Considerations</span>

   Security considerations appear throughout this document.  In
   particular see <a href="#section-2.1">Section 2.1</a>.

   When delegating session protection from one layer to another, one
   will almost certainly be making some session security trade-offs,
   such as using weaker cipher modes in one layer than might be used in
   the other.  Evaluation and comparison of the relative cryptographic
   strengths of these is difficult, may not be easily automated, and is
   far out of scope for this document.  Implementors and administrators
   should understand these trade-offs.  Interfaces to secure channels
   and application-layer authentication frameworks and mechanisms could
   provide some notion of security profile so that applications may
   avoid delegation of session protection to channels that are too weak
   to match a required security profile.

   Channel binding makes "anonymous" channels (where neither end-point
   is strongly authenticated to the other) useful.  Implementors should
   avoid making it easy to use such channels without channel binding.




<span class="grey">Williams                    Standards Track                    [Page 17]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-18" id="page-18" name="page-18"> </a>
<span class="grey"><a href="rfc5056.html">RFC 5056</a>                  On Channel Bindings              November 2007</span>


   The security of channel binding depends on the security of the
   channels, the construction of their channel bindings, and the
   security of the authentication mechanism used by the application and
   its channel binding method.

   Channel bindings should be constructed in such a way that revealing
   the channel bindings of a channel to third parties does not weaken
   the security of the channel.  However, for end-point channel bindings
   disclosure of the channel bindings may disclose the identities of the
   peers.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/8.1.%20%20Non-Unique%20Channel%20Bindings%20and%20Channel%20Binding%20Re-Establishment"></a><a class="selflink" href="#section-8.1" name="section-8.1">8.1</a>.  Non-Unique Channel Bindings and Channel Binding Re-Establishment</span>

   Application developers may be tempted to use non-unique channel
   bindings for fast re-authentication following channel re-
   establishment.  Care must be taken to avoid the possibility of
   attacks on multi-user systems.

   Consider a user multiplexing protocol like NFSv4 using channel
   binding to IPsec on a multi-user client.  If another user can connect
   directly to port 2049 (NFS) on some server using IPsec and merely
   assert RPCSEC_GSS credential handles, then this user will be able to
   impersonate any user authenticated by the client to the server.  This
   is because the new connection will have the same channel bindings as
   the NFS client's!  To prevent this, the server must require that at
   least a host-based client principal, and perhaps all the client's
   user principals, re-authenticate and perform channel binding before
   the server will allow the clients to assert RPCSEC_GSS context
   handles.  Alternatively, the protocol could require a) that secure
   channels provide confidentiality protection and b) that fast re-
   authentication cookies be difficult to guess (e.g., large numbers
   selected randomly).

   In other contexts there may not be such problems, for example, in the
   case of application protocols that don't multiplex users over a
   single channel and where confidentiality protection is always used in
   the secure channel.














<span class="grey">Williams                    Standards Track                    [Page 18]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-19" id="page-19" name="page-19"> </a>
<span class="grey"><a href="rfc5056.html">RFC 5056</a>                  On Channel Bindings              November 2007</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/9.%20%20References"></a><a class="selflink" href="#section-9" name="section-9">9</a>.  References</span>

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/9.1.%20%20Normative%20References"></a><a class="selflink" href="#section-9.1" name="section-9.1">9.1</a>.  Normative References</span>

   [<a id="ref-RFC2119" name="ref-RFC2119">RFC2119</a>]    Bradner, S., "Key words for use in RFCs to Indicate
                Requirement Levels", <a href="http://tools.ietf.org/html/bcp14">BCP 14</a>, <a href="rfc2119.html">RFC 2119</a>, March 1997.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/9.2.%20%20Informative%20References"></a><a class="selflink" href="#section-9.2" name="section-9.2">9.2</a>.  Informative References</span>

   [<a id="ref-BTNS-AS" name="ref-BTNS-AS">BTNS-AS</a>]    Touch, J., Black, D., and Y. Wang, "Problem and
                Applicability Statement for Better Than Nothing Security
                (BTNS)", Work in Progress, October 2007.

   [<a id="ref-BTNS-CORE" name="ref-BTNS-CORE">BTNS-CORE</a>]  Richardson, M. and N. Williams, "Better-Than-Nothing-
                Security: An Unauthenticated Mode of IPsec", Work in
                Progress, September 2007.

   [<a id="ref-BTNS-IPSEC" name="ref-BTNS-IPSEC">BTNS-IPSEC</a>] Richardson, M. and B. Sommerfeld, "Requirements for an
                IPsec API", Work in Progress, April 2006.

   [<a id="ref-CONN-LATCH" name="ref-CONN-LATCH">CONN-LATCH</a>] Williams, N., <a href="http://www.google.com/search?sitesearch=tools.ietf.org%2Fhtml%2F&amp;q=inurl:draft-+%22IPsec+Channels%3A+Connection+Latching%22" style="text-decoration: none">"IPsec Channels: Connection Latching"</a>,
                Work in Progress, September 2007.

   [<a id="ref-Lampson91" name="ref-Lampson91">Lampson91</a>]  Lampson, B., Abadi, M., Burrows, M., and E. Wobber,
                "Authentication in Distributed Systems: Theory and
                Practive", October 1991.

   [<a id="ref-NFS-DDP" name="ref-NFS-DDP">NFS-DDP</a>]    Callaghan, B. and T. Talpey, "NFS Direct Data
                Placement", Work in Progress, July 2007.

   [<a id="ref-RFC1964" name="ref-RFC1964">RFC1964</a>]    Linn, J., "The Kerberos Version 5 GSS-API Mechanism",
                <a href="rfc1964.html">RFC 1964</a>, June 1996.

   [<a id="ref-RFC2203" name="ref-RFC2203">RFC2203</a>]    Eisler, M., Chiu, A., and L. Ling, "RPCSEC_GSS Protocol
                Specification", <a href="rfc2203.html">RFC 2203</a>, September 1997.

   [<a id="ref-RFC2401" name="ref-RFC2401">RFC2401</a>]    Kent, S. and R. Atkinson, "Security Architecture for the
                Internet Protocol", <a href="rfc2401.html">RFC 2401</a>, November 1998.

   [<a id="ref-RFC2434" name="ref-RFC2434">RFC2434</a>]    Narten, T. and H. Alvestrand, "Guidelines for Writing an
                IANA Considerations Section in RFCs", <a href="http://tools.ietf.org/html/bcp26">BCP 26</a>, <a href="rfc2434.html">RFC 2434</a>,
                October 1998.

   [<a id="ref-RFC2743" name="ref-RFC2743">RFC2743</a>]    Linn, J., "Generic Security Service Application Program
                Interface Version 2, Update 1", <a href="rfc2743.html">RFC 2743</a>, January 2000.

   [<a id="ref-RFC2744" name="ref-RFC2744">RFC2744</a>]    Wray, J., "Generic Security Service API Version 2 :
                C-bindings", <a href="rfc2744.html">RFC 2744</a>, January 2000.



<span class="grey">Williams                    Standards Track                    [Page 19]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-20" id="page-20" name="page-20"> </a>
<span class="grey"><a href="rfc5056.html">RFC 5056</a>                  On Channel Bindings              November 2007</span>


   [<a id="ref-RFC2817" name="ref-RFC2817">RFC2817</a>]    Khare, R. and S. Lawrence, "Upgrading to TLS Within
                HTTP/1.1", <a href="rfc2817.html">RFC 2817</a>, May 2000.

   [<a id="ref-RFC2818" name="ref-RFC2818">RFC2818</a>]    Rescorla, E., "HTTP Over TLS", <a href="rfc2818.html">RFC 2818</a>, May 2000.

   [<a id="ref-RFC3530" name="ref-RFC3530">RFC3530</a>]    Shepler, S., Callaghan, B., Robinson, D., Thurlow, R.,
                Beame, C., Eisler, M., and D. Noveck, "Network File
                System (NFS) version 4 Protocol", <a href="rfc3530.html">RFC 3530</a>, April 2003.

   [<a id="ref-RFC3720" name="ref-RFC3720">RFC3720</a>]    Satran, J., Meth, K., Sapuntzakis, C., Chadalapaka, M.,
                and E. Zeidner, "Internet Small Computer Systems
                Interface (iSCSI)", <a href="rfc3720.html">RFC 3720</a>, April 2004.

   [<a id="ref-RFC3748" name="ref-RFC3748">RFC3748</a>]    Aboba, B., Blunk, L., Vollbrecht, J., Carlson, J., and
                H.  Levkowetz, "Extensible Authentication Protocol
                (EAP)", <a href="rfc3748.html">RFC 3748</a>, June 2004.

   [<a id="ref-RFC4120" name="ref-RFC4120">RFC4120</a>]    Neuman, C., Yu, T., Hartman, S., and K. Raeburn, "The
                Kerberos Network Authentication Service (V5)", <a href="rfc4120.html">RFC 4120</a>,
                July 2005.

   [<a id="ref-RFC4251" name="ref-RFC4251">RFC4251</a>]    Ylonen, T. and C. Lonvick, "The Secure Shell (SSH)
                Protocol Architecture", <a href="rfc4251.html">RFC 4251</a>, January 2006.

   [<a id="ref-RFC4301" name="ref-RFC4301">RFC4301</a>]    Kent, S. and K. Seo, "Security Architecture for the
                Internet Protocol", <a href="rfc4301.html">RFC 4301</a>, December 2005.

   [<a id="ref-RFC4302" name="ref-RFC4302">RFC4302</a>]    Kent, S., "IP Authentication Header", <a href="rfc4302.html">RFC 4302</a>, December
                2005.

   [<a id="ref-RFC4303" name="ref-RFC4303">RFC4303</a>]    Kent, S., "IP Encapsulating Security Payload (ESP)", <a href="rfc4303.html">RFC</a>
                <a href="rfc4303.html">4303</a>, December 2005.

   [<a id="ref-RFC4346" name="ref-RFC4346">RFC4346</a>]    Dierks, T. and E. Rescorla, "The Transport Layer
                Security (TLS) Protocol Version 1.1", <a href="rfc4346.html">RFC 4346</a>, April
                2006.

   [<a id="ref-RFC4422" name="ref-RFC4422">RFC4422</a>]    Melnikov, A. and K. Zeilenga, "Simple Authentication and
                Security Layer (SASL)", <a href="rfc4422.html">RFC 4422</a>, June 2006.

   [<a id="ref-RFC4462" name="ref-RFC4462">RFC4462</a>]    Hutzelman, J., Salowey, J., Galbraith, J., and V. Welch,
                "Generic Security Service Application Program Interface
                (GSS-API) Authentication and Key Exchange for the Secure
                Shell (SSH) Protocol", <a href="rfc4462.html">RFC 4462</a>, May 2006.







<span class="grey">Williams                    Standards Track                    [Page 20]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-21" id="page-21" name="page-21"> </a>
<span class="grey"><a href="rfc5056.html">RFC 5056</a>                  On Channel Bindings              November 2007</span>


   [<a id="ref-RFC5046" name="ref-RFC5046">RFC5046</a>]    Ko, M., Chadalapaka, M., Hufferd, J., Elzur, U., Shah,
                H., and P. Thaler, "Internet Small Computer System
                Interface (iSCSI) Extensions for Remote Direct Memory
                Access (RDMA)", <a href="rfc5046.html">RFC 5046</a>, October 2007.

   [<a id="ref-SASL-GS2" name="ref-SASL-GS2">SASL-GS2</a>]   Josefsson, S., "Using GSS-API Mechanisms in SASL: The
                GS2 Mechanism Family", Work in Progress, October 2007.

   [<a id="ref-SSH-CB" name="ref-SSH-CB">SSH-CB</a>]     Williams, N., "Channel Binding Identifiers for Secure
                Shell Channels", Work in Progress, November 2007.

   [<a id="ref-STACKABLE" name="ref-STACKABLE">STACKABLE</a>]  Williams, N., "Stackable Generic Security Service
                Pseudo-Mechanisms", Work in Progress, June 2006.

   [<a id="ref-TLS-CB" name="ref-TLS-CB">TLS-CB</a>]     Altman, J. and N. Williams, "Unique Channel Bindings for
                TLS", Work in Progress, November 2007.



































<span class="grey">Williams                    Standards Track                    [Page 21]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-22" id="page-22" name="page-22"> </a>
<span class="grey"><a href="rfc5056.html">RFC 5056</a>                  On Channel Bindings              November 2007</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/Appendix%20A.%20%20Acknowledgments"></a><a class="selflink" href="#appendix-A" name="appendix-A">Appendix A</a>.  Acknowledgments</span>

   Thanks to Mike Eisler for his work on the Channel Conjunction
   Mechanism document and for bringing the problem to a head, Sam
   Hartman for pointing out that channel binding provides a general
   solution to the channel binding problem, and Jeff Altman for his
   suggestion of using the TLS finished messages as the TLS channel
   bindings.  Also, thanks to Bill Sommerfeld, Radia Perlman, Simon
   Josefsson, Joe Salowey, Eric Rescorla, Michael Richardson, Bernard
   Aboba, Tom Petch, Mark Brown, and many others.

Author's Address

   Nicolas Williams
   Sun Microsystems
   5300 Riata Trace Ct.
   Austin, TX  78727
   US

   EMail: Nicolas.Williams@sun.com































<span class="grey">Williams                    Standards Track                    [Page 22]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-23" id="page-23" name="page-23"> </a>
<span class="grey"><a href="rfc5056.html">RFC 5056</a>                  On Channel Bindings              November 2007</span>


Full Copyright Statement

   Copyright (C) The IETF Trust (2007).

   This document is subject to the rights, licenses and restrictions
   contained in <a href="http://tools.ietf.org/html/bcp78">BCP 78</a>, and except as set forth therein, the authors
   retain all their rights.

   This document and the information contained herein are provided on an
   "AS IS" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS
   OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST AND
   THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS
   OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF
   THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED
   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.

Intellectual Property

   The IETF takes no position regarding the validity or scope of any
   Intellectual Property Rights or other rights that might be claimed to
   pertain to the implementation or use of the technology described in
   this document or the extent to which any license under such rights
   might or might not be available; nor does it represent that it has
   made any independent effort to identify any such rights.  Information
   on the procedures with respect to rights in RFC documents can be
   found in <a href="http://tools.ietf.org/html/bcp78">BCP 78</a> and <a href="http://tools.ietf.org/html/bcp79">BCP 79</a>.

   Copies of IPR disclosures made to the IETF Secretariat and any
   assurances of licenses to be made available, or the result of an
   attempt made to obtain a general license or permission for the use of
   such proprietary rights by implementers or users of this
   specification can be obtained from the IETF on-line IPR repository at
   <a href="http://www.ietf.org/ipr">http://www.ietf.org/ipr</a>.

   The IETF invites any interested party to bring to its attention any
   copyrights, patents or patent applications, or other proprietary
   rights that may cover technology that may be required to implement
   this standard.  Please address the information to the IETF at
   ietf-ipr@ietf.org.












Williams                    Standards Track                    [Page 23]

</pre><br/>
<span class="noprint"><small><small>Html markup produced by rfcmarkup 1.107, available from
<a href="http://tools.ietf.org/tools/rfcmarkup/">http://tools.ietf.org/tools/rfcmarkup/</a>
</small></small></span>


<meta content="text/html;charset=utf-8" http-equiv="content-type"/><!-- /Added by HTTrack -->

</body><!-- Mirrored from tools.ietf.org/html/rfc5056 by HTTrack Website Copier/3.x [XR&CO'2010], Wed, 19 Mar 2014 18:38:27 GMT --><!-- Added by HTTrack --></html>