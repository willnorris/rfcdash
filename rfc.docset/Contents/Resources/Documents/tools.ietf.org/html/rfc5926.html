<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml"><head profile="http://dublincore.org/documents/2008/08/04/dc-html/">
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
    <meta content="index,follow" name="robots"/>
    <meta content="rfcmarkup version 1.106" name="creator"/>
    <link href="http://purl.org/dc/elements/1.1/" rel="schema.DC"/>
<meta content="draft-lebovitz-ietf-tcpm-tcp-ao-crypto" name="DC.Relation.Replaces"/>
<meta content="urn:ietf:rfc:5926" name="DC.Identifier"/>
<meta content="June, 2010" name="DC.Date.Issued"/>
<meta content="Rescorla, Eric" name="DC.Creator"/>
<meta content="Lebovitz, Gregory" name="DC.Creator"/>
<meta content="The TCP Authentication Option (TCP-AO) relies on security algorithms\nto provide authentication between two end-points. There are many such\nalgorithms available, and two TCP-AO systems cannot interoperate\nunless they are using the same algorithms. This document specifies the\nalgorithms and attributes that can be used in TCP-AO\x27s current\nmanual keying mechanism and provides the interface for future message\nauthentication codes (MACs). [STANDARDS-TRACK]" name="DC.Description.Abstract"/>
<meta content="Cryptographic Algorithms for the TCP Authentication Option (TCP-AO)" name="DC.Title"/>

    <link href="http://tools.ietf.org/images/rfc.png" rel="icon" type="image/png"/>
    <link href="http://tools.ietf.org/images/rfc.png" rel="shortcut icon" type="image/png"/>
    <title>RFC 5926 - Cryptographic Algorithms for the TCP Authentication Option (TCP-AO)</title>
    
    
    <style type="text/css">
	body {
	    margin: 0px 8px;
            font-size: 1em;
	}
        h1, h2, h3, h4, h5, h6, .h1, .h2, .h3, .h4, .h5, .h6 {
	    font-weight: bold;
            line-height: 0pt;
            display: inline;
            white-space: pre;
            font-family: monospace;
            font-size: 1em;
	    font-weight: bold;
        }
        pre {
            font-size: 1em;
            margin-top: 0px;
            margin-bottom: 0px;
        }
	.pre {
	    white-space: pre;
	    font-family: monospace;
	}
	.header{
	    font-weight: bold;
	}
        .newpage {
            page-break-before: always;
        }
        .invisible {
            text-decoration: none;
            color: white;
        }
        a.selflink {
          color: black;
          text-decoration: none;
        }
        @media print {
            body {
                font-family: monospace;
                font-size: 10.5pt;
            }
            h1, h2, h3, h4, h5, h6 {
                font-size: 1em;
            }
        
            a:link, a:visited {
                color: inherit;
                text-decoration: none;
            }
            .noprint {
                display: none;
            }
        }
	@media screen {
	    .grey, .grey a:link, .grey a:visited {
		color: #777;
	    }
            .docinfo {
                background-color: #EEE;
            }
            .top {
                border-top: 7px solid #EEE;
            }
            .bgwhite  { background-color: white; }
            .bgred    { background-color: #F44; }
            .bggrey   { background-color: #666; }
            .bgbrown  { background-color: #840; }            
            .bgorange { background-color: #FA0; }
            .bgyellow { background-color: #EE0; }
            .bgmagenta{ background-color: #F4F; }
            .bgblue   { background-color: #66F; }
            .bgcyan   { background-color: #4DD; }
            .bggreen  { background-color: #4F4; }

            .legend   { font-size: 90%; }
            .cplate   { font-size: 70%; border: solid grey 1px; }
	}
    </style>
    <!--[if IE]>
    <style>
    body {
       font-size: 13px;
       margin: 10px 10px;
    }
    </style>
    <![endif]-->

    <script type="text/javascript"><!--
    function addHeaderTags() {
	var spans = document.getElementsByTagName("span");
	for (var i=0; i < spans.length; i++) {
	    var elem = spans[i];
	    if (elem) {
		var level = elem.getAttribute("class");
                if (level == "h1" || level == "h2" || level == "h3" || level == "h4" || level == "h5" || level == "h6") {
                    elem.innerHTML = "<"+level+">"+elem.innerHTML+"</"+level+">";		
                }
	    }
	}
    }
    var legend_html = "Colour legend:<br />      <table>         <tr><td>Unknown:</td>                   <td><span class='cplate bgwhite'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft:</td>                     <td><span class='cplate bgred'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Informational:</td>             <td><span class='cplate bgorange'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Experimental:</td>              <td><span class='cplate bgyellow'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Best Common Practice:</td>      <td><span class='cplate bgmagenta'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Proposed Standard:</td>         <td><span class='cplate bgblue'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft Standard (old designation):</td> <td><span class='cplate bgcyan'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Internet Standard:</td>         <td><span class='cplate bggreen'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Historic:</td>                  <td><span class='cplate bggrey'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Obsolete:</td>                  <td><span class='cplate bgbrown'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>     </table>";
    function showElem(id) {
        var elem = document.getElementById(id);
        elem.innerHTML = eval(id+"_html");
        elem.style.visibility='visible';
    }
    function hideElem(id) {
        var elem = document.getElementById(id);
        elem.style.visibility='hidden';        
        elem.innerHTML = "";
    }
    // -->
    </script>
</head>
<body onload="addHeaderTags()">
   <div style="height: 13px;">
      <div class="pre noprint docinfo bgblue" onclick="showElem('legend');" onmouseout="hideElem('legend')" onmouseover="this.style.cursor='pointer';" style="height: 6px; position: absolute;" title="Click for colour legend.">                                                                        </div>
      <div class="docinfo noprint pre legend" id="legend" onmouseout="hideElem('legend');" onmouseover="showElem('legend');" style="position:absolute; top: 4px; left: 4ex; visibility:hidden; background-color: white; padding: 4px 9px 5px 7px; border: solid #345 1px; ">
      </div>
   </div>
<span class="pre noprint docinfo top">[<a href="index.html" title="Document search and retrieval page">Docs</a>] [<a href="http://tools.ietf.org/rfc/rfc5926.txt" title="Plaintext version of this document">txt</a>|<a href="http://tools.ietf.org/pdf/rfc5926" title="PDF version of this document">pdf</a>] [<a href="http://tools.ietf.org/html/draft-ietf-tcpm-tcp-ao-crypto" title="draft-ietf-tcpm-tcp-ao-crypto">draft-ietf-tcpm-t...</a>] [<a href="http://tools.ietf.org/rfcdiff?difftype=--hwdiff&amp;url2=rfc5926" title="Inline diff (wdiff)">Diff1</a>] [<a href="http://tools.ietf.org/rfcdiff?url2=rfc5926" title="Side-by-side diff">Diff2</a>]                 </span><br/>
<span class="pre noprint docinfo">                                                                        </span><br/>
<span class="pre noprint docinfo">                                                       PROPOSED STANDARD</span><br/>
<span class="pre noprint docinfo">                                                                        </span><br/>
<pre>Internet Engineering Task Force (IETF)                       G. Lebovitz
Request for Comments: 5926                                       Juniper
Category: Standards Track                                    E. Rescorla
ISSN: 2070-1721                                                     RTFM
                                                               June 2010


  <span class="h1">Cryptographic Algorithms for the TCP Authentication Option (TCP-AO)</span>

Abstract

   The TCP Authentication Option (TCP-AO) relies on security algorithms
   to provide authentication between two end-points.  There are many
   such algorithms available, and two TCP-AO systems cannot interoperate
   unless they are using the same algorithms.  This document specifies
   the algorithms and attributes that can be used in TCP-AO's current
   manual keying mechanism and provides the interface for future message
   authentication codes (MACs).

Status of This Memo

   This is an Internet Standards Track document.

   This document is a product of the Internet Engineering Task Force
   (IETF).  It represents the consensus of the IETF community.  It has
   received public review and has been approved for publication by the
   Internet Engineering Steering Group (IESG).  Further information on
   Internet Standards is available in <a href="rfc5741.html#section-2">Section 2 of RFC 5741</a>.

   Information about the current status of this document, any errata,
   and how to provide feedback on it may be obtained at
   <a href="http://www.rfc-editor.org/info/rfc5926">http://www.rfc-editor.org/info/rfc5926</a>.

Copyright Notice

   Copyright (c) 2010 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to <a href="http://tools.ietf.org/html/bcp78">BCP 78</a> and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (<a href="http://trustee.ietf.org/license-info">http://trustee.ietf.org/license-info</a>) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in <a href="#section-4">Section 4</a>.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.




<span class="grey">Lebovitz &amp; Rescorla          Standards Track                    [Page 1]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-2" id="page-2" name="page-2"> </a>
<span class="grey"><a href="rfc5926.html">RFC 5926</a>                    Crypto for TCP-AO                  June 2010</span>


Table of Contents

   <a href="#section-1">1</a>. Introduction ....................................................<a href="#page-2">2</a>
   <a href="#section-2">2</a>. Requirements ....................................................<a href="#page-3">3</a>
      <a href="#section-2.1">2.1</a>. Requirements Language ......................................<a href="#page-3">3</a>
      <a href="#section-2.2">2.2</a>. Algorithm Requirements .....................................<a href="#page-3">3</a>
      <a href="#section-2.3">2.3</a>. Requirements for Future MAC Algorithms .....................<a href="#page-3">3</a>
   <a href="#section-3">3</a>. Algorithms Specified ............................................<a href="#page-4">4</a>
      <a href="#section-3.1">3.1</a>. Key Derivation Functions (KDFs) ............................<a href="#page-4">4</a>
           <a href="#section-3.1.1">3.1.1</a>. Concrete KDFs .......................................<a href="#page-5">5</a>
                  <a href="#section-3.1.1.1">3.1.1.1</a>. KDF_HMAC_SHA1 ..............................<a href="#page-6">6</a>
                  <a href="#section-3.1.1.2">3.1.1.2</a>. KDF_AES_128_CMAC ...........................<a href="#page-7">7</a>
                  <a href="#section-3.1.1.3">3.1.1.3</a>. Tips for User Interfaces Regarding KDFs ....<a href="#page-9">9</a>
      <a href="#section-3.2">3.2</a>. MAC Algorithms .............................................<a href="#page-9">9</a>
           <a href="#section-3.2.1">3.2.1</a>. The Use of HMAC-SHA-1-96 ...........................<a href="#page-10">10</a>
           <a href="#section-3.2.2">3.2.2</a>. The Use of AES-128-CMAC-96 .........................<a href="#page-11">11</a>
   <a href="#section-4">4</a>. Security Considerations ........................................<a href="#page-11">11</a>
   <a href="#section-5">5</a>. IANA Considerations ............................................<a href="#page-13">13</a>
   <a href="#section-6">6</a>. Acknowledgements ...............................................<a href="#page-13">13</a>
   <a href="#section-7">7</a>. References .....................................................<a href="#page-14">14</a>
      <a href="#section-7.1">7.1</a>. Normative References ......................................<a href="#page-14">14</a>
      <a href="#section-7.2">7.2</a>. Informative References ....................................<a href="#page-14">14</a>

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/1.%20%20Introduction"></a><a class="selflink" href="#section-1" name="section-1">1</a>.  Introduction</span>

   This document is a companion to [<a href="rfc5925.html" title='"The TCP Authentication Option"'>RFC5925</a>].  Like most modern security
   protocols, TCP-AO allows users to choose which cryptographic
   algorithm(s) they want to use to meet their security needs.

   TCP-AO provides cryptographic authentication and message integrity
   verification between two end-points.  In order to accomplish this
   function, message authentication codes (MACs) are used, which then
   rely on shared keys.  There are various ways to create MACs.  The use
   of hash-based MACs (HMACs) is defined in [<a href="rfc2104.html" title='"HMAC: Keyed-Hashing for Message Authentication"'>RFC2104</a>].  The use of
   cipher-based MACs (CMACs) is defined in [<a href="#ref-NIST-SP800-38B">NIST-SP800-38B</a>].

   This RFC defines the general requirements for MACs used in TCP-AO,
   both for currently specified MACs and for any future specified MACs.
   It specifies two MAC algorithms required in all TCP-AO
   implementations.  It also specifies two key derivation functions
   (KDFs) used to create the traffic keys used by the MACs.  These KDFs
   are also required by all TCP-AO implementations.









<span class="grey">Lebovitz &amp; Rescorla          Standards Track                    [Page 2]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-3" id="page-3" name="page-3"> </a>
<span class="grey"><a href="rfc5926.html">RFC 5926</a>                    Crypto for TCP-AO                  June 2010</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/2.%20%20Requirements"></a><a class="selflink" href="#section-2" name="section-2">2</a>.  Requirements</span>

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/2.1.%20%20Requirements%20Language"></a><a class="selflink" href="#section-2.1" name="section-2.1">2.1</a>.  Requirements Language</span>

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in [<a href="rfc2119.html" title='"Key words for use in RFCs to Indicate Requirement Levels"'>RFC2119</a>].

   When used in lowercase, these words convey their typical use in
   common language, and they are not to be interpreted as described in
   [<a href="rfc2119.html" title='"Key words for use in RFCs to Indicate Requirement Levels"'>RFC2119</a>].

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/2.2.%20%20Algorithm%20Requirements"></a><a class="selflink" href="#section-2.2" name="section-2.2">2.2</a>.  Algorithm Requirements</span>

   This is the initial specification of required cryptography for
   TCP-AO, and indicates two MAC algorithms and two KDFs.  All four
   components MUST be implemented in order for the implementation to be
   fully compliant with this RFC.

   The following table indicates the required MAC algorithms and KDFs
   for TCP-AO:

           Requirement      Authentication Algorithm

           ------------     ------------------------

           MUST             HMAC-SHA-1-96 [<a href="rfc2104.html" title='"HMAC: Keyed-Hashing for Message Authentication"'>RFC2104</a>][FIPS-180-3]

           MUST             AES-128-CMAC-96 [<a href="#ref-NIST-SP800-38B">NIST-SP800-38B</a>][FIPS197]

           Requirement      Key Derivation Function (KDF)

           -------------    ------------------------

           MUST             KDF_HMAC_SHA1

           MUST             KDF_AES_128_CMAC

   For an explanation of why two MAC algorithms were mandated, see the
   <a href="#section-4">Section 4</a>.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/2.3.%20%20Requirements%20for%20Future%20MAC%20Algorithms"></a><a class="selflink" href="#section-2.3" name="section-2.3">2.3</a>.  Requirements for Future MAC Algorithms</span>

   TCP-AO is intended to support cryptographic agility.  As a result,
   this document includes recommendations in various places for future
   MAC and KDF algorithms when used for TCP-AO.  For future MAC
   algorithms specifically, they SHOULD protect at least 2**48 messages
   with a collision probability of less than one in 10**9.



<span class="grey">Lebovitz &amp; Rescorla          Standards Track                    [Page 3]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-4" id="page-4" name="page-4"> </a>
<span class="grey"><a href="rfc5926.html">RFC 5926</a>                    Crypto for TCP-AO                  June 2010</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/3.%20%20Algorithms%20Specified"></a><a class="selflink" href="#section-3" name="section-3">3</a>.  Algorithms Specified</span>

   TCP-AO requires two classes of cryptographic algorithms used on a
   particular connection, and refers to this document to define them
   both:

       (1)  Key Derivation Functions (KDFs), which name a pseudorandom
            function (PRF) and use a Master_Key and some connection-
            specific input with that PRF to produce Traffic_Keys, the
            keys suitable for authenticating and integrity checking
            individual TCP segments, as described in TCP-AO.

       (2)  Message Authentication Code (MAC) algorithms, which take a
            key and a message and produce an authentication tag that can
            be used to verify the integrity and authenticity of those
            messages.

   In TCP-AO, these algorithms are always used in pairs.  Each MAC
   algorithm MUST specify the KDF to be used with that MAC algorithm.
   However, a KDF MAY be used with more than one MAC algorithm.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.1.%20%20Key%20Derivation%20Functions%20%28KDFs%29"></a><a class="selflink" href="#section-3.1" name="section-3.1">3.1</a>.  Key Derivation Functions (KDFs)</span>

   TCP-AO's Traffic_Keys are derived using KDFs.  The KDFs used in TCP-
   AO's current manual keying have the following interface:

       Traffic_Key = KDF_alg(Master_Key, Context, Output_Length)

   where:

      - KDF_alg:     the specific pseudorandom function (PRF) that is
                     the basic building block used in constructing the
                     given Traffic_Key.

      - Master_Key:  In TCP-AO's manual key mode, this is a key shared
                     by both peers, entered via some interface to their
                     respective configurations.  The Master_Key is used
                     as the seed for the KDF.  We assume that this is a
                     human-readable pre-shared key (PSK); thus, we
                     assume it is of variable length.  Master_Keys
                     SHOULD be random, but might not be (e.g., badly
                     chosen by the user).  For interoperability, the
                     management interface by which the PSK is configured
                     MUST accept ASCII strings, and SHOULD also allow
                     for the configuration of any arbitrary binary
                     string in hexadecimal form.  Other configuration
                     methods MAY be supported.




<span class="grey">Lebovitz &amp; Rescorla          Standards Track                    [Page 4]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-5" id="page-5" name="page-5"> </a>
<span class="grey"><a href="rfc5926.html">RFC 5926</a>                    Crypto for TCP-AO                  June 2010</span>


      - Context:     A binary string containing information related to
                     the specific connection for this derived keying
                     material, as defined in <a href="rfc5925.html#section-5.2">[RFC5925], Section 5.2</a>.

      - Output_Length:  The length, in bits, of the key that the KDF
                        will produce.  This length must be the size
                        required for the MAC algorithm that will use the
                        PRF result as a seed.

   When invoked, a KDF generates a string of length Output_Length bits
   based on the Master_Key and context value.  This result may then be
   used as a cryptographic key for any algorithm that takes an
   Output_Length length key.  A KDF MAY specify a maximum Output_Length
   parameter.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/3.1.1.%20%20Concrete%20KDFs"></a><a class="selflink" href="#section-3.1.1" name="section-3.1.1">3.1.1</a>.  Concrete KDFs</span>

   This document defines two KDF algorithms, each paired with a
   corresponding PRF algorithm as explained below:

       *  KDF_HMAC_SHA1  based on PRF-HMAC-SHA1 [<a href="rfc2104.html" title='"HMAC: Keyed-Hashing for Message Authentication"'>RFC2104</a>][FIPS-180-3]

       *  KDF_AES_128_CMAC  based on AES-CMAC-PRF-128
                            [<a href="#ref-NIST-SP800-38B">NIST-SP800-38B</a>][FIPS197]

   Both of these KDFs are based on the iteration-mode KDFs specified in
   [<a href="#ref-NIST-SP800-108">NIST-SP800-108</a>].  This means that they use an underlying
   pseudorandom function (PRF) with a fixed-length output, 128 bits in
   the case of the AES-CMAC, and 160 bits in the case of HMAC-SHA1.  The
   KDF generates an arbitrary number of output bits by operating the PRF
   in a "counter mode", where each invocation of the PRF uses a
   different input block differentiated by a block counter.

   Each input block is constructed as follows:

        ( i || Label || Context || Output_Length )

      Where

      - "||":      For any X || Y, "||" represents a concatenation
                   operation of the binary strings X and Y.

      - i:         A counter, a binary string that is an input to each
                   iteration of the PRF in counter mode.  The counter
                   "i" is represented in a single octet.  The number of
                   iterations will depend on the specific size of the
                   Output_Length desired for a given MAC. "i" always
                   starts = 1.



<span class="grey">Lebovitz &amp; Rescorla          Standards Track                    [Page 5]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-6" id="page-6" name="page-6"> </a>
<span class="grey"><a href="rfc5926.html">RFC 5926</a>                    Crypto for TCP-AO                  June 2010</span>


      - Label:     A binary string that clearly identifies the purpose
                   of this KDF's derived keying material.  For TCP-AO,
                   we use the ASCII string "TCP-AO", where the last
                   character is the capital letter "O", not to be
                   confused with a zero.  While this may seem like
                   overkill in this specification since TCP-AO only
                   describes one call to the KDF, it is included in
                   order to comply with FIPS 140 certifications.

      - Context:   The context argument provided to the KDF interface,
                   as described above in <a href="#section-3.1">Section 3.1</a> .

      - Output_Length:  The length, in bits, of the key that the KDF
                        will produce.  The Output_length is represented
                        within two octets.  This length must be the size
                        required for the MAC algorithm that will use the
                        PRF result as a seed.

   The output of multiple PRF invocations is simply concatenated.  For
   the Traffic_Key, values of multiple PRF invocations are concatenated
   and truncated as needed to create a Traffic_Key of the desired
   length.  For instance, if one were using KDF_HMAC_SHA1, which uses a
   160-bit internal PRF to generate 320 bits of data, one would execute
   the PRF twice, once with i=1 and once with i=2.  The result would be
   the entire output of the first invocation concatenated with the
   second invocation.  For example,

  Traffic_Key =
          KDF_alg(Master_Key, 1 || Label || Context || Output_length) ||
          KDF_alg(Master_Key, 2 || Label || Context || Output_length)

   If the number of bits required is not an exact multiple of the output
   size of the PRF, then the output of the final invocation of the PRF
   is truncated as necessary.

<span class="h5"><a class="dashAnchor" name="//apple_ref/Section/3.1.1.1.%20%20KDF_HMAC_SHA1"></a><a class="selflink" href="#section-3.1.1.1" name="section-3.1.1.1">3.1.1.1</a>.  KDF_HMAC_SHA1</span>

   For KDF_HMAC_SHA1:

   - PRF for KDF_alg:  HMAC-SHA1 [<a href="rfc2104.html" title='"HMAC: Keyed-Hashing for Message Authentication"'>RFC2104</a>][FIPS-180-3].

   - Use:       HMAC-SHA1(Key, Input).

   - Key:       Master_Key, configured by user, and passed to the KDF.

   - Input:     ( i || Label || Context || Output_Length)

   - Output_Length:  160 bits.



<span class="grey">Lebovitz &amp; Rescorla          Standards Track                    [Page 6]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-7" id="page-7" name="page-7"> </a>
<span class="grey"><a href="rfc5926.html">RFC 5926</a>                    Crypto for TCP-AO                  June 2010</span>


   - Result:    Traffic_Key, used in the MAC function by TCP-AO.

<span class="h5"><a class="dashAnchor" name="//apple_ref/Section/3.1.1.2.%20%20KDF_AES_128_CMAC"></a><a class="selflink" href="#section-3.1.1.2" name="section-3.1.1.2">3.1.1.2</a>.  KDF_AES_128_CMAC</span>

   For KDF_AES_128_CMAC:

   - PRF for KDF_alg:  AES-CMAC-PRF-128 [<a href="#ref-NIST-SP800-38B">NIST-SP800-38B</a>][FIPS197].

   - Use:       AES-CMAC(Key, Input).

   - Key:       Master_Key (see usage below)

   - Input:     ( i || Label || Context || Output_Length)

   - Output_Length:  128 bits.

   - Result:    Traffic_Key, used in the MAC function by TCP-AO

   The Master_Key in TCP-AO's current manual keying mechanism is a
   shared secret, entered by an administrator.  It is passed via an out-
   of-band mechanism between two devices, and often between two
   organizations.  The shared secret does not have to be 16 octets, and
   the length may vary.  However, AES_128_CMAC requires a key of exactly
   16 octets (128 bits) in length.  We could mandate that
   implementations force administrators to input Master_Keys of exactly
   128-bit length when using AES_128_CMAC, and with sufficient
   randomness, but this places undue burden on the implementors and
   deployers.  This specification RECOMMENDS that deployers use a
   randomly generated 128-bit string as the Master_Key, but acknowledges
   that deployers may not.

   To handle variable length Master_Keys, we use the same mechanism as
   described in <a href="rfc4615.html#section-3">[RFC4615], Section 3</a>.  First, we use AES_128_CMAC with a
   fixed key of all zeros as a "randomness extractor", while using the
   shared secret Master_Key, MK, as the message input, to produce a 128-
   bit key Derived_Master_Key (K).  Second, we use the result as a key,
   and run AES-128_CMAC again, this time using the result K as the Key,
   and the true input block as the Input to yield the Traffic_Key (TK)
   used in the MAC over the message.  The description follows:












<span class="grey">Lebovitz &amp; Rescorla          Standards Track                    [Page 7]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-8" id="page-8" name="page-8"> </a>
<span class="grey"><a href="rfc5926.html">RFC 5926</a>                    Crypto for TCP-AO                  June 2010</span>


   +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
   +                        KDF-AES-128-CMAC                           +
   +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
   +                                                                   +
   + Input  : MK (Master_Key, the variable-length shared secret)       +
   +        : I (Input, i.e., the input data of the PRF)               +
   +        : MKlen (length of MK in octets)                           +
   +        : len (length of M in octets)                              +
   + Output : TK (Traffic_Key, 128-bit Pseudo-Random Variable)         +
   +                                                                   +
   +-------------------------------------------------------------------+
   + Variable: K (128-bit key for AES-CMAC)                            +
   +                                                                   +
   + Step 1.   If MKlen is equal to 16                                 +
   + Step 1a.  then                                                    +
   +               K := MK;                                            +
   + Step 1b.  else                                                    +
   +               K := AES-CMAC(0^128, MK, MKlen);                    +
   + Step 2.   TK := AES-CMAC(K, I, len);                              +
   +           return TK;                                              +
   +                                                                   +
   +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

                                 Figure 1

   In step 1, the 128-bit key, K, for AES-CMAC is derived as follows:

   o If the Master_Key, MK, provided by the administrator is exactly 128
   bits, then we use it as is.

   o If it is longer or shorter than 128 bits, then we derive the key K
   by applying the AES-CMAC algorithm using the 128-bit all-zero string
   as the key and MK as the input message.  This step is described in
   1b.

   In step 2, we apply the AES-CMAC algorithm again, this time using K
   as the key and I as the input message.

   The output of this algorithm returns TK, the Traffic_Key, which is
   128 bits and is suitable for use in the MAC function on each TCP
   segment of the connection.










<span class="grey">Lebovitz &amp; Rescorla          Standards Track                    [Page 8]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-9" id="page-9" name="page-9"> </a>
<span class="grey"><a href="rfc5926.html">RFC 5926</a>                    Crypto for TCP-AO                  June 2010</span>


<span class="h5"><a class="dashAnchor" name="//apple_ref/Section/3.1.1.3.%20%20Tips%20for%20User%20Interfaces%20Regarding%20KDFs"></a><a class="selflink" href="#section-3.1.1.3" name="section-3.1.1.3">3.1.1.3</a>.  Tips for User Interfaces Regarding KDFs</span>

   This section provides suggested representations for the KDFs in
   implementation user interfaces (UIs).  Following these guidelines
   across common implementations will make interoperability easier and
   simpler for deployers.

   UIs SHOULD refer to the choice of KDF_HMAC_SHA1 as simply "SHA1".

   UIs SHOULD refer to the choice of KDF_AES_128_CMAC as simply
   "AES128".

   The initial IANA registry values reflect these two entries.

   UIs SHOULD use KDF_HMAC_SHA1 as the default selection in TCP-AO
   settings.  KDF_HMAC_SHA1 is preferred at this time because it has
   wide support, being present in most implementations in the
   marketplace.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.2.%20%20MAC%20Algorithms"></a><a class="selflink" href="#section-3.2" name="section-3.2">3.2</a>.  MAC Algorithms</span>

   Each MAC_alg defined for TCP-AO has three fixed elements as part of
   its definition:

   - KDF_Alg:     Name of the TCP-AO KDF algorithm used to generate the
                  Traffic_Key.

   - Key_Length:  Length, in bits, required for the Traffic_Key used in
                  this MAC.

   - MAC_Length:  The final length of the bits used in the TCP-AO MAC
                  field.  This value may be a truncation of the MAC
                  function's original output length.

   MACs computed for TCP-AO have the following interface:

       MAC = MAC_alg(Traffic_Key, Message)

   where:

      - MAC_alg:     MAC Algorithm used.

      - Traffic_Key: Variable; the result of KDF.

      -  Message     The message to be authenticated, as specified in
                     <a href="rfc5925.html#section-5.1">[RFC5925], Section 5.1</a>.





<span class="grey">Lebovitz &amp; Rescorla          Standards Track                    [Page 9]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-10" id="page-10" name="page-10"> </a>
<span class="grey"><a href="rfc5926.html">RFC 5926</a>                    Crypto for TCP-AO                  June 2010</span>


   This document specifies two MAC algorithm options for generating the
   MAC as used by TCP-AO:

       *  HMAC-SHA-1-96  based on [<a href="rfc2104.html" title='"HMAC: Keyed-Hashing for Message Authentication"'>RFC2104</a>] and [<a href="#ref-FIPS-180-3" title='"Secured Hash Standard"'>FIPS-180-3</a>].

       *  AES-128-CMAC-96  based on [<a href="#ref-NIST-SP800-38B">NIST-SP800-38B</a>][FIPS197]

   Both provide a high level of security and efficiency.  The AES-128-
   CMAC-96 is potentially more efficient, particularly in hardware, but
   HMAC-SHA-1-96 is more widely used in Internet protocols and in most
   cases could be supported with little or no additional code in today's
   deployed software and devices.

   An important aspect to note about these algorithms' definitions for
   use in TCP-AO is the fact that the MAC outputs are truncated to 96
   bits.  AES-128-CMAC-96 produces a 128-bit MAC, and HMAC SHA-1
   produces a 160-bit result.  The MAC output is then truncated to 96
   bits to provide a reasonable trade-off between security and message
   size, for fitting into the TCP-AO option field.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/3.2.1.%20%20The%20Use%20of%20HMAC-SHA-1-96"></a><a class="selflink" href="#section-3.2.1" name="section-3.2.1">3.2.1</a>.  The Use of HMAC-SHA-1-96</span>

   By definition, HMAC [<a href="rfc2104.html" title='"HMAC: Keyed-Hashing for Message Authentication"'>RFC2104</a>] requires a cryptographic hash function.
   SHA1 will be that hash function used for authenticating and providing
   integrity validation on TCP segments with HMAC.

   The three fixed elements for HMAC-SHA-1-96 are:

   - KDF_Alg:     KDF_HMAC_SHA1.

   - Key_Length:  160 bits.

   - MAC_Length:  96 bits.

   For:

        MAC = MAC_alg (Traffic_Key, Message)

   HMAC-SHA-1-96 for TCP-AO has the following values:

      - MAC_alg:     HMAC-SHA1.

      - Traffic_Key: Variable; the result of the KDF.

      - Message:     The message to be authenticated, as specified in
                     <a href="rfc5925.html#section-5.1">[RFC5925], Section 5.1</a>.





<span class="grey">Lebovitz &amp; Rescorla          Standards Track                   [Page 10]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-11" id="page-11" name="page-11"> </a>
<span class="grey"><a href="rfc5926.html">RFC 5926</a>                    Crypto for TCP-AO                  June 2010</span>


<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/3.2.2.%20%20The%20Use%20of%20AES-128-CMAC-96"></a><a class="selflink" href="#section-3.2.2" name="section-3.2.2">3.2.2</a>.  The Use of AES-128-CMAC-96</span>

   In the context of TCP-AO, when we say "AES-128-CMAC-96", we actually
   define a usage of AES-128 as a cipher-based MAC according to
   [<a href="#ref-NIST-SP800-38B">NIST-SP800-38B</a>].

   The three fixed elements for AES-128-CMAC-96 are:

   - KDF_Alg:     KDF_AES_128_CMAC.

   - Key_Length:  128 bits.

   - MAC_Length:  96 bits.

   For:

        MAC = MAC_alg (Traffic_Key, Message)

   AES-128-CMAC-96 for TCP-AO has the following values:

      - MAC_alg:     AES-128-CMAC-96.  [<a href="#ref-NIST-SP800-38B">NIST-SP800-38B</a>]

      - Traffic_Key: Variable; the result of the KDF.

      - Message:     The message to be authenticated, as specified in
                     <a href="rfc5925.html#section-5.1">[RFC5925], Section 5.1</a>.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/4.%20%20Security%20Considerations"></a><a class="selflink" href="#section-4" name="section-4">4</a>.  Security Considerations</span>

   This document inherits all of the security considerations of the
   TCP-AO [<a href="rfc5925.html" title='"The TCP Authentication Option"'>RFC5925</a>], the AES-CMAC [<a href="rfc4493.html" title='"The AES-CMAC Algorithm"'>RFC4493</a>], and the HMAC-SHA-1
   [<a href="rfc2104.html" title='"HMAC: Keyed-Hashing for Message Authentication"'>RFC2104</a>] documents.

   The security of cryptography-based systems depends on both the
   strength of the cryptographic algorithms chosen and the strength of
   the keys used with those algorithms.  The security also depends on
   the engineering of the protocol used by the system to ensure that
   there are no non-cryptographic ways to bypass the security of the
   overall system.

   Care should also be taken to ensure that the selected key is
   unpredictable, avoiding any keys known to be weak for the algorithm
   in use.  [<a href="rfc4086.html" title='"Randomness Requirements for Security"'>RFC4086</a>] contains helpful information on both key
   generation techniques and cryptographic randomness.

   Note that in the composition of KDF_AES_128_CMAC, the PRF needs a
   128-bit / 16-byte key as the seed.  However, for convenience to the
   administrators/deployers, we did not want to force them to enter a



<span class="grey">Lebovitz &amp; Rescorla          Standards Track                   [Page 11]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-12" id="page-12" name="page-12"> </a>
<span class="grey"><a href="rfc5926.html">RFC 5926</a>                    Crypto for TCP-AO                  June 2010</span>


   16-byte Master_Key.  So we specified the sub-key routine that could
   handle a variable length Master_Key, one that might be less than 16
   bytes.  This does NOT mean that it is safe for administrators to use
   weak keys.  Administrators are encouraged to follow [<a href="rfc4086.html" title='"Randomness Requirements for Security"'>RFC4086</a>] as
   listed above.  We simply attempted to "put a fence around
   foolishness", as much as possible.

   This document concerns itself with the selection of cryptographic
   algorithms for the use of TCP-AO.  The algorithms identified in this
   document as "MUST implement" are not known to be broken at the
   current time, and cryptographic research so far leads us to believe
   that they will likely remain secure into the foreseeable future.
   Some of the algorithms may be found in the future to have properties
   significantly weaker than those that were believed at the time this
   document was produced.  Expect that new revisions of this document
   will be issued from time to time.  Be sure to search for more recent
   versions of this document before implementing.

   NOTE EXPLAINING WHY TWO MAC ALGORITHMS WERE MANDATED:

   Two MAC algorithms and two corresponding KDFs are mandated as a
   result of discussion in the TCPM WG, and in consultation with the
   Security Area Directors.  SHA-1 was selected because it is widely
   deployed and currently has sufficient strength and reasonable
   computational cost, so it is a "MUST" for TCP-AO today.  The security
   strength of SHA-1 HMACs should be sufficient for the foreseeable
   future, especially given that the tags are truncated to 96 bits.

   Recently exposed vulnerabilities in other MACs (e.g., MD5 or HMAC
   MD5) aren't practical on HMAC-SHA-1, but these types of analyses are
   mounting and could potentially pose a concern for HMAC forgery if
   they were significantly improved, over time.  The security issues
   driving the migration from SHA-1 to SHA-256 for digital signatures
   [<a href="#ref-HMAC-ATTACK" title='"On the Security of HMAC and NMAC Based on HAVAL, MD4, MD5, SHA-0 and SHA-1"'>HMAC-ATTACK</a>] do not immediately render SHA-1 weak for this
   application of SHA-1 in HMAC mode.

   AES-128 CMAC is considered to be a stronger algorithm than SHA-1, but
   may not yet have very wide implementation.  AES-128 CMAC is also a
   "MUST" to implement, in order to drive vendors toward its use, and to
   allow for another MAC option, if SHA-1 were to be compromised.











<span class="grey">Lebovitz &amp; Rescorla          Standards Track                   [Page 12]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-13" id="page-13" name="page-13"> </a>
<span class="grey"><a href="rfc5926.html">RFC 5926</a>                    Crypto for TCP-AO                  June 2010</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/5.%20%20IANA%20Considerations"></a><a class="selflink" href="#section-5" name="section-5">5</a>.  IANA Considerations</span>

   IANA has created the following registry (<a href="http://www.iana.org/">http://www.iana.org</a>).

   Registry Name: Cryptographic Algorithms for TCP-AO Registration
   Procedure: RFC Publication after Expert Review

   Initial contents of this registry are:

         Algorithm      | Reference
        ----------------|-----------
         SHA1           | [<a href="rfc5926.html">RFC5926</a>]
         AES128         | [<a href="rfc5926.html">RFC5926</a>]

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/6.%20%20Acknowledgements"></a><a class="selflink" href="#section-6" name="section-6">6</a>.  Acknowledgements</span>

   Eric "EKR" Rescorla, who provided a ton of input and feedback,
   including a somewhat heavy re-write of <a href="#section-3.1">Section 3.1</a>.x, earning him an
   author slot on the document.

   Paul Hoffman, from whose [<a href="rfc4308.html" title='"Cryptographic Suites for IPsec"'>RFC4308</a>] I sometimes copied, to quickly
   create a first version here.

   Tim Polk, whose email summarizing SAAG's guidance to TCPM on the two
   hash algorithms for TCP-AO is largely cut-and-pasted into various
   sections of this document.

   Jeff Schiller, Donald Eastlake, and the IPsec WG, whose [<a href="rfc4307.html" title='"Cryptographic Algorithms for Use in the Internet Key Exchange Version 2 (IKEv2)"'>RFC4307</a>] &amp;
   [<a href="rfc4835.html" title='"Cryptographic Algorithm Implementation Requirements for Encapsulating Security Payload (ESP) and Authentication Header (AH)"'>RFC4835</a>] text was consulted and sometimes used in the Requirements
   <a href="#section-2">Section 2</a> of this document.

   (In other words, I was truly only an editor of others' text in
   creating this document.)

   Eric "EKR" Rescorla and Brian Weis, who brought to clarity the issues
   with the inputs to PRFs for the KDFs.  EKR was also of great
   assistance in how to structure the text, as well as helping to guide
   good cryptographic decisions.

   The TCPM working group, who put up with all us crypto and routing
   folks DoS'ing their WG for 2 years, and who provided reviews of this
   document.









<span class="grey">Lebovitz &amp; Rescorla          Standards Track                   [Page 13]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-14" id="page-14" name="page-14"> </a>
<span class="grey"><a href="rfc5926.html">RFC 5926</a>                    Crypto for TCP-AO                  June 2010</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/7.%20%20References"></a><a class="selflink" href="#section-7" name="section-7">7</a>.  References</span>

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/7.1.%20%20Normative%20References"></a><a class="selflink" href="#section-7.1" name="section-7.1">7.1</a>.  Normative References</span>

   [<a id="ref-FIPS-180-3" name="ref-FIPS-180-3">FIPS-180-3</a>]  FIPS Publication 180-3, "Secured Hash Standard",
                 FIPS 180-3, October 2008.

   [<a id="ref-FIPS197" name="ref-FIPS197">FIPS197</a>]     FIPS Publications 197, "Advanced Encryption Standard
                 (AES)", FIPS 197, November 2001.

   [<a id="ref-NIST-SP800-108" name="ref-NIST-SP800-108">NIST-SP800-108</a>]
                 National Institute of Standards and Technology,
                 "Recommendation for Key Derivation Using Pseudorandom
                 Functions, NIST SP800-108", SP 800- 108, October 2009.

   [<a id="ref-NIST-SP800-38B" name="ref-NIST-SP800-38B">NIST-SP800-38B</a>]
                 National Institute of Standards and Technology,
                 "Recommendation for Block Cipher Modes of Operation:
                 The CMAC Mode for Authentication", SP 800-38B,
                 May 2005.

   [<a id="ref-RFC2104" name="ref-RFC2104">RFC2104</a>]     Krawczyk, H., Bellare, M., and R. Canetti, "HMAC:
                 Keyed-Hashing for Message Authentication", <a href="rfc2104.html">RFC 2104</a>,
                 February 1997.

   [<a id="ref-RFC2119" name="ref-RFC2119">RFC2119</a>]     Bradner, S., "Key words for use in RFCs to Indicate
                 Requirement Levels", <a href="http://tools.ietf.org/html/bcp14">BCP 14</a>, <a href="rfc2119.html">RFC 2119</a>, March 1997.

   [<a id="ref-RFC4493" name="ref-RFC4493">RFC4493</a>]     Song, JH., Poovendran, R., Lee, J., and T. Iwata, "The
                 AES-CMAC Algorithm", <a href="rfc4493.html">RFC 4493</a>, June 2006.

   [<a id="ref-RFC5925" name="ref-RFC5925">RFC5925</a>]     Touch, J., Mankin, A., and R. Bonica, "The TCP
                 Authentication Option", <a href="rfc5925.html">RFC 5925</a>, June 2010.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/7.2.%20%20Informative%20References"></a><a class="selflink" href="#section-7.2" name="section-7.2">7.2</a>.  Informative References</span>

   [<a id="ref-HMAC-ATTACK" name="ref-HMAC-ATTACK">HMAC-ATTACK</a>] "On the Security of HMAC and NMAC Based on HAVAL, MD4,
                 MD5, SHA-0 and SHA-1", &lt;<a href="http://www.springerlink.com/content/00w4v62651001303">http://</a>
                 <a href="http://www.springerlink.com/content/00w4v62651001303">www.springerlink.com/content/00w4v62651001303</a>&gt; , 2006,
                 &lt;<a href="http://eprint.iacr.org/2006/187">http://eprint.iacr.org/2006/187</a>&gt;.

   [<a id="ref-RFC4086" name="ref-RFC4086">RFC4086</a>]     Eastlake, D., Schiller, J., and S. Crocker, "Randomness
                 Requirements for Security", <a href="http://tools.ietf.org/html/bcp106">BCP 106</a>, <a href="rfc4086.html">RFC 4086</a>,
                 June 2005.







<span class="grey">Lebovitz &amp; Rescorla          Standards Track                   [Page 14]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-15" id="page-15" name="page-15"> </a>
<span class="grey"><a href="rfc5926.html">RFC 5926</a>                    Crypto for TCP-AO                  June 2010</span>


   [<a id="ref-RFC4307" name="ref-RFC4307">RFC4307</a>]     Schiller, J., "Cryptographic Algorithms for Use in the
                 Internet Key Exchange Version 2 (IKEv2)", <a href="rfc4307.html">RFC 4307</a>,
                 December 2005.

   [<a id="ref-RFC4308" name="ref-RFC4308">RFC4308</a>]     Hoffman, P., "Cryptographic Suites for IPsec",
                 <a href="rfc4308.html">RFC 4308</a>, December 2005.

   [<a id="ref-RFC4615" name="ref-RFC4615">RFC4615</a>]     Song, J., Poovendran, R., Lee, J., and T. Iwata, "The
                 Advanced Encryption Standard-Cipher-based Message
                 Authentication Code-Pseudo-Random Function-128
                 (AES-CMAC-PRF-128) Algorithm for the Internet Key
                 Exchange Protocol (IKE)", <a href="rfc4615.html">RFC 4615</a>, August 2006.

   [<a id="ref-RFC4835" name="ref-RFC4835">RFC4835</a>]     Manral, V., "Cryptographic Algorithm Implementation
                 Requirements for Encapsulating Security Payload (ESP)
                 and Authentication Header (AH)", <a href="rfc4835.html">RFC 4835</a>, April 2007.

Authors' Addresses

   Gregory Lebovitz
   Juniper Networks, Inc.
   1194 North Mathilda Ave.
   Sunnyvale, CA  94089-1206
   US

   Phone:
   EMail: gregory.ietf@gmail.com


   Eric Rescorla
   RTFM, Inc.
   2064 Edgewood Drive
   Palo Alto, CA  94303
   US

   Phone: 650-678-2350
   EMail: ekr@rtfm.com














Lebovitz &amp; Rescorla          Standards Track                   [Page 15]

</pre><br/>
<span class="noprint"><small><small>Html markup produced by rfcmarkup 1.106, available from
<a href="http://tools.ietf.org/tools/rfcmarkup/">http://tools.ietf.org/tools/rfcmarkup/</a>
</small></small></span>


<meta content="text/html;charset=utf-8" http-equiv="content-type"/><!-- /Added by HTTrack -->

</body><!-- Mirrored from tools.ietf.org/html/rfc5926 by HTTrack Website Copier/3.x [XR&CO'2010], Wed, 19 Mar 2014 18:35:31 GMT --><!-- Added by HTTrack --></html>