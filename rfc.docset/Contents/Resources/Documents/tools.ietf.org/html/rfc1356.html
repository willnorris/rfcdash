<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head profile="http://dublincore.org/documents/2008/08/04/dc-html/">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="robots" content="index,follow" />
    <meta name="creator" content="rfcmarkup version 1.107" />
    <link rel="schema.DC" href="http://purl.org/dc/elements/1.1/" />
<meta name="DC.Relation.Replaces" content="rfc877" />
<meta name="DC.Identifier" content="urn:ietf:rfc:1356" />
<meta name="DC.Date.Issued" content="August, 1992" />
<meta name="DC.Creator" content="Ullmann, R." />
<meta name="DC.Creator" content="Robinson, D." />
<meta name="DC.Creator" content="Malis, A." />
<meta name="DC.Description.Abstract" content="This document specifies the encapsulation of IP and other network\nlayer protocols over X.25 networks, in accordance and alignment with\nISO/IEC and CCITT standards. It is a replacement for RFC 877, &quot;A\nStandard for the Transmission of IP Datagrams Over Public Data\nNetworks&quot; [1]. [STANDARDS-TRACK]" />
<meta name="DC.Title" content="Multiprotocol Interconnect on X.25 and ISDN in the Packet Mode" />

    <link rel="icon" href="http://tools.ietf.org/images/rfc.png" type="image/png" />
    <link rel="shortcut icon" href="http://tools.ietf.org/images/rfc.png" type="image/png" />
    <title>RFC 1356 - Multiprotocol Interconnect on X.25 and ISDN in the Packet Mode</title>
    
    
    <style type="text/css">
	body {
	    margin: 0px 8px;
            font-size: 1em;
	}
        h1, h2, h3, h4, h5, h6, .h1, .h2, .h3, .h4, .h5, .h6 {
	    font-weight: bold;
            line-height: 0pt;
            display: inline;
            white-space: pre;
            font-family: monospace;
            font-size: 1em;
	    font-weight: bold;
        }
        pre {
            font-size: 1em;
            margin-top: 0px;
            margin-bottom: 0px;
        }
	.pre {
	    white-space: pre;
	    font-family: monospace;
	}
	.header{
	    font-weight: bold;
	}
        .newpage {
            page-break-before: always;
        }
        .invisible {
            text-decoration: none;
            color: white;
        }
        a.selflink {
          color: black;
          text-decoration: none;
        }
        @media print {
            body {
                font-family: monospace;
                font-size: 10.5pt;
            }
            h1, h2, h3, h4, h5, h6 {
                font-size: 1em;
            }
        
            a:link, a:visited {
                color: inherit;
                text-decoration: none;
            }
            .noprint {
                display: none;
            }
        }
	@media screen {
	    .grey, .grey a:link, .grey a:visited {
		color: #777;
	    }
            .docinfo {
                background-color: #EEE;
            }
            .top {
                border-top: 7px solid #EEE;
            }
            .bgwhite  { background-color: white; }
            .bgred    { background-color: #F44; }
            .bggrey   { background-color: #666; }
            .bgbrown  { background-color: #840; }            
            .bgorange { background-color: #FA0; }
            .bgyellow { background-color: #EE0; }
            .bgmagenta{ background-color: #F4F; }
            .bgblue   { background-color: #66F; }
            .bgcyan   { background-color: #4DD; }
            .bggreen  { background-color: #4F4; }

            .legend   { font-size: 90%; }
            .cplate   { font-size: 70%; border: solid grey 1px; }
	}
    </style>
    <!--[if IE]>
    <style>
    body {
       font-size: 13px;
       margin: 10px 10px;
    }
    </style>
    <![endif]-->

    <script type="text/javascript"><!--
    function addHeaderTags() {
	var spans = document.getElementsByTagName("span");
	for (var i=0; i < spans.length; i++) {
	    var elem = spans[i];
	    if (elem) {
		var level = elem.getAttribute("class");
                if (level == "h1" || level == "h2" || level == "h3" || level == "h4" || level == "h5" || level == "h6") {
                    elem.innerHTML = "<"+level+">"+elem.innerHTML+"</"+level+">";		
                }
	    }
	}
    }
    var legend_html = "Colour legend:<br />      <table>         <tr><td>Unknown:</td>                   <td><span class='cplate bgwhite'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft:</td>                     <td><span class='cplate bgred'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Informational:</td>             <td><span class='cplate bgorange'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Experimental:</td>              <td><span class='cplate bgyellow'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Best Common Practice:</td>      <td><span class='cplate bgmagenta'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Proposed Standard:</td>         <td><span class='cplate bgblue'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft Standard (old designation):</td> <td><span class='cplate bgcyan'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Internet Standard:</td>         <td><span class='cplate bggreen'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Historic:</td>                  <td><span class='cplate bggrey'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Obsolete:</td>                  <td><span class='cplate bgbrown'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>     </table>";
    function showElem(id) {
        var elem = document.getElementById(id);
        elem.innerHTML = eval(id+"_html");
        elem.style.visibility='visible';
    }
    function hideElem(id) {
        var elem = document.getElementById(id);
        elem.style.visibility='hidden';        
        elem.innerHTML = "";
    }
    // -->
    </script>
</head>
<body onload="addHeaderTags()">
   <div style="height: 13px;">
      <div onmouseover="this.style.cursor='pointer';"
         onclick="showElem('legend');"
         onmouseout="hideElem('legend')"
	 style="height: 6px; position: absolute;"
         class="pre noprint docinfo bgcyan"
         title="Click for colour legend." >                                                                        </div>
      <div id="legend"
           class="docinfo noprint pre legend"
           style="position:absolute; top: 4px; left: 4ex; visibility:hidden; background-color: white; padding: 4px 9px 5px 7px; border: solid #345 1px; "
           onmouseover="showElem('legend');"
           onmouseout="hideElem('legend');">
      </div>
   </div>
<span class="pre noprint docinfo top">[<a href="index.html" title="Document search and retrieval page">Docs</a>] [<a href="http://tools.ietf.org/rfc/rfc1356.txt" title="Plaintext version of this document">txt</a>|<a href="http://tools.ietf.org/pdf/rfc1356" title="PDF version of this document">pdf</a>] [<a href="http://tools.ietf.org/html/draft-ietf-iplpdn-x25_isdn" title="draft-ietf-iplpdn-x25_isdn">draft-ietf-iplpdn...</a>] [<a href="http://tools.ietf.org/rfcdiff?difftype=--hwdiff&amp;url2=rfc1356" title="Inline diff (wdiff)">Diff1</a>] [<a href="http://tools.ietf.org/rfcdiff?url2=rfc1356" title="Side-by-side diff">Diff2</a>]                 </span><br />
<span class="pre noprint docinfo">                                                                        </span><br />
<span class="pre noprint docinfo">                                                          DRAFT STANDARD</span><br />
<span class="pre noprint docinfo">                                                                        </span><br />
<pre>
Network Working Group                                           A. Malis
Request for Comments: 1356                            BBN Communications
Obsoletes: RFC <a href="rfc877.html">877</a>                                           D. Robinson
                                      Computervision Systems Integration
                                                              R. Ullmann
                                            Process Software Corporation
                                                             August 1992


                       <span class="h1">Multiprotocol Interconnect</span>
                  <span class="h1">on X.25 and ISDN in the Packet Mode</span>

Status of this Memo

   This RFC specifies an IAB standards track protocol for the Internet
   community, and requests discussion and suggestions for improvements.
   Please refer to the current edition of the "IAB Official Protocol
   Standards" for the standardization state and status of this protocol.
   Distribution of this memo is unlimited.

Abstract

   This document specifies the encapsulation of IP and other network
   layer protocols over X.25 networks, in accordance and alignment with
   ISO/IEC and CCITT standards.  It is a replacement for <a href="rfc877.html">RFC 877</a>, "A
   Standard for the Transmission of IP Datagrams Over Public Data
   Networks" [<a href="#ref-1" title="&quot;A Standard for the Transmission of IP Datagrams Over Public Data Networks&quot;">1</a>].

   It was written to correct several ambiguities in the Internet
   Standard for IP/X.25 (<a href="rfc877.html">RFC 877</a>), to align it with ISO/IEC standards
   that have been written following <a href="rfc877.html">RFC 877</a>, to allow interoperable
   multiprotocol operation between routers and bridges over X.25, and to
   add some additional remarks based upon practical experience with the
   specification over the 8 years since that RFC.

   The substantive change to the IP encapsulation is an increase in the
   allowed IP datagram Maximum Transmission Unit from 576 to 1600, to
   reflect existing practice.

   This document also specifies the Internet encapsulation for
   protocols, including IP, on the packet mode of the ISDN.  It applies
   to the use of Internet protocols on the ISDN in the circuit mode only
   when the circuit is established as an end-to-end X.25 connection.








<span class="grey">Malis, Robinson, &amp; Ullmann                                      [Page 1]</span>
</pre><!--NewPage--><pre class='newpage'><a name="page-2" id="page-2" href="#page-2" class="invisible"> </a>
<span class="grey"><a href="rfc1356.html">RFC 1356</a>           Multiprotocol Interconnect on X.25        August 1992</span>


Acknowledgements

   <a href="rfc877.html">RFC 877</a> was written by J. T. Korb of Purdue University, and this
   document follows that RFC's format and builds upon its text as
   appropriate.  This document was produced under the auspices of the IP
   over Large Public Data Networks Working Group of the IETF.

<span class="h2"><a class="selflink" name="section-1" href="#section-1">1</a>. Conventions</span>

   The following language conventions are used in the items of
   specification in this document:

   o MUST -- the item is an absolute requirement of the specification.
     MUST is only used where it is actually required for interoperation,
     not to try to impose a particular method on implementors where not
     required for interoperability.

   o SHOULD -- the item should be followed for all but exceptional
     circumstances.

   o MAY or optional -- the item is truly optional and may be followed
     or ignored according to the needs of the implementor.

   The words "should" and "may" are also used, in lower case, in their
   more ordinary senses.

<span class="h2"><a class="selflink" name="section-2" href="#section-2">2</a>. Introduction</span>

   <a href="rfc877.html">RFC 877</a> was written to document the method CSNET and the VAN Gateway
   had adopted to transmit IP datagrams over X.25 networks.  Its success
   is evident in its current wide use and the inclusion of its IP
   protocol identifier in ISO/IEC TR 9577, "Protocol Identification in
   the Network Layer" [<a href="#ref-2" title="Information technology - Telecommunications and Information exchange between systems - Protocol Identification in the network layer">2</a>], which is administered by ISO/IEC and CCITT.

   However, due to changes in the scope of X.25 and the protocols that
   it can carry, several inadequacies have become evident in the RFC,
   especially in the areas of IP datagram Maximum Transmission Unit
   (MTU) size, X.25 maximum data packet size, virtual circuit
   management, and the interoperable encapsulation, over X.25, of
   protocols other than IP between multiprotocol routers and bridges.

   As with <a href="rfc877.html">RFC 877</a>, one or more X.25 virtual circuits are opened on
   demand when datagrams arrive at the network interface for
   transmission.  A virtual circuit is closed after some period of
   inactivity (the length of the period depends on the cost associated
   with an open virtual circuit).  A virtual circuit may also be closed
   if the interface runs out of virtual circuits.




<span class="grey">Malis, Robinson, &amp; Ullmann                                      [Page 2]</span>
</pre><!--NewPage--><pre class='newpage'><a name="page-3" id="page-3" href="#page-3" class="invisible"> </a>
<span class="grey"><a href="rfc1356.html">RFC 1356</a>           Multiprotocol Interconnect on X.25        August 1992</span>


<span class="h2"><a class="selflink" name="section-3" href="#section-3">3</a>. Standards</span>

<span class="h3"><a class="selflink" name="section-3.1" href="#section-3.1">3.1</a> Protocol Data Units (PDUs) are sent as X.25 "complete packet</span>
<span class="h3">    sequences".  That is, PDUs begin on X.25 data packet boundaries and</span>
    the M bit ("more data") is used to fragment PDUs that are larger
    than one X.25 data packet in length.

    In the IP encapsulation the PDU is the IP datagram.

<span class="h3"><a class="selflink" name="section-3.2" href="#section-3.2">3.2</a> The first octet in the Call User Data (CUD) Field (the first data</span>
<span class="h3">    octet in the Call Request packet) is used for protocol</span>
    demultiplexing, in accordance with the Subsequent Protocol
    Identifier (SPI) in ISO/IEC TR 9577.  This field contains a one-
    octet Network Layer Protocol Identifier (NLPID), which identifies
    the network layer protocol encapsulated over the X.25 virtual
    circuit.  The CUD field MAY contain more than one octet of
    information, and receivers MUST ignore all extraneous octets in the
    field.

    In the following discussion, the most significant digit of the
    binary numbers is left-most.

    For the Internet community, the NLPID has four relevant values:

    The value hex CC (binary 11001100, decimal 204) is IP [<a href="#ref-6" title="&quot;Internet Protocol - DARPA Internet Program Protocol Specification&quot;">6</a>].
    Conformance with this specification requires that IP be supported.
    See <a href="#section-5.1">section 5.1</a> for a diagram of the packet formats.

    The value hex 81 (binary 10000001, decimal 129) identifies ISO/IEC
    8473 (CLNP) [<a href="#ref-4" title="Information processing systems - Data communications - Protocol for providing the connectionless- mode network service">4</a>].  ISO/IEC TR 9577 specifically allows other ISO/IEC
    connectionless-protocol packets, such as ES-IS and IS-IS, to also be
    carried on the same virtual circuit as CLNP.  Conformance with this
    specification does not require that CLNP be supported.  See <a href="#section-5.2">section</a>
    <a href="#section-5.2">5.2</a> for a diagram of the packet formats.

    The value hex 82 (binary 10000010, decimal 130) is used specifically
    for ISO/IEC 9542 (ES-IS) [<a href="#ref-5" title="Information processing systems - Telecommunications and information exchange between systems - End system to intermediate system routeing protocol for use in conjunction with the protocol for providing the connectionless- mode network service (ISO/IEC 8473)">5</a>].  If there is already a circuit open to
    carry CLNP, then it is not necessary to open a second circuit to
    carry ES-IS.  Conformance with this specification does not require
    that ES-IS be supported.

    The value hex 80 (binary 10000000, decimal 128) identifies the use
    of IEEE Subnetwork Access Protocol (SNAP) [<a href="#ref-3" title="&quot;IEEE Standard for Local and Metropolitan Area Networks: Overview and Architecture&quot;">3</a>] to further encapsulate
    and identify a single network-layer protocol.  The SNAP-encapsulated
    protocol is identified by including a five-octet SNAP header in the
    Call Request CUD field immediately following the hex 80 octet.  SNAP
    headers are not included in the subsequent X.25 data packets.  Only
    one SNAP-encapsulated protocol may be carried over a virtual circuit



<span class="grey">Malis, Robinson, &amp; Ullmann                                      [Page 3]</span>
</pre><!--NewPage--><pre class='newpage'><a name="page-4" id="page-4" href="#page-4" class="invisible"> </a>
<span class="grey"><a href="rfc1356.html">RFC 1356</a>           Multiprotocol Interconnect on X.25        August 1992</span>


    opened using this encoding.  The receiver SHOULD accept the incoming
    call only if it can support the particular SNAP-identified protocol.
    Conformance with this specification does not require that this SNAP
    encoding be supported.  See <a href="#section-5.3">section 5.3</a> for a diagram of the packet
    formats.

    The value hex 00 (binary 00000000, decimal 0) identifies the Null
    encapsulation, used to multiplex multiple network layer protocols
    over the same circuit.  This encoding is further discussed in
    <a href="#section-3.3">section 3.3</a> below.

    The "Assigned Numbers" RFC [<a href="#ref-7" title="&quot;Assigned Numbers&quot;">7</a>] contains one other non-CCITT and
    non-ISO/IEC value that has been in active use for Internet X.25
    encapsulation identification, namely hex C5 (binary 11000101,
    decimal 197) for Blacker X.25.  This value MAY continue to be used,
    but only by prior preconfiguration of the sending and receiving X.25
    interfaces to support this value.  The value hex CD (binary
    11001101, decimal 205), listed in "Assigned Numbers" for "ISO-IP",
    is also used by Blacker and also can only be used by prior
    preconfiguration of the sending and receiving X.25 interfaces.

    Each system MUST only accept calls for protocols it can process;
    every Internet system MUST be able to accept the CC encapsulation
    for IP datagrams.  A system MUST NOT accept calls, and then
    immediately clear them.  Accepting the call indicates to the calling
    system that the protocol encapsulation is supported; on some
    networks, a call accepted and cleared is charged, while a call
    cleared in the request state is not charged.

    Systems that support NLPIDs other than hex CC (for IP) SHOULD allow
    their use to be configured on a per-peer address basis.  The use of
    hex CC (for IP) MUST always be allowed between peers and cannot be
    configured.

<span class="h3"><a class="selflink" name="section-3.3" href="#section-3.3">3.3</a> The NLPID encodings discussed in <a href="#section-3.2">section 3.2</a> only allow a single</span>
<span class="h3">    network layer protocol to be sent over a circuit.  The Null</span>
    encapsulation, identified by a NLPID encoding of hex 00, is used in
    order to multiplex multiple network layer protocols over one
    circuit.

    When the Null encapsulation is used, each X.25 complete packet
    sequence sent on the circuit begins with a one-octet NLPID, which
    identifies the network layer protocol data unit contained only in
    that particular complete packet sequence.  Further, if the SNAP
    NLPID (hex 80) is used, then the NLPID octet is immediately followed
    by the five-octet SNAP header, which is then immediately followed by
    the encapsulated PDU.  The encapsulated network layer protocol MAY
    differ from one complete packet sequence to the next over the same



<span class="grey">Malis, Robinson, &amp; Ullmann                                      [Page 4]</span>
</pre><!--NewPage--><pre class='newpage'><a name="page-5" id="page-5" href="#page-5" class="invisible"> </a>
<span class="grey"><a href="rfc1356.html">RFC 1356</a>           Multiprotocol Interconnect on X.25        August 1992</span>


    circuit.

    When a receiver is presented with an Incoming Call identifying the
    Null encapsulation, the receiver MUST accept the call if it supports
    the Null encapsulation for any network layer protocol.  The receiver
    MAY then silently discard a multiplexed PDU if it cannot support
    that particular encapsulated protocol.  See <a href="#section-5.4">section 5.4</a> for a
    diagram of the packet formats.

    Use of the single network layer protocol circuits described in
    <a href="#section-3.2">section 3.2</a> is more efficient in terms of bandwidth if only a
    limited number of protocols are supported by a system.  It also
    allows each system to determine exactly which protocols are
    supported by its communicating partner.  Other advantages include
    being able to use X.25 accounting to detail each protocol and
    different quality of service or flow control windows for different
    protocols.

    The Null encapsulation, for multiplexing, is useful when a system,
    for any reason (such as implementation restrictions or network cost
    considerations), may only open a limited number of virtual circuits
    simultaneously.  This is the method most likely to be used by a
    multiprotocol router, to avoid using an unreasonable number of
    virtual circuits.

    If performing IEEE 802.1d bridging across X.25 is desired, then the
    Null encapsulation MUST be used.  See <a href="#section-4.2">section 4.2</a> for a further
    discussion.

    Conformance with this specification does not require that the Null
    encapsulation be supported.

    Systems that support the Null encapsulation SHOULD allow its use to
    be configured on a per-peer address basis.

<span class="h3"><a class="selflink" name="section-3.4" href="#section-3.4">3.4</a> For compatibility with existing practice, and <a href="rfc877.html">RFC 877</a> systems, IP</span>
<span class="h3">    datagrams MUST, by default, be encapsulated on a virtual circuit</span>
    opened with the CC CUD.

    Implementations MAY also support up to three other possible
    encapsulations of IP:

   o IP may be contained in multiplexed data packets on a circuit using
     the Null (multiplexed) encapsulation.  Such data packets are
     identified by a NLPID of hex CC.

   o IP may be encapsulated within the SNAP encapsulation on a circuit.
     This encapsulation is identified by containing, in the 5-octet SNAP



<span class="grey">Malis, Robinson, &amp; Ullmann                                      [Page 5]</span>
</pre><!--NewPage--><pre class='newpage'><a name="page-6" id="page-6" href="#page-6" class="invisible"> </a>
<span class="grey"><a href="rfc1356.html">RFC 1356</a>           Multiprotocol Interconnect on X.25        August 1992</span>


     header, an Organizationally Unique Identifier (OUI) of hex 00-00-00
     and Protocol Identifier (PID) of hex 08-00.

   o On a circuit using the Null encapsulation, IP may be contained
     within the SNAP encapsulation of IP in multiplexed data packets.

    If an implementation supports the SNAP, multiplexed, and/or
    multiplexed SNAP encapsulations, then it MUST accept the encoding of
    IP within the supported encapsulation(s), MAY send IP using those
    encapsulation(s), and MUST allow the IP encapsulation to send to be
    configured on a per-peer address basis.

<span class="h3"><a class="selflink" name="section-3.5" href="#section-3.5">3.5</a> The negotiable facilities of X.25 MAY be used (e.g., packet and</span>
<span class="h3">    window size negotiation).  Since PDUs are sent as complete packet</span>
    sequences, any maximum X.25 data packet size MAY be configured or
    negotiated between systems and their network service providers.  See
    <a href="#section-4.5">section 4.5</a> for a discussion of maximum X.25 data packet size and
    network performance.

    There is no implied relationship between PDU size and X.25 packet
    size (i.e., the method of setting IP MTU based on X.25 packet size
    in <a href="rfc877.html">RFC 877</a> is not used).

<span class="h3"><a class="selflink" name="section-3.6" href="#section-3.6">3.6</a> Every system MUST be able to receive and transmit PDUs up to at</span>
<span class="h3">    least 1600 octets in length.</span>

    For compatibility with existing practice, as well as
    interoperability with <a href="rfc877.html">RFC 877</a> systems, the default transmit MTU for
    IP datagrams SHOULD default to 1500, and MUST be configurable in at
    least the range 576 to 1600.

    This is done with a view toward a standard default IP MTU of 1500,
    used on both local and wide area networks with no fragmentation at
    routers. Actually redefining the IP default MTU is, of course,
    outside the scope of this specification.

    The PDU size (e.g., IP MTU) MUST be configurable, on at least a
    per-interface basis.  The maximum transmitted PDU length SHOULD be
    configurable on a per-peer basis, and MAY be configurable on a per-
    encapsulation basis as well.  Note that the ability to configure to
    send IP datagrams with an MTU of 576 octets and to receive IP
    datagrams of 1600 octets is essential to interoperate with existing
    implementations of <a href="rfc877.html">RFC 877</a> and implementations of this
    specification.

    Note that on circuits using the Null (multiplexed) encapsulation,
    when IP packets are encapsulated using the NLPID of hex CC, then the
    default IP MTU of 1500 implies a PDU size of 1501; a PDU size of



<span class="grey">Malis, Robinson, &amp; Ullmann                                      [Page 6]</span>
</pre><!--NewPage--><pre class='newpage'><a name="page-7" id="page-7" href="#page-7" class="invisible"> </a>
<span class="grey"><a href="rfc1356.html">RFC 1356</a>           Multiprotocol Interconnect on X.25        August 1992</span>


    1600 implies an IP MTU of 1599.  When IP packets are encapsulated
    using the NLPID of hex 80 followed by the SNAP header for IP, then
    the default IP MTU of 1500 implies a PDU size of 1506; a PDU size of
    1600 implies an IP MTU of 1594.

    Of course, an implementation MAY support a maximum PDU size larger
    than 1600 octets.  In particular, there is no limit to the size that
    may be used when explicitly configured by communicating peers.

<span class="h3"><a class="selflink" name="section-3.7" href="#section-3.7">3.7</a> Each ISO/IEC TR 9577 encapsulation (e.g., IP, CLNP, and SNAP)</span>
<span class="h3">    requires a separate virtual circuit between systems.  In addition,</span>
    multiple virtual circuits for a single encapsulation MAY be used
    between systems, to, for example, increase throughput (see notes in
    <a href="#section-4.5">section 4.5</a>).

    Receivers SHOULD accept multiple incoming calls with the same
    encapsulation from a single system.  Having done so, receivers MUST
    then accept incoming PDUs on the additional circuit(s), and SHOULD
    transmit on the additional circuits.

    Shedding load by refusing additional calls for the same
    encapsulation with a X.25 diagnostic of 0 (DTE clearing) is correct
    practice, as is shortening inactivity timers to try to clear
    circuits.

    Receivers MUST NOT accept the incoming call, only to close the
    circuit or ignore PDUs from the circuit.

    Because opening multiple virtual circuits specifying the same
    encapsulation is specifically allowed, algorithms to prevent virtual
    circuit call collision, such as the one found in <a href="#section-8.4.3.5">section 8.4.3.5</a> of
    ISO/IEC 8473 [<a href="#ref-4" title="Information processing systems - Data communications - Protocol for providing the connectionless- mode network service">4</a>], MUST NOT be implemented.

    While allowing multiple virtual circuits for a single protocol is
    specifically desired and allowed, implementations MAY choose (by
    configuration) to permit only a single circuit for some protocols to
    some destinations.  Only in such a case, if a colliding incoming
    call is received while a call request is pending, the incoming call
    shall be rejected.  Note that this may result in a failure to
    establish a connection.  In such a case, each system shall wait at
    least a configurable collision retry time before retrying.  Adding a
    random increment, with exponential backoff if necessary, is
    recommended.

<span class="h3"><a class="selflink" name="section-3.8" href="#section-3.8">3.8</a> Either system MAY close a virtual circuit.  </span>If the virtual circuit
    is closed or reset while a datagram is being transmitted, the
    datagram is lost.  Systems SHOULD be able to configure a minimum
    holding time for circuits to remain open as long as the endpoints



<span class="grey">Malis, Robinson, &amp; Ullmann                                      [Page 7]</span>
</pre><!--NewPage--><pre class='newpage'><a name="page-8" id="page-8" href="#page-8" class="invisible"> </a>
<span class="grey"><a href="rfc1356.html">RFC 1356</a>           Multiprotocol Interconnect on X.25        August 1992</span>


    are up. (Note that holding time, the time the circuit has been open,
    differs from idle time.)

<span class="h3"><a class="selflink" name="section-3.9" href="#section-3.9">3.9</a> Each system MUST use an inactivity timer to clear virtual circuits</span>
<span class="h3">    that are idle for some period of time.  Some X.25 networks,</span>
    including the ISDN under present tariffs in most areas, charge for
    virtual circuit holding time.  Even where they do not, the resource
    SHOULD be released when idle.  The timer SHOULD be configurable; a
    timer value of "infinite" is acceptable when explicitly configured.
    The default SHOULD be a small number of minutes.  For IP, a
    reasonable default is 90 seconds.

<span class="h3"><a class="selflink" name="section-3.10" href="#section-3.10">3.10</a> Systems SHOULD allow calls from unconfigured calling addresses</span>
     (presumably not collect calls, however); this SHOULD be a
     configuration option.  A system accepting such a call will, of
     course, not transmit on that virtual circuit if it cannot determine
     the protocol (e.g., IP) address of the caller.  As an example, on
     the DDN this is not a restriction because IP addresses can be
     determined algorithmically based upon the caller's X.121 address
     [<a href="#ref-7" title="&quot;Assigned Numbers&quot;">7</a>,<a href="#ref-9" title="&quot;Defense Data Network X.25 Host Interface Specification&quot;">9</a>].

     Allowing such calls helps work around various "helpful" address
     translations done by the network(s), as well as allowing
     experimentation with various address resolution protocols.

<span class="h3"><a class="selflink" name="section-3.11" href="#section-3.11">3.11</a> Systems SHOULD use a configurable hold-down timer to prevent calls</span>
<span class="h3">     to failed destinations from being immediately retried.</span>

<span class="h3"><a class="selflink" name="section-3.12" href="#section-3.12">3.12</a> X.25 implementations MUST minimally support the following features</span>
<span class="h3">     in order to conform with this specification: call setup and</span>
     clearing and complete packet sequences.  For better performance
     and/or interoperability, X.25 implementations SHOULD also support:
     extended frame and/or packet sequence numbering, flow control
     parameter negotiation, and reverse charging.

<span class="h3"><a class="selflink" name="section-3.13" href="#section-3.13">3.13</a> The following X.25 features MUST NOT be used: interrupt packets and</span>
<span class="h3">     the Q bit (indicating qualified data).  Other X.25 features not</span>
     explicitly discussed in this document, such as fast select and the
     D bit (indicating end-to-end significance) SHOULD NOT be used.

     Use of the D bit will interfere with use of the M bit (more data
     sequences) required for identification of PDUs.  In particular, as
     subscription to the D bit modification facility (X.25-1988, <a href="#section-3.3">section</a>
     <a href="#section-3.3">3.3</a>) will prevent proper operation, this user facility MUST NOT be
     subscribed.

<span class="h3"><a class="selflink" name="section-3.14" href="#section-3.14">3.14</a> ISO/IEC 8208 [<a href="#ref-11">11</a>] defines the clearing diagnostic code 249 to</span>
<span class="h3">     signify that a requested protocol is not supported.  Systems MAY</span>



<span class="grey">Malis, Robinson, &amp; Ullmann                                      [Page 8]</span>
</pre><!--NewPage--><pre class='newpage'><a name="page-9" id="page-9" href="#page-9" class="invisible"> </a>
<span class="grey"><a href="rfc1356.html">RFC 1356</a>           Multiprotocol Interconnect on X.25        August 1992</span>


     use this diagnostic code when clearing an incoming call because the
     identified protocol is not supported.  Non-8208 systems more
     typically use a diagnostic code of 0 for this function.  Supplying
     a diagnostic code is not mandatory, but when it is supplied for
     this reason, it MUST be either of these two values.

<span class="h2"><a class="selflink" name="section-4" href="#section-4">4</a>. General Remarks</span>

   The following remarks are not specifications or requirements for
   implementations, but provide developers and users with guidelines and
   the results of operational experience with <a href="rfc877.html">RFC 877</a>.

<span class="h3"><a class="selflink" name="section-4.1" href="#section-4.1">4.1</a> Protocols above the network layer, such as TCP or TP4, do not</span>
<span class="h3">    affect this standard.  In particular, no attempt is made to open</span>
    X.25 virtual circuits corresponding to TCP or TP4 connections.

<span class="h3"><a class="selflink" name="section-4.2" href="#section-4.2">4.2</a> Both the circuit and multiplexed encapsulations of SNAP may be used</span>
<span class="h3">    to contain any SNAP encapsulated protocol.  In particular, this</span>
    includes using an OUI of 00-00-00 and the two octets of PID
    containing an Ethertype [<a href="#ref-7" title="&quot;Assigned Numbers&quot;">7</a>], or using IEEE 802.1's OUI of hex 00-
    80-C2 with the bridging PIDs listed in <a href="rfc1294.html">RFC 1294</a>, "Multiprotocol
    Interconnect over Frame Relay" [<a href="#ref-8" title="&quot;Multiprotocol Interconnect over Frame Relay&quot;">8</a>].  Note that IEEE 802.1d bridging
    can only be performed over a circuit using the Null (multiplexed)
    encapsulation of SNAP, because of the necessity of preserving the
    order of PDUs (including 802.1d Bridged PDUs) using different SNAP
    headers.

<span class="h3"><a class="selflink" name="section-4.3" href="#section-4.3">4.3</a> Experience has shown that there are X.25 implementations that will</span>
<span class="h3">    assign calls with CC CUD to the X.29 PAD (remote login) facility</span>
    when the IP layer is not installed, not configured properly, or not
    operating (indeed, they assume that ALL calls for unconfigured or
    unbound X.25 protocol IDs are for X.29 PAD sessions).  Call
    originators can detect that this has occurred at the receiver if the
    originator receives any X.25 data packets with the Q bit set,
    especially if the first octet of these packets is hex 02, 04, or 06
    (X.29 PAD parameter commands).  In this case, the originator should
    clear the call, and log the occurrence so that the misconfigured
    X.25 address can be corrected.  It may be useful to also use the
    hold-down timer (see <a href="#section-3.11">section 3.11</a>) to prevent further attempts for
    some period of time.

<span class="h3"><a class="selflink" name="section-4.4" href="#section-4.4">4.4</a> It is often assumed that a larger X.25 data packet size will result</span>
<span class="h3">    in increased performance.  This is not necessarily true: in typical</span>
    X.25 networks it will actually decrease performance.

    Many, if not most, X.25 networks completely store X.25 data packets
    in each switch before forwarding them.  If the X.25 network requires
    a path through a number of switches, and low-speed trunks are used,



<span class="grey">Malis, Robinson, &amp; Ullmann                                      [Page 9]</span>
</pre><!--NewPage--><pre class='newpage'><a name="page-10" id="page-10" href="#page-10" class="invisible"> </a>
<span class="grey"><a href="rfc1356.html">RFC 1356</a>           Multiprotocol Interconnect on X.25        August 1992</span>


    then negotiating and using large X.25 data packets could result in
    large transit delays through the X.25 network as a result of the
    time required to clock the data packets over each low-speed trunk.
    If a small end-to-end window size is also used, this may also
    adversely affect the end-to-end throughput of the X.25 circuit.  For
    this reason, segmenting large IP datagrams in the X.25 layer into
    complete packet sequences of smaller X.25 data packets allows a
    greater amount of pipelining through the X.25 switches, with
    subsequent improvements in end-to-end throughput.

    Large X.25 data packet size combined with slow (e.g., 9.6Kbps)
    physical circuits will also increase individual packet latency for
    other virtual circuits on the same path; this may cause unacceptable
    effects on, for example, X.29 connections.

    This discussion is further complicated by the fact that X.25
    networks are free to internally combine or split X.25 data packets
    as long as the complete packet sequence is preserved.

    The optimum X.25 data packet size is, therefore, dependent on the
    network, and is not necessarily the largest size offered by that
    network.

<span class="h3"><a class="selflink" name="section-4.5" href="#section-4.5">4.5</a> Another method of increasing performance is to open multiple virtual</span>
<span class="h3">    circuits to the same destination, specifying the same CUD.  Like</span>
    packet size, this is not always the best method.

    When the throughput limitation is due to X.25 window size, opening
    multiple circuits effectively multiplies the window, and may
    increase performance.

    However, opening multiple circuits also competes more effectively
    for the physical path, by taking more shares of the available
    bandwidth.  While this may be desirable to the user of the
    encapsulation, it may be somewhat less desirable to the other users
    of the path.

    Opening multiple circuits may also cause datagram sequencing and
    reordering problems in end systems with limited buffering (e.g., at
    the TCP level, receiving segments out of order, when a single
    circuit would have delivered them in order). This will only affect
    performance, not correctness of operation.

    Opening multiple circuits may also increase the cost of delivering
    datagrams across a public data network.






<span class="grey">Malis, Robinson, &amp; Ullmann                                     [Page 10]</span>
</pre><!--NewPage--><pre class='newpage'><a name="page-11" id="page-11" href="#page-11" class="invisible"> </a>
<span class="grey"><a href="rfc1356.html">RFC 1356</a>           Multiprotocol Interconnect on X.25        August 1992</span>


<span class="h3"><a class="selflink" name="section-4.6" href="#section-4.6">4.6</a> This document does not specify any method of dynamic IP to X.25 (or</span>
<span class="h3">    X.121) address resolution.  The problem is left for further study.</span>

    Typical present-day implementations use static tables of varying
    kinds, or an algorithmic transformation between IP and X.121
    addresses [<a href="#ref-7" title="&quot;Assigned Numbers&quot;">7</a>,<a href="#ref-9" title="&quot;Defense Data Network X.25 Host Interface Specification&quot;">9</a>].  There are proposals for other methods.  In
    particular, <a href="rfc1183.html">RFC 1183</a> [<a href="#ref-10" title="&quot;New DNS RR Definitions&quot;">10</a>] describes Domain Name System (DNS)
    resource records that may be useful either for automatic resolution
    or for maintenance of static tables.  Use of these method(s) is
    entirely experimental at this time.

<span class="h2"><a class="selflink" name="section-5" href="#section-5">5</a>. Packet Formats</span>

   For each protocol encoding, the diagrams outline the call request and
   the data packet format. The data packet shown is the first of a
   complete packet (M bit) sequence.

<span class="h3"><a class="selflink" name="section-5.1" href="#section-5.1">5.1</a> IP Encapsulation</span>

    Call Request:

    +----------------+-----------+------------+----+
    | GFI, LCN, type | addresses | facilities | CC |
    +----------------+-----------+------------+----+

    X.25 data packets:

    +----------------+------------------------+
    | GFI, LCN, I    | IP datagram            |
    +----------------+------------------------+

<span class="h3"><a class="selflink" name="section-5.2" href="#section-5.2">5.2</a> CLNP, ES-IS, IS-IS Encapsulation</span>

    Call Request:

    +----------------+-----------+------------+----+
    | GFI, LCN, type | addresses | facilities | 81 |
    +----------------+-----------+------------+----+

    X.25 data packets:

    +----------------+--------------------------------+
    | GFI, LCN, I    | CLNP, ES-IS, or IS-IS datagram |
    +----------------+--------------------------------+

    (Note that these datagrams are self-identifying in their
    first octet).




<span class="grey">Malis, Robinson, &amp; Ullmann                                     [Page 11]</span>
</pre><!--NewPage--><pre class='newpage'><a name="page-12" id="page-12" href="#page-12" class="invisible"> </a>
<span class="grey"><a href="rfc1356.html">RFC 1356</a>           Multiprotocol Interconnect on X.25        August 1992</span>


<span class="h3"><a class="selflink" name="section-5.3" href="#section-5.3">5.3</a> SNAP Encapsulation</span>

    Call Request:

    +----------------+-----------+------------+----+-----------------+
    | GFI, LCN, type | addresses | facilities | 80 | SNAP (5 octets) |
    +----------------+-----------+------------+----+-----------------+

    X.25 data packets:

    +----------------+-------------------------------------+
    | GFI, LCN, I    | Protocol Data Unit (no SNAP header) |
    +----------------+-------------------------------------+

<span class="h3"><a class="selflink" name="section-5.4" href="#section-5.4">5.4</a> Null (Multiplexed) Encapsulation</span>

    Call Request:

    +----------------+-----------+------------+----+
    | GFI, LCN, type | addresses | facilities | 00 |
    +----------------+-----------+------------+----+

    X.25 data packets:

    +----------------+-----------------+---------------------+
    | GFI, LCN, I    | NLPID (1 octet) | Protocol Data Unit  |
    +----------------+-----------------+---------------------+

    Examples of data packets:

    Multiplexed IP datagram:

    +----------------+----+-----------------------+
    | GFI, LCN, I    | CC | IP datagram           |
    +----------------+----+-----------------------+

    Multiplexed CLNP datagram:

    +----------------+----+-------------------------+
    | GFI, LCN, I    | 81 | CLNP datagram           |
    +----------------+----+-------------------------+

    Multiplexed SNAP PDU:

    +----------------+----+-----------------+--------------------+
    | GFI, LCN, I    | 80 | SNAP (5 octets) | Protocol Data Unit |
    +----------------+----+-----------------+--------------------+




<span class="grey">Malis, Robinson, &amp; Ullmann                                     [Page 12]</span>
</pre><!--NewPage--><pre class='newpage'><a name="page-13" id="page-13" href="#page-13" class="invisible"> </a>
<span class="grey"><a href="rfc1356.html">RFC 1356</a>           Multiprotocol Interconnect on X.25        August 1992</span>


<span class="h2"><a class="selflink" name="section-6" href="#section-6">6</a>. Security Considerations</span>

   Security issues are not discussed in this memo.

<span class="h2"><a class="selflink" name="section-7" href="#section-7">7</a>. References</span>

   [<a name="ref-1" id="ref-1">1</a>]  Korb, J., "A Standard for the Transmission of IP Datagrams Over
        Public Data Networks", <a href="rfc877.html">RFC 877</a>, Purdue University, September
        1983.

   [<a name="ref-2" id="ref-2">2</a>]  ISO/IEC TR 9577, Information technology - Telecommunications and
        Information exchange between systems - Protocol Identification
        in the network layer, 1990 (E) 1990-10-15.

   [<a name="ref-3" id="ref-3">3</a>]  IEEE, "IEEE Standard for Local and Metropolitan Area Networks:
        Overview and Architecture", IEEE Standards 802-1990.

   [<a name="ref-4" id="ref-4">4</a>]  ISO/IEC 8473, Information processing systems - Data
        communications - Protocol for providing the connectionless- mode
        network service, 1988.

   [<a name="ref-5" id="ref-5">5</a>]  ISO/IEC 9542, Information processing systems -
        Telecommunications and information exchange between systems -
        End system to intermediate system routeing protocol for use in
        conjunction with the protocol for providing the connectionless-
        mode network service (ISO/IEC 8473), 1988.

   [<a name="ref-6" id="ref-6">6</a>]  Postel, J., Editor., "Internet Protocol - DARPA Internet Program
        Protocol Specification", <a href="rfc791.html">RFC 791</a>, USC/Information Sciences
        Institute, September 1981.

   [<a name="ref-7" id="ref-7">7</a>]  Reynolds, J. and J. Postel, "Assigned Numbers", <a href="rfc1340.html">RFC 1340</a>,
        USC/Information Sciences Institute, July 1992.

   [<a name="ref-8" id="ref-8">8</a>]  Bradley, T., Brown, C., and A. Malis, "Multiprotocol
        Interconnect over Frame Relay", <a href="rfc1294.html">RFC 1294</a>, Wellfleet
        Communications and BBN Communications, January 1992.

   [<a name="ref-9" id="ref-9">9</a>]  "Defense Data Network X.25 Host Interface Specification",
        contained in "DDN Protocol Handbook", Volume 1, DDN Network
        Information Center 50004, December 1985.

  [<a name="ref-10" id="ref-10">10</a>]  Everhart, C., Mamakos, L., Ullmann, R, and P. Mockapetris,
        Editors, "New DNS RR Definitions", <a href="rfc1183.html">RFC 1183</a>, Transarc,
        University of Maryland, Prime Computer, USC/Information Sciences
        Institute, October 1990.

  [<a name="ref-11" id="ref-11">11</a>]  ISO/IEC 8208, Information processing systems - Data



<span class="grey">Malis, Robinson, &amp; Ullmann                                     [Page 13]</span>
</pre><!--NewPage--><pre class='newpage'><a name="page-14" id="page-14" href="#page-14" class="invisible"> </a>
<span class="grey"><a href="rfc1356.html">RFC 1356</a>           Multiprotocol Interconnect on X.25        August 1992</span>


        communications - X.25 Packet Level Protocol for Data Terminal
        Equipment, 1987.

<span class="h2"><a class="selflink" name="section-8" href="#section-8">8</a>. Authors' Addresses</span>

   Andrew G. Malis
   BBN Communications
   150 CambridgePark Drive
   Cambridge, MA 02140
   USA

   Phone: +1 617 873 3419
   Email: malis@bbn.com


   David Robinson
   Computervision Systems Integration
   201 Burlington Road
   Bedford, MA 01730
   USA

   Phone: +1 617 275 1800 x2774
   Email: drb@relay.prime.com


   Robert L. Ullmann
   Process Software Corporation
   959 Concord Street
   Framingham, MA 01701
   USA

   Phone: +1 508 879 6994
   Email: ariel@process.com


















Malis, Robinson, &amp; Ullmann                                     [Page 14]

</pre><br />
<span class="noprint"><small><small>Html markup produced by rfcmarkup 1.107, available from
<a href="http://tools.ietf.org/tools/rfcmarkup/">http://tools.ietf.org/tools/rfcmarkup/</a>
</small></small></span>
</body>
<!-- Mirrored from tools.ietf.org/html/rfc1356 by HTTrack Website Copier/3.x [XR&CO'2010], Wed, 19 Mar 2014 18:51:31 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
</html>
