<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head profile="http://dublincore.org/documents/2008/08/04/dc-html/">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="robots" content="index,follow" />
    <meta name="creator" content="rfcmarkup version 1.107" />
    <link rel="schema.DC" href="http://purl.org/dc/elements/1.1/" />
<meta name="DC.Identifier" content="urn:ietf:rfc:6024" />
<meta name="DC.Description.Abstract" content="A trust anchor represents an authoritative entity via a public key and\nassociated data. The public key is used to verify digital signatures,\nand the associated data is used to constrain the types of information\nfor which the trust anchor is authoritative. A relying party uses\ntrust anchors to determine if a digitally signed object is valid by\nverifying a digital signature using the trust anchor\x27s public key,\nand by enforcing the constraints expressed in the associated data for\nthe trust anchor. This document describes some of the problems\nassociated with the lack of a standard trust anchor management\nmechanism and defines requirements for data formats and push-based\nprotocols designed to address these problems. This document is not an\nInternet Standards Track specification; it is published for\ninformational purposes." />
<meta name="DC.Creator" content="Reddy, Raksha" />
<meta name="DC.Creator" content="Wallace, Carl" />
<meta name="DC.Date.Issued" content="October, 2010" />
<meta name="DC.Title" content="Trust Anchor Management Requirements" />

    <link rel="icon" href="http://tools.ietf.org/images/rfc.png" type="image/png" />
    <link rel="shortcut icon" href="http://tools.ietf.org/images/rfc.png" type="image/png" />
    <title>RFC 6024 - Trust Anchor Management Requirements</title>
    
    
    <style type="text/css">
	body {
	    margin: 0px 8px;
            font-size: 1em;
	}
        h1, h2, h3, h4, h5, h6, .h1, .h2, .h3, .h4, .h5, .h6 {
	    font-weight: bold;
            line-height: 0pt;
            display: inline;
            white-space: pre;
            font-family: monospace;
            font-size: 1em;
	    font-weight: bold;
        }
        pre {
            font-size: 1em;
            margin-top: 0px;
            margin-bottom: 0px;
        }
	.pre {
	    white-space: pre;
	    font-family: monospace;
	}
	.header{
	    font-weight: bold;
	}
        .newpage {
            page-break-before: always;
        }
        .invisible {
            text-decoration: none;
            color: white;
        }
        a.selflink {
          color: black;
          text-decoration: none;
        }
        @media print {
            body {
                font-family: monospace;
                font-size: 10.5pt;
            }
            h1, h2, h3, h4, h5, h6 {
                font-size: 1em;
            }
        
            a:link, a:visited {
                color: inherit;
                text-decoration: none;
            }
            .noprint {
                display: none;
            }
        }
	@media screen {
	    .grey, .grey a:link, .grey a:visited {
		color: #777;
	    }
            .docinfo {
                background-color: #EEE;
            }
            .top {
                border-top: 7px solid #EEE;
            }
            .bgwhite  { background-color: white; }
            .bgred    { background-color: #F44; }
            .bggrey   { background-color: #666; }
            .bgbrown  { background-color: #840; }            
            .bgorange { background-color: #FA0; }
            .bgyellow { background-color: #EE0; }
            .bgmagenta{ background-color: #F4F; }
            .bgblue   { background-color: #66F; }
            .bgcyan   { background-color: #4DD; }
            .bggreen  { background-color: #4F4; }

            .legend   { font-size: 90%; }
            .cplate   { font-size: 70%; border: solid grey 1px; }
	}
    </style>
    <!--[if IE]>
    <style>
    body {
       font-size: 13px;
       margin: 10px 10px;
    }
    </style>
    <![endif]-->

    <script type="text/javascript"><!--
    function addHeaderTags() {
	var spans = document.getElementsByTagName("span");
	for (var i=0; i < spans.length; i++) {
	    var elem = spans[i];
	    if (elem) {
		var level = elem.getAttribute("class");
                if (level == "h1" || level == "h2" || level == "h3" || level == "h4" || level == "h5" || level == "h6") {
                    elem.innerHTML = "<"+level+">"+elem.innerHTML+"</"+level+">";		
                }
	    }
	}
    }
    var legend_html = "Colour legend:<br />      <table>         <tr><td>Unknown:</td>                   <td><span class='cplate bgwhite'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft:</td>                     <td><span class='cplate bgred'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Informational:</td>             <td><span class='cplate bgorange'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Experimental:</td>              <td><span class='cplate bgyellow'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Best Common Practice:</td>      <td><span class='cplate bgmagenta'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Proposed Standard:</td>         <td><span class='cplate bgblue'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft Standard (old designation):</td> <td><span class='cplate bgcyan'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Internet Standard:</td>         <td><span class='cplate bggreen'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Historic:</td>                  <td><span class='cplate bggrey'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Obsolete:</td>                  <td><span class='cplate bgbrown'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>     </table>";
    function showElem(id) {
        var elem = document.getElementById(id);
        elem.innerHTML = eval(id+"_html");
        elem.style.visibility='visible';
    }
    function hideElem(id) {
        var elem = document.getElementById(id);
        elem.style.visibility='hidden';        
        elem.innerHTML = "";
    }
    // -->
    </script>
</head>
<body onload="addHeaderTags()">
   <div style="height: 13px;">
      <div onmouseover="this.style.cursor='pointer';"
         onclick="showElem('legend');"
         onmouseout="hideElem('legend')"
	 style="height: 6px; position: absolute;"
         class="pre noprint docinfo bgorange"
         title="Click for colour legend." >                                                                        </div>
      <div id="legend"
           class="docinfo noprint pre legend"
           style="position:absolute; top: 4px; left: 4ex; visibility:hidden; background-color: white; padding: 4px 9px 5px 7px; border: solid #345 1px; "
           onmouseover="showElem('legend');"
           onmouseout="hideElem('legend');">
      </div>
   </div>
<span class="pre noprint docinfo top">[<a href="index.html" title="Document search and retrieval page">Docs</a>] [<a href="http://tools.ietf.org/rfc/rfc6024.txt" title="Plaintext version of this document">txt</a>|<a href="http://tools.ietf.org/pdf/rfc6024" title="PDF version of this document">pdf</a>] [<a href="http://tools.ietf.org/html/draft-ietf-pkix-ta-mgmt-reqs" title="draft-ietf-pkix-ta-mgmt-reqs">draft-ietf-pkix-t...</a>] [<a href="http://tools.ietf.org/rfcdiff?difftype=--hwdiff&amp;url2=rfc6024" title="Inline diff (wdiff)">Diff1</a>] [<a href="http://tools.ietf.org/rfcdiff?url2=rfc6024" title="Side-by-side diff">Diff2</a>]                 </span><br />
<span class="pre noprint docinfo">                                                                        </span><br />
<span class="pre noprint docinfo">                                                           INFORMATIONAL</span><br />
<span class="pre noprint docinfo">                                                                        </span><br />
<pre>
Internet Engineering Task Force (IETF)                          R. Reddy
Request for Comments: 6024                      National Security Agency
Category: Informational                                       C. Wallace
ISSN: 2070-1721                                       Cygnacom Solutions
                                                            October 2010


                  <span class="h1">Trust Anchor Management Requirements</span>

Abstract

   A trust anchor represents an authoritative entity via a public key
   and associated data.  The public key is used to verify digital
   signatures, and the associated data is used to constrain the types of
   information for which the trust anchor is authoritative.  A relying
   party uses trust anchors to determine if a digitally signed object is
   valid by verifying a digital signature using the trust anchor's
   public key, and by enforcing the constraints expressed in the
   associated data for the trust anchor.  This document describes some
   of the problems associated with the lack of a standard trust anchor
   management mechanism and defines requirements for data formats and
   push-based protocols designed to address these problems.

Status of This Memo

   This document is not an Internet Standards Track specification; it is
   published for informational purposes.

   This document is a product of the Internet Engineering Task Force
   (IETF).  It represents the consensus of the IETF community.  It has
   received public review and has been approved for publication by the
   Internet Engineering Steering Group (IESG).  Not all documents
   approved by the IESG are a candidate for any level of Internet
   Standard; see <a href="rfc5741.html#section-2">Section&nbsp;2 of RFC 5741</a>.

   Information about the current status of this document, any errata,
   and how to provide feedback on it may be obtained at
   <a href="http://www.rfc-editor.org/info/rfc6024">http://www.rfc-editor.org/info/rfc6024</a>.

Copyright Notice

   Copyright (c) 2010 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to <a href="http://tools.ietf.org/html/bcp78">BCP 78</a> and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (<a href="http://trustee.ietf.org/license-info">http://trustee.ietf.org/license-info</a>) in effect on the date of
   publication of this document.  Please review these documents



<span class="grey">Reddy &amp; Wallace               Informational                     [Page 1]</span>
</pre><!--NewPage--><pre class='newpage'><a name="page-2" id="page-2" href="#page-2" class="invisible"> </a>
<span class="grey"><a href="rfc6024.html">RFC 6024</a>                 Trust Anchor Management            October 2010</span>


   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in <a href="#section-4">Section 4</a>.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.

   This document may contain material from IETF Documents or IETF
   Contributions published or made publicly available before November
   10, 2008.  The person(s) controlling the copyright in some of this
   material may not have granted the IETF Trust the right to allow
   modifications of such material outside the IETF Standards Process.
   Without obtaining an adequate license from the person(s) controlling
   the copyright in such materials, this document may not be modified
   outside the IETF Standards Process, and derivative works of it may
   not be created outside the IETF Standards Process, except to format
   it for publication as an RFC or to translate it into languages other
   than English.

Table of Contents

   <a href="#section-1">1</a>.  Introduction . . . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-3">3</a>
     <a href="#section-1.1">1.1</a>.  Terminology  . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-4">4</a>
     <a href="#section-1.2">1.2</a>.  Requirements Notation  . . . . . . . . . . . . . . . . . .  <a href="#page-4">4</a>
   <a href="#section-2">2</a>.  Problem Statement  . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-5">5</a>
   <a href="#section-3">3</a>.  Requirements . . . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-6">6</a>
     <a href="#section-3.1">3.1</a>.  Transport Independence . . . . . . . . . . . . . . . . . .  <a href="#page-6">6</a>
     <a href="#section-3.2">3.2</a>.  Basic Management Operations  . . . . . . . . . . . . . . .  <a href="#page-7">7</a>
     <a href="#section-3.3">3.3</a>.  Management Targets . . . . . . . . . . . . . . . . . . . .  <a href="#page-7">7</a>
     <a href="#section-3.4">3.4</a>.  Delegation of TA Manager Authority . . . . . . . . . . . .  <a href="#page-8">8</a>
     <a href="#section-3.5">3.5</a>.  <a href="rfc5280.html">RFC 5280</a> Support . . . . . . . . . . . . . . . . . . . . .  <a href="#page-9">9</a>
     3.6.  Support Purposes other than Certification Path
           Validation . . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-9">9</a>
     <a href="#section-3.7">3.7</a>.  Trust Anchor Format  . . . . . . . . . . . . . . . . . . . <a href="#page-10">10</a>
     <a href="#section-3.8">3.8</a>.  Source Authentication  . . . . . . . . . . . . . . . . . . <a href="#page-10">10</a>
     <a href="#section-3.9">3.9</a>.  Reduce Reliance on Out-of-Band Trust Mechanisms  . . . . . <a href="#page-11">11</a>
     <a href="#section-3.10">3.10</a>. Replay Detection . . . . . . . . . . . . . . . . . . . . . <a href="#page-11">11</a>
     <a href="#section-3.11">3.11</a>. Compromise or Disaster Recovery  . . . . . . . . . . . . . <a href="#page-12">12</a>
   <a href="#section-4">4</a>.  Security Considerations  . . . . . . . . . . . . . . . . . . . <a href="#page-12">12</a>
   <a href="#section-5">5</a>.  References . . . . . . . . . . . . . . . . . . . . . . . . . . <a href="#page-13">13</a>
     <a href="#section-5.1">5.1</a>.  Normative References . . . . . . . . . . . . . . . . . . . <a href="#page-13">13</a>
     <a href="#section-5.2">5.2</a>.  Informative References . . . . . . . . . . . . . . . . . . <a href="#page-13">13</a>










<span class="grey">Reddy &amp; Wallace               Informational                     [Page 2]</span>
</pre><!--NewPage--><pre class='newpage'><a name="page-3" id="page-3" href="#page-3" class="invisible"> </a>
<span class="grey"><a href="rfc6024.html">RFC 6024</a>                 Trust Anchor Management            October 2010</span>


<span class="h2"><a class="selflink" name="section-1" href="#section-1">1</a>.  Introduction</span>

   Digital signatures are used in many applications.  For digital
   signatures to provide integrity and authentication, the public key
   used to verify the digital signature must be "trusted", i.e.,
   accepted by a relying party (RP) as appropriate for use in the given
   context.  A public key used to verify a signature must be configured
   as a trust anchor (TA) or contained in a certificate that can be
   transitively verified by a certification path terminating at a trust
   anchor.  A trust anchor is a public key and associated data used by a
   relying party to validate a signature on a signed object where the
   object is either:

   o  a public key certificate that begins a certification path
      terminated by a signature certificate or encryption certificate

   o  an object, other than a public key certificate or certificate
      revocation list (CRL), that cannot be validated via use of a
      certification path

   Trust anchors have only local significance, i.e., each RP is
   configured with a set of trust anchors, either by the RP or by an
   entity that manages TAs in the context in which the RP operates.  The
   associated data defines the scope of a trust anchor by imposing
   constraints on the signatures that the trust anchor may be used to
   verify.  For example, if a trust anchor is used to verify signatures
   on X.509 certificates, these constraints may include a combination of
   name spaces, certificate policies, or application/usage types.

   One use of digital signatures is the verification of signatures on
   firmware packages loaded into hardware modules, such as cryptographic
   modules, cable boxes, routers, etc.  Since such devices are often
   managed remotely, the devices must be able to authenticate the source
   of management interactions and can use trust anchors to perform this
   authentication.  However, trust anchors require management as well.
   Other applications requiring trust anchor management include web
   browsers (which use trust anchors when authenticating web servers)
   and email clients (which use trust anchors when validating signed
   email and when authenticating recipients of encrypted email).

   All applications that rely upon digital signatures rely upon some
   means of managing one or more sets of trust anchors.  Each set of
   trust anchors is referred to in this document as a trust anchor
   store.  Often, the means of managing trust anchor stores are
   application-specific and rely upon out-of-band means to establish and
   maintain trustworthiness.  An application may use multiple trust





<span class="grey">Reddy &amp; Wallace               Informational                     [Page 3]</span>
</pre><!--NewPage--><pre class='newpage'><a name="page-4" id="page-4" href="#page-4" class="invisible"> </a>
<span class="grey"><a href="rfc6024.html">RFC 6024</a>                 Trust Anchor Management            October 2010</span>


   anchor stores, and a given trust anchor store may be used by multiple
   applications.  Each trust anchor store is managed by at least one TA
   manager; a TA manager may manage multiple TA stores.

   The requirements stated in this document were prepared prior to the
   publication of [<a href="rfc5914.html" title="&quot;Trust Anchor Format&quot;">RFC5914</a>] and [<a href="rfc5934.html" title="&quot;Trust Anchor Management Protocol (TAMP)&quot;">RFC5934</a>].  The document was not
   published at that time to allow for changes in requirements during
   the development of the associated technical specifications.  The
   requirements described below are those that were considered during
   the development of [<a href="rfc5914.html" title="&quot;Trust Anchor Format&quot;">RFC5914</a>] and [<a href="rfc5934.html" title="&quot;Trust Anchor Management Protocol (TAMP)&quot;">RFC5934</a>].

   This section provides an introduction and defines basic terminology.
   <a href="#section-2">Section 2</a> describes problems with current trust anchor management
   methods.  Sections <a href="#section-3">3</a> and <a href="#section-4">4</a> describe requirements and security
   considerations for a trust anchor management solution.

<span class="h3"><a class="selflink" name="section-1.1" href="#section-1.1">1.1</a>.  Terminology</span>

   The following terms are defined in order to provide a vocabulary for
   describing requirements for trust anchor management.

   Trust Anchor:   A trust anchor represents an authoritative entity via
      a public key and associated data.  The public key is used to
      verify digital signatures, and the associated data is used to
      constrain the types of information for which the trust anchor is
      authoritative.  A relying party uses trust anchors to determine if
      a digitally signed object is valid by verifying a digital
      signature using the trust anchor's public key, and by enforcing
      the constraints expressed in the associated data for the trust
      anchor.

   Trust Anchor Manager:   A trust anchor manager is an entity
      responsible for managing the contents of a trust anchor store.
      Throughout this document, each trust anchor manager is assumed to
      be represented as or delegated by a distinct trust anchor.

   Trust Anchor Store:   A trust anchor store is a set of one or more
      trust anchors stored in a device.  A trust anchor store may be
      managed by one or more trust anchor managers.  A device may have
      more than one trust anchor store, each of which may be used by one
      or more applications.

<span class="h3"><a class="selflink" name="section-1.2" href="#section-1.2">1.2</a>.  Requirements Notation</span>

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in <a href="rfc2119.html">RFC 2119</a> [<a href="rfc2119.html" title="&quot;Key words for use in RFCs to Indicate Requirement Levels&quot;">RFC2119</a>].




<span class="grey">Reddy &amp; Wallace               Informational                     [Page 4]</span>
</pre><!--NewPage--><pre class='newpage'><a name="page-5" id="page-5" href="#page-5" class="invisible"> </a>
<span class="grey"><a href="rfc6024.html">RFC 6024</a>                 Trust Anchor Management            October 2010</span>


<span class="h2"><a class="selflink" name="section-2" href="#section-2">2</a>.  Problem Statement</span>

   Trust anchors are used to support many application scenarios.  Most
   Internet browsers and email clients use trust anchors when
   authenticating Transport Layer Security (TLS) sessions, verifying
   signed email, and generating encrypted email by validating a
   certification path to a server's certificate, an email originator's
   certificate, or an email recipient's certificate, respectively.  Many
   software distributions are digitally signed to enable authentication
   of the software source prior to installation.  Trust anchors that
   support these applications are typically installed as part of the
   operating system (OS) or application, installed using an enterprise
   configuration management system, or installed directly by an OS or
   application user.

   Trust anchors are typically stored in application-specific or
   OS-specific trust anchor stores.  Often, a single machine may have a
   number of different trust anchor stores that may not be synchronized.
   Reviewing the contents of a particular trust anchor store typically
   involves use of a proprietary tool that interacts with a particular
   type of trust store.

   The presence of a trust anchor in a particular store often conveys
   implicit authorization to validate signatures for any contexts from
   which the store is accessed.  For example, the public key of a
   timestamp authority (TSA) may be installed in a trust anchor store to
   validate signatures on timestamps [<a href="rfc3161.html" title="&quot;Internet X.509 Public Key Infrastructure Time-Stamp Protocol (TSP)&quot;">RFC3161</a>].  However, if the store
   containing this TA is used by multiple applications that serve
   different purposes, the same key may be used (inappropriately) to
   validate other types of objects such as certificates or Online
   Certificate Status Protocol (OCSP) responses.  Prior to publication
   of [<a href="rfc5914.html" title="&quot;Trust Anchor Format&quot;">RFC5914</a>], there was no standard general-purpose mechanism for
   limiting the applicability (scope) of a trust anchor.  A common
   practice to address this problem is to place different TAs in
   different stores and limit the set of applications that access a
   given TA store.

   Trust relationships between Public Key Infrastructures (PKIs) are
   negotiated by policy authorities.  Negotiations frequently require
   significant time to ensure all participating parties' requirements
   are satisfied.  These requirements are expressed, to some extent, in
   public key certificates via policy constraints, name constraints,
   etc.  In order for these requirements to be enforced, trust anchor
   stores must be managed in accord with policy authority intentions.
   Otherwise, the constraints defined in a cross-certificate could be
   circumvented by recognizing the subject of the cross certificate as a
   trust anchor, which would enable path processing implementations to
   avoid the cross-certificate.



<span class="grey">Reddy &amp; Wallace               Informational                     [Page 5]</span>
</pre><!--NewPage--><pre class='newpage'><a name="page-6" id="page-6" href="#page-6" class="invisible"> </a>
<span class="grey"><a href="rfc6024.html">RFC 6024</a>                 Trust Anchor Management            October 2010</span>


   Trust anchors are often represented as self-signed certificates,
   which provide no useful means of establishing the validity of the
   information contained in the certificate.  Confidence in the
   integrity of a trust anchor is typically established through out-of-
   band means, often by checking the "fingerprint" (one-way hash) of the
   self-signed certificate with an authoritative source.  Routine trust
   anchor rekey operations typically require similar out-of-band checks,
   though in-band rekey of a trust anchor is supported by the
   Certificate Management Protocol (CMP) [<a href="rfc4210.html" title="&quot;Internet X.509 Public Key Infrastructure Certificate Management Protocol (CMP)&quot;">RFC4210</a>].  Ideally, only the
   initial set of trust anchors are installed in a particular trust
   anchor store should require out-of-band verification, particularly
   when the costs of performing out-of-band checks commensurate with the
   security requirements of applications using the trust anchor store
   are high.

   Despite the prevalent use of trust anchors, there is neither a
   standard means for discovering the set of trust anchors installed in
   a particular trust anchor store nor a standard means of managing
   those trust anchors.  The remainder of this document describes
   requirements for a solution to this problem along with some security
   considerations.

<span class="h2"><a class="selflink" name="section-3" href="#section-3">3</a>.  Requirements</span>

   This section describes the requirements for a trust anchor management
   protocol.  Requirements are provided for trust anchor contents as
   well as for trust anchor store management operations.

<span class="h3"><a class="selflink" name="section-3.1" href="#section-3.1">3.1</a>.  Transport Independence</span>

<span class="h4"><a class="selflink" name="section-3.1.1" href="#section-3.1.1">3.1.1</a>.  Functional Requirements</span>

   A general-purpose solution for the management of trust anchors MUST
   be transport independent in order to apply to a range of device
   communications environments.  It MUST work in both session-oriented
   and store-and-forward communications environments as well as in both
   push and pull distribution models.  To accommodate both communication
   models in a uniform fashion, connectionless integrity and data origin
   authentication for TA transactions MUST be provided at the
   application layer.  Confidentiality MAY be provided for such
   transactions.

<span class="h4"><a class="selflink" name="section-3.1.2" href="#section-3.1.2">3.1.2</a>.  Rationale</span>

   Not all devices that use trust anchors are available for online
   management operations; some devices may require manual interaction
   for trust anchor management.  Data origin authentication and
   integrity are required to ensure that the transaction has not been



<span class="grey">Reddy &amp; Wallace               Informational                     [Page 6]</span>
</pre><!--NewPage--><pre class='newpage'><a name="page-7" id="page-7" href="#page-7" class="invisible"> </a>
<span class="grey"><a href="rfc6024.html">RFC 6024</a>                 Trust Anchor Management            October 2010</span>


   modified en route.  Only connectionless integrity is required, for
   compatibility with store-and-forward contexts.

<span class="h3"><a class="selflink" name="section-3.2" href="#section-3.2">3.2</a>.  Basic Management Operations</span>

<span class="h4"><a class="selflink" name="section-3.2.1" href="#section-3.2.1">3.2.1</a>.  Functional Requirements</span>

   At a minimum, a protocol used for trust anchor management MUST enable
   a trust anchor manager to perform the following operations:

   o  Determine which trust anchors are installed in a particular trust
      anchor store

   o  Add one or more trust anchors to a trust anchor store

   o  Remove one or more trust anchors from a trust anchor store

   o  Replace an entire trust anchor store

   A trust anchor management protocol MUST provide support for these
   basic operations; however, not all implementations must support each
   option.  For example, some implementations may support only
   replacement of trust anchor stores.

<span class="h4"><a class="selflink" name="section-3.2.2" href="#section-3.2.2">3.2.2</a>.  Rationale</span>

   These requirements describe the core operations required to manage
   the contents of a trust anchor store.  An edit operation was omitted
   for the sake of simplicity, with consecutive remove and add
   operations used for this purpose.  A single add or remove operation
   can act upon more than one trust anchor to avoid unnecessary round
   trips and are provided to avoid the need to always replace an entire
   trust anchor store.  Trust anchor store replacement may be useful as
   a simple, higher-bandwidth alternative to add and remove operations.

<span class="h3"><a class="selflink" name="section-3.3" href="#section-3.3">3.3</a>.  Management Targets</span>

<span class="h4"><a class="selflink" name="section-3.3.1" href="#section-3.3.1">3.3.1</a>.  Functional Requirements</span>

   A protocol for TA management MUST allow a TA management transaction
   to be directed to:

      All TA stores for which the manager is responsible

      An enumerated list of one or more named groups of trust anchor
      stores

      An individual trust anchor store



<span class="grey">Reddy &amp; Wallace               Informational                     [Page 7]</span>
</pre><!--NewPage--><pre class='newpage'><a name="page-8" id="page-8" href="#page-8" class="invisible"> </a>
<span class="grey"><a href="rfc6024.html">RFC 6024</a>                 Trust Anchor Management            October 2010</span>


<span class="h4"><a class="selflink" name="section-3.3.2" href="#section-3.3.2">3.3.2</a>.  Rationale</span>

   Connections between PKIs can be accomplished using different means.
   Unilateral or bilateral cross-certification can be performed, or a
   community may simply elect to explicitly accept a trust anchor from
   another community.  Typically, these decisions occur at the
   enterprise level.  In some scenarios, it can be useful to establish
   these connections for a small community within an enterprise.
   Enterprise-wide mechanisms such as cross-certificates are ill-suited
   for this purpose since certificate revocation or expiration affects
   the entire enterprise.

   A trust anchor management protocol can address this issue by
   supporting limited installation of trust anchors (i.e., installation
   of TAs in subsets of the enterprise user community), and by
   supporting expression of constraints on trust anchor use by relying
   parties.  Limited installation requires the ability to identify the
   members of the community that are intended to rely upon a particular
   trust anchor, as well as the ability to query and report on the
   contents of trust anchor stores.  Trust anchor constraints can be
   used to represent the limitations that might otherwise be expressed
   in a cross-certificate, and limited installation ensures the
   recognition of the trust anchor does not necessarily encompass an
   entire enterprise.

   Trust anchor configurations may be uniform across an enterprise, or
   they may be unique to a single application or small set of
   applications.  Many devices and some applications utilize multiple
   trust anchor stores.  By providing means of addressing a specific
   store or collections of stores, a trust anchor management protocol
   can enable efficient management of all stores under a trust anchor
   manager's control.

<span class="h3"><a class="selflink" name="section-3.4" href="#section-3.4">3.4</a>.  Delegation of TA Manager Authority</span>

<span class="h4"><a class="selflink" name="section-3.4.1" href="#section-3.4.1">3.4.1</a>.  Functional Requirements</span>

   A trust anchor management protocol MUST enable secure transfer of
   control of a trust anchor store from one trust anchor manager to
   another.  It also SHOULD enable delegation for specific operations
   without requiring delegation of the overall trust anchor management
   capability itself.

<span class="h4"><a class="selflink" name="section-3.4.2" href="#section-3.4.2">3.4.2</a>.  Rationale</span>

   Trust anchor manager rekey is one type of transfer that must be
   supported.  In this case, the new key will be assigned the same
   privileges as the old key.



<span class="grey">Reddy &amp; Wallace               Informational                     [Page 8]</span>
</pre><!--NewPage--><pre class='newpage'><a name="page-9" id="page-9" href="#page-9" class="invisible"> </a>
<span class="grey"><a href="rfc6024.html">RFC 6024</a>                 Trust Anchor Management            October 2010</span>


   Creation of trust anchors for specific purposes, such as firmware
   signing, is another example of delegation.  For example, a trust
   anchor manager may delegate only the authority to sign firmware to an
   entity, but disallow further delegation of that privilege, or the
   trust anchor manager may allow its delegate to further delegate
   firmware signing authority to other entities.

<span class="h3"><a class="selflink" name="section-3.5" href="#section-3.5">3.5</a>.  <a href="rfc5280.html">RFC 5280</a> Support</span>

<span class="h4"><a class="selflink" name="section-3.5.1" href="#section-3.5.1">3.5.1</a>.  Functional Requirements</span>

   A trust anchor management protocol MUST enable management of trust
   anchors that will be used to validate certification paths and CRLs in
   accordance with [<a href="rfc5280.html" title="&quot;Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile&quot;">RFC5280</a>] and [<a href="rfc5055.html" title="&quot;Server-Based Certificate Validation Protocol (SCVP)&quot;">RFC5055</a>].  A trust anchor format MUST
   enable the representation of constraints that influence certification
   path validation or otherwise establish the scope of usage of the
   trust anchor public key.  Examples of such constraints are name
   constraints, certificate policies, and key usage.

<span class="h4"><a class="selflink" name="section-3.5.2" href="#section-3.5.2">3.5.2</a>.  Rationale</span>

   Certification path validation is one of the most common applications
   of trust anchors.  The rules for using trust anchors for path
   validation are established in [<a href="rfc5280.html" title="&quot;Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile&quot;">RFC5280</a>].  [<a href="rfc5055.html" title="&quot;Server-Based Certificate Validation Protocol (SCVP)&quot;">RFC5055</a>] describes the use
   of trust anchors for delegated path validation.  Trust anchors used
   to validate certification paths are responsible for providing,
   possibly through a delegate, the revocation status information of
   certificates it issues; this is often accomplished by signing a CRL.

<span class="h3"><a class="selflink" name="section-3.6" href="#section-3.6">3.6</a>.  Support Purposes other than Certification Path Validation</span>

<span class="h4"><a class="selflink" name="section-3.6.1" href="#section-3.6.1">3.6.1</a>.  Functional Requirements</span>

   A trust anchor management protocol MUST enable management of trust
   anchors that can be used for purposes other than certification path
   validation, including trust anchors that cannot be used for
   certification path validation.  It SHOULD be possible to authorize a
   trust anchor to delegate authority (to other TAs or certificate
   holders) and to prevent a trust anchor from delegating authority.

<span class="h4"><a class="selflink" name="section-3.6.2" href="#section-3.6.2">3.6.2</a>.  Rationale</span>

   Trust anchors are used to validate a variety of signed objects, not
   just public key certificates and CRLs.  For example, a trust anchor
   may be used to verify firmware packages [<a href="rfc4108.html" title="&quot;Using Cryptographic Message Syntax (CMS) to Protect Firmware Packages&quot;">RFC4108</a>], OCSP responses
   [<a href="rfc2560.html" title="&quot;X.509 Internet Public Key Infrastructure Online Certificate Status Protocol - OCSP&quot;">RFC2560</a>], Server-Based Certificate Validation Protocol (SCVP)
   responses [<a href="rfc5055.html" title="&quot;Server-Based Certificate Validation Protocol (SCVP)&quot;">RFC5055</a>], or timestamps [<a href="rfc3161.html" title="&quot;Internet X.509 Public Key Infrastructure Time-Stamp Protocol (TSP)&quot;">RFC3161</a>].  TAs that are
   authorized for use with some or all of these other types of



<span class="grey">Reddy &amp; Wallace               Informational                     [Page 9]</span>
</pre><!--NewPage--><pre class='newpage'><a name="page-10" id="page-10" href="#page-10" class="invisible"> </a>
<span class="grey"><a href="rfc6024.html">RFC 6024</a>                 Trust Anchor Management            October 2010</span>


   operations may not be authorized to verify public key certificates or
   CRLs.  Thus, it is important to be able to impose constraints on the
   ways in which a given TA is employed.

<span class="h3"><a class="selflink" name="section-3.7" href="#section-3.7">3.7</a>.  Trust Anchor Format</span>

<span class="h4"><a class="selflink" name="section-3.7.1" href="#section-3.7.1">3.7.1</a>.  Functional Requirements</span>

   Minimally, a trust anchor management protocol MUST support management
   of trust anchors represented as self-signed certificates and trust
   anchors represented as a distinguished name, public key information,
   and, optionally, associated data.  The definition of a trust anchor
   MUST include a public key, a public key algorithm, and, if necessary,
   public key parameters.  When the public key is used to validate
   certification paths or CRLs, a distinguished name also MUST be
   included per [<a href="rfc5280.html" title="&quot;Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile&quot;">RFC5280</a>].  A trust anchor format SHOULD enable
   specification of a public key identifier to enable other applications
   of the trust anchor, for example, verification of data signed using
   the Cryptographic Message Syntax (CMS) SignedData structure
   [<a href="rfc5652.html" title="&quot;Cryptographic Message Syntax (CMS)&quot;">RFC5652</a>].  A trust anchor format also SHOULD enable the
   representation of constraints that can be applied to restrict the use
   of a trust anchor.

<span class="h4"><a class="selflink" name="section-3.7.2" href="#section-3.7.2">3.7.2</a>.  Rationale</span>

   Prior to the publication of [<a href="rfc5914.html" title="&quot;Trust Anchor Format&quot;">RFC5914</a>], there was no standardized
   format for trust anchors.  Self-signed X.509 certificates are
   typically used, but [<a href="rfc5280.html" title="&quot;Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile&quot;">RFC5280</a>] does not mandate a particular trust
   anchor representation.  It requires only that a trust anchor's public
   key information and distinguished name be available during
   certification path validation.  CMS is widely used to protect a
   variety of types of content using digital signatures, including
   contents that may be verified directly using a trust anchor, such as
   firmware packages [<a href="rfc4108.html" title="&quot;Using Cryptographic Message Syntax (CMS) to Protect Firmware Packages&quot;">RFC4108</a>].  Constraints may include a validity
   period, constraints on certification path validation, etc.

<span class="h3"><a class="selflink" name="section-3.8" href="#section-3.8">3.8</a>.  Source Authentication</span>

<span class="h4"><a class="selflink" name="section-3.8.1" href="#section-3.8.1">3.8.1</a>.  Functional Requirements</span>

   An entity receiving trust anchor management data MUST be able to
   authenticate the identity of the party providing the information and
   MUST be able to confirm the party is authorized to provide that trust
   anchor information.







<span class="grey">Reddy &amp; Wallace               Informational                    [Page 10]</span>
</pre><!--NewPage--><pre class='newpage'><a name="page-11" id="page-11" href="#page-11" class="invisible"> </a>
<span class="grey"><a href="rfc6024.html">RFC 6024</a>                 Trust Anchor Management            October 2010</span>


   A trust anchor manager MUST be able to authenticate which trust
   anchor store corresponds to a report listing the contents of the
   trust anchor store and be able to confirm the contents of the report
   have not been subsequently altered.

<span class="h4"><a class="selflink" name="section-3.8.2" href="#section-3.8.2">3.8.2</a>.  Rationale</span>

   Data origin authentication and integrity are required to support
   remote management operations, even when TA management transactions
   are effected via store-and-forward communications.

<span class="h3"><a class="selflink" name="section-3.9" href="#section-3.9">3.9</a>.  Reduce Reliance on Out-of-Band Trust Mechanisms</span>

<span class="h4"><a class="selflink" name="section-3.9.1" href="#section-3.9.1">3.9.1</a>.  Functional Requirements</span>

   When performing add operations, a trust anchor management protocol
   SHOULD enable TA integrity to be checked automatically by a relying
   party without relying on out-of-band trust mechanisms.

<span class="h4"><a class="selflink" name="section-3.9.2" href="#section-3.9.2">3.9.2</a>.  Rationale</span>

   Traditionally, a trust anchor is distributed out-of-band with its
   integrity checked manually prior to installation.  Installation
   typically is performed by anyone with sufficient administrative
   privilege on the system receiving the trust anchor.  Reliance on out-
   of-band trust mechanisms is one problem with current trust anchor
   management approaches, and reduction of the need to use out-of-band
   trust mechanisms is a primary motivation for developing a trust
   anchor management protocol.  Ideally, out-of-band trust mechanisms
   will be required only during trust anchor store initialization.

<span class="h3"><a class="selflink" name="section-3.10" href="#section-3.10">3.10</a>.  Replay Detection</span>

<span class="h4"><a class="selflink" name="section-3.10.1" href="#section-3.10.1">3.10.1</a>.  Functional Requirements</span>

   A trust anchor management protocol MUST enable participants engaged
   in a trust anchor management protocol exchange to detect replay
   attacks.  A replay detection mechanism that does not introduce a
   requirement for a reliable source of time MUST be available.
   Mechanisms that do require a reliable source of time MAY be
   available.

<span class="h4"><a class="selflink" name="section-3.10.2" href="#section-3.10.2">3.10.2</a>.  Rationale</span>

   Detection of replays of trust anchor management transactions is
   required to support remote management operations.  Replay of old
   trust anchor management transactions could result in the




<span class="grey">Reddy &amp; Wallace               Informational                    [Page 11]</span>
</pre><!--NewPage--><pre class='newpage'><a name="page-12" id="page-12" href="#page-12" class="invisible"> </a>
<span class="grey"><a href="rfc6024.html">RFC 6024</a>                 Trust Anchor Management            October 2010</span>


   reintroduction of compromised trust anchors to a trust anchor store,
   potentially exposing applications to malicious signed objects or
   certification paths.

   Some devices that utilize trust anchors have no access to a reliable
   source of time, so a replay detection mechanism that requires a
   reliable time source is insufficient.

<span class="h3"><a class="selflink" name="section-3.11" href="#section-3.11">3.11</a>.  Compromise or Disaster Recovery</span>

<span class="h4"><a class="selflink" name="section-3.11.1" href="#section-3.11.1">3.11.1</a>.  Functional Requirements</span>

   A trust anchor management protocol MUST enable recovery from the
   compromise or loss of a trust anchor private key, including the
   private key authorized to serve as a trust anchor manager, without
   requiring re-initialization of the trust store.

<span class="h4"><a class="selflink" name="section-3.11.2" href="#section-3.11.2">3.11.2</a>.  Rationale</span>

   Compromise or loss of a private key corresponding to a trust anchor
   can have significant negative consequences.  Currently, in some
   cases, re-initialization of all affected trust anchor stores is
   required to recover from a lost or compromised trust anchor key.  Due
   to the costs associated with re-initialization, a trust anchor
   management protocol should support recovery options that do not
   require trust anchor store re-initialization.

<span class="h2"><a class="selflink" name="section-4" href="#section-4">4</a>.  Security Considerations</span>

   The public key used to authenticate a TA management transaction may
   have been placed in the client as the result of an earlier TA
   management transaction or during an initial bootstrap configuration
   operation.  In most scenarios, at least one public key authorized for
   trust anchor management must be placed in each trust anchor store to
   be managed during the initial configuration of the trust anchor
   store.  This public key may be transported and checked using out-of-
   band means.  In all scenarios, regardless of the authentication
   mechanism, at least one trust anchor manager must be established for
   each trust anchor store during the initial configuration of the trust
   anchor store.

   Compromise of a trust anchor's private key can result in many
   security problems including issuance of bogus certificates or
   installation of rogue trust anchors.

   Usage of trust anchor-based constraints requires great care when
   defining trust anchors.  Errors on the part of a trust anchor manager
   could result in denial of service or have serious security



<span class="grey">Reddy &amp; Wallace               Informational                    [Page 12]</span>
</pre><!--NewPage--><pre class='newpage'><a name="page-13" id="page-13" href="#page-13" class="invisible"> </a>
<span class="grey"><a href="rfc6024.html">RFC 6024</a>                 Trust Anchor Management            October 2010</span>


   consequences.  For example, if a name constraint for a trust anchor
   that serves as the root of a PKI includes a typo, denial of service
   results for certificate holders and relying parties.  If a trust
   anchor manager inadvertently delegates all of its privileges and the
   delegate subsequently removes the trust anchor manager from trust
   anchor stores now under its control, recovery may require
   re-initialization of all effected trust anchor stores.

   <a href="rfc5280.html">RFC 5280</a> requires that certificate path validation be initialized
   with a TA subject name and public key, but does not require
   processing of other information, such as name constraints extensions.
   Inclusion of constraints in trust anchors is optional.  When
   constraints are explicitly included by a trust anchor manager using a
   trust anchor management protocol, there exists an expectation that
   the certificate path validation algorithm will make use of the
   constraints.  Application owners must confirm the path processing
   implementations support the processing of TA-based constraints, where
   required.

   Many of the security considerations from [<a href="rfc5280.html" title="&quot;Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile&quot;">RFC5280</a>] are also
   applicable to trust anchor management.

<span class="h2"><a class="selflink" name="section-5" href="#section-5">5</a>.  References</span>

<span class="h3"><a class="selflink" name="section-5.1" href="#section-5.1">5.1</a>.  Normative References</span>

   [<a name="ref-RFC2119" id="ref-RFC2119">RFC2119</a>]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", <a href="http://tools.ietf.org/html/bcp14">BCP 14</a>, <a href="rfc2119.html">RFC 2119</a>, March 1997.

   [<a name="ref-RFC5055" id="ref-RFC5055">RFC5055</a>]  Freeman, T., Housley, R., Malpani, A., Cooper, D., and W.
              Polk, "Server-Based Certificate Validation Protocol
              (SCVP)", <a href="rfc5055.html">RFC 5055</a>, December 2007.

   [<a name="ref-RFC5280" id="ref-RFC5280">RFC5280</a>]  Cooper, D., Santesson, S., Farrell, S., Boeyen, S.,
              Housley, R., and W. Polk, "Internet X.509 Public Key
              Infrastructure Certificate and Certificate Revocation List
              (CRL) Profile", <a href="rfc5280.html">RFC 5280</a>, May 2008.

<span class="h3"><a class="selflink" name="section-5.2" href="#section-5.2">5.2</a>.  Informative References</span>

   [<a name="ref-RFC2560" id="ref-RFC2560">RFC2560</a>]  Myers, M., Ankney, R., Malpani, A., Galperin, S., and C.
              Adams, "X.509 Internet Public Key Infrastructure Online
              Certificate Status Protocol - OCSP", <a href="rfc2560.html">RFC 2560</a>, June 1999.

   [<a name="ref-RFC3161" id="ref-RFC3161">RFC3161</a>]  Adams, C., Cain, P., Pinkas, D., and R. Zuccherato,
              "Internet X.509 Public Key Infrastructure Time-Stamp
              Protocol (TSP)", <a href="rfc3161.html">RFC 3161</a>, August 2001.




<span class="grey">Reddy &amp; Wallace               Informational                    [Page 13]</span>
</pre><!--NewPage--><pre class='newpage'><a name="page-14" id="page-14" href="#page-14" class="invisible"> </a>
<span class="grey"><a href="rfc6024.html">RFC 6024</a>                 Trust Anchor Management            October 2010</span>


   [<a name="ref-RFC4108" id="ref-RFC4108">RFC4108</a>]  Housley, R., "Using Cryptographic Message Syntax (CMS) to
              Protect Firmware Packages", <a href="rfc4108.html">RFC 4108</a>, August 2005.

   [<a name="ref-RFC4210" id="ref-RFC4210">RFC4210</a>]  Adams, C., Farrell, S., Kause, T., and T. Mononen,
              "Internet X.509 Public Key Infrastructure Certificate
              Management Protocol (CMP)", <a href="rfc4210.html">RFC 4210</a>, September 2005.

   [<a name="ref-RFC5652" id="ref-RFC5652">RFC5652</a>]  Housley, R., "Cryptographic Message Syntax (CMS)", STD 70,
              <a href="rfc5652.html">RFC 5652</a>, September 2009.

   [<a name="ref-RFC5914" id="ref-RFC5914">RFC5914</a>]  Housley, R., Ashmore, S., and C. Wallace, "Trust Anchor
              Format", <a href="rfc5914.html">RFC 5914</a>, June 2010.

   [<a name="ref-RFC5934" id="ref-RFC5934">RFC5934</a>]  Housley, R., Ashmore, S., and C. Wallace, "Trust Anchor
              Management Protocol (TAMP)", <a href="rfc5934.html">RFC 5934</a>, August 2010.

Authors' Addresses

   Raksha Reddy
   National Security Agency
   Suite 6599
   9800 Savage Road
   Fort Meade, MD  20755

   EMail: r.reddy@radium.ncsc.mil


   Carl Wallace
   Cygnacom Solutions
   Suite 5400
   7925 Jones Branch Drive
   McLean, VA  22102

   EMail: cwallace@cygnacom.com

















Reddy &amp; Wallace               Informational                    [Page 14]

</pre><br />
<span class="noprint"><small><small>Html markup produced by rfcmarkup 1.107, available from
<a href="http://tools.ietf.org/tools/rfcmarkup/">http://tools.ietf.org/tools/rfcmarkup/</a>
</small></small></span>
</body>
<!-- Mirrored from tools.ietf.org/html/rfc6024 by HTTrack Website Copier/3.x [XR&CO'2010], Wed, 19 Mar 2014 18:35:11 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
</html>
