<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml"><!-- Mirrored from tools.ietf.org/html/rfc5210 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 06 Mar 2018 23:18:36 GMT --><!-- Added by HTTrack --><head><meta content="text/html;charset=utf-8" http-equiv="content-type"/><!-- /Added by HTTrack -->

    <meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
    <meta content="index,follow" name="robots"/>
    <meta content="rfcmarkup version 1.126" name="creator"/>
    <link href="http://purl.org/dc/elements/1.1/" rel="schema.DC"/>
<meta content="urn:ietf:rfc:5210" name="DC.Identifier"/>
<meta content="Because the Internet forwards packets according to the IP destination
address, packet forwarding typically takes place without inspection of
the source address and malicious attacks have been launched using
spoofed source addresses. In an effort to enhance the Internet with IP
source address validation, a prototype implementation of the IP Source
Address Validation Architecture (SAVA) was created and an evaluation
was conducted on an IPv6 network. This document reports on the
prototype implementation and the test results, as well as the lessons
and insights gained from experimentation. This memo defines an
Experimental Protocol for the Internet community." name="DC.Description.Abstract"/>
<meta content="Bi, Jun" name="DC.Creator"/>
<meta content="Xu, Ke" name="DC.Creator"/>
<meta content="Li, Xing" name="DC.Creator"/>
<meta content="Williams, Mark" name="DC.Creator"/>
<meta content="Wu, Jianping" name="DC.Creator"/>
<meta content="Ren, Gang" name="DC.Creator"/>
<meta content="June, 2008" name="DC.Date.Issued"/>
<meta content="A Source Address Validation Architecture (SAVA) Testbed and Deployment Experience" name="DC.Title"/>

    <link href="https://tools.ietf.org/images/rfc.png" rel="icon" type="image/png"/>
    <link href="https://tools.ietf.org/images/rfc.png" rel="shortcut icon" type="image/png"/>
    <title>RFC 5210 - A Source Address Validation Architecture (SAVA) Testbed and Deployment Experience</title>
    
    
    <style type="text/css">
	@media only screen 
	  and (min-width: 992px)
	  and (max-width: 1199px) {
	    body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 768px)
	  and (max-width: 991px) {
            body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 480px)
	  and (max-width: 767px) {
            body { font-size: 11pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (max-width: 479px) {
            body { font-size: 8pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-device-width : 375px) 
	  and (max-device-width : 667px) {
            body { font-size: 9.5pt; }
            div.content { width: 96ex; margin: 0 1px; }
        }
	@media only screen 
	  and (min-device-width: 1200px) {
            body { font-size: 10pt; margin: 0 4em; }
            div.content { width: 96ex; margin: 0; }
        }
        h1, h2, h3, h4, h5, h6, .h1, .h2, .h3, .h4, .h5, .h6 {
	    font-weight: bold;
            line-height: 0pt;
            display: inline;
            white-space: pre;
            font-family: monospace;
            font-size: 1em;
	    font-weight: bold;
        }
        pre {
            font-size: 1em;
            margin-top: 0px;
            margin-bottom: 0px;
        }
	.pre {
	    white-space: pre;
	    font-family: monospace;
	}
	.header{
	    font-weight: bold;
	}
        .newpage {
            page-break-before: always;
        }
        .invisible {
            text-decoration: none;
            color: white;
        }
        a.selflink {
          color: black;
          text-decoration: none;
        }
        @media print {
            body {
                font-family: monospace;
                font-size: 10.5pt;
            }
            h1, h2, h3, h4, h5, h6 {
                font-size: 1em;
            }
        
            a:link, a:visited {
                color: inherit;
                text-decoration: none;
            }
            .noprint {
                display: none;
            }
        }
	@media screen {
	    .grey, .grey a:link, .grey a:visited {
		color: #777;
	    }
            .docinfo {
                background-color: #EEE;
            }
            .top {
                border-top: 7px solid #EEE;
            }
            .bgwhite  { background-color: white; }
            .bgred    { background-color: #F44; }
            .bggrey   { background-color: #666; }
            .bgbrown  { background-color: #840; }            
            .bgorange { background-color: #FA0; }
            .bgyellow { background-color: #EE0; }
            .bgmagenta{ background-color: #F4F; }
            .bgblue   { background-color: #66F; }
            .bgcyan   { background-color: #4DD; }
            .bggreen  { background-color: #4F4; }

            .legend   { font-size: 90%; }
            .cplate   { font-size: 70%; border: solid grey 1px; }
	}
    </style>
    <!--[if IE]>
    <style>
    body {
       font-size: 13px;
       margin: 10px 10px;
    }
    </style>
    <![endif]-->

    <script type="text/javascript"><!--
    function addHeaderTags() {
	var spans = document.getElementsByTagName("span");
	for (var i=0; i < spans.length; i++) {
	    var elem = spans[i];
	    if (elem) {
		var level = elem.getAttribute("class");
                if (level == "h1" || level == "h2" || level == "h3" || level == "h4" || level == "h5" || level == "h6") {
                    elem.innerHTML = "<"+level+">"+elem.innerHTML+"</"+level+">";		
                }
	    }
	}
    }
    var legend_html = "Colour legend:<br />      <table>         <tr><td>Unknown:</td>                   <td><span class='cplate bgwhite'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft:</td>                     <td><span class='cplate bgred'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Informational:</td>             <td><span class='cplate bgorange'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Experimental:</td>              <td><span class='cplate bgyellow'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Best Common Practice:</td>      <td><span class='cplate bgmagenta'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Proposed Standard:</td>         <td><span class='cplate bgblue'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft Standard (old designation):</td> <td><span class='cplate bgcyan'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Internet Standard:</td>         <td><span class='cplate bggreen'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Historic:</td>                  <td><span class='cplate bggrey'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Obsolete:</td>                  <td><span class='cplate bgbrown'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>     </table>";
    function showElem(id) {
        var elem = document.getElementById(id);
        elem.innerHTML = eval(id+"_html");
        elem.style.visibility='visible';
    }
    function hideElem(id) {
        var elem = document.getElementById(id);
        elem.style.visibility='hidden';        
        elem.innerHTML = "";
    }
    // -->
    </script>
</head>
<body onload="addHeaderTags()">
  <div class="content">
   <div style="height: 13px;">
      <div class="pre noprint docinfo bgyellow" onclick="showElem('legend');" onmouseout="hideElem('legend')" onmouseover="this.style.cursor='pointer';" style="height: 6px; position: absolute;" title="Click for colour legend.">                                                                        </div>
      <div class="docinfo noprint pre legend" id="legend" onmouseout="hideElem('legend');" onmouseover="showElem('legend');" style="position:absolute; top: 4px; left: 4ex; visibility:hidden; background-color: white; padding: 4px 9px 5px 7px; border: solid #345 1px; ">
      </div>
   </div>
<span class="pre noprint docinfo top">[<a href="index.html" title="Document search and retrieval page">Docs</a>] [<a href="https://tools.ietf.org/rfc/rfc5210.txt" title="Plaintext version of this document">txt</a>|<a href="https://tools.ietf.org/pdf/rfc5210" title="PDF version of this document">pdf</a>] [<a href="https://tools.ietf.org/html/draft-wu-sava-testbed-experience" title="draft-wu-sava-testbed-experience">draft-wu-sava-t...</a>] [<a href="https://datatracker.ietf.org/doc/rfc5210" title="IESG Datatracker information for this document">Tracker</a>] [<a href="https://tools.ietf.org/rfcdiff?difftype=--hwdiff&amp;url2=rfc5210" title="Inline diff (wdiff)">Diff1</a>] [<a href="https://tools.ietf.org/rfcdiff?url2=rfc5210" title="Side-by-side diff">Diff2</a>]         </span><br/>
<span class="pre noprint docinfo">                                                                        </span><br/>
<span class="pre noprint docinfo">                                                            EXPERIMENTAL</span><br/>
<span class="pre noprint docinfo">                                                                        </span><br/>
<pre>Network Working Group                                              J. Wu
Request for Comments: 5210                                         J. Bi
Category: Experimental                                             X. Li
                                                                  G. Ren
                                                                   K. Xu
                                                     Tsinghua University
                                                             M. Williams
                                                        Juniper Networks
                                                               June 2008


        <span class="h1">A Source Address Validation Architecture (SAVA) Testbed</span>
                       <span class="h1">and Deployment Experience</span>

Status of This Memo

   This memo defines an Experimental Protocol for the Internet
   community.  It does not specify an Internet standard of any kind.
   Discussion and suggestions for improvement are requested.
   Distribution of this memo is unlimited.

Abstract

   Because the Internet forwards packets according to the IP destination
   address, packet forwarding typically takes place without inspection
   of the source address and malicious attacks have been launched using
   spoofed source addresses.  In an effort to enhance the Internet with
   IP source address validation, a prototype implementation of the IP
   Source Address Validation Architecture (SAVA) was created and an
   evaluation was conducted on an IPv6 network.  This document reports
   on the prototype implementation and the test results, as well as the
   lessons and insights gained from experimentation.



















<span class="grey">Wu, et al.                    Experimental                      [Page 1]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-2" id="page-2" name="page-2"> </a>
<span class="grey"><a href="rfc5210.html">RFC 5210</a>                      SAVA Testbed                     June 2008</span>


Table of Contents

   <a href="#section-1">1</a>.  Introduction . . . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-3">3</a>
   <a href="#section-2">2</a>.  A Prototype SAVA Implementation  . . . . . . . . . . . . . . .  <a href="#page-4">4</a>
     <a href="#section-2.1">2.1</a>.  Solution Overview  . . . . . . . . . . . . . . . . . . . .  <a href="#page-4">4</a>
     <a href="#section-2.2">2.2</a>.  IP Source Address Validation in the Access Network . . . .  <a href="#page-6">6</a>
     <a href="#section-2.3">2.3</a>.  IP Source Address Validation at Intra-AS/Ingress Point . .  <a href="#page-9">9</a>
     2.4.  IP Source Address Validation in the Inter-AS Case
           (Neighboring AS) . . . . . . . . . . . . . . . . . . . . .  <a href="#page-9">9</a>
     2.5.  IP Source Address Validation in the Inter-AS Case
           (Non-Neighboring AS) . . . . . . . . . . . . . . . . . . . <a href="#page-12">12</a>
   <a href="#section-3">3</a>.  SAVA Testbed . . . . . . . . . . . . . . . . . . . . . . . . . <a href="#page-15">15</a>
     <a href="#section-3.1">3.1</a>.  CNGI-CERNET2 . . . . . . . . . . . . . . . . . . . . . . . <a href="#page-15">15</a>
     <a href="#section-3.2">3.2</a>.  SAVA Testbed on CNGI-CERNET2 Infrastructure  . . . . . . . <a href="#page-16">16</a>
   <a href="#section-4">4</a>.  Test Experience and Results  . . . . . . . . . . . . . . . . . <a href="#page-17">17</a>
     <a href="#section-4.1">4.1</a>.  Test Scenarios . . . . . . . . . . . . . . . . . . . . . . <a href="#page-17">17</a>
     <a href="#section-4.2">4.2</a>.  Test Results . . . . . . . . . . . . . . . . . . . . . . . <a href="#page-18">18</a>
   <a href="#section-5">5</a>.  Limitations and Issues . . . . . . . . . . . . . . . . . . . . <a href="#page-18">18</a>
     <a href="#section-5.1">5.1</a>.  General Issues . . . . . . . . . . . . . . . . . . . . . . <a href="#page-18">18</a>
     <a href="#section-5.2">5.2</a>.  Security Issues  . . . . . . . . . . . . . . . . . . . . . <a href="#page-20">20</a>
     <a href="#section-5.3">5.3</a>.  Protocol Details . . . . . . . . . . . . . . . . . . . . . <a href="#page-20">20</a>
   <a href="#section-6">6</a>.  Conclusion . . . . . . . . . . . . . . . . . . . . . . . . . . <a href="#page-21">21</a>
   <a href="#section-7">7</a>.  Security Considerations  . . . . . . . . . . . . . . . . . . . <a href="#page-22">22</a>
   <a href="#section-8">8</a>.  Acknowledgements . . . . . . . . . . . . . . . . . . . . . . . <a href="#page-22">22</a>
   <a href="#section-9">9</a>.  References . . . . . . . . . . . . . . . . . . . . . . . . . . <a href="#page-23">23</a>
     <a href="#section-9.1">9.1</a>.  Normative References . . . . . . . . . . . . . . . . . . . <a href="#page-23">23</a>
     <a href="#section-9.2">9.2</a>.  Informative References . . . . . . . . . . . . . . . . . . <a href="#page-23">23</a>
























<span class="grey">Wu, et al.                    Experimental                      [Page 2]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-3" id="page-3" name="page-3"> </a>
<span class="grey"><a href="rfc5210.html">RFC 5210</a>                      SAVA Testbed                     June 2008</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/1.%20%20Introduction"></a><a class="selflink" href="#section-1" name="section-1">1</a>.  Introduction</span>

   By design, the Internet forwards data packets solely based on the
   destination IP address.  The source IP address is not checked during
   the forwarding process in most cases.  This makes it easy for
   malicious hosts to spoof the source address of the IP packet.  We
   believe that it would be useful to enforce the validity of the source
   IP address for all the packets being forwarded.

   Enforcing the source IP address validity would help us achieve the
   following goals:

   o  Since packets which carry spoofed source addresses would not be
      forwarded, it would be impossible to launch network attacks that
      are enabled by using spoofed source addresses and more difficult
      to successfully carry out attacks enhanced or strengthened by the
      use of spoofed source addresses.

   o  Being able to assume that all packet source addresses are correct
      would allow traceback to be accomplished accurately and with
      confidence.  This would benefit network diagnosis, management,
      accounting, and applications.

   As part of the effort in developing a Source Address Validation
   Architecture (SAVA), we implemented a SAVA prototype and deployed the
   prototype in 12 ASes in an operational network as part of China Next
   Generation Internet (CNGI) Project [<a href="#ref-Wu07" title='"Source Address Validation: Architecture and Protocol Design"'>Wu07</a>].  We conducted evaluation
   experiments.  In this document, we first describe the prototype
   solutions and then report experimental results.  We hope that this
   document can provide useful insights to those interested in the
   subject, and can serve as an initial input to future IETF effort in
   this area.

   In recent years, there have been a number of research and engineering
   efforts to design IP source address validation mechanisms, such as
   [<a href="rfc2827.html" title='"Network Ingress Filtering: Defeating Denial of Service Attacks which employ IP Source Address Spoofing"'>RFC2827</a>], [<a href="#ref-Park01" title='"On the effectiveness of route-based packet filtering for distributed DoS attack prevention in power-law internets"'>Park01</a>], [<a href="#ref-Li02" title='"SAVE: Source Address Validity Enforcement Protocol"'>Li02</a>], [<a href="#ref-Brem05" title='"Spoofing Prevention Method"'>Brem05</a>], and [<a href="#ref-Snoe01" title='"A Hash-based IP traceback"'>Snoe01</a>].  Our SAVA
   prototype implementation was inspired by some of the schemes from the
   proposed or existing solutions.

   The prototype implementation and experimental results presented in
   this report serve only as an input, and by no means preempt any
   solution development that may be carried out by future IETF effort.
   Indeed, the presented solutions are experimental approaches and have
   a number of limitations as discussed in Sections <a href="#section-5">5</a> and <a href="#section-6">6</a>.







<span class="grey">Wu, et al.                    Experimental                      [Page 3]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-4" id="page-4" name="page-4"> </a>
<span class="grey"><a href="rfc5210.html">RFC 5210</a>                      SAVA Testbed                     June 2008</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/2.%20%20A%20Prototype%20SAVA%20Implementation"></a><a class="selflink" href="#section-2" name="section-2">2</a>.  A Prototype SAVA Implementation</span>

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/2.1.%20%20Solution%20Overview"></a><a class="selflink" href="#section-2.1" name="section-2.1">2.1</a>.  Solution Overview</span>

   A multiple-fence solution is proposed in this document.  That is,
   there are multiple points in the network at which the validity of a
   packet's source address can be checked.  This is because in the
   current single-fence model where source address validity is
   essentially checked only at ingress to the network, deployment has
   been inadequate to the point that there is always sufficient
   opportunity to mount attacks based on spoofed source addresses, and
   it seems likely that this condition will continue in the foreseeable
   future.  A multiple-fence solution will allow "holes" in deployment
   to be covered and validity of the source address to be evaluated with
   increased confidence across the whole Internet.  The assumption here
   is that when validity checking is not universal, it is still
   worthwhile to increase the confidence in the validity of source
   addresses and to reduce the opportunities to mount a source address
   spoofing attack.

   Furthermore, the architecture allows for multiple independent and
   loosely-coupled checking mechanisms.  The motivation for this is that
   in the Internet at large, it is unrealistic to expect any single IP
   source address validation mechanism to be universally supported.
   Different operators and vendors may choose to deploy/develop
   different mechanisms to achieve the same end, and there need to be
   different mechanisms to solve the problem at different places in the
   network.  Furthermore, implementation bugs or configuration errors
   could potentially render an implementation ineffective.  Therefore,
   our prototype SAVA implementation is a combination of multiple
   coexisting and cooperating mechanisms.  More specifically, we
   implement source IP address validation at three levels: access
   network source address validation; intra-AS source address
   validation; and inter-AS source address validation, as shown in
   Figure 1.  The system details can be found in [<a href="#ref-Wu07" title='"Source Address Validation: Architecture and Protocol Design"'>Wu07</a>].
















<span class="grey">Wu, et al.                    Experimental                      [Page 4]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-5" id="page-5" name="page-5"> </a>
<span class="grey"><a href="rfc5210.html">RFC 5210</a>                      SAVA Testbed                     June 2008</span>


                     __ ____                          __ ____
                 .-''       `':                   .-''       `':
                 |             |                  |             |
                 |   +-+----+  |   Inter-AS SAV   |   +-+----+  |
                 |   |Router+--+------------------+---|Router+  +
                 |   +--.---+  |                  |   +--.---+  |
      Intra-AS   |      |       \      Intra-AS   |      |      |
         SAV     |   +--+---+    \        SAV     |   +--+---+  |
                 |   |Router|     \               |   |Router|  |
                 |   +--.---+      \               '_  +-----+  _
                 |      |           \               `'-------'''
                /       |            \
               /        |             \
              | +---------------------+\
          ----+---------. Router      | \
              | ++-------\------------+  \
              |  |     |  \    |     |    |

              |  | +------+|+------++----+|Intra-AS
              |  | |Switch|||Switch||Host||SAV

              |  | +------+|+------++----+|

              |  |     |   |  |    \      |

              |+-+--++----+|+----++----+  |

              ||Host||Host|||Host||Host|  |
              `+----++----+|+----++----+ /

                `--.       |         _.-'
                    `------|------+''
                 Access    |
                 Network   |
                  SAV

       Key:  SAV - Source Address Validation

                        Figure 1: Solution Overview

   This document divides source address validation into three different
   classes of solutions:

   1.  Access network.  This prevents a host in a network from spoofing
       the address of another host in the same network segment.  This
       enables host-granularity of protection compared to Intra-AS
       prevention.  See <a href="#section-2.2">Section 2.2</a> for details.




<span class="grey">Wu, et al.                    Experimental                      [Page 5]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-6" id="page-6" name="page-6"> </a>
<span class="grey"><a href="rfc5210.html">RFC 5210</a>                      SAVA Testbed                     June 2008</span>


   2.  Intra-AS.  When the edge router of an access network performs
       source address validation (e.g., using [<a href="rfc2827.html" title='"Network Ingress Filtering: Defeating Denial of Service Attacks which employ IP Source Address Spoofing"'>RFC2827</a>] and [<a href="rfc3704.html" title='"Ingress Filtering for Multihomed Networks"'>RFC3704</a>]),
       hosts are prevented from spoofing an arbitrary address, but
       unless access network SAV is employed, they may be able to spoof
       an address of a host in the same network segment.  In a
       degenerate case, when a router connects a single host, the host
       can't spoof any address.

   3.  Inter-AS.  Mechanisms that enforce packet source address
       correctness at AS boundaries.  Because the global Internet has a
       mesh topology, and because different networks belong to different
       administrative authorities, IP source address validation at the
       Inter-AS level is more challenging.  Nevertheless, we believe
       this third level of protection is necessary to detect packets
       with spoofed source addresses, when the first two levels of
       source address validation are missing or ineffective.

   In the following sections, we describe the specific mechanisms
   implemented at each of the three levels in detail.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/2.2.%20%20IP%20Source%20Address%20Validation%20in%20the%20Access%20Network"></a><a class="selflink" href="#section-2.2" name="section-2.2">2.2</a>.  IP Source Address Validation in the Access Network</span>

   At the access network level, the solution ensures the host inside the
   access network cannot use the source address of another host.  The
   host address should be a valid address assigned to the host
   statically or dynamically.  The solution implemented in the
   experiment provides such a function for Ethernet networks.  A layer-3
   source address validation architecture device (SAVA Device) for the
   access network (the device can be a function inside the Customer
   Premises Equipment (CPE) router or a separate device) is deployed at
   the exit of the access network.  Source address validation
   architecture agents (SAVA Agents) are deployed inside the access
   network.  (In fact, these agents could be a function inside the first
   hop router/switch connected to the hosts.)  A set of protocols was
   designed for communication between the host, SAVA Agent, and SAVA
   Device.  Only a packet originating from the host that was assigned
   that particular source address may pass through the SAVA Agent and
   SAVA Device.

   Two possible deployment variants exist; we will call them Variant A
   and Variant B.  In Variant A, an agent is mandatory and each host is
   attached to the agent on a dedicated physical port.  In Variant B,
   hosts are required to perform network access authentication and
   generate key material needed to protect each packet.  In this
   variant, the agent is optional.






<span class="grey">Wu, et al.                    Experimental                      [Page 6]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-7" id="page-7" name="page-7"> </a>
<span class="grey"><a href="rfc5210.html">RFC 5210</a>                      SAVA Testbed                     June 2008</span>


   The key function of Variant A is to create a dynamic binding between
   a switch port and valid source IP address, or a binding between Media
   Access Control (MAC) address, source IP address, and switch port.  In
   the prototype, this is established by having hosts employ a new
   address configuration protocol that the switch is capable of
   tracking.

   Note:  In a production environment, the approach in the prototype
      would not be sufficient due to reasons discussed in <a href="#section-5">Section 5</a>.

   In Variant A, there are three main participants: Source Address
   Request Client (SARC) on the host, Source Address Validation Proxy
   (SAVP) on the switch, and Source Address Management Server (SAMS). as
   shown in Figure 2.  The solution follows the basic steps below:

   1.  The SARC on the end host sends an IP address request.  The SAVP
       on the switch relays this request to the SAMS and records the MAC
       address and incoming port.  If the address has already been
       predetermined by the end host, the end host still needs to put
       that address in the request message for verification by SAMS.

   2.  After the SAMS receives the IP address request, it then allocates
       a source address for that SARC based on the address allocation
       and management policy of the access network, it stores the
       allocation of the IP address in the SAMS history database for
       traceback, then sends response message containing the allocated
       address to the SARC.

   3.  After the SAVP on the access switch receives the response, it
       binds the IP address and the former stored MAC address of the
       request message with the switch port on the binding table.  Then,
       it forwards the issued address to SARC on the end host.

   4.  The access switch begins to filter packets sent from the end
       host.  Packets which do not conform to the tuple (IP address,
       Switch Port) are discarded.















<span class="grey">Wu, et al.                    Experimental                      [Page 7]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-8" id="page-8" name="page-8"> </a>
<span class="grey"><a href="rfc5210.html">RFC 5210</a>                      SAVA Testbed                     June 2008</span>


                         ----------------
                         | SERVER        |
                         |    -------    |
                         |    | SAMS |   |
                         |    --------   |
                         -----------------
                                 |
                                 |
                         ----------------
                         | SWITCH        |
                         |    -------    |
                         |    | SAVP |   |
                         |    --------   |
                         -----------------
                                 |
                                 |
                         ----------------
                         | END HOST      |
                         |    -------    |
                         |    | SARC |   |
                         |    --------   |
                         -----------------

         Key:     SARC - Source Address Request Client
                  SAVP - Source Address Validation Proxy
                  SAMS - Source Address Management Sever

           Figure 2: Binding-Based IP Source Address Validation
                           in the Access Network

   The main idea of Variant B is to employ key material from network
   access authentication for some additional validation process.  A
   session key is derived for each host connecting to the network, and
   each packet sent by the host has cryptographic protection that
   employs this session key.  After establishing which host the packet
   comes from, it again becomes possible to track whether the addresses
   allocated to the host match those used by the host.  The mechanism
   details can be found in [<a href="#ref-XBW07" title='"An Authentication based Source Address Spoofing Prevention Method Deployed in IPv6 Edge Network"'>XBW07</a>], but the process follows these basic
   steps:

   1.  When a host wants to establish connectivity, it needs to perform
       network access authentication.

   2.  The network access devices provide the SAVA Agent (often co-
       located) a session key S.  This key is further distributed to the
       SAVA Device.  The SAVA Device binds the session key and the
       host's IP address.




<span class="grey">Wu, et al.                    Experimental                      [Page 8]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-9" id="page-9" name="page-9"> </a>
<span class="grey"><a href="rfc5210.html">RFC 5210</a>                      SAVA Testbed                     June 2008</span>


   3.  When the host sends packet M to somewhere outside the access
       network, either the host or the SAVA Agent needs to generate a
       message authentication code for each using key S and packet M.
        In the prototype, the message authentication code is carried in
       an experimental IPv6 extension header.

   4.  The SAVA Device uses the session key to authenticate the
       signature carried in the packet so that it can validate the
       source address.

   In our testbed, we implemented and tested both solutions.  The
   switch-based solution has better performance, but the switches in the
   access network would need to be upgraded (usually the number of
   switches in an access network is large).  The signature-based
   solution could be deployed between the host and the exit router, but
   it has some extra cost in inserting and validating the signature.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/2.3.%20%20IP%20Source%20Address%20Validation%20at%20Intra-AS%2FIngress%20Point"></a><a class="selflink" href="#section-2.3" name="section-2.3">2.3</a>.  IP Source Address Validation at Intra-AS/Ingress Point</span>

   We adopted the solution of the source address validation of IP
   packets at ingress points described in [<a href="rfc2827.html" title='"Network Ingress Filtering: Defeating Denial of Service Attacks which employ IP Source Address Spoofing"'>RFC2827</a>] and [<a href="rfc3704.html" title='"Ingress Filtering for Multihomed Networks"'>RFC3704</a>]; the
   latter describes source address validation at the ingress points of
   multi-homed access networks.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/2.4.%20%20IP%20Source%20Address%20Validation%20in%20the%20Inter-AS%20Case%20%28Neighboring%20AS%29"></a><a class="selflink" href="#section-2.4" name="section-2.4">2.4</a>.  IP Source Address Validation in the Inter-AS Case (Neighboring AS)</span>

   Our design for the Inter-AS Source Address Validation included the
   following characteristics: It should cooperate among different ASes
   with different administrative authorities and different interests.
   It should be lightweight enough to support high throughput and not to
   influence forwarding efficiency.

   The inter-AS level of SAVA can be classified into two sub-cases:

   o  Two SAVA-compliant ASes exchanging traffic are directly connected;

   o  Two SAVA-compliant ASes are separated by one or more intervening,
      non-SAVA-compliant providers.













<span class="grey">Wu, et al.                    Experimental                      [Page 9]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-10" id="page-10" name="page-10"> </a>
<span class="grey"><a href="rfc5210.html">RFC 5210</a>                      SAVA Testbed                     June 2008</span>


                                        ---------
                                        | AIMS   |
                                         ------|-
                                               |
   --------------                   -----------|-----
   |  AS-4       |--------  --------|    AS-1  |    |-------     Global
   | ------      |ASBR,VE|-&gt;|ASBR,VE|    ------|-   |ASBR,VE|---&gt;IPv6
   | |VRGE|      |--------  --------|    | VRGE |   |-------     Network
   | ------      |                  |    --------   |
   ---------------            ----- -----------------
                              |ASBR,VE|    |ASBR,VE|
                              ---------    ---------
                               /             |
                              /              |
                             /               |
                            /                |
                        ----------        --------
                        |ASBR, VE|        |ASBR,VE|
                   ---------------      -------------
                   |   AS-2      |      |  AS-3     |
                   |  -----      |      |   -----   |
                   |  |VRGE|     |      |  |VRGE|   |
                   |  -----      |      |  ------   |
                   ---------------      -------------

          Key:     AIMS - AS-IPv6 prefix Mapping Server
                   ASBR - AS Border Router
                   VE   - Validating Engine
                   VR   - Validation Rule
                   VRGE - Validation Rule Generating Engine

               Figure 3: Inter-ISP (Neighboring AS) Solution

   Two ASes that exchange traffic have a customer-to-provider, provider-
   to-customer, peer-to-peer, or sibling-to-sibling relationship.  In a
   customer-to-provider or provider-to-customer relationship, the
   customer typically belongs to a smaller administrative domain that
   pays a larger administrative domain for access to the rest of
   Internet.  The provider is an AS that belongs to the larger
   administrative domain.  In a peer-to-peer relationship, the two peers
   typically belong to administrative domains of comparable size and
   find it mutually advantageous to exchange traffic between their
   respective customers.  Two ASes have a sibling-to-sibling
   relationship if they belong to the same administrative domain or to
   administrative domains that have a mutual-transit agreement.






<span class="grey">Wu, et al.                    Experimental                     [Page 10]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-11" id="page-11" name="page-11"> </a>
<span class="grey"><a href="rfc5210.html">RFC 5210</a>                      SAVA Testbed                     June 2008</span>


   An AS-relation-based mechanism is used for neighboring SAVA-compliant
   ASes.  The basic ideas of this AS-relation-based mechanism are as
   follows.  It builds a VR table that associates each incoming
   interface of a router with a set of valid source address blocks, and
   then uses it to filter spoofed packets.

   In the solution implemented on the testbed, the solution for the
   validation of IPv6 prefixes is separated into three functional
   modules: The Validation Rule Generating Engine (VRGE), the Validation
   Engine (VE), and the AS-IPv6 prefix Mapping Server (AIMS).
   Validation rules that are generated by the VRGE are expressed as IPv6
   address prefixes.

   The VRGE generates validation rules that are derived according to
   Table 1, and each AS has a VRGE.  The VE loads validation rules
   generated by VRGE to filter packets passed between ASes (in the case
   of Figure 3, from neighboring ASes into AS-1).  In the SAVA testbed,
   the VE is implemented as a simulated layer-2 device on a Linux-based
   machine inserted into the data path just outside each ASBR interface
   that faces a neighboring AS.  In a real-world implementation, it
   would probably be implemented as a packet-filtering set on the ASBR.
   The AS-IPv6 prefix mapping server is also implemented on a Linux
   machine and derives a mapping between an IPv6 prefix and the AS
   number of that prefix.
  ----------------------------------------------------------------------
  |   \Export| Own     | Customer's| Sibling's | Provider's | Peer's   |
  |To  \     | Address | Address   | Address   | Address    | Address  |
  |-----\--------------------------------------------------------------|
  | Provider |    Y    |     Y     |     Y     |            |          |
  |--------------------------------------------------------------------|
  | Customer |    Y    |     Y     |     Y     |     Y      |    Y     |
  |--------------------------------------------------------------------|
  | Peer     |    Y    |     Y     |     Y     |            |          |
  |--------------------------------------------------------------------|
  | Sibling  |    Y    |     Y     |     Y     |     Y      |    Y     |
  ----------------------------------------------------------------------

           Table 1: AS-Relation-Based Inter-AS Filtering

   Different ASes exchange and transmit VR information using the AS-
   Relation-Based Export Rules in the VRGE.  As per Table 1, an AS
   exports the address prefixes of itself, its customers, its providers,
   its siblings, and its peers to its customers and siblings as valid
   prefixes, while it only exports the address prefixes of itself, its
   customers, and its siblings to its providers and peers as valid
   prefixes.  With the support of the AS-IPv6 prefix mapping server,
   only AS numbers of valid address prefixes are transferred between
   ASes, and the AS number is mapped to address prefixes at the VRGE.



<span class="grey">Wu, et al.                    Experimental                     [Page 11]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-12" id="page-12" name="page-12"> </a>
<span class="grey"><a href="rfc5210.html">RFC 5210</a>                      SAVA Testbed                     June 2008</span>


   Only changes of AS relation and changes of IP address prefixes
   belonging to an AS require the generation of VR updates.

   The procedure's principal steps are as follows (starting from AS-1 in
   Figure 3):

   1.  When the VRGE has initialized, it reads its neighboring SAVA-
       compliant AS table and establishes connections to all the VEs in
       its own AS.

   2.  The VRGE initiates a VR renewal.  According to its export table,
       it sends its own originated VR to VRGEs of neighboring ASes.  In
       this process, VRs are expressed as AS numbers.

   3.  When a VRGE receives a new VR from its neighbor, it uses its own
       export table to decide whether it should accept the VR and, if it
       accepts a VR, whether or not it should re-export the VR to other
       neighboring ASes.

   4.  If the VRGE accepts a VR, it uses the AIMS to transform the AS-
       expressed VR into an IPv6 prefix-expressed VR.

   5.  The VRGE pushes the VR to all the VEs in its AS.

   The VEs use these prefix-based VRs to validate the source IP
   addresses of incoming packets.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/2.5.%20%20IP%20Source%20Address%20Validation%20in%20the%20Inter-AS%20Case"></a><a class="selflink" href="#section-2.5" name="section-2.5">2.5</a>.  IP Source Address Validation in the Inter-AS Case</span>
      (Non-Neighboring AS)

   In the case where two ASes do not exchange packets directly, it is
   not possible to deploy a solution like that described in the previous
   section.  However, it is highly desirable for non-neighboring ISPs to
   be able to form a trust alliance such that packets leaving one AS
   will be recognized by the other and inherit the validation status
   they possessed on leaving the first AS.  There is more than one way
   to do this.  For the SAVA experiments to date, an authentication tag
   method has been used.  This solution is inspired by the work of
   [<a href="#ref-Brem05" title='"Spoofing Prevention Method"'>Brem05</a>].

   The key elements of this lightweight authentication tag based
   mechanism are as follows: For each pair of SAVA-compliant ASes, there
   is a pair of unique temporary authentication tags.  All SAVA-
   compliant ASes together form a SAVA AS Alliance.  When a packet is
   leaving its own AS, if the destination IP address belongs to an AS in
   the SAVA AS Alliance, the edge router of this AS looks up the
   authentication tag using the destination AS number as the key, and
   adds an authentication tag to the packet.  When a packet arrives at



<span class="grey">Wu, et al.                    Experimental                     [Page 12]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-13" id="page-13" name="page-13"> </a>
<span class="grey"><a href="rfc5210.html">RFC 5210</a>                      SAVA Testbed                     June 2008</span>


   the destination AS, if the source address of the packet belongs to an
   AS in the SAVA AS Alliance, the edge router of the destination AS
   searches its table for the authentication tag using the source AS
   number as the key, and the authentication tag carried in the packet
   is verified and removed.  As suggested by its name, this particular
   method uses a lightweight authentication tag.  For every packet
   forwarded, the authentication tag can be put in an IPv6 hop-by-hop
   extension header.  It is reasonable to use a 128-bit shared random
   number as the authentication tag to save the processing overhead
   brought by using a cryptographic method to generate the
   authentication tag.

   The benefit of this scheme compared to merely turning on local
   address validation (such as <a href="rfc2827.html">RFC 2827</a>) is as follows: when local
   address validation is employed within a group of networks, it is
   assured that their networks do not send spoofed packets.  But other
   networks may still do this.  With the above scheme, however, this
   capability is eliminated.  If someone outside the alliance spoofs a
   packet using a source address from someone within the alliance, the
   members of the alliance refuse to accept such a packet.

                                +-----+
              .-----------------+ REG |-----------------.
              |                 +-----+                 |
              |                                         |
        ,-----+--------                          ,------+-------
      ,'     `|        `.                      ,'     ` |       `.
     /        |         \                     /         |         \
    /         |          \                   /          |          \
   ;       +--'--+      +----+             +----+     +-----+       ;
   |       | ASC +------+ASBR|             |ASBR+-----+ ASC |       |
   :       +--.--+      +----+`            +----+     +--+--+       :
    \         |__________________________________________|         /
     \                   /                    \                   /
      `.               ,'                      `.               ,'
        '-------------'                          '-------------'
             AS-1                                     AS-2

                 Key:   REG  - Registration Server
                        ASC  - AS Control Server
                        ASBR - AS Border Router

             Figure 4: Inter-AS (Non-Neighboring AS) Solution

   There are three major components in the system: the Registration
   Server (REG), the AS Control Server (ASC), and the AS Border Router
   (ASBR).




<span class="grey">Wu, et al.                    Experimental                     [Page 13]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-14" id="page-14" name="page-14"> </a>
<span class="grey"><a href="rfc5210.html">RFC 5210</a>                      SAVA Testbed                     June 2008</span>


   The Registration Server is the "center" of the trust alliance (TA).
   It maintains a member list for the TA.  It performs two major
   functions:

   o  Processes requests from the AS Control Server, to get the member
      list for the TA.

   o  Notifies each AS Control Server when the member list is changed.

   Each AS deploying the method has an AS Control Server.  The AS
   Control Server has three major functions:

   o  Communicates with the Registration Server, to get the up-to-date
      member list of TA.

   o  Communicates with the AS Control Server in other member ASes in
      the TA, to exchange updates of prefix ownership information and to
      exchange authentication tags.

   o  Communicates with all AS Border Routers of the local AS, to
      configure the processing component on the AS Border Routers.

   The AS Border Router does the work of adding the authentication tag
   to the packet at the sending AS, and the work of verifying and
   removing the authentication tag at the destination AS.

   In the design of this system, in order to decrease the burden on the
   REG, most of the control traffic happens between ASCs.

   The authentication tag needs to be changed periodically.  Although
   the overhead of maintaining and exchanging authentication tags
   between AS pairs is O(N) from the point of view of one AS, rather
   than O(N^2), the traffic and processing overhead do increase as the
   number of ASes increases.  Therefore, an automatic authentication tag
   refresh mechanism is utilized in this solution.  In this mechanism,
   each peer runs the same algorithm to automatically generate an
   authentication tag sequence.  Then the authentication tag in packets
   can be changed automatically with high frequency.  To enhance the
   security, a seed is used for the algorithm to generate an
   authentication tag sequence robust against guessing.  Thus, the peers
   need only to negotiate and change the seed at very low frequency.
   This lowers the overhead associated with frequently negotiating and
   changing the authentication tag while maintaining acceptable
   security.

   Since the authentication tag is put in an IPv6 hop-by-hop extension
   header, the MTU issues should be considered.  Currently we have two
   solutions to this problem.  Neither of the solutions is perfect, but



<span class="grey">Wu, et al.                    Experimental                     [Page 14]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-15" id="page-15" name="page-15"> </a>
<span class="grey"><a href="rfc5210.html">RFC 5210</a>                      SAVA Testbed                     June 2008</span>


   they are both feasible.  One possible way is to set the MTU at the
   ASBR to be 1280 bytes, which is the minimum MTU for the IPv6.  Thus,
   there should be no ICMP "Packet Too Big" message received from the
   downstream gateways.  The disadvantage of this solution is that it
   doesn't make good use of the available MTU.  The other possible way
   is to let the ASBR catch all incoming ICMP "Packet Too Big" messages,
   and decrease the value in the MTU field before forwarding it into the
   AS.  The advantage of this solution is that it can make good use of
   the available MTU.  But such processing of ICMP packets at the ASBR
   may create a target for a denial-of-service (DoS) attack.

   Because the authentication tag is validated at the border router of
   the destination AS, not the destination host, the destination options
   header is not chosen to carry the authentication tag.

   Authentication tag management is a critical issue.  Our work focused
   on two points: tag negotiation and tag refresh.  The tag negotiation
   happens between the ASCs of a pair of ASes in the SAVA AS Alliance.
   Considering the issue of synchronization and the incentive of
   enabling SAVA, receiver-driven tag negotiation is suggested.  It
   gives more decision power to the receiver AS rather than the sender
   AS.  With a receiver-driven scheme, the receiver AS can decide the
   policies of tag management.  The packets tagged with old
   authentication tags should not be allowed indefinitely.  Rather,
   after having negotiated a new tag, the old tag should be set to be
   invalid after a period of time.  The length of this period is a
   parameter that will control how long the old tag will be valid after
   the new tag has been assigned.  In the experiment, we used five
   seconds.

   The trust alliance is intended to be established dynamically (join
   and quit), but in this testbed we needed to confirm off-line the
   initial trust among alliance members.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/3.%20%20SAVA%20Testbed"></a><a class="selflink" href="#section-3" name="section-3">3</a>.  SAVA Testbed</span>

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.1.%20%20CNGI-CERNET2"></a><a class="selflink" href="#section-3.1" name="section-3.1">3.1</a>.  CNGI-CERNET2</span>

   The prototypes of our solutions for SAVA are implemented and tested
   on CNGI-CERNET2.  CNGI-CERNET2 is one of the China Next Generation
   Internet (CNGI) backbones, operated by the China Education and
   Research Network (CERNET).  CNGI-CERNET2 connects 25 core nodes
   distributed in 20 cities in China at speeds of 2.5-10 Gb/s.  The
   CNGI-CERNET2 backbones are IPv6-only networks rather than being a
   mixed IPv4/IPv6 infrastructure.  Only some Customer Premises Networks
   (CPNs) are dual-stacked.  The CNGI-CERNET2 backbones, CNGI-CERNET2
   CPNs, and CNGI-6IX all have globally unique AS numbers.  Thus a
   multi-AS testbed environment is provided.



<span class="grey">Wu, et al.                    Experimental                     [Page 15]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-16" id="page-16" name="page-16"> </a>
<span class="grey"><a href="rfc5210.html">RFC 5210</a>                      SAVA Testbed                     June 2008</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.2.%20%20SAVA%20Testbed%20on%20CNGI-CERNET2%20Infrastructure"></a><a class="selflink" href="#section-3.2" name="section-3.2">3.2</a>.  SAVA Testbed on CNGI-CERNET2 Infrastructure</span>

   It is intended that eventually the SAVA testbed will be implemented
   directly on the CNGI-CERNET2 backbone, but in the early stages the
   testbed has been implemented across 12 universities connected to
   CNGI-CERNET2.  First, this is because some of the algorithms need to
   be implemented in the testbed routers themselves, and to date they
   have not been implemented on any of the commercial routers forming
   the CNGI-CERNET2 backbone.  Second, since CNGI-CERNET2 is an
   operational backbone, any new protocols and networking techniques
   need to be tested in a non-disruptive way.
                               __
                             ,'  \                            _,...._
                            ,'    \____---------------+     ,'Beijing`.
                            /      \  | Inter-AS SAV  |-----| Univ    |
    +---------------+     |         | +---------------+     `-._____,'
    | Inter-AS SAV  +-----|         |
    +------.--------+     |  CNGI-  |                         _,...._
           |              | CERNET2 |__---------------+     ,Northeast`.
           |              |         | |Inter-AS SAV   |-----| Univ    |
   Tsinghua|University    | Backbone| +---------------+     `-._____,'
        ,,-|-._           |         |
      ,'   |   `.         |         |
    ,'+---------+\        |         |
   |  |Intra-AS | |       |         |      ...
   |  |   SAV   | |       |         |
   |  +---------+ |       |         |
   |       |      |       |         |                         _,...._
   |  +---------+ |       |         |__---------------+     ,Chongqing`.
   |  | Access  | |       |         | |Inter-AS SAV   |-----|Univ     |
   |  | Network | |       |         | +---------------+     `-._____,'
   |  |  SAV    | |       |         |
    \ +---------+.'        \       .'
     \          ,'          \      |
      `.      ,'             \    /
        ``---'                -_,'

                  Key:  SAV - Source Address Validation

                    Figure 5: CNGI-CERNET2 SAVA Testbed

   In any case, the testbed is fully capable of functional testing of
   solutions for all parts of SAVA.  This includes testing procedures
   for ensuring the validity of IPv6 source addresses in the access
   network, in packets sent from the access network to an IPv6 service
   provider, in packets sent within one service provider's network, in





<span class="grey">Wu, et al.                    Experimental                     [Page 16]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-17" id="page-17" name="page-17"> </a>
<span class="grey"><a href="rfc5210.html">RFC 5210</a>                      SAVA Testbed                     June 2008</span>


   packets sent between neighboring service providers, and in packets
   sent between service providers separated by an intervening transit
   network.

   The testbed is distributed across 12 universities connected to CNGI-
   CERNET2.

   Each of the university installations is connected to the CNGI-CERNET2
   backbone through a set of inter-AS Source Address Validation
   prototype equipment and traffic monitoring equipment for test result
   display.

   Each university deployed one AS.  Six universities deployed all parts
   of the solution and are hence fully-featured, with validation at the
   inter-AS, intra-AS, and access network levels all able to be tested.
   In addition, a suite of applications that could be subject to
   spoofing attacks or that can be subverted to carry out spoofing
   attacks were installed on a variety of servers.  Two solutions for
   the access network were deployed.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/4.%20%20Test%20Experience%20and%20Results"></a><a class="selflink" href="#section-4" name="section-4">4</a>.  Test Experience and Results</span>

   The solutions outlined in <a href="#section-2">section 2</a> were implemented on the testbed
   described in <a href="#section-3">section 3</a>.  Successful testing of all solutions was been
   carried out, as detailed in the following sections.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.1.%20%20Test%20Scenarios"></a><a class="selflink" href="#section-4.1" name="section-4.1">4.1</a>.  Test Scenarios</span>

   For each of the test scenarios, we tested many cases.  Taking the
   Inter-AS (non-neighboring AS) SAVA solution test as an example, we
   classified the test cases into three classes: normal class, dynamic
   class, and anti-spoofing class.

   1.  For normal class, there are three cases: Adding authentication
       tag Test, Removing authentication tag Test, and Forwarding
       packets with valid source address.

   2.  For dynamic class, there are four cases: Updating the
       authentication tag between ASes, The protection for a newly
       joined member AS, Adding address space, and Deleting address
       space.

   3.  For anti-spoofing class, there is one case: Filtering of packets
       with forged IP addresses.

   As is shown in Figure 5, we have "multiple-fence" design for our SAVA
   testbed.  If source address validation is deployed in the access
   network, we can get a host granularity validation.  If source address



<span class="grey">Wu, et al.                    Experimental                     [Page 17]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-18" id="page-18" name="page-18"> </a>
<span class="grey"><a href="rfc5210.html">RFC 5210</a>                      SAVA Testbed                     June 2008</span>


   validation is deployed at the intra-AS level, we can guarantee that
   the packets sent from this point have a correct IP prefix.  If source
   address validation is deployed at the inter-AS level, we can
   guarantee that the packets sent from this point are from the correct
   AS.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.2.%20%20Test%20Results"></a><a class="selflink" href="#section-4.2" name="section-4.2">4.2</a>.  Test Results</span>

   1.  The test results are consistent with the expected ones.  For an
       AS that has fully-featured SAVA deployment with validation at the
       inter-AS, intra-AS, and access network levels, packets that do
       not hold an authenticated source address will not be forwarded in
       the network.  As a result, it is not possible to launch network
       attacks with spoofed source addresses.  Moreover, the traffic in
       the network can be traced back accurately.

   2.  For the Inter-AS (non-neighboring AS) SAVA solution, during the
       period of authentication tag update, the old and the new
       authentication tags are both valid for source address validation;
       thus, there is no packet loss.

   3.  For the Inter-AS (non-neighboring AS) SAVA solution, the
       validation function is implemented in software on a device
       running Linux, which simulates the source address validation
       functions of a router interface.  It is a layer-2 device because
       it needs to be transparent to the router interface.  During the
       test, when the devices were connected directly, normal line-rate
       forwarding was achieved.  When the devices were connected with
       routers from another vendor, only a very limited forwarding speed
       was achieved.  The reason is that the authentication tags are
       added on the IPv6 hop-by-hop option header, and many current
       routers can handle the hop-by-hop options only at a limited rate.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/5.%20%20Limitations%20and%20Issues"></a><a class="selflink" href="#section-5" name="section-5">5</a>.  Limitations and Issues</span>

   There are several issues both within this overall problem area and
   with the particular approach taken in the experiment.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.1.%20%20General%20Issues"></a><a class="selflink" href="#section-5.1" name="section-5.1">5.1</a>.  General Issues</span>

   There is a long-standing debate about whether the lack of universal
   deployment of source address validation is a technical issue that
   needs a technical solution, or if mere further deployment of existing
   tools (such as <a href="rfc2827.html">RFC 2827</a>) would be a more cost effective way to
   improve the situation.  Further deployment efforts of this tool have
   proved to be slow, however.  Some of the solutions prototyped in this
   experiment allow a group of network operators to have additional
   protection for their networks while waiting for universal deployment



<span class="grey">Wu, et al.                    Experimental                     [Page 18]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-19" id="page-19" name="page-19"> </a>
<span class="grey"><a href="rfc5210.html">RFC 5210</a>                      SAVA Testbed                     June 2008</span>


   of simpler tools in the rest of the Internet.  This allows them to
   prevent spoofing attacks that the simple tools alone would not be
   able to prevent, even if already deployed within the group.

   Similarly, since a large fraction of current denial-of-service
   attacks can be launched by employing legitimate IP addresses
   belonging to botnet clients, even universal deployment of better
   source address validation techniques would be unable to prevent these
   attacks.  However, tracing these attacks would be easier given that
   there would be more reliance on the validity of source address.

   There is also a question about the optimal placement of the source
   address validation checks.  The simplest model is placing the checks
   on the border of a network.  Such <a href="rfc2827.html">RFC 2827</a>-style checks are more
   widely deployed than full checks ensuring that all addresses within
   the network are correct.  It can be argued that it is sufficient to
   provide such coarse granularity checks, because this makes it at
   least possible to find the responsible network administrators.
   However, depending on the type of network in question, those
   administrators may or may not find it easy to track the specific
   offending machines or users.  It is obviously required that the
   administrators have a way to trace offending equipment or users --
   even if the network does not block spoofed packets in real-time.

   New technology for address validation would also face a number of
   deployment barriers.  For instance, all current technology can be
   locally and independently applied.  A system that requires global
   operation (such as the Inter-AS validation mechanism) would require
   significant coordination, deployment synchronization, configuration,
   key setup, and other issues, given the number of ASes.

   Similarly, deploying host-based access network address validation
   mechanisms requires host changes, and can generally be done only when
   the network owners are in control of all hosts.  Even then, the
   changing availability of the host for all types of products and
   platforms would likely prevent universal deployment even within a
   single network.

   There may be also be significant costs involved in some of these
   solutions.  For instance, in an environment where access network
   authentication is normally not required, employing an authentication-
   based access network address validation would require deployment of
   equipment capable of this authentication as well as credentials
   distribution for all devices.  Such undertaking is typically only
   initiated after careful evaluation of the costs and benefits
   involved.





<span class="grey">Wu, et al.                    Experimental                     [Page 19]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-20" id="page-20" name="page-20"> </a>
<span class="grey"><a href="rfc5210.html">RFC 5210</a>                      SAVA Testbed                     June 2008</span>


   Finally, all the presented solutions have issues in situations that
   go beyond a simple model of a host connecting to a network via the
   same single interface at all times.  Multihoming, failover, and some
   forms of mobility or wireless solutions may collide with the
   requirements of source address validation.  In general, dynamic
   changes to the attachment of hosts and topology of the routing
   infrastructure are something that would have to be handled in a
   production environment.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.2.%20%20Security%20Issues"></a><a class="selflink" href="#section-5.2" name="section-5.2">5.2</a>.  Security Issues</span>

   The security vs. scalability of the authentication tags in the
   Inter-AS (non-neighboring AS) SAVA solution presents a difficult
   tradeoff.  Some analysis about the difficulty of guessing the
   authentication tag between two AS members was discussed in [<a href="#ref-Brem05" title='"Spoofing Prevention Method"'>Brem05</a>].
   It is relatively difficult, even with using a random number as an
   "authentication tag".  The difficulty of guessing can be increased by
   increasing the length of the authentication tag.

   In any case, the random number approach is definitely vulnerable to
   attackers who are on the path between the two ASes.

   On the other hand, using an actual cryptographic hash in the packets
   will cause a significant increase in the amount of effort needed to
   forward a packet.  In general, addition of the option and the
   calculation of the authentication tag consume valuable resources on
   the forwarding path.  This resource usage comes on top of everything
   else that modern routers need to do at ever increasing line speeds.
   It is far from clear that the costs are worth the benefits.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.3.%20%20Protocol%20Details"></a><a class="selflink" href="#section-5.3" name="section-5.3">5.3</a>.  Protocol Details</span>

   In the current CNGI-CERNET2 SAVA testbed, a 128-bit authentication
   tag is placed in an IPv6 hop-by-hop option header.  The size of the
   packets increases with the authentication tags.  This by itself is
   expected to be acceptable, if the network administrator feels that
   the additional protection is needed.  The size increases may result
   in an MTU issue, and we found a way to resolve it in the testbed.
   Since an IPv6 hop-by-hop option header was chosen, the option header
   has to be examined by all intervening routers.  While in theory this
   should pose no concern, the test results show that many current
   routers handle hop-by-hop options with a much reduced throughput
   compared to normal traffic.

   The Inter-AS (neighboring AS) SAVA solution is based on the AS
   relation; thus, it may not synchronize with the dynamics of route
   changes very quickly and it may cause false positives.  Currently,




<span class="grey">Wu, et al.                    Experimental                     [Page 20]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-21" id="page-21" name="page-21"> </a>
<span class="grey"><a href="rfc5210.html">RFC 5210</a>                      SAVA Testbed                     June 2008</span>


   CNGI-CERNET2 is a relatively stable network, and this method works
   well in the testbed.  We will further study the impact of false
   positives in an unstable network.

   The access network address validation solution is merely one option
   among many.  Solutions appear to depend highly on the chosen link
   technology and network architecture.  For instance, source address
   validation on point-to-point links is easy and has generally been
   supported by implementations for years.  Validation in shared
   networks has been more problematic, but is increasing in importance
   given the use of Ethernet technology across administrative boundaries
   (such as in DSL).  In any case, the prototyped solution has a number
   of limitations, including the decision to use a new address
   configuration protocol.  In a production environment, a solution that
   is suitable for all IPv6 address assignment mechanisms would be
   needed.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/6.%20%20Conclusion"></a><a class="selflink" href="#section-6" name="section-6">6</a>.  Conclusion</span>

   Several conclusions can be drawn from the experiment.

   First, the experiment is a proof that a prototype can be built that
   is deployable on loosely-coupled domains of test networks in a
   limited scale and "multiple-fence" design for source address
   validation.  The solution allows different validation granularities,
   and also allows different providers to use different solutions.  The
   coupling of components at different levels of granularity can be
   loose enough to allow component substitution.

   Incremental deployment is another design principle that was used in
   the experiment.  The tests have demonstrated that benefit is derived
   even when deployment is incomplete, thus giving providers an
   incentive to be early adopters.

   The experiment also provided a proof of concept for the switch-based
   local subnet validation, network authentication based validation,
   filter-based Inter-AS validation, and authentication tag-based
   Inter-AS validation mechanisms.  The client host and network
   equipment need to be modified and some new servers should be
   deployed.

   Nevertheless, as discussed in the previous section, there are a
   number of limitations, issues, and questions in the prototype designs
   and the overall source address validation space.







<span class="grey">Wu, et al.                    Experimental                     [Page 21]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-22" id="page-22" name="page-22"> </a>
<span class="grey"><a href="rfc5210.html">RFC 5210</a>                      SAVA Testbed                     June 2008</span>


   It is our hope that some of the experiences will help vendors and the
   Internet standards community in these efforts.  Future work in this
   space should attempt to answer some of the issues raised in
   <a href="#section-5">Section 5</a>.  Some of the key issues going forward include:

   o  Scalability questions and per-packet operations.

   o  Protocol design issues, such as integration to existing address
      allocation mechanisms, use of hop-by-hop headers, etc.

   o  Cost vs. benefit questions.  These may be ultimately answered only
      by actually employing some of these technologies in production
      networks.

   o  Trust establishment issue and study of false positives.

   o  Deployability considerations, e.g. modifiability of switches,
      hosts, etc.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/7.%20%20Security%20Considerations"></a><a class="selflink" href="#section-7" name="section-7">7</a>.  Security Considerations</span>

   The purpose of the document is to report experimental results.  Some
   security considerations of the solution mechanisms of the testbed are
   mentioned in the document, but are not the main problem to be
   described in this document.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/8.%20%20Acknowledgements"></a><a class="selflink" href="#section-8" name="section-8">8</a>.  Acknowledgements</span>

   This experiment was conducted among 12 universities -- namely,
   Tsinghua University, Beijing University, Beijing University of Post
   and Telecommunications, Shanghai Jiaotong University, Huazhong
   University of Science and Technology in Wuhan, Southeast University
   in Nanjing, South China University of Technology in Guangzhou,
   Northeast University in Shenyang, Xi'an Jiaotong University, Shandong
   University in Jinan, University of Electronic Science and Technology
   of China in Chengdu, and Chongqing University.  The authors would
   like to thank everyone involved in this effort in these universities.

   The authors would like to thank Jari Arkko, Lixia Zhang, and Pekka
   Savola for their detailed review comments on this document, and thank
   Paul Ferguson and Ron Bonica for their valuable advice on the
   solution development and the testbed implementation.









<span class="grey">Wu, et al.                    Experimental                     [Page 22]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-23" id="page-23" name="page-23"> </a>
<span class="grey"><a href="rfc5210.html">RFC 5210</a>                      SAVA Testbed                     June 2008</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/9.%20%20References"></a><a class="selflink" href="#section-9" name="section-9">9</a>.  References</span>

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/9.1.%20%20Normative%20References"></a><a class="selflink" href="#section-9.1" name="section-9.1">9.1</a>.  Normative References</span>

   [<a id="ref-RFC2827" name="ref-RFC2827">RFC2827</a>]  Ferguson, P. and D. Senie, "Network Ingress Filtering:
              Defeating Denial of Service Attacks which employ IP Source
              Address Spoofing", <a href="https://tools.ietf.org/html/bcp38">BCP 38</a>, <a href="rfc2827.html">RFC 2827</a>, May 2000.

   [<a id="ref-RFC3704" name="ref-RFC3704">RFC3704</a>]  Baker, F. and P. Savola, "Ingress Filtering for Multihomed
              Networks", <a href="https://tools.ietf.org/html/bcp84">BCP 84</a>, <a href="rfc3704.html">RFC 3704</a>, March 2004.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/9.2.%20%20Informative%20References"></a><a class="selflink" href="#section-9.2" name="section-9.2">9.2</a>.  Informative References</span>

   [<a id="ref-Brem05" name="ref-Brem05">Brem05</a>]   Bremler-Barr, A. and H. Levy, "Spoofing Prevention
              Method", INFOCOM 2005.

   [<a id="ref-Li02" name="ref-Li02">Li02</a>]     Li,, J., Mirkovic, J., Wang, M., Reiher, P., and L.
              Zhang, "SAVE: Source Address Validity Enforcement
              Protocol", INFOCOM  2002.

   [<a id="ref-Park01" name="ref-Park01">Park01</a>]   Park, K. and H. Lee, "On the effectiveness of route-based
              packet filtering for distributed DoS attack prevention in
              power-law internets", SIGCOMM 2001.

   [<a id="ref-Snoe01" name="ref-Snoe01">Snoe01</a>]   Snoeren, A., Partridge, C., Sanchez, L., and C. Jones, "A
              Hash-based IP traceback", SIGCOMM 2001.

   [<a id="ref-Wu07" name="ref-Wu07">Wu07</a>]     Wu, J., Ren, G., and X. Li, "Source Address Validation:
              Architecture and Protocol Design", ICNP 2007.

   [<a id="ref-XBW07" name="ref-XBW07">XBW07</a>]    Xie, L., Bi, J., and J. Wu, "An Authentication based
              Source Address Spoofing Prevention Method Deployed in IPv6
              Edge Network", ICCS 2007.


















<span class="grey">Wu, et al.                    Experimental                     [Page 23]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-24" id="page-24" name="page-24"> </a>
<span class="grey"><a href="rfc5210.html">RFC 5210</a>                      SAVA Testbed                     June 2008</span>


Authors' Addresses

   Jianping Wu
   Tsinghua University
   Computer Science, Tsinghua University
   Beijing  100084
   China
   EMail: jianping@cernet.edu.cn

   Jun Bi
   Tsinghua University
   Network Research Center, Tsinghua University
   Beijing  100084
   China
   EMail: junbi@cernet.edu.cn

   Xing Li
   Tsinghua University
   Electronic Engineering, Tsinghua University
   Beijing  100084
   China
   EMail: xing@cernet.edu.cn

   Gang Ren
   Tsinghua University
   Computer Science, Tsinghua University
   Beijing  100084
   China
   EMail: rg03@mails.tsinghua.edu.cn

   Ke Xu
   Tsinghua University
   Computer Science, Tsinghua University
   Beijing  100084
   China
   EMail: xuke@csnet1.cs.tsinghua.edu.cn

   Mark I. Williams
   Juniper Networks
   Suite 1508, W3 Tower, Oriental Plaza, 1 East Chang'An Ave
   Dong Cheng District, Beijing  100738
   China
   EMail: miw@juniper.net








<span class="grey">Wu, et al.                    Experimental                     [Page 24]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-25" id="page-25" name="page-25"> </a>
<span class="grey"><a href="rfc5210.html">RFC 5210</a>                      SAVA Testbed                     June 2008</span>


Full Copyright Statement

   Copyright (C) The IETF Trust (2008).

   This document is subject to the rights, licenses and restrictions
   contained in <a href="https://tools.ietf.org/html/bcp78">BCP 78</a>, and except as set forth therein, the authors
   retain all their rights.

   This document and the information contained herein are provided on an
   "AS IS" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS
   OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST AND
   THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS
   OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF
   THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED
   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.

Intellectual Property

   The IETF takes no position regarding the validity or scope of any
   Intellectual Property Rights or other rights that might be claimed to
   pertain to the implementation or use of the technology described in
   this document or the extent to which any license under such rights
   might or might not be available; nor does it represent that it has
   made any independent effort to identify any such rights.  Information
   on the procedures with respect to rights in RFC documents can be
   found in <a href="https://tools.ietf.org/html/bcp78">BCP 78</a> and <a href="https://tools.ietf.org/html/bcp79">BCP 79</a>.

   Copies of IPR disclosures made to the IETF Secretariat and any
   assurances of licenses to be made available, or the result of an
   attempt made to obtain a general license or permission for the use of
   such proprietary rights by implementers or users of this
   specification can be obtained from the IETF on-line IPR repository at
   <a href="http://www.ietf.org/ipr">http://www.ietf.org/ipr</a>.

   The IETF invites any interested party to bring to its attention any
   copyrights, patents or patent applications, or other proprietary
   rights that may cover technology that may be required to implement
   this standard.  Please address the information to the IETF at
   ietf-ipr@ietf.org.












Wu, et al.                    Experimental                     [Page 25]

</pre><br/>
    <span class="noprint"><small><small>Html markup produced by rfcmarkup 1.126, available from
      <a href="https://tools.ietf.org/tools/rfcmarkup/">https://tools.ietf.org/tools/rfcmarkup/</a>
    </small></small></span>
  </div>




</body><!-- Mirrored from tools.ietf.org/html/rfc5210 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 06 Mar 2018 23:18:36 GMT --></html>