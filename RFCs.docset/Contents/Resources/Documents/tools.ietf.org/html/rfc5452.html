<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml"><!-- Mirrored from tools.ietf.org/html/rfc5452 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 06 Mar 2018 23:18:35 GMT --><!-- Added by HTTrack --><head><meta content="text/html;charset=utf-8" http-equiv="content-type"/><!-- /Added by HTTrack -->

    <meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
    <meta content="index,follow" name="robots"/>
    <meta content="rfcmarkup version 1.126" name="creator"/>
    <link href="http://purl.org/dc/elements/1.1/" rel="schema.DC"/>
<meta content="urn:ietf:rfc:5452" name="DC.Identifier"/>
<meta content="The current Internet climate poses serious threats to the Domain Name
System. In the interim period before the DNS protocol can be secured
more fully, measures can already be taken to harden the DNS to make
'spoofing' a recursing nameserver many orders of magnitude
harder.  Even a cryptographically secured DNS benefits from having the
ability to discard bogus responses quickly, as this potentially saves
large amounts of computation.  By describing certain behavior that has
previously not been standardized, this document sets out how to make
the DNS more resilient against accepting incorrect responses. This
document updates RFC 2181. [STANDARDS-TRACK]" name="DC.Description.Abstract"/>
<meta content="Remco Mook &lt;remco@eu.equinix.com&gt;" name="DC.Creator"/>
<meta content="January, 2009" name="DC.Date.Issued"/>
<meta content="Measures for Making DNS More Resilient against Forged Answers" name="DC.Title"/>

    <link href="https://tools.ietf.org/images/rfc.png" rel="icon" type="image/png"/>
    <link href="https://tools.ietf.org/images/rfc.png" rel="shortcut icon" type="image/png"/>
    <title>RFC 5452 - Measures for Making DNS More Resilient against Forged Answers</title>
    
    
    <style type="text/css">
	@media only screen 
	  and (min-width: 992px)
	  and (max-width: 1199px) {
	    body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 768px)
	  and (max-width: 991px) {
            body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 480px)
	  and (max-width: 767px) {
            body { font-size: 11pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (max-width: 479px) {
            body { font-size: 8pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-device-width : 375px) 
	  and (max-device-width : 667px) {
            body { font-size: 9.5pt; }
            div.content { width: 96ex; margin: 0 1px; }
        }
	@media only screen 
	  and (min-device-width: 1200px) {
            body { font-size: 10pt; margin: 0 4em; }
            div.content { width: 96ex; margin: 0; }
        }
        h1, h2, h3, h4, h5, h6, .h1, .h2, .h3, .h4, .h5, .h6 {
	    font-weight: bold;
            line-height: 0pt;
            display: inline;
            white-space: pre;
            font-family: monospace;
            font-size: 1em;
	    font-weight: bold;
        }
        pre {
            font-size: 1em;
            margin-top: 0px;
            margin-bottom: 0px;
        }
	.pre {
	    white-space: pre;
	    font-family: monospace;
	}
	.header{
	    font-weight: bold;
	}
        .newpage {
            page-break-before: always;
        }
        .invisible {
            text-decoration: none;
            color: white;
        }
        a.selflink {
          color: black;
          text-decoration: none;
        }
        @media print {
            body {
                font-family: monospace;
                font-size: 10.5pt;
            }
            h1, h2, h3, h4, h5, h6 {
                font-size: 1em;
            }
        
            a:link, a:visited {
                color: inherit;
                text-decoration: none;
            }
            .noprint {
                display: none;
            }
        }
	@media screen {
	    .grey, .grey a:link, .grey a:visited {
		color: #777;
	    }
            .docinfo {
                background-color: #EEE;
            }
            .top {
                border-top: 7px solid #EEE;
            }
            .bgwhite  { background-color: white; }
            .bgred    { background-color: #F44; }
            .bggrey   { background-color: #666; }
            .bgbrown  { background-color: #840; }            
            .bgorange { background-color: #FA0; }
            .bgyellow { background-color: #EE0; }
            .bgmagenta{ background-color: #F4F; }
            .bgblue   { background-color: #66F; }
            .bgcyan   { background-color: #4DD; }
            .bggreen  { background-color: #4F4; }

            .legend   { font-size: 90%; }
            .cplate   { font-size: 70%; border: solid grey 1px; }
	}
    </style>
    <!--[if IE]>
    <style>
    body {
       font-size: 13px;
       margin: 10px 10px;
    }
    </style>
    <![endif]-->

    <script type="text/javascript"><!--
    function addHeaderTags() {
	var spans = document.getElementsByTagName("span");
	for (var i=0; i < spans.length; i++) {
	    var elem = spans[i];
	    if (elem) {
		var level = elem.getAttribute("class");
                if (level == "h1" || level == "h2" || level == "h3" || level == "h4" || level == "h5" || level == "h6") {
                    elem.innerHTML = "<"+level+">"+elem.innerHTML+"</"+level+">";		
                }
	    }
	}
    }
    var legend_html = "Colour legend:<br />      <table>         <tr><td>Unknown:</td>                   <td><span class='cplate bgwhite'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft:</td>                     <td><span class='cplate bgred'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Informational:</td>             <td><span class='cplate bgorange'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Experimental:</td>              <td><span class='cplate bgyellow'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Best Common Practice:</td>      <td><span class='cplate bgmagenta'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Proposed Standard:</td>         <td><span class='cplate bgblue'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft Standard (old designation):</td> <td><span class='cplate bgcyan'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Internet Standard:</td>         <td><span class='cplate bggreen'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Historic:</td>                  <td><span class='cplate bggrey'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Obsolete:</td>                  <td><span class='cplate bgbrown'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>     </table>";
    function showElem(id) {
        var elem = document.getElementById(id);
        elem.innerHTML = eval(id+"_html");
        elem.style.visibility='visible';
    }
    function hideElem(id) {
        var elem = document.getElementById(id);
        elem.style.visibility='hidden';        
        elem.innerHTML = "";
    }
    // -->
    </script>
</head>
<body onload="addHeaderTags()">
  <div class="content">
   <div style="height: 13px;">
      <div class="pre noprint docinfo bgblue" onclick="showElem('legend');" onmouseout="hideElem('legend')" onmouseover="this.style.cursor='pointer';" style="height: 6px; position: absolute;" title="Click for colour legend.">                                                                        </div>
      <div class="docinfo noprint pre legend" id="legend" onmouseout="hideElem('legend');" onmouseover="showElem('legend');" style="position:absolute; top: 4px; left: 4ex; visibility:hidden; background-color: white; padding: 4px 9px 5px 7px; border: solid #345 1px; ">
      </div>
   </div>
<span class="pre noprint docinfo top">[<a href="index.html" title="Document search and retrieval page">Docs</a>] [<a href="https://tools.ietf.org/rfc/rfc5452.txt" title="Plaintext version of this document">txt</a>|<a href="https://tools.ietf.org/pdf/rfc5452" title="PDF version of this document">pdf</a>] [<a href="https://tools.ietf.org/html/draft-ietf-dnsext-forgery-resilience" title="draft-ietf-dnsext-forgery-resilience">draft-ietf-dnse...</a>] [<a href="https://datatracker.ietf.org/doc/rfc5452" title="IESG Datatracker information for this document">Tracker</a>] [<a href="https://tools.ietf.org/rfcdiff?difftype=--hwdiff&amp;url2=rfc5452" title="Inline diff (wdiff)">Diff1</a>] [<a href="https://tools.ietf.org/rfcdiff?url2=rfc5452" title="Side-by-side diff">Diff2</a>]         </span><br/>
<span class="pre noprint docinfo">                                                                        </span><br/>
<span class="pre noprint docinfo">                                                       PROPOSED STANDARD</span><br/>
<span class="pre noprint docinfo">                                                                        </span><br/>
<pre>Network Working Group                                          A. Hubert
Request for Comments: 5452            Netherlabs Computer Consulting BV.
Updates: <a href="rfc2181.html">2181</a>                                                R. van Mook
Category: Standards Track                                        Equinix
                                                            January 2009


     <span class="h1">Measures for Making DNS More Resilient against Forged Answers</span>

Status of This Memo

   This document specifies an Internet standards track protocol for the
   Internet community, and requests discussion and suggestions for
   improvements.  Please refer to the current edition of the "Internet
   Official Protocol Standards" (STD 1) for the standardization state
   and status of this protocol.  Distribution of this memo is unlimited.

Copyright Notice

   Copyright (c) 2009 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to <a href="https://tools.ietf.org/html/bcp78">BCP 78</a> and the IETF Trust's Legal
   Provisions Relating to IETF Documents (<a href="http://trustee.ietf.org/license-info">http://trustee.ietf.org/</a>
   <a href="http://trustee.ietf.org/license-info">license-info</a>) in effect on the date of publication of this document.
   Please review these documents carefully, as they describe your rights
   and restrictions with respect to this document.

Abstract

   The current Internet climate poses serious threats to the Domain Name
   System.  In the interim period before the DNS protocol can be secured
   more fully, measures can already be taken to harden the DNS to make
   'spoofing' a recursing nameserver many orders of magnitude harder.

   Even a cryptographically secured DNS benefits from having the ability
   to discard bogus responses quickly, as this potentially saves large
   amounts of computation.

   By describing certain behavior that has previously not been
   standardized, this document sets out how to make the DNS more
   resilient against accepting incorrect responses.  This document
   updates <a href="rfc2181.html">RFC 2181</a>.








<span class="grey">Hubert &amp; van Mook           Standards Track                     [Page 1]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-2" id="page-2" name="page-2"> </a>
<span class="grey"><a href="rfc5452.html">RFC 5452</a>         DNS Resilience against Forged Answers      January 2009</span>


Table of Contents

   <a href="#section-1">1</a>.  Introduction . . . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-3">3</a>
   <a href="#section-2">2</a>.  Requirements and Definitions . . . . . . . . . . . . . . . . .  <a href="#page-4">4</a>
     <a href="#section-2.1">2.1</a>.  Definitions  . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-4">4</a>
     <a href="#section-2.2">2.2</a>.  Key Words  . . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-5">5</a>
   <a href="#section-3">3</a>.  Description of DNS Spoofing  . . . . . . . . . . . . . . . . .  <a href="#page-5">5</a>
   <a href="#section-4">4</a>.  Detailed Description of Spoofing Scenarios . . . . . . . . . .  <a href="#page-6">6</a>
     <a href="#section-4.1">4.1</a>.  Forcing a Query  . . . . . . . . . . . . . . . . . . . . .  <a href="#page-6">6</a>
     <a href="#section-4.2">4.2</a>.  Matching the Question Section  . . . . . . . . . . . . . .  <a href="#page-7">7</a>
     <a href="#section-4.3">4.3</a>.  Matching the ID Field  . . . . . . . . . . . . . . . . . .  <a href="#page-7">7</a>
     <a href="#section-4.4">4.4</a>.  Matching the Source Address of the Authentic Response  . .  <a href="#page-7">7</a>
     4.5.  Matching the Destination Address and Port of the
           Authentic Response . . . . . . . . . . . . . . . . . . . .  <a href="#page-8">8</a>
     <a href="#section-4.6">4.6</a>.  Have the Response Arrive before the Authentic Response . .  <a href="#page-8">8</a>
   <a href="#section-5">5</a>.  Birthday Attacks . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-9">9</a>
   <a href="#section-6">6</a>.  Accepting Only In-Domain Records . . . . . . . . . . . . . . .  <a href="#page-9">9</a>
   <a href="#section-7">7</a>.  Combined Difficulty  . . . . . . . . . . . . . . . . . . . . . <a href="#page-10">10</a>
     <a href="#section-7.1">7.1</a>.  Symbols Used in Calculation  . . . . . . . . . . . . . . . <a href="#page-10">10</a>
     <a href="#section-7.2">7.2</a>.  Calculation  . . . . . . . . . . . . . . . . . . . . . . . <a href="#page-11">11</a>
   <a href="#section-8">8</a>.  Discussion . . . . . . . . . . . . . . . . . . . . . . . . . . <a href="#page-12">12</a>
     <a href="#section-8.1">8.1</a>.  Repetitive Spoofing Attempts for a Single Domain Name  . . <a href="#page-13">13</a>
   <a href="#section-9">9</a>.  Forgery Countermeasures  . . . . . . . . . . . . . . . . . . . <a href="#page-13">13</a>
     <a href="#section-9.1">9.1</a>.  Query Matching Rules . . . . . . . . . . . . . . . . . . . <a href="#page-13">13</a>
     <a href="#section-9.2">9.2</a>.  Extending the Q-ID Space by Using Ports and Addresses  . . <a href="#page-14">14</a>
       <a href="#section-9.2.1">9.2.1</a>.  Justification and Discussion . . . . . . . . . . . . . <a href="#page-14">14</a>
     <a href="#section-9.3">9.3</a>.  Spoof Detection and Countermeasure . . . . . . . . . . . . <a href="#page-15">15</a>
   <a href="#section-10">10</a>. Security Considerations  . . . . . . . . . . . . . . . . . . . <a href="#page-15">15</a>
   <a href="#section-11">11</a>. Acknowledgments  . . . . . . . . . . . . . . . . . . . . . . . <a href="#page-16">16</a>
   <a href="#section-12">12</a>. References . . . . . . . . . . . . . . . . . . . . . . . . . . <a href="#page-16">16</a>
     <a href="#section-12.1">12.1</a>. Normative References . . . . . . . . . . . . . . . . . . . <a href="#page-16">16</a>
     <a href="#section-12.2">12.2</a>. Informative References . . . . . . . . . . . . . . . . . . <a href="#page-17">17</a>



















<span class="grey">Hubert &amp; van Mook           Standards Track                     [Page 2]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-3" id="page-3" name="page-3"> </a>
<span class="grey"><a href="rfc5452.html">RFC 5452</a>         DNS Resilience against Forged Answers      January 2009</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/1.%20%20Introduction"></a><a class="selflink" href="#section-1" name="section-1">1</a>.  Introduction</span>

   This document describes several common problems in DNS
   implementations, which, although previously recognized, remain
   largely unsolved.  Besides briefly recapping these problems, this
   document contains rules that, if implemented, make complying
   resolvers vastly more resistant to the attacks described.  The goal
   is to make the existing DNS as secure as possible within the current
   protocol boundaries.

   The words below are aimed at authors of resolvers: it is up to
   operators to decide which nameserver implementation to use, or which
   options to enable.  Operational constraints may override the security
   concerns described below.  However, implementations are expected to
   allow an operator to enable functionality described in this document.

   Almost every transaction on the Internet involves the Domain Name
   System, which is described in [<a href="rfc1034.html" title='"Domain names - concepts and facilities"'>RFC1034</a>], [<a href="rfc1035.html" title='"Domain names - implementation and specification"'>RFC1035</a>], and beyond.

   Additionally, it has recently become possible to acquire Secure
   Socket Layer/Transport Layer Security (SSL/TLS) certificates with no
   other confirmation of identity than the ability to respond to a
   verification email sent via SMTP ([<a href="rfc5321.html" title='"Simple Mail Transfer Protocol"'>RFC5321</a>]) -- which generally uses
   DNS for its routing.

   In other words, any party that (temporarily) controls the Domain Name
   System is in a position to reroute most kinds of Internet
   transactions, including the verification steps in acquiring an SSL/
   TLS certificate for a domain.  This in turn means that even
   transactions protected by SSL/TLS could be diverted.

   It is entirely conceivable that such rerouted traffic could be used
   to the disadvantage of Internet users.

   These and other developments have made the security and
   trustworthiness of DNS of renewed importance.  Although the DNS
   community is working hard on finalizing and implementing a
   cryptographically enhanced DNS protocol, steps should be taken to
   make sure that the existing use of DNS is as secure as possible
   within the bounds of the relevant standards.

   It should be noted that the most commonly used resolvers currently do
   not perform as well as possible in this respect, making this document
   of urgent importance.

   A thorough analysis of risks facing DNS can be found in [<a href="rfc3833.html" title='"Threat Analysis of the Domain Name System (DNS)"'>RFC3833</a>].





<span class="grey">Hubert &amp; van Mook           Standards Track                     [Page 3]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-4" id="page-4" name="page-4"> </a>
<span class="grey"><a href="rfc5452.html">RFC 5452</a>         DNS Resilience against Forged Answers      January 2009</span>


   This document expands on some of the risks mentioned in <a href="rfc3833.html">RFC 3833</a>,
   especially those outlined in the sections on "ID Guessing and Query
   Prediction" and "Name Chaining".  Furthermore, it emphasizes a number
   of existing rules and guidelines embodied in the relevant DNS
   protocol specifications.  The following also specifies new
   requirements to make sure the Domain Name System can be relied upon
   until a more secure protocol has been standardized and deployed.

   It should be noted that even when all measures suggested below are
   implemented, protocol users are not protected against third parties
   with the ability to observe, modify, or inject packets in the traffic
   of a resolver.

   For protocol extensions that offer protection against these
   scenarios, see [<a href="rfc4033.html" title='"DNS Security Introduction and Requirements"'>RFC4033</a>] and beyond.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/2.%20%20Requirements%20and%20Definitions"></a><a class="selflink" href="#section-2" name="section-2">2</a>.  Requirements and Definitions</span>

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/2.1.%20%20Definitions"></a><a class="selflink" href="#section-2.1" name="section-2.1">2.1</a>.  Definitions</span>

   This document uses the following definitions:

      Client: typically a 'stub-resolver' on an end-user's computer.

      Resolver: a nameserver performing recursive service for clients,
      also known as a caching server, or a full service resolver
      (<a href="rfc1123.html#section-6.1.3.1">[RFC1123], Section 6.1.3.1</a>).

      Stub resolver: a very limited resolver on a client computer, that
      leaves the recursing work to a full resolver.

      Query: a question sent out by a resolver, typically in a UDP
      packet

      Response: the answer sent back by an authoritative nameserver,
      typically in a UDP packet.

      Third party: any entity other than the resolver or the intended
      recipient of a question.  The third party may have access to an
      arbitrary authoritative nameserver, but has no access to packets
      transmitted by the resolver or authoritative server.

      Attacker: malicious third party.

      Spoof: the activity of attempting to subvert the DNS process by
      getting a chosen answer accepted.





<span class="grey">Hubert &amp; van Mook           Standards Track                     [Page 4]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-5" id="page-5" name="page-5"> </a>
<span class="grey"><a href="rfc5452.html">RFC 5452</a>         DNS Resilience against Forged Answers      January 2009</span>


      Authentic response: the correct answer that comes from the right
      authoritative server.

      Target domain name: domain for which the attacker wishes to spoof
      in an answer

      Fake data: response chosen by the attacker.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/2.2.%20%20Key%20Words"></a><a class="selflink" href="#section-2.2" name="section-2.2">2.2</a>.  Key Words</span>

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in [<a href="rfc2119.html" title='"Key words for use in RFCs to Indicate Requirement Levels"'>RFC2119</a>].

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/3.%20%20Description%20of%20DNS%20Spoofing"></a><a class="selflink" href="#section-3" name="section-3">3</a>.  Description of DNS Spoofing</span>

   When certain steps are taken, it is feasible to "spoof" the current
   deployed majority of resolvers with carefully crafted and timed DNS
   packets.  Once spoofed, a caching server will repeat the data it
   wrongfully accepted, and make its clients contact the wrong, and
   possibly malicious, servers.

   To understand how this process works it is important to know what
   makes a resolver accept a response.

   The following sentence in <a href="rfc1034.html#section-5.3.3">Section 5.3.3 of [RFC1034]</a> presaged the
   present problem:

     The resolver should be highly paranoid in its parsing of responses.
     It should also check that the response matches the query it sent
     using the ID field in the response.

   DNS data is to be accepted by a resolver if and only if:

   1.  The question section of the reply packet is equivalent to that of
       a question packet currently waiting for a response.

   2.  The ID field of the reply packet matches that of the question
       packet.

   3.  The response comes from the same network address to which the
       question was sent.

   4.  The response comes in on the same network address, including port
       number, from which the question was sent.

   In general, the first response matching these four conditions is
   accepted.



<span class="grey">Hubert &amp; van Mook           Standards Track                     [Page 5]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-6" id="page-6" name="page-6"> </a>
<span class="grey"><a href="rfc5452.html">RFC 5452</a>         DNS Resilience against Forged Answers      January 2009</span>


   If a third party succeeds in meeting the four conditions before the
   response from the authentic nameserver does so, it is in a position
   to feed a resolver fabricated data.  When it does so, we dub it an
   "attacker", attempting to spoof in fake data.

   All conditions mentioned above can theoretically be met by a third
   party, with the difficulty being a function of the resolver
   implementation and zone configuration.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/4.%20%20Detailed%20Description%20of%20Spoofing%20Scenarios"></a><a class="selflink" href="#section-4" name="section-4">4</a>.  Detailed Description of Spoofing Scenarios</span>

   The previous paragraph discussed a number of requirements an attacker
   must match in order to spoof in manipulated (or fake) data.  This
   section discusses the relative difficulties and how implementation-
   defined choices impact the amount of work an attacker has to perform
   to meet said difficulties.

   Some more details can be found in <a href="rfc3833.html#section-2.2">Section 2.2 of [RFC3833]</a>.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.1.%20%20Forcing%20a%20Query"></a><a class="selflink" href="#section-4.1" name="section-4.1">4.1</a>.  Forcing a Query</span>

   Formally, there is no need for a nameserver to perform service except
   for its operator, its customers, or more generally its users.
   Recently, open recursing nameservers have been used to amplify
   denial-of-service attacks.

   Providing full service enables the third party to send the target
   resolver a query for the domain name it intends to spoof.  On
   receiving this query, and not finding the answer in its cache, the
   resolver will transmit queries to relevant authoritative nameservers.
   This opens up a window of opportunity for getting fake answer data
   accepted.

   Queries may however be forced indirectly, for example, by inducing a
   mail server to perform DNS lookups.

   Some operators restrict access by not recursing for unauthorized IP
   addresses, but only respond with data from the cache.  This makes
   spoofing harder for a third party as it cannot then force the exact
   moment a question will be asked.  It is still possible however to
   determine a time range when this will happen, because nameservers
   helpfully publish the decreasing time to live (TTL) of entries in the
   cache, which indicate from which absolute time onwards a new query
   could be sent to refresh the expired entry.

   The time to live of the target domain name's RRSets determines how
   often a window of opportunity is available, which implies that a
   short TTL makes spoofing far more viable.



<span class="grey">Hubert &amp; van Mook           Standards Track                     [Page 6]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-7" id="page-7" name="page-7"> </a>
<span class="grey"><a href="rfc5452.html">RFC 5452</a>         DNS Resilience against Forged Answers      January 2009</span>


   Note that the attacker might very well have authorized access to the
   target resolver by virtue of being a customer or employee of its
   operator.  In addition, access may be enabled through the use of
   reflectors as outlined in [<a href="rfc5358.html" title='"Preventing Use of Recursive Nameservers in Reflector Attacks"'>RFC5358</a>].

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.2.%20%20Matching%20the%20Question%20Section"></a><a class="selflink" href="#section-4.2" name="section-4.2">4.2</a>.  Matching the Question Section</span>

   DNS packets, both queries and responses, contain a question section.
   Incoming responses should be verified to have a question section that
   is equivalent to that of the outgoing query.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.3.%20%20Matching%20the%20ID%20Field"></a><a class="selflink" href="#section-4.3" name="section-4.3">4.3</a>.  Matching the ID Field</span>

   The DNS ID field is 16 bits wide, meaning that if full use is made of
   all these bits, and if their contents are truly random, it will
   require on average 32768 attempts to guess.  Anecdotal evidence
   suggests there are implementations utilizing only 14 bits, meaning on
   average 8192 attempts will suffice.

   Additionally, if the target nameserver can be forced into having
   multiple identical queries outstanding, the "Birthday Attack"
   phenomenon means that any fake data sent by the attacker is matched
   against multiple outstanding queries, significantly raising the
   chance of success.  Further details in <a href="#section-5">Section 5</a>.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.4.%20%20Matching%20the%20Source%20Address%20of%20the%20Authentic%20Response"></a><a class="selflink" href="#section-4.4" name="section-4.4">4.4</a>.  Matching the Source Address of the Authentic Response</span>

   It should be noted that meeting this condition entails being able to
   transmit packets on behalf of the address of the authoritative
   nameserver.  While two Best Current Practice documents ([<a href="rfc2827.html" title='"Network Ingress Filtering: Defeating Denial of Service Attacks which employ IP Source Address Spoofing"'>RFC2827</a>] and
   [<a href="rfc3013.html" title='"Recommended Internet Service Provider Security Services and Procedures"'>RFC3013</a>] specifically) direct Internet access providers to prevent
   their customers from assuming IP addresses that are not assigned to
   them, these recommendations are not universally (nor even widely)
   implemented.

   Many zones have two or three authoritative nameservers, which make
   matching the source address of the authentic response very likely
   with even a naive choice having a double digit success rate.

   Most recursing nameservers store relative performance indications of
   authoritative nameservers, which may make it easier to predict which
   nameserver would originally be queried -- the one most likely to
   respond the quickest.

   Generally, this condition requires at most two or three attempts
   before it is matched.





<span class="grey">Hubert &amp; van Mook           Standards Track                     [Page 7]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-8" id="page-8" name="page-8"> </a>
<span class="grey"><a href="rfc5452.html">RFC 5452</a>         DNS Resilience against Forged Answers      January 2009</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.5.%20%20Matching%20the%20Destination%20Address%20and%20Port%20of%20the%20Authentic"></a><a class="selflink" href="#section-4.5" name="section-4.5">4.5</a>.  Matching the Destination Address and Port of the Authentic</span>
<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/Response"></a>      Response</span>

   Note that the destination address of the authentic response is the
   source address of the original query.

   The actual address of a recursing nameserver is generally known; the
   port used for asking questions is harder to determine.  Most current
   resolvers pick an arbitrary port at startup (possibly at random) and
   use this for all outgoing queries.  In quite a number of cases, the
   source port of outgoing questions is fixed at the traditional DNS
   assigned server port number of 53.

   If the source port of the original query is random, but static, any
   authoritative nameserver under observation by the attacker can be
   used to determine this port.  This means that matching this
   conditions often requires no guess work.

   If multiple ports are used for sending queries, this enlarges the
   effective ID space by a factor equal to the number of ports used.

   Less common resolving servers choose a random port per outgoing
   query.  If this strategy is followed, this port number can be
   regarded as an additional ID field, again containing up to 16 bits.

   If the maximum ports range is utilized, on average, around 32256
   source ports would have to be tried before matching the source port
   of the original query, as ports below 1024 may be unavailable for
   use, leaving 64512 options.

   It is in general safe for DNS to use ports in the range 1024-49152
   even though some of these ports are allocated to other protocols.
   DNS resolvers will not be able to use any ports that are already in
   use.  If a DNS resolver uses a port, it will release that port after
   a short time and migrate to a different port.  Only in the case of a
   high-volume resolver is it possible that an application wanting a
   particular UDP port suffers a long term block-out.

   It should be noted that a firewall will not prevent the matching of
   this address, as it will accept answers that (appear to) come from
   the correct address, offering no additional security.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.6.%20%20Have%20the%20Response%20Arrive%20before%20the%20Authentic%20Response"></a><a class="selflink" href="#section-4.6" name="section-4.6">4.6</a>.  Have the Response Arrive before the Authentic Response</span>

   Once any packet has matched the previous four conditions (plus
   possible additional conditions), no further responses are generally
   accepted.




<span class="grey">Hubert &amp; van Mook           Standards Track                     [Page 8]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-9" id="page-9" name="page-9"> </a>
<span class="grey"><a href="rfc5452.html">RFC 5452</a>         DNS Resilience against Forged Answers      January 2009</span>


   This means that the third party has a limited time in which to inject
   its spoofed response.  For calculations, we will assume a window in
   order of at most 100 ms (depending on the network distance to the
   authentic authoritative nameserver).

   This time period can be far longer if the authentic authoritative
   nameservers are (briefly) overloaded by queries, perhaps by the
   attacker.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/5.%20%20Birthday%20Attacks"></a><a class="selflink" href="#section-5" name="section-5">5</a>.  Birthday Attacks</span>

   The so-called "birthday paradox" implies that a group of 23 people
   suffices to have a more than even chance of having two or more
   members of the group share a birthday.

   An attacker can benefit from this exact phenomenon if it can force
   the target resolver to have multiple equivalent (identical QNAME,
   QTYPE, and QCLASS) outstanding queries at any one time to the same
   authoritative server.

   Any packet the attacker sends then has a much higher chance of being
   accepted because it only has to match any of the outstanding queries
   for that single domain.  Compared to the birthday analogy above, of
   the group composed of queries and responses, the chance of having any
   of these share an ID rises quickly.

   As long as small numbers of queries are sent out, the chance of
   successfully spoofing a response rises linearly with the number of
   outstanding queries for the exact domain and nameserver.

   For larger numbers, this effect is less pronounced.

   More details are available in US-CERT [<a href="#ref-vu-457875" title='"Various DNS service implementations generate multiple simultaneous queries for the same resource record"'>vu-457875</a>].

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/6.%20%20Accepting%20Only%20In-Domain%20Records"></a><a class="selflink" href="#section-6" name="section-6">6</a>.  Accepting Only In-Domain Records</span>

   Responses from authoritative nameservers often contain information
   that is not part of the zone for which we deem it authoritative.  As
   an example, a query for the MX record of a domain might get as its
   responses a mail exchanger in another domain, and additionally the IP
   address of this mail exchanger.

   If accepted uncritically, the resolver stands the chance of accepting
   data from an untrusted source.  Care must be taken to only accept
   data if it is known that the originator is authoritative for the
   QNAME or a parent of the QNAME.





<span class="grey">Hubert &amp; van Mook           Standards Track                     [Page 9]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-10" id="page-10" name="page-10"> </a>
<span class="grey"><a href="rfc5452.html">RFC 5452</a>         DNS Resilience against Forged Answers      January 2009</span>


   One very simple way to achieve this is to only accept data if it is
   part of the domain for which the query was intended.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/7.%20%20Combined%20Difficulty"></a><a class="selflink" href="#section-7" name="section-7">7</a>.  Combined Difficulty</span>

   Given a known or static destination port, matching ID field, the
   source and destination address requires on average in the order of 2
   * 2^15 = 65000 packets, assuming a zone has 2 authoritative
   nameservers.

   If the window of opportunity available is around 100 ms, as assumed
   above, an attacker would need to be able to briefly transmit 650000
   packets/s to have a 50% chance to get spoofed data accepted on the
   first attempt.

   A realistic minimal DNS response consists of around 80 bytes,
   including IP headers, making the packet rate above correspond to a
   respectable burst of 416 Mbit/s.

   As of mid-2006, this kind of bandwidth was not common but not scarce
   either, especially among those in a position to control many servers.

   These numbers change when a window of a full second is assumed,
   possibly because the arrival of the authentic response can be
   prevented by overloading the bona fide authoritative hosts with decoy
   queries.  This reduces the needed bandwidth to 42 Mbit/s.

   If, in addition, the attacker is granted more than a single chance
   and allowed up to 60 minutes of work on a domain with a time to live
   of 300 seconds, a meager 4 Mbit/s suffices for a 50% chance at
   getting fake data accepted.  Once equipped with a longer time,
   matching condition 1 mentioned above is straightforward -- any
   popular domain will have been queried a number of times within this
   hour, and given the short TTL, this would lead to queries to
   authoritative nameservers, opening windows of opportunity.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/7.1.%20%20Symbols%20Used%20in%20Calculation"></a><a class="selflink" href="#section-7.1" name="section-7.1">7.1</a>.  Symbols Used in Calculation</span>

   Assume the following symbols are used:

   I: Number distinct IDs available (maximum 65536)

   P: Number of ports used (maximum around 64000 as ports under 1024 are
      not always available, but often 1)

   N: Number of authoritative nameservers for a domain (averages around
      2.5)




<span class="grey">Hubert &amp; van Mook           Standards Track                    [Page 10]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-11" id="page-11" name="page-11"> </a>
<span class="grey"><a href="rfc5452.html">RFC 5452</a>         DNS Resilience against Forged Answers      January 2009</span>


   F: Number of "fake" packets sent by the attacker

   R: Number of packets sent per second by the attacker

   W: Window of opportunity, in seconds.  Bounded by the response time
      of the authoritative servers (often 0.1s)

   D: Average number of identical outstanding queries of a resolver
      (typically 1, see <a href="#section-5">Section 5</a>)

   A: Number of attempts, one for each window of opportunity

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/7.2.%20%20Calculation"></a><a class="selflink" href="#section-7.2" name="section-7.2">7.2</a>.  Calculation</span>

   The probability of spoofing a resolver is equal to the amount of fake
   packets that arrive within the window of opportunity, divided by the
   size of the problem space.

   When the resolver has 'D' multiple identical outstanding queries,
   each fake packet has a proportionally higher chance of matching any
   of these queries.  This assumption only holds for small values of
   'D'.

   In symbols, if the probability of being spoofed is denoted as P_s:

              D * F
   P_s =    ---------
            N * P * I

   It is more useful to reason not in terms of aggregate packets but to
   convert to packet rate, which can easily be converted to bandwidth if
   needed.

   If the window of opportunity length is 'W' and the attacker can send
   'R' packets per second, the number of fake packets 'F' that are
   candidates to be accepted is:

                          D * R * W
   F = R * W  -&gt;   P_s  = ---------
                          N * P * I

   Finally, to calculate the combined chance 'P_cs' of spoofing over a
   chosen time period 'T', it should be realized that the attacker has a
   new window of opportunity each time the TTL 'TTL' of the target
   domain expires.  This means that the number of attempts 'A' is equal
   to 'T / TTL'.





<span class="grey">Hubert &amp; van Mook           Standards Track                    [Page 11]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-12" id="page-12" name="page-12"> </a>
<span class="grey"><a href="rfc5452.html">RFC 5452</a>         DNS Resilience against Forged Answers      January 2009</span>


   To calculate the combined chance of at least one success, the
   following formula holds:

                                                        (T / TTL)
                         A          (       D * R * W )
   P_cs = 1 - ( 1 - P_s )    =  1 - ( 1  -  --------- )
                                    (       N * P * I )

   When common numbers (as listed above) for D, W, N, P, and I are
   inserted, this formula reduces to:

                               (T / TTL)
              (         R    )
   P_cs = 1 - ( 1 -  ------- )
              (      1638400 )

   From this formula, it can be seen that, if the nameserver
   implementation is unchanged, only raising the TTL offers protection.
   Raising N, the number of authoritative nameservers, is not feasible
   beyond a small number.

   For the degenerate case of a zero-second TTL, a window of opportunity
   opens for each query sent, making the effective TTL equal to 'W'
   above, the response time of the authoritative server.

   This last case also holds for spoofing techniques that do not rely on
   TTL expiry, but use repeated and changing queries.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/8.%20%20Discussion"></a><a class="selflink" href="#section-8" name="section-8">8</a>.  Discussion</span>

   The calculations above indicate the relative ease with which DNS data
   can be spoofed.  For example, using the formula derived earlier on an
   RRSet with a 3600 second TTL, an attacker sending 7000 fake response
   packets/s (a rate of 4.5 Mbit/s), stands a 10% chance of spoofing a
   record in the first 24 hours, which rises to 50% after a week.

   For an RRSet with a TTL of 60 seconds, the 10% level is hit after 24
   minutes, 50% after less than 3 hours, 90% after around 9 hours.

   For some classes of attacks, the effective TTL is near zero, as noted
   above.

   Note that the attacks mentioned above can be detected by watchful
   server operators - an unexpected incoming stream of 4.5 Mbit/s of
   packets might be noticed.

   An important assumption however in these calculations is a known or
   static destination port of the authentic response.



<span class="grey">Hubert &amp; van Mook           Standards Track                    [Page 12]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-13" id="page-13" name="page-13"> </a>
<span class="grey"><a href="rfc5452.html">RFC 5452</a>         DNS Resilience against Forged Answers      January 2009</span>


   If that port number is unknown and needs to be guessed as well, the
   problem space expands by a factor of 64000, leading the attacker to
   need in excess of 285Gb/s to achieve similar success rates.

   Such bandwidth is not generally available, nor is it expected to be
   so in the foreseeable future.

   Note that some firewalls may need reconfiguring if they are currently
   set up to only allow outgoing queries from a single DNS source port.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/8.1.%20%20Repetitive%20Spoofing%20Attempts%20for%20a%20Single%20Domain%20Name"></a><a class="selflink" href="#section-8.1" name="section-8.1">8.1</a>.  Repetitive Spoofing Attempts for a Single Domain Name</span>

   Techniques are available to use an effectively infinite number of
   queries to achieve a desired spoofing goal.  In the math above, this
   reduces the effective TTL to 0.

   If such techniques are employed, using the same 7000 packets/s rate
   mentioned above, and using 1 source port, the spoofing chance rises
   to 50% within 7 seconds.

   If 64000 ports are used, as recommended in this document, using the
   same query rate, the 50% level is reached after around 116 hours.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/9.%20%20Forgery%20Countermeasures"></a><a class="selflink" href="#section-9" name="section-9">9</a>.  Forgery Countermeasures</span>

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/9.1.%20%20Query%20Matching%20Rules"></a><a class="selflink" href="#section-9.1" name="section-9.1">9.1</a>.  Query Matching Rules</span>

   A resolver implementation MUST match responses to all of the
   following attributes of the query:

   o  Source address against query destination address

   o  Destination address against query source address

   o  Destination port against query source port

   o  Query ID

   o  Query name

   o  Query class and type

   before applying DNS trustworthiness rules (see <a href="rfc2181.html#section-5.4.1">Section 5.4.1 of
   [RFC2181]</a>).

   A mismatch and the response MUST be considered invalid.





<span class="grey">Hubert &amp; van Mook           Standards Track                    [Page 13]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-14" id="page-14" name="page-14"> </a>
<span class="grey"><a href="rfc5452.html">RFC 5452</a>         DNS Resilience against Forged Answers      January 2009</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/9.2.%20%20Extending%20the%20Q-ID%20Space%20by%20Using%20Ports%20and%20Addresses"></a><a class="selflink" href="#section-9.2" name="section-9.2">9.2</a>.  Extending the Q-ID Space by Using Ports and Addresses</span>

   Resolver implementations MUST:

   o  Use an unpredictable source port for outgoing queries from the
      range of available ports (53, or 1024 and above) that is as large
      as possible and practicable;

   o  Use multiple different source ports simultaneously in case of
      multiple outstanding queries;

   o  Use an unpredictable query ID for outgoing queries, utilizing the
      full range available (0-65535).

   Resolvers that have multiple IP addresses SHOULD use them in an
   unpredictable manner for outgoing queries.

   Resolver implementations SHOULD provide means to avoid usage of
   certain ports.

   Resolvers SHOULD favor authoritative nameservers with which a trust
   relation has been established; stub-resolvers SHOULD be able to use
   Transaction Signature (TSIG) ([<a href="rfc2845.html" title='"Secret Key Transaction Authentication for DNS (TSIG)"'>RFC2845</a>]) or IPsec ([<a href="rfc4301.html" title='"Security Architecture for the Internet Protocol"'>RFC4301</a>]) when
   communicating with their recursive resolver.

   In case a cryptographic verification of response validity is
   available (TSIG, SIG(0)), resolver implementations MAY waive above
   rules, and rely on this guarantee instead.

   Proper unpredictability can be achieved by employing a high quality
   (pseudo-)random generator, as described in [<a href="rfc4086.html" title='"Randomness Requirements for Security"'>RFC4086</a>].

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/9.2.1.%20%20Justification%20and%20Discussion"></a><a class="selflink" href="#section-9.2.1" name="section-9.2.1">9.2.1</a>.  Justification and Discussion</span>

   Since an attacker can force a full DNS resolver to send queries to
   the attacker's own nameservers, any constant or sequential state held
   by such a resolver can be measured, and it must not be trivially easy
   to reverse engineer the resolver's internal state in a way that
   allows low-cost, high-accuracy prediction of future state.

   A full DNS resolver with only one or a small number of upstream-
   facing endpoints is effectively using constants for IP source address
   and UDP port number, and these are very predictable by potential
   attackers, and must therefore be avoided.

   A full DNS resolver that uses a simple increment to get its next DNS
   query ID is likewise very predictable and so very spoofable.




<span class="grey">Hubert &amp; van Mook           Standards Track                    [Page 14]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-15" id="page-15" name="page-15"> </a>
<span class="grey"><a href="rfc5452.html">RFC 5452</a>         DNS Resilience against Forged Answers      January 2009</span>


   Finally, weak random number generators have been shown to expose
   their internal state, such that an attacker who witnesses several
   sequential "random" values can easily predict the next ones.  A
   crypto-strength random number generator is one whose output cannot be
   predicted no matter how many successive values are witnessed.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/9.3.%20%20Spoof%20Detection%20and%20Countermeasure"></a><a class="selflink" href="#section-9.3" name="section-9.3">9.3</a>.  Spoof Detection and Countermeasure</span>

   If a resolver detects that an attempt is being made to spoof it,
   perhaps by discovering that many packets fail the criteria as
   outlined above, it MAY abandon the UDP query and re-issue it over
   TCP.  TCP, by the nature of its use of sequence numbers, is far more
   resilient against forgery by third parties.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/10.%20%20Security%20Considerations"></a><a class="selflink" href="#section-10" name="section-10">10</a>.  Security Considerations</span>

   This document provides clarification of the DNS specification to
   decrease the probability that DNS responses can be successfully
   forged.  Recommendations found above should be considered
   complementary to possible cryptographical enhancements of the domain
   name system, which protect against a larger class of attacks.

   This document recommends the use of UDP source port number
   randomization to extend the effective DNS transaction ID beyond the
   available 16 bits.

   A resolver that does not implement the recommendations outlined above
   can easily be forced to accept spoofed responses, which in turn are
   passed on to client computers -- misdirecting (user) traffic to
   possibly malicious entities.

   This document directly impacts the security of the Domain Name
   System, implementers are urged to follow its recommendations.

   Most security considerations can be found in Sections <a href="#section-4">4</a> and <a href="#section-5">5</a>, while
   proposed countermeasures are described in <a href="#section-9">Section 9</a>.

   For brevity's sake, in lieu of repeating the security considerations
   references, the reader is referred to these sections.

   Nothing in this document specifies specific algorithms for operators
   to use; it does specify algorithms implementations SHOULD or MUST
   support.

   It should be noted that the effects of source port randomization may
   be dramatically reduced by NAT devices that either serialize or limit
   in volume the UDP source ports used by the querying resolver.




<span class="grey">Hubert &amp; van Mook           Standards Track                    [Page 15]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-16" id="page-16" name="page-16"> </a>
<span class="grey"><a href="rfc5452.html">RFC 5452</a>         DNS Resilience against Forged Answers      January 2009</span>


   DNS recursive servers sitting behind at NAT or a statefull firewall
   may consume all available NAT translation entries/ports when
   operating under high query load.  Port randomization will cause
   translation entries to be consumed faster than with fixed query port.

   To avoid this, NAT boxes and statefull firewalls can/should purge
   outgoing DNS query translation entries 10-17 seconds after the last
   outgoing query on that mapping was sent.  [<a href="rfc4787.html" title='"Network Address Translation (NAT) Behavioral Requirements for Unicast UDP"'>RFC4787</a>]-compliant devices
   need to treat UDP messages with port 53 differently than most other
   UDP protocols.

   To minimize the potential that port/state exhaustion attacks can be
   staged from the outside, it is recommended that services that
   generate a number of DNS queries for each connection should be rate
   limited.  This applies in particular to email servers.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/11.%20%20Acknowledgments"></a><a class="selflink" href="#section-11" name="section-11">11</a>.  Acknowledgments</span>

   Source port randomization in DNS was first implemented and possibly
   invented by Dan J. Bernstein.

   Although any mistakes remain our own, the authors gratefully
   acknowledge the help and contributions of:
      Stephane Bortzmeyer
      Alfred Hoenes
      Peter Koch
      Sean Leach
      Norbert Sendetzky
      Paul Vixie
      Florian Weimer
      Wouter Wijngaards
      Dan Wing

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/12.%20%20References"></a><a class="selflink" href="#section-12" name="section-12">12</a>.  References</span>

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/12.1.%20%20Normative%20References"></a><a class="selflink" href="#section-12.1" name="section-12.1">12.1</a>.  Normative References</span>

   [<a id="ref-RFC1034" name="ref-RFC1034">RFC1034</a>]    Mockapetris, P., "Domain names - concepts and
                facilities", STD 13, <a href="rfc1034.html">RFC 1034</a>, November 1987.

   [<a id="ref-RFC1035" name="ref-RFC1035">RFC1035</a>]    Mockapetris, P., "Domain names - implementation and
                specification", STD 13, <a href="rfc1035.html">RFC 1035</a>, November 1987.

   [<a id="ref-RFC2119" name="ref-RFC2119">RFC2119</a>]    Bradner, S., "Key words for use in RFCs to Indicate
                Requirement Levels", <a href="https://tools.ietf.org/html/bcp14">BCP 14</a>, <a href="rfc2119.html">RFC 2119</a>, March 1997.

   [<a id="ref-RFC2181" name="ref-RFC2181">RFC2181</a>]    Elz, R. and R. Bush, "Clarifications to the DNS
                Specification", <a href="rfc2181.html">RFC 2181</a>, July 1997.



<span class="grey">Hubert &amp; van Mook           Standards Track                    [Page 16]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-17" id="page-17" name="page-17"> </a>
<span class="grey"><a href="rfc5452.html">RFC 5452</a>         DNS Resilience against Forged Answers      January 2009</span>


   [<a id="ref-RFC2827" name="ref-RFC2827">RFC2827</a>]    Ferguson, P. and D. Senie, "Network Ingress Filtering:
                Defeating Denial of Service Attacks which employ IP
                Source Address Spoofing", <a href="https://tools.ietf.org/html/bcp38">BCP 38</a>, <a href="rfc2827.html">RFC 2827</a>, May 2000.

   [<a id="ref-RFC2845" name="ref-RFC2845">RFC2845</a>]    Vixie, P., Gudmundsson, O., Eastlake, D., and B.
                Wellington, "Secret Key Transaction Authentication for
                DNS (TSIG)", <a href="rfc2845.html">RFC 2845</a>, May 2000.

   [<a id="ref-RFC3013" name="ref-RFC3013">RFC3013</a>]    Killalea, T., "Recommended Internet Service Provider
                Security Services and Procedures", <a href="https://tools.ietf.org/html/bcp46">BCP 46</a>, <a href="rfc3013.html">RFC 3013</a>,
                November 2000.

   [<a id="ref-RFC4033" name="ref-RFC4033">RFC4033</a>]    Arends, R., Austein, R., Larson, M., Massey, D., and S.
                Rose, "DNS Security Introduction and Requirements",
                <a href="rfc4033.html">RFC 4033</a>, March 2005.

   [<a id="ref-RFC4086" name="ref-RFC4086">RFC4086</a>]    Eastlake, D., Schiller, J., and S. Crocker, "Randomness
                Requirements for Security", <a href="https://tools.ietf.org/html/bcp106">BCP 106</a>, <a href="rfc4086.html">RFC 4086</a>,
                June 2005.

   [<a id="ref-RFC5321" name="ref-RFC5321">RFC5321</a>]    Klensin, J., "Simple Mail Transfer Protocol", <a href="rfc5321.html">RFC 5321</a>,
                October 2008.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/12.2.%20%20Informative%20References"></a><a class="selflink" href="#section-12.2" name="section-12.2">12.2</a>.  Informative References</span>

   [<a id="ref-RFC1123" name="ref-RFC1123">RFC1123</a>]    Braden, R., "Requirements for Internet Hosts -
                Application and Support", STD 3, <a href="rfc1123.html">RFC 1123</a>, October 1989.

   [<a id="ref-RFC3833" name="ref-RFC3833">RFC3833</a>]    Atkins, D. and R. Austein, "Threat Analysis of the
                Domain Name System (DNS)", <a href="rfc3833.html">RFC 3833</a>, August 2004.

   [<a id="ref-RFC4301" name="ref-RFC4301">RFC4301</a>]    Kent, S. and K. Seo, "Security Architecture for the
                Internet Protocol", <a href="rfc4301.html">RFC 4301</a>, December 2005.

   [<a id="ref-RFC4787" name="ref-RFC4787">RFC4787</a>]    Audet, F. and C. Jennings, "Network Address Translation
                (NAT) Behavioral Requirements for Unicast UDP", <a href="https://tools.ietf.org/html/bcp127">BCP 127</a>,
                <a href="rfc4787.html">RFC 4787</a>, January 2007.

   [<a id="ref-RFC5358" name="ref-RFC5358">RFC5358</a>]    Damas, J. and F. Neves, "Preventing Use of Recursive
                Nameservers in Reflector Attacks", <a href="https://tools.ietf.org/html/bcp140">BCP 140</a>, <a href="rfc5358.html">RFC 5358</a>,
                October 2008.

   [<a id="ref-vu-457875" name="ref-vu-457875">vu-457875</a>]  United States CERT, "Various DNS service implementations
                generate multiple simultaneous queries for the same
                resource record", VU 457875, November 2002.






<span class="grey">Hubert &amp; van Mook           Standards Track                    [Page 17]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-18" id="page-18" name="page-18"> </a>
<span class="grey"><a href="rfc5452.html">RFC 5452</a>         DNS Resilience against Forged Answers      January 2009</span>


Authors' Addresses

   Bert Hubert
   Netherlabs Computer Consulting BV.
   Braillelaan 10
   Rijswijk (ZH)  2289 CM
   The Netherlands

   EMail: bert.hubert@netherlabs.nl


   Remco van Mook
   Equinix
   Auke Vleerstraat 1
   Enschede  7521 PE
   The Netherlands

   EMail: remco@eu.equinix.com

































Hubert &amp; van Mook           Standards Track                    [Page 18]

</pre><br/>
    <span class="noprint"><small><small>Html markup produced by rfcmarkup 1.126, available from
      <a href="https://tools.ietf.org/tools/rfcmarkup/">https://tools.ietf.org/tools/rfcmarkup/</a>
    </small></small></span>
  </div>




</body><!-- Mirrored from tools.ietf.org/html/rfc5452 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 06 Mar 2018 23:18:35 GMT --></html>