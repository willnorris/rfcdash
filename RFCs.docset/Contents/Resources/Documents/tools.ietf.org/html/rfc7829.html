<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml"><!-- Mirrored from tools.ietf.org/html/rfc7829 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 06 Mar 2018 23:18:19 GMT --><!-- Added by HTTrack --><head><meta content="text/html;charset=utf-8" http-equiv="content-type"/><!-- /Added by HTTrack -->

    <meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
    <meta content="index,follow" name="robots"/>
    <meta content="rfcmarkup version 1.126" name="creator"/>
    <link href="http://purl.org/dc/elements/1.1/" rel="schema.DC"/>
<meta content="draft-nishida-tsvwg-sctp-failover" name="DC.Relation.Replaces"/>
<meta content="urn:ietf:rfc:7829" name="DC.Identifier"/>
<meta content="April, 2016" name="DC.Date.Issued"/>
<meta content="Nielsen, Karen E. E." name="DC.Creator"/>
<meta content="Natarajan, Preethi" name="DC.Creator"/>
<meta content="Amer, Paul" name="DC.Creator"/>
<meta content="Nishida, Yoshifumi" name="DC.Creator"/>
<meta content="Caro, Armando" name="DC.Creator"/>
<meta content='The Stream Control Transmission Protocol (SCTP) supports multihoming.
However, when the failover operation specified in RFC 4960 is
followed, there can be significant delay and performance degradation
in the data transfer path failover. This document specifies a quick
failover algorithm and introduces the SCTP Potentially Failed (SCTP-
PF) destination state in SCTP Path Management.  This document also
specifies a dormant state operation of SCTP that is required to be
followed by an SCTP-PF implementation, but it may equally well be
applied by a standard SCTP implementation, as described in RFC 4960.
Additionally, this document introduces an alternative switchback
operation mode called "Primary Path Switchover" that will be
beneficial in certain situations. This mode of operation applies to
both a standard SCTP implementation and an SCTP-PF implementation.
The procedures defined in the document require only minimal
modifications to the specification in RFC 4960. The procedures are
sender-side only and do not impact the SCTP receiver.' name="DC.Description.Abstract"/>
<meta content="SCTP-PF: A Quick Failover Algorithm for the Stream Control Transmission Protocol" name="DC.Title"/>

    <link href="https://tools.ietf.org/images/rfc.png" rel="icon" type="image/png"/>
    <link href="https://tools.ietf.org/images/rfc.png" rel="shortcut icon" type="image/png"/>
    <title>RFC 7829 - SCTP-PF: A Quick Failover Algorithm for the Stream Control Transmission Protocol</title>
    
    
    <style type="text/css">
	@media only screen 
	  and (min-width: 992px)
	  and (max-width: 1199px) {
	    body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 768px)
	  and (max-width: 991px) {
            body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 480px)
	  and (max-width: 767px) {
            body { font-size: 11pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (max-width: 479px) {
            body { font-size: 8pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-device-width : 375px) 
	  and (max-device-width : 667px) {
            body { font-size: 9.5pt; }
            div.content { width: 96ex; margin: 0 1px; }
        }
	@media only screen 
	  and (min-device-width: 1200px) {
            body { font-size: 10pt; margin: 0 4em; }
            div.content { width: 96ex; margin: 0; }
        }
        h1, h2, h3, h4, h5, h6, .h1, .h2, .h3, .h4, .h5, .h6 {
	    font-weight: bold;
            line-height: 0pt;
            display: inline;
            white-space: pre;
            font-family: monospace;
            font-size: 1em;
	    font-weight: bold;
        }
        pre {
            font-size: 1em;
            margin-top: 0px;
            margin-bottom: 0px;
        }
	.pre {
	    white-space: pre;
	    font-family: monospace;
	}
	.header{
	    font-weight: bold;
	}
        .newpage {
            page-break-before: always;
        }
        .invisible {
            text-decoration: none;
            color: white;
        }
        a.selflink {
          color: black;
          text-decoration: none;
        }
        @media print {
            body {
                font-family: monospace;
                font-size: 10.5pt;
            }
            h1, h2, h3, h4, h5, h6 {
                font-size: 1em;
            }
        
            a:link, a:visited {
                color: inherit;
                text-decoration: none;
            }
            .noprint {
                display: none;
            }
        }
	@media screen {
	    .grey, .grey a:link, .grey a:visited {
		color: #777;
	    }
            .docinfo {
                background-color: #EEE;
            }
            .top {
                border-top: 7px solid #EEE;
            }
            .bgwhite  { background-color: white; }
            .bgred    { background-color: #F44; }
            .bggrey   { background-color: #666; }
            .bgbrown  { background-color: #840; }            
            .bgorange { background-color: #FA0; }
            .bgyellow { background-color: #EE0; }
            .bgmagenta{ background-color: #F4F; }
            .bgblue   { background-color: #66F; }
            .bgcyan   { background-color: #4DD; }
            .bggreen  { background-color: #4F4; }

            .legend   { font-size: 90%; }
            .cplate   { font-size: 70%; border: solid grey 1px; }
	}
    </style>
    <!--[if IE]>
    <style>
    body {
       font-size: 13px;
       margin: 10px 10px;
    }
    </style>
    <![endif]-->

    <script type="text/javascript"><!--
    function addHeaderTags() {
	var spans = document.getElementsByTagName("span");
	for (var i=0; i < spans.length; i++) {
	    var elem = spans[i];
	    if (elem) {
		var level = elem.getAttribute("class");
                if (level == "h1" || level == "h2" || level == "h3" || level == "h4" || level == "h5" || level == "h6") {
                    elem.innerHTML = "<"+level+">"+elem.innerHTML+"</"+level+">";		
                }
	    }
	}
    }
    var legend_html = "Colour legend:<br />      <table>         <tr><td>Unknown:</td>                   <td><span class='cplate bgwhite'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft:</td>                     <td><span class='cplate bgred'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Informational:</td>             <td><span class='cplate bgorange'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Experimental:</td>              <td><span class='cplate bgyellow'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Best Common Practice:</td>      <td><span class='cplate bgmagenta'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Proposed Standard:</td>         <td><span class='cplate bgblue'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft Standard (old designation):</td> <td><span class='cplate bgcyan'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Internet Standard:</td>         <td><span class='cplate bggreen'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Historic:</td>                  <td><span class='cplate bggrey'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Obsolete:</td>                  <td><span class='cplate bgbrown'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>     </table>";
    function showElem(id) {
        var elem = document.getElementById(id);
        elem.innerHTML = eval(id+"_html");
        elem.style.visibility='visible';
    }
    function hideElem(id) {
        var elem = document.getElementById(id);
        elem.style.visibility='hidden';        
        elem.innerHTML = "";
    }
    // -->
    </script>
</head>
<body onload="addHeaderTags()">
  <div class="content">
   <div style="height: 13px;">
      <div class="pre noprint docinfo bgblue" onclick="showElem('legend');" onmouseout="hideElem('legend')" onmouseover="this.style.cursor='pointer';" style="height: 6px; position: absolute;" title="Click for colour legend.">                                                                        </div>
      <div class="docinfo noprint pre legend" id="legend" onmouseout="hideElem('legend');" onmouseover="showElem('legend');" style="position:absolute; top: 4px; left: 4ex; visibility:hidden; background-color: white; padding: 4px 9px 5px 7px; border: solid #345 1px; ">
      </div>
   </div>
<span class="pre noprint docinfo top">[<a href="index.html" title="Document search and retrieval page">Docs</a>] [<a href="https://tools.ietf.org/rfc/rfc7829.txt" title="Plaintext version of this document">txt</a>|<a href="https://tools.ietf.org/pdf/rfc7829" title="PDF version of this document">pdf</a>] [<a href="https://tools.ietf.org/html/draft-ietf-tsvwg-sctp-failover" title="draft-ietf-tsvwg-sctp-failover">draft-ietf-tsvw...</a>] [<a href="https://datatracker.ietf.org/doc/rfc7829" title="IESG Datatracker information for this document">Tracker</a>] [<a href="https://tools.ietf.org/rfcdiff?difftype=--hwdiff&amp;url2=rfc7829" title="Inline diff (wdiff)">Diff1</a>] [<a href="https://tools.ietf.org/rfcdiff?url2=rfc7829" title="Side-by-side diff">Diff2</a>]         </span><br/>
<span class="pre noprint docinfo">                                                                        </span><br/>
<span class="pre noprint docinfo">                                                       PROPOSED STANDARD</span><br/>
<span class="pre noprint docinfo">                                                                        </span><br/>
<pre>Internet Engineering Task Force (IETF)                        Y. Nishida
Request for Comments: 7829                            GE Global Research
Category: Standards Track                                   P. Natarajan
ISSN: 2070-1721                                            Cisco Systems
                                                                 A. Caro
                                                        BBN Technologies
                                                                 P. Amer
                                                  University of Delaware
                                                              K. Nielsen
                                                                Ericsson
                                                              April 2016


              <span class="h1">SCTP-PF: A Quick Failover Algorithm for the</span>
                  <span class="h1">Stream Control Transmission Protocol</span>

Abstract

   The Stream Control Transmission Protocol (SCTP) supports multihoming.
   However, when the failover operation specified in <a href="rfc4960.html">RFC 4960</a> is
   followed, there can be significant delay and performance degradation
   in the data transfer path failover.  This document specifies a quick
   failover algorithm and introduces the SCTP Potentially Failed
   (SCTP-PF) destination state in SCTP Path Management.

   This document also specifies a dormant state operation of SCTP that
   is required to be followed by an SCTP-PF implementation, but it may
   equally well be applied by a standard SCTP implementation, as
   described in <a href="rfc4960.html">RFC 4960</a>.

   Additionally, this document introduces an alternative switchback
   operation mode called "Primary Path Switchover" that will be
   beneficial in certain situations.  This mode of operation applies to
   both a standard SCTP implementation and an SCTP-PF implementation.

   The procedures defined in the document require only minimal
   modifications to the specification in <a href="rfc4960.html">RFC 4960</a>.  The procedures are
   sender-side only and do not impact the SCTP receiver.













<span class="grey">Nishida, et al.              Standards Track                    [Page 1]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-2" id="page-2" name="page-2"> </a>
<span class="grey"><a href="rfc7829.html">RFC 7829</a>                         SCTP-PF                      April 2016</span>


Status of This Memo

   This is an Internet Standards Track document.

   This document is a product of the Internet Engineering Task Force
   (IETF).  It represents the consensus of the IETF community.  It has
   received public review and has been approved for publication by the
   Internet Engineering Steering Group (IESG).  Further information on
   Internet Standards is available in <a href="rfc5741.html#section-2">Section 2 of RFC 5741</a>.

   Information about the current status of this document, any errata,
   and how to provide feedback on it may be obtained at
   <a href="http://www.rfc-editor.org/info/rfc7829">http://www.rfc-editor.org/info/rfc7829</a>.

Copyright Notice

   Copyright (c) 2016 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to <a href="https://tools.ietf.org/html/bcp78">BCP 78</a> and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (<a href="http://trustee.ietf.org/license-info">http://trustee.ietf.org/license-info</a>) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.























<span class="grey">Nishida, et al.              Standards Track                    [Page 2]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-3" id="page-3" name="page-3"> </a>
<span class="grey"><a href="rfc7829.html">RFC 7829</a>                         SCTP-PF                      April 2016</span>


Table of Contents

   <a href="#section-1">1</a>.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   <a href="#page-3">3</a>
   <a href="#section-2">2</a>.  Conventions and Terminology . . . . . . . . . . . . . . . . .   <a href="#page-5">5</a>
   <a href="#section-3">3</a>.  SCTP with Potentially Failed (SCTP-PF) Destination State  . .   <a href="#page-5">5</a>
     <a href="#section-3.1">3.1</a>.  Overview  . . . . . . . . . . . . . . . . . . . . . . . .   <a href="#page-5">5</a>
     <a href="#section-3.2">3.2</a>.  Specification of the SCTP-PF Procedures . . . . . . . . .   <a href="#page-6">6</a>
   <a href="#section-4">4</a>.  Dormant State Operation . . . . . . . . . . . . . . . . . . .  <a href="#page-10">10</a>
     <a href="#section-4.1">4.1</a>.  SCTP Dormant State Procedure  . . . . . . . . . . . . . .  <a href="#page-11">11</a>
   <a href="#section-5">5</a>.  Primary Path Switchover . . . . . . . . . . . . . . . . . . .  <a href="#page-11">11</a>
   <a href="#section-6">6</a>.  Suggested SCTP Protocol Parameter Values  . . . . . . . . . .  <a href="#page-13">13</a>
   <a href="#section-7">7</a>.  Socket API Considerations . . . . . . . . . . . . . . . . . .  <a href="#page-13">13</a>
     <a href="#section-7.1">7.1</a>.  Support for the Potentially Failed Path State . . . . . .  <a href="#page-14">14</a>
     7.2.  Peer Address Thresholds (SCTP_PEER_ADDR_THLDS) Socket
           Option  . . . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-15">15</a>
     7.3.  Exposing the Potentially Failed Path State
           (SCTP_EXPOSE_POTENTIALLY_FAILED_STATE) Socket Option  . .  <a href="#page-16">16</a>
   <a href="#section-8">8</a>.  Security Considerations . . . . . . . . . . . . . . . . . . .  <a href="#page-16">16</a>
   <a href="#section-9">9</a>.  MIB Considerations  . . . . . . . . . . . . . . . . . . . . .  <a href="#page-17">17</a>
   <a href="#section-10">10</a>. References  . . . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-17">17</a>
     <a href="#section-10.1">10.1</a>.  Normative References . . . . . . . . . . . . . . . . . .  <a href="#page-17">17</a>
     <a href="#section-10.2">10.2</a>.  Informative References . . . . . . . . . . . . . . . . .  <a href="#page-18">18</a>
   <a href="#appendix-A">Appendix A</a>.  Discussion of Alternative Approaches . . . . . . . .  <a href="#page-20">20</a>
     <a href="#appendix-A.1">A.1</a>.  Reduce PMR  . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-20">20</a>
     <a href="#appendix-A.2">A.2</a>.  Adjust RTO-Related Parameters . . . . . . . . . . . . . .  <a href="#page-21">21</a>
   <a href="#appendix-B">Appendix B</a>.  Discussion of the Path-Bouncing Effect . . . . . . .  <a href="#page-21">21</a>
   <a href="#appendix-C">Appendix C</a>.  SCTP-PF for SCTP Single-Homed Operation  . . . . . .  <a href="#page-22">22</a>
   Acknowledgments . . . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-22">22</a>
   Authors' Addresses  . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-23">23</a>

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/1.%20%20Introduction"></a><a class="selflink" href="#section-1" name="section-1">1</a>.  Introduction</span>

   The Stream Control Transmission Protocol (SCTP) specified in
   [<a href="rfc4960.html" title='"Stream Control Transmission Protocol"'>RFC4960</a>] supports multihoming at the transport layer.  SCTP's
   multihoming features include failure detection and failover
   procedures to provide network interface redundancy and improved end-
   to-end fault tolerance.  In SCTP's current failure detection
   procedure, the sender must experience Path.Max.Retrans (PMR) number
   of consecutive failed timer-based retransmissions on a destination
   address before detecting a path failure.  Until detecting the path
   failure, the sender continues to transmit data on the failed path.
   The prolonged time in which SCTP as described in [<a href="rfc4960.html" title='"Stream Control Transmission Protocol"'>RFC4960</a>] continues
   to use a failed path severely degrades the performance of the
   protocol.  To address this problem, this document specifies a quick
   failover algorithm called "SCTP-PF" based on the introduction of a
   new Potentially Failed (PF) path state in SCTP path management.  The





<span class="grey">Nishida, et al.              Standards Track                    [Page 3]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-4" id="page-4" name="page-4"> </a>
<span class="grey"><a href="rfc7829.html">RFC 7829</a>                         SCTP-PF                      April 2016</span>


   performance deficiencies of the failover operation described in <a href="rfc4960.html">RFC</a>
   <a href="rfc4960.html">4960</a>, and the improvements obtainable from the introduction of a PF
   state in SCTP, were proposed and documented in [<a href="#ref-NATARAJAN09">NATARAJAN09</a>] for
   Concurrent Multipath Transfer SCTP [<a href="#ref-IYENGAR06">IYENGAR06</a>].

   While SCTP-PF can accelerate the failover process and improve
   performance, the risk that an SCTP endpoint might enter the dormant
   state where all destination addresses are inactive can be increased.
   [<a href="rfc4960.html" title='"Stream Control Transmission Protocol"'>RFC4960</a>] leaves the protocol operation during dormant state to
   implementations and encourages avoiding entering the state as much as
   possible by careful tuning of the PMR and Association.Max.Retrans
   (AMR) parameters.  We specify a dormant state operation for SCTP-PF,
   which makes SCTP-PF provide the same disruption tolerance as
   [<a href="rfc4960.html" title='"Stream Control Transmission Protocol"'>RFC4960</a>] despite the fact that the dormant state may be entered more
   quickly.  The dormant state operation may equally well be applied by
   an implementation of [<a href="rfc4960.html" title='"Stream Control Transmission Protocol"'>RFC4960</a>] and will serve here to provide added
   fault tolerance for situations where the tuning of the PMR and AMR
   parameters fail to provide adequate prevention of the entering of the
   dormant state.

   The operation after the recovery of a failed path also impacts the
   performance of the protocol.  With the procedures specified in
   [<a href="rfc4960.html" title='"Stream Control Transmission Protocol"'>RFC4960</a>], SCTP will (after a failover from the primary path) switch
   back to use the primary path for data transfer as soon as this path
   becomes available again.  From a performance perspective, such a
   forced switchback of the data transmission path can be suboptimal as
   the Congestion Window (CWND) towards the original primary destination
   address has to be rebuilt once data transfer resumes, [<a href="#ref-CARO02" title='"A Two-level Threshold Recovery Mechanism for SCTP"'>CARO02</a>].  As
   an optional alternative to the switchback operation of [<a href="rfc4960.html" title='"Stream Control Transmission Protocol"'>RFC4960</a>],
   this document specifies an alternative Primary Path Switchover
   procedure that avoids such forced switchbacks of the data transfer
   path.  The Primary Path Switchover operation was originally proposed
   in [<a href="#ref-CARO02" title='"A Two-level Threshold Recovery Mechanism for SCTP"'>CARO02</a>].

   While SCTP-PF is primarily motivated by a desire to improve the
   multihomed operation, the feature also applies to SCTP single-homed
   operation.  Here the algorithm serves to provide increased failure
   detection on idle associations, whereas the failover or switchback
   aspects of the algorithm will not be activated.  This is discussed in
   more detail in <a href="#appendix-C">Appendix C</a>.

   A brief description of the motivation for the introduction of the PF
   state, including a discussion of alternative approaches to mitigate
   the deficiencies of the failover operation in [<a href="rfc4960.html" title='"Stream Control Transmission Protocol"'>RFC4960</a>], are given in
   the appendices.  Discussion of path-bouncing effects that might be
   caused by frequent switchovers are also provided there.





<span class="grey">Nishida, et al.              Standards Track                    [Page 4]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-5" id="page-5" name="page-5"> </a>
<span class="grey"><a href="rfc7829.html">RFC 7829</a>                         SCTP-PF                      April 2016</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/2.%20%20Conventions%20and%20Terminology"></a><a class="selflink" href="#section-2" name="section-2">2</a>.  Conventions and Terminology</span>

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in [<a href="rfc2119.html" title='"Key words for use in RFCs to Indicate Requirement Levels"'>RFC2119</a>].

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/3.%20%20SCTP%20with%20Potentially%20Failed%20%28SCTP-PF%29%20Destination%20State"></a><a class="selflink" href="#section-3" name="section-3">3</a>.  SCTP with Potentially Failed (SCTP-PF) Destination State</span>

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.1.%20%20Overview"></a><a class="selflink" href="#section-3.1" name="section-3.1">3.1</a>.  Overview</span>

   To minimize the performance impact during failover, the sender should
   avoid transmitting data to a failed destination address as early as
   possible.  In the SCTP path management scheme described in [<a href="rfc4960.html" title='"Stream Control Transmission Protocol"'>RFC4960</a>],
   the sender stops transmitting data to a destination address only
   after the destination address is marked inactive.  This process takes
   a significant amount of time as it requires the error counter of the
   destination address to exceed the PMR threshold.  The issue cannot
   simply be mitigated by lowering the PMR threshold because this may
   result in spurious failure detection and unnecessary prevention of
   the usage of a preferred primary path.  Also, due to the coupled
   tuning of the PMR and the AMR parameter values in [<a href="rfc4960.html" title='"Stream Control Transmission Protocol"'>RFC4960</a>], lowering
   the PMR threshold may result in lowering the AMR threshold, which
   would result in a decrease of the fault tolerance of SCTP.

   The solution provided in this document is to extend the SCTP path
   management scheme of [<a href="rfc4960.html" title='"Stream Control Transmission Protocol"'>RFC4960</a>] by the addition of the PF state as an
   intermediate state in between the active and inactive state of a
   destination address in the path management scheme of [<a href="rfc4960.html" title='"Stream Control Transmission Protocol"'>RFC4960</a>], and
   let the failover of data transfer away from a destination address be
   driven by the entering of the PF state instead of by the entering of
   the inactive state.  Thereby, SCTP may perform quick failover without
   negatively impacting the overall fault tolerance of SCTP as described
   in [<a href="rfc4960.html" title='"Stream Control Transmission Protocol"'>RFC4960</a>].  At the same time, HEARTBEAT probing based on
   Retransmission Timeout (RTO) is initiated towards a destination
   address once it enters PF state.  Thereby, SCTP may quickly ascertain
   whether network connectivity towards the destination address is
   broken or whether the failover was spurious.  In the case where the
   failover was spurious, data transfer may quickly resume towards the
   original destination address.

   The new failure detection algorithm assumes that loss detected by a
   timeout implies either severe congestion or network connectivity
   failure.  It recommends that, by default, a destination address be
   classified as PF at the occurrence of the first timeout.







<span class="grey">Nishida, et al.              Standards Track                    [Page 5]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-6" id="page-6" name="page-6"> </a>
<span class="grey"><a href="rfc7829.html">RFC 7829</a>                         SCTP-PF                      April 2016</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.2.%20%20Specification%20of%20the%20SCTP-PF%20Procedures"></a><a class="selflink" href="#section-3.2" name="section-3.2">3.2</a>.  Specification of the SCTP-PF Procedures</span>

   The SCTP-PF operation is specified as follows:

   1.   The sender maintains a new tunable SCTP Protocol Parameter
        called PotentiallyFailed.Max.Retrans (PFMR).  The PFMR defines
        the new intermediate PF threshold on the destination address
        error counter.  When this threshold is exceeded, the destination
        address is classified as PF.  The RECOMMENDED value of PFMR is
        0.  If PFMR is set to be greater than or equal to PMR, the
        resulting PF threshold will be so high that the destination
        address will reach the inactive state before it can be
        classified as PF.

   2.   The error counter of an active destination address is
        incremented or cleared as specified in [<a href="rfc4960.html" title='"Stream Control Transmission Protocol"'>RFC4960</a>].  This means
        that the error counter of the destination address in active
        state will be incremented each time the Timer T3 retransmission
        (T3-rtx) timer expires, or each time a HEARTBEAT chunk is sent
        when idle and not acknowledged within an RTO.  When the value in
        the destination address error counter exceeds PFMR, the endpoint
        MUST mark the destination address as in the PF state.

   3.   An SCTP-PF sender SHOULD NOT send data to destination addresses
        in PF state when alternative destination addresses in active
        state are available.  Specifically, this means that:

        i.     When there is outbound data to send and the destination
               address presently used for data transmission is in PF
               state, the sender SHOULD choose a destination address in
               active state, if one exists, and use this destination
               address for data transmission.

        ii.    As specified in <a href="rfc4960.html#section-6.4.1">Section 6.4.1 of [RFC4960]</a>, when the
               sender retransmits data that has timed out, they should
               attempt to pick a new destination address for data
               retransmission.  In this case, the sender SHOULD choose
               an alternate destination transport address in active
               state, if one exists.

        iii.   When there is outbound data to send and the SCTP user
               explicitly requests to send data to a destination address
               in PF state, the sender SHOULD send the data to an
               alternate destination address in active state if one
               exists.






<span class="grey">Nishida, et al.              Standards Track                    [Page 6]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-7" id="page-7" name="page-7"> </a>
<span class="grey"><a href="rfc7829.html">RFC 7829</a>                         SCTP-PF                      April 2016</span>


        When choosing among multiple destination addresses in active
        state, an SCTP sender will follow the guiding principles of
        <a href="rfc4960.html#section-6.4.1">Section 6.4.1 of [RFC4960]</a> by choosing the most divergent
        source-destination pairs compared with, for (the aforementioned
        points i and ii):

        i.    the destination address in PF state that it performs a
              failover from, and

        ii.   the destination address towards which the data timed out.

        Rules for picking the most divergent source-destination pair are
        an implementation decision and are not specified within this
        document.

        In all cases, the sender MUST NOT change the state of the chosen
        destination address, whether this state be active or PF, and it
        MUST NOT clear the error counter of the destination address as a
        result of choosing the destination address for data
        transmission.

   4.   When the destination addresses are all in PF state, or some are
        in PF state and some in inactive state, the sender MUST choose
        one destination address in PF state and SHOULD transmit or
        retransmit data to this destination address using the following
        rules:

        i.    The sender SHOULD choose the destination in PF state with
              the lowest error count (fewest consecutive timeouts) for
              data transmission and transmit or retransmit data to this
              destination.

        ii.   When there are multiple destination addresses in PF state
              with same error count, the sender should let the choice
              among the multiple destination addresses in PF state with
              equal error count be based on the principles of choosing
              the most divergent source-destination pairs when executing
              (potentially consecutive) retransmission outlined in
              <a href="rfc4960.html#section-6.4.1">Section 6.4.1 of [RFC4960]</a>.  Rules for picking the most
              divergent source-destination pairs are an implementation
              decision and are not specified within this document.

        The sender MUST NOT change the state and the error counter of
        any destination addresses as the result of the selection.

   5.   The HB.Interval of the Path Heartbeat function of [<a href="rfc4960.html" title='"Stream Control Transmission Protocol"'>RFC4960</a>] MUST
        be ignored for destination addresses in PF state.  Instead,
        HEARTBEAT chunks are sent to destination addresses in PF state



<span class="grey">Nishida, et al.              Standards Track                    [Page 7]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-8" id="page-8" name="page-8"> </a>
<span class="grey"><a href="rfc7829.html">RFC 7829</a>                         SCTP-PF                      April 2016</span>


        once per RTO.  HEARTBEAT chunks SHOULD be sent to destination
        addresses in PF state, but the sending of HEARTBEATs MUST honor
        whether or not the Path Heartbeat function (<a href="rfc4960.html#section-8.3">Section 8.3 of
        [RFC4960]</a>) is enabled for the destination address.  That is, if
        the Path Heartbeat function is disabled for the destination
        address in question, HEARTBEATs MUST NOT be sent.  Note that
        when the Path Heartbeat function is disabled, it may take longer
        to transition a destination address in PF state back to active
        state.

   6.   HEARTBEATs are sent when a destination address reaches the PF
        state.  When a HEARTBEAT chunk is not acknowledged within the
        RTO, the sender increments the error counter and exponentially
        backs off the RTO value.  If the error counter is less than PMR,
        the sender transmits another packet containing the HEARTBEAT
        chunk immediately after timeout expiration on the previous
        HEARTBEAT.  When data is being transmitted to a destination
        address in the PF state, the transmission of a HEARTBEAT chunk
        MAY be omitted in the case where the receipt of a Selective
        Acknowledgment (SACK) of the data or a T3-rtx timer expiration
        on the data can provide equivalent information, such as the case
        where the data chunk has been transmitted to a single
        destination address only.  Likewise, the timeout of a HEARTBEAT
        chunk MAY be ignored if data is outstanding towards the
        destination address.

   7.   When the sender receives a HEARTBEAT ACK from a HEARTBEAT sent
        to a destination address in PF state, the sender SHOULD clear
        the error counter of the destination address and transition the
        destination address back to active state.  However, there may be
        a situation where HEARTBEAT chunks can go through while DATA
        chunks cannot.  Hence, in a situation where a HEARTBEAT ACK
        arrives while there is data outstanding towards the destination
        address to which the HEARTBEAT was sent, then an implementation
        MAY choose to not have the HEARTBEAT ACK reset the error
        counter, but have the error counter reset await the fate of the
        outstanding data transmission.  This situation can happen when
        data is sent to a destination address in PF state.  When the
        sender resumes data transmission on a destination address after
        a transition of the destination address from PF to active state,
        it MUST do this following the prescriptions of <a href="rfc4960.html#section-7.2">Section 7.2 of
        [RFC4960]</a>.

   8.   Additional PMR - PFMR consecutive timeouts on a destination
        address in PF state confirm the path failure, upon which the
        destination address transitions to the inactive state.  As
        described in [<a href="rfc4960.html" title='"Stream Control Transmission Protocol"'>RFC4960</a>], the sender SHOULD (i) notify the Upper
        Layer Protocol (ULP) about this state transition, and (ii)



<span class="grey">Nishida, et al.              Standards Track                    [Page 8]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-9" id="page-9" name="page-9"> </a>
<span class="grey"><a href="rfc7829.html">RFC 7829</a>                         SCTP-PF                      April 2016</span>


        transmit HEARTBEAT chunks to the inactive destination address at
        a lower HB.Interval frequency as described in <a href="rfc4960.html#section-8.3">Section 8.3 of
        [RFC4960]</a> (when the Path Heartbeat function is enabled for the
        destination address).

   9.   Acknowledgments for chunks that have been transmitted to
        multiple destinations (i.e., a chunk that has been retransmitted
        to a different destination address than the destination address
        to which the chunk was first transmitted) SHOULD NOT clear the
        error count for an inactive destination address and SHOULD NOT
        move a destination address in PF state back to active state,
        since a sender cannot disambiguate whether the ACK was for the
        original transmission or the retransmission(s).  An SCTP sender
        MAY clear the error counter and move a destination address back
        to active state by information other than acknowledgments, when
        it can uniquely determine which destination, among multiple
        destination addresses, the chunk reached.  This document makes
        no reference to what such information could consist of, nor how
        such information could be obtained.

   10.  Acknowledgments for data chunks that have been transmitted to
        one destination address only MUST clear the error counter for
        the destination address and MUST transition a destination
        address in PF state back to active state.  This situation can
        happen when new data is sent to a destination address in the PF
        state.  It can also happen in situations where the destination
        address is in the PF state due to the occurrence of a spurious
        T3-rtx timer and acknowledgments start to arrive for data sent
        prior to occurrence of the spurious T3-rtx and data has not yet
        been retransmitted towards other destinations.  This document
        does not specify special handling for detection of, or reaction
        to, spurious T3-rtx timeouts, e.g., for special operation vis-
        a-vis the congestion control handling or data retransmission
        operation towards a destination address that undergoes a
        transition from active to PF to active state due to a spurious
        T3-rtx timeout.  But it is noted that this is an area that would
        benefit from additional attention, experimentation, and
        specification for single-homed SCTP as well as for multihomed
        SCTP protocol operation.

   11.  When all destination addresses are in inactive state, and SCTP
        protocol operation thus is said to be in dormant state, the
        prescriptions given in <a href="#section-4">Section 4</a> shall be followed.

   12.  The SCTP stack SHOULD expose the PF state of its destination
        addresses to the ULP as well as provide the means to notify the
        ULP of state transitions of its destination addresses from
        active to PF, and vice versa.  However, it is recommended that



<span class="grey">Nishida, et al.              Standards Track                    [Page 9]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-10" id="page-10" name="page-10"> </a>
<span class="grey"><a href="rfc7829.html">RFC 7829</a>                         SCTP-PF                      April 2016</span>


        an SCTP stack implementing SCTP-PF also allows for the ULP to be
        kept ignorant of the PF state of its destinations and the
        associated state transitions, thus allowing for retention of the
        simpler state transition model of [<a href="rfc4960.html" title='"Stream Control Transmission Protocol"'>RFC4960</a>] in the ULP.  For
        this reason, it is recommended that an SCTP stack implementing
        SCTP-PF also provide the ULP with the means to suppress exposure
        of the PF state and the associated state transitions.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/4.%20%20Dormant%20State%20Operation"></a><a class="selflink" href="#section-4" name="section-4">4</a>.  Dormant State Operation</span>

   In a situation with complete disruption of the communication in
   between the SCTP endpoints, the aggressive HEARTBEAT transmissions of
   SCTP-PF on destination addresses in PF state may make the association
   enter dormant state faster than a standard SCTP implementation of
   [<a href="rfc4960.html" title='"Stream Control Transmission Protocol"'>RFC4960</a>] given the same setting of PMR and AMR.  For example, an
   SCTP association with two destination addresses would typically reach
   dormant state in half the time of an SCTP implementation of [<a href="rfc4960.html" title='"Stream Control Transmission Protocol"'>RFC4960</a>]
   in such situations.  This is because an SCTP PF sender will send
   HEARTBEATs and data retransmissions in parallel with RTO intervals
   when there are multiple destinations addresses in PF state.  This
   argument presumes that RTO &lt;&lt; HB.Interval of [<a href="rfc4960.html" title='"Stream Control Transmission Protocol"'>RFC4960</a>].  With the
   design goal that SCTP-PF shall provide the same level of disruption
   tolerance as a standard SCTP implementation with the same PMR and AMR
   setting, we prescribe that an SCTP-PF implementation SHOULD operate
   as described in <a href="#section-4.1">Section 4.1</a> during dormant state.

   An SCTP-PF implementation MAY choose a different dormant state
   operation than the one described in <a href="#section-4.1">Section 4.1</a> provided that the
   solution chosen does not decrease the fault tolerance of the SCTP-PF
   operation.

   The prescription below for SCTP-PF dormant state handling MUST NOT be
   coupled to the value of the PFMR, but solely to the activation of
   SCTP-PF logic in an SCTP implementation.

   It is noted that the below dormant state operation can also provide
   enhanced disruption tolerance to a standard SCTP implementation that
   doesn't support SCTP-PF.  Thus, it can be sensible for a standard
   SCTP implementation to follow this mode of operation.  For a standard
   SCTP implementation, the continuation of data transmission during
   dormant state makes the fault tolerance of SCTP be more robust
   towards situations where some, or all, alternative paths of an SCTP
   association approach, or reach, inactive state before the primary
   path used for data transmission observes trouble.







<span class="grey">Nishida, et al.              Standards Track                   [Page 10]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-11" id="page-11" name="page-11"> </a>
<span class="grey"><a href="rfc7829.html">RFC 7829</a>                         SCTP-PF                      April 2016</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.1.%20%20SCTP%20Dormant%20State%20Procedure"></a><a class="selflink" href="#section-4.1" name="section-4.1">4.1</a>.  SCTP Dormant State Procedure</span>

   1.  When the destination addresses are all in inactive state and data
       is available for transfer, the sender MUST choose one destination
       and transmit data to this destination address.

   2.  The sender MUST NOT change the state of the chosen destination
       address (it remains in inactive state) and MUST NOT clear the
       error counter of the destination address as a result of choosing
       the destination address for data transmission.

   3.  The sender SHOULD choose the destination in inactive state with
       the lowest error count (fewest consecutive timeouts) for data
       transmission.  When there are multiple destinations with the same
       error count in inactive state, the sender SHOULD attempt to pick
       the most divergent source -- destination pair from the last
       source -- destination pair where failure was observed.  Rules for
       picking the most divergent source-destination pair are an
       implementation decision and are not specified within this
       document.  To support differentiation of inactive destination
       addresses based on their error count, SCTP will need to allow for
       incrementing of the destination address error counters up to some
       reasonable limit above PMR+1, thus changing the prescriptions of
       <a href="rfc4960.html#section-8.3">Section 8.3 of [RFC4960]</a> in this respect.  The exact limit to
       apply is not specified in this document, but it is considered
       reasonable enough to require that the limit be an order of
       magnitude higher than the PMR value.  A sender MAY choose to
       deploy other strategies than the strategy defined here.  The
       strategy to prioritize the last active destination address, i.e.,
       the destination address with the fewest error counts is optimal
       when some paths are permanently inactive, but suboptimal when
       path instability is transient.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/5.%20%20Primary%20Path%20Switchover"></a><a class="selflink" href="#section-5" name="section-5">5</a>.  Primary Path Switchover</span>

   The objective of the Primary Path Switchover operation is to allow
   the SCTP sender to continue data transmission on a new working path
   even when the old primary destination address becomes active again.
   This is achieved by having SCTP perform a switchover of the primary
   path to the new working path if the error counter of the primary path
   exceeds a certain threshold.  This mode of operation can be applied
   not only to SCTP-PF implementations, but also to implementations of
   [<a href="rfc4960.html" title='"Stream Control Transmission Protocol"'>RFC4960</a>].








<span class="grey">Nishida, et al.              Standards Track                   [Page 11]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-12" id="page-12" name="page-12"> </a>
<span class="grey"><a href="rfc7829.html">RFC 7829</a>                         SCTP-PF                      April 2016</span>


   The Primary Path Switchover operation requires only sender-side
   changes.  The details are:

   1.  The sender maintains a new tunable parameter, called
       Primary.Switchover.Max.Retrans (PSMR).  For SCTP-PF
       implementations, the PSMR MUST be set greater than or equal to
       the PFMR value.  For implementations of [<a href="rfc4960.html" title='"Stream Control Transmission Protocol"'>RFC4960</a>], the PSMR MUST
       be set greater than or equal to the PMR value.  Implementations
       MUST reject any other values of PSMR.

   2.  When the path error counter on a set primary path exceeds PSMR,
       the SCTP implementation MUST autonomously select and set a new
       primary path.

   3.  The primary path selected by the SCTP implementation MUST be the
       path that, at the given time, would be chosen for data transfer.
       A previously failed primary path can be used as a data transfer
       path as per normal path selection when the present data transfer
       path fails.

   4.  For SCTP-PF, the recommended value of PSMR is PFMR when Primary
       Path Switchover operation mode is used.  This means that no
       forced switchback to a previously failed primary path is
       performed.  An SCTP-PF implementation of Primary Path Switchover
       MUST support the setting of PSMR = PFMR.  An SCTP-PF
       implementation of Primary Path Switchover MAY support setting of
       PSMR &gt; PFMR.

   5.  For standard SCTP, the recommended value of PSMR is PMR when
       Primary Path Switchover is used.  This means that no forced
       switchback to a previously failed primary path is performed.  A
       standard SCTP implementation of Primary Path Switchover MUST
       support the setting of PSMR = PMR.  A standard SCTP
       implementation of Primary Path Switchover MAY support larger
       settings of PSMR &gt; PMR.

   6.  It MUST be possible to disable the Primary Path Switchover
       operation and obtain the standard switchback operation of
       [<a href="rfc4960.html" title='"Stream Control Transmission Protocol"'>RFC4960</a>].

   The manner of switchover operation that is most optimal in a given
   scenario depends on the relative quality of a set primary path versus
   the quality of alternative paths available as well as on the extent
   to which it is desired for the mode of operation to enforce traffic
   distribution over a number of network paths.  That is, load
   distribution of traffic from multiple SCTP associations may be
   enforced by distribution of the set primary paths with the switchback
   operation of [<a href="rfc4960.html" title='"Stream Control Transmission Protocol"'>RFC4960</a>].  However, as switchback behavior of [<a href="rfc4960.html" title='"Stream Control Transmission Protocol"'>RFC4960</a>]



<span class="grey">Nishida, et al.              Standards Track                   [Page 12]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-13" id="page-13" name="page-13"> </a>
<span class="grey"><a href="rfc7829.html">RFC 7829</a>                         SCTP-PF                      April 2016</span>


   is suboptimal in certain situations, especially in scenarios where a
   number of equally good paths are available, an SCTP implementation
   MAY support also, as alternative behavior, the Primary Path
   Switchover mode of operation and MAY enable it based on applications'
   requests.

   For an SCTP implementation that implements the Primary Path
   Switchover operation, this specification RECOMMENDS that the standard
   switchback operation of [<a href="rfc4960.html" title='"Stream Control Transmission Protocol"'>RFC4960</a>] be retained as the default
   operation.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/6.%20%20Suggested%20SCTP%20Protocol%20Parameter%20Values"></a><a class="selflink" href="#section-6" name="section-6">6</a>.  Suggested SCTP Protocol Parameter Values</span>

   This document does not alter the value recommendation for the SCTP
   Protocol Parameters defined in [<a href="rfc4960.html" title='"Stream Control Transmission Protocol"'>RFC4960</a>].

   The following protocol parameter is RECOMMENDED:

      PotentiallyFailed.Max.Retrans (PFMR) - 0

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/7.%20%20Socket%20API%20Considerations"></a><a class="selflink" href="#section-7" name="section-7">7</a>.  Socket API Considerations</span>

   This section describes how the socket API defined in [<a href="rfc6458.html" title='"Sockets API Extensions for the Stream Control Transmission Protocol (SCTP)"'>RFC6458</a>] is
   extended to provide a way for the application to control and observe
   the SCTP-PF behavior as well as the Primary Path Switchover function.

   Please note that this section is informational only.

   A socket API implementation based on [<a href="rfc6458.html" title='"Sockets API Extensions for the Stream Control Transmission Protocol (SCTP)"'>RFC6458</a>] is, by means of the
   existing SCTP_PEER_ADDR_CHANGE event, extended to provide the event
   notification when a peer address enters or leaves the PF state as
   well as the socket API implementation is extended to expose the PF
   state of a peer address in the existing SCTP_GET_PEER_ADDR_INFO
   structure.

   Furthermore, two new read/write socket options for the level
   IPPROTO_SCTP and the name SCTP_PEER_ADDR_THLDS and
   SCTP_EXPOSE_POTENTIALLY_FAILED_STATE are defined as described below.
   The first socket option is used to control the values of the PFMR and
   PSMR parameters described in Sections <a href="#section-3">3</a> and <a href="#section-5">5</a>.  The second one
   controls the exposition of the PF path state.

   Support for the SCTP_PEER_ADDR_THLDS and
   SCTP_EXPOSE_POTENTIALLY_FAILED_STATE socket options also needs to be
   added to the function sctp_opt_info().






<span class="grey">Nishida, et al.              Standards Track                   [Page 13]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-14" id="page-14" name="page-14"> </a>
<span class="grey"><a href="rfc7829.html">RFC 7829</a>                         SCTP-PF                      April 2016</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/7.1.%20%20Support%20for%20the%20Potentially%20Failed%20Path%20State"></a><a class="selflink" href="#section-7.1" name="section-7.1">7.1</a>.  Support for the Potentially Failed Path State</span>

   As defined in [<a href="rfc6458.html" title='"Sockets API Extensions for the Stream Control Transmission Protocol (SCTP)"'>RFC6458</a>], the SCTP_PEER_ADDR_CHANGE event is provided
   if the status of a peer address changes.  In addition to the state
   changes described in [<a href="rfc6458.html" title='"Sockets API Extensions for the Stream Control Transmission Protocol (SCTP)"'>RFC6458</a>], this event is also provided if a peer
   address enters or leaves the PF state.  The notification as defined
   in [<a href="rfc6458.html" title='"Sockets API Extensions for the Stream Control Transmission Protocol (SCTP)"'>RFC6458</a>] uses the following structure:

   struct sctp_paddr_change {
     uint16_t spc_type;
     uint16_t spc_flags;
     uint32_t spc_length;
     struct sockaddr_storage spc_aaddr;
     uint32_t spc_state;
     uint32_t spc_error;
     sctp_assoc_t spc_assoc_id;
   }

   [<a id="ref-RFC6458" name="ref-RFC6458">RFC6458</a>] defines the constants SCTP_ADDR_AVAILABLE,
   SCTP_ADDR_UNREACHABLE, SCTP_ADDR_REMOVED, SCTP_ADDR_ADDED, and
   SCTP_ADDR_MADE_PRIM to be provided in the spc_state field.  This
   document defines the new additional constant
   SCTP_ADDR_POTENTIALLY_FAILED, which is reported if the affected
   address becomes PF.

   The SCTP_GET_PEER_ADDR_INFO socket option defined in [<a href="rfc6458.html" title='"Sockets API Extensions for the Stream Control Transmission Protocol (SCTP)"'>RFC6458</a>] can be
   used to query the state of a peer address.  It uses the following
   structure:

   struct sctp_paddrinfo {
     sctp_assoc_t spinfo_assoc_id;
     struct sockaddr_storage spinfo_address;
     int32_t spinfo_state;
     uint32_t spinfo_cwnd;
     uint32_t spinfo_srtt;
     uint32_t spinfo_rto;
     uint32_t spinfo_mtu;
   };

   [<a id="ref-RFC6458" name="ref-RFC6458">RFC6458</a>] defines the constants SCTP_UNCONFIRMED, SCTP_ACTIVE, and
   SCTP_INACTIVE to be provided in the spinfo_state field.  This
   document defines the new additional constant SCTP_POTENTIALLY_FAILED,
   which is reported if the peer address is PF.








<span class="grey">Nishida, et al.              Standards Track                   [Page 14]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-15" id="page-15" name="page-15"> </a>
<span class="grey"><a href="rfc7829.html">RFC 7829</a>                         SCTP-PF                      April 2016</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/7.2.%20%20Peer%20Address%20Thresholds%20%28SCTP_PEER_ADDR_THLDS%29%20Socket%20Option"></a><a class="selflink" href="#section-7.2" name="section-7.2">7.2</a>.  Peer Address Thresholds (SCTP_PEER_ADDR_THLDS) Socket Option</span>

   Applications can control the SCTP-PF behavior by getting or setting
   the number of consecutive timeouts before a peer address is
   considered PF or unreachable.  The same socket option is used by
   applications to set and get the number of timeouts before the primary
   path is changed automatically by the Primary Path Switchover
   function.  This socket option uses the level IPPROTO_SCTP and the
   name SCTP_PEER_ADDR_THLDS.

   The following structure is used to access and modify the thresholds:

   struct sctp_paddrthlds {
     sctp_assoc_t spt_assoc_id;
     struct sockaddr_storage spt_address;
     uint16_t spt_pathmaxrxt;
     uint16_t spt_pathpfthld;
     uint16_t spt_pathcpthld;
   };

   spt_assoc_id:  This parameter is ignored for one-to-one style
      sockets.  For one-to-many style sockets, the application may fill
      in an association identifier or SCTP_FUTURE_ASSOC.  It is an error
      to use SCTP_{CURRENT|ALL}_ASSOC in spt_assoc_id.

   spt_address:  This specifies which peer address is of interest.  If a
      wildcard address is provided, this socket option applies to all
      current and future peer addresses.

   spt_pathmaxrxt:  Each peer address of interest is considered
      unreachable, if its path error counter exceeds spt_pathmaxrxt.

   spt_pathpfthld:  Each peer address of interest is considered PF, if
      its path error counter exceeds spt_pathpfthld.

   spt_pathcpthld:  Each peer address of interest is not considered the
      primary remote address anymore, if its path error counter exceeds
      spt_pathcpthld.  Using a value of 0xffff disables the selection of
      a new primary peer address.  If an implementation does not support
      the automatic selection of a new primary address, it should
      indicate an error with errno set to EINVAL if a value different
      from 0xffff is used in spt_pathcpthld.  For SCTP-PF, the setting
      of spt_pathcpthld &lt; spt_pathpfthld should be rejected with errno
      set to EINVAL.  For standard SCTP, the setting of spt_pathcpthld &lt;
      spt_pathmaxrxt should be rejected with errno set to EINVAL.  An
      SCTP-PF implementation may support only setting of spt_pathcpthld
      = spt_pathpfthld and spt_pathcpthld = 0xffff and a standard SCTP




<span class="grey">Nishida, et al.              Standards Track                   [Page 15]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-16" id="page-16" name="page-16"> </a>
<span class="grey"><a href="rfc7829.html">RFC 7829</a>                         SCTP-PF                      April 2016</span>


      implementation may support only setting of spt_pathcpthld =
      spt_pathmaxrxt and spt_pathcpthld = 0xffff.  In these cases, SCTP
      shall reject setting of other values with errno set to EINVAL.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/7.3.%20%20Exposing%20the%20Potentially%20Failed%20Path%20State"></a><a class="selflink" href="#section-7.3" name="section-7.3">7.3</a>.  Exposing the Potentially Failed Path State</span>
      (SCTP_EXPOSE_POTENTIALLY_FAILED_STATE) Socket Option

   Applications can control the exposure of the PF path state in the
   SCTP_PEER_ADDR_CHANGE event and the SCTP_GET_PEER_ADDR_INFO as
   described in <a href="#section-7.1">Section 7.1</a>.  The default value is implementation
   specific.

   This socket option uses the level IPPROTO_SCTP and the name
   SCTP_EXPOSE_POTENTIALLY_FAILED_STATE.

   The following structure is used to control the exposition of the PF
   path state:

   struct sctp_assoc_value {
     sctp_assoc_t assoc_id;
     uint32_t assoc_value;
   };

   assoc_id:  This parameter is ignored for one-to-one style sockets.
      For one-to-many style sockets, the application may fill in an
      association identifier or SCTP_FUTURE_ASSOC.  It is an error to
      use SCTP_{CURRENT|ALL}_ASSOC in assoc_id.

   assoc_value:  The PF path state is exposed if, and only if, this
      parameter is non-zero.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/8.%20%20Security%20Considerations"></a><a class="selflink" href="#section-8" name="section-8">8</a>.  Security Considerations</span>

   Security considerations for the use of SCTP and its APIs are
   discussed in [<a href="rfc4960.html" title='"Stream Control Transmission Protocol"'>RFC4960</a>] and [<a href="rfc6458.html" title='"Sockets API Extensions for the Stream Control Transmission Protocol (SCTP)"'>RFC6458</a>].

   The logic introduced by this document does not impact existing SCTP
   messages on the wire.  Also, this document does not introduce any new
   SCTP messages on the wire that require new security considerations.

   SCTP-PF makes SCTP not only more robust during primary path failure/
   congestion, but also more vulnerable to network connectivity/
   congestion attacks on the primary path.  SCTP-PF makes it easier for
   an attacker to trick SCTP into changing the data transfer path, since
   the duration of time that an attacker needs to negatively influence
   the network connectivity is much shorter than used in [<a href="rfc4960.html" title='"Stream Control Transmission Protocol"'>RFC4960</a>].
   However, SCTP-PF does not constitute a significant change in the
   duration of time and effort an attacker needs to keep SCTP away from



<span class="grey">Nishida, et al.              Standards Track                   [Page 16]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-17" id="page-17" name="page-17"> </a>
<span class="grey"><a href="rfc7829.html">RFC 7829</a>                         SCTP-PF                      April 2016</span>


   the primary path.  With the standard switchback operation in
   [<a href="rfc4960.html" title='"Stream Control Transmission Protocol"'>RFC4960</a>], SCTP resumes data transfer on its primary path as soon as
   the next HEARTBEAT succeeds.

   On the other hand, usage of the Primary Path Switchover mechanism,
   does change the threat analysis.  This is because on-path attackers
   can force a permanent change of the data transfer path by blocking
   the primary path until the switchover of the primary path is
   triggered by the Primary Path Switchover algorithm.  This will
   especially be the case when the Primary Path Switchover is used
   together with SCTP-PF with the particular setting of PSMR = PFMR = 0,
   as Primary Path Switchover here happens already at the first RTO
   timeout experienced.  Users of the Primary Path Switchover mechanism
   should be aware of this fact.

   The event notification of path state transfer from active to PF state
   and vice versa gives attackers an increased possibility to generate
   more local events.  However, it is assumed that event notifications
   are rate-limited in the implementation to address this threat.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/9.%20%20MIB%20Considerations"></a><a class="selflink" href="#section-9" name="section-9">9</a>.  MIB Considerations</span>

   SCTP-PF introduces new SCTP algorithms for failover and switchback
   with associated new state parameters.  It is recommended that the
   SCTP-MIB defined in [<a href="rfc3873.html" title='"Stream Control Transmission Protocol (SCTP) Management Information Base (MIB)"'>RFC3873</a>] is updated to support the management of
   the SCTP-PF implementation.  This can be done by extending the
   sctpAssocRemAddrActive field of the SCTPAssocRemAddrTable to include
   information of the PF state of the destination address and by adding
   new fields to the SCTPAssocRemAddrTable supporting
   PotentiallyFailed.Max.Retrans (PFMR) and
   Primary.Switchover.Max.Retrans (PSMR) parameters.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/10.%20%20References"></a><a class="selflink" href="#section-10" name="section-10">10</a>.  References</span>

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/10.1.%20%20Normative%20References"></a><a class="selflink" href="#section-10.1" name="section-10.1">10.1</a>.  Normative References</span>

   [<a id="ref-RFC2119" name="ref-RFC2119">RFC2119</a>]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", <a href="https://tools.ietf.org/html/bcp14">BCP 14</a>, <a href="rfc2119.html">RFC 2119</a>,
              DOI 10.17487/RFC2119, March 1997,
              &lt;<a href="http://www.rfc-editor.org/info/rfc2119">http://www.rfc-editor.org/info/rfc2119</a>&gt;.

   [<a id="ref-RFC4960" name="ref-RFC4960">RFC4960</a>]  Stewart, R., Ed., "Stream Control Transmission Protocol",
              <a href="rfc4960.html">RFC 4960</a>, DOI 10.17487/RFC4960, September 2007,
              &lt;<a href="http://www.rfc-editor.org/info/rfc4960">http://www.rfc-editor.org/info/rfc4960</a>&gt;.







<span class="grey">Nishida, et al.              Standards Track                   [Page 17]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-18" id="page-18" name="page-18"> </a>
<span class="grey"><a href="rfc7829.html">RFC 7829</a>                         SCTP-PF                      April 2016</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/10.2.%20%20Informative%20References"></a><a class="selflink" href="#section-10.2" name="section-10.2">10.2</a>.  Informative References</span>

   [<a id="ref-CARO02" name="ref-CARO02">CARO02</a>]   Caro, A., Iyengar, J., Amer, P., Heinz, G., and R.
              Stewart, "A Two-level Threshold Recovery Mechanism for
              SCTP", Tech report, CIS Dept., University of Delaware,
              July 2002.

   [<a id="ref-CARO04" name="ref-CARO04">CARO04</a>]   Caro, A., Amer, P., and R. Stewart, "End-to-End Failover
              Thresholds for Transport Layer Multihoming", MILCOM 2004,
              DOI 10.1109/MILCOM.2004.1493253, November 2004.

   [<a id="ref-CARO05" name="ref-CARO05">CARO05</a>]   Caro, A., "End-to-End Fault Tolerance using Transport
              Layer Multihoming", Ph.D. Thesis, University of Delaware,
              DOI 10.1007/BF03219970, January 2005.

   [<a id="ref-FALLON08" name="ref-FALLON08">FALLON08</a>]
              Fallon, S., Jacob, P., Qiao, Y., Murphy, L., Fallon, E.,
              and A. Hanley, "SCTP Switchover Performance Issues in WLAN
              Environments", IEEE CCNC, DOI 10.1109/ccnc08.2007.131,
              January 2008.

   [<a id="ref-GRINNEMO04" name="ref-GRINNEMO04">GRINNEMO04</a>]
              Grinnemo, K-J. and A. Brunstrom, "Performance of SCTP-
              controlled failovers in M3UA-based SIGTRAN networks",
              Advanced Simulation Technologies Conference, April 2004.

   [<a id="ref-IYENGAR06" name="ref-IYENGAR06">IYENGAR06</a>]
              Iyengar, J., Amer, P., and R. Stewart, "Concurrent
              Multipath Transfer using SCTP Multihoming over Independent
              End-to-end Paths", IEEE/ACM Transactions on Networking,
              DOI 10.1109/TNET.2006.882843, October 2006.

   [<a id="ref-JUNGMAIER02" name="ref-JUNGMAIER02">JUNGMAIER02</a>]
              Jungmaier, A., Rathgeb, E., and M. Tuexen, "On the use of
              SCTP in failover scenarios", World Multiconference on
              Systemics, Cybernetics and Informatics, July 2002.

   [<a id="ref-NATARAJAN09" name="ref-NATARAJAN09">NATARAJAN09</a>]
              Natarajan, P., Ekiz, N., Amer, P., and R. Stewart,
              "Concurrent Multipath Transfer during Path Failure",
              Computer Communications, DOI 10.1016/j.comcom.2009.05.001,
              May 2009.

   [<a id="ref-RFC3873" name="ref-RFC3873">RFC3873</a>]  Pastor, J. and M. Belinchon, "Stream Control Transmission
              Protocol (SCTP) Management Information Base (MIB)",
              <a href="rfc3873.html">RFC 3873</a>, DOI 10.17487/RFC3873, September 2004,
              &lt;<a href="http://www.rfc-editor.org/info/rfc3873">http://www.rfc-editor.org/info/rfc3873</a>&gt;.




<span class="grey">Nishida, et al.              Standards Track                   [Page 18]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-19" id="page-19" name="page-19"> </a>
<span class="grey"><a href="rfc7829.html">RFC 7829</a>                         SCTP-PF                      April 2016</span>


   [<a id="ref-RFC6458" name="ref-RFC6458">RFC6458</a>]  Stewart, R., Tuexen, M., Poon, K., Lei, P., and V.
              Yasevich, "Sockets API Extensions for the Stream Control
              Transmission Protocol (SCTP)", <a href="rfc6458.html">RFC 6458</a>,
              DOI 10.17487/RFC6458, December 2011,
              &lt;<a href="http://www.rfc-editor.org/info/rfc6458">http://www.rfc-editor.org/info/rfc6458</a>&gt;.














































<span class="grey">Nishida, et al.              Standards Track                   [Page 19]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-20" id="page-20" name="page-20"> </a>
<span class="grey"><a href="rfc7829.html">RFC 7829</a>                         SCTP-PF                      April 2016</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/Appendix%20A.%20%20Discussion%20of%20Alternative%20Approaches"></a><a class="selflink" href="#appendix-A" name="appendix-A">Appendix A</a>.  Discussion of Alternative Approaches</span>

   This section lists alternative approaches for the issues described in
   this document.  Although these approaches do not require updating <a href="rfc4960.html">RFC</a>
   <a href="rfc4960.html">4960</a>, we do not recommend them for the reasons described below.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/A.1.%20%20Reduce%20PMR"></a><a class="selflink" href="#appendix-A.1" name="appendix-A.1">A.1</a>.  Reduce PMR</span>

   Smaller values for Path.Max.Retrans shorten the failover duration and
   in fact, this is recommended in some research results [<a href="#ref-JUNGMAIER02">JUNGMAIER02</a>],
   [<a href="#ref-GRINNEMO04">GRINNEMO04</a>], and [<a href="#ref-FALLON08">FALLON08</a>].  However, to significantly reduce the
   failover time, it is required to go down (as with PFMR) to
   Path.Max.Retrans=0 and, with this setting, SCTP switches to another
   destination address already on a single timeout that may result in
   spurious failover.  Spurious failover is a problem in standard SCTP
   as the transmission of HEARTBEATs on the left primary path, unlike in
   SCTP-PF, is governed by HB.Interval also during the failover process.
   HB.Interval is usually set in the order of seconds (recommended value
   is 30 seconds) and when the primary path becomes inactive, the next
   HEARTBEAT may be transmitted only many seconds later: as recommended,
   only 30 seconds later.  Meanwhile, the primary path may have long
   since recovered, if it needed recovery at all (indeed the failover
   could be truly spurious).  In such situations, post failover, an
   endpoint is forced to wait in the order of many seconds before the
   endpoint can resume transmission on the primary path and furthermore,
   once it returns on the primary path, the CWND needs to be rebuilt
   anew -- a process that the throughput already had to suffer from on
   the alternate path.  Using a smaller value for HB.Interval might help
   this situation, but it would result in a general waste of bandwidth
   as such more frequent HEARTBEATING would take place also when there
   are no observed troubles.  The bandwidth overhead may be diminished
   by having the ULP use a smaller HB.Interval only on the path that, at
   any given time, is set to be the primary path; however, this adds
   complication in the ULP.

   In addition, smaller Path.Max.Retrans values also affect the
   Association.Max.Retrans value.  When the SCTP association's error
   count exceeds Association.Max.Retrans threshold, the SCTP sender
   considers the peer endpoint unreachable and terminates the
   association.  <a href="rfc4960.html#section-8.2">Section 8.2 in [RFC4960]</a> recommends that the
   Association.Max.Retrans value should not be larger than the summation
   of the Path.Max.Retrans of each of the destination addresses.









<span class="grey">Nishida, et al.              Standards Track                   [Page 20]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-21" id="page-21" name="page-21"> </a>
<span class="grey"><a href="rfc7829.html">RFC 7829</a>                         SCTP-PF                      April 2016</span>


   Otherwise, the SCTP sender considers its peer reachable even when all
   destinations are INACTIVE.  To avoid this dormant state operation,
   standard SCTP implementation SHOULD reduce Association.Max.Retrans
   accordingly whenever it reduces Path.Max.Retrans.  However, smaller
   Association.Max.Retrans value decreases the fault tolerance of SCTP
   as it increases the chances of association termination during minor
   congestion events.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/A.2.%20%20Adjust%20RTO-Related%20Parameters"></a><a class="selflink" href="#appendix-A.2" name="appendix-A.2">A.2</a>.  Adjust RTO-Related Parameters</span>

   As several research results indicate, we can also shorten the
   duration of the failover process by adjusting the RTO-related
   parameters [<a href="#ref-JUNGMAIER02">JUNGMAIER02</a>] and [<a href="#ref-FALLON08">FALLON08</a>].  During the failover
   process, RTO keeps being doubled.  However, if we can choose a
   smaller value for RTO.max, we can stop the exponential growth of RTO
   at some point.  Also, choosing smaller values for RTO.initial or
   RTO.min can contribute to keeping the RTO value small.

   Similar to reducing Path.Max.Retrans, the advantage of this approach
   is that it requires no modification to the current specification,
   although it needs to ignore several recommendations described in
   <a href="rfc4960.html#section-15">Section 15 of [RFC4960]</a>.  However, this approach requires having
   enough knowledge about the network characteristics between endpoints.
   Otherwise, it can introduce adverse side effects such as spurious
   timeouts.

   The significant issue with this approach, however, is that even if
   the RTO.max is lowered to an optimal low value, as long as the
   Path.Max.Retrans is kept at the recommended value from [<a href="rfc4960.html" title='"Stream Control Transmission Protocol"'>RFC4960</a>], the
   reduction of the RTO.max doesn't reduce the failover time
   sufficiently enough to prevent severe performance degradation during
   failover.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/Appendix%20B.%20%20Discussion%20of%20the%20Path-Bouncing%20Effect"></a><a class="selflink" href="#appendix-B" name="appendix-B">Appendix B</a>.  Discussion of the Path-Bouncing Effect</span>

   The methods described in the document can accelerate the failover
   process.  Hence, they might introduce a path-bouncing effect in which
   the sender keeps changing the data transmission path frequently.
   This sounds harmful to the data transfer; however, several research
   results indicate that there is no serious problem with SCTP in terms
   of the path-bouncing effect (see [<a href="#ref-CARO04" title='"End-to-End Failover Thresholds for Transport Layer Multihoming"'>CARO04</a>] and [<a href="#ref-CARO05" title='"End-to-End Fault Tolerance using Transport Layer Multihoming"'>CARO05</a>]).

   There are two main reasons for this.  First, SCTP is basically
   designed for multipath communication, which means SCTP maintains all
   path-related parameters (CWND, ssthresh, RTT, error count, etc.) per
   each destination address.  These parameters cannot be affected by





<span class="grey">Nishida, et al.              Standards Track                   [Page 21]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-22" id="page-22" name="page-22"> </a>
<span class="grey"><a href="rfc7829.html">RFC 7829</a>                         SCTP-PF                      April 2016</span>


   path bouncing.  In addition, when SCTP migrates the data transfer to
   another path, it starts with the minimal or the initial CWND.  Hence,
   there is little chance for packet reordering or duplicating.

   Second, even if all communication paths between the end nodes share
   the same bottleneck, the SCTP-PF results in a behavior already
   allowed by [<a href="rfc4960.html" title='"Stream Control Transmission Protocol"'>RFC4960</a>].

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/Appendix%20C.%20%20SCTP-PF%20for%20SCTP%20Single-Homed%20Operation"></a><a class="selflink" href="#appendix-C" name="appendix-C">Appendix C</a>.  SCTP-PF for SCTP Single-Homed Operation</span>

   For a single-homed SCTP association, the only tangible effect of the
   activation of SCTP-PF operation is enhanced failure detection in
   terms of potential notification of the PF state of the sole
   destination address as well as, for idle associations, more rapid
   entering, and notification, of inactive state of the destination
   address and more rapid endpoint failure detection.  It is believed
   that neither of these effects are harmful, provided adequate dormant
   state operation is implemented.  Furthermore, it is believed that
   they may be particularly useful for applications that deploy multiple
   SCTP associations for load-balancing purposes.  The early
   notification of the PF state may be used for preventive measures as
   the entering of the PF state can be used as a warning of potential
   congestion.  Depending on the PMR value, the aggressive HEARTBEAT
   transmission in PF state may speed up the endpoint failure detection
   (exceed of AMR threshold on the sole path error counter) on idle
   associations in the case with a relatively large HB.Interval value
   compared to RTO (e.g., 30 seconds) is used.

Acknowledgments

   The authors would like to acknowledge members of the IETF Transport
   Area Working Group (tsvwg) for continuing discussions on this
   document and insightful feedback, and we appreciate continuous
   encouragement and suggestions from the Chairs of the tsvwg.  We
   especially wish to thank Michael Tuexen for his many invaluable
   comments and for his substantial supports with the making of the
   document.














<span class="grey">Nishida, et al.              Standards Track                   [Page 22]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-23" id="page-23" name="page-23"> </a>
<span class="grey"><a href="rfc7829.html">RFC 7829</a>                         SCTP-PF                      April 2016</span>


Authors' Addresses

   Yoshifumi Nishida
   GE Global Research
   2623 Camino Ramon
   San Ramon, CA  94583
   United States

   Email: nishida@wide.ad.jp


   Preethi Natarajan
   Cisco Systems
   510 McCarthy Blvd.
   Milpitas, CA  95035
   United States

   Email: prenatar@cisco.com


   Armando Caro
   BBN Technologies
   10 Moulton St.
   Cambridge, MA  02138
   United States

   Email: acaro@bbn.com


   Paul D. Amer
   University of Delaware
   Computer Science Department - 434 Smith Hall
   Newark, DE  19716-2586
   United States

   Email: amer@udel.edu


   Karen E. E. Nielsen
   Ericsson
   Kistavaegen 25
   Stockholm  164 80
   Sweden

   Email: karen.nielsen@tieto.com






Nishida, et al.              Standards Track                   [Page 23]

</pre><br/>
    <span class="noprint"><small><small>Html markup produced by rfcmarkup 1.126, available from
      <a href="https://tools.ietf.org/tools/rfcmarkup/">https://tools.ietf.org/tools/rfcmarkup/</a>
    </small></small></span>
  </div>




</body><!-- Mirrored from tools.ietf.org/html/rfc7829 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 06 Mar 2018 23:18:19 GMT --></html>