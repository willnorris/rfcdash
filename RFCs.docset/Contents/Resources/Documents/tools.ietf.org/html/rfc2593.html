<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml"><!-- Mirrored from tools.ietf.org/html/rfc2593 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 06 Mar 2018 23:18:53 GMT --><!-- Added by HTTrack --><head><meta content="text/html;charset=utf-8" http-equiv="content-type"/><!-- /Added by HTTrack -->

    <meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
    <meta content="index,follow" name="robots"/>
    <meta content="rfcmarkup version 1.126" name="creator"/>
    <link href="http://purl.org/dc/elements/1.1/" rel="schema.DC"/>
<meta content="urn:ietf:rfc:2593" name="DC.Identifier"/>
<meta content="The Script MIB extensibility protocol (SMX) defined in this memo
separates language specific runtime systems from language independent
Script MIB implementations. This memo defines an Experimental Protocol
for the Internet community." name="DC.Description.Abstract"/>
<meta content="Quittek, Juergen" name="DC.Creator"/>
<meta content="Schoenwaelder, Juergen" name="DC.Creator"/>
<meta content="May, 1999" name="DC.Date.Issued"/>
<meta content="Script MIB Extensibility Protocol Version 1.0" name="DC.Title"/>

    <link href="https://tools.ietf.org/images/rfc.png" rel="icon" type="image/png"/>
    <link href="https://tools.ietf.org/images/rfc.png" rel="shortcut icon" type="image/png"/>
    <title>RFC 2593 - Script MIB Extensibility Protocol Version 1.0</title>
    
    
    <style type="text/css">
	@media only screen 
	  and (min-width: 992px)
	  and (max-width: 1199px) {
	    body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 768px)
	  and (max-width: 991px) {
            body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 480px)
	  and (max-width: 767px) {
            body { font-size: 11pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (max-width: 479px) {
            body { font-size: 8pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-device-width : 375px) 
	  and (max-device-width : 667px) {
            body { font-size: 9.5pt; }
            div.content { width: 96ex; margin: 0 1px; }
        }
	@media only screen 
	  and (min-device-width: 1200px) {
            body { font-size: 10pt; margin: 0 4em; }
            div.content { width: 96ex; margin: 0; }
        }
        h1, h2, h3, h4, h5, h6, .h1, .h2, .h3, .h4, .h5, .h6 {
	    font-weight: bold;
            line-height: 0pt;
            display: inline;
            white-space: pre;
            font-family: monospace;
            font-size: 1em;
	    font-weight: bold;
        }
        pre {
            font-size: 1em;
            margin-top: 0px;
            margin-bottom: 0px;
        }
	.pre {
	    white-space: pre;
	    font-family: monospace;
	}
	.header{
	    font-weight: bold;
	}
        .newpage {
            page-break-before: always;
        }
        .invisible {
            text-decoration: none;
            color: white;
        }
        a.selflink {
          color: black;
          text-decoration: none;
        }
        @media print {
            body {
                font-family: monospace;
                font-size: 10.5pt;
            }
            h1, h2, h3, h4, h5, h6 {
                font-size: 1em;
            }
        
            a:link, a:visited {
                color: inherit;
                text-decoration: none;
            }
            .noprint {
                display: none;
            }
        }
	@media screen {
	    .grey, .grey a:link, .grey a:visited {
		color: #777;
	    }
            .docinfo {
                background-color: #EEE;
            }
            .top {
                border-top: 7px solid #EEE;
            }
            .bgwhite  { background-color: white; }
            .bgred    { background-color: #F44; }
            .bggrey   { background-color: #666; }
            .bgbrown  { background-color: #840; }            
            .bgorange { background-color: #FA0; }
            .bgyellow { background-color: #EE0; }
            .bgmagenta{ background-color: #F4F; }
            .bgblue   { background-color: #66F; }
            .bgcyan   { background-color: #4DD; }
            .bggreen  { background-color: #4F4; }

            .legend   { font-size: 90%; }
            .cplate   { font-size: 70%; border: solid grey 1px; }
	}
    </style>
    <!--[if IE]>
    <style>
    body {
       font-size: 13px;
       margin: 10px 10px;
    }
    </style>
    <![endif]-->

    <script type="text/javascript"><!--
    function addHeaderTags() {
	var spans = document.getElementsByTagName("span");
	for (var i=0; i < spans.length; i++) {
	    var elem = spans[i];
	    if (elem) {
		var level = elem.getAttribute("class");
                if (level == "h1" || level == "h2" || level == "h3" || level == "h4" || level == "h5" || level == "h6") {
                    elem.innerHTML = "<"+level+">"+elem.innerHTML+"</"+level+">";		
                }
	    }
	}
    }
    var legend_html = "Colour legend:<br />      <table>         <tr><td>Unknown:</td>                   <td><span class='cplate bgwhite'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft:</td>                     <td><span class='cplate bgred'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Informational:</td>             <td><span class='cplate bgorange'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Experimental:</td>              <td><span class='cplate bgyellow'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Best Common Practice:</td>      <td><span class='cplate bgmagenta'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Proposed Standard:</td>         <td><span class='cplate bgblue'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft Standard (old designation):</td> <td><span class='cplate bgcyan'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Internet Standard:</td>         <td><span class='cplate bggreen'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Historic:</td>                  <td><span class='cplate bggrey'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Obsolete:</td>                  <td><span class='cplate bgbrown'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>     </table>";
    function showElem(id) {
        var elem = document.getElementById(id);
        elem.innerHTML = eval(id+"_html");
        elem.style.visibility='visible';
    }
    function hideElem(id) {
        var elem = document.getElementById(id);
        elem.style.visibility='hidden';        
        elem.innerHTML = "";
    }
    // -->
    </script>
</head>
<body onload="addHeaderTags()">
  <div class="content">
   <div style="height: 13px;">
      <div class="pre noprint docinfo bgbrown" onclick="showElem('legend');" onmouseout="hideElem('legend')" onmouseover="this.style.cursor='pointer';" style="height: 6px; position: absolute;" title="Click for colour legend.">                                                                        </div>
      <div class="docinfo noprint pre legend" id="legend" onmouseout="hideElem('legend');" onmouseover="showElem('legend');" style="position:absolute; top: 4px; left: 4ex; visibility:hidden; background-color: white; padding: 4px 9px 5px 7px; border: solid #345 1px; ">
      </div>
   </div>
<span class="pre noprint docinfo top">[<a href="index.html" title="Document search and retrieval page">Docs</a>] [<a href="https://tools.ietf.org/rfc/rfc2593.txt" title="Plaintext version of this document">txt</a>|<a href="https://tools.ietf.org/pdf/rfc2593" title="PDF version of this document">pdf</a>] [<a href="https://tools.ietf.org/html/draft-schoenw-smx" title="draft-schoenw-smx">draft-schoenw-smx</a>] [<a href="https://datatracker.ietf.org/doc/rfc2593" title="IESG Datatracker information for this document">Tracker</a>] [<a href="https://tools.ietf.org/rfcdiff?difftype=--hwdiff&amp;url2=rfc2593" title="Inline diff (wdiff)">Diff1</a>] [<a href="https://tools.ietf.org/rfcdiff?url2=rfc2593" title="Side-by-side diff">Diff2</a>]          </span><br/>
<span class="pre noprint docinfo">                                                                        </span><br/>
<span class="pre noprint docinfo">Obsoleted by: <a href="rfc3179.html">3179</a>                                          EXPERIMENTAL</span><br/>
<span class="pre noprint docinfo">                                                                        </span><br/>
<pre>Network Working Group                                   J. Schoenwaelder
Request for Comments: 2593                               TU Braunschweig
Category: Experimental                                        J. Quittek
                                                         NEC Europe Ltd.
                                                                May 1999


             <span class="h1">Script MIB Extensibility Protocol Version 1.0</span>

Status of this Memo

   This memo defines an Experimental Protocol for the Internet
   community.  It does not specify an Internet standard of any kind.
   Discussion and suggestions for improvement are requested.
   Distribution of this memo is unlimited.

Copyright Notice

   Copyright (C) The Internet Society (1999).  All Rights Reserved.

Abstract

   The IETF Script MIB defines an interface for the delegation of
   management functions based on the Internet management framework. A
   management script is a set of instructions that are executed by a
   language specific runtime system. The Script MIB extensibility
   protocol (SMX) defined in this memo separates language specific
   runtime systems from language independent Script MIB implementations.

Table of Contents

   <a href="#section-1">1</a>. Introduction ................................................    <a href="#page-2">2</a>
   <a href="#section-2">2</a>. Process Model and Communication Model .......................    <a href="#page-3">3</a>
   <a href="#section-3">3</a>. Security Profiles ...........................................    <a href="#page-3">3</a>
   <a href="#section-4">4</a>. Start of Runtime Systems and Connection Establishment .......    <a href="#page-4">4</a>
   <a href="#section-5">5</a>. SMX Messages ................................................    <a href="#page-5">5</a>
   <a href="#section-5.1">5.1</a> Common Definitions .........................................    <a href="#page-5">5</a>
   <a href="#section-5.2">5.2</a> Commands ...................................................    <a href="#page-7">7</a>
   <a href="#section-5.3">5.3</a> Replies ....................................................    <a href="#page-8">8</a>
   <a href="#section-6">6</a>. Elements of Procedure .......................................    <a href="#page-9">9</a>
   <a href="#section-6.1">6.1</a> SMX Message Processing on the Runtime Systems ..............    <a href="#page-9">9</a>
   <a href="#section-6.1.1">6.1.1</a> Processing the `hello' Command ...........................   <a href="#page-10">10</a>
   <a href="#section-6.1.2">6.1.2</a> Processing the `start' Command ...........................   <a href="#page-10">10</a>
   <a href="#section-6.1.3">6.1.3</a> Processing the `suspend' Command .........................   <a href="#page-11">11</a>
   <a href="#section-6.1.4">6.1.4</a> Processing the `resume' Command ..........................   <a href="#page-12">12</a>
   <a href="#section-6.1.5">6.1.5</a> Processing the `abort' Command ...........................   <a href="#page-12">12</a>
   <a href="#section-6.1.6">6.1.6</a> Processing the `status' Command ..........................   <a href="#page-12">12</a>
   <a href="#section-6.1.7">6.1.7</a> Generation of Asynchronous Notifications .................   <a href="#page-13">13</a>



<span class="grey">Schoenwaelder &amp; Quittek       Experimental                      [Page 1]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-2" id="page-2" name="page-2"> </a>
<span class="grey"><a href="rfc2593.html">RFC 2593</a>                    SMX Protocol 1.0                    May 1999</span>


   <a href="#section-6.2">6.2</a> SMX Message Processing on the SNMP Agent ...................   <a href="#page-13">13</a>
   <a href="#section-6.2.1">6.2.1</a> Creating a Runtime System ................................   <a href="#page-13">13</a>
   <a href="#section-6.2.2">6.2.2</a> Generating the `hello' Command ...........................   <a href="#page-13">13</a>
   <a href="#section-6.2.3">6.2.3</a> Generating the `start' Command ...........................   <a href="#page-14">14</a>
   <a href="#section-6.2.4">6.2.4</a> Generating the `suspend' Command .........................   <a href="#page-15">15</a>
   <a href="#section-6.2.5">6.2.5</a> Generating the `resume' Command ..........................   <a href="#page-16">16</a>
   <a href="#section-6.2.6">6.2.6</a> Generating the `abort' Command ...........................   <a href="#page-16">16</a>
   <a href="#section-6.2.7">6.2.7</a> Generating the `status' Command ..........................   <a href="#page-17">17</a>
   <a href="#section-6.2.8">6.2.8</a> Processing Asynchronous Notifications ....................   <a href="#page-18">18</a>
   <a href="#section-7">7</a>. An Example SMX Message Flow .................................   <a href="#page-19">19</a>
   <a href="#section-8">8</a>. Security Considerations .....................................   <a href="#page-19">19</a>
   <a href="#section-9">9</a>. Acknowledgments .............................................   <a href="#page-20">20</a>
   <a href="#section-10">10</a>. References .................................................   <a href="#page-20">20</a>
   <a href="#section-11">11</a>. Authors' Addresses .........................................   <a href="#page-21">21</a>
   <a href="#section-12">12</a>. Full Copyright Statement ...................................   <a href="#page-22">22</a>

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/1.%20%20Introduction"></a><a class="selflink" href="#section-1" name="section-1">1</a>.  Introduction</span>

   The Script MIB [<a href="#ref-1" title='"Definitions of Managed Objects for the Delegation of Management Scripts"'>1</a>] defines a standard interface for the delegation of
   management functions based on the Internet management framework. In
   particular, it provides the following capabilities:

   1.   Transfer of management scripts to a distributed manager.

   2.   Initiating, suspending, resuming and terminating management
        scripts.

   3.   Transfer of arguments for management scripts.

   4.   Monitoring and control of running management scripts.

   5.   Transfer of results produced by management scripts.

   A management script is a set of instructions executed by a language
   specific runtime system. The Script MIB does not prescribe a specific
   language. Instead, it allows to control scripts written in different
   languages that are executing concurrently.

   The Script MIB Extensibility protocol (SMX) defined in this memo can
   be used to separate language specific runtime systems from the
   runtime system independent Script MIB implementations. The
   lightweight SMX protocol can be used to support different runtime
   systems without any changes to the language neutral part of a Script
   MIB implementation.

   Examples of languages and runtime systems considered during the
   design of the SMX protocol are the Java virtual machine [<a href="#ref-2" title='"The Java Virtual Machine Specification"'>2</a>] and the
   Tool Command Language (Tcl) [<a href="#ref-3" title='"Tcl and the Tk Toolkit"'>3</a>]. Other languages with comparable



<span class="grey">Schoenwaelder &amp; Quittek       Experimental                      [Page 2]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-3" id="page-3" name="page-3"> </a>
<span class="grey"><a href="rfc2593.html">RFC 2593</a>                    SMX Protocol 1.0                    May 1999</span>


   features should be easy to integrate as well.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/2.%20%20Process%20Model%20and%20Communication%20Model"></a><a class="selflink" href="#section-2" name="section-2">2</a>.  Process Model and Communication Model</span>

   Figure 1 shows the process and communication model underlying the SMX
   protocol. The language and runtime system independent SNMP agent
   implementing the Script MIB communicates with one ore more runtime
   systems via the SMX protocol. A runtime system may be able to execute
   one or multiple scripts simultaneously (multi-threading). The SMX
   protocol supports multi-threading, but it does not require multi-
   threaded runtime systems.

   The SMX protocol uses a local storage device (usually implemented on
   top of the local file system) to transfer scripts from the SNMP agent
   to the runtime systems. The SNMP agent has read and write access to
   the script storage device while the runtime systems only need read
   access. The SMX protocol passes the location of a script in the local
   storage device to the runtime engines. It is then the responsibility
   of the runtime engines to load the script from the specified
   location.

                                                    runtime 1
                   +--------------+       SMX      +---------+
                   |              |&lt;--------------&gt;| O  O  O |&lt;-+
           SNMP    |  Script MIB  |                +---------+  |
       &lt;----------&gt;|              |                             |
                   |  SNMP Agent  |                 runtime 2   |
                   |              |       SMX      +---------+  |
                   |              |&lt;--------------&gt;| O       |  |
                   +--------------+                +---------+  |
                           ^                            ^       |
                           |       +---------+          |       |
                           |       | script  |----------+       |
                           +------&gt;| storage |------------------+
                                   +---------+

           Figure 1: SMX process and communication model


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/3.%20%20Security%20Profiles"></a><a class="selflink" href="#section-3" name="section-3">3</a>.  Security Profiles</span>

   Security profiles control what a running script is allowed to do. It
   is useful to distinguish two different classes of security profiles:

   -    The operating system security profile specifies the set of
        operating system services that can be used by the operating
        system level process which executes a script. Under UNIX, this
        maps to the effective user and group identity for the running



<span class="grey">Schoenwaelder &amp; Quittek       Experimental                      [Page 3]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-4" id="page-4" name="page-4"> </a>
<span class="grey"><a href="rfc2593.html">RFC 2593</a>                    SMX Protocol 1.0                    May 1999</span>


        process. In addition, many UNIX versions allow to set other
        resource limits, such as the number of open files or the maximum
        stack sizes. Another mechanism in UNIX is the chroot() system
        call which changes the file system root for a process. The
        chroot() mechanism can be used to prevent runtime systems from
        accessing any system files. It is suggested to make use of all
        applicable operating system security mechanism in order to
        protect the operating system from malicious scripts or runtime
        systems.

   -    Secure runtime systems provide fine grained control over the set
        of services that can be used by a running script at a particular
        point during script execution. A runtime security profile
        specifying fine grained access control is runtime system
        dependent. For a Java virtual machine, the runtime security
        profile is interpreted by the SecurityManager and ClassLoader
        classes[4]. For Tcl, the runtime security profile maps to the
        interpreter's security profile [<a href="#ref-5" title='"The Safe-Tcl Security Model"'>5</a>].

   The SMX protocol allows to execute scripts under different operating
   system profiles and runtime system profiles. Multiple operating
   system security profiles are realized by using multiple runtime
   systems which execute in operating system processes with different
   security profiles.  Multiple runtime security profiles are supported
   by passing a security profile name to a runtime system during script
   invocation.

   The Script MIB does not define how operating system or runtime system
   security profiles are identified. This memo suggests that the
   smLaunchOwner is mapped to an operating system security profile and a
   runtime system security profile when a script is started.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/4.%20%20Start%20of%20Runtime%20Systems%20and%20Connection%20Establishment"></a><a class="selflink" href="#section-4" name="section-4">4</a>.  Start of Runtime Systems and Connection Establishment</span>

   The SNMP agent starts runtime systems based on the static properties
   of the runtime system (multi-threaded or single-threaded) and the
   operating system security profiles. Starting a new runtime system
   requires to create a process environment which matches the operating
   system security profile.

   The SNMP agent initially passes information to the runtime system by
   means of environment variables. The information is needed to
   establish a trusted communication channel between the SNMP agent and
   a runtime system.

   The SNMP agent first creates a listening TCP socket which accepts
   connections from runtime systems. It is the responsibility of the
   runtime system to establish a connection to this TCP socket once it



<span class="grey">Schoenwaelder &amp; Quittek       Experimental                      [Page 4]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-5" id="page-5" name="page-5"> </a>
<span class="grey"><a href="rfc2593.html">RFC 2593</a>                    SMX Protocol 1.0                    May 1999</span>


   has been started. The port number of the listening TCP socket is
   passed from the SNMP agent to the runtime system in the environment
   variable SMX_PORT.

   The SNMP agent must ensure that only authorized runtime systems
   establish a connection to the listening TCP socket. The following
   rules are used for this purpose:

   -    The TCP connection must originate from the local host.

   -    The SNMP agent queries the runtime system for a security cookie
        and closes the TCP connection if no valid response is received
        within a given time interval. The security cookie is a random
        number generated by the SNMP agent and passed to the runtime
        system as part of its environment. The cookie is found in the
        environment variable SMX_COOKIE.

   The security assumption here is that access to the process
   environment is protected by the operating system.

   Alternate transports (e.g. UNIX domain sockets) are possible but not
   defined at this point in time. The reason to choose TCP as the
   transport protocol for SMX was that TCP is supported by all potential
   runtime systems, while other transports are not universally
   available.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/5.%20%20SMX%20Messages"></a><a class="selflink" href="#section-5" name="section-5">5</a>.  SMX Messages</span>

   The message formats described below are defined using the Augmented
   BNF (ABNF) defined in <a href="rfc2234.html">RFC 2234</a> [<a href="#ref-6" title='"Augmented BNF for Syntax Specifications: ABNF"'>6</a>]. The definitions for `ALPHA',
   `DIGIT', `HEXDIG', `WSP', `CRLF', `CR', `LF', `HTAB', `VCHAR' and
   `DQUOTE' are imported from <a href="rfc2234.html#appendix-A">appendix A of RFC 2234</a> and not repeated
   here.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.1.%20%20Common%20Definitions"></a><a class="selflink" href="#section-5.1" name="section-5.1">5.1</a>.  Common Definitions</span>

   The following ABNF definitions are used in subsequent sections to
   define the SMX protocol messages.

     Zero          = %x30          ; the ASCII character '0'

     AlNum         = DIGIT / ALPHA / %x2D-2F
                                   ; digits, alphas plus '-', '.', '/'

     QuotedString  = DQUOTE *(VCHAR / WSP) DQUOTE

     HexString     = 1*(HEXDIG HEXDIG)




<span class="grey">Schoenwaelder &amp; Quittek       Experimental                      [Page 5]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-6" id="page-6" name="page-6"> </a>
<span class="grey"><a href="rfc2593.html">RFC 2593</a>                    SMX Protocol 1.0                    May 1999</span>


     Id            = 1*DIGIT       ; identifier for an SMX transaction

     Script        = QuotedString  ; script file name

     RunId         = 1*DIGIT       ; globally unique identifier for a
                                   ; running script (note, smRunIndex
                                   ; is only unique for a smLaunchOwner,
                                   ; smLaunchName pair)

     Profile       = 1*AlNum       ; security profile name

     RunState      =  "1"          ; smRunState `initializing'
     RunState      =/ "2"          ; smRunState `executing'
     RunState      =/ "3"          ; smRunState `suspending'
     RunState      =/ "4"          ; smRunState `suspended'
     RunState      =/ "5"          ; smRunState `resuming'
     RunState      =/ "6"          ; smRunState `aborting'
     RunState      =/ "7"          ; smRunState `terminated'

     ExitCode      =  "1"          ; smRunExitCode `noError'
     ExitCode      =/ "2"          ; smRunExitCode `halted'
     ExitCode      =/ "3"          ; smRunExitCode `lifeTimeExceeded'
     ExitCode      =/ "4"          ; smRunExitCode `noResourcesLeft'
     ExitCode      =/ "5"          ; smRunExitCode `languageError'
     ExitCode      =/ "6"          ; smRunExitCode `runtimeError'
     ExitCode      =/ "7"          ; smRunExitCode `invalidArgument'
     ExitCode      =/ "8"          ; smRunExitCode `securityViolation'
     ExitCode      =/ "9"          ; smRunExitCode `genericError'

     Cookie        = HexString     ; authentication cookie

     Version       = "SMX/1.0"     ; current version of the SMX protocol

     Argument      = HexString / QuotedString      ; see smRunArgument

     Result        = HexString / QuotedString      ; see smRunResult

     ErrorMsg      = HexString / QuotedString      ; see smRunError


   The definition of QuotedString requires further explanation. A quoted
   string may contain special character sequences, all starting with the
   backslash character (%x5C). The interpretation of these sequences is
   as follows:







<span class="grey">Schoenwaelder &amp; Quittek       Experimental                      [Page 6]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-7" id="page-7" name="page-7"> </a>
<span class="grey"><a href="rfc2593.html">RFC 2593</a>                    SMX Protocol 1.0                    May 1999</span>


           `\\'   backslash character       (`%x5C')
           `\t'   tab character             (`HTAB')
           `\n'   newline character         (`LF')
           `\r'   carriage-return character (`CR')
           `\"'   quote character           (`DQUOTE')

   In all other cases not listed above, the backslash is dropped and the
   following character is treated as an ordinary character.  `Argument'
   and `Result' is either a QuotedString or a HexString.  The Script MIB
   defines script arguments and results as arbitrary octet strings. The
   SMX protocol supports a binary and a human readable representation
   since it is likely that printable argument and result strings will be
   used frequently. However, an implementation must be able to handle
   both formats in order to be compliant with the Script MIB.

   The `Cookie' is a HexString which does not carry any semantics other
   than being a random sequence of bytes. It is therefore not necessary
   to have a human readable representation.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.2.%20%20Commands"></a><a class="selflink" href="#section-5.2" name="section-5.2">5.2</a>.  Commands</span>

   The following ABNF definitions define the set of SMX commands which
   can be sent from the SNMP agent to a runtime system.

     Command =  "hello"   WSP Id CRLF

     Command =/ "start"   WSP Id WSP RunId WSP Script WSP Profile
                          WSP Argument CRLF

     Command =/ "suspend" WSP Id WSP RunId CRLF

     Command =/ "resume"  WSP Id WSP RunId CRLF

     Command =/ "abort"   WSP Id WSP RunId CRLF

     Command =/ "status"  WSP Id WSP RunId CRLF

   The `hello' command is always the first command sent over a SMX
   connection. It is used to identify and authenticate the runtime
   system. The `start' command starts the execution of a script. The
   `suspend', `resume' and `abort' commands can be used to change the
   status of a running script. The `status' command is used to retrieve
   status information for a running script.

   There is no compile command. It is the responsibility of the SNMP
   agent to perform any compilation steps as needed before using the SMX
   `start' command. There is no SMX command to shutdown a runtime
   system. Closing the connection must be interpreted as a request to



<span class="grey">Schoenwaelder &amp; Quittek       Experimental                      [Page 7]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-8" id="page-8" name="page-8"> </a>
<span class="grey"><a href="rfc2593.html">RFC 2593</a>                    SMX Protocol 1.0                    May 1999</span>


   terminate all running scripts in that runtime system and to shutdown
   the runtime system.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.3.%20%20Replies"></a><a class="selflink" href="#section-5.3" name="section-5.3">5.3</a>.  Replies</span>

   Every reply message starts with a three digit reply code and ends
   with `CRLF'. The three digits in a reply code have a special meaning.
   The first digit identifies the class of a reply message. The
   following classes exist:

     1yz   transient positive response
     2yz   permanent positive response
     3yz   transient negative response
     4yz   permanent negative response
     5yz   asynchronous notification

   The classes 1yz and 3yz are currently not used by SMX version 1.0.
   They are defined only for future SMX extensions.

   The second digit encodes the specific category. The following
   categories exist:

     x0z   syntax errors that don't fit any other category
     x1z   replies for commands targeted at the whole runtime system
     x2z   replies for commands targeted at scripts
     x3z   replies for commands targeted at running instances of scripts

   The third digit gives a finer gradation of meaning in each category
   specified by the second digit. Below is the ABNF definition of all
   reply messages and codes:

     Reply =  "211" WSP Id WSP Version WSP Cookie CRLF
                                   ; identification of the
                                   ; runtime system

     Reply =/ "231" WSP Id WSP RunState CRLF
                                   ; status of a running script

     Reply =/ "232" WSP Id CRLF    ; abort of a running script

     Reply =/ "401" WSP Id CRLF    ; syntax error in command

     Reply =/ "402" WSP Id CRLF    ; unknown command

     Reply =/ "421" WSP Id CRLF    ; unknown or illegal Script

     Reply =/ "431" WSP Id CRLF    ; unknown or illegal RunId




<span class="grey">Schoenwaelder &amp; Quittek       Experimental                      [Page 8]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-9" id="page-9" name="page-9"> </a>
<span class="grey"><a href="rfc2593.html">RFC 2593</a>                    SMX Protocol 1.0                    May 1999</span>


     Reply =/ "432" WSP Id CRLF    ; unknown or illegal Profile

     Reply =/ "433" WSP Id CRLF    ; illegal Argument

     Reply =/ "434" WSP Id CRLF    ; unable to change the status of
                                   ; a running script

     Reply =/ "511" WSP Zero WSP QuotedString CRLF
                                   ; an arbitrary message send from
                                   ; the runtime system

     Reply =/ "531" WSP Zero WSP RunId WSP RunState CRLF
                                   ; asynchronous running script
                                   ; status change

     Reply =/ "532" WSP Zero WSP RunId WSP RunState WSP Result CRLF
                                   ; intermediate script result

     Reply =/ "533" WSP Zero WSP RunId WSP RunState WSP Result CRLF
                                   ; intermediate script result that
                                   ; trigger an event report

     Reply =/ "534" WSP Zero WSP RunId WSP Result CRLF
                                   ; normal script termination

     Reply =/ "535" WSP Zero WSP RunId WSP ExitCode WSP ErrorMsg CRLF
                                   ; abnormal script termination.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/6.%20%20Elements%20of%20Procedure"></a><a class="selflink" href="#section-6" name="section-6">6</a>.  Elements of Procedure</span>

   This section describes in detail the processing steps performed by
   the SNMP agent and the runtime system with regard to the SMX
   protocol.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/6.1.%20%20SMX%20Message%20Processing%20on%20the%20Runtime%20Systems"></a><a class="selflink" href="#section-6.1" name="section-6.1">6.1</a>.  SMX Message Processing on the Runtime Systems</span>

   This section describes the processing of SMX command messages by a
   runtime engine and the conditions under which asynchronous
   notifications are generated.

   When the runtime system receives a message, it first tries to
   recognize a command consisting of the command string and the
   transaction identifier. If the runtime system is not able to extract
   both the command string and the transaction identifier, then the
   message is discarded. An asynchronous `511' reply may be generated in
   this case. Otherwise, the command string is checked to be valid, i.e.
   to be one of the strings `hello', `start', `suspend', `resume',
   `abort', or `status'.  If the string is invalid, a `402' reply is



<span class="grey">Schoenwaelder &amp; Quittek       Experimental                      [Page 9]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-10" id="page-10" name="page-10"> </a>
<span class="grey"><a href="rfc2593.html">RFC 2593</a>                    SMX Protocol 1.0                    May 1999</span>


   sent and processing of the message stops.  If a valid command has
   been detected, further processing of the message depends on the
   command as described below.

   The command specific processing describes several possible syntax
   errors for which specific reply messages are generated. If the
   runtime engine detects any syntax error which is not explicitely
   mentioned or which cannot be identified uniquely, a generic `401'
   reply is sent indicating that the command cannot be executed.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/6.1.1.%20%20Processing%20the%20%60hello%27%20Command"></a><a class="selflink" href="#section-6.1.1" name="section-6.1.1">6.1.1</a>.  Processing the `hello' Command</span>

   When the runtime system receives a `hello' command, it processes it
   as follows:

   1.   The runtime system obtains the security cookie from its process
        environment.

   2.   The runtime system sends a `211' reply containing the security
        cookie.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/6.1.2.%20%20Processing%20the%20%60start%27%20Command"></a><a class="selflink" href="#section-6.1.2" name="section-6.1.2">6.1.2</a>.  Processing the `start' Command</span>

   When the runtime system receives a `start' command, it processes it
   as follows:

   1.   The syntax of the arguments of the `start' command is checked.
        The following four checks must be made:

        (a)   The syntax of the `RunId' parameter is checked and a `431'
              reply is sent if any syntax error is detected.

        (b)   The syntax of the `Script' parameter is checked and a
              `421' reply is sent if any syntax error is detected.

        (c)   The syntax of the `Profile' parameter is checked and a
              `432' reply is sent if any syntax error is detected.

        (d)   If syntax of the `Argument' parameter is checked and a
              `433' reply is sent if any syntax error is detected.

   2.   The runtime system checks whether the new `RunId' is already in
        use. If yes, a `431' reply is sent and processing stops.

   3.   The runtime system checks whether the `Script' parameter is the
        name of a file on the local storage device, that can be read. A
        `421' reply is sent and processing stops if the file does not
        exist or is not readable.



<span class="grey">Schoenwaelder &amp; Quittek       Experimental                     [Page 10]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-11" id="page-11" name="page-11"> </a>
<span class="grey"><a href="rfc2593.html">RFC 2593</a>                    SMX Protocol 1.0                    May 1999</span>


   4.   The runtime system checks whether the security profile is known
        and sends a `432' reply and stops processing if not.

   5.   The runtime engine starts the script given by the script name.
        When the script has been started, a `231' reply is sent
        including the current run state.

   Processing of the `start' command stops, when the script reaches the
   state `running'. For each asynchronous state change of the running
   script, a `531' reply is sent. Processing of the `start' command is
   also stopped if an error occurs before the state `running' is
   reached. In this case, the run is aborted and a `535' reply is
   generated.

   If an `abort' command or a `suspend' command for the running script
   is received before processing of the `start' command is complete,
   then the processing of the `start' command may be stopped before the
   state `running' is reached. In this case, the resulting status of the
   running script is given by the respective reply to the `abort' or
   `suspend' command, and no reply with the transaction identifier of
   the `start' command is generated.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/6.1.3.%20%20Processing%20the%20%60suspend%27%20Command"></a><a class="selflink" href="#section-6.1.3" name="section-6.1.3">6.1.3</a>.  Processing the `suspend' Command</span>

   When the runtime system receives a `suspend' command, it processes it
   as follows:

   1.   If there is a syntax error in the running script identifier or
        if there is no running script matching the identifier, a `431'
        reply is sent and processing of the command is stopped.

   2.   If the running script is already in the state `suspended', a
        '231' reply is sent and processing of the command is stopped.

   3.   If the running script is in the state `running', it is suspended
        and a `231' reply is sent after suspending. If suspending fails,
        a `434' reply is sent and processing of the command is stopped.

   4.   If the running script has not yet reached the state `running'
        (the `start' command still being processed), it may reach the
        state `suspended' without having been in the state `running'.
        After reaching the state `suspended', a `231' reply is sent.

   5.   If the running script is in any other state, a `434' reply is
        sent.






<span class="grey">Schoenwaelder &amp; Quittek       Experimental                     [Page 11]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-12" id="page-12" name="page-12"> </a>
<span class="grey"><a href="rfc2593.html">RFC 2593</a>                    SMX Protocol 1.0                    May 1999</span>


<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/6.1.4.%20%20Processing%20the%20%60resume%27%20Command"></a><a class="selflink" href="#section-6.1.4" name="section-6.1.4">6.1.4</a>.  Processing the `resume' Command</span>

   When the runtime system receives a `resume' command, it processes it
   as follows:

   1.   If there is a syntax error in the running script identifier or
        if there is no running script matching the identifier, a `431'
        reply is sent and processing of the command is stopped.

   2.   If the running script is already in the state `running', a `231'
        reply is sent and processing of the command is stopped.

   3.   If the running script is in the state `suspended', it is resumed
        and a `231' reply is sent after resuming. If resuming fails, a
        `434' reply is sent and processing of the command is stopped.

   4.   If the `start' command is still being processed for the script,
        a `231' reply is sent when the state `running' has been reached.

   5.   If the running script is in any other state, a `434' reply is
        sent.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/6.1.5.%20%20Processing%20the%20%60abort%27%20Command"></a><a class="selflink" href="#section-6.1.5" name="section-6.1.5">6.1.5</a>.  Processing the `abort' Command</span>

   When the runtime system receives an `abort' command, it processes it
   as follows:

   1.   If there is a syntax error in the running script identifier or
        if there is no running script matching the identifier, a `431'
        reply is sent and processing of the command is stopped.

   2.   If the running script is already aborted, a `232' reply is sent
        and processing of the command is stopped.

   3.   The running script is aborted and a `232' reply is sent after
        aborting. If aborting fails, a `434' reply is sent and
        processing is stopped.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/6.1.6.%20%20Processing%20the%20%60status%27%20Command"></a><a class="selflink" href="#section-6.1.6" name="section-6.1.6">6.1.6</a>.  Processing the `status' Command</span>

   When the runtime system receives a `status' command, it processes it
   as follows:

   1.   If there is a syntax error in the running script identifier or
        if there is no running script matching the identifier, a `431'
        reply is sent and processing of the command is stopped.

   2.   The status of the script is obtained and a `231' reply is sent.



<span class="grey">Schoenwaelder &amp; Quittek       Experimental                     [Page 12]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-13" id="page-13" name="page-13"> </a>
<span class="grey"><a href="rfc2593.html">RFC 2593</a>                    SMX Protocol 1.0                    May 1999</span>


<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/6.1.7.%20%20Generation%20of%20Asynchronous%20Notifications"></a><a class="selflink" href="#section-6.1.7" name="section-6.1.7">6.1.7</a>.  Generation of Asynchronous Notifications</span>

   The runtime system generates or may generate the following
   notifications:

   1.   If a change of the status of a running script is observed by the
        runtime system, a `531' reply is sent.

   2.   A `534' reply is sent if a running script terminates normally.

   3.   A `535' reply is sent if a running script terminates abnormally.

   4.   If a script generates an intermediate result, a `532' reply is
        sent.

   5.   If a script requests the generation of a `smScriptResult'
        notification, a `533' reply is sent.

   6.   Besides the notifications mentioned above, the runtime system
        may generate arbitrary `511' replies, which are logged or
        displayed by the SNMP agent.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/6.2.%20%20SMX%20Message%20Processing%20on%20the%20SNMP%20Agent"></a><a class="selflink" href="#section-6.2" name="section-6.2">6.2</a>.  SMX Message Processing on the SNMP Agent</span>

   This section describes the conditions under which an SNMP agent
   implementing the Script MIB generates SMX commands. It also describes
   how the SNMP agent processes replies to SMX commands.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/6.2.1.%20%20Creating%20a%20Runtime%20System"></a><a class="selflink" href="#section-6.2.1" name="section-6.2.1">6.2.1</a>.  Creating a Runtime System</span>

   New runtime systems are started by the SNMP agent while processing
   set requests for a `smLaunchStart' variable. The SNMP agent first
   searches for an already running runtime systems which matches the
   security profiles associated with the `smLaunchStart' variable. If no
   suitable runtime system is available, a new runtime system is started
   by preparing the environment for the new runtime system and starting
   the executable for the runtime system in a new process which conforms
   to the operating system security profile. The SNMP agent prepares to
   accept a connection from the new runtime system. The `smRunState' of
   all scripts that should be executed in this new runtime system is set
   to `initializing'.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/6.2.2.%20%20Generating%20the%20%60hello%27%20Command"></a><a class="selflink" href="#section-6.2.2" name="section-6.2.2">6.2.2</a>.  Generating the `hello' Command</span>

   The `hello' command is generated once a connection request from a
   runtime system has been accepted. The SNMP agent sends the `hello'
   command as defined in <a href="#section-5.2">section 5.2</a>. The SNMP agent then expects a
   reply from the runtime system within a reasonable timeout interval.



<span class="grey">Schoenwaelder &amp; Quittek       Experimental                     [Page 13]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-14" id="page-14" name="page-14"> </a>
<span class="grey"><a href="rfc2593.html">RFC 2593</a>                    SMX Protocol 1.0                    May 1999</span>


   1.   If the timeout expires before the SNMP agent received a reply,
        then the connection is closed and all data associated with it is
        deleted.  Any scripts that should be running in this runtime
        system are aborted, the `smRunExitCode' is set to `genericError'
        and `smRunError' is modified to describe the error situation.

   2.   If the received message can not be analyzed because it does not
        have the required format, then the connection is closed and all
        data associated with it is deleted. Any scripts that should be
        running in this runtime system are aborted, the `smRunExitCode'
        is set to `genericError' and `smRunError' is modified to
        describe the error situation.

   3.   If the received message is a `211' reply, then the `Id' is
        checked whether it matches the `Id' used in the `hello' command.
        If the `Id' matches, then the `Version' is checked. If the
        `Version' matches a supported SMX protocol version, then the
        `Cookie' is checked whether it matches the cookie passed to the
        runtime system. If any of these tests fails, then the connection
        is closed and all data associated with this runtime system is
        deleted. Any scripts that should be running in this runtime
        system are aborted, the `smRunExitCode' is set to `genericError'
        and `smRunError' is modified to describe the error situation.

   4.   Received messages are discarded if none of the previous rules
        applies.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/6.2.3.%20%20Generating%20the%20%60start%27%20Command"></a><a class="selflink" href="#section-6.2.3" name="section-6.2.3">6.2.3</a>.  Generating the `start' Command</span>

   The `start' command is generated while processing set-requests for a
   `smLaunchStart' variable. The `start' command assumes that the SNMP
   agent already determined a runtime system suitable to execute the
   script associated with the `smLaunchStart' variable.  The SNMP agent
   sends the `start' command as defined in <a href="#section-5.2">section 5.2</a> to the selected
   runtime system. The SNMP agent then expects a reply from the runtime
   system within a reasonable timeout interval.

   1.   If the timeout expires before the SNMP agent received a reply,
        then the SNMP agent sends an `abort' command to abort the
        running script and sets the `smRunState' of the running script
        to `terminated', the `smRunExitCode' to `genericError' and
        `smRunError' is modified to describe the timeout situation.

   2.   If the received message can not be analyzed because it does not
        have the required format, then the message is ignored. The SNMP
        agent continues to wait for a valid reply message until the
        timeout expires.




<span class="grey">Schoenwaelder &amp; Quittek       Experimental                     [Page 14]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-15" id="page-15" name="page-15"> </a>
<span class="grey"><a href="rfc2593.html">RFC 2593</a>                    SMX Protocol 1.0                    May 1999</span>


   3.   If the received message is a `4yz' reply and the `Id' matches
        the `Id' of the `start' command, then the SNMP agent assumes
        that the script can not be started. The `smRunState' of the
        running script is set to `terminated', the `smRunExitCode' to
        `genericError' and the `smRunError' is modified to contain a
        message describing the error situation.

   4.   If the received message is a `231' reply and the `Id' matches
        the `Id' of the `start' command, then the `smRunState' variable
        of the running script is updated.

   5.   Received messages are discarded if none of the previous rules
        applies.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/6.2.4.%20%20Generating%20the%20%60suspend%27%20Command"></a><a class="selflink" href="#section-6.2.4" name="section-6.2.4">6.2.4</a>.  Generating the `suspend' Command</span>

   The `suspend' command is generated while processing set-requests for
   the `smLaunchControl' and `smRunControl' variables which change the
   value to `suspend'. The SNMP agent sets the `smRunState' variable to
   `suspending' and sends the `suspend' command as defined in <a href="#section-5.2">section</a>
   <a href="#section-5.2">5.2</a>. The SNMP agent then expects a reply from the runtime system
   within a reasonable timeout interval.

   1.   If the timeout expires before the SNMP agent received a reply,
        then the SNMP agent sends an `abort' command to abort the
        running script and sets the `smRunState' of the running script
        to `terminated', the `smRunExitCode' to `genericError' and
        `smRunError' is modified to describe the timeout situation.

   2.   If the received message can not be analyzed because it does not
        have the required format, then the message is ignored. The SNMP
        agent continues to wait for a valid reply message until the
        timeout expires.

   3.   If the received message is a `401', `402' or a `431' reply and
        the `Id' matches the `Id' of the `suspend' command, then the
        runtime systems is assumed to not provide the suspend/resume
        capability and processing of the `suspend' command stops.

   4.   If the received message is a `231' reply and the `Id' matches
        the `Id' of the `suspend' command, then the `smRunState'
        variable of the running script is updated.

   5.   Received messages are discarded if none of the previous rules
        applies.






<span class="grey">Schoenwaelder &amp; Quittek       Experimental                     [Page 15]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-16" id="page-16" name="page-16"> </a>
<span class="grey"><a href="rfc2593.html">RFC 2593</a>                    SMX Protocol 1.0                    May 1999</span>


<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/6.2.5.%20%20Generating%20the%20%60resume%27%20Command"></a><a class="selflink" href="#section-6.2.5" name="section-6.2.5">6.2.5</a>.  Generating the `resume' Command</span>

   The `resume' command is generated while processing set-requests for
   the `smLaunchControl' and `smRunControl' variables which change the
   value to `resume'. The SNMP agent sets the `smRunState' variable to
   `resuming' and sends the `resume' command as defined in <a href="#section-5.2">section 5.2</a>.
   The SNMP agent then expects a reply from the runtime system within a
   reasonable timeout interval.

   1.   If the timeout expires before the SNMP agent received a reply,
        then the SNMP agent sends an `abort' command to abort the
        running script and sets the `smRunState' of the running script
        to `terminated', the `smRunExitCode' to `genericError' and
        `smRunError' is modified to describe the timeout situation.

   2.   If the received message can not be analyzed because it does not
        have the required format, then the message is ignored. The SNMP
        agent continues to wait for a valid reply message until the
        timeout expires.

   3.   If the received message is a `401', `402' or a `431' reply and
        the `Id' matches the `Id' of the `resume' command, then the
        runtime systems is assumed to not provide the suspend/resume
        capability and processing of the `resume' command stops.

   4.   If the received message is a `231' reply and the `Id' matches
        the `Id' of the `resume' command, then the `smRunState' variable
        of the running script is updated.

   5.   Received messages are discarded if none of the previous rules
        applies.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/6.2.6.%20%20Generating%20the%20%60abort%27%20Command"></a><a class="selflink" href="#section-6.2.6" name="section-6.2.6">6.2.6</a>.  Generating the `abort' Command</span>

   The `abort' command is generated while processing set-requests for
   the `smLaunchControl' and `smRunControl' variables which change the
   value to `abort'. In addition, the `abort' command is also generated
   if the `smRunLifeTime' variable reaches the value 0. The SNMP agent
   sends the `abort' command as defined in <a href="#section-5.2">section 5.2</a>. The SNMP agent
   then expects a reply from the runtime system within a reasonable
   timeout interval.

   1.   If the timeout expires before the SNMP agent received a reply,
        then the SNMP agent sets the `smRunState' of the running script
        to `terminated', the `smRunExitCode' to `genericError' and
        `smRunError' is modified to describe the timeout situation.





<span class="grey">Schoenwaelder &amp; Quittek       Experimental                     [Page 16]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-17" id="page-17" name="page-17"> </a>
<span class="grey"><a href="rfc2593.html">RFC 2593</a>                    SMX Protocol 1.0                    May 1999</span>


   2.   If the received message can not be analyzed because it does not
        have the required format, then the message is ignored. The SNMP
        agent continues to wait for a valid reply message until the
        timeout expires.

   3.   If the received message is a `4yz' reply and the `Id' matches
        the `Id' of the `abort' command, then the SNMP agent assumes
        that the script can not be aborted. The `smRunState' of the
        running script is set to `terminated', the `smRunExitCode' to
        `genericError' and the `smRunResult' is modified to describe the
        error situation.

   4.   If the received message is a `232' reply and the `Id' matches
        the `Id' of the `abort' command, then the `smRunExitCode'
        variable of the terminated script is changed to either `halted'
        (when processing a set-request for the `smLaunchControl' and
        `smRunControl' variables) or `lifeTimeExceeded' (if the `abort'
        command was generated because the `smRunLifeTime' variable
        reached the value 0). The `smRunState' variable is changed to
        the value `terminated'.

   5.   Received messages are discarded if none of the previous rules
        applies.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/6.2.7.%20%20Generating%20the%20%60status%27%20Command"></a><a class="selflink" href="#section-6.2.7" name="section-6.2.7">6.2.7</a>.  Generating the `status' Command</span>

   The `status' command is generated either periodically or on demand by
   the SNMP agent in order to retrieve status information from running
   scripts. The SNMP agent sends the `status' command as defined in 5.2.
   The SNMP agent then expects a reply from the runtime system within a
   reasonable timeout interval.

   1.   If the timeout expires before the SNMP agent received a reply,
        then the SNMP agent sends an `abort' command to abort the
        running script and sets the `smRunState' of the running script
        to `terminated', the `smRunExitCode' to `genericError' and
        `smRunError' is modified to describe the timeout situation.

   2.   If the received message can not be analyzed because it does not
        have the required format, then the message is ignored. The SNMP
        agent continues to wait for a valid reply message until the
        timeout expires.

   3.   If the received message is a `4yz' reply and the `Id' matches
        the `Id' of the `status' command, then the SNMP agent assumes
        that the script status can not be read, which is a fatal error
        condition. The SNMP agent sends an `abort' command to abort the
        running script. The `smRunState' of the running script is set to



<span class="grey">Schoenwaelder &amp; Quittek       Experimental                     [Page 17]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-18" id="page-18" name="page-18"> </a>
<span class="grey"><a href="rfc2593.html">RFC 2593</a>                    SMX Protocol 1.0                    May 1999</span>


        `terminated', the `smRunExitCode' to `genericError' and the
        `smRunError' is modified to describe the error situation.

   4.   If the received message is a `231' reply and the `Id' matches
        the `Id' of the `status' command, then the `smRunState' variable
        of the running script is updated.

   5.   Received messages are discarded if none of the previous rules
        applies.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/6.2.8.%20%20Processing%20Asynchronous%20Notifications"></a><a class="selflink" href="#section-6.2.8" name="section-6.2.8">6.2.8</a>.  Processing Asynchronous Notifications</span>

   The runtime system can send asynchronous status change notifications.
   These `5yz' replies are processed as described below.

   1.   If the received message is a `511' reply, then the message is
        displayed or logged appropriately and processing stops.

   2.   If the received message is a `531' reply, then the SNMP agent
        checks whether a running script with the given `RunId' exists in
        the runtime system. Processing of the notification stops if
        there is no running script with the `RunId'. Otherwise, the
        `smRunState' is updated.

   3.   If the received message is a `532' reply, then the SNMP agent
        checks whether a running script with the given `RunId' exists in
        the runtime system. Processing of the notification stops if
        there is no running script with the `RunId'. Otherwise,
        `smRunState' and `smRunResult' are updated.

   4.   If the received message is a `533' reply, then the SNMP agent
        checks whether a running script with the given `RunId' exists in
        the runtime system. Processing of the notification stops if
        there is no running script with the `RunId'. Otherwise,
        `smRunState' and `smRunResult' are updated and the
        `smScriptResult' notification is generated.

   5.   If the received message is a `534' reply, then the SNMP agent
        checks whether a running script with the given `RunId' exists in
        the runtime system. Processing stops if there is no running
        script with the `RunId'. Otherwise, `smExitCode' is set to
        `noError', `smRunState' is set to `terminated' and `smRunResult'
        is updated.

   6.   If the received message is a `535' reply, then the SNMP agent
        checks whether a running script with the given `RunId' exists in
        the runtime system. Processing stops if there is no running
        script with the `RunId'. Otherwise, `smRunState' is set to



<span class="grey">Schoenwaelder &amp; Quittek       Experimental                     [Page 18]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-19" id="page-19" name="page-19"> </a>
<span class="grey"><a href="rfc2593.html">RFC 2593</a>                    SMX Protocol 1.0                    May 1999</span>


        `terminated' and `smExitCode' and `smRunError' are updated.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/7.%20%20An%20Example%20SMX%20Message%20Flow"></a><a class="selflink" href="#section-7" name="section-7">7</a>.  An Example SMX Message Flow</span>

   Below is an example SMX message exchange. Messages send from the SNMP
   agent are marked with `&gt;' while replies send from the runtime system
   are marked with `&lt;'. Line terminators (`CRLF') are not shown in order
   to make the example more readable.

     &gt; hello 1
     &lt; 211 1 SMX/1.0 0AF0BAED6F877FBC
     &gt; start 2 42 "/var/snmp/scripts/foo.jar" untrusted ""
     &gt; start 5 44 "/var/snmp/scripts/bar.jar" trusted "www.ietf.org"
     &lt; 231 2 2
     &gt; start 12 48 "/var/snmp/scripts/foo.jar" funny ""
     &lt; 231 5 2
     &lt; 532 0 44 2 "waiting for response"
     &gt; status 18 42
     &gt; status 19 44
     &lt; 432 12
     &lt; 231 19 2
     &lt; 231 18 2
     &gt; hello 578
     &lt; 211 578 SMX/1.0 0AF0BAED6F877FBC
     &gt; suspend 581 42
     &lt; 231 581 4
     &lt; 534 0 44 "test completed"
     &gt; abort 611 42
     &lt; 232 611

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/8.%20%20Security%20Considerations"></a><a class="selflink" href="#section-8" name="section-8">8</a>.  Security Considerations</span>

   The SMX protocol runs on top of a local TCP connection. Protocol
   messages never leave the local system. It is therefore not possible
   to attack the message exchanges if the underlying operating system
   protects local TCP connections from other users on the same machine.

   The only critical situation is the connection establishment phase.
   The rules defined in <a href="#section-4">section 4</a> ensure that only local connections are
   accepted and that a runtime system has to identify itself with a
   security cookie generated by the SNMP agent and passed to the runtime
   system process as part of its environment. This rule ensures that
   scripts will only be executed on authorized runtime systems. This
   scheme relies on the protection of process environments by the
   operating system. Well maintained UNIX operating systems have this
   property.





<span class="grey">Schoenwaelder &amp; Quittek       Experimental                     [Page 19]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-20" id="page-20" name="page-20"> </a>
<span class="grey"><a href="rfc2593.html">RFC 2593</a>                    SMX Protocol 1.0                    May 1999</span>


   The SMX protocol allows to execute script under different operating
   system and runtime system security profiles. The memo suggests to map
   the smLaunchOwner value to an operating system and a runtime system
   security profile. The operating system security profile is enforced
   by the operating system by setting up a proper process environment.
   The runtime security profile is enforced by a secure runtime system
   (e.g. the Java virtual machine or a safe Tcl interpreter) [<a href="#ref-7" title='"Secure Management by Delegation within the Internet Management"'>7</a>].

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/9.%20%20Acknowledgments"></a><a class="selflink" href="#section-9" name="section-9">9</a>.  Acknowledgments</span>

   The protocol described in this memo is the result of a joint project
   between the Technical University of Braunschweig and C&amp;C Research
   Laboratories of NEC Europe Ltd. in Berlin. We would like to thank the
   following project members for their contributions to the initial
   design and the implementation of the protocol described in this memo:

           M. Bolz         (TU Braunschweig)
           C. Kappler      (NEC Europe Ltd.)
           A. Kind         (NEC Europe Ltd.)
           S. Mertens      (TU Braunschweig)
           J. Nicklisch    (NEC Europe Ltd.)

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/10.%20%20References"></a><a class="selflink" href="#section-10" name="section-10">10</a>.  References</span>

   [<a id="ref-1" name="ref-1">1</a>]  Levi, D. and J. Schoenwaelder, "Definitions of Managed Objects
        for the Delegation of Management Scripts", <a href="rfc2592.html">RFC 2592</a>, May 1999.

   [<a id="ref-2" name="ref-2">2</a>]  Lindholm, T., and F. Yellin, "The Java Virtual Machine
        Specification", Addison Wesley, 1997.

   [<a id="ref-3" name="ref-3">3</a>]  J.K. Ousterhout, "Tcl and the Tk Toolkit", Addison Wesley, 1994.

   [<a id="ref-4" name="ref-4">4</a>]  Fritzinger, J.S., and M. Mueller, "Java Security", White Paper,
        Sun Microsystems, Inc., 1996.

   [<a id="ref-5" name="ref-5">5</a>]  Levy, J.Y., Demailly, L., Ousterhout, J.K., and B. Welch, "The
        Safe-Tcl Security Model", Proc. USENIX Annual Technical
        Conference, June 1998.

   [<a id="ref-6" name="ref-6">6</a>]  Crocker, D., and P. Overell, "Augmented BNF for Syntax
        Specifications: ABNF", <a href="rfc2234.html">RFC 2234</a>, Internet Mail Consortium, Demon
        Internet Ltd., November 1997.

   [<a id="ref-7" name="ref-7">7</a>]  Schoenwaelder, J., and J. Quittek, "Secure Management by
        Delegation within the Internet Management", Proc. IFIP/IEEE
        International Symposium on Integrated Network Management '99,
        May 1999.




<span class="grey">Schoenwaelder &amp; Quittek       Experimental                     [Page 20]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-21" id="page-21" name="page-21"> </a>
<span class="grey"><a href="rfc2593.html">RFC 2593</a>                    SMX Protocol 1.0                    May 1999</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/11.%20%20Authors%27%20Addresses"></a><a class="selflink" href="#section-11" name="section-11">11</a>.  Authors' Addresses</span>

   Juergen Schoenwaelder
   TU Braunschweig
   Bueltenweg 74/75
   38106 Braunschweig
   Germany

   Phone: +49 531 391-3283
   EMail: schoenw@ibr.cs.tu-bs.de


   Juergen Quittek
   NEC Europe Ltd.
   C&amp;C Research Laboratories
   Hardenbergplatz 2
   10623 Berlin
   Germany

   Phone: +49 30 254230-19
   EMail: quittek@ccrle.nec.de






























<span class="grey">Schoenwaelder &amp; Quittek       Experimental                     [Page 21]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-22" id="page-22" name="page-22"> </a>
<span class="grey"><a href="rfc2593.html">RFC 2593</a>                    SMX Protocol 1.0                    May 1999</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/12.%20%20Full%20Copyright%20Statement"></a><a class="selflink" href="#section-12" name="section-12">12</a>.  Full Copyright Statement</span>

   Copyright (C) The Internet Society (1999). All Rights Reserved.

   This document and translations of it may be copied and furnished to
   others, and derivative works that comment on or otherwise explain it
   or assist in its implementation may be prepared, copied, published
   and distributed, in whole or in part, without restriction of any
   kind, provided that the above copyright notice and this paragraph are
   included on all such copies and derivative works.  However, this
   document itself may not be modified in any way, such as by removing
   the copyright notice or references to the Internet Society or other
   Internet organizations, except as needed for the  purpose of
   developing Internet standards in which case the procedures for
   copyrights defined in the Internet Standards process must be
   followed, or as required to translate it into languages other than
   English.

   The limited permissions granted above are perpetual and will not be
   revoked by the Internet Society or its successors or assigns.

   This document and the information contained herein is provided on an
   "AS IS" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING
   TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING
   BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION
   HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF
   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.

Acknowledgement

   Funding for the RFC Editor function is currently provided by the
   Internet Society.



















Schoenwaelder &amp; Quittek       Experimental                     [Page 22]

</pre><br/>
    <span class="noprint"><small><small>Html markup produced by rfcmarkup 1.126, available from
      <a href="https://tools.ietf.org/tools/rfcmarkup/">https://tools.ietf.org/tools/rfcmarkup/</a>
    </small></small></span>
  </div>




</body><!-- Mirrored from tools.ietf.org/html/rfc2593 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 06 Mar 2018 23:18:53 GMT --></html>