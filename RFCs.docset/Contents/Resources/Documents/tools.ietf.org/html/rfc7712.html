<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml"><!-- Mirrored from tools.ietf.org/html/rfc7712 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 06 Mar 2018 23:18:19 GMT --><!-- Added by HTTrack --><head><meta content="text/html;charset=utf-8" http-equiv="content-type"/><!-- /Added by HTTrack -->

    <meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
    <meta content="index,follow" name="robots"/>
    <meta content="rfcmarkup version 1.126" name="creator"/>
    <link href="http://purl.org/dc/elements/1.1/" rel="schema.DC"/>
<meta content="draft-saintandre-xmpp-dna" name="DC.Relation.Replaces"/>
<meta content="urn:ietf:rfc:7712" name="DC.Identifier"/>
<meta content="November, 2015" name="DC.Date.Issued"/>
<meta content="Hancke, Philipp" name="DC.Creator"/>
<meta content="Miller, Matthew" name="DC.Creator"/>
<meta content="Saint-Andre, Peter" name="DC.Creator"/>
<meta content='This document improves the security of the Extensible Messaging and
Presence Protocol (XMPP) in two ways. First, it specifies how to
establish a strong association between a domain name and an XML
stream, using the concept of "prooftypes". Second, it describes how to
securely delegate a service domain name (e.g., example.com) to a
target server hostname (e.g., hosting.example.net); this is especially
important in multi-tenanted environments where the same target server
hosts a large number of domains.' name="DC.Description.Abstract"/>
<meta content="Domain Name Associations (DNA) in the Extensible Messaging and Presence Protocol (XMPP)" name="DC.Title"/>

    <link href="https://tools.ietf.org/images/rfc.png" rel="icon" type="image/png"/>
    <link href="https://tools.ietf.org/images/rfc.png" rel="shortcut icon" type="image/png"/>
    <title>RFC 7712 - Domain Name Associations (DNA) in the Extensible Messaging and Presence Protocol (XMPP)</title>
    
    
    <style type="text/css">
	@media only screen 
	  and (min-width: 992px)
	  and (max-width: 1199px) {
	    body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 768px)
	  and (max-width: 991px) {
            body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 480px)
	  and (max-width: 767px) {
            body { font-size: 11pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (max-width: 479px) {
            body { font-size: 8pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-device-width : 375px) 
	  and (max-device-width : 667px) {
            body { font-size: 9.5pt; }
            div.content { width: 96ex; margin: 0 1px; }
        }
	@media only screen 
	  and (min-device-width: 1200px) {
            body { font-size: 10pt; margin: 0 4em; }
            div.content { width: 96ex; margin: 0; }
        }
        h1, h2, h3, h4, h5, h6, .h1, .h2, .h3, .h4, .h5, .h6 {
	    font-weight: bold;
            line-height: 0pt;
            display: inline;
            white-space: pre;
            font-family: monospace;
            font-size: 1em;
	    font-weight: bold;
        }
        pre {
            font-size: 1em;
            margin-top: 0px;
            margin-bottom: 0px;
        }
	.pre {
	    white-space: pre;
	    font-family: monospace;
	}
	.header{
	    font-weight: bold;
	}
        .newpage {
            page-break-before: always;
        }
        .invisible {
            text-decoration: none;
            color: white;
        }
        a.selflink {
          color: black;
          text-decoration: none;
        }
        @media print {
            body {
                font-family: monospace;
                font-size: 10.5pt;
            }
            h1, h2, h3, h4, h5, h6 {
                font-size: 1em;
            }
        
            a:link, a:visited {
                color: inherit;
                text-decoration: none;
            }
            .noprint {
                display: none;
            }
        }
	@media screen {
	    .grey, .grey a:link, .grey a:visited {
		color: #777;
	    }
            .docinfo {
                background-color: #EEE;
            }
            .top {
                border-top: 7px solid #EEE;
            }
            .bgwhite  { background-color: white; }
            .bgred    { background-color: #F44; }
            .bggrey   { background-color: #666; }
            .bgbrown  { background-color: #840; }            
            .bgorange { background-color: #FA0; }
            .bgyellow { background-color: #EE0; }
            .bgmagenta{ background-color: #F4F; }
            .bgblue   { background-color: #66F; }
            .bgcyan   { background-color: #4DD; }
            .bggreen  { background-color: #4F4; }

            .legend   { font-size: 90%; }
            .cplate   { font-size: 70%; border: solid grey 1px; }
	}
    </style>
    <!--[if IE]>
    <style>
    body {
       font-size: 13px;
       margin: 10px 10px;
    }
    </style>
    <![endif]-->

    <script type="text/javascript"><!--
    function addHeaderTags() {
	var spans = document.getElementsByTagName("span");
	for (var i=0; i < spans.length; i++) {
	    var elem = spans[i];
	    if (elem) {
		var level = elem.getAttribute("class");
                if (level == "h1" || level == "h2" || level == "h3" || level == "h4" || level == "h5" || level == "h6") {
                    elem.innerHTML = "<"+level+">"+elem.innerHTML+"</"+level+">";		
                }
	    }
	}
    }
    var legend_html = "Colour legend:<br />      <table>         <tr><td>Unknown:</td>                   <td><span class='cplate bgwhite'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft:</td>                     <td><span class='cplate bgred'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Informational:</td>             <td><span class='cplate bgorange'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Experimental:</td>              <td><span class='cplate bgyellow'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Best Common Practice:</td>      <td><span class='cplate bgmagenta'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Proposed Standard:</td>         <td><span class='cplate bgblue'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft Standard (old designation):</td> <td><span class='cplate bgcyan'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Internet Standard:</td>         <td><span class='cplate bggreen'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Historic:</td>                  <td><span class='cplate bggrey'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Obsolete:</td>                  <td><span class='cplate bgbrown'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>     </table>";
    function showElem(id) {
        var elem = document.getElementById(id);
        elem.innerHTML = eval(id+"_html");
        elem.style.visibility='visible';
    }
    function hideElem(id) {
        var elem = document.getElementById(id);
        elem.style.visibility='hidden';        
        elem.innerHTML = "";
    }
    // -->
    </script>
</head>
<body onload="addHeaderTags()">
  <div class="content">
   <div style="height: 13px;">
      <div class="pre noprint docinfo bgblue" onclick="showElem('legend');" onmouseout="hideElem('legend')" onmouseover="this.style.cursor='pointer';" style="height: 6px; position: absolute;" title="Click for colour legend.">                                                                        </div>
      <div class="docinfo noprint pre legend" id="legend" onmouseout="hideElem('legend');" onmouseover="showElem('legend');" style="position:absolute; top: 4px; left: 4ex; visibility:hidden; background-color: white; padding: 4px 9px 5px 7px; border: solid #345 1px; ">
      </div>
   </div>
<span class="pre noprint docinfo top">[<a href="index.html" title="Document search and retrieval page">Docs</a>] [<a href="https://tools.ietf.org/rfc/rfc7712.txt" title="Plaintext version of this document">txt</a>|<a href="https://tools.ietf.org/pdf/rfc7712" title="PDF version of this document">pdf</a>] [<a href="https://tools.ietf.org/html/draft-ietf-xmpp-dna" title="draft-ietf-xmpp-dna">draft-ietf-xmpp...</a>] [<a href="https://datatracker.ietf.org/doc/rfc7712" title="IESG Datatracker information for this document">Tracker</a>] [<a href="https://tools.ietf.org/rfcdiff?difftype=--hwdiff&amp;url2=rfc7712" title="Inline diff (wdiff)">Diff1</a>] [<a href="https://tools.ietf.org/rfcdiff?url2=rfc7712" title="Side-by-side diff">Diff2</a>]         </span><br/>
<span class="pre noprint docinfo">                                                                        </span><br/>
<span class="pre noprint docinfo">                                                       PROPOSED STANDARD</span><br/>
<span class="pre noprint docinfo">                                                                        </span><br/>
<pre>Internet Engineering Task Force (IETF)                    P. Saint-Andre
Request for Comments: 7712                                          &amp;yet
Category: Standards Track                                      M. Miller
ISSN: 2070-1721                                      Cisco Systems, Inc.
                                                               P. Hancke
                                                                    &amp;yet
                                                           November 2015


                     <span class="h1">Domain Name Associations (DNA)</span>
        <span class="h1">in the Extensible Messaging and Presence Protocol (XMPP)</span>

Abstract

   This document improves the security of the Extensible Messaging and
   Presence Protocol (XMPP) in two ways.  First, it specifies how to
   establish a strong association between a domain name and an XML
   stream, using the concept of "prooftypes".  Second, it describes how
   to securely delegate a service domain name (e.g., example.com) to a
   target server hostname (e.g., hosting.example.net); this is
   especially important in multi-tenanted environments where the same
   target server hosts a large number of domains.

Status of This Memo

   This is an Internet Standards Track document.

   This document is a product of the Internet Engineering Task Force
   (IETF).  It represents the consensus of the IETF community.  It has
   received public review and has been approved for publication by the
   Internet Engineering Steering Group (IESG).  Further information on
   Internet Standards is available in <a href="rfc5741.html#section-2">Section 2 of RFC 5741</a>.

   Information about the current status of this document, any errata,
   and how to provide feedback on it may be obtained at
   <a href="http://www.rfc-editor.org/info/rfc7712">http://www.rfc-editor.org/info/rfc7712</a>.















<span class="grey">Saint-Andre, et al.          Standards Track                    [Page 1]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-2" id="page-2" name="page-2"> </a>
<span class="grey"><a href="rfc7712.html">RFC 7712</a>                        XMPP DNA                   November 2015</span>


Copyright Notice

   Copyright (c) 2015 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to <a href="https://tools.ietf.org/html/bcp78">BCP 78</a> and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (<a href="http://trustee.ietf.org/license-info">http://trustee.ietf.org/license-info</a>) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.

Table of Contents

   <a href="#section-1">1</a>. Introduction ....................................................<a href="#page-3">3</a>
   <a href="#section-2">2</a>. Terminology .....................................................<a href="#page-4">4</a>
   <a href="#section-3">3</a>. Client-to-Server (C2S) DNA ......................................<a href="#page-4">4</a>
      <a href="#section-3.1">3.1</a>. C2S Flow ...................................................<a href="#page-4">4</a>
      <a href="#section-3.2">3.2</a>. C2S Description ............................................<a href="#page-5">5</a>
   <a href="#section-4">4</a>. Server-to-Server (S2S) DNA ......................................<a href="#page-5">5</a>
      <a href="#section-4.1">4.1</a>. S2S Flow ...................................................<a href="#page-6">6</a>
      <a href="#section-4.2">4.2</a>. A Simple S2S Scenario .....................................<a href="#page-10">10</a>
      <a href="#section-4.3">4.3</a>. No Mutual PKIX Authentication .............................<a href="#page-12">12</a>
      <a href="#section-4.4">4.4</a>. Piggybacking ..............................................<a href="#page-13">13</a>
           <a href="#section-4.4.1">4.4.1</a>. Assertion ..........................................<a href="#page-13">13</a>
           <a href="#section-4.4.2">4.4.2</a>. Supposition ........................................<a href="#page-15">15</a>
   <a href="#section-5">5</a>. Alternative Prooftypes .........................................<a href="#page-16">16</a>
      <a href="#section-5.1">5.1</a>. DANE ......................................................<a href="#page-16">16</a>
      <a href="#section-5.2">5.2</a>. POSH ......................................................<a href="#page-17">17</a>
   <a href="#section-6">6</a>. Secure Delegation and Multi-Tenancy ............................<a href="#page-18">18</a>
   <a href="#section-7">7</a>. Prooftype Model ................................................<a href="#page-18">18</a>
   <a href="#section-8">8</a>. Guidance for Server Operators ..................................<a href="#page-19">19</a>
   <a href="#section-9">9</a>. IANA Considerations ............................................<a href="#page-20">20</a>
      <a href="#section-9.1">9.1</a>. POSH Service Name for xmpp-client Service .................<a href="#page-20">20</a>
      <a href="#section-9.2">9.2</a>. POSH Service Name for xmpp-server Service .................<a href="#page-20">20</a>
   <a href="#section-10">10</a>. Security Considerations .......................................<a href="#page-20">20</a>
   <a href="#section-11">11</a>. References ....................................................<a href="#page-21">21</a>
      <a href="#section-11.1">11.1</a>. Normative References .....................................<a href="#page-21">21</a>
      <a href="#section-11.2">11.2</a>. Informative References ...................................<a href="#page-23">23</a>
   Acknowledgements ..................................................<a href="#page-24">24</a>
   Authors' Addresses ................................................<a href="#page-24">24</a>







<span class="grey">Saint-Andre, et al.          Standards Track                    [Page 2]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-3" id="page-3" name="page-3"> </a>
<span class="grey"><a href="rfc7712.html">RFC 7712</a>                        XMPP DNA                   November 2015</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/1.%20%20Introduction"></a><a class="selflink" href="#section-1" name="section-1">1</a>.  Introduction</span>

   In systems that use the Extensible Messaging and Presence Protocol
   (XMPP) [<a href="rfc6120.html" title='"Extensible Messaging and Presence Protocol (XMPP): Core"'>RFC6120</a>], it is important to establish a strong association
   between the DNS domain name of an XMPP service (e.g., example.com)
   and the XML stream that a client or peer server initiates with that
   service.  In other words, the client or peer server needs to verify
   the identity of the server to which it connects.  Additionally,
   servers need to verify incoming connections from other servers.

   To date, such verification has been established based on information
   obtained from the Domain Name System (DNS), the Public Key
   Infrastructure (PKI), or similar sources.  In particular, XMPP as
   defined in [<a href="rfc6120.html" title='"Extensible Messaging and Presence Protocol (XMPP): Core"'>RFC6120</a>] assumed that Domain Name Associations (DNA) are
   to be proved using the "PKIX prooftype"; that is, the server's proof
   consists of a PKIX certificate that is checked according to the XMPP
   profile of the matching rules from [<a href="rfc6125.html" title='"Representation and Verification of Domain-Based Application Service Identity within Internet Public Key Infrastructure Using X.509 (PKIX) Certificates in the Context of Transport Layer Security (TLS)"'>RFC6125</a>] (and the overall
   validation rules from [<a href="rfc5280.html" title='"Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile"'>RFC5280</a>]), the client's verification material
   is obtained out of band in the form of a trusted root, and secure DNS
   is not necessary.

   By extending the concept of a domain name association within XMPP,
   this document does the following:

   1.  Generalizes the model currently in use so that additional
       prooftypes can be defined if needed.

   2.  Provides a basis for modernizing some prooftypes to reflect
       progress in underlying technologies such as DNS Security
       [<a href="rfc4033.html" title='"DNS Security Introduction and Requirements"'>RFC4033</a>].

   3.  Describes the flow of operations for establishing a domain name
       association.

   This document also provides guidelines for secure delegation of a
   service domain name (e.g., example.com) to a target server hostname
   (e.g., hosting.example.net).  The need for secure delegation arises
   because the process for resolving the domain name of an XMPP service
   into the IP address at which an XML stream will be negotiated (see
   [<a href="rfc6120.html" title='"Extensible Messaging and Presence Protocol (XMPP): Core"'>RFC6120</a>]) can involve delegation of a service domain name to a
   target server hostname using technologies such as DNS SRV records
   [<a href="rfc2782.html" title='"A DNS RR for specifying the location of services (DNS SRV)"'>RFC2782</a>].  A more detailed description of the delegation problem can
   be found in [<a href="rfc7711.html" title='"PKIX over Secure HTTP (POSH)"'>RFC7711</a>].  The domain name association can be verified
   only if the delegation is done in a secure manner.







<span class="grey">Saint-Andre, et al.          Standards Track                    [Page 3]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-4" id="page-4" name="page-4"> </a>
<span class="grey"><a href="rfc7712.html">RFC 7712</a>                        XMPP DNA                   November 2015</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/2.%20%20Terminology"></a><a class="selflink" href="#section-2" name="section-2">2</a>.  Terminology</span>

   This document inherits XMPP terminology from [<a href="rfc6120.html" title='"Extensible Messaging and Presence Protocol (XMPP): Core"'>RFC6120</a>] and
   [<a href="#ref-XEP-0220" title='"Server Dialback"'>XEP-0220</a>]; DNS terminology from [<a href="rfc1034.html" title='"Domain names - concepts and facilities"'>RFC1034</a>], [<a href="rfc1035.html" title='"Domain names - implementation and specification"'>RFC1035</a>], [<a href="rfc2782.html" title='"A DNS RR for specifying the location of services (DNS SRV)"'>RFC2782</a>], and
   [<a href="rfc4033.html" title='"DNS Security Introduction and Requirements"'>RFC4033</a>]; and security terminology from [<a href="rfc4949.html" title='"Internet Security Glossary, Version 2"'>RFC4949</a>] and [<a href="rfc5280.html" title='"Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile"'>RFC5280</a>].
   The terms "reference identity" and "presented identity" are used as
   defined in the "CertID" specification [<a href="rfc6125.html" title='"Representation and Verification of Domain-Based Application Service Identity within Internet Public Key Infrastructure Using X.509 (PKIX) Certificates in the Context of Transport Layer Security (TLS)"'>RFC6125</a>].  For the sake of
   consistency with [<a href="rfc7673.html" title='"Using DNS-Based Authentication of Named Entities (DANE) TLSA Records with SRV Records"'>RFC7673</a>], this document uses the terms "service
   domain name" and "target server hostname" to refer to the same
   entities identified by the terms "source domain" and "derived domain"
   from [<a href="rfc6125.html" title='"Representation and Verification of Domain-Based Application Service Identity within Internet Public Key Infrastructure Using X.509 (PKIX) Certificates in the Context of Transport Layer Security (TLS)"'>RFC6125</a>].

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/3.%20%20Client-to-Server%20%28C2S%29%20DNA"></a><a class="selflink" href="#section-3" name="section-3">3</a>.  Client-to-Server (C2S) DNA</span>

   The client-to-server case is much simpler than the server-to-server
   case because the client does not assert a domain name; this means
   that verification happens in only one direction.  Therefore, we
   describe this case first to help the reader understand domain name
   associations in XMPP.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.1.%20%20C2S%20Flow"></a><a class="selflink" href="#section-3.1" name="section-3.1">3.1</a>.  C2S Flow</span>

   The following flow chart illustrates the protocol flow for
   establishing a domain name association for an XML stream from a
   client (C) to a server (S) using the standard PKIX prooftype
   specified in [<a href="rfc6120.html" title='"Extensible Messaging and Presence Protocol (XMPP): Core"'>RFC6120</a>].

                           |
                   DNS RESOLUTION ETC.
                           |
   +-----------------STREAM HEADERS---------------------+
   |                                                    |
   |  C: &lt;stream to='a.example'&gt;                        |
   |                                                    |
   |  S: &lt;stream from='a.example'&gt;                      |
   |                                                    |
   +----------------------------------------------------+
                           |
   +-----------------TLS NEGOTIATION--------------------+
   |                                                    |
   |  S: Server Certificate                             |
   |                                                    |
   +----------------------------------------------------+
                           |
             (client checks certificate and
              establishes DNA for a.example)





<span class="grey">Saint-Andre, et al.          Standards Track                    [Page 4]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-5" id="page-5" name="page-5"> </a>
<span class="grey"><a href="rfc7712.html">RFC 7712</a>                        XMPP DNA                   November 2015</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.2.%20%20C2S%20Description"></a><a class="selflink" href="#section-3.2" name="section-3.2">3.2</a>.  C2S Description</span>

   The simplified order of events (see [<a href="rfc6120.html" title='"Extensible Messaging and Presence Protocol (XMPP): Core"'>RFC6120</a>] for details) in
   establishing an XML stream from a client (user@a.example) to a server
   (a.example) is as follows:

   1.  The client resolves via DNS the service
       _xmpp-client._tcp.a.example.

   2.  The client opens a TCP connection to the resolved IP address.

   3.  The client sends an initial stream header to the server:

       &lt;stream:stream to='a.example'&gt;

   4.  The server sends a response stream header to the client,
       asserting that it is a.example:

       &lt;stream:stream from='a.example'&gt;

   5.  The parties attempt TLS negotiation, during which the XMPP server
       (acting as a TLS server) presents a PKIX certificate proving that
       it is a.example.

   6.  The client checks the PKIX certificate that the server provided;
       if the proof is consistent with the XMPP profile of the matching
       rules from [<a href="rfc6125.html" title='"Representation and Verification of Domain-Based Application Service Identity within Internet Public Key Infrastructure Using X.509 (PKIX) Certificates in the Context of Transport Layer Security (TLS)"'>RFC6125</a>] and the certificate is otherwise valid
       according to [<a href="rfc5280.html" title='"Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile"'>RFC5280</a>], the client accepts that there is a strong
       domain name association between its stream to the target server
       and the DNS domain name of the XMPP service.

   The certificate that the server presents might not be acceptable to
   the client.  As one example, the server might be hosting multiple
   domains and secure delegation as described in <a href="#section-6">Section 6</a> is necessary.
   As another example, the server might present a self-signed
   certificate, which requires the client to either (1) apply the
   fallback process described in <a href="rfc6125.html#section-6.6.4">Section 6.6.4 of [RFC6125]</a> or
   (2) prompt the user to accept an unauthenticated connection as
   described in <a href="rfc7590.html#section-3.4">Section 3.4 of [RFC7590]</a>.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/4.%20%20Server-to-Server%20%28S2S%29%20DNA"></a><a class="selflink" href="#section-4" name="section-4">4</a>.  Server-to-Server (S2S) DNA</span>

   The server-to-server case is significantly more complex than the
   client-to-server case, and it involves the checking of domain name
   associations in both directions along with other "wrinkles"
   described in the following sections.  In some parts of the flow,
   server-to-server communications use the Server Dialback protocol
   first specified in (the now obsolete) [<a href="rfc3920.html" title='"Extensible Messaging and Presence Protocol (XMPP): Core"'>RFC3920</a>] and since moved to



<span class="grey">Saint-Andre, et al.          Standards Track                    [Page 5]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-6" id="page-6" name="page-6"> </a>
<span class="grey"><a href="rfc7712.html">RFC 7712</a>                        XMPP DNA                   November 2015</span>


   [<a href="#ref-XEP-0220" title='"Server Dialback"'>XEP-0220</a>].  See "Impact of TLS and DNSSEC on Dialback" [<a href="#ref-XEP-0344" title='"Impact of TLS and DNSSEC on Dialback"'>XEP-0344</a>]
   for considerations when using it together with TLS and DNSSEC.  Also,
   "Bidirectional Server-to-Server Connections" [<a href="#ref-XEP-0288" title='"Bidirectional Server-to-Server Connections"'>XEP-0288</a>] provides a
   way to use the server-to-server connections for bidirectional
   exchange of XML stanzas, which reduces the complexity of some of the
   processes involved.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.1.%20%20S2S%20Flow"></a><a class="selflink" href="#section-4.1" name="section-4.1">4.1</a>.  S2S Flow</span>

   The following flow charts illustrate the protocol flow for
   establishing domain name associations between Server 1 (the
   initiating entity) and Server 2 (the receiving entity), as described
   in the remaining sections of this document.

   A simple S2S scenario would be as follows:

                       |
                DNS RESOLUTION ETC.
                       |
   +-------------STREAM HEADERS--------------------+
   |                                               |
   |  A: &lt;stream from='a.example' to='b.example'&gt;  |
   |                                               |
   |  B: &lt;stream from='b.example' to='a.example'&gt;  |
   |                                               |
   +-----------------------------------------------+
                       |
   +-------------TLS NEGOTIATION-------------------+
   |                                               |
   |  B: Server Certificate                        |
   |  B: Certificate Request                       |
   |  A: Client Certificate                        |
   |                                               |
   +-----------------------------------------------+
                       |
       (A establishes DNA for b.example)
                       |














<span class="grey">Saint-Andre, et al.          Standards Track                    [Page 6]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-7" id="page-7" name="page-7"> </a>
<span class="grey"><a href="rfc7712.html">RFC 7712</a>                        XMPP DNA                   November 2015</span>


   After the domain name association has been established in one
   direction, it is possible to perform mutual authentication using the
   Simple Authentication and Security Layer (SASL) [<a href="rfc4422.html" title='"Simple Authentication and Security Layer (SASL)"'>RFC4422</a>] and thus
   establish domain name associations in both directions.

                       |
   +-------------AUTHENTICATION--------------------+
   |                   |                           |
   |       {valid client certificate?} --+         |
   |                   |                 |         |
   |                   | yes         no  |         |
   |                   v                 |         |
   |             SASL EXTERNAL           |         |
   |             (mutual auth)           |         |
   |   (B establishes DNA for a.example) |         |
   +-------------------------------------|---------+
                                         |

   However, if mutual authentication cannot be completed using SASL, the
   receiving server needs to establish a domain name association in
   another way.  This scenario is described in <a href="#section-4.3">Section 4.3</a>.

                                         |
                       +-----------------+
                       |
           (<a href="#section-4.3">Section 4.3</a>: No Mutual PKIX Authentication)
                       |
                       | B needs to establish DNA
                       | for this stream from a.example,
                       | so A asserts its identity
                       |
   +----------DIALBACK IDENTITY ASSERTION----------+
   |                                               |
   |  A: &lt;db:result from='a.example'               |
   |                to='b.example'&gt;                |
   |       some-dialback-key                       |
   |     &lt;/db:result&gt;                              |
   |                                               |
   +-----------------------------------------------+
                       |











<span class="grey">Saint-Andre, et al.          Standards Track                    [Page 7]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-8" id="page-8" name="page-8"> </a>
<span class="grey"><a href="rfc7712.html">RFC 7712</a>                        XMPP DNA                   November 2015</span>


                DNS RESOLUTION ETC.
                       |
   +-------------STREAM HEADERS--------------------+
   |                                               |
   |  B: &lt;stream from='b.example' to='a.example'&gt;  |
   |                                               |
   |  A: &lt;stream from='a.example' to='b.example'&gt;  |
   |                                               |
   +-----------------------------------------------+
                       |
   +-------------TLS NEGOTIATION-------------------+
   |                                               |
   |  A: Server Certificate                        |
   |                                               |
   +-----------------------------------------------+
                       |
   +----------DIALBACK IDENTITY VERIFICATION-------+
   |                                               |
   |  B: &lt;db:verify from='b.example'               |
   |                to='a.example'                 |
   |                id='...'&gt;                      |
   |       some-dialback-key                       |
   |     &lt;/db:verify&gt;                              |
   |                                               |
   |  A: &lt;db:verify from='a.example'               |
   |                to='b.example'                 |
   |                type='valid'                   |
   |                id='...'&gt;                      |
   |                                               |
   +-----------------------------------------------+
                       |
       (B establishes DNA for a.example)
                       |

   If one of the servers hosts additional service names (e.g., Server 2
   might host c.example in addition to b.example and Server 1 might host
   rooms.a.example in addition to a.example), then the servers can use
   Server Dialback "piggybacking" to establish additional domain name
   associations for the stream, as described in <a href="#section-4.4">Section 4.4</a>.












<span class="grey">Saint-Andre, et al.          Standards Track                    [Page 8]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-9" id="page-9" name="page-9"> </a>
<span class="grey"><a href="rfc7712.html">RFC 7712</a>                        XMPP DNA                   November 2015</span>


   There are two varieties of piggybacking.  The first is here called
   "assertion".

                       |
         (<a href="#section-4.4.1">Section 4.4.1</a>: Piggybacking Assertion)
                       |
   +----------DIALBACK IDENTITY ASSERTION----------+
   |                                               |
   |  B: &lt;db:result from='c.example'               |
   |                to='a.example'/&gt;               |
   |                                               |
   +-----------------------------------------------+
                       |
   +-------DNA ESTABLISHMENT AS ABOVE--------------+
   |                                               |
   |    DNS RESOLUTION, STREAM HEADERS,            |
   |    TLS NEGOTIATION, AUTHENTICATION            |
   |                                               |
   +-----------------------------------------------+
                       |
   +----------DIALBACK IDENTITY VERIFICATION-------+
   |                                               |
   |  A: &lt;db:result from='a.example'               |
   |                to='c.example'                 |
   |                type='valid'/&gt;                 |
   |                                               |
   +-----------------------------------------------+
                       |























<span class="grey">Saint-Andre, et al.          Standards Track                    [Page 9]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-10" id="page-10" name="page-10"> </a>
<span class="grey"><a href="rfc7712.html">RFC 7712</a>                        XMPP DNA                   November 2015</span>


   The second variety of piggybacking is here called "supposition".

                       |
         (<a href="#section-4.4.2">Section 4.4.2</a>: Piggybacking Supposition)
                       |
   +-----------SUBSEQUENT CONNECTION---------------+
   |                                               |
   |  B: &lt;stream from='c.example'                  |
   |             to='rooms.a.example'&gt;             |
   |                                               |
   |  A: &lt;stream from='rooms.a.example'            |
   |             to='c.example'&gt;                   |
   |                                               |
   +-----------------------------------------------+
                       |
   +-------DNA ESTABLISHMENT AS ABOVE--------------+
   |                                               |
   |    DNS RESOLUTION, STREAM HEADERS,            |
   |    TLS NEGOTIATION, AUTHENTICATION            |
   |                                               |
   +-----------------------------------------------+
                       |
   +-----------DIALBACK OPTIMIZATION---------------+
   |                                               |
   |  B: &lt;db:result from='c.example'               |
   |                to='rooms.a.example'/&gt;         |
   |                                               |
   |  B: &lt;db:result from='rooms.a.example'         |
   |                to='c.example'                 |
   |                type='valid'/&gt;                 |
   |                                               |
   +-----------------------------------------------+

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.2.%20%20A%20Simple%20S2S%20Scenario"></a><a class="selflink" href="#section-4.2" name="section-4.2">4.2</a>.  A Simple S2S Scenario</span>

   To illustrate the problem, consider the simplified order of events
   (see [<a href="rfc6120.html" title='"Extensible Messaging and Presence Protocol (XMPP): Core"'>RFC6120</a>] for details) in establishing an XML stream between
   Server 1 (a.example) and Server 2 (b.example):

   1.  Server 1 resolves via DNS the service
       _xmpp-server._tcp.b.example.

   2.  Server 1 opens a TCP connection to the resolved IP address.

   3.  Server 1 sends an initial stream header to Server 2, asserting
       that it is a.example:

       &lt;stream:stream from='a.example' to='b.example'&gt;



<span class="grey">Saint-Andre, et al.          Standards Track                   [Page 10]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-11" id="page-11" name="page-11"> </a>
<span class="grey"><a href="rfc7712.html">RFC 7712</a>                        XMPP DNA                   November 2015</span>


   4.  Server 2 sends a response stream header to Server 1, asserting
       that it is b.example:

       &lt;stream:stream from='b.example' to='a.example'&gt;

   5.  The servers attempt TLS negotiation, during which Server 2
       (acting as a TLS server) presents a PKIX certificate proving that
       it is b.example and Server 1 (acting as a TLS client) presents a
       PKIX certificate proving that it is a.example.

   6.  Server 1 checks the PKIX certificate that Server 2 provided, and
       Server 2 checks the PKIX certificate that Server 1 provided; if
       these proofs are consistent with the XMPP profile of the matching
       rules from [<a href="rfc6125.html" title='"Representation and Verification of Domain-Based Application Service Identity within Internet Public Key Infrastructure Using X.509 (PKIX) Certificates in the Context of Transport Layer Security (TLS)"'>RFC6125</a>] and are otherwise valid according to
       [<a href="rfc5280.html" title='"Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile"'>RFC5280</a>], each server accepts that there is a strong domain name
       association between its stream to the other party and the DNS
       domain name of the other party (i.e., mutual authentication is
       achieved).

   Several simplifying assumptions underlie the "happy path" scenario
   just outlined:

   o  The PKIX certificate presented by Server 2 during TLS negotiation
      is acceptable to Server 1 and matches the expected identity.

   o  The PKIX certificate presented by Server 1 during TLS negotiation
      is acceptable to Server 2; this enables the parties to complete
      mutual authentication.

   o  There are no additional domains associated with Server 1 and
      Server 2 (say, a sub-domain rooms.a.example on Server 1 or a
      second domain c.example on Server 2).

   o  The server administrators are able to obtain PKIX certificates
      issued by a widely accepted Certification Authority (CA) in the
      first place.

   o  The server administrators are running their own XMPP servers,
      rather than using hosting services.

   Let's consider each of these "wrinkles" in turn.










<span class="grey">Saint-Andre, et al.          Standards Track                   [Page 11]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-12" id="page-12" name="page-12"> </a>
<span class="grey"><a href="rfc7712.html">RFC 7712</a>                        XMPP DNA                   November 2015</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.3.%20%20No%20Mutual%20PKIX%20Authentication"></a><a class="selflink" href="#section-4.3" name="section-4.3">4.3</a>.  No Mutual PKIX Authentication</span>

   If the PKIX certificate presented by Server 1 during TLS negotiation
   is not acceptable to Server 2, Server 2 is unable to mutually
   authenticate Server 1.  Therefore, Server 2 needs to verify the
   asserted identity of Server 1 by other means.

   1.  Server 1 asserts that it is a.example using the Server Dialback
       protocol:

       &lt;db:result from='a.example' to='b.example'&gt;
                  some-dialback-key&lt;/db:result&gt;

   2.  Server 2 resolves via DNS the service
       _xmpp-server._tcp.a.example.

   3.  Server 2 opens a TCP connection to the resolved IP address.

   4.  Server 2 sends an initial stream header to Server 1, asserting
       that it is b.example:

       &lt;stream:stream from='b.example' to='a.example'&gt;

   5.  Server 1 sends a response stream header to Server 2, asserting
       that it is a.example:

       &lt;stream:stream from='a.example' to='b.example'&gt;

   6.  The servers attempt TLS negotiation, during which Server 1
       (acting as a TLS server) presents a PKIX certificate.

   7.  Server 2 checks the PKIX certificate that Server 1 provided (this
       might be the same certificate presented by Server 1 as a client
       certificate in the initial connection).  However, Server 2 does
       not accept this certificate as proving that Server 1 is
       authorized as a.example and therefore uses another method (here,
       the Server Dialback protocol) to establish the domain name
       association.













<span class="grey">Saint-Andre, et al.          Standards Track                   [Page 12]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-13" id="page-13" name="page-13"> </a>
<span class="grey"><a href="rfc7712.html">RFC 7712</a>                        XMPP DNA                   November 2015</span>


   8.  Server 2 proceeds with Server Dialback in order to establish the
       domain name association.  In order to do this, it sends a request
       for verification as described in [<a href="#ref-XEP-0220" title='"Server Dialback"'>XEP-0220</a>]:

       &lt;db:verify from='b.example' to='a.example'
                  id='...'&gt;some-dialback-key&lt;/db:verify&gt;

   9.  Server 1 responds to this:

       &lt;db:verify from='a.example' to='b.example' id='...' type='valid/&gt;

       allowing Server 2 to establish the domain name association.

   In some situations (e.g., if the Authoritative Server in Server
   Dialback presents the same certificate as the Originating Server), it
   is the practice of some XMPP server implementations to skip steps 8
   and 9.  These situations are discussed in "Impact of TLS and DNSSEC
   on Dialback" [<a href="#ref-XEP-0344" title='"Impact of TLS and DNSSEC on Dialback"'>XEP-0344</a>].

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.4.%20%20Piggybacking"></a><a class="selflink" href="#section-4.4" name="section-4.4">4.4</a>.  Piggybacking</span>

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/4.4.1.%20%20Assertion"></a><a class="selflink" href="#section-4.4.1" name="section-4.4.1">4.4.1</a>.  Assertion</span>

   Consider the common scenario in which Server 2 hosts not only
   b.example but also a second domain c.example (often called a
   "multi-tenanted" environment).  If a user of Server 2 associated with
   c.example wishes to communicate with a friend at a.example, Server 2
   needs to send XMPP stanzas from the domain c.example rather than
   b.example.  Although Server 2 could open a new TCP connection and
   negotiate new XML streams for the domain pair of c.example and
   a.example, that is wasteful (especially if Server 2 hosts a large
   number of domains).  Server 2 already has a connection to a.example,
   so how can it assert that it would like to add a new domain pair to
   the existing connection?

   The traditional method for doing so is the Server Dialback protocol
   [<a href="#ref-XEP-0220" title='"Server Dialback"'>XEP-0220</a>].  Here, Server 2 can send a &lt;db:result/&gt; element for the
   new domain pair over the existing stream.

       &lt;db:result from='c.example' to='a.example'&gt;
         some-dialback-key
       &lt;/db:result&gt;

   This &lt;db:result/&gt; element functions as Server 2's assertion that it
   is (also) c.example (thus, the element is functionally equivalent to
   the 'from' address of an initial stream header as previously
   described).




<span class="grey">Saint-Andre, et al.          Standards Track                   [Page 13]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-14" id="page-14" name="page-14"> </a>
<span class="grey"><a href="rfc7712.html">RFC 7712</a>                        XMPP DNA                   November 2015</span>


   In response to this assertion, Server 1 needs to obtain some kind of
   proof that Server 2 really is also c.example.  If the certificate
   presented by Server 2 is also valid for c.example, then no further
   action is necessary.  However, if not, then Server 1 needs to do a
   bit more work.  Specifically, Server 1 can pursue the same strategy
   it used before:

   1.  Server 1 resolves via DNS the service
       _xmpp-server._tcp.c.example.

   2.  Server 1 opens a TCP connection to the resolved IP address (which
       might be the same IP address as for b.example).

   3.  Server 1 sends an initial stream header to Server 2, asserting
       that it is a.example:

       &lt;stream:stream from='a.example' to='c.example'&gt;

   4.  Server 2 sends a response stream header to Server 1, asserting
       that it is c.example:

       &lt;stream:stream from='c.example' to='a.example'&gt;

   5.  The servers attempt TLS negotiation, during which Server 2
       (acting as a TLS server) presents a PKIX certificate proving that
       it is c.example.

   6.  At this point, Server 1 needs to establish that, despite
       different certificates, c.example is associated with the origin
       of the request.  This is done using Server Dialback [<a href="#ref-XEP-0220" title='"Server Dialback"'>XEP-0220</a>]:

       &lt;db:verify from='a.example' to='c.example'
                  id='...'&gt;some-dialback-key&lt;/db:verify&gt;

   7.  Server 2 responds to this:

       &lt;db:verify from='c.example' to='a.example' id='...' type='valid/&gt;

       allowing Server 1 to establish the domain name association.

   Now that Server 1 accepts the domain name association, it informs
   Server 2 of that fact:

       &lt;db:result from='a.example' to='c.example' type='valid'/&gt;







<span class="grey">Saint-Andre, et al.          Standards Track                   [Page 14]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-15" id="page-15" name="page-15"> </a>
<span class="grey"><a href="rfc7712.html">RFC 7712</a>                        XMPP DNA                   November 2015</span>


   The parties can then terminate the second connection, because it was
   used only for Server 1 to associate a stream with the domain name
   c.example (the dialback key links the original stream to the new
   association).

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/4.4.2.%20%20Supposition"></a><a class="selflink" href="#section-4.4.2" name="section-4.4.2">4.4.2</a>.  Supposition</span>

   Piggybacking can also occur in the other direction.  Consider the
   common scenario in which Server 1 provides XMPP services not only for
   a.example but also for a sub-domain such as a Multi-User Chat
   [<a href="#ref-XEP-0045" title='"Multi-User Chat"'>XEP-0045</a>] service at rooms.a.example.  If a user from c.example at
   Server 2 wishes to join a room on the groupchat service, Server 2
   needs to send XMPP stanzas from the domain c.example to the domain
   rooms.a.example rather than a.example.

   First, Server 2 needs to determine whether it can piggyback the
   domain rooms.a.example on the connection to a.example:

   1.  Server 2 resolves via DNS the service
       _xmpp-server._tcp.rooms.a.example.

   2.  Server 2 determines that this resolves to an IP address and port
       to which it is already connected.

   3.  Server 2 determines that the PKIX certificate for that active
       connection would also be valid for the rooms.a.example domain and
       that Server 1 has announced support for dialback errors.

   Server 2 sends a dialback key to Server 1 over the existing
   connection:

       &lt;db:result from='c.example' to='rooms.a.example'&gt;
         some-dialback-key
       &lt;/db:result&gt;

   Server 1 then informs Server 2 that it accepts the domain name
   association:

       &lt;db:result from='rooms.a.example' to='c.example' type='valid'/&gt;












<span class="grey">Saint-Andre, et al.          Standards Track                   [Page 15]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-16" id="page-16" name="page-16"> </a>
<span class="grey"><a href="rfc7712.html">RFC 7712</a>                        XMPP DNA                   November 2015</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/5.%20%20Alternative%20Prooftypes"></a><a class="selflink" href="#section-5" name="section-5">5</a>.  Alternative Prooftypes</span>

   The foregoing protocol flows assumed that domain name associations
   were proved using the PKIX prooftype.  However, sometimes XMPP server
   administrators are unable or unwilling to obtain valid PKIX
   certificates for all of the domains they host at their servers.
   For example:

   o  In order to issue a PKIX certificate, a CA might try to send email
      messages to authoritative mailbox names [<a href="rfc2142.html" title='"Mailbox Names for Common Services, Roles and Functions"'>RFC2142</a>], but the
      administrator of a subsidiary service such as im.cs.podunk.example
      cannot receive email sent to hostmaster@podunk.example.

   o  A hosting provider such as hosting.example.net might not want to
      take on the liability of holding the certificate and private key
      for a tenant such as example.com (or the tenant might not want the
      hosting provider to hold its certificate and private key).

   o  Even if PKIX certificates for each tenant can be obtained, the
      management of so many certificates can introduce a large
      administrative load.

   (Additional discussion can be found in [<a href="rfc7711.html" title='"PKIX over Secure HTTP (POSH)"'>RFC7711</a>].)

   In these circumstances, prooftypes other than PKIX are desirable or
   necessary.  As described below, two alternatives have been defined so
   far: DNS-Based Authentication of Named Entities (DANE) and PKIX over
   Secure HTTP (POSH).

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.1.%20%20DANE"></a><a class="selflink" href="#section-5.1" name="section-5.1">5.1</a>.  DANE</span>

   The DANE prooftype is defined as follows:

   1.  The server's proof consists of either a service certificate or
       domain-issued certificate (TLSA usage PKIX-EE or DANE-EE; see
       [<a href="rfc6698.html" title='"The DNS-Based Authentication of Named Entities (DANE) Transport Layer Security (TLS) Protocol: TLSA"'>RFC6698</a>] and [<a href="rfc7218.html" title='"Adding Acronyms to Simplify Conversations about DNS-Based Authentication of Named Entities (DANE)"'>RFC7218</a>]).

   2.  The proof is checked by verifying an exact match or a hash of
       either the SubjectPublicKeyInfo or the full certificate.

   3.  The client's verification material is obtained via secure DNS
       [<a href="rfc4033.html" title='"DNS Security Introduction and Requirements"'>RFC4033</a>] as described in [<a href="rfc7673.html" title='"Using DNS-Based Authentication of Named Entities (DANE) TLSA Records with SRV Records"'>RFC7673</a>].

   4.  Secure DNS is necessary in order to effectively establish an
       alternative chain of trust from the service certificate or
       domain-issued certificate to the DNS root.





<span class="grey">Saint-Andre, et al.          Standards Track                   [Page 16]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-17" id="page-17" name="page-17"> </a>
<span class="grey"><a href="rfc7712.html">RFC 7712</a>                        XMPP DNA                   November 2015</span>


   The DANE prooftype makes use of DNS-Based Authentication of Named
   Entities [<a href="rfc6698.html" title='"The DNS-Based Authentication of Named Entities (DANE) Transport Layer Security (TLS) Protocol: TLSA"'>RFC6698</a>], specifically the use of DANE with DNS SRV records
   [<a href="rfc7673.html" title='"Using DNS-Based Authentication of Named Entities (DANE) TLSA Records with SRV Records"'>RFC7673</a>].  For XMPP purposes, the following rules apply:

   o  If there is no SRV resource record, pursue the fallback methods
      described in [<a href="rfc6120.html" title='"Extensible Messaging and Presence Protocol (XMPP): Core"'>RFC6120</a>].

   o  Use the 'to' address of the initial stream header to determine the
      domain name of the TLS client's reference identifier (because the
      use of the Server Name Indication extension (TLS SNI) [<a href="rfc6066.html" title='"Transport Layer Security (TLS) Extensions: Extension Definitions"'>RFC6066</a>] is
      purely discretionary in XMPP, as mentioned in [<a href="rfc6120.html" title='"Extensible Messaging and Presence Protocol (XMPP): Core"'>RFC6120</a>]).

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.2.%20%20POSH"></a><a class="selflink" href="#section-5.2" name="section-5.2">5.2</a>.  POSH</span>

   The POSH prooftype is defined as follows:

   1.  The server's proof consists of a PKIX certificate.

   2.  The proof is checked according to the rules from [<a href="rfc6120.html" title='"Extensible Messaging and Presence Protocol (XMPP): Core"'>RFC6120</a>] and
       [<a href="rfc6125.html" title='"Representation and Verification of Domain-Based Application Service Identity within Internet Public Key Infrastructure Using X.509 (PKIX) Certificates in the Context of Transport Layer Security (TLS)"'>RFC6125</a>].

   3.  The client's verification material is obtained by retrieving a
       hash of the PKIX certificate over HTTPS at a well-known URI
       [<a href="rfc5785.html" title='"Defining Well-Known Uniform Resource Identifiers (URIs)"'>RFC5785</a>].

   4.  Secure DNS is not necessary, because the HTTPS retrieval
       mechanism relies on the chain of trust from the public key
       infrastructure.

   POSH is defined in [<a href="rfc7711.html" title='"PKIX over Secure HTTP (POSH)"'>RFC7711</a>].  For XMPP purposes, the following rules
   apply:

   o  If no verification material is found via POSH, pursue the fallback
      methods described in [<a href="rfc6120.html" title='"Extensible Messaging and Presence Protocol (XMPP): Core"'>RFC6120</a>].

   o  Use the 'to' address of the initial stream header to determine the
      domain name of the TLS client's reference identifier (because the
      use of TLS SNI [<a href="rfc6066.html" title='"Transport Layer Security (TLS) Extensions: Extension Definitions"'>RFC6066</a>] is purely discretionary in XMPP, as
      mentioned in [<a href="rfc6120.html" title='"Extensible Messaging and Presence Protocol (XMPP): Core"'>RFC6120</a>]).

   The well-known URIs [<a href="rfc5785.html" title='"Defining Well-Known Uniform Resource Identifiers (URIs)"'>RFC5785</a>] to be used for POSH are:

   o  "/.well-known/posh/xmpp-client.json" for client-to-server
      connections

   o  "/.well-known/posh/xmpp-server.json" for server-to-server
      connections




<span class="grey">Saint-Andre, et al.          Standards Track                   [Page 17]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-18" id="page-18" name="page-18"> </a>
<span class="grey"><a href="rfc7712.html">RFC 7712</a>                        XMPP DNA                   November 2015</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/6.%20%20Secure%20Delegation%20and%20Multi-Tenancy"></a><a class="selflink" href="#section-6" name="section-6">6</a>.  Secure Delegation and Multi-Tenancy</span>

   One common method for deploying XMPP services is multi-tenancy: e.g.,
   XMPP services for the service domain name example.com are actually
   hosted at the target server hosting.example.net.  Such an arrangement
   is relatively convenient in XMPP given the use of DNS SRV records
   [<a href="rfc2782.html" title='"A DNS RR for specifying the location of services (DNS SRV)"'>RFC2782</a>], such as the following delegation from example.com to
   hosting.example.net:

   _xmpp-server._tcp.example.com. 0 IN SRV 0 0 5269 hosting.example.net

   Secure connections with multi-tenancy can work using the PKIX
   prooftype on a small scale if the provider itself wishes to host
   several domains (e.g., related domains such as jabber-de.example and
   jabber-ch.example).  However, in practice the security of
   multi-tenancy has been found to be unwieldy when the provider hosts
   large numbers of XMPP services on behalf of multiple tenants (see
   [<a href="rfc7711.html" title='"PKIX over Secure HTTP (POSH)"'>RFC7711</a>] for a detailed description).  There are two possible
   results: either (1) server-to-server communications to example.com
   are unencrypted or (2) the communications are TLS-encrypted but the
   certificates are not checked (which is functionally equivalent to a
   connection using an anonymous key exchange).  This is also true of
   client-to-server communications, forcing end users to override
   certificate warnings or configure their clients to accept or "pin"
   certificates for hosting.example.net instead of example.com.  The
   fundamental problem here is that if DNSSEC is not used, then the act
   of delegation via DNS SRV records is inherently insecure.

   The specification for the use of SRV records with DANE [<a href="rfc7673.html" title='"Using DNS-Based Authentication of Named Entities (DANE) TLSA Records with SRV Records"'>RFC7673</a>]
   explains how to use DNSSEC for secure delegation with the DANE
   prooftype, and the POSH specification [<a href="rfc7711.html" title='"PKIX over Secure HTTP (POSH)"'>RFC7711</a>] explains how to use
   HTTPS redirects for secure delegation with the POSH prooftype.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/7.%20%20Prooftype%20Model"></a><a class="selflink" href="#section-7" name="section-7">7</a>.  Prooftype Model</span>

   In general, a Domain Name Association (DNA) prooftype conforms to the
   following definition:

   prooftype:  A mechanism for proving an association between a domain
      name and an XML stream, where the mechanism defines (1) the nature
      of the server's proof, (2) the matching rules for comparing the
      client's verification material against the server's proof, (3) how
      the client obtains its verification material, and (4) whether or
      not the mechanism depends on secure DNS.

   The PKIX, DANE, and POSH prooftypes adhere to this model.  (Some
   prooftypes depend on, or are enhanced by, secure DNS [<a href="rfc4033.html" title='"DNS Security Introduction and Requirements"'>RFC4033</a>] and
   thus also need to describe how they ensure secure delegation.)



<span class="grey">Saint-Andre, et al.          Standards Track                   [Page 18]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-19" id="page-19" name="page-19"> </a>
<span class="grey"><a href="rfc7712.html">RFC 7712</a>                        XMPP DNA                   November 2015</span>


   Other prooftypes are possible; examples might include TLS with Pretty
   Good Privacy (PGP) keys [<a href="rfc6091.html" title='"Using OpenPGP Keys for Transport Layer Security (TLS) Authentication"'>RFC6091</a>], a token mechanism such as Kerberos
   [<a href="rfc4120.html" title='"The Kerberos Network Authentication Service (V5)"'>RFC4120</a>] or OAuth [<a href="rfc6749.html" title='"The OAuth 2.0 Authorization Framework"'>RFC6749</a>], and Server Dialback keys [<a href="#ref-XEP-0220" title='"Server Dialback"'>XEP-0220</a>].

   Although the PKIX prooftype reuses the syntax of the XMPP Server
   Dialback protocol [<a href="#ref-XEP-0220" title='"Server Dialback"'>XEP-0220</a>] for signaling between servers, this
   framework document does not define how the generation and validation
   of Server Dialback keys (also specified in [<a href="#ref-XEP-0220" title='"Server Dialback"'>XEP-0220</a>]) constitute a
   DNA prooftype.  However, nothing in this document prevents the
   continued use of Server Dialback for signaling, and a future
   specification (or an updated version of [<a href="#ref-XEP-0220" title='"Server Dialback"'>XEP-0220</a>]) might define a
   DNA prooftype for Server Dialback keys in a way that is consistent
   with this framework.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/8.%20%20Guidance%20for%20Server%20Operators"></a><a class="selflink" href="#section-8" name="section-8">8</a>.  Guidance for Server Operators</span>

   This document introduces the concept of a prooftype in order to
   explain and generalize the approach to establishing a strong
   association between the DNS domain name of an XMPP service and the
   XML stream that a client or peer server initiates with that service.

   The operations and management implications of DNA prooftypes will
   depend on the particular prooftypes that an operator supports.
   For example:

   o  To support the PKIX prooftype [<a href="rfc6120.html" title='"Extensible Messaging and Presence Protocol (XMPP): Core"'>RFC6120</a>], an operator needs to
      obtain certificates for the XMPP server from a Certification
      Authority (CA).  However, DNS Security is not required.

   o  To support the DANE prooftype [<a href="rfc7673.html" title='"Using DNS-Based Authentication of Named Entities (DANE) TLSA Records with SRV Records"'>RFC7673</a>], an operator can generate
      its own certificates for the XMPP server or obtain them from a CA.
      In addition, DNS Security is required.

   o  To support the POSH prooftype [<a href="rfc7711.html" title='"PKIX over Secure HTTP (POSH)"'>RFC7711</a>], an operator can generate
      its own certificates for the XMPP server or obtain them from a CA,
      but in addition needs to deploy the web server for POSH files with
      certificates obtained from a CA.  However, DNS Security is not
      required.

   Considerations for the use of the foregoing prooftypes are explained
   in the relevant specifications.  See in particular <a href="rfc6120.html#section-13.7">Section 13.7 of
   [RFC6120]</a>, <a href="rfc7673.html#section-6">Section 6 of [RFC7673]</a>, and <a href="rfc7711.html#section-7">Section 7 of [RFC7711]</a>.

   Naturally, these operations and management considerations are
   additive: if an operator wishes to use multiple prooftypes, the
   complexity of deployment increases (e.g., the operator might want to
   obtain a PKIX certificate from a CA for use in the PKIX prooftype and
   generate its own certificate for use in the DANE prooftype).  This is



<span class="grey">Saint-Andre, et al.          Standards Track                   [Page 19]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-20" id="page-20" name="page-20"> </a>
<span class="grey"><a href="rfc7712.html">RFC 7712</a>                        XMPP DNA                   November 2015</span>


   an unavoidable aspect of supporting as many prooftypes as needed in
   order to ensure that domain name associations can be established in
   the largest possible percentage of cases.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/9.%20%20IANA%20Considerations"></a><a class="selflink" href="#section-9" name="section-9">9</a>.  IANA Considerations</span>

   The POSH specification [<a href="rfc7711.html" title='"PKIX over Secure HTTP (POSH)"'>RFC7711</a>] establishes the "POSH Service Names"
   registry for use in well-known URIs [<a href="rfc5785.html" title='"Defining Well-Known Uniform Resource Identifiers (URIs)"'>RFC5785</a>].  This specification
   registers two such service names for use in XMPP: "xmpp-client" and
   "xmpp-server".  The completed registration templates follow.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/9.1.%20%20POSH%20Service%20Name%20for%20xmpp-client%20Service"></a><a class="selflink" href="#section-9.1" name="section-9.1">9.1</a>.  POSH Service Name for xmpp-client Service</span>

   Service name: xmpp-client

   Change controller: IETF

   Definition and usage:  Specifies the location of a POSH file
      containing verification material or a reference thereto that
      enables a client to verify the identity of a server for a
      client-to-server stream in XMPP

   Specification: <a href="rfc7712.html">RFC 7712</a> (this document)

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/9.2.%20%20POSH%20Service%20Name%20for%20xmpp-server%20Service"></a><a class="selflink" href="#section-9.2" name="section-9.2">9.2</a>.  POSH Service Name for xmpp-server Service</span>

   Service name: xmpp-server

   Change controller: IETF

   Definition and usage:  Specifies the location of a POSH file
      containing verification material or a reference thereto that
      enables a server to verify the identity of a peer server for a
      server-to-server stream in XMPP

   Specification: <a href="rfc7712.html">RFC 7712</a> (this document)

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/10.%20%20Security%20Considerations"></a><a class="selflink" href="#section-10" name="section-10">10</a>.  Security Considerations</span>

   With regard to the PKIX prooftype, this document supplements but does
   not supersede the security considerations of [<a href="rfc6120.html" title='"Extensible Messaging and Presence Protocol (XMPP): Core"'>RFC6120</a>] and [<a href="rfc6125.html" title='"Representation and Verification of Domain-Based Application Service Identity within Internet Public Key Infrastructure Using X.509 (PKIX) Certificates in the Context of Transport Layer Security (TLS)"'>RFC6125</a>].

   With regard to the DANE and POSH prooftypes, the reader is referred
   to [<a href="rfc7673.html" title='"Using DNS-Based Authentication of Named Entities (DANE) TLSA Records with SRV Records"'>RFC7673</a>] and [<a href="rfc7711.html" title='"PKIX over Secure HTTP (POSH)"'>RFC7711</a>], respectively.

   Any future prooftypes need to thoroughly describe how they conform to
   the prooftype model specified in <a href="#section-7">Section 7</a> of this document.




<span class="grey">Saint-Andre, et al.          Standards Track                   [Page 20]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-21" id="page-21" name="page-21"> </a>
<span class="grey"><a href="rfc7712.html">RFC 7712</a>                        XMPP DNA                   November 2015</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/11.%20%20References"></a><a class="selflink" href="#section-11" name="section-11">11</a>.  References</span>

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/11.1.%20%20Normative%20References"></a><a class="selflink" href="#section-11.1" name="section-11.1">11.1</a>.  Normative References</span>

   [<a id="ref-RFC1034" name="ref-RFC1034">RFC1034</a>]   Mockapetris, P., "Domain names - concepts and
               facilities", STD 13, <a href="rfc1034.html">RFC 1034</a>, DOI 10.17487/RFC1034,
               November 1987, &lt;<a href="http://www.rfc-editor.org/info/rfc1034">http://www.rfc-editor.org/info/rfc1034</a>&gt;.

   [<a id="ref-RFC1035" name="ref-RFC1035">RFC1035</a>]   Mockapetris, P., "Domain names - implementation and
               specification", STD 13, <a href="rfc1035.html">RFC 1035</a>, DOI 10.17487/RFC1035,
               November 1987, &lt;<a href="http://www.rfc-editor.org/info/rfc1035">http://www.rfc-editor.org/info/rfc1035</a>&gt;.

   [<a id="ref-RFC2782" name="ref-RFC2782">RFC2782</a>]   Gulbrandsen, A., Vixie, P., and L. Esibov, "A DNS RR for
               specifying the location of services (DNS SRV)", <a href="rfc2782.html">RFC 2782</a>,
               DOI 10.17487/RFC2782, February 2000,
               &lt;<a href="http://www.rfc-editor.org/info/rfc2782">http://www.rfc-editor.org/info/rfc2782</a>&gt;.

   [<a id="ref-RFC4033" name="ref-RFC4033">RFC4033</a>]   Arends, R., Austein, R., Larson, M., Massey, D., and S.
               Rose, "DNS Security Introduction and Requirements",
               <a href="rfc4033.html">RFC 4033</a>, DOI 10.17487/RFC4033, March 2005,
               &lt;<a href="http://www.rfc-editor.org/info/rfc4033">http://www.rfc-editor.org/info/rfc4033</a>&gt;.

   [<a id="ref-RFC4422" name="ref-RFC4422">RFC4422</a>]   Melnikov, A., Ed., and K. Zeilenga, Ed., "Simple
               Authentication and Security Layer (SASL)", <a href="rfc4422.html">RFC 4422</a>,
               DOI 10.17487/RFC4422, June 2006,
               &lt;<a href="http://www.rfc-editor.org/info/rfc4422">http://www.rfc-editor.org/info/rfc4422</a>&gt;.

   [<a id="ref-RFC4949" name="ref-RFC4949">RFC4949</a>]   Shirey, R., "Internet Security Glossary, Version 2",
               FYI 36, <a href="rfc4949.html">RFC 4949</a>, DOI 10.17487/RFC4949, August 2007,
               &lt;<a href="http://www.rfc-editor.org/info/rfc4949">http://www.rfc-editor.org/info/rfc4949</a>&gt;.

   [<a id="ref-RFC5280" name="ref-RFC5280">RFC5280</a>]   Cooper, D., Santesson, S., Farrell, S., Boeyen, S.,
               Housley, R., and W. Polk, "Internet X.509 Public Key
               Infrastructure Certificate and Certificate Revocation
               List (CRL) Profile", <a href="rfc5280.html">RFC 5280</a>, DOI 10.17487/RFC5280,
               May 2008, &lt;<a href="http://www.rfc-editor.org/info/rfc5280">http://www.rfc-editor.org/info/rfc5280</a>&gt;.

   [<a id="ref-RFC5785" name="ref-RFC5785">RFC5785</a>]   Nottingham, M. and E. Hammer-Lahav, "Defining Well-Known
               Uniform Resource Identifiers (URIs)", <a href="rfc5785.html">RFC 5785</a>,
               DOI 10.17487/RFC5785, April 2010,
               &lt;<a href="http://www.rfc-editor.org/info/rfc5785">http://www.rfc-editor.org/info/rfc5785</a>&gt;.

   [<a id="ref-RFC6120" name="ref-RFC6120">RFC6120</a>]   Saint-Andre, P., "Extensible Messaging and Presence
               Protocol (XMPP): Core", <a href="rfc6120.html">RFC 6120</a>, DOI 10.17487/RFC6120,
               March 2011, &lt;<a href="http://www.rfc-editor.org/info/rfc6120">http://www.rfc-editor.org/info/rfc6120</a>&gt;.






<span class="grey">Saint-Andre, et al.          Standards Track                   [Page 21]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-22" id="page-22" name="page-22"> </a>
<span class="grey"><a href="rfc7712.html">RFC 7712</a>                        XMPP DNA                   November 2015</span>


   [<a id="ref-RFC6125" name="ref-RFC6125">RFC6125</a>]   Saint-Andre, P. and J. Hodges, "Representation and
               Verification of Domain-Based Application Service Identity
               within Internet Public Key Infrastructure Using X.509
               (PKIX) Certificates in the Context of Transport Layer
               Security (TLS)", <a href="rfc6125.html">RFC 6125</a>, DOI 10.17487/RFC6125,
               March 2011, &lt;<a href="http://www.rfc-editor.org/info/rfc6125">http://www.rfc-editor.org/info/rfc6125</a>&gt;.

   [<a id="ref-RFC6698" name="ref-RFC6698">RFC6698</a>]   Hoffman, P. and J. Schlyter, "The DNS-Based
               Authentication of Named Entities (DANE) Transport Layer
               Security (TLS) Protocol: TLSA", <a href="rfc6698.html">RFC 6698</a>,
               DOI 10.17487/RFC6698, August 2012,
               &lt;<a href="http://www.rfc-editor.org/info/rfc6698">http://www.rfc-editor.org/info/rfc6698</a>&gt;.

   [<a id="ref-RFC7218" name="ref-RFC7218">RFC7218</a>]   Gudmundsson, O., "Adding Acronyms to Simplify
               Conversations about DNS-Based Authentication of Named
               Entities (DANE)", <a href="rfc7218.html">RFC 7218</a>, DOI 10.17487/RFC7218,
               April 2014, &lt;<a href="http://www.rfc-editor.org/info/rfc7218">http://www.rfc-editor.org/info/rfc7218</a>&gt;.

   [<a id="ref-RFC7673" name="ref-RFC7673">RFC7673</a>]   Finch, T., Miller, M., and P. Saint-Andre, "Using
               DNS-Based Authentication of Named Entities (DANE) TLSA
               Records with SRV Records", <a href="rfc7673.html">RFC 7673</a>,
               DOI 10.17487/RFC7673, October 2015,
               &lt;<a href="http://www.rfc-editor.org/info/rfc7673">http://www.rfc-editor.org/info/rfc7673</a>&gt;.

   [<a id="ref-RFC7711" name="ref-RFC7711">RFC7711</a>]   Miller, M. and P. Saint-Andre, "PKIX over Secure HTTP
               (POSH)", <a href="rfc7711.html">RFC 7711</a>, DOI 10.17487/RFC7711, November 2015,
               &lt;<a href="http://www.rfc-editor.org/info/rfc7711">http://www.rfc-editor.org/info/rfc7711</a>&gt;.

   [<a id="ref-XEP-0220" name="ref-XEP-0220">XEP-0220</a>]  Miller, J., Saint-Andre, P., and P. Hancke, "Server
               Dialback", XSF XEP 0220, August 2014,
               &lt;<a href="http://xmpp.org/extensions/xep-0220.html">http://xmpp.org/extensions/xep-0220.html</a>&gt;.




















<span class="grey">Saint-Andre, et al.          Standards Track                   [Page 22]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-23" id="page-23" name="page-23"> </a>
<span class="grey"><a href="rfc7712.html">RFC 7712</a>                        XMPP DNA                   November 2015</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/11.2.%20%20Informative%20References"></a><a class="selflink" href="#section-11.2" name="section-11.2">11.2</a>.  Informative References</span>

   [<a id="ref-RFC2142" name="ref-RFC2142">RFC2142</a>]   Crocker, D., "Mailbox Names for Common Services, Roles
               and Functions", <a href="rfc2142.html">RFC 2142</a>, DOI 10.17487/RFC2142, May 1997,
               &lt;<a href="http://www.rfc-editor.org/info/rfc2142">http://www.rfc-editor.org/info/rfc2142</a>&gt;.

   [<a id="ref-RFC3920" name="ref-RFC3920">RFC3920</a>]   Saint-Andre, P., Ed., "Extensible Messaging and Presence
               Protocol (XMPP): Core", <a href="rfc3920.html">RFC 3920</a>, DOI 10.17487/RFC3920,
               October 2004, &lt;<a href="http://www.rfc-editor.org/info/rfc3920">http://www.rfc-editor.org/info/rfc3920</a>&gt;.

   [<a id="ref-RFC4120" name="ref-RFC4120">RFC4120</a>]   Neuman, C., Yu, T., Hartman, S., and K. Raeburn, "The
               Kerberos Network Authentication Service (V5)", <a href="rfc4120.html">RFC 4120</a>,
               DOI 10.17487/RFC4120, July 2005,
               &lt;<a href="http://www.rfc-editor.org/info/rfc4120">http://www.rfc-editor.org/info/rfc4120</a>&gt;.

   [<a id="ref-RFC6066" name="ref-RFC6066">RFC6066</a>]   Eastlake 3rd, D., "Transport Layer Security (TLS)
               Extensions: Extension Definitions", <a href="rfc6066.html">RFC 6066</a>,
               DOI 10.17487/RFC6066, January 2011,
               &lt;<a href="http://www.rfc-editor.org/info/rfc6066">http://www.rfc-editor.org/info/rfc6066</a>&gt;.

   [<a id="ref-RFC6091" name="ref-RFC6091">RFC6091</a>]   Mavrogiannopoulos, N. and D. Gillmor, "Using OpenPGP Keys
               for Transport Layer Security (TLS) Authentication",
               <a href="rfc6091.html">RFC 6091</a>, DOI 10.17487/RFC6091, February 2011,
               &lt;<a href="http://www.rfc-editor.org/info/rfc6091">http://www.rfc-editor.org/info/rfc6091</a>&gt;.

   [<a id="ref-RFC6749" name="ref-RFC6749">RFC6749</a>]   Hardt, D., Ed., "The OAuth 2.0 Authorization Framework",
               <a href="rfc6749.html">RFC 6749</a>, DOI 10.17487/RFC6749, October 2012,
               &lt;<a href="http://www.rfc-editor.org/info/rfc6749">http://www.rfc-editor.org/info/rfc6749</a>&gt;.

   [<a id="ref-RFC7590" name="ref-RFC7590">RFC7590</a>]   Saint-Andre, P. and T. Alkemade, "Use of Transport Layer
               Security (TLS) in the Extensible Messaging and Presence
               Protocol (XMPP)", <a href="rfc7590.html">RFC 7590</a>, DOI 10.17487/RFC7590,
               June 2015, &lt;<a href="http://www.rfc-editor.org/info/rfc7590">http://www.rfc-editor.org/info/rfc7590</a>&gt;.

   [<a id="ref-XEP-0045" name="ref-XEP-0045">XEP-0045</a>]  Saint-Andre, P., "Multi-User Chat", XSF XEP 0045,
               February 2012,
               &lt;<a href="http://xmpp.org/extensions/xep-0045.html">http://xmpp.org/extensions/xep-0045.html</a>&gt;.

   [<a id="ref-XEP-0288" name="ref-XEP-0288">XEP-0288</a>]  Hancke, P. and D. Cridland, "Bidirectional
               Server-to-Server Connections", XSF XEP 0288,
               September 2013,
               &lt;<a href="http://xmpp.org/extensions/xep-0288.html">http://xmpp.org/extensions/xep-0288.html</a>&gt;.

   [<a id="ref-XEP-0344" name="ref-XEP-0344">XEP-0344</a>]  Hancke, P. and D. Cridland, "Impact of TLS and DNSSEC on
               Dialback", XSF XEP 0344, March 2015,
               &lt;<a href="http://xmpp.org/extensions/xep-0344.html">http://xmpp.org/extensions/xep-0344.html</a>&gt;.





<span class="grey">Saint-Andre, et al.          Standards Track                   [Page 23]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-24" id="page-24" name="page-24"> </a>
<span class="grey"><a href="rfc7712.html">RFC 7712</a>                        XMPP DNA                   November 2015</span>


Acknowledgements

   Richard Barnes, Stephen Farrell, and Jonas Lindberg contributed as
   co-authors to earlier draft versions of this document.

   Derek Atkins, Mahesh Jethanandani, and Dan Romascanu reviewed the
   document on behalf of the Security Directorate, the Operations and
   Management Directorate, and the General Area Review Team,
   respectively.

   During IESG review, Stephen Farrell and Barry Leiba provided helpful
   input that led to improvements in the specification.

   Thanks to Dave Cridland as document shepherd, Joe Hildebrand as
   working group chair, and Ben Campbell as area director.

   Peter Saint-Andre wishes to acknowledge Cisco Systems, Inc., for
   employing him during his work on earlier draft versions of this
   document.

Authors' Addresses

   Peter Saint-Andre
   &amp;yet

   Email: peter@andyet.com
   URI:   <a href="https://andyet.com/">https://andyet.com/</a>


   Matthew Miller
   Cisco Systems, Inc.
   1899 Wynkoop Street, Suite 600
   Denver, CO  80202
   United States

   Email: mamille2@cisco.com


   Philipp Hancke
   &amp;yet

   Email: fippo@andyet.com
   URI:   <a href="https://andyet.com/">https://andyet.com/</a>








Saint-Andre, et al.          Standards Track                   [Page 24]

</pre><br/>
    <span class="noprint"><small><small>Html markup produced by rfcmarkup 1.126, available from
      <a href="https://tools.ietf.org/tools/rfcmarkup/">https://tools.ietf.org/tools/rfcmarkup/</a>
    </small></small></span>
  </div>




</body><!-- Mirrored from tools.ietf.org/html/rfc7712 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 06 Mar 2018 23:18:19 GMT --></html>