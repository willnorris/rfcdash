<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml"><!-- Mirrored from tools.ietf.org/html/rfc1913 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 06 Mar 2018 23:18:55 GMT --><!-- Added by HTTrack --><head><meta content="text/html;charset=utf-8" http-equiv="content-type"/><!-- /Added by HTTrack -->

    <meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
    <meta content="index,follow" name="robots"/>
    <meta content="rfcmarkup version 1.126" name="creator"/>
    <link href="http://purl.org/dc/elements/1.1/" rel="schema.DC"/>
<meta content="urn:ietf:rfc:1913" name="DC.Identifier"/>
<meta content="The authors describe an architecture for indexing in distributed
databases, and apply this to the WHOIS++ protocol. [STANDARDS-TRACK]" name="DC.Description.Abstract"/>
<meta content="Fullton, Jim" name="DC.Creator"/>
<meta content="Spero, Simon" name="DC.Creator"/>
<meta content="Weider, Chris" name="DC.Creator"/>
<meta content="February, 1996" name="DC.Date.Issued"/>
<meta content="Architecture of the Whois++ Index Service" name="DC.Title"/>

    <link href="https://tools.ietf.org/images/rfc.png" rel="icon" type="image/png"/>
    <link href="https://tools.ietf.org/images/rfc.png" rel="shortcut icon" type="image/png"/>
    <title>RFC 1913 - Architecture of the Whois++ Index Service</title>
    
    
    <style type="text/css">
	@media only screen 
	  and (min-width: 992px)
	  and (max-width: 1199px) {
	    body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 768px)
	  and (max-width: 991px) {
            body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 480px)
	  and (max-width: 767px) {
            body { font-size: 11pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (max-width: 479px) {
            body { font-size: 8pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-device-width : 375px) 
	  and (max-device-width : 667px) {
            body { font-size: 9.5pt; }
            div.content { width: 96ex; margin: 0 1px; }
        }
	@media only screen 
	  and (min-device-width: 1200px) {
            body { font-size: 10pt; margin: 0 4em; }
            div.content { width: 96ex; margin: 0; }
        }
        h1, h2, h3, h4, h5, h6, .h1, .h2, .h3, .h4, .h5, .h6 {
	    font-weight: bold;
            line-height: 0pt;
            display: inline;
            white-space: pre;
            font-family: monospace;
            font-size: 1em;
	    font-weight: bold;
        }
        pre {
            font-size: 1em;
            margin-top: 0px;
            margin-bottom: 0px;
        }
	.pre {
	    white-space: pre;
	    font-family: monospace;
	}
	.header{
	    font-weight: bold;
	}
        .newpage {
            page-break-before: always;
        }
        .invisible {
            text-decoration: none;
            color: white;
        }
        a.selflink {
          color: black;
          text-decoration: none;
        }
        @media print {
            body {
                font-family: monospace;
                font-size: 10.5pt;
            }
            h1, h2, h3, h4, h5, h6 {
                font-size: 1em;
            }
        
            a:link, a:visited {
                color: inherit;
                text-decoration: none;
            }
            .noprint {
                display: none;
            }
        }
	@media screen {
	    .grey, .grey a:link, .grey a:visited {
		color: #777;
	    }
            .docinfo {
                background-color: #EEE;
            }
            .top {
                border-top: 7px solid #EEE;
            }
            .bgwhite  { background-color: white; }
            .bgred    { background-color: #F44; }
            .bggrey   { background-color: #666; }
            .bgbrown  { background-color: #840; }            
            .bgorange { background-color: #FA0; }
            .bgyellow { background-color: #EE0; }
            .bgmagenta{ background-color: #F4F; }
            .bgblue   { background-color: #66F; }
            .bgcyan   { background-color: #4DD; }
            .bggreen  { background-color: #4F4; }

            .legend   { font-size: 90%; }
            .cplate   { font-size: 70%; border: solid grey 1px; }
	}
    </style>
    <!--[if IE]>
    <style>
    body {
       font-size: 13px;
       margin: 10px 10px;
    }
    </style>
    <![endif]-->

    <script type="text/javascript"><!--
    function addHeaderTags() {
	var spans = document.getElementsByTagName("span");
	for (var i=0; i < spans.length; i++) {
	    var elem = spans[i];
	    if (elem) {
		var level = elem.getAttribute("class");
                if (level == "h1" || level == "h2" || level == "h3" || level == "h4" || level == "h5" || level == "h6") {
                    elem.innerHTML = "<"+level+">"+elem.innerHTML+"</"+level+">";		
                }
	    }
	}
    }
    var legend_html = "Colour legend:<br />      <table>         <tr><td>Unknown:</td>                   <td><span class='cplate bgwhite'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft:</td>                     <td><span class='cplate bgred'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Informational:</td>             <td><span class='cplate bgorange'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Experimental:</td>              <td><span class='cplate bgyellow'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Best Common Practice:</td>      <td><span class='cplate bgmagenta'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Proposed Standard:</td>         <td><span class='cplate bgblue'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft Standard (old designation):</td> <td><span class='cplate bgcyan'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Internet Standard:</td>         <td><span class='cplate bggreen'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Historic:</td>                  <td><span class='cplate bggrey'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Obsolete:</td>                  <td><span class='cplate bgbrown'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>     </table>";
    function showElem(id) {
        var elem = document.getElementById(id);
        elem.innerHTML = eval(id+"_html");
        elem.style.visibility='visible';
    }
    function hideElem(id) {
        var elem = document.getElementById(id);
        elem.style.visibility='hidden';        
        elem.innerHTML = "";
    }
    // -->
    </script>
</head>
<body onload="addHeaderTags()">
  <div class="content">
   <div style="height: 13px;">
      <div class="pre noprint docinfo bggrey" onclick="showElem('legend');" onmouseout="hideElem('legend')" onmouseover="this.style.cursor='pointer';" style="height: 6px; position: absolute;" title="Click for colour legend.">                                                                        </div>
      <div class="docinfo noprint pre legend" id="legend" onmouseout="hideElem('legend');" onmouseover="showElem('legend');" style="position:absolute; top: 4px; left: 4ex; visibility:hidden; background-color: white; padding: 4px 9px 5px 7px; border: solid #345 1px; ">
      </div>
   </div>
<span class="pre noprint docinfo top">[<a href="index.html" title="Document search and retrieval page">Docs</a>] [<a href="https://tools.ietf.org/rfc/rfc1913.txt" title="Plaintext version of this document">txt</a>|<a href="https://tools.ietf.org/pdf/rfc1913" title="PDF version of this document">pdf</a>] [<a href="https://tools.ietf.org/html/draft-ietf-wnils-whois" title="draft-ietf-wnils-whois">draft-ietf-wnil...</a>] [<a href="https://datatracker.ietf.org/doc/rfc1913" title="IESG Datatracker information for this document">Tracker</a>] [<a href="https://tools.ietf.org/rfcdiff?difftype=--hwdiff&amp;url2=rfc1913" title="Inline diff (wdiff)">Diff1</a>] [<a href="https://tools.ietf.org/rfcdiff?url2=rfc1913" title="Side-by-side diff">Diff2</a>]         </span><br/>
<span class="pre noprint docinfo">                                                                        </span><br/>
<span class="pre noprint docinfo">                                                                HISTORIC</span><br/>
<span class="pre noprint docinfo">                                                                        </span><br/>
<pre>Network Working Group                                          C. Weider
Request for Comments: 1913                                        Bunyip
Category: Standards Track                                     J. Fullton
                                                                   CNIDR
                                                                S. Spero
                                                                     EIT
                                                           February 1996


               <span class="h1">Architecture of the Whois++ Index Service</span>

Status of this Memo

   This document specifies an Internet standards track protocol for the
   Internet community, and requests discussion and suggestions for
   improvements.  Please refer to the current edition of the "Internet
   Official Protocol Standards" (STD 1) for the standardization state
   and status of this protocol.  Distribution of this memo is unlimited.

Abstract

   The authors describe an architecture for indexing in distributed
   databases, and apply this to the WHOIS++ protocol.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/1.%20Purpose%3A"></a><a class="selflink" href="#section-1" name="section-1">1</a>. Purpose:</span>

   The WHOIS++ directory service [Deutsch, et al, 1995] is intended to
   provide a simple, extensible directory service predicated on a
   template-based information model and a flexible query language. This
   document describes a general architecture designed for indexing
   distributed databases, and then applys that architecture to link
   together many of these WHOIS++ servers into a distributed, searchable
   wide area directory service.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/2.%20Scope%3A"></a><a class="selflink" href="#section-2" name="section-2">2</a>. Scope:</span>

   This document details a distributed, easily maintained architecture
   for providing a unified index to a large number of distributed
   WHOIS++ servers. This architecture can be used with systems other
   than WHOIS++ to provide a distributed directory service which is also
   searchable.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/3.%20Motivation%20and%20Introduction%3A"></a><a class="selflink" href="#section-3" name="section-3">3</a>. Motivation and Introduction:</span>

   It seems clear that with the vast amount of directory information
   potentially available on the Internet, it is simply not feasible to
   build a centralized directory to serve all this information. If we
   are to distribute the directory service, the easiest (although not



<span class="grey">Weider, et al               Standards Track                     [Page 1]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-2" id="page-2" name="page-2"> </a>
<span class="grey"><a href="rfc1913.html">RFC 1913</a>       Architecture of the Whois++ Index Service   February 1996</span>


   necessarily the best) way of building the directory service is to
   build a hierarchy of directory information collection agents. In this
   architecture, a directory query is delivered to a certain agent in
   the tree, and then handed up or down, as appropriate, so that the
   query is delivered to the agent which holds the information which
   fills the query.  This approach has been tried before, most notably
   in some implementations of the X.500 standard. However, there are
   number of major flaws with the approach as it has been taken. This
   new Index Service is designed to fix these flaws.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.1.%20The%20search%20problem"></a><a class="selflink" href="#section-3.1" name="section-3.1">3.1</a>. The search problem</span>

   One of the primary assumptions made by recent implementations of
   distributed directory services is that every entry resides in some
   location in a hierarchical name space. While this arrangement is
   ideal for reading the entry once one knows its location, it is not as
   good when one is searching for the location in the namespace of those
   entries which meet some set of criteria. If the only criteria we know
   about a desired entry are items which do not appear in the namespace,
   we are forced to do a global query. Whenever we issue a global query
   (at the root of the namespace), or a query at the top of a given
   subtree in the namespace, that query is replicated to "all" subtrees
   of the starting point. The replication of the query to all subtrees
   is not necessarily a problem; queries are cheap. However, every
   server to which the query has been replicated must process that
   query, even if it has no entries which match the specified criteria.
   This part of the global query processing is quite expensive. A poorly
   designed namespace or a thin namespace can cause the vast majority of
   queries to be replicated globally, but a very broad namespace can
   cause its own navigation problems. Because of these problems, search
   has been turned off at high levels of the X.500 namespace.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.2.%20The%20location%20problem"></a><a class="selflink" href="#section-3.2" name="section-3.2">3.2</a>. The location problem</span>

   With global search turned off, one must know in advance how the name
   space is laid out so that one can guide a query to a proper location.
   Also, the layout of the namespace then becomes critical to a user's
   ability to find the desired information. Thus there are endless
   battles about how to lay out the name space to best serve a given set
   of users, and enormous headaches whenever it becomes apparent that
   the current namespace is unsuited to the current usages and must be
   changed (as recently happened in X.500). Also, assuming one does
   impose multiple hierarchies on the entries through use of the
   namespace, the mechanisms to maintain these multiple hierarchies in
   X.500 do not exist yet, and it is possible to move entries out from
   under their pointers.  Also, there is as yet no agreement on how the
   X.500 namespace should look even for the White Pages types of
   information that is currently installed in the X.500 pilot project.



<span class="grey">Weider, et al               Standards Track                     [Page 2]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-3" id="page-3" name="page-3"> </a>
<span class="grey"><a href="rfc1913.html">RFC 1913</a>       Architecture of the Whois++ Index Service   February 1996</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.3.%20The%20Yellow%20Pages%20problem"></a><a class="selflink" href="#section-3.3" name="section-3.3">3.3</a>. The Yellow Pages problem</span>

   Current implementations of this hierarchical architecture have also
   been unsuited to solving the Yellow Pages problem; that is, the
   problem of easily and flexibly building special-purpose directories
   (say of molecular biologists) and of automatically maintaining these
   directories once they have been built. In particular, the attributes
   appropriate to the new directory must be built into the namespace
   because that is the only way to segregate related entries into a
   place where they can be found without a global search. Also, there is
   a classification problem; how does one adequately specify the proper
   categories so that people other than the creator of the directory can
   find the correct subtree? Additionally, there is the problem of
   actually finding the data to put into the subtree; if one must
   traverse the hierarchy to find the data, we have to look globally for
   the proper entries.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.4.%20Solutions"></a><a class="selflink" href="#section-3.4" name="section-3.4">3.4</a>. Solutions</span>

   The problems examined in this section can be addressed by a
   combination of two new techniques: directory meshes and forward
   knowledge.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/4.%20Directory%20meshes%20and%20forward%20knowledge"></a><a class="selflink" href="#section-4" name="section-4">4</a>. Directory meshes and forward knowledge</span>

   We'll hold off for a moment on describing the actual architecture
   used in our solution to these problems and concentrate on a high
   level description of what solutions are provided by our conceptual
   approach. To begin with, although every entry in WHOIS++ does indeed
   have a unique identifier (resides in a specific location in the
   namespace) the navigational algorithms to reach a specific entry do
   not necessarily depend on the identifier the entry has been assigned.
   The Index Service gets around the namespace and hierarchy problems by
   creating a directory mesh on top of the entries.  Each layer of the
   mesh has a set of 'forward knowledge' which indicates the contents of
   the various servers at the next lower layer of the mesh. Thus when a
   query is received by a server in a given layer of the mesh, it can
   prune the search tree and hand the query off to only those lower
   level servers which have indicated that they might be able to answer
   it. Thus search becomes feasible at all levels of the mesh. In the
   current version of this architecture, we have chosen a certain set of
   information to hand up the mesh as forward knowledge. This may or may
   not be exactly the set of information required to construct a truly
   searchable directory, but the protocol itself doesn't restrict the
   types of information which can be handed around.

   In addition, the protocols designed to maintain the forward knowledge
   will also work perfectly well to provide replication of servers for



<span class="grey">Weider, et al               Standards Track                     [Page 3]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-4" id="page-4" name="page-4"> </a>
<span class="grey"><a href="rfc1913.html">RFC 1913</a>       Architecture of the Whois++ Index Service   February 1996</span>


   redundancy and robustness. In this case, the forward knowledge handed
   around by the protocols is the entire database of entries held by the
   replicated server.

   Another benefit provided by the mesh of index servers is that since
   the entry identification scheme has been decoupled from the
   navigation service, multiple hierarchies can be built and easily
   maintained on top of the existing data. Also, the user does not need
   to know in advance where in the mesh the entry is contained.

   Also, the Yellow Pages problem now becomes tractable, as the index
   servers can pick and choose between information proffered by a given
   server; because we have an architecture that allows for automatic
   polling of data, special purpose directories become easy to construct
   and to maintain.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/5.%20Components%20of%20the%20Index%20Service%3A"></a><a class="selflink" href="#section-5" name="section-5">5</a>. Components of the Index Service:</span>

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.1.%20WHOIS%2B%2B%20servers"></a><a class="selflink" href="#section-5.1" name="section-5.1">5.1</a>. WHOIS++ servers</span>

   The whois++ service is described in [Deutsch, et al, 1995]. As that
   service specifies only the query language, the information model, and
   the server responses, whois++ services can be provided by a wide
   variety of databases and directory services. However, to participate
   in the Index Service, that underlying database must also be able to
   generate a 'centroid', or some other type of forward knowledge, for
   the data it serves.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.2.%20Centroids%20as%20forward%20knowledge"></a><a class="selflink" href="#section-5.2" name="section-5.2">5.2</a>. Centroids as forward knowledge</span>

   The centroid of a server is comprised of a list of the templates and
   attributes used by that server, and a word list for each attribute.
   The word list for a given attribute contains one occurrence of every
   word which appears at least once in that attribute in some record in
   that server's data, and nothing else.

   A word is any token delimited by blank spaces, newlines, or the '@'
   character, in the value of an attribute.

   For example, if a whois++ server contains exactly three records, as
   follows:

   Record 1                        Record 2
   Template: User                  Template: User
   First Name: John                First Name: Joe
   Last Name: Smith                Last Name: Smith
   Favourite Drink: Labatt Beer    Favourite Drink: Molson Beer




<span class="grey">Weider, et al               Standards Track                     [Page 4]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-5" id="page-5" name="page-5"> </a>
<span class="grey"><a href="rfc1913.html">RFC 1913</a>       Architecture of the Whois++ Index Service   February 1996</span>


   Record 3
   Template: Domain
   Domain Name: foo.edu
   Contact Name: Mike Foobar

   the centroid for this server would be

   Template:         User
   First Name:       Joe
                     John
   Last Name:        Smith
   Favourite Drink:  Beer
                     Labatt
                     Molson

   Template:         Domain
   Domain Name:      foo.edu
   Contact Name:     Mike
                     Foobar

   It is this information which is handed up the tree to provide forward
   knowledge.  As we mention above, this may not turn out to be the
   ideal solution for forward knowledge, and we suspect that there may
   be a number of different sets of forward knowledge used in the Index
   Service. However, the directory architecture is in a very real sense
   independent of what types of forward knowledge are handed around, and
   it is entirely possible to build a unified directory which uses many
   types of forward knowledge.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.3.%20Index%20servers%20and%20Index%20server%20Architecture"></a><a class="selflink" href="#section-5.3" name="section-5.3">5.3</a>. Index servers and Index server Architecture</span>

   A whois++ index server collects and collates the centroids (or other
   forward knowledge) of either a number of whois++ servers or of a
   number of other index servers. An index server must be able to
   generate a centroid for the information it contains. In addition, an
   index server can index any other server it wishes, which allows one
   base level server (or index server) to participate in many
   hierarchies in the directory mesh.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/5.3.1.%20Queries%20to%20index%20servers"></a><a class="selflink" href="#section-5.3.1" name="section-5.3.1">5.3.1</a>. Queries to index servers</span>

   An index server will take a query in standard whois++ format, search
   its collections of centroids and other forward information, determine
   which servers hold records which may fill that query, and then
   notifies the user's client of the next servers to contact to submit
   the query (referral in the X.500 model). An index server can also
   contain primary data of its own; and thus act a both an index server
   and a base level server. In this case, the index server's response to



<span class="grey">Weider, et al               Standards Track                     [Page 5]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-6" id="page-6" name="page-6"> </a>
<span class="grey"><a href="rfc1913.html">RFC 1913</a>       Architecture of the Whois++ Index Service   February 1996</span>


   a query may be a mix of records and referral pointers.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/5.3.2.%20Index%20server%20distribution%20model%20and%20centroid%20propogation"></a><a class="selflink" href="#section-5.3.2" name="section-5.3.2">5.3.2</a>. Index server distribution model and centroid propogation</span>

   The diagram on the next page illustrates how a mesh of index servers
   might be created for a set of whois++ servers. Although it looks like
   a hierarchy, the protocols allow (for example) server A to be indexed
   by both server D and by server H.

     whois++               index                   index
     servers               servers                 servers
                           for                     for
                           whois++                 lower-level
                           servers                 index servers
     _______
    |       |
    |   A   |__
    |_______|  \            _______
                \----------|       |
     _______               |   D   |__             ______
    |       |   /----------|_______|  \           |      |
    |   B   |__/                       \----------|      |
    |_______|                                     |  F   |
                                       /----------|______|
                                      /
     _______                _______  /
    |       |              |       |-
    |   C   |--------------|   E   |
    |_______|              |_______|-
                                     \
                                      \
     _______                           \            ______
    |       |                           \----------|      |
    |   G   |--------------------------------------|  H   |
    |_______|                                      |______|

             Figure 1: Sample layout of the Index Service mesh

   In the portion of the index tree shown above, whois++ servers A and B
   hand their centroids up to index server D, whois++ server C hands its
   centroid up to index server E, and index servers D and E hand their
   centroids up to index server F. Servers E and G also hand their
   centroids up to H.

   The number of levels of index servers, and the number of index
   servers at each level, will depend on the number of whois++ servers
   deployed, and the response time of individual layers of the server
   tree. These numbers will have to be determined in the field.



<span class="grey">Weider, et al               Standards Track                     [Page 6]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-7" id="page-7" name="page-7"> </a>
<span class="grey"><a href="rfc1913.html">RFC 1913</a>       Architecture of the Whois++ Index Service   February 1996</span>


<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/5.3.3.%20Centroid%20propogation%20and%20changes%20to%20centroids"></a><a class="selflink" href="#section-5.3.3" name="section-5.3.3">5.3.3</a>. Centroid propogation and changes to centroids</span>

   Centroid propogation is initiated by an authenticated POLL command
   (sec. 5.2).  The format of the POLL command allows the poller to
   request the centroid of any or all templates and attributes held by
   the polled server. After the polled server has authenticated the
   poller, it determines which of the requested centroids the poller is
   allowed to request, and then issues a CENTROID-CHANGES report (sec.
   5.3) to transmit the data. When the poller receives the CENTROID-
   CHANGES report, it can authenticate the pollee to determine whether
   to add the centroid changes to its data. Additionally, if a given
   pollee knows what pollers hold centroids from the pollee, it can
   signal to those pollers the fact that its centroid has changed by
   issuing a DATA-CHANGED command. The poller can then determine if and
   when to issue a new POLL request to get the updated information. The
   DATA-CHANGED command is included in this protocol to allow
   'interactive' updating of critical information.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/5.3.4.%20Centroid%20propogation%20and%20mesh%20traversal"></a><a class="selflink" href="#section-5.3.4" name="section-5.3.4">5.3.4</a>. Centroid propogation and mesh traversal</span>

   When an index server issues a POLL request, it may indicate to the
   polled server what relationship it has to the polled. This
   information can be used to help traverse the directory mesh. Two
   fields are specified in the current proposal to transmit the
   relationship information, although it is expected that richer
   relationship information will be shared in future revisions of this
   protocol.

   One field used for this information is the Hierarchy field, and can
   take on three values. The first is 'topology', which indicates that
   the indexing server is at a higher level in the network topology
   (e.g. indexes the whole regional ISP). The second is 'geographical',
   which indicates that the polling server covers a geographical area
   subsuming the pollee. The third is 'administrative', which indicates
   that the indexing server covers an administrative domain subsuming
   the pollee.

   The second field used for this information is the Description field,
   which contains the DESCRIBE record of the polling server. This allows
   users to obtain richer metainformation for the directory mesh,
   enabling them to expand queries more effectively.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/5.3.5.%20Query%20handling%20and%20passing%20algorithms"></a><a class="selflink" href="#section-5.3.5" name="section-5.3.5">5.3.5</a>. Query handling and passing algorithms</span>

   When an index server receives a query, it searches its collection of
   centroids and determines which servers hold records which may fill
   that query. As whois++ becomes widely deployed, it is expected that
   some index servers may specialize in indexing certain whois++



<span class="grey">Weider, et al               Standards Track                     [Page 7]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-8" id="page-8" name="page-8"> </a>
<span class="grey"><a href="rfc1913.html">RFC 1913</a>       Architecture of the Whois++ Index Service   February 1996</span>


   templates or perhaps even certain fields within those templates. If
   an index server obtains a match with the query "for those template
   fields and attributes the server indexes", it is to be considered a
   match for the purpose of forwarding the query.

<span class="h5"><a class="dashAnchor" name="//apple_ref/Section/5.3.5.1.%20Query%20referral"></a><a class="selflink" href="#section-5.3.5.1" name="section-5.3.5.1">5.3.5.1</a>. Query referral</span>

   Query referral is the process of informing a client which servers to
   contact next to resolve a query.  The syntax for notifying a client
   is outlined in <a href="#section-5.5">section 5.5</a>.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/5.3.6%20Loop%20control"></a><a class="selflink" href="#section-5.3.6" name="section-5.3.6">5.3.6</a> Loop control</span>

   Since there are no a priori restrictions on which servers may poll
   which other servers, and since a given server may participate in many
   sub-meshes, mechanisms must be installed to allow the detection of
   cycles in the polling relationships. This is accomplished in the
   current protocol by including a hop-count on polling relationships.
   Each time a polled server generates forward information, it informs
   the polling server about its current hopcount, which is the maximum
   of the hopcounts of all the servers it polls, plus 1.  A base level
   server (one which polls no other servers) will have a hopcount of 0.
   When a server decides to poll a new server, if its hopcount goes up,
   then it must information all the other servers which poll it about
   its new hopcount.  A maximum hopcount (8 in the current version) will
   help the servers detect polling loops.

   A second approach to loop detection is to do all the work in the
   client; which would determine which new referrals have already
   appeared in the referral list, and then simply iterate the referral
   process until there are no new servers to ask.  An algorithm to
   accomplish this in WHOIS++ is detailed in [Faltstrom 95].

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/6.%20Syntax%20for%20operations%20of%20the%20Index%20Service%3A"></a><a class="selflink" href="#section-6" name="section-6">6</a>. Syntax for operations of the Index Service:</span>

   The syntax for each protocol componenet is listed below. In addition,
   each section contains a listing of which of these attributes is
   required and optional for each of the componenet. All timestamps must
   be in the format YYYYMMDDHHMM and in GMT.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/6.1.%20Data%20changed%20syntax"></a><a class="selflink" href="#section-6.1" name="section-6.1">6.1</a>. Data changed syntax</span>

   The data changed template look like this:

# DATA-CHANGED
 Version-number: // version number of index service software, used to
                 // insure compatibility. Current value is 1.0
 Time-of-latest-centroid-change: // time stamp of latest centroid



<span class="grey">Weider, et al               Standards Track                     [Page 8]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-9" id="page-9" name="page-9"> </a>
<span class="grey"><a href="rfc1913.html">RFC 1913</a>       Architecture of the Whois++ Index Service   February 1996</span>


                                 // change, GMT
 Time-of-message-generation: // time when this message was generated,
                             // GMT
 Server-handle: // IANA unique identifier for this server
 Host-Name: // Host name of this server (current name)
 Host-Port: // Port number of this server (current port)
 Best-time-to-poll: // For heavily used servers, this will identify
                    // when the server is likely to be lightly
                    // loaded so that response to the poll will be
                    //speedy, GMT
 Authentication-type: // Type of authentication used by server, or NONE
 Authentication-data: // data for authentication
# END // This line must be used to terminate the data changed
                 // message

Required/optional table

Version-Number  REQUIRED
Time-of-latest-centroid-change  REQUIRED
Time-of-message-generation      REQUIRED
Server-handle   REQUIRED
Host-Name       REQUIRED
Host-Port       REQUIRED
Best-time-to-poll       OPTIONAL
Authentication-type     OPTIONAL
Authentication-data     OPTIONAL

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/6.2.%20Polling%20syntax"></a><a class="selflink" href="#section-6.2" name="section-6.2">6.2</a>. Polling syntax</span>

# POLL:
 Version-number: // version number of poller's index software, used to
                 // insure compatibility
 Type-of-poll: // type of forward data requested. CENTROID or QUERY
               // are the only one currently defined
 Poll-scope: // Selects bounds within which data will be returned.
             // See note.
 Start-time: // give me all the centroid changes starting at this
             // time, GMT
 End-time: // ending at this time, GMT
 Template: // a standard whois++ template name, or the keyword ALL,
           // for a full update.
 Field:    // used to limit centroid update information to specific
           // fields, is either a specific field name, a list of field
           // names, or the keyword ALL
 Server-handle: // IANA unique identifier for the polling server.
                // this handle may optionally be cached by the polled
                // server to announce future changes
 Host-Name: // Host name of the polling server.



<span class="grey">Weider, et al               Standards Track                     [Page 9]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-10" id="page-10" name="page-10"> </a>
<span class="grey"><a href="rfc1913.html">RFC 1913</a>       Architecture of the Whois++ Index Service   February 1996</span>


 Host-Port: // Port number of the polling server.
 Hierarchy: // This field indicates the relationship which the poller
              // bears to the pollee. Typical values might include
              // 'Topology', 'Geographical", or "Administrative"
 Description: // This field contains the DESCRIBE record of the
                // polling server
 Authentication-type: // Type of authentication used by poller, or NONE
 Authentication-data: // Data for authentication
# END  // This line must by used to terminate the poll message

   Note: For poll type CENTROID, the allowable values for Poll Scope are
   FULL and RELATIVE. Support of the FULL value is required, this
   provides a complete listing of the centroid or other forward
   information. RELATIVE indicates that these are the relative changes
   in the centroid since the last report to the polling server.

   For poll type QUERY, the allowable values for Poll Scope are a blank
   line, which indicates that all records are to be returned, or a valid
   WHOIS++ query, which indicates that just those records which satisfy
   the query are to be returned. N.B. Security considerations may
   require additional authentication for successful response to the
   Blank Line Poll Scope. This value has been included for server
   replication.

   A polling server may wish to index different types of information
   than the polled server has collected. The POLLED-FOR command will
   indicate which servers the polled server has contacted.

Required/Optional Table

Version-Number  REQUIRED, value is 1.0
Type-Of-Poll    REQUIRED, values CENTROID and QUERY are required
Poll-scope      REQUIRED  If Type-of-poll is CENTROID, FULL is required,
                          RELATIVE is optional
                          If Type-of-poll is QUERY, Blank line is
                          required, and WHOIS++-type queries are
                          required
Start-time      OPTIONAL
End-Time        OPTIONAL
Template        REQUIRED
Field           REQUIRED
Server-handle   REQUIRED
Host-Name       REQUIRED
Host-Port       REQUIRED
Hierarchy       OPTIONAL
Description     OPTIONAL
Authentication-Type:    OPTIONAL
Authentication-data:    OPTIONAL



<span class="grey">Weider, et al               Standards Track                    [Page 10]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-11" id="page-11" name="page-11"> </a>
<span class="grey"><a href="rfc1913.html">RFC 1913</a>       Architecture of the Whois++ Index Service   February 1996</span>


Example of a POLL command:
# POLL:
 Version-number: 1.0
 Type-of-poll: CENTROID
 Poll-scope: FULL
 Start-time: 199501281030+0100
 Template: ALL
 Field: ALL
 Server-handle: BUNYIP01
 Host-Name: services.bunyip.com
 Host-Port: 7070
 Hierarchy: Geographical
 # END

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/6.3.%20Centroid%20change%20report"></a><a class="selflink" href="#section-6.3" name="section-6.3">6.3</a>. Centroid change report</span>

   As the centroid change report contains nested multiply-occuring
   blocks, each multiply occurring block is surrounded *in this paper*
   by curly braces '{', '}'. These curly braces are NOT part of the
   syntax, they are for identification purposes only.

   The syntax of a Data: item is either a list of words, one word per
   line, or the keyword:

     ANY

   The keyword ANY as the only item of a Data: list means that any value
   for this field should be treated as a hit by the indexing server.

   The field Any-field: needs more explanation than can be given in the
   body of the syntax description below. It can take two values, True or
   False. If the value is True, the pollee is indicating that there are
   fields in this template which are not being exported to the polling
   server, but wishes to treat as a hit. Thus, when the polling server
   gets a query which has a term requesting a field not in this list for
   this template, the polling server will treat that term as a 'hit'.
   If the value is False, the pollee is indicating that there are no
   other fields for this template which should be treated as a hit. This
   field is required because the basic model for the WHOIS++ query
   syntax requires that the results of each search term be 'and'ed
   together. This field allows polled servers to export data only for
   non-sensitive fields, yet still get referrals of queries which
   contain sensitive terms.

   IMPORTANT: The data listed in the centroid must be in the ISO-8859-1
   character set in this version of the indexing protocol. Use of any
   other character set is a violation of the protocol. Note that the
   base-level server is also specified to use ISO-8859-1 [Deutsch, et



<span class="grey">Weider, et al               Standards Track                    [Page 11]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-12" id="page-12" name="page-12"> </a>
<span class="grey"><a href="rfc1913.html">RFC 1913</a>       Architecture of the Whois++ Index Service   February 1996</span>


   al, 1995].

# CENTROID-CHANGES
 Version-number: // version number of pollee's index software, used to
                 // insure compatibility
 Start-time: // change list starting time, GMT
 End-time: // change list ending time, GMT
 Server-handle: // IANA unique identifier of the responding server
 Case-sensitive: // states whether data is case sensitive or case
                 // insensitive. values are TRUE or FALSE
 Authentication-type: // Type of authentication used by pollee, or NONE
 Authentication-data: // Data for authentication
 Compression-type: // Type of compression used on the data, or NONE
 Size-of-compressed-data: // size of compressed data if compression
                          // is used
 Operation: // One of 3 keywords: ADD, DELETE, FULL
            // ADD - add these entries to the centroid for this server
            // DELETE - delete these entries from the centroid of this
            // server
            // FULL - the full centroid as of end-time follows
{ // The multiply occurring template block starts here
# BEGIN TEMPLATE
 Template: // a standard whois++ template name
 Any-field: // TRUE or FALSE. See beginning of 6.3 for explanation.
 { // the template contains multiple field blocks
# BEGIN FIELD
 Field: // a field name within that template
 Data: // Either the keyword *ANY*, or
       // the word list itself, one per line, cr/lf terminated,
       // each line starting with a dash character ('-').
# END FIELD
  } // the field ends with END FIELD
# END TEMPLATE
} // the template block ends with END TEMPLATE
# END CENTROID-CHANGES // This line must be used to terminate the
                         // centroid change report

   For each template, all fields must be listed, or queries will not be
   referred correctly.

Required/Optional table

Version-number  REQUIRED, value is 1.0
Start-time      REQUIRED (even if the centroid type is FULL)
End-time        REQUIRED (even if the centroid type is FULL)
Server-handle   REQUIRED
Case-Sensitive  OPTIONAL
Authentication-Type     OPTIONAL



<span class="grey">Weider, et al               Standards Track                    [Page 12]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-13" id="page-13" name="page-13"> </a>
<span class="grey"><a href="rfc1913.html">RFC 1913</a>       Architecture of the Whois++ Index Service   February 1996</span>


Authentication-Data     OPTIONAL
Compression-type        OPTIONAL
Size-of-compressed-data OPTIONAL (even if compression is used)
Operation     OPTIONAL, if used, upport for all three values is required
Tokenization-type       OPTIONAL
#BEGIN TEMPLATE REQUIRED
Template        REQUIRED
Any-field       REQUIRED
#BEGIN FIELD    REQUIRED
Field           REQUIRED
Data            REQUIRED
#END FIELD      REQUIRED
#END TEMPLATE   REQUIRED
#END CENTROID-CHANGES REQUIRED

Example:

# CENTROID-CHANGES
 Version-number: 1.0
 Start-time: 197001010000
 End-time: 199503012336
 Server-handle: BUNYIP01
# BEGIN TEMPLATE
 Template: USER
 Any-field: TRUE
# BEGIN FIELD
 Field: Name
 Data: Patrik
-Faltstrom
-Malin
-Linnerborg
#END FIELD
#BEGIN FIELD
 Field: Email
 Data: paf@bunyip.com
-malin.linnerborg@paf.se
# END FIELD
# END TEMPLATE
# END CENTROID-CHANGES

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/6.4%20QUERY%20and%20POLLEES%20responses"></a><a class="selflink" href="#section-6.4" name="section-6.4">6.4</a> QUERY and POLLEES responses</span>

   The response to a QUERY command is done in WHOIS++ format.








<span class="grey">Weider, et al               Standards Track                    [Page 13]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-14" id="page-14" name="page-14"> </a>
<span class="grey"><a href="rfc1913.html">RFC 1913</a>       Architecture of the Whois++ Index Service   February 1996</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/6.5.%20Query%20referral"></a><a class="selflink" href="#section-6.5" name="section-6.5">6.5</a>. Query referral</span>

   When referrals are included in the body of a response to a query,
   each referral is listed in a separate SERVER-TO-ASK block as shown
   below.

# SERVER-TO-ASK
 Version-number: // version number of index software, used to insure
                 // compatibility
 Body-of-Query: // the original query goes here
 Server-Handle: // WHOIS++ handle of the referred server
 Host-Name: // DNS name or IP address of the referred server
 Port-Number: // Port number to which to connect, if different from the
                // WHOIS++ port number

# END

Required/Optional table

Version-number REQUIRED, value should be 1.0
Body-of-query OPTIONAL
Server-Handle REQUIRED
Host-Name REQUIRED
Port-Number OPTIONAL, must be used if different from port 63

Example:

# SERVER-TO-ASK
 Version-Number: 1.0
 Server-Handle: SUNETSE01
 Host-Name: sunic.sunet.se
 Port-Number: 63
# END

7: Reply Codes

   In addition to the reply codes listed in [Deutsch 95] for the basic
   WHOIS++ client/server interaction, the following reply codes are used
   in version 1.0 of this protocol.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/113%20Requested%20method%20not%20available"></a><a class="selflink" href="#section-113" name="section-113">113</a> Requested method not available  </span>    Unable to provide a requested
                                        compression method. Contacted
                                        server will send requested
                                        data in different format.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/227%20Update%20request%20acknowledged"></a><a class="selflink" href="#section-227" name="section-227">227</a> Update request acknowledged  </span>       A DATA-CHANGED transmission
                                        has been accepted and logged
                                        for further action.



<span class="grey">Weider, et al               Standards Track                    [Page 14]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-15" id="page-15" name="page-15"> </a>
<span class="grey"><a href="rfc1913.html">RFC 1913</a>       Architecture of the Whois++ Index Service   February 1996</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/503%20Required%20attribute%20missing"></a><a class="selflink" href="#section-503" name="section-503">503</a> Required attribute missing  </span>        A REQUIRED attribute is
                                        missing in an interaction.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/504%20Desired%20server%20unreachable"></a><a class="selflink" href="#section-504" name="section-504">504</a> Desired server unreachable  </span>        The desired server is
                                        unreachable.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/505%20Desired%20server%20unavailable"></a><a class="selflink" href="#section-505" name="section-505">505</a> Desired server unavailable  </span>        The desired server fails to
                                        respond to requests, but host
                                        is still reachable.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/8.%20References"></a><a class="selflink" href="#section-8" name="section-8">8</a>. References</span>

[Deutsch 95] Deutsch, et al., "Architecture of the WHOIS++ service",
             <a href="rfc1835.html">RFC 1835</a>, August 1995.


[Faltstrom 95] Faltstrom, P., et al., "How to Interact with a WHOIS++
               Mesh, <a href="rfc1914.html">RFC 1914</a>, February 1996.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/9.%20Security%20Considerations"></a><a class="selflink" href="#section-9" name="section-9">9</a>. Security Considerations</span>

   Security issues are not discussed in this memo.





























<span class="grey">Weider, et al               Standards Track                    [Page 15]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-16" id="page-16" name="page-16"> </a>
<span class="grey"><a href="rfc1913.html">RFC 1913</a>       Architecture of the Whois++ Index Service   February 1996</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/10.%20Authors%27%20Addresses"></a><a class="selflink" href="#section-10" name="section-10">10</a>. Authors' Addresses</span>

   Chris Weider
   Bunyip Information Systems, Inc.
   310 St. Catherine St. West
   Montreal, PQ H2X 2A1
   CANADA

   Phone: +1-514-875-8611
   Fax:   +1-514-875-6134
   EMail: clw@bunyip.com


   Jim Fullton
   MCNC Center for Communications
   Post Office Box 12889
   3021 Cornwallis Road
   Research Triangle Park
   North Carolina 27709-2889

   Phone: 410-795-5422
   Fax:   410-795-5422
   EMail: fullton@cnidr.org


   Simon Spero
   EMail: ses@eit.com
























Weider, et al               Standards Track                    [Page 16]

</pre><br/>
    <span class="noprint"><small><small>Html markup produced by rfcmarkup 1.126, available from
      <a href="https://tools.ietf.org/tools/rfcmarkup/">https://tools.ietf.org/tools/rfcmarkup/</a>
    </small></small></span>
  </div>




</body><!-- Mirrored from tools.ietf.org/html/rfc1913 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 06 Mar 2018 23:18:55 GMT --></html>