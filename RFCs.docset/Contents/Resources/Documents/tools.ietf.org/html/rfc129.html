<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml"><!-- Mirrored from tools.ietf.org/html/rfc129 by HTTrack Website Copier/3.x [XR&CO'2013], Sat, 07 Jun 2014 20:18:58 GMT --><!-- Added by HTTrack --><head><meta content="text/html;charset=utf-8" http-equiv="content-type"/><!-- /Added by HTTrack -->

    <meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
    <meta content="index,follow" name="robots"/>
    <meta content="rfcmarkup version 1.107" name="creator"/>
    <link href="http://purl.org/dc/elements/1.1/" rel="schema.DC"/>
<meta content="urn:ietf:rfc:129" name="DC.Identifier"/>
<meta content="Heafner, J." name="DC.Creator"/>
<meta content="Meyer, E." name="DC.Creator"/>
<meta content="Harslem, E." name="DC.Creator"/>
<meta content="April, 1971" name="DC.Date.Issued"/>
<meta content="Request for comments on socket name structure" name="DC.Title"/>

    <link href="http://tools.ietf.org/images/rfc.png" rel="icon" type="image/png"/>
    <link href="http://tools.ietf.org/images/rfc.png" rel="shortcut icon" type="image/png"/>
    <title>RFC 129 - Request for comments on socket name structure</title>
    
    
    <style type="text/css">
	body {
	    margin: 0px 8px;
            font-size: 1em;
	}
        h1, h2, h3, h4, h5, h6, .h1, .h2, .h3, .h4, .h5, .h6 {
	    font-weight: bold;
            line-height: 0pt;
            display: inline;
            white-space: pre;
            font-family: monospace;
            font-size: 1em;
	    font-weight: bold;
        }
        pre {
            font-size: 1em;
            margin-top: 0px;
            margin-bottom: 0px;
        }
	.pre {
	    white-space: pre;
	    font-family: monospace;
	}
	.header{
	    font-weight: bold;
	}
        .newpage {
            page-break-before: always;
        }
        .invisible {
            text-decoration: none;
            color: white;
        }
        a.selflink {
          color: black;
          text-decoration: none;
        }
        @media print {
            body {
                font-family: monospace;
                font-size: 10.5pt;
            }
            h1, h2, h3, h4, h5, h6 {
                font-size: 1em;
            }
        
            a:link, a:visited {
                color: inherit;
                text-decoration: none;
            }
            .noprint {
                display: none;
            }
        }
	@media screen {
	    .grey, .grey a:link, .grey a:visited {
		color: #777;
	    }
            .docinfo {
                background-color: #EEE;
            }
            .top {
                border-top: 7px solid #EEE;
            }
            .bgwhite  { background-color: white; }
            .bgred    { background-color: #F44; }
            .bggrey   { background-color: #666; }
            .bgbrown  { background-color: #840; }            
            .bgorange { background-color: #FA0; }
            .bgyellow { background-color: #EE0; }
            .bgmagenta{ background-color: #F4F; }
            .bgblue   { background-color: #66F; }
            .bgcyan   { background-color: #4DD; }
            .bggreen  { background-color: #4F4; }

            .legend   { font-size: 90%; }
            .cplate   { font-size: 70%; border: solid grey 1px; }
	}
    </style>
    <!--[if IE]>
    <style>
    body {
       font-size: 13px;
       margin: 10px 10px;
    }
    </style>
    <![endif]-->

    <script type="text/javascript"><!--
    function addHeaderTags() {
	var spans = document.getElementsByTagName("span");
	for (var i=0; i < spans.length; i++) {
	    var elem = spans[i];
	    if (elem) {
		var level = elem.getAttribute("class");
                if (level == "h1" || level == "h2" || level == "h3" || level == "h4" || level == "h5" || level == "h6") {
                    elem.innerHTML = "<"+level+">"+elem.innerHTML+"</"+level+">";		
                }
	    }
	}
    }
    var legend_html = "Colour legend:<br />      <table>         <tr><td>Unknown:</td>                   <td><span class='cplate bgwhite'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft:</td>                     <td><span class='cplate bgred'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Informational:</td>             <td><span class='cplate bgorange'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Experimental:</td>              <td><span class='cplate bgyellow'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Best Common Practice:</td>      <td><span class='cplate bgmagenta'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Proposed Standard:</td>         <td><span class='cplate bgblue'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft Standard (old designation):</td> <td><span class='cplate bgcyan'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Internet Standard:</td>         <td><span class='cplate bggreen'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Historic:</td>                  <td><span class='cplate bggrey'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Obsolete:</td>                  <td><span class='cplate bgbrown'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>     </table>";
    function showElem(id) {
        var elem = document.getElementById(id);
        elem.innerHTML = eval(id+"_html");
        elem.style.visibility='visible';
    }
    function hideElem(id) {
        var elem = document.getElementById(id);
        elem.style.visibility='hidden';        
        elem.innerHTML = "";
    }
    // -->
    </script>
</head>
<body onload="addHeaderTags()">
   <div style="height: 13px;">
      <div class="pre noprint docinfo bgwhite" onclick="showElem('legend');" onmouseout="hideElem('legend')" onmouseover="this.style.cursor='pointer';" style="height: 6px; position: absolute;" title="Click for colour legend.">                                                                        </div>
      <div class="docinfo noprint pre legend" id="legend" onmouseout="hideElem('legend');" onmouseover="showElem('legend');" style="position:absolute; top: 4px; left: 4ex; visibility:hidden; background-color: white; padding: 4px 9px 5px 7px; border: solid #345 1px; ">
      </div>
   </div>
<span class="pre noprint docinfo top">[<a href="index.html" title="Document search and retrieval page">Docs</a>] [<a href="http://tools.ietf.org/rfc/rfc129.txt" title="Plaintext version of this document">txt</a>|<a href="http://tools.ietf.org/pdf/rfc129" title="PDF version of this document">pdf</a>]                                                        </span><br/>
<span class="pre noprint docinfo">                                                                        </span><br/>
<span class="pre noprint docinfo">Updated by: <a href="rfc147.html">147</a>                                                        </span><br/>
<span class="pre noprint docinfo">                                                                        </span><br/>
<pre>Network Working Group                         22 April 1971
Request for Comments:  129               E. E. Harslem-Rand
NIC 5845                                 J. F. Heafner-Rand
                                         E.    Meyer-MIT

                       A REQUEST FOR COMMENTS ON
                         SOCKET NAME STRUCTURE

INTRODUCTION

     This RFC is in answer to a request (made at the
February NWG Meeting at the University of Illinois) that
we comment on several suggested socket name structures.
We apologize for the delay in getting out these comments
and we hope that you will respond more quickly with your
reactions.
     Please direct your replies via the standard RFC
mechanism.
     Two structures are presented in this RFC as shown
below.

                        31                 1
          +-------------------------------+-+
     1.   |         Arbitrary             | | &lt;-- gender
          +-------------------------------+-+

                        24             7   1
          +------------------------+------+-+
     2.   |        User ID         | tag  | | &lt;-- gender
          +------------------------+------+-+

     Three variations are given for the way in which
socket names are assigned, as examples of use of the
first structure.
     1.   Users pick the arbitrary number arbitrarily
          and associate it with a process.
     2.   A logger chooses the arbitrary number dynamically
          and associates it with a process via a directory.
     3.   The arbitrary number is assigned outside of a
          logger but may be issued by a logger to the
          remote party.










<span class="grey">                                                                [Page 1]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-2" id="page-2" name="page-2"> </a>
<span class="grey">The second format shown above associates sockets specifi-</span>
cally with users as opposed to processes.
     The following discussion covers three different schemes
of socket identifier assignment using a simple example.
User A at Host A has agreed (by letter, telephone, etc.)
with User B at Host B for their respective processes to
establish a connection through the Network at a particular
time.  User B is to be waiting for the connection attempt
initiated by User A.  The issues to be faced are those of
addressing (how is User A to know to which socket to connect?),
and of security (how are both users to be confident that
they are talking each other, and not some interloper?).
     A fourth scheme follows which addresses another concept
of Network use--that connections are made between processes
and that processes not users should be identified via
Socket names.

FREELY SELECTED RANDOM SOCKET IDENTIFIERS (Scheme 1)

     Under this scheme a user is able to use any 32-bit
socket identifier he chooses.  Two restrictions apply:  the
least significant bit denotes the socket's gender (0-read,
1-write), and no more than one socket bearing a given iden-
tifier can be active at a host at a time.
     The two users select suitably random identifiers ("a"
and "b").  User A will attempt to activate his socket with
identifier "a" an connect it to socket "b" at Host B.  There
is the possibility that somebody other than User B has
activated socket "b" at Host B so that User A will address
the wrong  party.  However, the possibility that some other
user has accidentally picked this particular identifier is
reasonably small, since there are about a billion different
identifiers.  When the connection request from A gets to
User B, he examines the identifier of the calling socket.
If for some reasom it is not "a" or not from Host A, he
rejects the request, because it is likely to be from some















<span class="grey">                                                                [Page 2]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-3" id="page-3" name="page-3"> </a>
<span class="grey">outside party.  If the calling socket is named, "a" and</span>
from Host A, User B can be reasonably sure that it is from
User A.  It is very unlikely that some other party will
accidentally address socket "b" from a socket named "a".
     The advantages of this scheme are:  simplicity and
reasonable security in a non-malicious environment.  The
disadvantages are that there are possibilities from annoy-
ingly unavoidable conflicts with other users and that each
pair of users must conduct a prior confidential private
communication (as opposed to a broadcast announcement in
more secure schemes).

HOST-SELECTED IDENTIFIERS PLUS DIRECTORY (Scheme 2)

     This system uses the same socket identifier structure
as presented above, except that the Host picks the identi-
fier at the time the socket is assigned, and the user has no
no prior knowledge or control of the assignment.  By itself,
this system would be totally unusable, because there would
be no way for User A to address User B.  However, it allows
certain service functions (such as the Network logger) to
have specifically assigned sockets.
     One of these is a Network Directory service.  This
serves to relate a socket identifier at a particular host
to the name of the user operating it.  This might either
be a single distributed service, or there might be a separ-
ate service at each host.
     Under this scheme, each user, A and B, first activates
his socket (or somehow gets his host to assign and tell
him of a socket identifier).  Then he gets the Directory
module at his host to associate his name with the identi-
fier of the socket just activated.  Following this, User A
in some manner gets the Directory Service at Host B to tell
him the socket identifier assigned to User B.  Then User A
dispatches a connection request for this socket.
















<span class="grey">                                                                [Page 3]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-4" id="page-4" name="page-4"> </a>
<span class="grey">When User B gets the request, he similarly calls on the</span>
Directory service at Host A to find out the name of the user
who is operating the socket User B was called by.  If the
name is that of User A, User B can safely accept the request.
Otherwise, he rejects.
     This scheme is rather cumbersome, but some directory
services must exist for Host-selected socket identifiers to
work.  On advantage of the Directory Service is thst it
allows symbolic addressing.  A sizeable disadvantage in view
of its complexity is that it does not provide absolute
security.  (For exemple, after User A gets the identifier
of the socket he is to address, User B could deactivate it,
and somebody else could come along and get the same-named
socket.)

ADMINISTRATIVELY ASSIGNED USER IDENTIFIERS (Scheme 3)

     This is the system that is put forth on page 5 of
Protocol Document 1(8/3/70).  Under it a user is permanently
assigned a user identifier by his home host.  There is a
user identifier subfield within the socket identifier, and a
user is permitted by an NCP to operate only those sockets
bearing his uder identifier.  This gives the user a selec-
tion of 256 sockets operable by him.
     In arranging for the connection the two Users A and B
tell each other their user identifiers (alternatively a user
ID could be read from a directory), and User B specifies
which of his sockets ("b") that he will "listen" on.  At
connection time, User A selects one of his sockets and
requests connection for it to socket "b" specified by User B.
By protocol only User B can operate socket "b", so User A
can be certain of reaching the right party.
     When User B receives the connection request, he examines
the user identifier subfield of the calling socket identifier.
If it is the user identifier of User A, User B accepts the
connection request, confident that it is actually User A at
the other end.  Otherwise B rejects the request.














<span class="grey">                                                                [Page 4]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-5" id="page-5" name="page-5"> </a>
<span class="grey">The advantages of this scheme are that if both hosts</span>
involved in a connection enforce the user ID assignment,
the misconnection aspect of security is solved and there
can be no socket naming conflict between users.  Also,
arrangements can be made openly and publicly between many
potential communicators.  A disadvantage to this scheme is
that some systems may be incapable of insuring user ID
integrity.

<span class="h1"><a class="selflink" href="#appendix-A" name="appendix-A">A</a> VIEW OF SOCKET NAME MEANING (Scheme 4)</span>

     Another view of Network use is that programs will con-
nect to programs, via NCPs.  Some of these programs may be
multi-access subsystems that are really agents for local
consoles (and TELNETs).  Consoles will generally communicate
through some such software agent rather than directly to
an NCP.
     Programs, then, must have a fixed, unique identifier,
known to its remote users and perhaps to its local logger.
The identifier is constant; it does not change from day to
day.  If such a program is to allow multiple concurrent
connections (for many or a single user) then it must have
a range of variable identifiers as well.  It makes sense
to group these sockets in a contiguous range.  The variable
identifiers are transient and are dynamically associated
with Network logical connections.

      +---------------------   ---------------------+
      |                                           |
      | Fixed, unique       /  /  Variable          |
      | Identifier         /  /  Identifier         |
      |                                           |
      +---------------------   ---------------------+

      _________  _________/   _________  _________/
                /                       /
       Identifies the           Identifies a particular
       program uniquely         connection of the program













<span class="grey">                                                                [Page 5]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-6" id="page-6" name="page-6"> </a>
<span class="grey">The above premise is that the program (or agent) is</span>
doing the communicating with an NCP and thus needs to be
identified for message traffic routing from an NCP.  In
the past it has been said that users can be mobile, i.e.,
log on from different sites, and thus it is the user that
needs identification.  In many typical on-line systems the
user first requests a service and then identifies himself
to the service for purposes of accounting, etc.  User IDs
can be transmitted after requesting a service and can thus
be elevated above the meaning of socket names.
     A program might typically associate the terminals, for
which it is an agent, with the variable part of the identi-
fier, i.e., the particular connection(s).  For example,
the Network Services Program (NSP) at Rand now uses the
following format for socket names.  The first 24 bits are
administratively assigned and would be known to a logger.
The multiplex code is normally chosen randomly.  Predefined,
fixed multiplex codes are possible also.

                24                   7     1
       +------------------------+---------+-+
       | Program Number         |Multiplex| | &lt;-- Gender
       |                        |  Code   | |
       +------------------------+---------+-+

     The Socket name structure #1 (page 1) thus accomodates
the above example as well as other exploratory socket name
structures and various "standards" superimposed on the arbi-
trary field.


       [ This RFC was put into machine readable form for entry ]
         [ into the online RFC archives by Simone Demmel 4/97 ]


















                                                                [Page 6]

</pre><br/>
<span class="noprint"><small><small>Html markup produced by rfcmarkup 1.107, available from
<a href="http://tools.ietf.org/tools/rfcmarkup/">http://tools.ietf.org/tools/rfcmarkup/</a>
</small></small></span>



</body><!-- Mirrored from tools.ietf.org/html/rfc129 by HTTrack Website Copier/3.x [XR&CO'2013], Sat, 07 Jun 2014 20:18:58 GMT --></html>