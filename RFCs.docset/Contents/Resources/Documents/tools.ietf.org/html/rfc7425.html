<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml"><!-- Mirrored from tools.ietf.org/html/rfc7425 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 06 Mar 2018 23:18:21 GMT --><!-- Added by HTTrack --><head><meta content="text/html;charset=utf-8" http-equiv="content-type"/><!-- /Added by HTTrack -->

    <meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
    <meta content="index,follow" name="robots"/>
    <meta content="rfcmarkup version 1.126" name="creator"/>
    <link href="http://purl.org/dc/elements/1.1/" rel="schema.DC"/>
<meta content="urn:ietf:rfc:7425" name="DC.Identifier"/>
<meta content="This memo describes how to use Adobe's Secure Real-Time Media Flow
Protocol (RTMFP) to transport the video, audio, and data messages of
Adobe Flash platform communications. Aspects of this application
profile include cryptographic methods and data formats, flow metadata
formats, and protocol details for client-server and peer-to-peer
communication." name="DC.Description.Abstract"/>
<meta content="Michael Thornburgh &lt;mthornbu@adobe.com&gt;" name="DC.Creator"/>
<meta content="December, 2014" name="DC.Date.Issued"/>
<meta content="Adobe's RTMFP Profile for Flash Communication" name="DC.Title"/>

    <link href="https://tools.ietf.org/images/rfc.png" rel="icon" type="image/png"/>
    <link href="https://tools.ietf.org/images/rfc.png" rel="shortcut icon" type="image/png"/>
    <title>RFC 7425 - Adobe's RTMFP Profile for Flash Communication</title>
    
    
    <style type="text/css">
	@media only screen 
	  and (min-width: 992px)
	  and (max-width: 1199px) {
	    body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 768px)
	  and (max-width: 991px) {
            body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 480px)
	  and (max-width: 767px) {
            body { font-size: 11pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (max-width: 479px) {
            body { font-size: 8pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-device-width : 375px) 
	  and (max-device-width : 667px) {
            body { font-size: 9.5pt; }
            div.content { width: 96ex; margin: 0 1px; }
        }
	@media only screen 
	  and (min-device-width: 1200px) {
            body { font-size: 10pt; margin: 0 4em; }
            div.content { width: 96ex; margin: 0; }
        }
        h1, h2, h3, h4, h5, h6, .h1, .h2, .h3, .h4, .h5, .h6 {
	    font-weight: bold;
            line-height: 0pt;
            display: inline;
            white-space: pre;
            font-family: monospace;
            font-size: 1em;
	    font-weight: bold;
        }
        pre {
            font-size: 1em;
            margin-top: 0px;
            margin-bottom: 0px;
        }
	.pre {
	    white-space: pre;
	    font-family: monospace;
	}
	.header{
	    font-weight: bold;
	}
        .newpage {
            page-break-before: always;
        }
        .invisible {
            text-decoration: none;
            color: white;
        }
        a.selflink {
          color: black;
          text-decoration: none;
        }
        @media print {
            body {
                font-family: monospace;
                font-size: 10.5pt;
            }
            h1, h2, h3, h4, h5, h6 {
                font-size: 1em;
            }
        
            a:link, a:visited {
                color: inherit;
                text-decoration: none;
            }
            .noprint {
                display: none;
            }
        }
	@media screen {
	    .grey, .grey a:link, .grey a:visited {
		color: #777;
	    }
            .docinfo {
                background-color: #EEE;
            }
            .top {
                border-top: 7px solid #EEE;
            }
            .bgwhite  { background-color: white; }
            .bgred    { background-color: #F44; }
            .bggrey   { background-color: #666; }
            .bgbrown  { background-color: #840; }            
            .bgorange { background-color: #FA0; }
            .bgyellow { background-color: #EE0; }
            .bgmagenta{ background-color: #F4F; }
            .bgblue   { background-color: #66F; }
            .bgcyan   { background-color: #4DD; }
            .bggreen  { background-color: #4F4; }

            .legend   { font-size: 90%; }
            .cplate   { font-size: 70%; border: solid grey 1px; }
	}
    </style>
    <!--[if IE]>
    <style>
    body {
       font-size: 13px;
       margin: 10px 10px;
    }
    </style>
    <![endif]-->

    <script type="text/javascript"><!--
    function addHeaderTags() {
	var spans = document.getElementsByTagName("span");
	for (var i=0; i < spans.length; i++) {
	    var elem = spans[i];
	    if (elem) {
		var level = elem.getAttribute("class");
                if (level == "h1" || level == "h2" || level == "h3" || level == "h4" || level == "h5" || level == "h6") {
                    elem.innerHTML = "<"+level+">"+elem.innerHTML+"</"+level+">";		
                }
	    }
	}
    }
    var legend_html = "Colour legend:<br />      <table>         <tr><td>Unknown:</td>                   <td><span class='cplate bgwhite'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft:</td>                     <td><span class='cplate bgred'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Informational:</td>             <td><span class='cplate bgorange'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Experimental:</td>              <td><span class='cplate bgyellow'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Best Common Practice:</td>      <td><span class='cplate bgmagenta'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Proposed Standard:</td>         <td><span class='cplate bgblue'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft Standard (old designation):</td> <td><span class='cplate bgcyan'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Internet Standard:</td>         <td><span class='cplate bggreen'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Historic:</td>                  <td><span class='cplate bggrey'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Obsolete:</td>                  <td><span class='cplate bgbrown'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>     </table>";
    function showElem(id) {
        var elem = document.getElementById(id);
        elem.innerHTML = eval(id+"_html");
        elem.style.visibility='visible';
    }
    function hideElem(id) {
        var elem = document.getElementById(id);
        elem.style.visibility='hidden';        
        elem.innerHTML = "";
    }
    // -->
    </script>
</head>
<body onload="addHeaderTags()">
  <div class="content">
   <div style="height: 13px;">
      <div class="pre noprint docinfo bgorange" onclick="showElem('legend');" onmouseout="hideElem('legend')" onmouseover="this.style.cursor='pointer';" style="height: 6px; position: absolute;" title="Click for colour legend.">                                                                        </div>
      <div class="docinfo noprint pre legend" id="legend" onmouseout="hideElem('legend');" onmouseover="showElem('legend');" style="position:absolute; top: 4px; left: 4ex; visibility:hidden; background-color: white; padding: 4px 9px 5px 7px; border: solid #345 1px; ">
      </div>
   </div>
<span class="pre noprint docinfo top">[<a href="index.html" title="Document search and retrieval page">Docs</a>] [<a href="https://tools.ietf.org/rfc/rfc7425.txt" title="Plaintext version of this document">txt</a>|<a href="https://tools.ietf.org/pdf/rfc7425" title="PDF version of this document">pdf</a>] [<a href="https://tools.ietf.org/html/draft-thornburgh-rtmfp-flash" title="draft-thornburgh-rtmfp-flash">draft-thornburg...</a>] [<a href="https://datatracker.ietf.org/doc/rfc7425" title="IESG Datatracker information for this document">Tracker</a>] [<a href="https://tools.ietf.org/rfcdiff?difftype=--hwdiff&amp;url2=rfc7425" title="Inline diff (wdiff)">Diff1</a>] [<a href="https://tools.ietf.org/rfcdiff?url2=rfc7425" title="Side-by-side diff">Diff2</a>] [<a href="https://datatracker.ietf.org/ipr/search/?rfc=7425&amp;submit=rfc" title="IPR disclosures related to this document">IPR</a>]   </span><br/>
<span class="pre noprint docinfo">                                                                        </span><br/>
<span class="pre noprint docinfo">                                                           INFORMATIONAL</span><br/>
<span class="pre noprint docinfo">                                                                        </span><br/>
<pre>Independent Submission                                     M. Thornburgh
Request for Comments: 7425                                         Adobe
Category: Informational                                    December 2014
ISSN: 2070-1721


             <span class="h1">Adobe's RTMFP Profile for Flash Communication</span>

Abstract

   This memo describes how to use Adobe's Secure Real-Time Media Flow
   Protocol (RTMFP) to transport the video, audio, and data messages of
   Adobe Flash platform communications.  Aspects of this application
   profile include cryptographic methods and data formats, flow metadata
   formats, and protocol details for client-server and peer-to-peer
   communication.

Status of This Memo

   This document is not an Internet Standards Track specification; it is
   published for informational purposes.

   This is a contribution to the RFC Series, independently of any other
   RFC stream.  The RFC Editor has chosen to publish this document at
   its discretion and makes no statement about its value for
   implementation or deployment.  Documents approved for publication by
   the RFC Editor are not a candidate for any level of Internet
   Standard; see <a href="rfc5741.html#section-2">Section 2 of RFC 5741</a>.

   Information about the current status of this document, any errata,
   and how to provide feedback on it may be obtained at
   <a href="http://www.rfc-editor.org/info/rfc7425">http://www.rfc-editor.org/info/rfc7425</a>.

Copyright Notice

   Copyright (c) 2014 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to <a href="https://tools.ietf.org/html/bcp78">BCP 78</a> and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (<a href="http://trustee.ietf.org/license-info">http://trustee.ietf.org/license-info</a>) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.

   This document may not be modified, and derivative works of it may not
   be created, except to format it for publication as an RFC or to
   translate it into languages other than English.



<span class="grey">Thornburgh                    Informational                     [Page 1]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-2" id="page-2" name="page-2"> </a>
<span class="grey"><a href="rfc7425.html">RFC 7425</a>           Adobe RTMFP for Flash Communication     December 2014</span>


Table of Contents

   <a href="#section-1">1</a>. Introduction ....................................................<a href="#page-3">3</a>
   <a href="#section-2">2</a>. Terminology .....................................................<a href="#page-4">4</a>
   <a href="#section-3">3</a>. Common Syntax Elements ..........................................<a href="#page-4">4</a>
   <a href="#section-4">4</a>. Cryptography Profile ............................................<a href="#page-5">5</a>
      <a href="#section-4.1">4.1</a>. Default Session Key ........................................<a href="#page-5">5</a>
      <a href="#section-4.2">4.2</a>. Diffie-Hellman Groups ......................................<a href="#page-6">6</a>
      <a href="#section-4.3">4.3</a>. Certificates ...............................................<a href="#page-6">6</a>
           <a href="#section-4.3.1">4.3.1</a>. Format ..............................................<a href="#page-6">6</a>
           <a href="#section-4.3.2">4.3.2</a>. Fingerprint .........................................<a href="#page-7">7</a>
           <a href="#section-4.3.3">4.3.3</a>. Options .............................................<a href="#page-7">7</a>
                  <a href="#section-4.3.3.1">4.3.3.1</a>. Hostname ...................................<a href="#page-8">8</a>
                  <a href="#section-4.3.3.2">4.3.3.2</a>. Accepts Ancillary Data .....................<a href="#page-8">8</a>
                  <a href="#section-4.3.3.3">4.3.3.3</a>. Extra Randomness ...........................<a href="#page-8">8</a>
                  <a href="#section-4.3.3.4">4.3.3.4</a>. Supported Ephemeral Diffie-Hellman Group ...<a href="#page-9">9</a>
                  <a href="#section-4.3.3.5">4.3.3.5</a>. Static Diffie-Hellman Public Key ...........<a href="#page-9">9</a>
           <a href="#section-4.3.4">4.3.4</a>. Authenticity .......................................<a href="#page-10">10</a>
           <a href="#section-4.3.5">4.3.5</a>. Signing and Verifying Messages .....................<a href="#page-10">10</a>
                  <a href="#section-4.3.5.1">4.3.5.1</a>. Options ...................................<a href="#page-11">11</a>
                           <a href="#section-4.3.5.1.1">4.3.5.1.1</a>. Simple Password ................<a href="#page-11">11</a>
           <a href="#section-4.3.6">4.3.6</a>. Glare Resolution ...................................<a href="#page-13">13</a>
           <a href="#section-4.3.7">4.3.7</a>. Session Override ...................................<a href="#page-13">13</a>
      <a href="#section-4.4">4.4</a>. Endpoint Discriminators ...................................<a href="#page-13">13</a>
           <a href="#section-4.4.1">4.4.1</a>. Format .............................................<a href="#page-14">14</a>
           <a href="#section-4.4.2">4.4.2</a>. Options ............................................<a href="#page-14">14</a>
                  <a href="#section-4.4.2.1">4.4.2.1</a>. Required Hostname .........................<a href="#page-15">15</a>
                  <a href="#section-4.4.2.2">4.4.2.2</a>. Ancillary Data ............................<a href="#page-15">15</a>
                  <a href="#section-4.4.2.3">4.4.2.3</a>. Fingerprint ...............................<a href="#page-16">16</a>
           <a href="#section-4.4.3">4.4.3</a>. Certificate Selection ..............................<a href="#page-16">16</a>
           <a href="#section-4.4.4">4.4.4</a>. Canonical Endpoint Discriminator ...................<a href="#page-17">17</a>
      <a href="#section-4.5">4.5</a>. Session Keying Components .................................<a href="#page-18">18</a>
           <a href="#section-4.5.1">4.5.1</a>. Format .............................................<a href="#page-19">19</a>
           <a href="#section-4.5.2">4.5.2</a>. Options ............................................<a href="#page-19">19</a>
                  <a href="#section-4.5.2.1">4.5.2.1</a>. Ephemeral Diffie-Hellman Public Key .......<a href="#page-20">20</a>
                  <a href="#section-4.5.2.2">4.5.2.2</a>. Extra Randomness ..........................<a href="#page-20">20</a>
                  <a href="#section-4.5.2.3">4.5.2.3</a>. Diffie-Hellman Group Select ...............<a href="#page-21">21</a>
                  <a href="#section-4.5.2.4">4.5.2.4</a>. HMAC Negotiation ..........................<a href="#page-21">21</a>
                  <a href="#section-4.5.2.5">4.5.2.5</a>. Session Sequence Number Negotiation .......<a href="#page-22">22</a>
      <a href="#section-4.6">4.6</a>. Session Key Computation ...................................<a href="#page-23">23</a>
           <a href="#section-4.6.1">4.6.1</a>. Public Key Selection ...............................<a href="#page-23">23</a>
                  <a href="#section-4.6.1.1">4.6.1.1</a>. Initiator and Responder Ephemeral .........<a href="#page-23">23</a>
                  <a href="#section-4.6.1.2">4.6.1.2</a>. Initiator Ephemeral and Responder Static ..23
                  <a href="#section-4.6.1.3">4.6.1.3</a>. Initiator Static and Responder Ephemeral ..24
                  <a href="#section-4.6.1.4">4.6.1.4</a>. Initiator and Responder Static ............<a href="#page-24">24</a>
           <a href="#section-4.6.2">4.6.2</a>. Diffie-Hellman Shared Secret .......................<a href="#page-24">24</a>
           <a href="#section-4.6.3">4.6.3</a>. Packet Encrypt/Decrypt Keys ........................<a href="#page-25">25</a>
           <a href="#section-4.6.4">4.6.4</a>. Packet HMAC Send/Receive Keys ......................<a href="#page-25">25</a>



<span class="grey">Thornburgh                    Informational                     [Page 2]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-3" id="page-3" name="page-3"> </a>
<span class="grey"><a href="rfc7425.html">RFC 7425</a>           Adobe RTMFP for Flash Communication     December 2014</span>


           <a href="#section-4.6.5">4.6.5</a>. Session Nonces .....................................<a href="#page-26">26</a>
           <a href="#section-4.6.6">4.6.6</a>. Session Sequence Number ............................<a href="#page-26">26</a>
      <a href="#section-4.7">4.7</a>. Packet Encryption .........................................<a href="#page-27">27</a>
           <a href="#section-4.7.1">4.7.1</a>. Cipher .............................................<a href="#page-27">27</a>
           <a href="#section-4.7.2">4.7.2</a>. Format .............................................<a href="#page-27">27</a>
           <a href="#section-4.7.3">4.7.3</a>. Verification .......................................<a href="#page-29">29</a>
                  <a href="#section-4.7.3.1">4.7.3.1</a>. Simple Checksum ...........................<a href="#page-30">30</a>
                  <a href="#section-4.7.3.2">4.7.3.2</a>. HMAC ......................................<a href="#page-30">30</a>
                  <a href="#section-4.7.3.3">4.7.3.3</a>. Session Sequence Number ...................<a href="#page-31">31</a>
   <a href="#section-5">5</a>. Flash Communication ............................................<a href="#page-31">31</a>
      <a href="#section-5.1">5.1</a>. RTMP Messages .............................................<a href="#page-31">31</a>
           <a href="#section-5.1.1">5.1.1</a>. Flow Metadata ......................................<a href="#page-32">32</a>
           <a href="#section-5.1.2">5.1.2</a>. Message Mapping ....................................<a href="#page-34">34</a>
      <a href="#section-5.2">5.2</a>. Flow Synchronization ......................................<a href="#page-35">35</a>
      <a href="#section-5.3">5.3</a>. Client-to-Server Connection ...............................<a href="#page-36">36</a>
           <a href="#section-5.3.1">5.3.1</a>. Connecting .........................................<a href="#page-36">36</a>
           <a href="#section-5.3.2">5.3.2</a>. Server-to-Client Return Control Flow ...............<a href="#page-37">37</a>
           <a href="#section-5.3.3">5.3.3</a>. setPeerInfo Command ................................<a href="#page-37">37</a>
           <a href="#section-5.3.4">5.3.4</a>. Set Keepalive Timers Command .......................<a href="#page-39">39</a>
           <a href="#section-5.3.5">5.3.5</a>. Additional Flows for Streams .......................<a href="#page-40">40</a>
                  <a href="#section-5.3.5.1">5.3.5.1</a>. To Server .................................<a href="#page-40">40</a>
                  <a href="#section-5.3.5.2">5.3.5.2</a>. From Server ...............................<a href="#page-40">40</a>
                  <a href="#section-5.3.5.3">5.3.5.3</a>. Closing Stream Flows ......................<a href="#page-41">41</a>
           <a href="#section-5.3.6">5.3.6</a>. Closing the Connection .............................<a href="#page-41">41</a>
           <a href="#section-5.3.7">5.3.7</a>. Example ............................................<a href="#page-42">42</a>
      <a href="#section-5.4">5.4</a>. Direct Peer-to-Peer Streams ...............................<a href="#page-43">43</a>
           <a href="#section-5.4.1">5.4.1</a>. Connecting .........................................<a href="#page-43">43</a>
           <a href="#section-5.4.2">5.4.2</a>. Return Flows for Stream ............................<a href="#page-43">43</a>
           <a href="#section-5.4.3">5.4.3</a>. Closing the Connection .............................<a href="#page-44">44</a>
   <a href="#section-6">6</a>. IANA Considerations ............................................<a href="#page-44">44</a>
      <a href="#section-6.1">6.1</a>. RTMFP URI Scheme Registration .............................<a href="#page-44">44</a>
   <a href="#section-7">7</a>. Security Considerations ........................................<a href="#page-46">46</a>
   <a href="#section-8">8</a>. References .....................................................<a href="#page-47">47</a>
      <a href="#section-8.1">8.1</a>. Normative References ......................................<a href="#page-47">47</a>
      <a href="#section-8.2">8.2</a>. Informative References ....................................<a href="#page-49">49</a>
   Acknowledgements ..................................................<a href="#page-49">49</a>
   Author's Address ..................................................<a href="#page-49">49</a>

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/1.%20%20Introduction"></a><a class="selflink" href="#section-1" name="section-1">1</a>.  Introduction</span>

   Adobe's Secure Real-Time Media Flow Protocol (RTMFP) [<a href="rfc7016.html" title="&quot;Adobe's Secure Real-Time Media Flow Protocol&quot;">RFC7016</a>] is a
   general-purpose transport service for real-time media and bulk data
   in IP networks, and it is suited to client-server and peer-to-peer
   (P2P) communication.  RTMFP provides a generalized framework for
   securing its communications according to the needs of its
   application.





<span class="grey">Thornburgh                    Informational                     [Page 3]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-4" id="page-4" name="page-4"> </a>
<span class="grey"><a href="rfc7425.html">RFC 7425</a>           Adobe RTMFP for Flash Communication     December 2014</span>


   The Flash platform comprises the Flash runtime (including Flash
   Player) from Adobe Systems Incorporated, communication servers such
   as Adobe Media Server, and interoperable clients and servers provided
   by other parties.

   Real-time streaming network communication for the Flash platform of
   video, audio, and data typically uses Adobe's Real-Time Messaging
   Protocol (RTMP) [<a href="#ref-RTMP" title='"Real-Time Messaging Protocol (RTMP) specification"'>RTMP</a>] messages.  RTMP messages were originally
   designed to be transported over RTMP Chunk Stream in TCP [<a href="#ref-RTMP" title='"Real-Time Messaging Protocol (RTMP) specification"'>RTMP</a>];
   however, other transports (such as the one described in this memo)
   are possible.

   This memo specifies the syntax and semantics for transporting RTMP
   messages over RTMFP, and it extends Flash communication semantics to
   include direct P2P communication.  This memo further specifies a
   concrete Cryptography Profile for RTMFP tailored to the application
   and cryptographic needs of Flash platform client-server and P2P
   communications.

   These protocols and profiles were developed by Adobe Systems
   Incorporated and are not the product of an IETF activity.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/2.%20%20Terminology"></a><a class="selflink" href="#section-2" name="section-2">2</a>.  Terminology</span>

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
   "OPTIONAL" in this document are to be interpreted as described in
   [<a href="rfc2119.html" title='"Key words for use in RFCs to Indicate Requirement Levels"'>RFC2119</a>].

   "HMAC" means the Keyed-Hash Message Authentication Code (HMAC)
   algorithm [<a href="rfc2104.html" title='"HMAC: Keyed- Hashing for Message Authentication"'>RFC2104</a>].

   "HMAC-SHA256" means HMAC using the SHA-256 Secure Hash Algorithm
   [<a href="#ref-SHA256" title='"Secure Hash Standard"'>SHA256</a>] [<a href="rfc6234.html" title='"US Secure Hash Algorithms (SHA and SHA-based HMAC and HKDF)"'>RFC6234</a>].

   "HMAC-SHA256(K, M)" means the calculation of the HMAC-SHA256 of
   message M using key K.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/3.%20%20Common%20Syntax%20Elements"></a><a class="selflink" href="#section-3" name="section-3">3</a>.  Common Syntax Elements</span>

   Definitions of types and structures in this specification use
   traditional text diagrams paired with procedural descriptions using a
   C-like syntax.  The C-like procedural descriptions SHALL be construed
   as definitive.







<span class="grey">Thornburgh                    Informational                     [Page 4]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-5" id="page-5" name="page-5"> </a>
<span class="grey"><a href="rfc7425.html">RFC 7425</a>           Adobe RTMFP for Flash Communication     December 2014</span>


   Structures are packed to take only as many bytes as explicitly
   indicated.  There is no 32-bit alignment constraint, and fields are
   not padded for alignment unless explicitly indicated or described.
   Text diagrams may include a bit ruler across the top; this is a
   convenience for counting bits in individual fields and does not
   necessarily imply field alignment on a multiple of the ruler width.

   Unless specified otherwise, reserved fields SHOULD be set to 0 by a
   sender and MUST be ignored by a receiver.

   The procedural syntax of this specification defines correct and
   error-free encoded inputs to a parser.  The procedural syntax does
   not describe a fully featured parser, including error detection and
   handling.  Implementations MUST include means to identify error
   circumstances, including truncations causing elementary or composed
   types not to fit inside containing structures, fields, or elements.
   Unless specified otherwise, an error circumstance SHALL abort the
   parsing and processing of an element and its enclosing elements.

   This memo uses the elementary and composed types described in
   <a href="rfc7016.html#section-2.1">Section 2.1 of RFC 7016</a>.  The definitions of that section are
   incorporated by reference as though fully set forth here.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/4.%20%20Cryptography%20Profile"></a><a class="selflink" href="#section-4" name="section-4">4</a>.  Cryptography Profile</span>

   RTMFP defines a general security framework but delegates specifics,
   such as packet encryption ciphers and key agreement algorithms, to an
   application-defined Cryptography Profile.

   This section defines the RTMFP Cryptography Profile for Flash
   platform communication.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.1.%20%20Default%20Session%20Key"></a><a class="selflink" href="#section-4.1" name="section-4.1">4.1</a>.  Default Session Key</span>

   RTMFP uses a Default Session Key and associated default cipher
   configuration during session startup handshaking, where session-
   specific keys and ciphers are negotiated.

   The default cipher is the Advanced Encryption Standard [<a href="#ref-AES" title='"Advanced Encryption Standard (AES)"'>AES</a>] with
   128-bit keys operating in Cipher Block Chaining [<a href="#ref-CBC" title='"Recommendation for Block Cipher Modes of Operation"'>CBC</a>] mode, as
   described in <a href="#section-4.7.1">Section 4.7.1</a>.  The Default Session Key is the 16 bytes
   of the string "Adobe Systems 02" encoded in UTF-8 [<a href="rfc3629.html" title='"UTF-8, a transformation format of ISO 10646"'>RFC3629</a>]:

           Hex: 41 64 6F 62 65 20 53 79 73 74 65 6D 73 20 30 32

   The Default Session Key uses checksum mode for packet verification
   and does not use session sequence numbers (<a href="#section-4.7.3">Section 4.7.3</a>).




<span class="grey">Thornburgh                    Informational                     [Page 5]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-6" id="page-6" name="page-6"> </a>
<span class="grey"><a href="rfc7425.html">RFC 7425</a>           Adobe RTMFP for Flash Communication     December 2014</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.2.%20%20Diffie-Hellman%20Groups"></a><a class="selflink" href="#section-4.2" name="section-4.2">4.2</a>.  Diffie-Hellman Groups</span>

   Implementations conforming to this profile MUST support Diffie-
   Hellman [<a href="#ref-DH" title='"New Directions in Cryptography"'>DH</a>] modular exponentiation (MODP) group 2 (1024 bits) as
   defined in [<a href="rfc7296.html" title='"Internet Key Exchange Protocol Version 2 (IKEv2)"'>RFC7296</a>], and SHOULD support Diffie-Hellman MODP group 5
   (1536 bits) and group 14 (2048 bits) as defined in [<a href="rfc3526.html" title='"More Modular Exponential (MODP) Diffie-Hellman groups for Internet Key Exchange (IKE)"'>RFC3526</a>].
   Implementations MAY support additional groups.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.3.%20%20Certificates"></a><a class="selflink" href="#section-4.3" name="section-4.3">4.3</a>.  Certificates</span>

   This section defines the certificate format for this Cryptography
   Profile, and the mapping to the abstract properties and semantics for
   RTMFP endpoint identities.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/4.3.1.%20%20Format"></a><a class="selflink" href="#section-4.3.1" name="section-4.3.1">4.3.1</a>.  Format</span>

   A certificate in this profile is encoded as a sequence of zero or
   more RTMFP Options and Markers (<a href="rfc7016.html#section-2.1.3">Section 2.1.3 of RFC 7016</a>).  The
   first marker (if any) in the certificate separates the canonical
   section of the certificate from the remainder.  Some options are
   ignored if they occur outside of the canonical section (that is,
   after the first marker).





























<span class="grey">Thornburgh                    Informational                     [Page 6]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-7" id="page-7" name="page-7"> </a>
<span class="grey"><a href="rfc7425.html">RFC 7425</a>           Adobe RTMFP for Flash Communication     December 2014</span>


   +~~~/~~~/~~~+   +~~~/~~~/~~~+~~~~~+~~~/~~~/~~~+   +~~~/~~~/~~~+
   | L \ T \ V |...| L \ T \ V |  0  | L \ T \ V |...| L \ T \ V |
   +~~~/~~~/~~~+   +~~~/~~~/~~~+~~~~~+~~~/~~~/~~~+   +~~~/~~~/~~~+
   ^                           ^  ^  ^                           ^
   |  Zero or more non-empty   |  |  |   Zero or more Options    |
   |         Options           |  |  +------  or Markers  -------+
   |                           |  |
   +---  Canonical Section  ---+  +---- First Marker
                                        (if present)

   struct certificate_t
   {
       canonicalStart = remainder();
       canonicalEnd = remainder();
       markerFound = false;

       while(remainder() &gt; 0)
       {
           option_t option :variable*8;

           if(0 == option.length)
               markerFound = true;
           else if(!markerFound)
               canonicalEnd = remainder();
       };

       canonicalSectionLength = canonicalStart - canonicalEnd;
   } :variable*8;

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/4.3.2.%20%20Fingerprint"></a><a class="selflink" href="#section-4.3.2" name="section-4.3.2">4.3.2</a>.  Fingerprint</span>

   A certificate's fingerprint is the SHA-256 hash [<a href="#ref-SHA256" title='"Secure Hash Standard"'>SHA256</a>] of the
   canonical section of the certificate (that is, the hash of the first
   canonicalSectionLength bytes of the certificate).

   The certificate's fingerprint is also called the "peer ID".

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/4.3.3.%20%20Options"></a><a class="selflink" href="#section-4.3.3" name="section-4.3.3">4.3.3</a>.  Options</span>

   This section lists options that can appear in a certificate.  The
   following option type codes are defined:

   0x00:    Hostname (must be in canonical section) (<a href="#section-4.3.3.1">Section 4.3.3.1</a>)

   0x0a:    Accepts Ancillary Data (must be in canonical section)
            (<a href="#section-4.3.3.2">Section 4.3.3.2</a>)

   0x0e:    Extra Randomness (<a href="#section-4.3.3.3">Section 4.3.3.3</a>)



<span class="grey">Thornburgh                    Informational                     [Page 7]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-8" id="page-8" name="page-8"> </a>
<span class="grey"><a href="rfc7425.html">RFC 7425</a>           Adobe RTMFP for Flash Communication     December 2014</span>


   0x15:    Supported Ephemeral Diffie-Hellman Group (must be in
            canonical section) (<a href="#section-4.3.3.4">Section 4.3.3.4</a>)

   0x1d:    Static Diffie-Hellman Public Key (must be in canonical
            section) (<a href="#section-4.3.3.5">Section 4.3.3.5</a>)

   An implementation MUST ignore a certificate option type that is not
   understood.

<span class="h5"><a class="dashAnchor" name="//apple_ref/Section/4.3.3.1.%20%20Hostname"></a><a class="selflink" href="#section-4.3.3.1" name="section-4.3.3.1">4.3.3.1</a>.  Hostname</span>

   This option gives an optional hostname for the endpoint.  This option
   MUST be ignored if is not in the canonical section.  This option MUST
   NOT occur more than once in a certificate.

   +-------------/-+-------------/-+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+
   |   length    \ |     0x00    \ |         hostname              |
   +-------------/-+-------------/-+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~/

   struct hostnameCertOptionValue_t
   {
       uint8_t hostname[remainder()];
   } :remainder()*8;

<span class="h5"><a class="dashAnchor" name="//apple_ref/Section/4.3.3.2.%20%20Accepts%20Ancillary%20Data"></a><a class="selflink" href="#section-4.3.3.2" name="section-4.3.3.2">4.3.3.2</a>.  Accepts Ancillary Data</span>

   This option indicates that the endpoint will accept an Endpoint
   Discriminator encoding an Ancillary Data option (<a href="#section-4.4.2.2">Section 4.4.2.2</a>).
   This option MUST be ignored if it is not in the canonical section.

   +-------------/-+-------------/-+
   |   length    \ |     0x0a    \ |
   +-------------/-+-------------/-+

<span class="h5"><a class="dashAnchor" name="//apple_ref/Section/4.3.3.3.%20%20Extra%20Randomness"></a><a class="selflink" href="#section-4.3.3.3" name="section-4.3.3.3">4.3.3.3</a>.  Extra Randomness</span>

   This option can be used to add extra entropy or randomness to a
   certificate that doesn't have any other cryptographic pseudorandom
   members (such as a public key).  This option is typically used so
   that endpoints using ephemeral Diffie-Hellman keying can have a
   unique certificate fingerprint.










<span class="grey">Thornburgh                    Informational                     [Page 8]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-9" id="page-9" name="page-9"> </a>
<span class="grey"><a href="rfc7425.html">RFC 7425</a>           Adobe RTMFP for Flash Communication     December 2014</span>


   +-------------/-+-------------/-+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+
   |   length    \ |     0x0e    \ |       extra randomness        |
   +-------------/-+-------------/-+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~/

   struct extraRandomnessCertOptionValue_t
   {
       uint_t extraRandomness[remainder()];
   } :remainder()*8;

<span class="h5"><a class="dashAnchor" name="//apple_ref/Section/4.3.3.4.%20%20Supported%20Ephemeral%20Diffie-Hellman%20Group"></a><a class="selflink" href="#section-4.3.3.4" name="section-4.3.3.4">4.3.3.4</a>.  Supported Ephemeral Diffie-Hellman Group</span>

   This option specifies a Diffie-Hellman group ID that is supported for
   ephemeral keying.  This option MUST be ignored if it is not in the
   canonical section.  This option may occur more than once in the
   certificate; each instance indicates an additional group that is
   supported for key agreement.

   +-------------/-+-------------/-+-------------/-+
   |   length    \ |     0x15    \ |   group ID  \ |
   +-------------/-+-------------/-+-------------/-+

   struct ephemeralDHGroupCertOptionValue_t
   {
       vlu_t groupID :variable*8;
   } :variable*8;

   The presence of this option means that the certificate uses ephemeral
   Diffie-Hellman public keys only.  The certificate MUST NOT contain a
   Static Diffie-Hellman public key (<a href="#section-4.3.3.5">Section 4.3.3.5</a>).

<span class="h5"><a class="dashAnchor" name="//apple_ref/Section/4.3.3.5.%20%20Static%20Diffie-Hellman%20Public%20Key"></a><a class="selflink" href="#section-4.3.3.5" name="section-4.3.3.5">4.3.3.5</a>.  Static Diffie-Hellman Public Key</span>

   This option specifies a Diffie-Hellman group ID and static public key
   in that group.  This option MUST be ignored if it is not in the
   canonical section.  This option MAY occur more than once in the
   certificate; however, this option SHOULD NOT occur more than once for
   each group ID.  The behavior for specifying more than one public key
   per group ID is not defined.













<span class="grey">Thornburgh                    Informational                     [Page 9]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-10" id="page-10" name="page-10"> </a>
<span class="grey"><a href="rfc7425.html">RFC 7425</a>           Adobe RTMFP for Flash Communication     December 2014</span>


   +-------------/-+-------------/-+-------------/-+
   |   length    \ |     0x1d    \ |   group ID  \ |
   +-------------/-+-------------/-+-------------/-+
   +------------------------------------------------------------------+
   |                  Diffie-Hellman Public Key                       |
   +------------------------------------------------------------------/

   struct staticDHPublicKeyCertOptionValue_t
   {
       vlu_t   groupID :variable*8;
       uintn_t publicKey :remainder()*8; // network byte order
   } :remainder()*8;

   The presence of this option means that the certificate uses static
   Diffie-Hellman public keys only.  The certificate MUST NOT contain
   any Supported Ephemeral Diffie-Hellman Group options
   (<a href="#section-4.3.3.4">Section 4.3.3.4</a>).

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/4.3.4.%20%20Authenticity"></a><a class="selflink" href="#section-4.3.4" name="section-4.3.4">4.3.4</a>.  Authenticity</span>

   This profile does not use a public key infrastructure, nor are there
   signing keys present in certificates.  Therefore, any properly
   encoded certificate is considered authentic according to <a href="rfc7016.html#section-3.2">Section 3.2
   of RFC 7016</a>.

   A certificate containing a static public key can only be used
   successfully for session communication if the holder of the
   certificate actually holds the private key associated with the public
   key.  Authenticity of an identity and its peer ID (<a href="#section-4.3.2">Section 4.3.2</a>)
   having a certificate containing a static public key is implied by
   successful encrypted communication with the associated endpoint
   (<a href="#section-4.6">Section 4.6</a>).

   See <a href="#section-7">Section 7</a> for further discussion of security issues related to
   identities.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/4.3.5.%20%20Signing%20and%20Verifying%20Messages"></a><a class="selflink" href="#section-4.3.5" name="section-4.3.5">4.3.5</a>.  Signing and Verifying Messages</span>

   RTMFP Initiator Initial Keying and Responder Initial Keying messages
   have a field for the sender's digital signature of the keying
   parameters (Sections <a href="#section-2.3.7">2.3.7</a> and <a href="#section-2.3.8">2.3.8</a> of <a href="rfc7016.html">RFC 7016</a>).  In this profile,
   the signature field of those messages is encoded as a sequence of
   zero or more RTMFP Options.








<span class="grey">Thornburgh                    Informational                    [Page 10]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-11" id="page-11" name="page-11"> </a>
<span class="grey"><a href="rfc7425.html">RFC 7425</a>           Adobe RTMFP for Flash Communication     December 2014</span>


   +~~~/~~~/~~~~~~~+               +~~~/~~~/~~~~~~~+
   | L \ T \   V   |...............| L \ T \   V   |
   +~~~/~~~/~~~~~~~+               +~~~/~~~/~~~~~~~+
   ^                                               ^
   +-------------  Zero or more Options  ----------+

   struct initialKeyingSignature_t
   {
       while(remainder() &gt; 0)
           option_t option :variable*8;
   } :remainder()*8;

   If a signer has no signature options to send, it MAY encode a
   signature as a UTF-8 capital "X" (hex 58) or as empty.  A verifier
   MUST interpret a malformed signature field or a signature field
   consisting only of a UTF-8 capital "X" as though it was empty.

   If a verifier does not require a signature, it SHALL consider any
   signature field (including an empty or malformed one) to be valid.  A
   verifier MAY require a signature comprising one or more non-empty
   options that are valid according to their respective types.

   This profile does not use a public key infrastructure, nor are there
   signing keys present in certificates.  <a href="#section-4.3.5.1.1">Section 4.3.5.1.1</a> defines a
   simple ID/password credential system.

<span class="h5"><a class="dashAnchor" name="//apple_ref/Section/4.3.5.1.%20%20Options"></a><a class="selflink" href="#section-4.3.5.1" name="section-4.3.5.1">4.3.5.1</a>.  Options</span>

   This section lists options that can appear in an RTMFP Initial Keying
   signature field.  The following option type code is defined:

   0x1d:  Simple Password (<a href="#section-4.3.5.1.1">Section 4.3.5.1.1</a>)

   Future or derived profiles may define additional signature field
   options and semantics; therefore, a verifier SHOULD ignore option
   types that are not understood.

<span class="h6"><a class="dashAnchor" name="//apple_ref/Section/4.3.5.1.1.%20%20Simple%20Password"></a><a class="selflink" href="#section-4.3.5.1.1" name="section-4.3.5.1.1">4.3.5.1.1</a>.  Simple Password</span>

   This option encodes a password identifier (such as a user name, or an
   application-specific or implementation-specific selector) and an HMAC
   over the signed parameters using the identified password as the HMAC
   key.  This option can occur more than once (for example, to allow
   interoperation between a current and a previous version of an
   implementation using implementation-specific passwords).






<span class="grey">Thornburgh                    Informational                    [Page 11]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-12" id="page-12" name="page-12"> </a>
<span class="grey"><a href="rfc7425.html">RFC 7425</a>           Adobe RTMFP for Flash Communication     December 2014</span>


   To support the versioning use case, a verifier SHOULD ignore a Simple
   Password option encoding an unrecognized password identifier.  A
   verifier SHOULD treat the entire signature as invalid if any Simple
   Password option encodes a recognized password identifier with an
   invalid password HMAC.

    0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7
   +-------------/-+-------------/-+
   |   length    \ |     0x1d    \ |
   +-------------/-+-------------/-+
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   + - - - - - - - + - - - - - - - + - - - - - - - + - - - - - - - +
   |                                                               |
   + - - - - - - - + - - - - - - - + - - - - - - - + - - - - - - - +
   |                                                               |
   + - - - - - - - + - - - - - - - + - - - - - - - + - - - - - - - +
   |                           hmacSHA256                          |
   + - - - - - - - + - - - - - - - + - - - - - - - + - - - - - - - +
   |                                                               |
   + - - - - - - - + - - - - - - - + - - - - - - - + - - - - - - - +
   |                                                               |
   + - - - - - - - + - - - - - - - + - - - - - - - + - - - - - - - +
   |                                                               |
   + - - - - - - - + - - - - - - - + - - - - - - - + - - - - - - - +
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+
   |                           passwordID                          |
   +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~/

   struct simplePasswordSignatureOptionValue_t
   {
       uint8_t hmacSHA256[32];
       uint8_t passwordID[remainder()];
   } :remainder()*8;

   hmacSHA256:  HMAC-SHA256(K, M), where K is the password associated
      with passwordID, and M is the signed parameters.

   passwordID:  The identifier (such as a user name) for the password
      used as the HMAC key.









<span class="grey">Thornburgh                    Informational                    [Page 12]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-13" id="page-13" name="page-13"> </a>
<span class="grey"><a href="rfc7425.html">RFC 7425</a>           Adobe RTMFP for Flash Communication     December 2014</span>


<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/4.3.6.%20%20Glare%20Resolution"></a><a class="selflink" href="#section-4.3.6" name="section-4.3.6">4.3.6</a>.  Glare Resolution</span>

   Glare occurs when two endpoints initiate a session each to the other
   concurrently.

   Compare the near end's certificate to the far end's with a binary
   lexicographic comparison, one byte at a time, up to the length of the
   shorter certificate.  At the first corresponding byte from each
   certificate that is different, the certificate having the differing
   byte (treated as an unsigned 8-bit integer) with the lower value is
   ordered before the other certificate.  If the certificates are not
   the same length and they are identical up to the length of the
   shorter certificate, then the shorter certificate is ordered before
   the longer.

   The near end prevails as the Initiator in case of glare if its
   certificate is ordered before, or is identical to, the certificate of
   the far end.  Otherwise, the near end's certificate is ordered after
   the far end's certificate, and the near end assumes the role of
   Responder.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/4.3.7.%20%20Session%20Override"></a><a class="selflink" href="#section-4.3.7" name="section-4.3.7">4.3.7</a>.  Session Override</span>

   A new incoming session overrides an existing session only if the
   certificate for the new session is identical to the certificate for
   the existing session.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.4.%20%20Endpoint%20Discriminators"></a><a class="selflink" href="#section-4.4" name="section-4.4">4.4</a>.  Endpoint Discriminators</span>

   This section describes the Endpoint Discriminator (EPD) (<a href="rfc7016.html#section-3.2">Section 3.2
   of RFC 7016</a>) format and semantics for this Cryptography Profile, and
   the mapping to RTMFP's abstract certificate and identity selection
   semantics.


















<span class="grey">Thornburgh                    Informational                    [Page 13]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-14" id="page-14" name="page-14"> </a>
<span class="grey"><a href="rfc7425.html">RFC 7425</a>           Adobe RTMFP for Flash Communication     December 2014</span>


<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/4.4.1.%20%20Format"></a><a class="selflink" href="#section-4.4.1" name="section-4.4.1">4.4.1</a>.  Format</span>

   An EPD in this profile is encoded as a sequence of zero or more RTMFP
   Options.

   +~~~/~~~/~~~~~~~+               +~~~/~~~/~~~~~~~+
   | L \ T \   V   |...............| L \ T \   V   |
   +~~~/~~~/~~~~~~~+               +~~~/~~~/~~~~~~~+
   ^                                               ^
   +-------------  Zero or more Options  ----------+

   struct endpointDiscriminator_t
   {
       while(remainder() &gt; 0)
           option_t option :variable*8;
   } :remainder()*8;

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/4.4.2.%20%20Options"></a><a class="selflink" href="#section-4.4.2" name="section-4.4.2">4.4.2</a>.  Options</span>

   This section lists options that can appear in an EPD.  The following
   option type codes are defined:

   0x00:  Required Hostname (<a href="#section-4.4.2.1">Section 4.4.2.1</a>)

   0x0a:  Ancillary Data (<a href="#section-4.4.2.2">Section 4.4.2.2</a>)

   0x0f:  Fingerprint (<a href="#section-4.4.2.3">Section 4.4.2.3</a>)

   The use of these options for selecting certificates is described in
   <a href="#section-4.4.3">Section 4.4.3</a>.

   An implementation MUST ignore EPD option types that are not
   understood.


















<span class="grey">Thornburgh                    Informational                    [Page 14]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-15" id="page-15" name="page-15"> </a>
<span class="grey"><a href="rfc7425.html">RFC 7425</a>           Adobe RTMFP for Flash Communication     December 2014</span>


<span class="h5"><a class="dashAnchor" name="//apple_ref/Section/4.4.2.1.%20%20Required%20Hostname"></a><a class="selflink" href="#section-4.4.2.1" name="section-4.4.2.1">4.4.2.1</a>.  Required Hostname</span>

   This option indicates the hostname to match against the certificate's
   Hostname option (<a href="#section-4.3.3.1">Section 4.3.3.1</a>).

   +-------------/-+-------------/-+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+
   |   length    \ |     0x00    \ |         hostname              |
   +-------------/-+-------------/-+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~/

   struct hostnameEPDOptionValue_t
   {
       uint8_t hostname[remainder()];
   } :remainder()*8;

   This option MUST NOT occur more than once in an EPD.

<span class="h5"><a class="dashAnchor" name="//apple_ref/Section/4.4.2.2.%20%20Ancillary%20Data"></a><a class="selflink" href="#section-4.4.2.2" name="section-4.4.2.2">4.4.2.2</a>.  Ancillary Data</span>

   In this profile, this option indicates the server Uniform Resource
   Identifier (URI) [<a href="rfc3986.html" title='"Uniform Resource Identifier (URI): Generic Syntax"'>RFC3986</a>] encoded in UTF-8 to which a client is
   connecting on this session, for example,
   "rtmfp://server.example.com/app/instance".

   +-------------/-+-------------/-+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+
   |   length    \ |     0x0a    \ |       ancillary data          |
   +-------------/-+-------------/-+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~/

   struct ancillaryDataEPDOptionValue_t
   {
       uint8_t ancillaryData[remainder()];
   } :remainder()*8;

   This option MUST NOT occur more than once in an EPD.


















<span class="grey">Thornburgh                    Informational                    [Page 15]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-16" id="page-16" name="page-16"> </a>
<span class="grey"><a href="rfc7425.html">RFC 7425</a>           Adobe RTMFP for Flash Communication     December 2014</span>


<span class="h5"><a class="dashAnchor" name="//apple_ref/Section/4.4.2.3.%20%20Fingerprint"></a><a class="selflink" href="#section-4.4.2.3" name="section-4.4.2.3">4.4.2.3</a>.  Fingerprint</span>

   This option indicates the 256-bit (32-byte) fingerprint
   (<a href="#section-4.3.2">Section 4.3.2</a>) of a certificate.

    0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7
   +-------------/-+-------------/-+
   |   length    \ |     0x0f    \ |
   +-------------/-+-------------/-+
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   + - - - - - - - + - - - - - - - + - - - - - - - + - - - - - - - +
   |                                                               |
   + - - - - - - - + - - - - - - - + - - - - - - - + - - - - - - - +
   |                                                               |
   + - - - - - - - + - - - - - - - + - - - - - - - + - - - - - - - +
   |                          fingerprint                          |
   + - - - - - - - + - - - - - - - + - - - - - - - + - - - - - - - +
   |                                                               |
   + - - - - - - - + - - - - - - - + - - - - - - - + - - - - - - - +
   |                                                               |
   + - - - - - - - + - - - - - - - + - - - - - - - + - - - - - - - +
   |                                                               |
   + - - - - - - - + - - - - - - - + - - - - - - - + - - - - - - - +
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

   struct fingerprintEPDOptionValue_t
   {
       uint8_t fingerprint[32];
   } :256;

   This option MUST NOT occur more than once in an EPD.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/4.4.3.%20%20Certificate%20Selection"></a><a class="selflink" href="#section-4.4.3" name="section-4.4.3">4.4.3</a>.  Certificate Selection</span>

   This section describes the REQUIRED method of determining whether an
   EPD selects a certificate.

   An EPD MUST contain at least one of Fingerprint, Required Hostname,
   or Ancillary Data options to select any certificate.

   A Fingerprint EPD option selects or rejects a certificate no matter
   what other options are present.

   Without a Fingerprint option, a Required Hostname EPD option, if
   present, REQUIRES an identical Hostname option in the certificate.




<span class="grey">Thornburgh                    Informational                    [Page 16]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-17" id="page-17" name="page-17"> </a>
<span class="grey"><a href="rfc7425.html">RFC 7425</a>           Adobe RTMFP for Flash Communication     December 2014</span>


   Without a Fingerprint option, an Ancillary Data EPD option, if
   present, REQUIRES that the certificate has an Accepts Ancillary Data
   option.

   if EPD contains a Fingerprint option:
       if certificate.fingerprint == option.fingerprint:
           certificate is selected. stop.
       else:
           certificate is not selected. stop.
   else:
       if EPD contains a Required Hostname option:
           if certificate contains a Hostname option:
               if certificate.hostname != option.hostname:
                   certificate is not selected. stop.
           else:
               certificate is not selected. stop.
       if EPD contains an Ancillary Data option:
           if certificate doesn't have an Accepts Ancillary Data option:
               certificate is not selected. stop.
       else if EPD does not contain a Required Hostname option:
           certificate is not selected. stop.
       certificate is selected. stop.

     Figure 1: Algorithm to Test Whether an EPD Selects a Certificate

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/4.4.4.%20%20Canonical%20Endpoint%20Discriminator"></a><a class="selflink" href="#section-4.4.4" name="section-4.4.4">4.4.4</a>.  Canonical Endpoint Discriminator</span>

   In this profile, a Canonical Endpoint Discriminator (<a href="rfc7016.html#section-3.2">Section 3.2 of
   RFC 7016</a>) contains only a Fingerprint option (<a href="#section-4.4.2.3">Section 4.4.2.3</a>) and no
   other options.  The option length and type code MUST be encoded as
   1-byte VLUs, even though VLU encoding allows those fields to be
   encoded in an arbitrary number of bytes.  That is, the Canonical
   Endpoint Discriminator MUST be exactly 34 bytes long, with a length
   field of 0x21 encoded as one byte, a type code of 0x0f encoded as one
   byte, and 32 bytes of fingerprint.
















<span class="grey">Thornburgh                    Informational                    [Page 17]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-18" id="page-18" name="page-18"> </a>
<span class="grey"><a href="rfc7425.html">RFC 7425</a>           Adobe RTMFP for Flash Communication     December 2014</span>


    0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |     0x21      |     0x0f      |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   + - - - - - - - + - - - - - - - + - - - - - - - + - - - - - - - +
   |                                                               |
   + - - - - - - - + - - - - - - - + - - - - - - - + - - - - - - - +
   |                                                               |
   + - - - - - - - + - - - - - - - + - - - - - - - + - - - - - - - +
   |                          fingerprint                          |
   + - - - - - - - + - - - - - - - + - - - - - - - + - - - - - - - +
   |                                                               |
   + - - - - - - - + - - - - - - - + - - - - - - - + - - - - - - - +
   |                                                               |
   + - - - - - - - + - - - - - - - + - - - - - - - + - - - - - - - +
   |                                                               |
   + - - - - - - - + - - - - - - - + - - - - - - - + - - - - - - - +
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

   struct canonicalEndpointDiscriminator_t
   {
       uint8_t length = 0x21;
       uint8_t type = 0x0f;
       uint8_t fingerprint[32];
   } :272;

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.5.%20%20Session%20Keying%20Components"></a><a class="selflink" href="#section-4.5" name="section-4.5">4.5</a>.  Session Keying Components</span>

   This section describes the format of the Session Key Initiator
   Component of the Initiator Initial Keying RTMFP chunk and the Session
   Key Responder Component of the Responder Initial Keying RTMFP chunk
   (Sections <a href="#section-2.3.7">2.3.7</a> and <a href="#section-2.3.8">2.3.8</a> of <a href="rfc7016.html">RFC 7016</a>).  The Initiator and Responder
   Session Keying Components have the same format.
















<span class="grey">Thornburgh                    Informational                    [Page 18]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-19" id="page-19" name="page-19"> </a>
<span class="grey"><a href="rfc7425.html">RFC 7425</a>           Adobe RTMFP for Flash Communication     December 2014</span>


<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/4.5.1.%20%20Format"></a><a class="selflink" href="#section-4.5.1" name="section-4.5.1">4.5.1</a>.  Format</span>

   A Session Keying Component in this profile is encoded as a sequence
   of zero or more RTMFP Options.

   +~~~/~~~/~~~~~~~+               +~~~/~~~/~~~~~~~+
   | L \ T \   V   |...............| L \ T \   V   |
   +~~~/~~~/~~~~~~~+               +~~~/~~~/~~~~~~~+
   ^                                               ^
   +-------------  Zero or more Options  ----------+

   struct sessionKeyingComponent_t
   {
       while(remainder() &gt; 0)
           option_t option :variable*8;
   } :remainder()*8;

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/4.5.2.%20%20Options"></a><a class="selflink" href="#section-4.5.2" name="section-4.5.2">4.5.2</a>.  Options</span>

   This section lists options that can appear in a Session Keying
   Component.  The following option type codes are defined:

   0x0d:  Ephemeral Diffie-Hellman Public Key (<a href="#section-4.5.2.1">Section 4.5.2.1</a>)

   0x0e:  Extra Randomness (<a href="#section-4.5.2.2">Section 4.5.2.2</a>)

   0x1d:  Diffie-Hellman Group Select (<a href="#section-4.5.2.3">Section 4.5.2.3</a>)

   0x1a:  HMAC Negotiation (<a href="#section-4.5.2.4">Section 4.5.2.4</a>)

   0x1e:  Session Sequence Number Negotiation (<a href="#section-4.5.2.5">Section 4.5.2.5</a>)

   An implementation MUST ignore a session keying component option type
   that is not understood.

















<span class="grey">Thornburgh                    Informational                    [Page 19]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-20" id="page-20" name="page-20"> </a>
<span class="grey"><a href="rfc7425.html">RFC 7425</a>           Adobe RTMFP for Flash Communication     December 2014</span>


<span class="h5"><a class="dashAnchor" name="//apple_ref/Section/4.5.2.1.%20%20Ephemeral%20Diffie-Hellman%20Public%20Key"></a><a class="selflink" href="#section-4.5.2.1" name="section-4.5.2.1">4.5.2.1</a>.  Ephemeral Diffie-Hellman Public Key</span>

   This option specifies a Diffie-Hellman group ID and public key in
   that group.  This option MUST NOT be sent if the sender's certificate
   has a static Diffie-Hellman public key.  This option MUST be sent if
   the sender's certificate does not have a static Diffie-Hellman public
   key.  This option MUST NOT be sent more than once.

   +-------------/-+-------------/-+-------------/-+
   |   length    \ |     0x0d    \ |   group ID  \ |
   +-------------/-+-------------/-+-------------/-+
   +------------------------------------------------------------------+
   |                  Diffie-Hellman Public Key                       |
   +------------------------------------------------------------------/

   struct ephemeralDHPublicKeyKeyingOptionValue_t
   {
       vlu_t   groupID :variable*8;
       uintn_t publicKey :remainder()*8; // network byte order
   } :remainder()*8;

<span class="h5"><a class="dashAnchor" name="//apple_ref/Section/4.5.2.2.%20%20Extra%20Randomness"></a><a class="selflink" href="#section-4.5.2.2" name="section-4.5.2.2">4.5.2.2</a>.  Extra Randomness</span>

   This option can be used to add extra entropy or randomness to a
   keying component, particularly when the sender uses a static public
   key.  When used for that purpose, the extra randomness SHOULD be
   cryptographically strong pseudorandom bytes not less than 16 bytes
   (for cryptographically significant entropy) and not more than 64
   bytes (the length of a SHA-256 input block) in length.  The extra
   randomness serves as a salt when computing the session keys
   (<a href="#section-4.6">Section 4.6</a>).

   +-------------/-+-------------/-+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+
   |   length    \ |     0x0e    \ |       extra randomness        |
   +-------------/-+-------------/-+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~/

   struct extraRandomnessKeyingOptionValue_t
   {
       uint_t extraRandomness[remainder()];
   } :remainder()*8;











<span class="grey">Thornburgh                    Informational                    [Page 20]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-21" id="page-21" name="page-21"> </a>
<span class="grey"><a href="rfc7425.html">RFC 7425</a>           Adobe RTMFP for Flash Communication     December 2014</span>


<span class="h5"><a class="dashAnchor" name="//apple_ref/Section/4.5.2.3.%20%20Diffie-Hellman%20Group%20Select"></a><a class="selflink" href="#section-4.5.2.3" name="section-4.5.2.3">4.5.2.3</a>.  Diffie-Hellman Group Select</span>

   This option is sent by the Initiator to specify which Diffie-Hellman
   group to use for key agreement.  The Initiator MUST send this option
   when it advertises a static Diffie-Hellman public key in its
   certificate and MUST NOT send this option if it sends an ephemeral
   Diffie-Hellman public key.  This option MUST NOT be sent more than
   once.

   +-------------/-+-------------/-+-------------/-+
   |   length    \ |     0x1d    \ |   group ID  \ |
   +-------------/-+-------------/-+-------------/-+

   struct staticDHGroupSelectKeyingOptionValue_t
   {
       vlu_t   groupID :variable*8;
   } :variable*8;

<span class="h5"><a class="dashAnchor" name="//apple_ref/Section/4.5.2.4.%20%20HMAC%20Negotiation"></a><a class="selflink" href="#section-4.5.2.4" name="section-4.5.2.4">4.5.2.4</a>.  HMAC Negotiation</span>

   This option is used to negotiate sending and receiving of an HMAC
   field for packet verification.

                                   |0 1 2 3 4 5 6 7|
   +-------------/-+-------------/-+-+-+-+-+-+-+-+-+-------------/-+
   |             \ |             \ |         |S|S|R|             \ |
   |   length    / |     0x1a    / |   rsv   |N|O|E|  hmacLength / |
   |             \ |             \ |         |D|R|Q|             \ |
   +-------------/-+-------------/-+-+-+-+-+-+-+-+-+-------------/-+

   struct hmacNegotiationKeyingOptionValue_t
   {
       uintn_t reserved :5;          // rsv
       bool_t  willSendAlways :1;    // SND
       bool_t  willSendOnRequest :1; // SOR
       bool_t  request :1;           // REQ
       vlu_t   hmacLength :variable*8;
   } :variable*8;

   willSendAlways:  If set, the sender will send an HMAC on packets in
      this session.

   willSendOnRequest:  If set, the sender will send an HMAC on packets
      in this session if the other end sets the request flag in its HMAC
      Negotiation.






<span class="grey">Thornburgh                    Informational                    [Page 21]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-22" id="page-22" name="page-22"> </a>
<span class="grey"><a href="rfc7425.html">RFC 7425</a>           Adobe RTMFP for Flash Communication     December 2014</span>


   request:  If set, the sender would very much like the receiver to
      send an HMAC on its packets.  If the other end doesn't send an
      HMAC on its packets, the session can fail.

   hmacLength:  If the sender negotiates to send an HMAC on its packets,
      the HMAC field will be this many bytes long.  This value MUST be
      between 4 and 32 inclusive, or 0 if and only if willSendAlways and
      willSendOnRequest are clear.

   The handshake operational semantics for this option are described in
   <a href="#section-4.6.4">Section 4.6.4</a>.

<span class="h5"><a class="dashAnchor" name="//apple_ref/Section/4.5.2.5.%20%20Session%20Sequence%20Number%20Negotiation"></a><a class="selflink" href="#section-4.5.2.5" name="section-4.5.2.5">4.5.2.5</a>.  Session Sequence Number Negotiation</span>

   This option is used to negotiate sending and receiving of the Session
   Sequence Number field for packet verification.

                                   |0 1 2 3 4 5 6 7|
   +-------------/-+-------------/-+-+-+-+-+-+-+-+-+
   |             \ |             \ |         |S|S|R|
   |   length    / |     0x1e    / |   rsv   |N|O|E|
   |             \ |             \ |         |D|R|Q|
   +-------------/-+-------------/-+-+-+-+-+-+-+-+-+

   struct sseqNegotiationKeyingOptionValue_t
   {
       uintn_t reserved :5;          // rsv
       bool_t  willSendAlways :1;    // SND
       bool_t  willSendOnRequest :1; // SOR
       bool_t  request :1;           // REQ
   } :8;

   willSendAlways:  If set, the sender will send a session sequence
      number in packets in this session.

   willSendOnRequest:  If set, the sender will send a session sequence
      number in packets in this session if the other end sets the
      request flag in its Session Sequence Number Negotiation.

   request:  If set, the sender would very much like the receiver to
      send a session sequence number in its packets.  If the other end
      doesn't send a session sequence number in its packets, the session
      can fail.

   The handshake operational semantics for this option are described in
   <a href="#section-4.6.6">Section 4.6.6</a>.





<span class="grey">Thornburgh                    Informational                    [Page 22]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-23" id="page-23" name="page-23"> </a>
<span class="grey"><a href="rfc7425.html">RFC 7425</a>           Adobe RTMFP for Flash Communication     December 2014</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.6.%20%20Session%20Key%20Computation"></a><a class="selflink" href="#section-4.6" name="section-4.6">4.6</a>.  Session Key Computation</span>

   This section describes how to compute the cryptographic keys and
   other settings for packet encryption and verification.

   The Session Key Near Component (SKNC) means the keying component sent
   by the near end of the session; that is, it is the Session Key
   Initiator Component at the Initiator and the Session Key Responder
   Component at the Responder.

   The Session Key Far Component (SKFC) means the keying component sent
   by the far end of the session; that is, it is the Session Key
   Responder Component at the Initiator and the Session Key Initiator
   Component at the Responder.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/4.6.1.%20%20Public%20Key%20Selection"></a><a class="selflink" href="#section-4.6.1" name="section-4.6.1">4.6.1</a>.  Public Key Selection</span>

   This section enumerates the public key selection methods for all
   possible combinations of static or ephemeral public key modes for
   each endpoint according to their certificate options (<a href="#section-4.3.3">Section 4.3.3</a>).

<span class="h5"><a class="dashAnchor" name="//apple_ref/Section/4.6.1.1.%20%20Initiator%20and%20Responder%20Ephemeral"></a><a class="selflink" href="#section-4.6.1.1" name="section-4.6.1.1">4.6.1.1</a>.  Initiator and Responder Ephemeral</span>

   The Initiator and Responder list one or more Supported Ephemeral
   Diffie-Hellman Group options (<a href="#section-4.3.3.4">Section 4.3.3.4</a>) in their certificates.
   The Initiator sends exactly one Ephemeral Diffie-Hellman Public Key
   option (<a href="#section-4.5.2.1">Section 4.5.2.1</a>) in its Session Key Initiator Component,
   which selects one group from among those supported by the Responder
   and Initiator.  Responder sends exactly one Ephemeral Diffie-Hellman
   Public Key option in its Session Key Responder Component, in the same
   group as indicated by the Initiator.

<span class="h5"><a class="dashAnchor" name="//apple_ref/Section/4.6.1.2.%20%20Initiator%20Ephemeral%20and%20Responder%20Static"></a><a class="selflink" href="#section-4.6.1.2" name="section-4.6.1.2">4.6.1.2</a>.  Initiator Ephemeral and Responder Static</span>

   The Responder lists one or more Static Diffie-Hellman Public Key
   options (<a href="#section-4.3.3.5">Section 4.3.3.5</a>) in its certificate.  The Initiator lists
   one or more Supported Ephemeral Diffie-Hellman Group options in its
   certificate.  The Initiator sends exactly one Ephemeral Diffie-
   Hellman Public Key option in its Session Key Initiator Component,
   which selects one group from among those supported by the Responder
   and Initiator and the corresponding public key for the Responder.
   Responder uses its public key from the indicated group, and sends
   only an Extra Randomness option (<a href="#section-4.5.2.2">Section 4.5.2.2</a>) in its Session Key
   Responder Component to salt the session keys.







<span class="grey">Thornburgh                    Informational                    [Page 23]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-24" id="page-24" name="page-24"> </a>
<span class="grey"><a href="rfc7425.html">RFC 7425</a>           Adobe RTMFP for Flash Communication     December 2014</span>


<span class="h5"><a class="dashAnchor" name="//apple_ref/Section/4.6.1.3.%20%20Initiator%20Static%20and%20Responder%20Ephemeral"></a><a class="selflink" href="#section-4.6.1.3" name="section-4.6.1.3">4.6.1.3</a>.  Initiator Static and Responder Ephemeral</span>

   The Responder lists one or more Supported Ephemeral Diffie-Hellman
   Group options in its certificate.  The Initiator lists one or more
   Static Diffie-Hellman Public Key options in its certificate.  The
   Initiator sends exactly one Diffie-Hellman Group Select option
   (<a href="#section-4.5.2.3">Section 4.5.2.3</a>) in its Session Key Initiator Component, which
   selects one group from among those supported by the Responder and
   Initiator and the corresponding public key for the Initiator, plus an
   Extra Randomness option to salt the session keys.  The Responder
   sends an Ephemeral Diffie-Hellman Public Key option in its Session
   Key Responder Component in the same group as indicated by the
   Initiator.

<span class="h5"><a class="dashAnchor" name="//apple_ref/Section/4.6.1.4.%20%20Initiator%20and%20Responder%20Static"></a><a class="selflink" href="#section-4.6.1.4" name="section-4.6.1.4">4.6.1.4</a>.  Initiator and Responder Static</span>

   The Initiator and Responder each list one or more Static Diffie-
   Hellman Public Key options in their certificates.  The Initiator
   sends exactly one Diffie-Hellman Group Select option in its Session
   Key Initiator Component, which selects one group and corresponding
   public keys from among those supported by the Responder and
   Initiator, and an Extra Randomness option to salt the session keys.
   The Responder sends an Extra Randomness option in its Session Key
   Responder Component to add its own salt to the session keys.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/4.6.2.%20%20Diffie-Hellman%20Shared%20Secret"></a><a class="selflink" href="#section-4.6.2" name="section-4.6.2">4.6.2</a>.  Diffie-Hellman Shared Secret</span>

   To be acceptable, a Diffie-Hellman public key MUST have all of the
   following properties:

   o  Be at least 16777216 (2^24);

   o  Be at most the group's prime modulus minus 16777216;

   o  Have at least 16 "1" bits;

   o  Have at least 16 "0" bits, not including leading zeros.

   An endpoint MUST NOT complete to an S_OPEN session with a far
   endpoint using a public key that is not acceptable according to these
   criteria.

   Once the group and corresponding public key of the far end is
   determined, the far end's public key and the near end's private key
   are combined according to Diffie-Hellman [<a href="#ref-DH" title='"New Directions in Cryptography"'>DH</a>] to compute the Diffie-
   Hellman Shared Secret, an integer.





<span class="grey">Thornburgh                    Informational                    [Page 24]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-25" id="page-25" name="page-25"> </a>
<span class="grey"><a href="rfc7425.html">RFC 7425</a>           Adobe RTMFP for Flash Communication     December 2014</span>


   In the following sections, DH_SECRET means the Diffie-Hellman Shared
   Secret encoded as a byte-aligned unsigned integer in network byte
   order with no leading zero bytes.  For example, if the shared secret
   is 4886718345, DH_SECRET would be the five bytes:

                            Hex: 01 23 45 67 89

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/4.6.3.%20%20Packet%20Encrypt%2FDecrypt%20Keys"></a><a class="selflink" href="#section-4.6.3" name="section-4.6.3">4.6.3</a>.  Packet Encrypt/Decrypt Keys</span>

   Packets are encrypted using a symmetric cipher, such as the Advanced
   Encryption Standard [<a href="#ref-AES" title='"Advanced Encryption Standard (AES)"'>AES</a>].  Distinct keys are used for sending and
   receiving packets.  Each end's sending (encrypt) key is the other
   end's receiving (decrypt) key.

   The raw keys computed in this section for encryption and decryption
   are transformed in a manner specific to the cipher with which they
   are to be used.  In this profile, AES-128 is the only currently
   defined cipher.  For this cipher, the first 128 bits (16 bytes) of
   the 256-bit output of the calculation are taken to be the AES-128
   key.

      Set ENCRYPT_KEY = HMAC-SHA256(DH_SECRET, HMAC-SHA256(SKFC, SKNC));

      Set DECRYPT_KEY = HMAC-SHA256(DH_SECRET, HMAC-SHA256(SKNC, SKFC));

   The full 256 bits of ENCRYPT_KEY and DECRYPT_KEY are used in the
   computations in the following sections.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/4.6.4.%20%20Packet%20HMAC%20Send%2FReceive%20Keys"></a><a class="selflink" href="#section-4.6.4" name="section-4.6.4">4.6.4</a>.  Packet HMAC Send/Receive Keys</span>

   Packets can be verified that they were not corrupted or modified by
   appending an HMAC to the packet.  Whether to use an HMAC or a simple
   checksum is determined during the initial keying phase using the HMAC
   Negotiation option (<a href="#section-4.5.2.4">Section 4.5.2.4</a>).  Distinct HMAC keys are used
   for sending and receiving packets.  Each end's sending key is the
   other end's receiving key, and vice versa.

      Set HMAC_SEND_KEY = HMAC_SHA256(DH_SECRET, ENCRYPT_KEY);

      Set HMAC_RECV_KEY = HMAC_SHA256(DH_SECRET, DECRYPT_KEY);

   If an endpoint sets the willSendAlways flag in its HMAC Negotiation
   option, then it MUST send an HMAC on packets it sends with this
   session key.







<span class="grey">Thornburgh                    Informational                    [Page 25]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-26" id="page-26" name="page-26"> </a>
<span class="grey"><a href="rfc7425.html">RFC 7425</a>           Adobe RTMFP for Flash Communication     December 2014</span>


   If an endpoint's willSendAlways flag is clear but its
   willSendOnRequest flag is set, then it MUST send an HMAC on packets
   it sends with this session key if and only if the other endpoint's
   request flag is set.

   If a sending endpoint's willSendAlways and willSendOnRequest flags
   are clear, then the receiving endpoint SHOULD reject that keying
   component if the receiving endpoint is configured to require the
   sending endpoint to send HMAC.

   If HMAC is negotiated to be used, the corresponding hmacLength MUST
   be between 4 and 32 inclusive.

   If HMAC is negotiated not to be used, a simple checksum is used for
   packet verification.

   The Default Session Key uses the simple checksum and does not use
   HMAC.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/4.6.5.%20%20Session%20Nonces"></a><a class="selflink" href="#section-4.6.5" name="section-4.6.5">4.6.5</a>.  Session Nonces</span>

   Session nonces are per-session, cryptographically strong secret
   values known only to the two endpoints of the session.  They can be
   used for application-layer cryptographic challenges (such as signing
   or password verification).  These nonces are a convenience being pre-
   shared and pre-agreed-upon in a secure manner during the initial
   keying handshake.

   Each end's near nonce is the other end's far nonce, and vice versa.

      Set NEAR_NONCE = HMAC_SHA256(DH_SECRET, SKNC);

      Set FAR_NONCE = HMAC_SHA256(DH_SECRET, SKFC);

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/4.6.6.%20%20Session%20Sequence%20Number"></a><a class="selflink" href="#section-4.6.6" name="section-4.6.6">4.6.6</a>.  Session Sequence Number</span>

   Duplicate packets can be detected and rejected by using an optional
   session sequence number inside the encrypted packets.  The session
   sequence number is a monotonically increasing unbounded integer and
   does not wrap.  Session sequence numbers SHOULD start at zero and
   SHOULD increment by one for each packet sent using that session key.
   Implementations MUST handle session sequence numbers with no less
   than 64 bits of range.

   If an endpoint's willSendAlways flag in its Session Sequence Number
   Negotiation option (<a href="#section-4.5.2.5">Section 4.5.2.5</a>) is set, then it MUST send a
   session sequence number in packets it sends with this session key.




<span class="grey">Thornburgh                    Informational                    [Page 26]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-27" id="page-27" name="page-27"> </a>
<span class="grey"><a href="rfc7425.html">RFC 7425</a>           Adobe RTMFP for Flash Communication     December 2014</span>


   If an endpoint's willSendAlways flag is clear but its
   willSendOnRequest flag is set, then it MUST send a session sequence
   number on packets it sends with this session key if and only if the
   other endpoint's request flag is set.

   If a sending endpoint's willSendAlways and willSendOnRequest flags
   are clear, then the receiving endpoint SHOULD reject that keying
   component if the receiving endpoint is configured to require the
   sending endpoint to send session sequence numbers.

   The Default Session Key does not use session sequence numbers.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.7.%20%20Packet%20Encryption"></a><a class="selflink" href="#section-4.7" name="section-4.7">4.7</a>.  Packet Encryption</span>

   This section describes the concrete syntax and operational semantics
   of RTMFP packet encryption for this Cryptography Profile.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/4.7.1.%20%20Cipher"></a><a class="selflink" href="#section-4.7.1" name="section-4.7.1">4.7.1</a>.  Cipher</span>

   This profile defines AES-128 [<a href="#ref-AES" title='"Advanced Encryption Standard (AES)"'>AES</a>] in CBC [<a href="#ref-CBC" title='"Recommendation for Block Cipher Modes of Operation"'>CBC</a>] mode as the only
   cipher.  Extensions to this profile can specify and negotiate
   additional ciphers and modes by defining certificate and keying
   component options and associated semantics.

   For AES-128-CBC, the initialization vector (IV) for each packet is 16
   zero bytes.  The IV is not included in the packet.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/4.7.2.%20%20Format"></a><a class="selflink" href="#section-4.7.2" name="section-4.7.2">4.7.2</a>.  Format</span>

   The Encrypted Packet is the encryptedPacket field of an RTMFP
   Multiplex packet (<a href="rfc7016.html#section-2.2.2">Section 2.2.2 of RFC 7016</a>); that is, the portion of
   the Multiplex packet following the scrambled session ID.  The
   Encrypted Packet has the following format:


















<span class="grey">Thornburgh                    Informational                    [Page 27]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-28" id="page-28" name="page-28"> </a>
<span class="grey"><a href="rfc7425.html">RFC 7425</a>           Adobe RTMFP for Flash Communication     December 2014</span>


   +----------------+     +----------------+~~~~~~~~~~~~~~~~~~~~~~~+
   |  CBC Block 1   | ... |  CBC Block N   |     truncatedHMAC     |
   +----------------+     +----------------+~~~~~~~~~~~~~~~~~~~~~~~+
   ^                                       ^                       ^
   |     Zero or more AES-128 chained      | hmacLength bytes long |
   +--------    cipher blocks   -----------+---  (may be zero)  ---+

   struct flashProfileEncryptedPacket_t
   {
       if(HMAC is being used)
           hmacLength = negotiated length;
       else
           hmacLength = 0;

       struct
       {
           iv[16 bytes] = { 0 };
           blockCount = 0;
           while((remainder() &gt; hmacLength) &amp;&amp; (remainder() &gt;= 16))
           {
               uint8_t cbcBlock[16];
               blockCount++;
           }
       } chainedCipherBlocks :variable*16*8;

       if(HMAC is being used)
       {
           if(remainder() == hmacLength)
               uint8_t truncatedHMAC[hmacLength];
           else
               packetVerificationFailed();
       }
       else if(remainder() &gt; 0)
           packetVerificationFailed();
   } :encryptedPacket.length*8;

   cbcBlock:  The next AES-128-CBC block.

   chainedCipherBlocks:  The concatenation of every cipher block in the
      packet (over which the HMAC is computed).

   truncatedHMAC:  If HMAC was negotiated to be used (<a href="#section-4.5.2.4">Section 4.5.2.4</a>),
      this field is set to the first negotiated hmacLength bytes of the
      HMAC of the chainedCipherBlocks.

   The plaintext data before encryption or after decryption has the
   following format:




<span class="grey">Thornburgh                    Informational                    [Page 28]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-29" id="page-29" name="page-29"> </a>
<span class="grey"><a href="rfc7425.html">RFC 7425</a>           Adobe RTMFP for Flash Communication     December 2014</span>


    0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7
   +~~~~~~~~~~~~~/~+
   | SSEQ (opt.) \ |
   +~~~~~~~~~~~~~/~+
   +~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+
   |        Checksum (opt.)        |
   +~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+
   +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+
   |                        Plain RTMFP Packet                     |
   +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~/

   struct flashProfilePlainPacket_t
   {
       if(session sequence numbers being used)
           vlu_t sessionSequenceNumber :variable*8; // SSEQ
       if(HMAC not being used)
           uint16_t checksum;
       packet_t plainRTMFPPacket :variable*8;
   } :chainedCipherBlocks.blockCount*16*8;

   sessionSequenceNumber:  If session sequence numbers were negotiated
      to be used (<a href="#section-4.6.6">Section 4.6.6</a>), this field is present and is the VLU
      session sequence number of this packet.

   checksum:  If HMAC was not negotiated to be used, this field is
      present and is the simple checksum (<a href="#section-4.7.3.1">Section 4.7.3.1</a>) of the
      remaining bytes of this structure.

   plainRTMFPPacket:  The (plain, unencrypted) RTMFP Packet
      (<a href="rfc7016.html#section-2.2.4">Section 2.2.4 of RFC 7016</a>) plus any necessary padding.

   When assembling this structure and prior to calculating the checksum
   (if present), if the structure's total length is not an integer
   multiple of 16 bytes (the AES cipher block size), pad the end of
   plainRTMFPPacket with as many bytes having a value of 0xff as are
   needed to bring the structure's total length to an integer multiple
   of 16 bytes.  The receiver's RTMFP Packet parser (<a href="rfc7016.html#section-2.2.4">Section 2.2.4 of
   RFC 7016</a>) will consume this padding.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/4.7.3.%20%20Verification"></a><a class="selflink" href="#section-4.7.3" name="section-4.7.3">4.7.3</a>.  Verification</span>

   In RTMFP, the Cryptography Profile is responsible for packet
   verification.  In this profile, packets are verified with an HMAC or
   a simple checksum, depending on the configuration of the endpoints,
   and optionally verified against replay or duplication using session
   sequence numbers.  The simple checksum is inside the encrypted
   packet, so it becomes essentially a 16-bit cryptographic checksum.




<span class="grey">Thornburgh                    Informational                    [Page 29]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-30" id="page-30" name="page-30"> </a>
<span class="grey"><a href="rfc7425.html">RFC 7425</a>           Adobe RTMFP for Flash Communication     December 2014</span>


<span class="h5"><a class="dashAnchor" name="//apple_ref/Section/4.7.3.1.%20%20Simple%20Checksum"></a><a class="selflink" href="#section-4.7.3.1" name="section-4.7.3.1">4.7.3.1</a>.  Simple Checksum</span>

   The simple checksum is the 16-bit ones' complement of the 16-bit
   ones' complement sum of all 16-bit (2 bytes in network byte order)
   words to be checked.  If there are an odd number of bytes to be
   checked, then for purposes of this checksum, treat the last byte as
   the lower 8 bits of a 16-bit word whose upper 8 bits are 0.  This is
   also known as the "Internet Checksum" [<a href="rfc1071.html" title='"Computing the Internet checksum"'>RFC1071</a>].

   When present, the checksum is calculated over all bytes of the
   plaintext packet starting after the checksum field through the end of
   the plain packet.  It cannot be calculated until the plain packet is
   padded, if necessary, to bring its length to an integer multiple of
   16 bytes (the AES cipher block size).  The session sequence number
   field, if present, and the checksum field itself are not included in
   the checksum.

   On receiving a packet being verified with a checksum: calculate the
   checksum over all the bytes of the plaintext packet following the
   checksum field and compare the checksum to the value in the checksum
   field.  If they match, the packet is verified; if they do not match,
   the packet is corrupt and MUST be discarded as though it was never
   received.

<span class="h5"><a class="dashAnchor" name="//apple_ref/Section/4.7.3.2.%20%20HMAC"></a><a class="selflink" href="#section-4.7.3.2" name="section-4.7.3.2">4.7.3.2</a>.  HMAC</span>

   When present, the HMAC field is the last hmacLength bytes of the
   packet and is calculated over all of the encrypted cipher blocks of
   the packet preceding the HMAC field.  The value of the HMAC field is
   the first hmacLength bytes of the HMAC-SHA256 of the checked data,
   using the computed HMAC keys (<a href="#section-4.6.4">Section 4.6.4</a>) and negotiated
   hmacLength (<a href="#section-4.5.2.4">Section 4.5.2.4</a>).  Note each endpoint independently
   specifies the length of the HMAC it will send via its hmacLength
   field.

   When an endpoint has negotiated to send an HMAC, it encrypts the data
   blocks, computes the HMAC over the encrypted data blocks using its
   HMAC_SEND_KEY, and appends the first hmacLength bytes of that hash
   after the final encrypted data block.

   When an endpoint has negotiated to receive an HMAC, the endpoint
   computes the HMAC over the encrypted data blocks using its
   HMAC_RECV_KEY and then compares the first receive hmacLength bytes of
   the computed HMAC to the HMAC field in the packet.  If they are
   identical, the packet is verified; if they are not identical, the
   packet is corrupt and MUST be discarded as though it was never
   received.




<span class="grey">Thornburgh                    Informational                    [Page 30]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-31" id="page-31" name="page-31"> </a>
<span class="grey"><a href="rfc7425.html">RFC 7425</a>           Adobe RTMFP for Flash Communication     December 2014</span>


   HMAC and simple checksum verification are mutually exclusive.

<span class="h5"><a class="dashAnchor" name="//apple_ref/Section/4.7.3.3.%20%20Session%20Sequence%20Number"></a><a class="selflink" href="#section-4.7.3.3" name="section-4.7.3.3">4.7.3.3</a>.  Session Sequence Number</span>

   Session sequence numbers are used to detect and reject a packet that
   was duplicated in the network or replayed by an attacker and to
   ensure the first chained cipher block of every packet is unique, in
   lieu of a full-block initialization vector.  Sequence numbers start
   at zero, increase by one for each packet sent in the session, do not
   wrap, and do not repeat.

   When session sequence numbers are negotiated to be used, the receiver
   MUST allow for packets to be reordered in the network by up to at
   least 32 sequence numbers; note, however, that reordering by more
   than three packets can trigger loss detection and retransmission by
   negative acknowledgement, just as with TCP, and is therefore not
   likely to occur in the real Internet.

   [<a href="rfc4302.html" title='"IP Authentication Header"'>RFC4302</a>], [<a href="rfc4303.html" title='"IP Encapsulating Security Payload (ESP)"'>RFC4303</a>], and [<a href="rfc6479.html" title='"IPsec Anti-Replay Algorithm without Bit Shifting"'>RFC6479</a>] describe Anti-Replay Window
   methods that can be employed to detect duplicate sequence numbers.
   Other methods are possible.

   Any packet received having a session sequence number that was already
   seen in that session, either directly or by being less than the
   lowest sequence number in the Anti-Replay Window, is a duplicate and
   MUST be discarded as though never received.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/5.%20%20Flash%20Communication"></a><a class="selflink" href="#section-5" name="section-5">5</a>.  Flash Communication</span>

   The Flash platform uses RTMP [<a href="#ref-RTMP" title='"Real-Time Messaging Protocol (RTMP) specification"'>RTMP</a>] messages for media streaming and
   communication.  This section describes how to transport RTMP messages
   over RTMFP flows and additional messages and semantics unique to this
   transport.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.1.%20%20RTMP%20Messages"></a><a class="selflink" href="#section-5.1" name="section-5.1">5.1</a>.  RTMP Messages</span>

   An RTMP message comprises a virtual header and a payload.  The
   virtual header comprises a Message Type, a Payload Length, a
   Timestamp, and a Stream ID.  The format of the payload is dependent
   on the type of message.

   An RTMP message is mapped onto a lower transport layer, such as RTMP
   Chunk Stream [<a href="#ref-RTMP" title='"Real-Time Messaging Protocol (RTMP) specification"'>RTMP</a>] or RTMFP.  RTMP messages were initially designed
   along with, and for transport on, RTMP Chunk Stream.  This design
   constrains the possible values of RTMP message header fields.  In
   particular:





<span class="grey">Thornburgh                    Informational                    [Page 31]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-32" id="page-32" name="page-32"> </a>
<span class="grey"><a href="rfc7425.html">RFC 7425</a>           Adobe RTMFP for Flash Communication     December 2014</span>


      Message Type is 8 bits wide, and is therefore constrained to
      values from 0 to 255 inclusive;

      Payload Length is 24 bits wide, so messages can be at most
      16777215 bytes long;

      Timestamp is 32 bits wide, so timestamps range from 0 to
      4294967295 and wrap around;

      Stream ID is 24 bits wide, and is therefore constrained to values
      from 0 to 16777215 inclusive.

   RTMP Chunk Stream Protocol Control messages (message types 1, 2, 3,
   5, and 6) are not used when transporting RTMP messages in RTMFP
   flows.  Messages of those types SHOULD NOT be sent and MUST be
   ignored.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/5.1.1.%20%20Flow%20Metadata"></a><a class="selflink" href="#section-5.1.1" name="section-5.1.1">5.1.1</a>.  Flow Metadata</span>

   All messages in RTMFP are transported in flows.  In this profile, an
   RTMFP flow for RTMP messages carries the messages for exactly one
   RTMP Stream ID.  Multiple flows can carry messages for the same
   Stream ID; for example, the video and audio messages of a stream
   could be sent on separate flows, allowing the audio to be given
   higher transmission priority.

   The User Metadata for flows in this profile begins with a distinct
   signature to distinguish among different kinds of flows.  The User
   Metadata for a flow used for RTMP messages begins with the two-
   character signature "TC".

   The Stream ID is encoded in the flow's User Metadata so that it
   doesn't need to be sent with each message.

   The sender can have a priori knowledge about the kind of media it
   intends to send on a flow and its intended use and can give the
   receiver a hint as to whether messages should be delivered as soon as
   possible or in their original queuing order.  For example, the sender
   might be sending real-time, delay-sensitive audio messages on a flow,
   and hint that the receiver should take delivery of the messages on
   that flow as soon as they arrive in the network, to reduce the end-
   to-end latency of the audio.

   The receiver can choose to take delivery of messages on flows as soon
   as they arrive in the network or in the messages' original queuing
   order.  A receiver that chooses to take delivery of messages as soon
   as they arrive in the network MUST be prepared for the messages to




<span class="grey">Thornburgh                    Informational                    [Page 32]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-33" id="page-33" name="page-33"> </a>
<span class="grey"><a href="rfc7425.html">RFC 7425</a>           Adobe RTMFP for Flash Communication     December 2014</span>


   arrive out-of-order.  For example, a receiver may choose not to
   render a newly received audio message having a timestamp earlier than
   the most recently rendered audio timestamp.

   The sender can choose to abandon a message that it has queued in a
   flow before the message has been delivered to the receiver.  For
   example, the sender may abandon a real-time, delay-sensitive audio
   message that has not been delivered within one second, to avoid
   spending transmission resources on stale media that is no longer
   relevant.

   Note: A gap will cause a delay at the receiver of at least one round-
   trip time if the receiver is taking delivery of messages in original
   queuing order.

    0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+~~~~~~~~~~~~~/~+
   |               |               |         |S|r|R|             \ |
   |   0x54  'T'   |   0x43  'C'   |   rsv   |I|s|X|   streamID  / |
   |               |               |         |D|v|I|             \ |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+~~~~~~~~~~~~~/~+

   struct RTMPMetadata_t
   {
       uint8_t signature[2] == { 'T', 'C' };
       uintn_t reserved1       :5; // rsv
       bool_t  streamIDPresent :1; // SID
       uintn_t reserved2       :1; // rsv
       uintn_t receiveIntent   :1; // RXI
           // 0: original queuing order, 1: network arrival order
       if(streamIDPresent)
           vlu_t   streamID        :variable*8;
   } :variable*8;

   signature:  Metadata signature for RTMP message flows, being the two
      UTF-8 coded characters "TC".

   streamIDPresent:  A boolean flag indicating whether the streamID
      field is present.  In this profile, this flag MUST be set.

   receiveIntent:  A hint by the sender as to the best order in which to
      take delivery of messages from the flow.  A value of zero
      indicates a hint that the flow's messages should be received in
      the order they were originally queued by the sender (that is, in
      ascending sequence number order); a value of one indicates a hint
      that the flow's messages should be received in the order they
      arrive in the network, even if there are sequence number gaps or
      reordering.  Network arrival order is typically hinted for live,



<span class="grey">Thornburgh                    Informational                    [Page 33]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-34" id="page-34" name="page-34"> </a>
<span class="grey"><a href="rfc7425.html">RFC 7425</a>           Adobe RTMFP for Flash Communication     December 2014</span>


      delay-sensitive flows, such as for audio media.  To take delivery
      of a message as soon as it arrives in the network: receive it from
      the receiving flow's RECV_BUFFER as soon as it becomes complete
      (<a href="rfc7016.html#section-3.6.3.3">Section 3.6.3.3 of RFC 7016</a>), and remove it from the RECV_BUFFER.
      <a href="rfc7016.html#section-3.6.3.3">Section 3.6.3.3 of RFC 7016</a> describes how to take delivery of
      messages in original queuing order.

   streamID:  If the streamIDPresent flag is set, this field is present
      and is the RTMP stream ID to which the messages in this flow
      belong.  In this profile, this field MUST be present.

   A receiver SHOULD reject an RTMP message flow if its streamIDPresent
   flag is clear.  This profile doesn't define a stream mapping for this
   case.

   Derived or composed profiles can define additional flow types and
   corresponding metadata signatures.  A receiver SHOULD reject a flow
   having an unrecognized metadata signature.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/5.1.2.%20%20Message%20Mapping"></a><a class="selflink" href="#section-5.1.2" name="section-5.1.2">5.1.2</a>.  Message Mapping</span>

   This section describes the format of an RTMP message (<a href="#section-5.1">Section 5.1</a>) in
   an RTMFP flow.

    0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7
   +-+-+-+-+-+-+-+-+
   |  messageType  |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                           timestamp                           |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                         messagePayload                        |
   +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~/

   struct RTMPMessage_t
   {
       uint8_t  messageType;
       uint32_t timestamp;
       uint8_t  messagePayload[remainder()];
   } :flowMessageLength*8;

   messageType:  The RTMP Message Type;

   timestamp:  The RTMP Timestamp, in network byte order;

   messagePayload:  The payload of the RTMP message;

   payload length:  The RTMP message payload length is inferred from the
      length of the RTMFP message;



<span class="grey">Thornburgh                    Informational                    [Page 34]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-35" id="page-35" name="page-35"> </a>
<span class="grey"><a href="rfc7425.html">RFC 7425</a>           Adobe RTMFP for Flash Communication     December 2014</span>


   Stream ID:  The Stream ID for this message is taken from the metadata
      of the flow on which this message was received.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.2.%20%20Flow%20Synchronization"></a><a class="selflink" href="#section-5.2" name="section-5.2">5.2</a>.  Flow Synchronization</span>

   RTMFP flows are independent and have no inter-flow ordering
   guarantee.  RTMP was designed for transport over a single, reliable,
   strictly ordered byte stream.  Some RTMP message semantics take
   advantage of this ordering; for example, a Stream EOF User Control
   event must not be processed until after all media messages for the
   corresponding stream have been received.  Flow Synchronization
   messages provide a barrier to align message delivery across flows
   when required by RTMP semantics.

   A Flow Synchronization message is coded as a User Control event
   message (Type 4) having Event Type 34.  Message timestamps are
   ignored and MAY be set to 0.

    0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7
   +-+-+-+-+-+-+-+-+
   |       4       |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                           timestamp                           |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |         eventType = 34        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                             syncID                            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                             count                             |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

   struct flowSyncUserControlMessagePayload_t
   {
       uint16_t eventType = 34;
       uint32_t syncID;
       uint32_t count;
   } :10*8;

   eventType:  The RTMP User Control Message Event Type.  Flow
      Synchronization messages have type 34 (0x22);

   syncID:  The identifier for this barrier;

   count:  The number of flows being synchronized by syncID.  This field
      MUST be at least 1 and SHOULD be at least 2.






<span class="grey">Thornburgh                    Informational                    [Page 35]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-36" id="page-36" name="page-36"> </a>
<span class="grey"><a href="rfc7425.html">RFC 7425</a>           Adobe RTMFP for Flash Communication     December 2014</span>


   On receipt of a Flow Synchronization message, a receiver SHOULD
   suspend receipt of further messages on that flow until count Flow
   Synchronization messages (including this one) with the same syncID
   have been received on flows in the same flow association tree.

   Example: Consider flows F1 and F2 in the same NetConnection carrying
   messages M, and let Sync(syncID,count) denote a Flow Synchronization
   message.

                                       |                |
             F1: M1  M2  M4  Sync(8,2) | Sync(13,2).....| M7
                                       |                |
             F2:   M3  Sync(8,2).......| M5  Sync(13,2) | M6
                                       |                |
                                   Barrier 8        Barrier 13

              Figure 2: Example Flow Synchronization Barriers

   Flow Synchronization messages form a delivery barrier to impart at
   least a partial message ordering across flows.  In this example,
   message M5 comes after M1..4 and before M6..7; however, M3 could be
   delivered before or after any of M1, M2, or M4, and M6 could come
   before or after M7.

   Flow Synchronization can cause a priority inversion; therefore, it
   SHOULD NOT be used except when necessary to preserve RTMP ordering
   semantics.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.3.%20%20Client-to-Server%20Connection"></a><a class="selflink" href="#section-5.3" name="section-5.3">5.3</a>.  Client-to-Server Connection</span>

   The client connects to a server.  The connection comprises one main
   control flow in each direction from client to server and from server
   to client for NetConnection messages, and zero or more flows in each
   direction for NetStream media messages.  NetStream flows may come and
   go naturally over time according to media transport needs.  An
   exception on a NetConnection control sending flow indicates the
   closure by the other end of the NetConnection and all associated
   NetStreams.

   The client MUST NOT use the same client certificate for more than one
   server connection; that is, a client's peer ID MUST NOT be reused.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/5.3.1.%20%20Connecting"></a><a class="selflink" href="#section-5.3.1" name="section-5.3.1">5.3.1</a>.  Connecting</span>

   The client desires a connection to a server having an RTMFP URI, for
   example, "rtmfp://server.example.com/app/instance".  The client
   gathers one or more initial candidate addresses for the server named
   in the URI (for example, by using the Domain Name System (DNS)



<span class="grey">Thornburgh                    Informational                    [Page 36]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-37" id="page-37" name="page-37"> </a>
<span class="grey"><a href="rfc7425.html">RFC 7425</a>           Adobe RTMFP for Flash Communication     December 2014</span>


   [<a href="rfc1035.html" title='"Domain names - implementation and specification"'>RFC1035</a>]).  The client creates an EPD having an Ancillary Data
   option (<a href="#section-4.4.2.2">Section 4.4.2.2</a>) encoding the URI.  The client initiates an
   RTMFP session to the one or more candidate addresses using the EPD.

   When the session transitions to the S_OPEN state, the client opens a
   new flow in that session for Stream ID 0 and Receive Intent 0
   "original queuing order".  This is the client's NetConnection main
   control flow.  The client sends an RTMP "connect" command on the flow
   and waits for a response or exception.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/5.3.2.%20%20Server-to-Client%20Return%20Control%20Flow"></a><a class="selflink" href="#section-5.3.2" name="section-5.3.2">5.3.2</a>.  Server-to-Client Return Control Flow</span>

   The server, on accepting the client's NetConnection control flow, and
   receiving and accepting the "connect" command, opens one or more
   return flows to the client having Stream ID 0 and associated to the
   control flow from the client.  Flows for Stream ID 0 are the server's
   NetConnection control flows.  The server sends a "_result" or
   "_error" transaction response for the client's connect command.

   When the client receives the first return flow from the server for
   Stream ID 0 and associated to the client's NetConnection control
   flow, the client assumes that flow is the canonical return
   NetConnection control flow from the server, to which all new client-
   to-server flows should be associated.

   On receipt of a "_result" transaction response on Stream ID 0 for the
   client's connect command, the connection is up.

   The client MAY open additional return control flows to the server on
   Stream ID 0, associated to the server's canonical NetConnection
   control flow.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/5.3.3.%20%20setPeerInfo%20Command"></a><a class="selflink" href="#section-5.3.3" name="section-5.3.3">5.3.3</a>.  setPeerInfo Command</span>

   The "setPeerInfo" command is sent by the client to the server over
   the NetConnection control flow to inform the server of candidate
   socket addresses through which the client might be reachable.  This
   list SHOULD include all directly connected interface addresses and
   proxy addresses except as provided below.  The list MAY be empty.
   The list need not include the address of the server, even if the
   server is to act as an introducer for the client.  The list SHOULD
   NOT include link-local or loopback addresses.

   This command is sent as a regular RTMP NetConnection command; that
   is, as an RTMP Type 20 Command Message or an RTMP Type 17 Command
   Extended Message on Stream ID 0.  A Type 20 Command Message SHOULD be
   used if the object encoding negotiated during the "connect" and




<span class="grey">Thornburgh                    Informational                    [Page 37]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-38" id="page-38" name="page-38"> </a>
<span class="grey"><a href="rfc7425.html">RFC 7425</a>           Adobe RTMFP for Flash Communication     December 2014</span>


   "_result" handshake is AMF0 [<a href="#ref-AMF0" title='"Action Message Format -- AMF 0"'>AMF0</a>], and a Type 17 Command Extended
   Message SHOULD be used if the negotiated object encoding is AMF3
   [<a href="#ref-AMF3" title='"Action Message Format -- AMF 3"'>AMF3</a>].

   Note: A Type 20 Command Message payload is a sequence of AMF objects
   encoded in AMF0.

   Note: A Type 17 Command Extended Message payload begins with a format
   selector byte, followed by a sequence of objects in a format-specific
   encoding.  At the time of writing, only format 0 is defined;
   therefore, the format selector byte MUST be 0.  Format 0 is a
   sequence of AMF objects, each encoded in AMF0 by default; AMF3
   encoding for an object can be selected by prefixing it with an
   "avmplus-object-marker" (0x11) as defined in [<a href="#ref-AMF0" title='"Action Message Format -- AMF 0"'>AMF0</a>].

   To complete the RTMFP NetConnection handshake, an RTMFP client MUST
   send a setPeerInfo command to the server after receiving a successful
   response to the "connect" command.

   (
       "setPeerInfo", // AMF String, command name
       0.0,  // AMF Number, transaction ID
       NULL, // AMF Null, no command object
       ...   // zero or more AMF Strings, each an address
   )

   Each listed socket address includes an IPv4 or IPv6 address in
   presentation format and a UDP port number in decimal, separated by a
   colon.  Since the IPv6 address presentation format uses colons, IPv6
   addresses are enclosed in square brackets [<a href="rfc3986.html" title='"Uniform Resource Identifier (URI): Generic Syntax"'>RFC3986</a>].

                        (
                            "setPeerInfo",
                            0.0,
                            NULL,
                            "192.0.2.129:50001",
                            "[2001:db8:1::2]:50002"
                        )

                   Figure 3: Example setPeerInfo Command

   A server SHOULD assume that the client is behind a Network Address
   Translator (NAT) if and only if the observed far endpoint address of
   the session for the flow on which this command was received does not
   appear in the setPeerInfo address list.






<span class="grey">Thornburgh                    Informational                    [Page 38]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-39" id="page-39" name="page-39"> </a>
<span class="grey"><a href="rfc7425.html">RFC 7425</a>           Adobe RTMFP for Flash Communication     December 2014</span>


<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/5.3.4.%20%20Set%20Keepalive%20Timers%20Command"></a><a class="selflink" href="#section-5.3.4" name="section-5.3.4">5.3.4</a>.  Set Keepalive Timers Command</span>

   The server can advise the client to set or change the client's
   session keepalive timer periods for its connection to the server and
   for its P2P connections.  The server MAY choose keepalive periods
   based on static configuration, application- or deployment-specific
   circumstances, whether the client appears to be behind a NAT, or for
   any other reason.

   The Set Keepalive Timers command is sent by the server to the client
   on Stream ID 0 as a User Control event message (Type 4) having Event
   Type 41.  Message timestamps are ignored and MAY be set to 0.

    0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7
   +-+-+-+-+-+-+-+-+
   |       4       |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                           timestamp                           |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |         eventType = 41        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                    serverKeepalivePeriodMsec                  |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                     peerKeepalivePeriodMsec                   |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

   struct setKeepaliveUserControlMessagePayload_t
   {
       uint16_t eventType = 41;
       uint32_t serverKeepalivePeriodMsec;
       uint32_t peerKeepalivePeriodMsec;
   } :10*8;

   eventType:  The RTMP User Control Message Event Type.  Set Keepalive
      Timers messages have type 41 (0x29);

   serverKeepalivePeriodMsec:  The keepalive period, in milliseconds,
      that the client is advised to set on its RTMFP session with the
      server;

   peerKeepalivePeriodMsec:  The keepalive period, in milliseconds, that
      the client is advised to use on its RTMFP sessions with any peer
      that is not the server.








<span class="grey">Thornburgh                    Informational                    [Page 39]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-40" id="page-40" name="page-40"> </a>
<span class="grey"><a href="rfc7425.html">RFC 7425</a>           Adobe RTMFP for Flash Communication     December 2014</span>


   The client MUST define minimum values for these keepalive periods,
   below which it will not set them, regardless of the values in this
   message.  The minimum keepalive timer periods SHOULD be at least five
   seconds.  The client MAY define maximum values for these keepalive
   periods, above which it will not set them.

   On receipt of this message from the server, a client SHOULD set its
   RTMFP server and peer keepalive timer periods to the indicated values
   subject to the client's minimum and maximum values.  The server MAY
   send this message more than once, particularly if conditions that it
   uses to determine the timer periods change.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/5.3.5.%20%20Additional%20Flows%20for%20Streams"></a><a class="selflink" href="#section-5.3.5" name="section-5.3.5">5.3.5</a>.  Additional Flows for Streams</span>

   The client or server opens additional flows to the other side to
   carry messages for any stream.  Additional flows are associated to
   the canonical NetConnection control flow from the other side.

         Client                                            Server
         ------&gt;--C2S-Control-Flow-------------------------&gt;--+
                                                              |
            +--&lt;------------------------S2C-Control-Flow---&lt;--+
            |                                                 |
            |  &lt;------------------------S2C-Stream-Flow-1--&lt;--+
            |                                  :              |
            |  &lt;------------------------S2C-Stream-Flow-M--&lt;--+
            |
            +--&gt;--C2S-Stream-Flow-1------------------------&gt;
            |               :
            +--&gt;--C2S-Stream-Flow-N------------------------&gt;

       Figure 4: Schematic Flow Association Tree for a NetConnection

<span class="h5"><a class="dashAnchor" name="//apple_ref/Section/5.3.5.1.%20%20To%20Server"></a><a class="selflink" href="#section-5.3.5.1" name="section-5.3.5.1">5.3.5.1</a>.  To Server</span>

   Additional flows from the client to the server for stream messages
   are opened with the Stream ID for that stream and associated in
   return to the server's canonical NetConnection control flow.

   The client MAY create as many flows as desired for any Stream ID
   (including Stream ID 0) at any time.

<span class="h5"><a class="dashAnchor" name="//apple_ref/Section/5.3.5.2.%20%20From%20Server"></a><a class="selflink" href="#section-5.3.5.2" name="section-5.3.5.2">5.3.5.2</a>.  From Server</span>

   Additional flows from the server to the client for stream messages
   are opened with the Stream ID for that stream, and associated in
   return to the client's NetConnection control flow.




<span class="grey">Thornburgh                    Informational                    [Page 40]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-41" id="page-41" name="page-41"> </a>
<span class="grey"><a href="rfc7425.html">RFC 7425</a>           Adobe RTMFP for Flash Communication     December 2014</span>


   The server MAY create as many flows as desired for any Stream ID
   (including Stream ID 0) at any time.

<span class="h5"><a class="dashAnchor" name="//apple_ref/Section/5.3.5.3.%20%20Closing%20Stream%20Flows"></a><a class="selflink" href="#section-5.3.5.3" name="section-5.3.5.3">5.3.5.3</a>.  Closing Stream Flows</span>

   Either end MAY close a sending flow that is not for Stream ID 0 at
   any time with no semantic meaning for the stream.

   At any time, either end MAY reject a receiving flow that is not one
   of the other end's NetConnection control flows.  No flow exception
   codes are defined by this profile, so the receiving end SHOULD use
   exception code 0 when rejecting the flow.  The sending end, on
   notification of any exception for a stream flow, SHOULD NOT open a
   new flow to take the rejected flow's place for transport of messages
   for that stream.  If an end rejects any flow for a stream, it SHOULD
   reject all the flows for that stream, otherwise Flow Synchronization
   messages (<a href="#section-5.2">Section 5.2</a>) that were in flight could be discarded and
   some flows might become or remain stuck in a suspended state.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/5.3.6.%20%20Closing%20the%20Connection"></a><a class="selflink" href="#section-5.3.6" name="section-5.3.6">5.3.6</a>.  Closing the Connection</span>

   The client or server can signal an orderly close of the connection by
   closing its NetConnection control sending flows and all stream
   sending flows.  The other end, on receiving a close/complete
   notification for the canonical NetConnection control receiving flow,
   closes its sending flows.  When both ends observe all receiving flows
   have closed and completed, the connection has cleanly terminated.

   Either end can abruptly terminate the connection by rejecting the
   NetConnection control receiving flows or by closing the underlying
   RTMFP session.  On notification of any exception on a NetConnection
   control sending flow, the end seeing the exception knows the other
   end has terminated abruptly, and can immediately close all sending
   and receiving flows for that connection.

















<span class="grey">Thornburgh                    Informational                    [Page 41]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-42" id="page-42" name="page-42"> </a>
<span class="grey"><a href="rfc7425.html">RFC 7425</a>           Adobe RTMFP for Flash Communication     December 2014</span>


<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/5.3.7.%20%20Example"></a><a class="selflink" href="#section-5.3.7" name="section-5.3.7">5.3.7</a>.  Example</span>

                 Client                    Server
                   |IHello (EPD:anc=URI)     |
               -+- |------------------------&gt;|
                |  |                         |
                |  |       RHello (RCert:anc)|
          RTMFP |  |&lt;------------------------|
         Session|  |                         |
          Hand- |  |IIKeying                 |
          shake |  |------------------------&gt;|
                |  |                         |
                |  |                 RIKeying|
               -+- |&lt;------------------------|
                   |                         |
               -+- |"connect" command        |
         (Str.ID=0)|-CFlow-0----------------&gt;|
                |  |                         |
                |  |       "_result" response|
          RTMP  |  |&lt;----------------SFlow-0-|(Str.ID=0,
         Connect|  |                         | Assoc=CFlow-0)
          Hand- |  |"setPeerInfo" command    |
          shake |  |-CFlow-0----------------&gt;|
               -+- |                         |
                   |"createStream" command   |
               -+- |-CFlow-0----------------&gt;|
                |  |                         |
                |  |     "_result" (str.ID=5)|
                |  |&lt;----------------SFlow-0-|
                |  |                         |
                |  |"play" command           |
         (Str.ID=5,|-CFlow-1----------------&gt;|
     Assoc=SFlow-0)|                         |
                |  | StreamBegin User Control|
                |  |&lt;----------------SFlow-1-|(Str.ID=5,
                |  |                         | Assoc=CFlow-0)
                |  |  (RTMP stream events)   |
     Streaming  |  |&lt;----------------SFlow-1-|
                |  |                         |
                |  |        Audio Data       |
                |  |&lt;----------------SFlow-2-|(Str.ID=5,
                |  |                         | Assoc=CFlow-0)
                |  |        Video Data       |
                |  |&lt;----------------SFlow-3-|(Str.ID=5,
                |  |            :            | Assoc=CFlow-0)
                   |            :            |

             Figure 5: Example NetConnection Message Exchange



<span class="grey">Thornburgh                    Informational                    [Page 42]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-43" id="page-43" name="page-43"> </a>
<span class="grey"><a href="rfc7425.html">RFC 7425</a>           Adobe RTMFP for Flash Communication     December 2014</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.4.%20%20Direct%20Peer-to-Peer%20Streams"></a><a class="selflink" href="#section-5.4" name="section-5.4">5.4</a>.  Direct Peer-to-Peer Streams</span>

   Clients can connect directly to other clients for P2P streaming and
   data exchange.  A client MAY have multiple separate P2P NetStreams
   with a peer in one RTMFP session, each a separate logical connection.
   P2P NetStreams are unidirectional, initiated by a subscriber (the
   side issuing the "play" command) to a publisher.  The subscribing
   peer has a control flow to the publisher.  The publisher has zero or
   more return flows to the subscriber associated to the subscriber's
   control flow, for the stream media and data.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/5.4.1.%20%20Connecting"></a><a class="selflink" href="#section-5.4.1" name="section-5.4.1">5.4.1</a>.  Connecting</span>

   A client desires to subscribe directly to a stream being published in
   P2P mode by a publishing peer.  The client learns the peer ID of the
   publisher and the stream name through application-specific means.

   If the client does not already have an RTMFP session with that peer
   ID, it initiates a new session, creating an EPD containing a
   Fingerprint option (<a href="#section-4.4.2.3">Section 4.4.2.3</a>) for the publisher's peer ID and
   using the server session's DESTADDR as the initial candidate address
   for the session to the peer.  The server acts as an Introducer
   (<a href="rfc7016.html#section-3.5.1.6">Section 3.5.1.6 of RFC 7016</a>), using forward and redirect messages to
   help the client and the peer establish a session.

   When an S_OPEN session exists to the desired peer, the client creates
   a new independent flow to that peer.  The flow MUST have a non-zero
   Stream ID.  The client sends an RTMP "play" command over the flow,
   giving the name of the desired stream at the publisher.  This flow is
   the subscriber's control flow.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/5.4.2.%20%20Return%20Flows%20for%20Stream"></a><a class="selflink" href="#section-5.4.2" name="section-5.4.2">5.4.2</a>.  Return Flows for Stream</span>

   The publisher, on accepting a new flow not indicating a return
   association with any of its sending flows and having a non-zero
   Stream ID, receives and processes the "play" command.  If and when
   the request is acceptable to the publisher, it opens one or more
   return flows to the subscribing peer, associated to the subscriber's
   control flow and having the same Stream ID.  The publisher sends a
   StreamBegin User Control message, appropriate RTMP status events, and
   the stream media over the one or more return flows.

   The subscriber uses the return association of the media flows to the
   subscriber control flow to determine the stream to which the media
   belongs.






<span class="grey">Thornburgh                    Informational                    [Page 43]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-44" id="page-44" name="page-44"> </a>
<span class="grey"><a href="rfc7425.html">RFC 7425</a>           Adobe RTMFP for Flash Communication     December 2014</span>


   The publisher MAY open any number of media flows for the stream and
   close them at any time.  The opening and closing of media flows has
   no semantic meaning for the stream, except that the opening of at
   least one flow and the reception of at least one media message or a
   StreamBegin User Control message indicates that the publisher is
   publishing the requested stream to the subscriber.

         Subscriber                                     Publisher
         ------&gt;--Subscriber-Control-Flow------------------&gt;--+
                                                              |
               &lt;------------------Publisher-Stream-Flow-1--&lt;--+
                                              :               |
               &lt;------------------Publisher-Stream-Flow-N--&lt;--+

   Figure 6: Schematic Flow Association Tree for a P2P Direct Connection

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/5.4.3.%20%20Closing%20the%20Connection"></a><a class="selflink" href="#section-5.4.3" name="section-5.4.3">5.4.3</a>.  Closing the Connection</span>

   Either end can close the stream by closing or rejecting the
   subscriber's control flow.  The publisher SHOULD close and unpublish
   to the subscriber on receipt of a close/complete of the control flow.
   The subscriber SHOULD consider the stream closed on notification of
   any exception on the control flow.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/6.%20%20IANA%20Considerations"></a><a class="selflink" href="#section-6" name="section-6">6</a>.  IANA Considerations</span>

   This memo specifies option type code values for Certificate fields
   (<a href="#section-4.3.3">Section 4.3.3</a>), Endpoint Discriminator fields (<a href="#section-4.4.2">Section 4.4.2</a>), and
   Session Keying Component fields (<a href="#section-4.5.2">Section 4.5.2</a>).  It also specifies a
   flow metadata signature (<a href="#section-5.1.1">Section 5.1.1</a>).  The type code values and
   signatures for this profile are assigned and maintained by Adobe, and
   therefore require no action from IANA.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/6.1.%20%20RTMFP%20URI%20Scheme%20Registration"></a><a class="selflink" href="#section-6.1" name="section-6.1">6.1</a>.  RTMFP URI Scheme Registration</span>

   This memo describes use of an RTMFP URI scheme (<a href="#section-4.4.2.2">Section 4.4.2.2</a>,
   <a href="#section-5.3.1">Section 5.3.1</a>, Figure 5).  Per this section, the "rtmfp" URI scheme
   has been registered by IANA.

   The syntax and semantics of this URI scheme are described using the
   Augmented Backus-Naur Form (ABNF) [<a href="rfc5234.html" title='"Augmented BNF for Syntax Specifications: ABNF"'>RFC5234</a>] rules from <a href="rfc3986.html">RFC 3986</a>.










<span class="grey">Thornburgh                    Informational                    [Page 44]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-45" id="page-45" name="page-45"> </a>
<span class="grey"><a href="rfc7425.html">RFC 7425</a>           Adobe RTMFP for Flash Communication     December 2014</span>


   URI scheme name:  rtmfp

   Status:  provisional

   URI scheme syntax:

      rtmfp-uri-scheme = "rtmfp:"
                       / "rtmfp://" host [ ":" port ] path-abempty

   URI scheme semantics:  The first form is used in the APIs of some
      implementations to indicate instantiation of an RTMFP client
      according to this memo, but without connecting to a server.  Such
      an instantiation might be used for pure peer-to-peer
      communication.

      The second form provides location information for the server to
      which to connect and optional additional information to pass to
      the server.  The only operation for this URI form is to connect to
      a server (initial candidate address(es) for which are named by
      host and port) according to <a href="#section-5.3">Section 5.3</a>.  The UDP port for initial
      candidate addresses, if not specified, is 1935.  If the host is a
      reg-name, the initial candidate address set SHOULD comprise all
      IPv4 and IPv6 addresses to which reg-name resolves.  The semantics
      of path-abempty are specific to the server.  Connections are made
      using RTMFP as specified by this memo.

   Encoding considerations:  The path-abempty component represents
      textual data consisting of characters from the Universal Character
      Set.  This component SHOULD be encoded according to <a href="rfc3986.html#section-2.5">Section 2.5 of
      RFC 3986</a>.

   Applications/protocols that use this URI scheme name:  The Flash
      runtime (including Flash Player) from Adobe Systems Incorporated,
      communication servers such as Adobe Media Server, and
      interoperable clients and servers provided by other parties, using
      RTMFP according to this memo.

   Interoperability considerations:  This scheme requires use of RTMFP
      as defined by <a href="rfc7016.html">RFC 7016</a> in the manner described by this memo.

   Security considerations:  See Security Considerations (<a href="#section-7">Section 7</a>) in
      this memo.

   Contact:  Michael Thornburgh, Adobe Systems Incorporated,
      &lt;mthornbu@adobe.com&gt;.

   Author/Change controller:  Michael Thornburgh, Adobe Systems
      Incorporated, &lt;mthornbu@adobe.com&gt;.



<span class="grey">Thornburgh                    Informational                    [Page 45]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-46" id="page-46" name="page-46"> </a>
<span class="grey"><a href="rfc7425.html">RFC 7425</a>           Adobe RTMFP for Flash Communication     December 2014</span>


   References:
      Thornburgh, M., "Adobe's Secure Real-Time Media Flow Protocol",
      <a href="rfc7016.html">RFC 7016</a>, November 2013.

      This memo.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/7.%20%20Security%20Considerations"></a><a class="selflink" href="#section-7" name="section-7">7</a>.  Security Considerations</span>

   <a href="#section-4">Section 4</a> details the cryptographic aspects of this profile.

   This profile does not define or use a Public Key Infrastructure
   (PKI).  Clients SHOULD use static Diffie-Hellman keys in their
   certificates (<a href="#section-4.3.3.5">Section 4.3.3.5</a>).  Clients MUST create a new
   certificate with a distinct fingerprint for each new NetConnection
   (<a href="#section-5.3">Section 5.3</a>).  These constraints make client identities ephemeral
   but unable to be forged.  A man-in-the-middle cannot successfully
   interpose itself in a connection to a target client addressed by its
   fingerprint/peer ID if the target client uses a static Diffie-Hellman
   public key.

   Servers can have long-lived RTMFP instances, so they SHOULD use
   ephemeral Diffie-Hellman public keys for forward secrecy.  This
   allows server peer IDs to be forged; however, clients do not connect
   to servers by peer ID, so this is irrelevant.

   When a client connects to a server, the client will accept the
   response of any endpoint claiming to be "a server".  It is assumed
   that an attacker that can passively observe traffic on a network
   segment can also inject its own packets with any source or
   destination and any payload.  An attacker can trick a client into
   connecting to a rogue server or man-in-the-middle, either by
   observing Initiator Hello packets from the client and responding
   earliest with a matching Responder Hello or by using tricks such as
   DNS spoofing or poisoning to direct a client to connect directly to
   the rogue.  A TCP-based transport would be vulnerable to similar
   attacks.  Since there is no PKI, this profile gives no guarantee that
   the client has actually connected to the desired server, versus a
   rogue or man-in-the-middle.  In circumstances where assurance is
   required that the connection is directly to the desired server, the
   client can use the Session Nonces (<a href="#section-4.6.5">Section 4.6.5</a>) to challenge the
   server, for example, over a different channel having acceptable
   security properties (such as an HTTPS) to transitively establish the
   server's identity and verify that the end-to-end communication is
   private and authentic.

   When session sequence numbers (<a href="#section-4.7.3.3">Section 4.7.3.3</a>) are not used, it is
   possible for an attacker to use traffic analysis techniques and
   record encrypted packets containing the start of a new flow, and



<span class="grey">Thornburgh                    Informational                    [Page 46]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-47" id="page-47" name="page-47"> </a>
<span class="grey"><a href="rfc7425.html">RFC 7425</a>           Adobe RTMFP for Flash Communication     December 2014</span>


   later to replay those packets after the flow has closed, which can
   look to the receiver like a brand new flow.  In circumstances where
   this can be detrimental, session sequence numbers SHOULD be used.
   Replay of packets for existing flows is not detrimental as the
   receiver detects and discards duplicate flow sequence numbers, and
   flow sequence numbers do not wrap or otherwise repeat.

   Packet encryption uses CBC with the same (null) initialization vector
   for each packet.  This can reveal to an observer whether two packets
   contain identical plaintext.  However, the maximum-length RTMFP
   common header and User Data or Data Acknowledgement header, including
   flow sequence number, always fit within the first 16-byte cipher
   block, so each initial cipher block for most packets will already be
   unique even if timestamps are suppressed.  Sending identical messages
   in a flow uses unique flow sequence numbers, so cipher blocks will be
   unique in this case.  Keepalive pings and retransmission of lost data
   can result in identical cipher blocks; however, traffic analysis can
   also reveal likely keepalives or retransmissions, and retransmission
   only occurs as a result of observable network loss, so this is
   usually irrelevant.  In circumstances where any identical cipher
   block is unacceptable, session sequence numbers SHOULD be used as
   they guarantee each initial cipher block will be unique.

   Packet verification can use a 16-bit simple checksum
   (<a href="#section-4.7.3.1">Section 4.7.3.1</a>).  The checksum is inside the encrypted packet, so
   for external packet modifications the checksum is equivalent to a
   16-bit cryptographic digest.  In circumstances where this is
   insufficient, HMAC verification (<a href="#section-4.7.3.2">Section 4.7.3.2</a>) SHOULD be used.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/8.%20%20References"></a><a class="selflink" href="#section-8" name="section-8">8</a>.  References</span>

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/8.1.%20%20Normative%20References"></a><a class="selflink" href="#section-8.1" name="section-8.1">8.1</a>.  Normative References</span>

   [<a id="ref-AES" name="ref-AES">AES</a>]      National Institute of Standards and Technology, "Advanced
              Encryption Standard (AES)", FIPS PUB 197, November 2001,
              &lt;<a href="http://csrc.nist.gov/publications/fips/fips197/fips-197.pdf">http://csrc.nist.gov/publications/fips/fips197/</a>
              <a href="http://csrc.nist.gov/publications/fips/fips197/fips-197.pdf">fips-197.pdf</a>&gt;.

   [<a id="ref-AMF0" name="ref-AMF0">AMF0</a>]     Adobe Systems Incorporated, "Action Message Format -- AMF
              0", December 2007, &lt;<a href="http://www.adobe.com/go/spec_amf0">http://www.adobe.com/go/spec_amf0</a>&gt;.

   [<a id="ref-AMF3" name="ref-AMF3">AMF3</a>]     Adobe Systems Incorporated, "Action Message Format -- AMF
              3", January 2013, &lt;<a href="http://www.adobe.com/go/spec_amf3">http://www.adobe.com/go/spec_amf3</a>&gt;.

   [<a id="ref-CBC" name="ref-CBC">CBC</a>]      Dworkin, M., "Recommendation for Block Cipher Modes of
              Operation", NIST Special Publication 800-38A, December
              2001, &lt;<a href="http://csrc.nist.gov/publications/nistpubs/800-38a/sp800-38a.pdf">http://csrc.nist.gov/publications/nistpubs/800-38a/</a>
              <a href="http://csrc.nist.gov/publications/nistpubs/800-38a/sp800-38a.pdf">sp800-38a.pdf</a>&gt;.



<span class="grey">Thornburgh                    Informational                    [Page 47]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-48" id="page-48" name="page-48"> </a>
<span class="grey"><a href="rfc7425.html">RFC 7425</a>           Adobe RTMFP for Flash Communication     December 2014</span>


   [<a id="ref-DH" name="ref-DH">DH</a>]       Diffie, W. and M. Hellman, "New Directions in
              Cryptography", IEEE Transactions on Information Theory, V.
              IT-22, n. 6, June 1977.

   [<a id="ref-RFC2104" name="ref-RFC2104">RFC2104</a>]  Krawczyk, H., Bellare, M., and R. Canetti, "HMAC: Keyed-
              Hashing for Message Authentication", <a href="rfc2104.html">RFC 2104</a>, February
              1997, &lt;<a href="http://www.rfc-editor.org/info/rfc2104">http://www.rfc-editor.org/info/rfc2104</a>&gt;.

   [<a id="ref-RFC2119" name="ref-RFC2119">RFC2119</a>]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", <a href="https://tools.ietf.org/html/bcp14">BCP 14</a>, <a href="rfc2119.html">RFC 2119</a>, March 1997,
              &lt;<a href="http://www.rfc-editor.org/info/rfc2119">http://www.rfc-editor.org/info/rfc2119</a>&gt;.

   [<a id="ref-RFC3526" name="ref-RFC3526">RFC3526</a>]  Kivinen, T. and M. Kojo, "More Modular Exponential (MODP)
              Diffie-Hellman groups for Internet Key Exchange (IKE)",
              <a href="rfc3526.html">RFC 3526</a>, May 2003,
              &lt;<a href="http://www.rfc-editor.org/info/rfc3526">http://www.rfc-editor.org/info/rfc3526</a>&gt;.

   [<a id="ref-RFC3629" name="ref-RFC3629">RFC3629</a>]  Yergeau, F., "UTF-8, a transformation format of ISO
              10646", STD 63, <a href="rfc3629.html">RFC 3629</a>, November 2003,
              &lt;<a href="http://www.rfc-editor.org/info/rfc3629">http://www.rfc-editor.org/info/rfc3629</a>&gt;.

   [<a id="ref-RFC3986" name="ref-RFC3986">RFC3986</a>]  Berners-Lee, T., Fielding, R., and L. Masinter, "Uniform
              Resource Identifier (URI): Generic Syntax", STD 66, <a href="rfc3986.html">RFC</a>
              <a href="rfc3986.html">3986</a>, January 2005,
              &lt;<a href="http://www.rfc-editor.org/info/rfc3986">http://www.rfc-editor.org/info/rfc3986</a>&gt;.

   [<a id="ref-RFC5234" name="ref-RFC5234">RFC5234</a>]  Crocker, D. and P. Overell, "Augmented BNF for Syntax
              Specifications: ABNF", STD 68, <a href="rfc5234.html">RFC 5234</a>, January 2008,
              &lt;<a href="http://www.rfc-editor.org/info/rfc5234">http://www.rfc-editor.org/info/rfc5234</a>&gt;.

   [<a id="ref-RFC6234" name="ref-RFC6234">RFC6234</a>]  Eastlake, D. and T. Hansen, "US Secure Hash Algorithms
              (SHA and SHA-based HMAC and HKDF)", <a href="rfc6234.html">RFC 6234</a>, May 2011,
              &lt;<a href="http://www.rfc-editor.org/info/rfc6234">http://www.rfc-editor.org/info/rfc6234</a>&gt;.

   [<a id="ref-RFC7016" name="ref-RFC7016">RFC7016</a>]  Thornburgh, M., "Adobe's Secure Real-Time Media Flow
              Protocol", <a href="rfc7016.html">RFC 7016</a>, November 2013,
              &lt;<a href="http://www.rfc-editor.org/info/rfc7016">http://www.rfc-editor.org/info/rfc7016</a>&gt;.

   [<a id="ref-RFC7296" name="ref-RFC7296">RFC7296</a>]  Kaufman, C., Hoffman, P., Nir, Y., Eronen, P., and T.
              Kivinen, "Internet Key Exchange Protocol Version 2
              (IKEv2)", STD 79, <a href="rfc7296.html">RFC 7296</a>, October 2014,
              &lt;<a href="http://www.rfc-editor.org/info/rfc7296">http://www.rfc-editor.org/info/rfc7296</a>&gt;.

   [<a id="ref-RTMP" name="ref-RTMP">RTMP</a>]     Adobe Systems Incorporated, "Real-Time Messaging Protocol
              (RTMP) specification", December 2012,
              &lt;<a href="http://www.adobe.com/go/spec_rtmp">http://www.adobe.com/go/spec_rtmp</a>&gt;.





<span class="grey">Thornburgh                    Informational                    [Page 48]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-49" id="page-49" name="page-49"> </a>
<span class="grey"><a href="rfc7425.html">RFC 7425</a>           Adobe RTMFP for Flash Communication     December 2014</span>


   [<a id="ref-SHA256" name="ref-SHA256">SHA256</a>]   National Institute of Standards and Technology, "Secure
              Hash Standard", FIPS PUB 180-4, March 2012,
              &lt;<a href="http://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf">http://csrc.nist.gov/publications/fips/fips180-4/</a>
              <a href="http://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf">fips-180-4.pdf</a>&gt;.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/8.2.%20%20Informative%20References"></a><a class="selflink" href="#section-8.2" name="section-8.2">8.2</a>.  Informative References</span>

   [<a id="ref-RFC1035" name="ref-RFC1035">RFC1035</a>]  Mockapetris, P., "Domain names - implementation and
              specification", STD 13, <a href="rfc1035.html">RFC 1035</a>, November 1987,
              &lt;<a href="http://www.rfc-editor.org/info/rfc1035">http://www.rfc-editor.org/info/rfc1035</a>&gt;.

   [<a id="ref-RFC1071" name="ref-RFC1071">RFC1071</a>]  Braden, R., Borman, D., Partridge, C., and W. Plummer,
              "Computing the Internet checksum", <a href="rfc1071.html">RFC 1071</a>, September
              1988, &lt;<a href="http://www.rfc-editor.org/info/rfc1071">http://www.rfc-editor.org/info/rfc1071</a>&gt;.

   [<a id="ref-RFC4302" name="ref-RFC4302">RFC4302</a>]  Kent, S., "IP Authentication Header", <a href="rfc4302.html">RFC 4302</a>, December
              2005, &lt;<a href="http://www.rfc-editor.org/info/rfc4302">http://www.rfc-editor.org/info/rfc4302</a>&gt;.

   [<a id="ref-RFC4303" name="ref-RFC4303">RFC4303</a>]  Kent, S., "IP Encapsulating Security Payload (ESP)", <a href="rfc4303.html">RFC</a>
              <a href="rfc4303.html">4303</a>, December 2005,
              &lt;<a href="http://www.rfc-editor.org/info/rfc4303">http://www.rfc-editor.org/info/rfc4303</a>&gt;.

   [<a id="ref-RFC6479" name="ref-RFC6479">RFC6479</a>]  Zhang, X. and T. Tsou, "IPsec Anti-Replay Algorithm
              without Bit Shifting", <a href="rfc6479.html">RFC 6479</a>, January 2012,
              &lt;<a href="http://www.rfc-editor.org/info/rfc6479">http://www.rfc-editor.org/info/rfc6479</a>&gt;.

Acknowledgements

   Special thanks go to Glenn Eguchi, Matthew Kaufman, and Adam Lane for
   their contributions to the design of this profile.

   Thanks to Philipp Hancke, Kevin Igoe, Paul Kyzivat, and Milos
   Trboljevac for their detailed reviews of this memo.

Author's Address

   Michael C. Thornburgh
   Adobe Systems Incorporated
   345 Park Avenue
   San Jose, CA  95110-2704
   United States

   Phone: +1 408 536 6000
   EMail: mthornbu@adobe.com
   URI:   <a href="http://www.adobe.com/">http://www.adobe.com/</a>






Thornburgh                    Informational                    [Page 49]

</pre><br/>
    <span class="noprint"><small><small>Html markup produced by rfcmarkup 1.126, available from
      <a href="https://tools.ietf.org/tools/rfcmarkup/">https://tools.ietf.org/tools/rfcmarkup/</a>
    </small></small></span>
  </div>




</body><!-- Mirrored from tools.ietf.org/html/rfc7425 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 06 Mar 2018 23:18:21 GMT --></html>