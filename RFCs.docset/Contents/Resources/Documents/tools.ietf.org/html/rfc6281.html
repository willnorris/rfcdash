<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml"><!-- Mirrored from tools.ietf.org/html/rfc6281 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 06 Mar 2018 23:18:31 GMT --><!-- Added by HTTrack --><head><meta content="text/html;charset=utf-8" http-equiv="content-type"/><!-- /Added by HTTrack -->

    <meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
    <meta content="index,follow" name="robots"/>
    <meta content="rfcmarkup version 1.126" name="creator"/>
    <link href="http://purl.org/dc/elements/1.1/" rel="schema.DC"/>
<meta content="urn:ietf:rfc:6281" name="DC.Identifier"/>
<meta content="This draft describes the implementation of Apple Inc.'s Back to My
Mac (BTMM) service. BTMM provides network connectivity between devices
so that a user can perform file sharing and screen sharing among
multiple computers at home, at work, or on the road. The
implementation of BTMM addresses the issues of single sign-on
authentication, secure data communication, service discovery and end-
to-end connectivity in face of Network Address Translators (NAT) and
mobility of devices." name="DC.Description.Abstract"/>
<meta content="Zhang, Lixia" name="DC.Creator"/>
<meta content="Zhu, Zhenkai" name="DC.Creator"/>
<meta content="Wakikawa, Ryuji" name="DC.Creator"/>
<meta content="June, 2011" name="DC.Date.Issued"/>
<meta content="Understanding Apple's Back to My Mac Service" name="DC.Title"/>

    <link href="https://tools.ietf.org/images/rfc.png" rel="icon" type="image/png"/>
    <link href="https://tools.ietf.org/images/rfc.png" rel="shortcut icon" type="image/png"/>
    <title>RFC 6281 - Understanding Apple's Back to My Mac Service</title>
    
    
    <style type="text/css">
	@media only screen 
	  and (min-width: 992px)
	  and (max-width: 1199px) {
	    body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 768px)
	  and (max-width: 991px) {
            body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 480px)
	  and (max-width: 767px) {
            body { font-size: 11pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (max-width: 479px) {
            body { font-size: 8pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-device-width : 375px) 
	  and (max-device-width : 667px) {
            body { font-size: 9.5pt; }
            div.content { width: 96ex; margin: 0 1px; }
        }
	@media only screen 
	  and (min-device-width: 1200px) {
            body { font-size: 10pt; margin: 0 4em; }
            div.content { width: 96ex; margin: 0; }
        }
        h1, h2, h3, h4, h5, h6, .h1, .h2, .h3, .h4, .h5, .h6 {
	    font-weight: bold;
            line-height: 0pt;
            display: inline;
            white-space: pre;
            font-family: monospace;
            font-size: 1em;
	    font-weight: bold;
        }
        pre {
            font-size: 1em;
            margin-top: 0px;
            margin-bottom: 0px;
        }
	.pre {
	    white-space: pre;
	    font-family: monospace;
	}
	.header{
	    font-weight: bold;
	}
        .newpage {
            page-break-before: always;
        }
        .invisible {
            text-decoration: none;
            color: white;
        }
        a.selflink {
          color: black;
          text-decoration: none;
        }
        @media print {
            body {
                font-family: monospace;
                font-size: 10.5pt;
            }
            h1, h2, h3, h4, h5, h6 {
                font-size: 1em;
            }
        
            a:link, a:visited {
                color: inherit;
                text-decoration: none;
            }
            .noprint {
                display: none;
            }
        }
	@media screen {
	    .grey, .grey a:link, .grey a:visited {
		color: #777;
	    }
            .docinfo {
                background-color: #EEE;
            }
            .top {
                border-top: 7px solid #EEE;
            }
            .bgwhite  { background-color: white; }
            .bgred    { background-color: #F44; }
            .bggrey   { background-color: #666; }
            .bgbrown  { background-color: #840; }            
            .bgorange { background-color: #FA0; }
            .bgyellow { background-color: #EE0; }
            .bgmagenta{ background-color: #F4F; }
            .bgblue   { background-color: #66F; }
            .bgcyan   { background-color: #4DD; }
            .bggreen  { background-color: #4F4; }

            .legend   { font-size: 90%; }
            .cplate   { font-size: 70%; border: solid grey 1px; }
	}
    </style>
    <!--[if IE]>
    <style>
    body {
       font-size: 13px;
       margin: 10px 10px;
    }
    </style>
    <![endif]-->

    <script type="text/javascript"><!--
    function addHeaderTags() {
	var spans = document.getElementsByTagName("span");
	for (var i=0; i < spans.length; i++) {
	    var elem = spans[i];
	    if (elem) {
		var level = elem.getAttribute("class");
                if (level == "h1" || level == "h2" || level == "h3" || level == "h4" || level == "h5" || level == "h6") {
                    elem.innerHTML = "<"+level+">"+elem.innerHTML+"</"+level+">";		
                }
	    }
	}
    }
    var legend_html = "Colour legend:<br />      <table>         <tr><td>Unknown:</td>                   <td><span class='cplate bgwhite'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft:</td>                     <td><span class='cplate bgred'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Informational:</td>             <td><span class='cplate bgorange'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Experimental:</td>              <td><span class='cplate bgyellow'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Best Common Practice:</td>      <td><span class='cplate bgmagenta'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Proposed Standard:</td>         <td><span class='cplate bgblue'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft Standard (old designation):</td> <td><span class='cplate bgcyan'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Internet Standard:</td>         <td><span class='cplate bggreen'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Historic:</td>                  <td><span class='cplate bggrey'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Obsolete:</td>                  <td><span class='cplate bgbrown'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>     </table>";
    function showElem(id) {
        var elem = document.getElementById(id);
        elem.innerHTML = eval(id+"_html");
        elem.style.visibility='visible';
    }
    function hideElem(id) {
        var elem = document.getElementById(id);
        elem.style.visibility='hidden';        
        elem.innerHTML = "";
    }
    // -->
    </script>
</head>
<body onload="addHeaderTags()">
  <div class="content">
   <div style="height: 13px;">
      <div class="pre noprint docinfo bgorange" onclick="showElem('legend');" onmouseout="hideElem('legend')" onmouseover="this.style.cursor='pointer';" style="height: 6px; position: absolute;" title="Click for colour legend.">                                                                        </div>
      <div class="docinfo noprint pre legend" id="legend" onmouseout="hideElem('legend');" onmouseover="showElem('legend');" style="position:absolute; top: 4px; left: 4ex; visibility:hidden; background-color: white; padding: 4px 9px 5px 7px; border: solid #345 1px; ">
      </div>
   </div>
<span class="pre noprint docinfo top">[<a href="index.html" title="Document search and retrieval page">Docs</a>] [<a href="https://tools.ietf.org/rfc/rfc6281.txt" title="Plaintext version of this document">txt</a>|<a href="https://tools.ietf.org/pdf/rfc6281" title="PDF version of this document">pdf</a>] [<a href="https://tools.ietf.org/html/draft-zhu-mobileme-doc" title="draft-zhu-mobileme-doc">draft-zhu-mobil...</a>] [<a href="https://datatracker.ietf.org/doc/rfc6281" title="IESG Datatracker information for this document">Tracker</a>] [<a href="https://tools.ietf.org/rfcdiff?difftype=--hwdiff&amp;url2=rfc6281" title="Inline diff (wdiff)">Diff1</a>] [<a href="https://tools.ietf.org/rfcdiff?url2=rfc6281" title="Side-by-side diff">Diff2</a>] [<a href="https://www.rfc-editor.org/errata_search.php?rfc=6281">Errata</a>]</span><br/>
<span class="pre noprint docinfo">                                                                        </span><br/>
<span class="pre noprint docinfo">                                                           INFORMATIONAL</span><br/>
<span class="pre noprint docinfo">                                                            <span style="color: #C00;">Errata Exist</span></span><br/>
<pre>Internet Engineering Task Force (IETF)                       S. Cheshire
Request for Comments: 6281                                    Apple Inc.
Category: Informational                                           Z. Zhu
ISSN: 2070-1721                                                     UCLA
                                                             R. Wakikawa
                                                              Toyota ITC
                                                                L. Zhang
                                                                    UCLA
                                                               June 2011


          <span class="h1">Understanding Apple's Back to My Mac (BTMM) Service</span>

Abstract

   This document describes the implementation of Apple Inc.'s Back to My
   Mac (BTMM) service.  BTMM provides network connectivity between
   devices so that a user can perform file sharing and screen sharing
   among multiple computers at home, at work, or on the road.  The
   implementation of BTMM addresses the issues of single sign-on
   authentication, secure data communication, service discovery, and
   end-to-end connectivity in the face of Network Address Translators
   (NATs) and mobility of devices.

Status of This Memo

   This document is not an Internet Standards Track specification; it is
   published for informational purposes.

   This document is a product of the Internet Engineering Task Force
   (IETF).  It represents the consensus of the IETF community.  It has
   received public review and has been approved for publication by the
   Internet Engineering Steering Group (IESG).  Not all documents
   approved by the IESG are a candidate for any level of Internet
   Standard; see <a href="rfc5741.html#section-2">Section 2 of RFC 5741</a>.

   Information about the current status of this document, any errata,
   and how to provide feedback on it may be obtained at
   <a href="http://www.rfc-editor.org/info/rfc6281">http://www.rfc-editor.org/info/rfc6281</a>.












<span class="grey">Cheshire, et al.              Informational                     [Page 1]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-2" id="page-2" name="page-2"> </a>
<span class="grey"><a href="rfc6281.html">RFC 6281</a>                          BTMM                         June 2011</span>


Copyright Notice

   Copyright (c) 2011 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to <a href="https://tools.ietf.org/html/bcp78">BCP 78</a> and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (<a href="http://trustee.ietf.org/license-info">http://trustee.ietf.org/license-info</a>) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.

Table of Contents

   <a href="#section-1">1</a>.  Introduction . . . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-2">2</a>
   <a href="#section-2">2</a>.  An Overview of Back to My Mac  . . . . . . . . . . . . . . . .  <a href="#page-3">3</a>
   <a href="#section-3">3</a>.  Encoding Host Information in DNS Resource Records  . . . . . .  <a href="#page-5">5</a>
   <a href="#section-4">4</a>.  NAT Traversal  . . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-6">6</a>
     <a href="#section-4.1">4.1</a>.  Introduction to NAT-PMP  . . . . . . . . . . . . . . . . .  <a href="#page-6">6</a>
     <a href="#section-4.2">4.2</a>.  Requesting/Removing a Port Mapping . . . . . . . . . . . .  <a href="#page-7">7</a>
     <a href="#section-4.3">4.3</a>.  Obtaining NAT Box's Public IP Address  . . . . . . . . . .  <a href="#page-7">7</a>
     <a href="#section-4.4">4.4</a>.  Unsupported Scenarios  . . . . . . . . . . . . . . . . . .  <a href="#page-8">8</a>
   <a href="#section-5">5</a>.  Handling IP Address or Port Changes  . . . . . . . . . . . . .  <a href="#page-8">8</a>
     <a href="#section-5.1">5.1</a>.  Updating Local Interfaces and Tunnels  . . . . . . . . . .  <a href="#page-8">8</a>
     <a href="#section-5.2">5.2</a>.  Dynamically Updating Reachability Information  . . . . . .  <a href="#page-8">8</a>
     5.3.  Getting Up-to-Date DNS Resource Records without Polling  .  9
   <a href="#section-6">6</a>.  IPv6 ULA as Host ID  . . . . . . . . . . . . . . . . . . . . . <a href="#page-11">11</a>
     <a href="#section-6.1">6.1</a>.  The Need for a Host Identifier . . . . . . . . . . . . . . <a href="#page-11">11</a>
     <a href="#section-6.2">6.2</a>.  What to Use as Host Identifiers  . . . . . . . . . . . . . <a href="#page-11">11</a>
     <a href="#section-6.3">6.3</a>.  IPv6 ULA Configuration . . . . . . . . . . . . . . . . . . <a href="#page-11">11</a>
   <a href="#section-7">7</a>.  Securing Communication . . . . . . . . . . . . . . . . . . . . <a href="#page-12">12</a>
     <a href="#section-7.1">7.1</a>.  Authentication for Connecting to Remote Host . . . . . . . <a href="#page-12">12</a>
     <a href="#section-7.2">7.2</a>.  Authentication for DNS Exchanges . . . . . . . . . . . . . <a href="#page-12">12</a>
     <a href="#section-7.3">7.3</a>.  IPsec for Secure End-to-End Data Communication . . . . . . <a href="#page-13">13</a>
   <a href="#section-8">8</a>.  Security Considerations  . . . . . . . . . . . . . . . . . . . <a href="#page-14">14</a>
   <a href="#section-9">9</a>.  References . . . . . . . . . . . . . . . . . . . . . . . . . . <a href="#page-14">14</a>
     <a href="#section-9.1">9.1</a>.  Normative Reference  . . . . . . . . . . . . . . . . . . . <a href="#page-14">14</a>
     <a href="#section-9.2">9.2</a>.  Informative References . . . . . . . . . . . . . . . . . . <a href="#page-15">15</a>










<span class="grey">Cheshire, et al.              Informational                     [Page 2]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-3" id="page-3" name="page-3"> </a>
<span class="grey"><a href="rfc6281.html">RFC 6281</a>                          BTMM                         June 2011</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/1.%20%20Introduction"></a><a class="selflink" href="#section-1" name="section-1">1</a>.  Introduction</span>

   Apple Inc.'s Back to My Mac (BTMM) service was first shipped with MAC
   OS X 10.5 release in October 2007; since then, it has been widely
   used.  BTMM provides an integrated solution to host mobility support,
   NAT traversal, and secure end-to-end data delivery through a
   combination of several existing protocols and software tools instead
   of designing new protocols.  Note that we generally refer to Network
   Address Port Translation (NAPT) as NAT in this document.  This
   document describes the implementation of BTMM and describes how BTMM
   works in MAC OS X version 10.5.x; BTMM continues to evolve over time.

   BTMM provides secure transport connections among a set of devices
   that may be located over a dynamic and heterogeneous network
   environment.  Independent from whether a user is traveling and
   accessing the Internet via airport WiFi or staying at home behind a
   NAT, BTMM allows the user to connect to any Mac hosts with a click,
   after which the user can share files with remote computers or control
   the remote host through screen sharing.  When a user changes
   locations and thus also changes the IP address of his computer (e.g.,
   roaming around with a laptop and receiving dynamically allocated IP
   address), BTMM provides a means for the roaming host to update its
   reachability information to keep it reachable by the user's other Mac
   devices.  BTMM maintains end-to-end transport connections in the face
   of host IP address changes through the use of unique host
   identifiers.  It also provides a means to reach devices behind a NAT.

   BTMM achieves the above functions mainly by integrating a set of
   existing protocols and software tools.  It uses DNS-based Service
   Discovery [<a href="#ref-DNS-SD" title='"DNS-Based Service Discovery"'>DNS-SD</a>] to announce host reachability information, dynamic
   DNS update [<a href="rfc2136.html" title='"Dynamic Updates in the Domain Name System (DNS UPDATE)"'>RFC2136</a>] to refresh the DNS resource records (RRs) when a
   host detects network changes, and DNS Long-Lived Queries (LLQs)
   [<a href="#ref-DNS-LLQ" title='"DNS Long-Lived Queries"'>DNS-LLQ</a>] to notify hosts immediately when the answers to their
   earlier DNS queries have changed.  BTMM uses the IPv6 Unique Local
   Address (ULA) [<a href="rfc4193.html" title='"Unique Local IPv6 Unicast Addresses"'>RFC4193</a>] as the host identifier and employs the NAT
   Port Mapping Protocol (PMP) [<a href="#ref-NAT-PMP" title='"NAT Port Mapping Protocol (NAT-PMP)"'>NAT-PMP</a>] to assist NAT traversal.  It
   uses Kerberos [<a href="rfc4120.html" title='"The Kerberos Network Authentication Service (V5)"'>RFC4120</a>] for end-to-end authentication and uses IPsec
   [<a href="rfc4301.html" title='"Security Architecture for the Internet Protocol"'>RFC4301</a>] to secure data communications between two end hosts.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/2.%20%20An%20Overview%20of%20Back%20to%20My%20Mac"></a><a class="selflink" href="#section-2" name="section-2">2</a>.  An Overview of Back to My Mac</span>

   To keep an established TCP connection running while either of the two
   end hosts may change its IP address requires that the connection use
   unique and stable identifiers that do not change with the addresses,
   and that a mapping service exists between these stable identifiers
   and dynamically changing IP addresses.  BTMM uses DNS to provide this
   mapping service.  Figure 1 provides a sketch of the basic components
   in the BTMM implementation.



<span class="grey">Cheshire, et al.              Informational                     [Page 3]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-4" id="page-4" name="page-4"> </a>
<span class="grey"><a href="rfc6281.html">RFC 6281</a>                          BTMM                         June 2011</span>


           DDNS update    +--------+  DDNS update
         +---------------&gt;|        |&lt;-------+
         |                |  DNS   |        |
         |      LLQ       |        | LLQ    |
         |    +----------&gt;|        |&lt;----+  |
         |    |           |        |     |  |
         |    |           +--------+     |  |
         |    |                          |  |            +----------+
         |    V                      +---+--+----+       |          |
       +-+-------+                   |           +-------|          |
       |Endhost N|     Tunnel        |    NAT    +------&gt;|Endhost M |
       |         |&lt;=====================================&gt;|          |
       +---------+                   |           |       |          |
                                     +-----------+       +----------+

                                 Figure 1

   Apple Inc. operates a DNS domain called members.me.com and provides
   DNS name resolution services for all the subdomains underneath.
   Every BTMM user is assigned a DNS subdomain under members.me.com,
   e.g., alice.members.me.com.  The user then assigns a DNS name for
   each of her computers, e.g., myMacPro.alice.members.me.com.  The
   reachability information of each of the user's hosts is encoded in
   DNS resource records and published in the DNS.  For example, if the
   host myMacPro.alice.members.me.com has a public IPv4 address P, P
   represents the reachability information to the host.  On the other
   hand, if the host is behind a NAT, its reachability information is
   composed of the public IP address of the NAT box and the port number
   opened on the NAT to reach the internal host.  In this case, both the
   public IP address of the NAT box and the port number are encoded into
   DNS using DNS SRV records [<a href="rfc2782.html" title='"A DNS RR for specifying the location of services (DNS SRV)"'>RFC2782</a>], as we explain in the next
   section.  When a user logs in from a host M, M starts updating the
   DNS server about its reachability information.  If the user has
   multiple hosts, M also sets up LLQs with the DNS server for her other
   hosts, so that the DNS server can push any reachability changes of
   these other hosts to M immediately.

   To obtain a unique identifier for each host, BTMM automatically
   generates an IPv6 ULA for each host as its identifier at machine boot
   time.  This design choice allows BTMM to reuse all the existing code
   of applications and protocols that already support IPv6.  To ensure
   end-to-end data security, BTMM leverages the existing IPsec to
   protect the communications and Kerberos to perform end-to-end
   authentication.







<span class="grey">Cheshire, et al.              Informational                     [Page 4]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-5" id="page-5" name="page-5"> </a>
<span class="grey"><a href="rfc6281.html">RFC 6281</a>                          BTMM                         June 2011</span>


   BTMM provides an IPv6 socket interface to user applications.  It then
   wraps the IPv6 packets with IPsec Encapsulating Security Payload
   (ESP) [<a href="rfc4303.html" title='"IP Encapsulating Security Payload (ESP)"'>RFC4303</a>] and encapsulates the packets in a UDP/IP tunnel, as
   illustrated in Figure 2.  Note that this is the case even when both
   ends have public IPv4 addresses.

    +-------------+------------+------------+---------------+
    | IPv4 Header | UDP Header | IPsec ESP  | IPv6 Packet   |
    +-------------+------------+------------+---------------+

                                 Figure 2

   The following sections describe each of the basic components in BTMM.
   Since this document is intended to be an informal description of the
   BTMM implementation, it does not include all the details (e.g.,
   packet format, error code, etc) of each component.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/3.%20%20Encoding%20Host%20Information%20in%20DNS%20Resource%20Records"></a><a class="selflink" href="#section-3" name="section-3">3</a>.  Encoding Host Information in DNS Resource Records</span>

   For each host, BTMM encodes into DNS both the host identifier and its
   current location information.  BTMM stores the host identifier (IPv6
   ULA) in a DNS AAAA RR and uses a DNS SRV RR [<a href="rfc2782.html" title='"A DNS RR for specifying the location of services (DNS SRV)"'>RFC2782</a>] to represent
   the host's current location information.  For hosts behind a NAT box,
   the use of a DNS SRV RR allows BTMM to store both the public IP
   address of the NAT box and also the port opened for the host.

   The SRV RR consists of eight fields: _Service._Proto.Name, Time to
   Live (TTL), Class, Type, Priority, Weight, Port, and Target.  BTMM
   uses SRV RRs in the following way.

   Service is the symbolic name of the desired service.  In the BTMM
   case, the service is named "autotunnel", which means that the
   information contained in the SRV RR is used by BTMM to automatically
   set up a tunnel between two end hosts.

   Proto is the symbolic name of the desired protocol.  In this
   document, the protocol is "_udp".  BTMM uses "_udp" to tunnel packets
   between the two ends to achieve NAT traversal.

   Name is the domain this RR refers to.  When a user subscribes to BTMM
   service with the username "alice", a domain name
   "alice.members.me.com" is assigned to her.  The user assigns a name,
   such as "myMacPro", to each host that is appended to the assigned
   domain name.  Hence, the first part of the SRV record would look like
   this: "_autotunnel._udp.myMacPro.alice.members.me.com".

   Priority and Weight are set to zero, since there is only one instance
   that provides autotunnel service for each name in BTMM.



<span class="grey">Cheshire, et al.              Informational                     [Page 5]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-6" id="page-6" name="page-6"> </a>
<span class="grey"><a href="rfc6281.html">RFC 6281</a>                          BTMM                         June 2011</span>


   Port is the port opened on the target host of the service.  In BTMM,
   most likely it is the external port a NAT opened for the host behind
   it.  Knowing the port number is the basic requirement for NAT
   traversal via UDP encapsulation.  If the host is not behind a NAT,
   the port opened on the host for autotunnel service is placed here.

   Target is the canonical hostname of the host that provides the
   service.  In BTMM, it refers to a name constructed by appending the
   user's domain name to an autotunnel label, which identifies the host
   and is not generally user-visible.  The autotunnel label is created
   by concatenating "AutoTunnel" with the IEEE EUI-64 identifier [<a href="#ref-EUI64" title='"Guidelines for 64-bit Global Identifier (EUI-64)"'>EUI64</a>]
   of the primary network interface.  Hence, an example for the Target
   field would look like this: AutoTunnel-00-22-69-FF-FE-8E-34-
   2A.alice.members.me.com.  After obtaining the SRV RR, the remote host
   can query the A RR for the Target and get the external tunnel address
   for the BTMM client during the NAT Traversal.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/4.%20%20NAT%20Traversal"></a><a class="selflink" href="#section-4" name="section-4">4</a>.  NAT Traversal</span>

   BTMM's NAT traversal function requires NAT router devices to support
   NAT-PMP or the Universal Plug and Play (UPnP) Internet Gateway Device
   (IGD).  NAT-PMP is the alternative introduced by Apple Inc. to the
   more common IGD Standardized Device Control Protocol [<a href="#ref-IGD" title='"Internet Gateway Device (IGD) Standard Device Control Protocol"'>IGD</a>] as
   published in the UPnP Forum.  Both NAT-PMP and IGD require the NAT
   devices to be able to open a port for inbound traffic to some host
   behind it and to inform the host about its public IP address.  The
   differences between IGD and NAT-PMP can be found in [<a href="#ref-NAT-PMP" title='"NAT Port Mapping Protocol (NAT-PMP)"'>NAT-PMP</a>].  This
   section focuses on NAT-PMP.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.1.%20%20Introduction%20to%20NAT-PMP"></a><a class="selflink" href="#section-4.1" name="section-4.1">4.1</a>.  Introduction to NAT-PMP</span>

   NAT-PMP is a protocol that is designed specifically to handle the NAT
   traversal without manual configuration.  When a host determines that
   its primary IPv4 address is in one of the private IP address ranges
   defined in "Address Allocation for Private Internets" [<a href="rfc1918.html" title='"Address Allocation for Private Internets"'>RFC1918</a>], it
   invokes NAT-PMP to communicate with the NAT gateway to request the
   creation of inbound mappings on demand.  Having created a NAT mapping
   to allow inbound traffic, the client host then publishes its NAT
   box's public IP address and external port number in a DNS server.

   A host sends its Port Mapping Protocol request to the default
   gateway, which means that by default, this protocol is designed for
   small home networks where the host's default gateway is the NAT
   router.  If the host finds that NAT-PMP or UPnP IGD is not available
   on its network, it would proceed under the assumption that the
   network is a public network.





<span class="grey">Cheshire, et al.              Informational                     [Page 6]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-7" id="page-7" name="page-7"> </a>
<span class="grey"><a href="rfc6281.html">RFC 6281</a>                          BTMM                         June 2011</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.2.%20%20Requesting%2FRemoving%20a%20Port%20Mapping"></a><a class="selflink" href="#section-4.2" name="section-4.2">4.2</a>.  Requesting/Removing a Port Mapping</span>

   To request a port mapping, the client host sends its request packet
   via UDP to port 5351 of its configured gateway address and waits 250
   ms for a response [<a href="#ref-NAT-PMP" title='"NAT Port Mapping Protocol (NAT-PMP)"'>NAT-PMP</a>].  If no response is received after 250
   ms, the host repeats the process with exponential back-off.

   While requesting the port mapping, the host can specify the desired
   external port (e.g., the port that is identical to the internal port
   opened on the host), but the NAT device is not obliged to allocate
   the desired one.  If such a port is not available, the NAT device
   responds with another port.  The primary reason for allowing the host
   to request a specific port is to help recovery from a NAT device
   crash by allowing the host to request the same port number used
   before the crash.  This simple mechanism allows the end hosts
   (instead of the NAT box) to keep the mapping states, which turns hard
   state in the network into soft state, and enables automatic recovery
   whenever possible.

   The default port-mapping lifetime is 3600 seconds.  The host tries to
   renew the mapping every 1800 seconds.  The renewal message sent by
   the client host, whether for the purpose of extending the lease or
   recreating mappings after the NAT device reboots, is the same as the
   message requesting a port mapping.

   A mapping may be removed in a variety of ways.  If a client host
   fails to renew a mapping, the mapping is automatically deleted when
   its lifetime expires.  If the client host's DHCP address lease
   expires, the NAT device also automatically deletes the mapping.  A
   client host can also send an explicit packet to request the deletion
   of a mapping that is no longer needed.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.3.%20%20Obtaining%20NAT%20Box%27s%20Public%20IP%20Address"></a><a class="selflink" href="#section-4.3" name="section-4.3">4.3</a>.  Obtaining NAT Box's Public IP Address</span>

   To determine the public IP address of the NAT, the client host also
   sends the query packet to port 5351 of the configured gateway
   address.  The NAT device responds with a packet containing the public
   IP address of NAT.

   In case the public IP address of the NAT changes, the NAT gateway
   sends a gratuitous response to the link-local multicast address
   224.0.0.1, port 5350 to notify the clients about the new IP address,
   and the host can then update its DNS SRV record to reflect its new
   reachability as we describe in the next section.







<span class="grey">Cheshire, et al.              Informational                     [Page 7]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-8" id="page-8" name="page-8"> </a>
<span class="grey"><a href="rfc6281.html">RFC 6281</a>                          BTMM                         June 2011</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.4.%20%20Unsupported%20Scenarios"></a><a class="selflink" href="#section-4.4" name="section-4.4">4.4</a>.  Unsupported Scenarios</span>

   There are a number of situations where NAT-PMP (and consequently
   BTMM) does not work.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/4.4.1.%20%20NAT%20behind%20NAT"></a><a class="selflink" href="#section-4.4.1" name="section-4.4.1">4.4.1</a>.  NAT behind NAT</span>

   Some people's primary IP address assigned by their ISPs may itself be
   a NAT address.  In addition, some people may have a public IP
   address, but may put their hosts (perhaps unknowingly) behind
   multiple nested NAT boxes.  NAT traversal cannot be achieved with
   NAT-PMP in such situations.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/4.4.2.%20%20NATs%20and%20Routed%20Private%20Networks"></a><a class="selflink" href="#section-4.4.2" name="section-4.4.2">4.4.2</a>.  NATs and Routed Private Networks</span>

   In some cases, a site may run multiple subnets in the private network
   behind a NAT gateway.  Such subnetting breaks the assumption of NAT-
   PMP protocol because a host's default router is not necessarily the
   device performing NAT.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/5.%20%20Handling%20IP%20Address%20or%20Port%20Changes"></a><a class="selflink" href="#section-5" name="section-5">5</a>.  Handling IP Address or Port Changes</span>

   This section describes how BTMM handles IP address or port number
   changes, so that the hosts of the same user can find each other and
   keep ongoing TCP connections even after the changes happen at one or
   both ends.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.1.%20%20Updating%20Local%20Interfaces%20and%20Tunnels"></a><a class="selflink" href="#section-5.1" name="section-5.1">5.1</a>.  Updating Local Interfaces and Tunnels</span>

   After a BTMM client receives the notification about the network
   changes, it updates the list of active interfaces.  Then, the client
   sends requests to the NAT device (if it is behind a NAT) in order to
   create a port mapping and obtain the new public IP address.

   Next, the BTMM client makes changes to the local autotunnel
   interface, i.e., configures the IPv6 interface for the inner address
   of the tunnel.  If there are established tunnels, it scans to find
   those whose local inner/outer addresses have been changed since the
   tunnel was set up, and then puts in the current addresses.

   With all these done, the BTMM client publishes the changes to DNS.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.2.%20%20Dynamically%20Updating%20Reachability%20Information"></a><a class="selflink" href="#section-5.2" name="section-5.2">5.2</a>.  Dynamically Updating Reachability Information</span>

   The mobile nature of BTMM clients implies that dynamic DNS updates
   are required if the location information of hosts are to be published
   via DNS.




<span class="grey">Cheshire, et al.              Informational                     [Page 8]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-9" id="page-9" name="page-9"> </a>
<span class="grey"><a href="rfc6281.html">RFC 6281</a>                          BTMM                         June 2011</span>


   However, a mobile host may have dynamically updated an RR but the
   updated value has not been propagated to the authoritative DNS
   server, leaving stale RRs in the server.  Hence, Dynamic DNS Update
   Leases (DDULs) [<a href="#ref-DDUL" title='"Dynamic DNS Update Leases"'>DDUL</a>] are employed by BTMM to minimize the chances of
   stale RRs.  Note that DDUL controls the lifetime of dynamically
   updated RRs at the authoritative DNS servers, while the RRs' TTL
   values control the cache lifetime at caching resolvers.

   In case of network changes, the RRs of a host are updated immediately
   after local interfaces are properly configured, and after the port
   mapping and the public IP address of the NAT are obtained.  Usually
   there are 4 types of RRs involved: a AAAA RR for updating the new
   host identifier of the host (possibly the same as the old one); an
   SRV RR for updating the autotunnel service information, which
   includes the new external port; an A RR for updating the new public
   IP address; and a TXT RR for describing the autotunnel device
   information.  The name for the SRV RR is discussed in <a href="#section-3">Section 3</a>, and
   the names for the A, AAAA, and TXT RRs are specified in the Target
   field of the SRV RR.  The host then constructs and sends an SRV query
   for the dynamic DNS server to which it should send updates.
   Following our example for alice, it queries the SRV RR for _dns-
   update-tls._udp.alice.members.me.com.  Then, the updates are sent to
   the dynamic DNS server returned in the Target field of query
   response.

   In addition, periodic refreshes are also required by the DDUL even in
   the absence of any network changes.  The update requests contain a
   signed 32-bit integer indicating the lease life in seconds.  To
   reduce network and server load, a minimum lease of 30 minutes is
   required.  On the other hand, to avoid stale information, a lease
   longer than 2 hours is not allowed in BTMM.  The typical length is 90
   minutes.  The client host refreshes the RRs before the lease expires
   to prevent them from being deleted by the server.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.3.%20%20Getting%20Up-to-Date%20DNS%20Resource%20Records%20without%20Polling"></a><a class="selflink" href="#section-5.3" name="section-5.3">5.3</a>.  Getting Up-to-Date DNS Resource Records without Polling</span>

   In dynamic environments, changes to DNS information can often be
   frequent.  However, since a DNS query only retrieves the RR value
   available at that instance in time, one must continue to query DNS to
   learn the latest changes.  This solution presents the dilemma of
   choosing a low polling rate that leaves the client with stale
   information or choosing a high polling rate that would have an
   adverse impact on the network and server.

   To let the hosts that care about particular DNS RRs learn the changes
   quickly and efficiently, BTMM uses DNS Long-Lived Queries (LLQs)
   [<a href="#ref-DNS-LLQ" title='"DNS Long-Lived Queries"'>DNS-LLQ</a>] to let the DNS server notify the client host once any
   changes are made to the concerned DNS data.



<span class="grey">Cheshire, et al.              Informational                     [Page 9]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-10" id="page-10" name="page-10"> </a>
<span class="grey"><a href="rfc6281.html">RFC 6281</a>                          BTMM                         June 2011</span>


   To obtain the LLQ server information, the client issues an SRV query.
   So alice's host issues a query for
   _dns-llq-tls._udp.alice.members.me.com and obtains the server that
   provides LLQ service.  LLQs are initiated by a client and are
   completed via a four-way handshake: Initial Request, Challenge,
   Challenge Response, and ACK + Answers.  During the Challenge phase,
   the DNS server provides a unique identifier for the request, and the
   client is required to echo this identifier in the Challenge Response
   phase.  This handshake provides resilience to packet loss,
   demonstrates client reachability, and reduces denial-of-service
   attack opportunities.

   LLQ lease is negotiated during the handshake.  In BTMM, the minimum
   lease is 15 minutes, and the maximum lease is 2 hours.  Leases are
   refreshed before they expire.

   When a change ("event") occurs to a name server's domain, the server
   checks if the new or deleted RRs answer any LLQs.  If so, the RRs are
   sent to the LLQ issuers in the form of a gratuitous DNS response.
   The client acknowledges the reception of the notification; otherwise,
   the server resends the response.  If a total of 3 transmissions (with
   exponential backoff) fail, the client is considered unreachable, and
   the LLQ is deleted.

   A BTMM client then updates its tunnels according to the query
   answers.  The callback function for automatically updating tunnels is
   depicted Figure 3.

                          1:  Push Updated AAAA RR       +------------+
                   &lt;-----------------------------------  |            |
                       2: Query for autotunnel SRV RR    |            |
       +--------+  -----------------------------------&gt;  |            |
       |        |        3: Reply Updated SRV RR         | DNS server |
       | client |  &lt;-----------------------------------  |            |
       |        |      4: Query for Target in SRV RR     |            |
       +--------+  -----------------------------------&gt;  |            |
                       5: Reply Updated A RR of Target   |            |
                   &lt;-----------------------------------  |            |
                                                         +------------+

      In Step 1: Client learns the inner IP address of the tunnel.
      In Step 3: Client learns the port opened for UDP NAT traversal.
      In Step 5: Client learns the public IP address of the remote NAT,
                 i.e., the outer IP address of the tunnel.

                                 Figure 3





<span class="grey">Cheshire, et al.              Informational                    [Page 10]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-11" id="page-11" name="page-11"> </a>
<span class="grey"><a href="rfc6281.html">RFC 6281</a>                          BTMM                         June 2011</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/6.%20%20IPv6%20ULA%20as%20Host%20ID"></a><a class="selflink" href="#section-6" name="section-6">6</a>.  IPv6 ULA as Host ID</span>

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/6.1.%20%20The%20Need%20for%20a%20Host%20Identifier"></a><a class="selflink" href="#section-6.1" name="section-6.1">6.1</a>.  The Need for a Host Identifier</span>

   BTMM needs to assign a topology-independent identifier to each client
   host for the following reasons.  First, two end hosts may wish to
   have the established TCP connections survive network changes.
   Second, sometimes one needs a constant identifier to be associated
   with a key so that the Security Association can survive the location
   changes.

   The above needs for a host identifier impose very little constraint
   on the properties of the identifier.  In particular, one notes that
   this identifier does not need to be a permanent one as long as its
   lifetime is no shorter than the lifetime of any TCP connection or any
   Security Association that runs on the host.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/6.2.%20%20What%20to%20Use%20as%20Host%20Identifiers"></a><a class="selflink" href="#section-6.2" name="section-6.2">6.2</a>.  What to Use as Host Identifiers</span>

   Much effort has been put into the development of host identifiers.
   Possible candidates for host identifiers include DNS name and Host
   Identity Tag (HIT) in the Host Identity Protocol (HIP) [<a href="rfc4423.html" title='"Host Identity Protocol (HIP) Architecture"'>RFC4423</a>].
   However, because the current protocol stack used IP as identifiers in
   TCP, other transport protocols, and some applications, if one does
   not wish to rewrite all the transport protocol and application code,
   then DNS is ruled out as infeasible because DNS names have variable
   lengths.

   For HIP, although publickey-based HIT has the same length as an IPv6
   address, we still lack a secure way to retrieve the public keys.
   Under this condition, using HIT would not bring us much benefit.

   BTMM chooses to use IPv6 ULA as the host identifier so that all the
   existing IPv6 code can be used directly.  Since the identifier does
   not need to stay constant over machine shutdown or crashes, each host
   creates an IPv6 ULA at boot time.  Furthermore, since a host does not
   leak this ULA to the network, it would not cause any problem to the
   routing system.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/6.3.%20%20IPv6%20ULA%20Configuration"></a><a class="selflink" href="#section-6.3" name="section-6.3">6.3</a>.  IPv6 ULA Configuration</span>

   In BTMM, IPv6 ULA is advertised to be used in the autotunnel service
   of the host.  Thus, the IPv6 address needs to be configured before
   BTMM starts its service.

   When the machine boots up, the IPv6 address for autotunnel service is
   initialized as zeros, and the autotunnel interface is marked as
   inactive.  During the process when BTMM updates the interfaces list



<span class="grey">Cheshire, et al.              Informational                    [Page 11]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-12" id="page-12" name="page-12"> </a>
<span class="grey"><a href="rfc6281.html">RFC 6281</a>                          BTMM                         June 2011</span>


   (which is performed every time the network changes), BTMM would
   randomly generate an IPv6 ULA according to [<a href="rfc4193.html" title='"Unique Local IPv6 Unicast Addresses"'>RFC4193</a>] if the IPv6
   address is found uninitialized.  The first octet of the ULA is set to
   be "0xFD", and the following 7 octets are randomly selected from
   0~255.  Finally, the EUI-64 identifier fills up the remaining 8
   octets.  Since there are 56 random bits plus a theoretically unique
   EUI-64 identifier, it is unlikely for an IPv6 ULA collision between
   any two hosts of the same subscriber to occur.

   This locally generated ULA remains unchanged when the machine is on,
   despite its location changes.  Hence, the user can fully enjoy the
   benefits brought by topology-independent host identifiers.  After the
   machine is turned off, this particular ULA is no longer kept.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/7.%20%20Securing%20Communication"></a><a class="selflink" href="#section-7" name="section-7">7</a>.  Securing Communication</span>

   BTMM users often have to fetch their personal data via a network they
   don't trust (or they do not know whether or not it's trustworthy).
   Hence, it is important for BTMM to have an effective means to secure
   the communications.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/7.1.%20%20Authentication%20for%20Connecting%20to%20Remote%20Host"></a><a class="selflink" href="#section-7.1" name="section-7.1">7.1</a>.  Authentication for Connecting to Remote Host</span>

   Kerberos is a "single sign on" technology and has been supported in
   Apple's products since MAC OS X 10.5.  Each Mac OS X client maintains
   a local Key Distribution Center (KDC) for the use of Bonjour and
   peer-to-peer security.

   When the user first signs in to MobileMe on a host, it automatically
   receives a digital certificate and private key for "Back to My Mac
   Encryption Certificate" from KDC.  When the user connects to another
   system using BTMM, authentication is performed using the Public Key
   Cryptography for Initial Authentication in Kerberos (PKINIT) protocol
   [<a href="rfc4556.html" title='"Public Key Cryptography for Initial Authentication in Kerberos (PKINIT)"'>RFC4556</a>] with that certificate.  After that, the user is granted a
   "ticket" that permits it to continue to use the services on the
   remote host without re-authenticating until the ticket expires (a
   ticket usually has a 10-hour lifetime).

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/7.2.%20%20Authentication%20for%20DNS%20Exchanges"></a><a class="selflink" href="#section-7.2" name="section-7.2">7.2</a>.  Authentication for DNS Exchanges</span>

   BTMM uses Transaction SIGnature (TSIG) to authenticate the user when
   dynamic DNS update is performed [<a href="rfc2845.html" title='"Secret Key Transaction Authentication for DNS (TSIG)"'>RFC2845</a>].  Also, to protect the
   subscriber's privacy, LLQ is required to contain TSIG.  This
   authentication mechanism is based on the shared secret key, which in
   BTMM's case is derived from the subscriber's MobileMe account
   password.





<span class="grey">Cheshire, et al.              Informational                    [Page 12]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-13" id="page-13" name="page-13"> </a>
<span class="grey"><a href="rfc6281.html">RFC 6281</a>                          BTMM                         June 2011</span>


   Every time a DNS request/response is going to be issued, a TSIG RR is
   dynamically computed with the HMAC-MD5 [<a href="rfc2104.html" title='"HMAC: Keyed- Hashing for Message Authentication"'>RFC2104</a>] message digest
   algorithm (and the TSIG RR will be discarded once its has been used).
   Inside the TSIG RR, the name of the shared secret key in the domain
   name syntax is included, so the receiver knows which key to use (this
   is especially useful if the receiver is the DNS server).  This TSIG
   RR is appended to the additional data section before the message is
   sent out.  The receiver of the message verifies the TSIG RR and
   proceeds only if the TSIG is valid.

   Besides, the DNS messages are also protected by TLS [<a href="rfc5246.html" title='"The Transport Layer Security (TLS) Protocol Version 1.2"'>RFC5246</a>] to
   prevent eavesdropping.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/7.3.%20%20IPsec%20for%20Secure%20End-to-End%20Data%20Communication"></a><a class="selflink" href="#section-7.3" name="section-7.3">7.3</a>.  IPsec for Secure End-to-End Data Communication</span>

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/7.3.1.%20%20Internet%20Key%20Exchange"></a><a class="selflink" href="#section-7.3.1" name="section-7.3.1">7.3.1</a>.  Internet Key Exchange</span>

   Before the Security Association can be established between two end
   hosts, the Internet Key Exchange (IKE) [<a href="rfc5996.html" title='"Internet Key Exchange Protocol Version 2 (IKEv2)"'>RFC5996</a>] process needs to be
   accomplished.

   BTMM calls Racoon [<a href="#ref-Racoon" title='"Racoon"'>Racoon</a>], the IKE daemon, to do the key exchange,
   after which the key is put into the Security Association Database
   (SAD).  The exchange mode is set to be aggressive so that it will not
   take too long, and it uses a pre-shared key to do the user
   authentication.  The subscriber's Fully Qualified Domain Name (FQDN)
   is used as both identifier and pre-shared key during the IKE process.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/7.3.2.%20%20Discussion%3A%20End-to-End%20Encryption"></a><a class="selflink" href="#section-7.3.2" name="section-7.3.2">7.3.2</a>.  Discussion: End-to-End Encryption</span>

   When it comes time to set up Security Associations between two BTMM
   clients, we have two choices: put the other host's IPv4 address in
   the destination address field or put it in the IPv6 address of the
   remote end.

   If the IPv4 address (which is the public address of a NAT) is chosen
   to associate with a Security Association, that means we set up a
   Security Association between one end host and the NAT of the other
   host.  The IPv6 packet would then be wrapped by the UDP header and
   then get encrypted by ESP.  After the encrypted packet arrives at the
   NAT, the NAT device decrypts the packet and sends it to the
   destination according to the port mapping.  Although this approach
   seems viable, there are 3 drawbacks:

   o  First, the encryption is not really end-to-end, i.e., only the
      path between one end host and the NAT device of the other end is
      protected.  The rest of the path, from the NAT device to the other
      BTMM client, is unprotected and vulnerable to attacks.  If the NAT



<span class="grey">Cheshire, et al.              Informational                    [Page 13]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-14" id="page-14" name="page-14"> </a>
<span class="grey"><a href="rfc6281.html">RFC 6281</a>                          BTMM                         June 2011</span>


      device is not trustworthy, the communication is at high risk.
      Even if the NAT device is trustworthy (e.g., the user owns the
      NAT), it is not uncommon for the NAT to communicate with the host
      through a broadcast channel, which provides opportunities for an
      eavesdropper to sniff the sensitive data (consider the unlocked
      "free" WiFi access near your neighborhood).

   o  Second, quite a few BTMM clients are on the move very often.
      Every time they change their attachment points to the Internet,
      they will get different IPv4 addresses.  As a result, the
      previously established Security Associations become obsoleted, and
      the two end hosts need to re-establish them again.  This is a
      waste of time and resources.

   o  Third, this approach assumes that the NAT device is able and
      willing to do the IPsec ESP for the host behind it, which is not
      always the case.

   Consequently, BTMM decides to put the IPv6 ULA into the destination
   field of IPsec Security Associations.  In this way, the end-to-end
   path between the hosts is fully protected, and the Security
   Associations survive the network changes since the IPv6 ULA remains
   the same even if the BTMM client changes its location.  Furthermore,
   the encryption is transparent to the NAT device, which means the NAT
   device is not required to interfere with the IPsec protection.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/8.%20%20Security%20Considerations"></a><a class="selflink" href="#section-8" name="section-8">8</a>.  Security Considerations</span>

   The BTMM implementation utilizes existing security protocols to
   address the end-to-end security considerations.  It uses Kerberos
   [<a href="rfc4120.html" title='"The Kerberos Network Authentication Service (V5)"'>RFC4120</a>] for end-to-end authentication and uses IPsec [<a href="rfc4301.html" title='"Security Architecture for the Internet Protocol"'>RFC4301</a>] to
   secure data communications between two end hosts.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/9.%20%20References"></a><a class="selflink" href="#section-9" name="section-9">9</a>.  References</span>

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/9.1.%20%20Normative%20Reference"></a><a class="selflink" href="#section-9.1" name="section-9.1">9.1</a>.  Normative Reference</span>

   [<a id="ref-RFC2104" name="ref-RFC2104">RFC2104</a>]  Krawczyk, H., Bellare, M., and R. Canetti, "HMAC: Keyed-
              Hashing for Message Authentication", <a href="rfc2104.html">RFC 2104</a>,
              February 1997.

   [<a id="ref-RFC2136" name="ref-RFC2136">RFC2136</a>]  Vixie, P., Thomson, S., Rekhter, Y., and J. Bound,
              "Dynamic Updates in the Domain Name System (DNS UPDATE)",
              <a href="rfc2136.html">RFC 2136</a>, April 1997.

   [<a id="ref-RFC2782" name="ref-RFC2782">RFC2782</a>]  Gulbrandsen, A., Vixie, P., and L. Esibov, "A DNS RR for
              specifying the location of services (DNS SRV)", <a href="rfc2782.html">RFC 2782</a>,
              February 2000.



<span class="grey">Cheshire, et al.              Informational                    [Page 14]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-15" id="page-15" name="page-15"> </a>
<span class="grey"><a href="rfc6281.html">RFC 6281</a>                          BTMM                         June 2011</span>


   [<a id="ref-RFC2845" name="ref-RFC2845">RFC2845</a>]  Vixie, P., Gudmundsson, O., Eastlake, D., and B.
              Wellington, "Secret Key Transaction Authentication for DNS
              (TSIG)", <a href="rfc2845.html">RFC 2845</a>, May 2000.

   [<a id="ref-RFC4120" name="ref-RFC4120">RFC4120</a>]  Neuman, C., Yu, T., Hartman, S., and K. Raeburn, "The
              Kerberos Network Authentication Service (V5)", <a href="rfc4120.html">RFC 4120</a>,
              July 2005.

   [<a id="ref-RFC4193" name="ref-RFC4193">RFC4193</a>]  Hinden, R. and B. Haberman, "Unique Local IPv6 Unicast
              Addresses", <a href="rfc4193.html">RFC 4193</a>, October 2005.

   [<a id="ref-RFC4301" name="ref-RFC4301">RFC4301</a>]  Kent, S. and K. Seo, "Security Architecture for the
              Internet Protocol", <a href="rfc4301.html">RFC 4301</a>, December 2005.

   [<a id="ref-RFC4303" name="ref-RFC4303">RFC4303</a>]  Kent, S., "IP Encapsulating Security Payload (ESP)",
              <a href="rfc4303.html">RFC 4303</a>, December 2005.

   [<a id="ref-RFC4556" name="ref-RFC4556">RFC4556</a>]  Zhu, L. and B. Tung, "Public Key Cryptography for Initial
              Authentication in Kerberos (PKINIT)", <a href="rfc4556.html">RFC 4556</a>, June 2006.

   [<a id="ref-RFC5246" name="ref-RFC5246">RFC5246</a>]  Dierks, T. and E. Rescorla, "The Transport Layer Security
              (TLS) Protocol Version 1.2", <a href="rfc5246.html">RFC 5246</a>, August 2008.

   [<a id="ref-RFC5996" name="ref-RFC5996">RFC5996</a>]  Kaufman, C., Hoffman, P., Nir, Y., and P. Eronen,
              "Internet Key Exchange Protocol Version 2 (IKEv2)",
              <a href="rfc5996.html">RFC 5996</a>, September 2010.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/9.2.%20%20Informative%20References"></a><a class="selflink" href="#section-9.2" name="section-9.2">9.2</a>.  Informative References</span>

   [<a id="ref-DDUL" name="ref-DDUL">DDUL</a>]     Sekar, K., <a href="https://www.google.com/search?sitesearch=tools.ietf.org%2Fhtml%2F&amp;q=inurl:draft-+%22Dynamic+DNS+Update+Leases%22" style="text-decoration: none">"Dynamic DNS Update Leases"</a>, Work in Progress,
              August 2006.

   [<a id="ref-DNS-LLQ" name="ref-DNS-LLQ">DNS-LLQ</a>]  Sekar, K., "DNS Long-Lived Queries", Work in Progess,
              August 2006.

   [<a id="ref-DNS-SD" name="ref-DNS-SD">DNS-SD</a>]   Cheshire, S. and M. Krochmal, "DNS-Based Service
              Discovery", Work in Progress, February 2011.

   [<a id="ref-EUI64" name="ref-EUI64">EUI64</a>]    "Guidelines for 64-bit Global Identifier (EUI-64)",
              &lt;<a href="http://standards.ieee.org/regauth/oui/tutorials/EUI64.html">http://standards.ieee.org/regauth/oui/tutorials/</a>
              <a href="http://standards.ieee.org/regauth/oui/tutorials/EUI64.html">EUI64.html</a>&gt;.

   [<a id="ref-IGD" name="ref-IGD">IGD</a>]      "Internet Gateway Device (IGD) Standard Device Control
              Protocol", &lt;<a href="http://www.upnp.org/">http://www.upnp.org</a>&gt;.

   [<a id="ref-NAT-PMP" name="ref-NAT-PMP">NAT-PMP</a>]  Cheshire, S., <a href="https://www.google.com/search?sitesearch=tools.ietf.org%2Fhtml%2F&amp;q=inurl:draft-+%22NAT+Port+Mapping+Protocol+%28NAT-PMP%29%22" style="text-decoration: none">"NAT Port Mapping Protocol (NAT-PMP)"</a>, Work
              in Progress, April 2008.




<span class="grey">Cheshire, et al.              Informational                    [Page 15]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-16" id="page-16" name="page-16"> </a>
<span class="grey"><a href="rfc6281.html">RFC 6281</a>                          BTMM                         June 2011</span>


   [<a id="ref-RFC1918" name="ref-RFC1918">RFC1918</a>]  Rekhter, Y., Moskowitz, R., Karrenberg, D., Groot, G., and
              E. Lear, "Address Allocation for Private Internets",
              <a href="https://tools.ietf.org/html/bcp5">BCP 5</a>, <a href="rfc1918.html">RFC 1918</a>, February 1996.

   [<a id="ref-RFC4423" name="ref-RFC4423">RFC4423</a>]  Moskowitz, R. and P. Nikander, "Host Identity Protocol
              (HIP) Architecture", <a href="rfc4423.html">RFC 4423</a>, May 2006.

   [<a id="ref-Racoon" name="ref-Racoon">Racoon</a>]   "Racoon", &lt;<a href="http://ipsec-tools.sourceforge.net/">http://ipsec-tools.sourceforge.net</a>&gt;.

Authors' Addresses

   Stuart Cheshire
   Apple Inc.
   1 Infinite Loop
   Cupertino, CA  95014
   USA
   Phone: +1 408 974 3207
   EMail: cheshire@apple.com


   Zhenkai Zhu
   UCLA
   4805 Boelter Hall, UCLA
   Los Angeles, CA  90095
   USA
   Phone: +1 310 993 7128
   EMail: zhenkai@cs.ucla.edu


   Ryuji Wakikawa
   Toyota ITC
   465 Bernardo Avenue
   Mountain View, CA  94043
   USA
   EMail: ryuji.wakikawa@gmail.com


   Lixia Zhang
   UCLA
   3713 Boelter Hall, UCLA
   Los Angeles, CA  90095
   USA
   Phone: +1 310 825 2695
   EMail: lixia@cs.ucla.edu







Cheshire, et al.              Informational                    [Page 16]

</pre><br/>
    <span class="noprint"><small><small>Html markup produced by rfcmarkup 1.126, available from
      <a href="https://tools.ietf.org/tools/rfcmarkup/">https://tools.ietf.org/tools/rfcmarkup/</a>
    </small></small></span>
  </div>




</body><!-- Mirrored from tools.ietf.org/html/rfc6281 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 06 Mar 2018 23:18:31 GMT --></html>