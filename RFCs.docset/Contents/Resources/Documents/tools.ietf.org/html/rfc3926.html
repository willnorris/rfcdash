<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml"><!-- Mirrored from tools.ietf.org/html/rfc3926 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 06 Mar 2018 23:18:44 GMT --><!-- Added by HTTrack --><head><meta content="text/html;charset=utf-8" http-equiv="content-type"/><!-- /Added by HTTrack -->

    <meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
    <meta content="index,follow" name="robots"/>
    <meta content="rfcmarkup version 1.126" name="creator"/>
    <link href="http://purl.org/dc/elements/1.1/" rel="schema.DC"/>
<meta content="urn:ietf:rfc:3926" name="DC.Identifier"/>
<meta content="This document defines FLUTE, a protocol for the unidirectional
delivery of files over the Internet, which is particularly suited to
multicast networks. The specification builds on Asynchronous Layered
Coding, the base protocol designed for massively scalable multicast
distribution. This memo defines an Experimental Protocol for the
Internet community." name="DC.Description.Abstract"/>
<meta content="Lehtonen, Rami" name="DC.Creator"/>
<meta content="Paila, Toni" name="DC.Creator"/>
<meta content="Roca, Vincent" name="DC.Creator"/>
<meta content="Luby, Michael" name="DC.Creator"/>
<meta content="Walsh, Rod" name="DC.Creator"/>
<meta content="October, 2004" name="DC.Date.Issued"/>
<meta content="FLUTE - File Delivery over Unidirectional Transport" name="DC.Title"/>

    <link href="https://tools.ietf.org/images/rfc.png" rel="icon" type="image/png"/>
    <link href="https://tools.ietf.org/images/rfc.png" rel="shortcut icon" type="image/png"/>
    <title>RFC 3926 - FLUTE - File Delivery over Unidirectional Transport</title>
    
    
    <style type="text/css">
	@media only screen 
	  and (min-width: 992px)
	  and (max-width: 1199px) {
	    body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 768px)
	  and (max-width: 991px) {
            body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 480px)
	  and (max-width: 767px) {
            body { font-size: 11pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (max-width: 479px) {
            body { font-size: 8pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-device-width : 375px) 
	  and (max-device-width : 667px) {
            body { font-size: 9.5pt; }
            div.content { width: 96ex; margin: 0 1px; }
        }
	@media only screen 
	  and (min-device-width: 1200px) {
            body { font-size: 10pt; margin: 0 4em; }
            div.content { width: 96ex; margin: 0; }
        }
        h1, h2, h3, h4, h5, h6, .h1, .h2, .h3, .h4, .h5, .h6 {
	    font-weight: bold;
            line-height: 0pt;
            display: inline;
            white-space: pre;
            font-family: monospace;
            font-size: 1em;
	    font-weight: bold;
        }
        pre {
            font-size: 1em;
            margin-top: 0px;
            margin-bottom: 0px;
        }
	.pre {
	    white-space: pre;
	    font-family: monospace;
	}
	.header{
	    font-weight: bold;
	}
        .newpage {
            page-break-before: always;
        }
        .invisible {
            text-decoration: none;
            color: white;
        }
        a.selflink {
          color: black;
          text-decoration: none;
        }
        @media print {
            body {
                font-family: monospace;
                font-size: 10.5pt;
            }
            h1, h2, h3, h4, h5, h6 {
                font-size: 1em;
            }
        
            a:link, a:visited {
                color: inherit;
                text-decoration: none;
            }
            .noprint {
                display: none;
            }
        }
	@media screen {
	    .grey, .grey a:link, .grey a:visited {
		color: #777;
	    }
            .docinfo {
                background-color: #EEE;
            }
            .top {
                border-top: 7px solid #EEE;
            }
            .bgwhite  { background-color: white; }
            .bgred    { background-color: #F44; }
            .bggrey   { background-color: #666; }
            .bgbrown  { background-color: #840; }            
            .bgorange { background-color: #FA0; }
            .bgyellow { background-color: #EE0; }
            .bgmagenta{ background-color: #F4F; }
            .bgblue   { background-color: #66F; }
            .bgcyan   { background-color: #4DD; }
            .bggreen  { background-color: #4F4; }

            .legend   { font-size: 90%; }
            .cplate   { font-size: 70%; border: solid grey 1px; }
	}
    </style>
    <!--[if IE]>
    <style>
    body {
       font-size: 13px;
       margin: 10px 10px;
    }
    </style>
    <![endif]-->

    <script type="text/javascript"><!--
    function addHeaderTags() {
	var spans = document.getElementsByTagName("span");
	for (var i=0; i < spans.length; i++) {
	    var elem = spans[i];
	    if (elem) {
		var level = elem.getAttribute("class");
                if (level == "h1" || level == "h2" || level == "h3" || level == "h4" || level == "h5" || level == "h6") {
                    elem.innerHTML = "<"+level+">"+elem.innerHTML+"</"+level+">";		
                }
	    }
	}
    }
    var legend_html = "Colour legend:<br />      <table>         <tr><td>Unknown:</td>                   <td><span class='cplate bgwhite'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft:</td>                     <td><span class='cplate bgred'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Informational:</td>             <td><span class='cplate bgorange'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Experimental:</td>              <td><span class='cplate bgyellow'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Best Common Practice:</td>      <td><span class='cplate bgmagenta'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Proposed Standard:</td>         <td><span class='cplate bgblue'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft Standard (old designation):</td> <td><span class='cplate bgcyan'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Internet Standard:</td>         <td><span class='cplate bggreen'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Historic:</td>                  <td><span class='cplate bggrey'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Obsolete:</td>                  <td><span class='cplate bgbrown'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>     </table>";
    function showElem(id) {
        var elem = document.getElementById(id);
        elem.innerHTML = eval(id+"_html");
        elem.style.visibility='visible';
    }
    function hideElem(id) {
        var elem = document.getElementById(id);
        elem.style.visibility='hidden';        
        elem.innerHTML = "";
    }
    // -->
    </script>
</head>
<body onload="addHeaderTags()">
  <div class="content">
   <div style="height: 13px;">
      <div class="pre noprint docinfo bgbrown" onclick="showElem('legend');" onmouseout="hideElem('legend')" onmouseover="this.style.cursor='pointer';" style="height: 6px; position: absolute;" title="Click for colour legend.">                                                                        </div>
      <div class="docinfo noprint pre legend" id="legend" onmouseout="hideElem('legend');" onmouseover="showElem('legend');" style="position:absolute; top: 4px; left: 4ex; visibility:hidden; background-color: white; padding: 4px 9px 5px 7px; border: solid #345 1px; ">
      </div>
   </div>
<span class="pre noprint docinfo top">[<a href="index.html" title="Document search and retrieval page">Docs</a>] [<a href="https://tools.ietf.org/rfc/rfc3926.txt" title="Plaintext version of this document">txt</a>|<a href="https://tools.ietf.org/pdf/rfc3926" title="PDF version of this document">pdf</a>] [<a href="https://tools.ietf.org/html/draft-ietf-rmt-flute" title="draft-ietf-rmt-flute">draft-ietf-rmt-...</a>] [<a href="https://datatracker.ietf.org/doc/rfc3926" title="IESG Datatracker information for this document">Tracker</a>] [<a href="https://tools.ietf.org/rfcdiff?difftype=--hwdiff&amp;url2=rfc3926" title="Inline diff (wdiff)">Diff1</a>] [<a href="https://tools.ietf.org/rfcdiff?url2=rfc3926" title="Side-by-side diff">Diff2</a>] [<a href="https://datatracker.ietf.org/ipr/search/?rfc=3926&amp;submit=rfc" title="IPR disclosures related to this document">IPR</a>] [<a href="https://www.rfc-editor.org/errata_search.php?rfc=3926">Errata</a>]</span><br/>
<span class="pre noprint docinfo">                                                                        </span><br/>
<span class="pre noprint docinfo">Obsoleted by: <a href="rfc6726.html">6726</a>                                          EXPERIMENTAL</span><br/>
<span class="pre noprint docinfo">                                                            <span style="color: #C00;">Errata Exist</span></span><br/>
<pre>Network Working Group                                           T. Paila
Request for Comments: 3926                                         Nokia
Category: Experimental                                           M. Luby
                                                        Digital Fountain
                                                             R. Lehtonen
                                                             TeliaSonera
                                                                 V. Roca
                                                       INRIA Rhone-Alpes
                                                                R. Walsh
                                                                   Nokia
                                                            October 2004


          <span class="h1">FLUTE - File Delivery over Unidirectional Transport</span>

Status of this Memo

   This memo defines an Experimental Protocol for the Internet
   community.  It does not specify an Internet standard of any kind.
   Discussion and suggestions for improvement are requested.
   Distribution of this memo is unlimited.

Copyright Notice

   Copyright (C) The Internet Society (2004).

Abstract

   This document defines FLUTE, a protocol for the unidirectional
   delivery of files over the Internet, which is particularly suited to
   multicast networks.  The specification builds on Asynchronous Layered
   Coding, the base protocol designed for massively scalable multicast
   distribution.

Table of Contents

   <a href="#section-1">1</a>.  Introduction . . . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-2">2</a>
       <a href="#section-1.1">1.1</a>.  Applicability Statement  . . . . . . . . . . . . . . . .  <a href="#page-3">3</a>
             <a href="#section-1.1.1">1.1.1</a>.  The Target Application Space . . . . . . . . . .  <a href="#page-3">3</a>
             <a href="#section-1.1.2">1.1.2</a>.  The Target Scale . . . . . . . . . . . . . . . .  <a href="#page-4">4</a>
             <a href="#section-1.1.3">1.1.3</a>.  Intended Environments  . . . . . . . . . . . . .  <a href="#page-4">4</a>
             <a href="#section-1.1.4">1.1.4</a>.  Weaknesses . . . . . . . . . . . . . . . . . . .  <a href="#page-4">4</a>
   <a href="#section-2">2</a>.  Conventions used in this Document. . . . . . . . . . . . . . .  <a href="#page-5">5</a>
   <a href="#section-3">3</a>.  File delivery  . . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-5">5</a>
       <a href="#section-3.1">3.1</a>.  File delivery session  . . . . . . . . . . . . . . . . .  <a href="#page-6">6</a>
       <a href="#section-3.2">3.2</a>.  File Delivery Table. . . . . . . . . . . . . . . . . . .  <a href="#page-8">8</a>
       3.3.  Dynamics of FDT Instances within file delivery session .  9
       <a href="#section-3.4">3.4</a>.  Structure of FDT Instance packets. . . . . . . . . . . . <a href="#page-11">11</a>



<span class="grey">Paila, et al.                 Experimental                      [Page 1]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-2" id="page-2" name="page-2"> </a>
<span class="grey"><a href="rfc3926.html">RFC 3926</a>                         FLUTE                      October 2004</span>


             <a href="#section-3.4.1">3.4.1</a>.  Format of FDT Instance Header  . . . . . . . . . <a href="#page-12">12</a>
             <a href="#section-3.4.2">3.4.2</a>.  Syntax of FDT Instance . . . . . . . . . . . . . <a href="#page-13">13</a>
             <a href="#section-3.4.3">3.4.3</a>.  Content Encoding of FDT Instance . . . . . . . . <a href="#page-16">16</a>
       <a href="#section-3.5">3.5</a>.  Multiplexing of files within a file delivery session . . <a href="#page-17">17</a>
   <a href="#section-4">4</a>.  Channels, congestion control and timing  . . . . . . . . . . . <a href="#page-18">18</a>
   <a href="#section-5">5</a>.  Delivering FEC Object Transmission Information . . . . . . . . <a href="#page-19">19</a>
       5.1.  Use of EXT_FTI for delivery of FEC Object Transmission
             Information. . . . . . . . . . . . . . . . . . . . . . . <a href="#page-20">20</a>
             <a href="#section-5.1.1">5.1.1</a>.  General EXT_FTI format . . . . . . . . . . . . . <a href="#page-20">20</a>
             <a href="#section-5.1.2">5.1.2</a>.  FEC Encoding ID specific formats for EXT_FTI . . <a href="#page-21">21</a>
       5.2.  Use of FDT for delivery of FEC Object Transmission
             Information. . . . . . . . . . . . . . . . . . . . . . . <a href="#page-25">25</a>
   <a href="#section-6">6</a>.  Describing file delivery sessions. . . . . . . . . . . . . . . <a href="#page-25">25</a>
   <a href="#section-7">7</a>.  Security Considerations  . . . . . . . . . . . . . . . . . . . <a href="#page-26">26</a>
   <a href="#section-8">8</a>.  IANA Considerations  . . . . . . . . . . . . . . . . . . . . . <a href="#page-29">29</a>
   <a href="#section-9">9</a>.  Acknowledgements . . . . . . . . . . . . . . . . . . . . . . . <a href="#page-29">29</a>
       Normative References . . . . . . . . . . . . . . . . . . . . . <a href="#page-29">29</a>
       Informative References . . . . . . . . . . . . . . . . . . . . <a href="#page-30">30</a>
   <a href="#appendix-A">A</a>.  Receiver operation (informative) . . . . . . . . . . . . . . . <a href="#page-32">32</a>
   <a href="#appendix-B">B</a>.  Example of FDT Instance (informative). . . . . . . . . . . . . <a href="#page-33">33</a>
       Authors' Addresses . . . . . . . . . . . . . . . . . . . . . . <a href="#page-34">34</a>
       Full Copyright Statement . . . . . . . . . . . . . . . . . . . <a href="#page-35">35</a>

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/1.%20%20Introduction"></a><a class="selflink" href="#section-1" name="section-1">1</a>.  Introduction</span>

   This document defines FLUTE version 1, a protocol for unidirectional
   delivery of files over the Internet.  The specification builds on
   Asynchronous Layered Coding (ALC), version 1 [<a href="#ref-2" title='"Asynchronous Layered Coding (ALC) Protocol Instantiation"'>2</a>], the base protocol
   designed for massively scalable multicast distribution.  ALC defines
   transport of arbitrary binary objects.  For file delivery
   applications mere transport of objects is not enough, however.  The
   end systems need to know what the objects actually represent.  This
   document specifies a technique called FLUTE - a mechanism for
   signaling and mapping the properties of files to concepts of ALC in a
   way that allows receivers to assign those parameters for received
   objects.  Consequently, throughout this document the term 'file'
   relates to an 'object' as discussed in ALC.  Although this
   specification frequently makes use of multicast addressing as an
   example, the techniques are similarly applicable for use with unicast
   addressing.

   This document defines a specific transport application of ALC, adding
   the following specifications:

   -  Definition of a file delivery session built on top of ALC,
      including transport details and timing constraints.

   -  In-band signalling of the transport parameters of the ALC session.



<span class="grey">Paila, et al.                 Experimental                      [Page 2]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-3" id="page-3" name="page-3"> </a>
<span class="grey"><a href="rfc3926.html">RFC 3926</a>                         FLUTE                      October 2004</span>


   -  In-band signalling of the properties of delivered files.

   -  Details associated with the multiplexing of multiple files within
      a session.

   This specification is structured as follows.  <a href="#section-3">Section 3</a> begins by
   defining the concept of the file delivery session.  Following that it
   introduces the File Delivery Table that forms the core part of this
   specification.  Further, it discusses multiplexing issues of
   transport objects within a file delivery session.  <a href="#section-4">Section 4</a>
   describes the use of congestion control and channels with FLUTE.
   <a href="#section-5">Section 5</a> defines how the Forward Error Correction (FEC) Object
   Transmission Information is to be delivered within a file delivery
   session.  <a href="#section-6">Section 6</a> defines the required parameters for describing
   file delivery sessions in a general case.  <a href="#section-7">Section 7</a> outlines
   security considerations regarding file delivery with FLUTE.  Last,
   there are two informative appendices.  The first appendix describes
   an envisioned receiver operation for the receiver of the file
   delivery session.  The second appendix gives an example of File
   Delivery Table.

   Statement of Intent

      This memo contains part of the definitions necessary to fully
      specify a Reliable Multicast Transport protocol in accordance with
      <a href="rfc2357.html">RFC2357</a>.  As per <a href="rfc2357.html">RFC2357</a>, the use of any reliable multicast
      protocol in the Internet requires an adequate congestion control
      scheme.

      While waiting for such a scheme to be available, or for an
      existing scheme to be proven adequate, the Reliable Multicast
      Transport working group (RMT) publishes this Request for Comments
      in the "Experimental" category.

      It is the intent of RMT to re-submit this specification as an IETF
      Proposed Standard as soon as the above condition is met.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/1.1.%20%20Applicability%20Statement"></a><a class="selflink" href="#section-1.1" name="section-1.1">1.1</a>.  Applicability Statement</span>

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/1.1.1.%20%20The%20Target%20Application%20Space"></a><a class="selflink" href="#section-1.1.1" name="section-1.1.1">1.1.1</a>.  The Target Application Space</span>

   FLUTE is applicable to the delivery of large and small files to many
   hosts, using delivery sessions of several seconds or more.  For
   instance, FLUTE could be used for the delivery of large software
   updates to many hosts simultaneously.  It could also be used for
   continuous, but segmented, data such as time-lined text for
   subtitling - potentially leveraging its layering inheritance from ALC
   and LCT to scale the richness of the session to the congestion status



<span class="grey">Paila, et al.                 Experimental                      [Page 3]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-4" id="page-4" name="page-4"> </a>
<span class="grey"><a href="rfc3926.html">RFC 3926</a>                         FLUTE                      October 2004</span>


   of the network.  It is also suitable for the basic transport of
   metadata, for example SDP [<a href="#ref-12" title='"SDP: Session Description Protocol"'>12</a>] files which enable user applications
   to access multimedia sessions.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/1.1.2.%20%20The%20Target%20Scale"></a><a class="selflink" href="#section-1.1.2" name="section-1.1.2">1.1.2</a>.  The Target Scale</span>

   Massive scalability is a primary design goal for FLUTE.  IP multicast
   is inherently massively scalable, but the best effort service that it
   provides does not provide session management functionality,
   congestion control or reliability.  FLUTE provides all of this using
   ALC and IP multicast without sacrificing any of the inherent
   scalability of IP multicast.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/1.1.3.%20%20Intended%20Environments"></a><a class="selflink" href="#section-1.1.3" name="section-1.1.3">1.1.3</a>.  Intended Environments</span>

   All of the environmental requirements and considerations that apply
   to the ALC building block [<a href="#ref-2" title='"Asynchronous Layered Coding (ALC) Protocol Instantiation"'>2</a>] and to any additional building blocks
   that FLUTE uses also apply to FLUTE.

   FLUTE can be used with both multicast and unicast delivery, but it's
   primary application is for unidirectional multicast file delivery.
   FLUTE requires connectivity between a sender and receivers but does
   not require connectivity from receivers to a sender.  FLUTE
   inherently works with all types of networks, including LANs, WANs,
   Intranets, the Internet, asymmetric networks, wireless networks, and
   satellite networks.

   FLUTE is compatible with both IPv4 or IPv6 as no part of the packet
   is IP version specific.  FLUTE works with both multicast models:
   Any-Source Multicast (ASM) [<a href="#ref-13" title='"Host extensions for IP multicasting"'>13</a>] and the Source-Specific Multicast
   (SSM) [<a href="#ref-15" title='"A Channel Model for Multicast, Ph.D. Dissertation, Stanford University, Department of Computer Science, Stanford, California"'>15</a>].

   FLUTE is applicable for both Internet use, with a suitable congestion
   control building block, and provisioned/controlled systems, such as
   delivery over wireless broadcast radio systems.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/1.1.4.%20%20Weaknesses"></a><a class="selflink" href="#section-1.1.4" name="section-1.1.4">1.1.4</a>.  Weaknesses</span>

   Some networks are not amenable to some congestion control protocols
   that could be used with FLUTE.  In particular, for a satellite or
   wireless network, there may be no mechanism for receivers to
   effectively reduce their reception rate since there may be a fixed
   transmission rate allocated to the session.








<span class="grey">Paila, et al.                 Experimental                      [Page 4]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-5" id="page-5" name="page-5"> </a>
<span class="grey"><a href="rfc3926.html">RFC 3926</a>                         FLUTE                      October 2004</span>


   FLUTE provides reliability using the FEC building block.  This will
   reduce the error rate as seen by applications.  However, FLUTE does
   not provide a method for senders to verify the reception success of
   receivers, and the specification of such a method is outside the
   scope of this document.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/2.%20%20Conventions%20used%20in%20this%20Document"></a><a class="selflink" href="#section-2" name="section-2">2</a>.  Conventions used in this Document</span>

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in <a href="rfc2119.html">RFC 2119</a> [<a href="#ref-1" title='"Key words for use in RFCs to Indicate Requirement Levels"'>1</a>].

   The terms "object" and "transport object" are consistent with the
   definitions in ALC [<a href="#ref-2" title='"Asynchronous Layered Coding (ALC) Protocol Instantiation"'>2</a>] and LCT [<a href="#ref-3" title='"Layered Coding Transport (LCT) Building Block"'>3</a>].  The terms "file" and "source
   object" are pseudonyms for "object".

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/3.%20%20File%20delivery"></a><a class="selflink" href="#section-3" name="section-3">3</a>.  File delivery</span>

   Asynchronous Layered Coding [<a href="#ref-2" title='"Asynchronous Layered Coding (ALC) Protocol Instantiation"'>2</a>] is a protocol designed for delivery
   of arbitrary binary objects.  It is especially suitable for massively
   scalable, unidirectional, multicast distribution.  ALC provides the
   basic transport for FLUTE, and thus FLUTE inherits the requirements
   of ALC.

   This specification is designed for the delivery of files.  The core
   of this specification is to define how the properties of the files
   are carried in-band together with the delivered files.

   As an example, let us consider a 5200 byte file referred to by
   "http://www.example.com/docs/file.txt".  Using the example, the
   following properties describe the properties that need to be conveyed
   by the file delivery protocol.

   *  Identifier of the file, expressed as a URI.  This identifier may
      be globally unique.  The identifier may also provide a location
      for the file.  In the above example: "http://www.example.com/docs/
      file.txt".

   *  File name (usually, this can be concluded from the URI).  In the
      above example: "file.txt".

   *  File type, expressed as MIME media type (usually, this can also be
      concluded from the extension of the file name).  In the above
      example: "text/plain".  If an explicit value for the MIME type is
      provided separately from the file extension and does not match the
      MIME type of the file extension then the explicitly provided value
      MUST be used as the MIME type.




<span class="grey">Paila, et al.                 Experimental                      [Page 5]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-6" id="page-6" name="page-6"> </a>
<span class="grey"><a href="rfc3926.html">RFC 3926</a>                         FLUTE                      October 2004</span>


   *  File size, expressed in bytes.  In the above example: "5200".  If
      the file is content encoded then this is the file size before
      content encoding.

   *  Content encoding of the file, within transport.  In the above
      example, the file could be encoded using ZLIB [<a href="#ref-10" title='"ZLIB Compressed Data Format Specification version 3.3"'>10</a>].  In this case
      the size of the transport object carrying the file would probably
      differ from the file size.  The transport object size is delivered
      to receivers as part of the FLUTE protocol.

   *  Security properties of the file such as digital signatures,
      message digests, etc.  For example, one could use S/MIME [<a href="#ref-18" title='"Secure/Multipurpose Internet Mail Extensions (S/MIME) Version 3.1 Message Specification"'>18</a>] as
      the content encoding type for files with this authentication
      wrapper, and one could use XML-DSIG [<a href="#ref-19" title='"(Extensible Markup Language) XML-Signature Syntax and Processing"'>19</a>] to digitally sign an FDT
      Instance.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.1.%20%20File%20delivery%20session"></a><a class="selflink" href="#section-3.1" name="section-3.1">3.1</a>.  File delivery session</span>

   ALC is a protocol instantiation of Layered Coding Transport building
   block (LCT) [<a href="#ref-3" title='"Layered Coding Transport (LCT) Building Block"'>3</a>].  Thus ALC inherits the session concept of LCT.  In
   this document we will use the concept ALC/LCT session to collectively
   denote the interchangeable terms ALC session and LCT session.

   An ALC/LCT session consists of a set of logically grouped ALC/LCT
   channels associated with a single sender sending packets with ALC/LCT
   headers for one or more objects.  An ALC/LCT channel is defined by
   the combination of a sender and an address associated with the
   channel by the sender.  A receiver joins a channel to start receiving
   the data packets sent to the channel by the sender, and a receiver
   leaves a channel to stop receiving data packets from the channel.

   One of the fields carried in the ALC/LCT header is the Transport
   Session Identifier (TSI).  The TSI is scoped by the source IP
   address, and the (source IP address, TSI) pair uniquely identifies a
   session, i.e., the receiver uses this pair carried in each packet to
   uniquely identify from which session the packet was received.  In
   case multiple objects are carried within a session, the Transport
   Object Identifier (TOI) field within the ALC/LCT header identifies
   from which object the data in the packet was generated.  Note that
   each object is associated with a unique TOI within the scope of a
   session.

   If the sender is not assigned a permanent IP address accessible to
   receivers, but instead, packets that can be received by receivers
   containing a temporary IP address for packets sent by the sender,
   then the TSI is scoped by this temporary IP address of the sender for
   the duration of the session.  As an example, the sender may be behind
   a Network Address Translation (NAT) device that temporarily assigns



<span class="grey">Paila, et al.                 Experimental                      [Page 6]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-7" id="page-7" name="page-7"> </a>
<span class="grey"><a href="rfc3926.html">RFC 3926</a>                         FLUTE                      October 2004</span>


   an IP address for the sender that is accessible to receivers, and in
   this case the TSI is scoped by the temporary IP address assigned by
   the NAT that will appear in packets received by the receiver.  As
   another example, the sender may send its original packets using IPv6,
   but some portions of the network may not be IPv6 capable and thus
   there may be an IPv6 to IPv4 translator that changes the IP address
   of the packets to a different IPv4 address.  In this case, receivers
   in the IPv4 portion of the network will receive packets containing
   the IPv4 address, and thus the TSI for them is scoped by the IPv4
   address.  How the IP address of the sender to be used to scope the
   session by receivers is delivered to receivers, whether it is a
   permanent IP address or a temporary IP address, is outside the scope
   of this document.

   When FLUTE is used for file delivery over ALC the following rules
   apply:

   *  The ALC/LCT session is called file delivery session.

   *  The ALC/LCT concept of 'object' denotes either a 'file' or a 'File
      Delivery Table Instance' (<a href="#section-3.2">section 3.2</a>)

   *  The TOI field MUST be included in ALC packets sent within a FLUTE
      session, with the exception that ALC packets sent in a FLUTE
      session with the Close Session (A) flag set to 1 (signaling the
      end of the session) and that contain no payload (carrying no
      information for any file or FDT) SHALL NOT carry the TOI.  See
      <a href="rfc3451.html#section-5.1">Section 5.1 of RFC 3451</a> [<a href="#ref-3" title='"Layered Coding Transport (LCT) Building Block"'>3</a>] for the LCT definition of the Close
      Session flag, and see <a href="rfc3450.html#section-4.2">Section 4.2 of RFC 3450</a> [<a href="#ref-2" title='"Asynchronous Layered Coding (ALC) Protocol Instantiation"'>2</a>] for an example
      of its use within an ALC packet.

   *  The TOI value '0' is reserved for delivery of File Delivery Table
      Instances.  Each File Delivery Table Instance is uniquely
      identified by an FDT Instance ID.

   *  Each file in a file delivery session MUST be associated with a TOI
      (&gt;0) in the scope of that session.

   *  Information carried in the headers and the payload of a packet is
      scoped by the source IP address and the TSI.  Information
      particular to the object carried in the headers and the payload of
      a packet is further scoped by the TOI for file objects, and is
      further scoped by both the TOI and the FDT Instance ID for FDT
      Instance objects.







<span class="grey">Paila, et al.                 Experimental                      [Page 7]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-8" id="page-8" name="page-8"> </a>
<span class="grey"><a href="rfc3926.html">RFC 3926</a>                         FLUTE                      October 2004</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.2.%20%20File%20Delivery%20Table"></a><a class="selflink" href="#section-3.2" name="section-3.2">3.2</a>.  File Delivery Table</span>

   The File Delivery Table (FDT) provides a means to describe various
   attributes associated with files that are to be delivered within the
   file delivery session.  The following lists are examples of such
   attributes, and are not intended to be mutually exclusive nor
   exhaustive.

   Attributes related to the delivery of file:

   -  TOI value that represents the file

   -  FEC Object Transmission Information (including the FEC Encoding ID
      and, if relevant, the FEC Instance ID)

   -  Size of the transport object carrying the file

   -  Aggregate rate of sending packets to all channels

   Attributes related to the file itself:

   -  Name, Identification and Location of file (specified by the URI)

   -  MIME media type of file

   -  Size of file

   -  Encoding of file

   -  Message digest of file

   Some of these attributes MUST be included in the file description
   entry for a file, others are optional, as defined in <a href="#section-3.4.2">section 3.4.2</a>.

   Logically, the FDT is a set of file description entries for files to
   be delivered in the session.  Each file description entry MUST
   include the TOI for the file that it describes and the URI
   identifying the file.  The TOI is included in each ALC/LCT data
   packet during the delivery of the file, and thus the TOI carried in
   the file description entry is how the receiver determines which
   ALC/LCT data packets contain information about which file.  Each file
   description entry may also contain one or more descriptors that map
   the above-mentioned attributes to the file.

   Each file delivery session MUST have an FDT that is local to the
   given session.  The FDT MUST provide a file description entry mapped
   to a TOI for each file appearing within the session.  An object that
   is delivered within the ALC session, but not described in the FDT, is



<span class="grey">Paila, et al.                 Experimental                      [Page 8]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-9" id="page-9" name="page-9"> </a>
<span class="grey"><a href="rfc3926.html">RFC 3926</a>                         FLUTE                      October 2004</span>


   not considered a 'file' belonging to the file delivery session.
   Handling of these unmapped TOIs (TOIs that are not resolved by the
   FDT) is out of scope of this specification.

   Within the file delivery session the FDT is delivered as FDT
   Instances.  An FDT Instance contains one or more file description
   entries of the FDT.  Any FDT Instance can be equal to, a subset of, a
   superset of, or complement any other FDT Instance.  A certain FDT
   Instance may be repeated several times during a session, even after
   subsequent FDT Instances (with higher FDT Instance ID numbers) have
   been transmitted.  Each FDT Instance contains at least a single file
   description entry and at most the complete FDT of the file delivery
   session.

   A receiver of the file delivery session keeps an FDT database for
   received file description entries.  The receiver maintains the
   database, for example, upon reception of FDT Instances.  Thus, at any
   given time the contents of the FDT database represent the receiver's
   current view of the FDT of the file delivery session.  Since each
   receiver behaves independently of other receivers, it SHOULD NOT be
   assumed that the contents of the FDT database are the same for all
   the receivers of a given file delivery session.

   Since FDT database is an abstract concept, the structure and the
   maintaining of the FDT database are left to individual
   implementations and are thus out of scope of this specification.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.3.%20%20Dynamics%20of%20FDT%20Instances%20within%20file%20delivery%20session"></a><a class="selflink" href="#section-3.3" name="section-3.3">3.3</a>.  Dynamics of FDT Instances within file delivery session</span>

   The following rules define the dynamics of the FDT Instances within a
   file delivery session:

   *  For every file delivered within a file delivery session there MUST
      be a file description entry included in at least one FDT Instance
      sent within the session.  A file description entry contains at a
      minimum the mapping between the TOI and the URI.

   *  An FDT Instance MAY appear in any part of the file delivery
      session and packets for an FDT Instance MAY be interleaved with
      packets for other files or other FDT Instances within a session.

   *  The TOI value of '0' MUST be reserved for delivery of FDT
      Instances.  The use of other TOI values for FDT Instances is
      outside the scope of this specification.







<span class="grey">Paila, et al.                 Experimental                      [Page 9]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-10" id="page-10" name="page-10"> </a>
<span class="grey"><a href="rfc3926.html">RFC 3926</a>                         FLUTE                      October 2004</span>


   *  FDT Instance is identified by the use of a new fixed length LCT
      Header Extension EXT_FDT (defined later in this section).  Each
      FDT Instance is uniquely identified within the file delivery
      session by its FDT Instance ID.  Any ALC/LCT packet carrying FDT
      Instance (indicated by TOI = 0) MUST include EXT_FDT.

   *  It is RECOMMENDED that FDT Instance that contains the file
      description entry for a file is sent prior to the sending of the
      described file within a file delivery session.

   *  Within a file delivery session, any TOI &gt; 0 MAY be described more
      than once.  An example: previous FDT Instance 0 describes TOI of
      value '3'.  Now, subsequent FDT Instances can either keep TOI '3'
      unmodified on the table, not include it, or complement the
      description.  However, subsequent FDT Instances MUST NOT change
      the parameters already described for a specific TOI.

   *  An FDT Instance is valid until its expiration time.  The
      expiration time is expressed within the FDT Instance payload as a
      32 bit data field.  The value of the data field represents the 32
      most significant bits of a 64 bit Network Time Protocol (NTP) [<a href="#ref-5" title='"Network Time Protocol (Version 3) Specification, Implementation"'>5</a>]
      time value.  These 32 bits provide an unsigned integer
      representing the time in seconds relative to 0 hours 1 January
      1900.  Handling of wraparound of the 32 bit time is outside the
      scope of NTP and FLUTE.

   *  The receiver SHOULD NOT use a received FDT Instance to interpret
      packets received beyond the expiration time of the FDT Instance.

   *  A sender MUST use an expiry time in the future upon creation of an
      FDT Instance relative to its Sender Current Time (SCT).

   *  Any FEC Encoding ID MAY be used for the sending of FDT Instances.
      The default is to use FEC Encoding ID 0 for the sending of FDT
      Instances.  (Note that since FEC Encoding ID 0 is the default for
      FLUTE, this implies that Source Block Number and Encoding Symbol
      ID lengths both default to 16 bits each.)

   Generally, a receiver needs to receive an FDT Instance describing a
   file before it is able to recover the file itself.  In this sense FDT
   Instances are of higher priority than files.  Thus, it is RECOMMENDED
   that FDT Instances describing a file be sent with at least as much
   reliability within a session (more often or with more FEC protection)
   as the files they describe.  In particular, if FDT Instances are
   longer than one packet payload in length it is RECOMMENDED that an
   FEC code that provides protection against loss be used for delivering
   FDT Instances.  How often the description of a file is sent in an FDT




<span class="grey">Paila, et al.                 Experimental                     [Page 10]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-11" id="page-11" name="page-11"> </a>
<span class="grey"><a href="rfc3926.html">RFC 3926</a>                         FLUTE                      October 2004</span>


   Instance or how much FEC protection is provided for each FDT Instance
   (if the FDT Instance is longer than one packet payload) is dependent
   on the particular application and outside the scope of this document.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.4.%20%20Structure%20of%20FDT%20Instance%20packets"></a><a class="selflink" href="#section-3.4" name="section-3.4">3.4</a>.  Structure of FDT Instance packets</span>

   FDT Instances are carried in ALC packets with TOI = 0 and with an
   additional REQUIRED LCT Header extension called the FDT Instance
   Header.  The FDT Instance Header (EXT_FDT) contains the FDT Instance
   ID that uniquely identifies FDT Instances within a file delivery
   session.  The FDT Instance Header is placed in the same way as any
   other LCT extension header.  There MAY be other LCT extension headers
   in use.

   The LCT extension headers are followed by the FEC Payload ID, and
   finally the Encoding Symbols for the FDT Instance which contains one
   or more file description entries.  A FDT Instance MAY span several
   ALC packets - the number of ALC packets is a function of the file
   attributes associated with the FDT Instance.  The FDT Instance Header
   is carried in each ALC packet carrying the FDT Instance.  The FDT
   Instance Header is identical for all ALC/LCT packets for a particular
   FDT Instance.

   The overall format of ALC/LCT packets carrying an FDT Instance is
   depicted in the Figure 1 below.  All integer fields are carried in
   "big-endian" or "network order" format, that is, most significant
   byte (octet) first.  As defined in [<a href="#ref-2" title='"Asynchronous Layered Coding (ALC) Protocol Instantiation"'>2</a>], all ALC/LCT packets are sent
   using UDP.























<span class="grey">Paila, et al.                 Experimental                     [Page 11]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-12" id="page-12" name="page-12"> </a>
<span class="grey"><a href="rfc3926.html">RFC 3926</a>                         FLUTE                      October 2004</span>


   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                         UDP header                            |
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                Default LCT header (with TOI = 0)              |
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |          LCT header extensions (EXT_FDT, EXT_FTI, etc.)       |
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                       FEC Payload ID                          |
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |              Encoding Symbol(s) for FDT Instance              |
   |                           ...                                 |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                    Figure 1 - Overall FDT Packet

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/3.4.1.%20%20Format%20of%20FDT%20Instance%20Header"></a><a class="selflink" href="#section-3.4.1" name="section-3.4.1">3.4.1</a>.  Format of FDT Instance Header</span>

   FDT Instance Header (EXT_FDT) is a new fixed length, ALC PI specific
   LCT header extension [<a href="#ref-3" title='"Layered Coding Transport (LCT) Building Block"'>3</a>].  The Header Extension Type (HET) for the
   extension is 192.  Its format is defined below:


    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |   HET = 192   |   V   |          FDT Instance ID              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

   Version of FLUTE (V), 4 bits:

   This document specifies FLUTE version 1.  Hence in any ALC packet
   that carries FDT Instance and that belongs to the file delivery
   session as specified in this specification MUST set this field to
   '1'.

   FDT Instance ID, 20 bits:

   For each file delivery session the numbering of FDT Instances starts
   from '0' and is incremented by one for each subsequent FDT Instance.
   After reaching the maximum value (2^20-1), the numbering starts again
   from '0'.  When wraparound from 2^20-1 to 0 occurs, 0 is considered
   higher than 2^20-1.  A new FDT Instance reusing a previous FDT
   Instance ID number, due to wraparound, may not implicitly expire the
   previous FDT Instance with the same ID.  It would be reasonable for



<span class="grey">Paila, et al.                 Experimental                     [Page 12]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-13" id="page-13" name="page-13"> </a>
<span class="grey"><a href="rfc3926.html">RFC 3926</a>                         FLUTE                      October 2004</span>


   FLUTE Senders to only construct and deliver FDT Instances with
   wraparound IDs after the previous FDT Instance using the same ID has
   expired.   However, mandatory receiver behavior for handling FDT
   Instance ID wraparound and other special situations (for example,
   missing FDT Instance IDs resulting in larger increments than one) is
   outside the scope of this specification and left to individual
   implementations of FLUTE.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/3.4.2.%20%20Syntax%20of%20FDT%20Instance"></a><a class="selflink" href="#section-3.4.2" name="section-3.4.2">3.4.2</a>.  Syntax of FDT Instance</span>

   The FDT Instance contains file description entries that provide the
   mapping functionality described in 3.2 above.

   The FDT Instance is an XML structure that has a single root element
   "FDT-Instance".  The "FDT-Instance" element MUST contain "Expires"
   attribute, which tells the expiry time of the FDT Instance.  In
   addition, the "FDT-Instance" element MAY contain the "Complete"
   attribute (boolean), which, when TRUE, signals that no new data will
   be provided in future FDT Instances within this session (i.e., that
   either FDT Instances with higher ID numbers will not be used or if
   they are used, will only provide identical file parameters to those
   already given in this and previous FDT Instances).  For example, this
   may be used to provide a complete list of files in an entire FLUTE
   session (a "complete FDT").

   The "FDT-Instance" element MAY contain attributes that give common
   parameters for all files of an FDT Instance.  These attributes MAY
   also be provided for individual files in the "File" element.  Where
   the same attribute appears in both the "FDT-Instance" and the "File"
   elements, the value of the attribute provided in the "File" element
   takes precedence.

   For each file to be declared in the given FDT Instance there is a
   single file description entry in the FDT Instance.  Each entry is
   represented by element "File" which is a child element of the FDT
   Instance structure.

   The attributes of "File" element in the XML structure represent the
   attributes given to the file that is delivered in the file delivery
   session.  The value of the XML attribute name corresponds to MIME
   field name and the XML attribute value corresponds to the value of
   the MIME field body.  Each "File" element MUST contain at least two
   attributes "TOI" and "Content-Location".  "TOI" MUST be assigned a
   valid TOI value as described in <a href="#section-3.3">section 3.3</a> above.  "Content-
   Location" MUST be assigned a valid URI as defined in [<a href="#ref-6" title='"Hypertext Transfer Protocol -- HTTP/1.1"'>6</a>].






<span class="grey">Paila, et al.                 Experimental                     [Page 13]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-14" id="page-14" name="page-14"> </a>
<span class="grey"><a href="rfc3926.html">RFC 3926</a>                         FLUTE                      October 2004</span>


   In addition to mandatory attributes, the "FDT-Instance" element and
   the "File" element MAY contain other attributes of which the
   following are specifically pointed out.

   *  Where the MIME type is described, the attribute "Content-Type"
      MUST be used for the purpose as defined in [<a href="#ref-6" title='"Hypertext Transfer Protocol -- HTTP/1.1"'>6</a>].

   *  Where the length is described, the attribute "Content-Length" MUST
      be used for the purpose as defined in [<a href="#ref-6" title='"Hypertext Transfer Protocol -- HTTP/1.1"'>6</a>].  The transfer length is
      defined to be the length of the object transported in bytes.  It
      is often important to convey the transfer length to receivers,
      because the source block structure needs to be known for the FEC
      decoder to be applied to recover source blocks of the file, and
      the transfer length is often needed to properly determine the
      source block structure of the file.  There generally will be a
      difference between the length of the original file and the
      transfer length if content encoding is applied to the file before
      transport, and thus the "Content-Encoding" attribute is used.  If
      the file is not content encoded before transport (and thus the
      "Content-Encoding" attribute is not used) then the transfer length
      is the length of the original file, and in this case the
      "Content-Length" is also the transfer length.  However, if the
      file is content encoded before transport (and thus the "Content-
      Encoding" attribute is used), e.g., if compression is applied
      before transport to reduce the number of bytes that need to be
      transferred, then the transfer length is generally different than
      the length of the original file, and in this case the attribute
      "Transfer-Length" MAY be used to carry the transfer length.

   *  Where the content encoding scheme is described, the attribute
      "Content-Encoding" MUST be used for the purpose as defined in [<a href="#ref-6" title='"Hypertext Transfer Protocol -- HTTP/1.1"'>6</a>].

   *  Where the MD5 message digest is described, the attribute
      "Content-MD5" MUST be used for the purpose as defined in [<a href="#ref-6" title='"Hypertext Transfer Protocol -- HTTP/1.1"'>6</a>].

   *  The FEC Object Transmission Information attributes as described in
      <a href="#section-5.2">section 5.2</a>.

   The following specifies the XML Schema [<a href="#ref-8" title='"XML Schema Part 1: Structures"'>8</a>][9] for FDT Instance:

   &lt;?xml version="1.0" encoding="UTF-8"?&gt;
   &lt;xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"
              xmlns:fl="http://www.example.com/flute"
              elementFormDefault:xs="qualified"
              targetNamespace:xs="http://www.example.com/flute"&gt;
    &lt;xs:element name="FDT-Instance"&gt;
     &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;



<span class="grey">Paila, et al.                 Experimental                     [Page 14]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-15" id="page-15" name="page-15"> </a>
<span class="grey"><a href="rfc3926.html">RFC 3926</a>                         FLUTE                      October 2004</span>


       &lt;xs:element name="File" maxOccurs="unbounded"&gt;
        &lt;xs:complexType&gt;
         &lt;xs:attribute name="Content-Location"
                       type="xs:anyURI"
                       use="required"/&gt;
         &lt;xs:attribute name="TOI"
                       type="xs:positiveInteger"
                       use="required"/&gt;
         &lt;xs:attribute name="Content-Length"
                       type="xs:unsignedLong"
                       use="optional"/&gt;
         &lt;xs:attribute name="Transfer-Length"
                       type="xs:unsignedLong"
                       use="optional"/&gt;
         &lt;xs:attribute name="Content-Type"
                       type="xs:string"
                       use="optional"/&gt;
         &lt;xs:attribute name="Content-Encoding"
                       type="xs:string"
                       use="optional"/&gt;
         &lt;xs:attribute name="Content-MD5"
                       type="xs:base64Binary"
                       use="optional"/&gt;
         &lt;xs:attribute name="FEC-OTI-FEC-Encoding-ID"
                       type="xs:unsignedLong"
                       use="optional"/&gt;
         &lt;xs:attribute name="FEC-OTI-FEC-Instance-ID"
                       type="xs:unsignedLong"
                       use="optional"/&gt;
         &lt;xs:attribute name="FEC-OTI-Maximum-Source-Block-Length"
                       type="xs:unsignedLong"
                       use="optional"/&gt;
         &lt;xs:attribute name="FEC-OTI-Encoding-Symbol-Length"
                       type="xs:unsignedLong"
                       use="optional"/&gt;
         &lt;xs:attribute name="FEC-OTI-Max-Number-of-Encoding-Symbols"
                       type="xs:unsignedLong"
                       use="optional"/&gt;
         &lt;xs:anyAttribute processContents="skip"/&gt;
        &lt;/xs:complexType&gt;
       &lt;/xs:element&gt;
      &lt;/xs:sequence&gt;

      &lt;xs:attribute name="Expires"
                    type="xs:string"
                    use="required"/&gt;
      &lt;xs:attribute name="Complete"
                    type="xs:boolean"



<span class="grey">Paila, et al.                 Experimental                     [Page 15]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-16" id="page-16" name="page-16"> </a>
<span class="grey"><a href="rfc3926.html">RFC 3926</a>                         FLUTE                      October 2004</span>


                    use="optional"/&gt;
      &lt;xs:attribute name="Content-Type"
                    type="xs:string"
                    use="optional"/&gt;
      &lt;xs:attribute name="Content-Encoding"
                    type="xs:string"
                    use="optional"/&gt;
      &lt;xs:attribute name="FEC-OTI-FEC-Encoding-ID"
                    type="xs:unsignedLong"
                    use="optional"/&gt;
      &lt;xs:attribute name="FEC-OTI-FEC-Instance-ID"
                    type="xs:unsignedLong"
                    use="optional"/&gt;
      &lt;xs:attribute name="FEC-OTI-Maximum-Source-Block-Length"
                    type="xs:unsignedLong"
                    use="optional"/&gt;
      &lt;xs:attribute name="FEC-OTI-Encoding-Symbol-Length"
                    type="xs:unsignedLong"
                    use="optional"/&gt;
      &lt;xs:attribute name="FEC-OTI-Max-Number-of-Encoding-Symbols"
                    type="xs:unsignedLong"
                    use="optional"/&gt;
      &lt;xs:anyAttribute processContents="skip"/&gt;
     &lt;/xs:complexType&gt;
    &lt;/xs:element&gt;
   &lt;/xs:schema&gt;

   Any valid FDT Instance must use the above XML Schema.  This way FDT
   provides extensibility to support private attributes within the file
   description entries.  Those could be, for example, the attributes
   related to the delivery of the file (timing, packet transmission
   rate, etc.).

   In case the basic FDT XML Schema is extended in terms of new
   descriptors, for attributes applying to a single file, those MUST be
   placed within the attributes of the element "File".  For attributes
   applying to all files described by the current FDT Instance, those
   MUST be placed within the element "FDT-Instance".  It is RECOMMENDED
   that the new descriptors applied in the FDT are in the format of MIME
   fields and are either defined in the HTTP/1.1 specification [<a href="#ref-6" title='"Hypertext Transfer Protocol -- HTTP/1.1"'>6</a>] or
   another well-known specification.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/3.4.3.%20%20Content%20Encoding%20of%20FDT%20Instance"></a><a class="selflink" href="#section-3.4.3" name="section-3.4.3">3.4.3</a>.  Content Encoding of FDT Instance</span>

   The FDT Instance itself MAY be content encoded, for example
   compressed.  This specification defines FDT Instance Content Encoding
   Header (EXT_CENC).  EXT_CENC is a new fixed length, ALC PI specific
   LCT header extension [<a href="#ref-3" title='"Layered Coding Transport (LCT) Building Block"'>3</a>].  The Header Extension Type (HET) for the



<span class="grey">Paila, et al.                 Experimental                     [Page 16]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-17" id="page-17" name="page-17"> </a>
<span class="grey"><a href="rfc3926.html">RFC 3926</a>                         FLUTE                      October 2004</span>


   extension is 193.  If the FDT Instance is content encoded, the
   EXT_CENC MUST be used to signal the content encoding type.  In that
   case, EXT_CENC header extension MUST be used in all ALC packets
   carrying the same FDT Instance ID.  Consequently, when EXT_CENC
   header is used, it MUST be used together with a proper FDT Instance
   Header (EXT_FDT).  Within a file delivery session, FDT Instances that
   are not content encoded and FDT Instances that are content encoded
   MAY both appear.  If content encoding is not used for a given FDT
   Instance, the EXT_CENC MUST NOT be used in any packet carrying the
   FDT Instance.  The format of EXT_CENC is defined below:

    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |   HET = 193   |     CENC      |          Reserved             |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

   Content Encoding Algorithm (CENC), 8 bits:

   This field signals the content encoding algorithm used in the FDT
   Instance payload.  The definition of this field is outside the scope
   of this specification.  Applicable content encoding algorithms
   include, for example, ZLIB [<a href="#ref-10" title='"ZLIB Compressed Data Format Specification version 3.3"'>10</a>], DEFLATE [<a href="#ref-16" title='"DEFLATE Compressed Data Format Specification version 1.3"'>16</a>] and GZIP [<a href="#ref-17" title='"GZIP file format specification version 4.3"'>17</a>].

   Reserved, 16 bits:

   This field MUST be set to all '0'.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.5.%20%20Multiplexing%20of%20files%20within%20a%20file%20delivery%20session"></a><a class="selflink" href="#section-3.5" name="section-3.5">3.5</a>.  Multiplexing of files within a file delivery session</span>

   The delivered files are carried as transport objects (identified with
   TOIs) in the file delivery session.  All these objects, including the
   FDT Instances, MAY be multiplexed in any order and in parallel with
   each other within a session, i.e., packets for one file MAY be
   interleaved with packets for other files or other FDT Instances
   within a session.

   Multiple FDT Instances MAY be delivered in a single session using TOI
   = 0.  In this case, it is RECOMMENDED that the sending of a previous
   FDT Instance SHOULD end before the sending of the next FDT Instance
   starts.  However, due to unexpected network conditions, packets for
   the FDT Instances MAY be interleaved.  A receiver can determine which
   FDT Instance a packet contains information about since the FDT
   Instances are uniquely identified by their FDT Instance ID carried in
   the EXT_FDT headers.






<span class="grey">Paila, et al.                 Experimental                     [Page 17]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-18" id="page-18" name="page-18"> </a>
<span class="grey"><a href="rfc3926.html">RFC 3926</a>                         FLUTE                      October 2004</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/4.%20%20Channels%2C%20congestion%20control%20and%20timing"></a><a class="selflink" href="#section-4" name="section-4">4</a>.  Channels, congestion control and timing</span>

   ALC/LCT has a concept of channels and congestion control.  There are
   four scenarios FLUTE is envisioned to be applied.

   (a) Use a single channel and a single-rate congestion control
       protocol.

   (b) Use multiple channels and a multiple-rate congestion control
       protocol.  In this case the FDT Instances MAY be delivered on
       more than one channel.

   (c) Use a single channel without congestion control supplied by ALC,
       but only when in a controlled network environment where flow/
       congestion control is being provided by other means.

   (d) Use multiple channels without congestion control supplied by ALC,
       but only when in a controlled network environment where flow/
       congestion control is being provided by other means.  In this
       case the FDT Instances MAY be delivered on more than one channel.

   When using just one channel for a file delivery session, as in (a)
   and (c), the notion of 'prior' and 'after' are intuitively defined
   for the delivery of objects with respect to their delivery times.

   However, if multiple channels are used, as in (b) and (d), it is not
   straightforward to state that an object was delivered 'prior' to the
   other.  An object may begin to be delivered on one or more of those
   channels before the delivery of a second object begins.  However, the
   use of multiple channels/layers may complete the delivery of the
   second object before the first.  This is not a problem when objects
   are delivered sequentially using a single channel.  Thus, if the
   application of FLUTE has a mandatory or critical requirement that the
   first transport object must complete 'prior' to the second one, it is
   RECOMMENDED that only a single channel is used for the file delivery
   session.

   Furthermore, if multiple channels are used then a receiver joined to
   the session at a low reception rate will only be joined to the lower
   layers of the session.  Thus, since the reception of FDT Instances is
   of higher priority than the reception of files (because the reception
   of files depends on the reception of an FDT Instance describing it),
   the following is RECOMMENDED:

   1. The layers to which packets for FDT Instances are sent SHOULD NOT
      be biased towards those layers to which lower rate receivers are
      not joined.  For example, it is ok to put all the packets for an
      FDT Instance into the lowest layer (if this layer carries enough



<span class="grey">Paila, et al.                 Experimental                     [Page 18]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-19" id="page-19" name="page-19"> </a>
<span class="grey"><a href="rfc3926.html">RFC 3926</a>                         FLUTE                      October 2004</span>


      packets to deliver the FDT to higher rate receivers in a
      reasonable amount of time), but it is not ok to put all the
      packets for an FDT Instance into the higher layers that only high
      rate receivers will receive.

   2. If FDT Instances are generally longer than one Encoding Symbol in
      length and some packets for FDT Instances are sent to layers that
      lower rate receivers do not receive, an FEC Encoding other than
      FEC Encoding ID 0 SHOULD be used to deliver FDT Instances.  This
      is because in this case, even when there is no packet loss in the
      network, a lower rate receiver will not receive all packets sent
      for an FDT Instance.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/5.%20%20Delivering%20FEC%20Object%20Transmission%20Information"></a><a class="selflink" href="#section-5" name="section-5">5</a>.  Delivering FEC Object Transmission Information</span>

   FLUTE inherits the use of FEC building block [<a href="#ref-4" title='"Forward Error Correction (FEC) Building Block"'>4</a>] from ALC.  When
   using FLUTE for file delivery over ALC the FEC Object Transmission
   Information MUST be delivered in-band within the file delivery
   session.  In this section, two methods are specified for FLUTE for
   this purpose: the use of ALC specific LCT extension header EXT_FTI
   [<a href="#ref-2" title='"Asynchronous Layered Coding (ALC) Protocol Instantiation"'>2</a>] and the use of FDT.

   The receiver of file delivery session MUST support delivery of FEC
   Object Transmission Information using the EXT_FTI for the FDT
   Instances carried using TOI value 0.  For the TOI values other than 0
   the receiver MUST support both methods: the use of EXT_FTI and the
   use of FDT.

   The FEC Object Transmission Information that needs to be delivered to
   receivers MUST be exactly the same whether it is delivered using
   EXT_FTI or using FDT (or both).  <a href="#section-5.1">Section 5.1</a> describes the required
   FEC Object Transmission Information that MUST be delivered to
   receivers for various FEC Encoding IDs.  In addition, it describes
   the delivery using EXT_FTI.  <a href="#section-5.2">Section 5.2</a> describes the delivery using
   FDT.

   The FEC Object Transmission Information regarding a given TOI may be
   available from several sources.  In this case, it is RECOMMENDED that
   the receiver of the file delivery session prioritizes the sources in
   the following way (in the order of decreasing priority).

   1. FEC Object Transmission Information that is available in EXT_FTI.

   2. FEC Object Transmission Information that is available in the FDT.







<span class="grey">Paila, et al.                 Experimental                     [Page 19]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-20" id="page-20" name="page-20"> </a>
<span class="grey"><a href="rfc3926.html">RFC 3926</a>                         FLUTE                      October 2004</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.1.%20%20Use%20of%20EXT_FTI%20for%20delivery%20of%20FEC%20Object%20Transmission%20Information"></a><a class="selflink" href="#section-5.1" name="section-5.1">5.1</a>.  Use of EXT_FTI for delivery of FEC Object Transmission Information</span>

   As specified in [<a href="#ref-2" title='"Asynchronous Layered Coding (ALC) Protocol Instantiation"'>2</a>], the EXT_FTI header extension is intended to
   carry the FEC Object Transmission Information for an object in-band.
   It is left up to individual implementations to decide how frequently
   and in which ALC packets the EXT_FTI header extension is included.
   In environments with higher packet loss rate, the EXT_FTI might need
   to be included more frequently in ALC packets than in environments
   with low error probability.  The EXT_FTI MUST be included in at least
   one sent ALC packet for each FDT Instance.

   The ALC specification does not define the format or the processing of
   the EXT_FTI header extension.  The following sections specify EXT_FTI
   when used in FLUTE.

   In FLUTE, the FEC Encoding ID (8 bits) is carried in the Codepoint
   field of the ALC/LCT header.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/5.1.1.%20%20General%20EXT_FTI%20format"></a><a class="selflink" href="#section-5.1.1" name="section-5.1.1">5.1.1</a>.  General EXT_FTI format</span>

   The general EXT_FTI format specifies the structure and those
   attributes of FEC Object Transmission Information that are applicable
   to any FEC Encoding ID.

    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |   HET = 64    |     HEL       |                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                               +
   |                       Transfer Length                         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |   FEC Instance ID             | FEC Enc. ID Specific Format   |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

   Header Extension Type (HET), 8 bits:

   64 as defined in [<a href="#ref-2" title='"Asynchronous Layered Coding (ALC) Protocol Instantiation"'>2</a>].

   Header Extension Length (HEL), 8 bits:












<span class="grey">Paila, et al.                 Experimental                     [Page 20]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-21" id="page-21" name="page-21"> </a>
<span class="grey"><a href="rfc3926.html">RFC 3926</a>                         FLUTE                      October 2004</span>


   The length of the whole Header Extension field, expressed in
   multiples of 32-bit words.  This length includes the FEC Encoding ID
   specific format part.

   Transfer Length, 48 bits:

   The length of the transport object that carries the file in bytes.
   (This is the same as the file length if the file is not content
   encoded.)

   FEC Instance ID, optional, 16 bits:

   This field is used for FEC Instance ID.  It is only present if the
   value of FEC Encoding ID is in the range of 128-255.  When the value
   of FEC Encoding ID is in the range of 0-127, this field is set to 0.

   FEC Encoding ID Specific Format:

   Different FEC encoding schemes will need different sets of encoding
   parameters.  Thus, the structure and length of this field depends on
   FEC Encoding ID.  The next sections specify structure of this field
   for FEC Encoding ID numbers 0, 128, 129, and 130.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/5.1.2.%20%20FEC%20Encoding%20ID%20specific%20formats%20for%20EXT_FTI"></a><a class="selflink" href="#section-5.1.2" name="section-5.1.2">5.1.2</a>.  FEC Encoding ID specific formats for EXT_FTI</span>

<span class="h5"><a class="dashAnchor" name="//apple_ref/Section/5.1.2.1.%20%20FEC%20Encoding%20IDs%200%2C%20128%2C%20and%20130"></a><a class="selflink" href="#section-5.1.2.1" name="section-5.1.2.1">5.1.2.1</a>.  FEC Encoding IDs 0, 128, and 130</span>

   FEC Encoding ID 0 is 'Compact No-Code FEC' (Fully-Specified) [<a href="#ref-7" title='"Compact Forward Error Correction (FEC) Schemes"'>7</a>].
   FEC Encoding ID 128 is 'Small Block, Large Block and Expandable FEC'
   (Under-Specified) [<a href="#ref-4" title='"Forward Error Correction (FEC) Building Block"'>4</a>].  FEC Encoding ID 130 is 'Compact FEC' (Under-
   Specified) [<a href="#ref-7" title='"Compact Forward Error Correction (FEC) Schemes"'>7</a>].  For these FEC Encoding IDs, the FEC Encoding ID
   specific format of EXT_FTI is defined as follows.

    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
                                   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      General EXT_FTI format       |    Encoding Symbol Length     |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                  Maximum Source Block Length                  |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

   Encoding Symbol Length, 16 bits:

   Length of Encoding Symbol in bytes.

   All Encoding Symbols of a transport object MUST be equal to this
   length, with the optional exception of the last source symbol of the
   last source block (so that redundant padding is not mandatory in this



<span class="grey">Paila, et al.                 Experimental                     [Page 21]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-22" id="page-22" name="page-22"> </a>
<span class="grey"><a href="rfc3926.html">RFC 3926</a>                         FLUTE                      October 2004</span>


   last symbol).  This last source symbol MUST be logically padded out
   with zeroes when another Encoding Symbol is computed based on this
   source symbol to ensure the same interpretation of this Encoding
   Symbol value by the sender and receiver.  However, this padding does
   not actually need to be sent with the data of the last source symbol.

   Maximum Source Block Length, 32 bits:

   The maximum number of source symbols per source block.

   This EXT_FTI specification requires that an algorithm is known to
   both sender and receivers for determining the size of all source
   blocks of the transport object that carries the file identified by
   the TOI (or within the FDT Instance identified by the TOI and the FDT
   Instance ID).  The algorithm SHOULD be the same for all files using
   the same FEC Encoding ID within a session.

   <a href="#section-5.1.2.3">Section 5.1.2.3</a> describes an algorithm that is RECOMMENDED for this
   use.

   For the FEC Encoding IDs 0, 128 and 130, this algorithm is the only
   well known way the receiver can determine the length of each source
   block.  Thus, the algorithm does two things: (a) it tells the
   receiver the length of each particular source block as it is
   receiving packets for that source block - this is essential to all of
   these FEC schemes; and, (b) it provides the source block structure
   immediately to the receiver so that the receiver can determine where
   to save recovered source blocks at the beginning of the reception of
   data packets for the file - this is an optimization which is
   essential for some implementations.

<span class="h5"><a class="dashAnchor" name="//apple_ref/Section/5.1.2.2.%20%20FEC%20Encoding%20ID%20129"></a><a class="selflink" href="#section-5.1.2.2" name="section-5.1.2.2">5.1.2.2</a>.  FEC Encoding ID 129</span>

   Small Block Systematic FEC (Under-Specified).  The FEC Encoding ID
   specific format of EXT_FTI is defined as follows.

    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
                                   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      General EXT_FTI format       |    Encoding Symbol Length     |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  Maximum Source Block Length  | Max. Num. of Encoding Symbols |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

   Encoding Symbol Length, 16 bits:

   Length of Encoding Symbol in bytes.




<span class="grey">Paila, et al.                 Experimental                     [Page 22]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-23" id="page-23" name="page-23"> </a>
<span class="grey"><a href="rfc3926.html">RFC 3926</a>                         FLUTE                      October 2004</span>


   All Encoding Symbols of a transport object MUST be equal to this
   length, with the optional exception of the last source symbol of the
   last source block (so that redundant padding is not mandatory in this
   last symbol).  This last source symbol MUST be logically padded out
   with zeroes when another Encoding Symbol is computed based on this
   source symbol to ensure the same interpretation of this Encoding
   Symbol value by the sender and receiver.  However, this padding need
   not be actually sent with the data of the last source symbol.

   Maximum Source Block Length, 16 bits:

   The maximum number of source symbols per source block.

   Maximum Number of Encoding Symbols, 16 bits:

   Maximum number of Encoding Symbols that can be generated for a source
   block.

   This EXT_FTI specification requires that an algorithm is known to
   both sender and receivers for determining the size of all source
   blocks of the transport object that carries the file identified by
   the TOI (or within the FDT Instance identified by the TOI and the FDT
   Instance ID).  The algorithm SHOULD be the same for all files using
   the same FEC Encoding ID within a session.

   <a href="#section-5.1.2.3">Section 5.1.2.3</a> describes an algorithm that is RECOMMENDED for this
   use.  For FEC Encoding ID 129 the FEC Payload ID in each data packet
   already contains the source block length for the source block
   corresponding to the Encoding Symbol carried in the data packet.
   Thus, the algorithm for computing source blocks for FEC Encoding ID
   129 could be to just use the source block lengths carried in data
   packets within the FEC Payload ID.  However, the algorithm described
   in <a href="#section-5.1.2.3">Section 5.1.2.3</a> is useful for the receiver to compute the source
   block structure at the beginning of the reception of data packets for
   the file.  If the algorithm described in <a href="#section-5.1.2.3">Section 5.1.2.3</a> is used then
   it MUST be the case that the source block lengths that appear in data
   packets agree with the source block lengths calculated by the
   algorithm.

<span class="h5"><a class="dashAnchor" name="//apple_ref/Section/5.1.2.3.%20%20Algorithm%20for%20Computing%20Source%20Block%20Structure"></a><a class="selflink" href="#section-5.1.2.3" name="section-5.1.2.3">5.1.2.3</a>.  Algorithm for Computing Source Block Structure</span>

   This algorithm computes a source block structure so that all source
   blocks are as close to being equal length as possible.  A first
   number of source blocks are of the same larger length, and the
   remaining second number of source blocks are sent of the same smaller
   length.  The total number of source blocks (N), the first number of





<span class="grey">Paila, et al.                 Experimental                     [Page 23]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-24" id="page-24" name="page-24"> </a>
<span class="grey"><a href="rfc3926.html">RFC 3926</a>                         FLUTE                      October 2004</span>


   source blocks (I), the second number of source blocks (N-I), the
   larger length (A_large) and the smaller length (A_small) are
   calculated thus,

      Input:
         B -- Maximum Source Block Length, i.e., the maximum number of
              source symbols per source block
         L -- Transfer Length in bytes
         E -- Encoding Symbol Length in bytes

      Output:
         N -- The number of source blocks into which the transport
              object is partitioned.

         The number and lengths of source symbols in each of the N
         source blocks.

      Algorithm:
      (a) The number of source symbols in the transport object is
          computed as T = L/E rounded up to the nearest integer.
      (b) The transport object is partitioned into N source blocks,
          where N = T/B rounded up to the nearest integer
      (c) The average length of a source block, A = T/N
          (this may be non-integer)
      (d) A_large = A rounded up to the nearest integer
          (it will always be the case that the value of A_large is at
          most B)
      (e) A_small = A rounded down to the nearest integer
          (if A is an integer A_small = A_large,
          and otherwise A_small = A_large - 1)
      (f) The fractional part of A, A_fraction = A - A_small
      (g) I = A_fraction * N
          (I is an integer between 0 and N-1)
      (h) Each of the first I source blocks consists of A_large source
          symbols, each source symbol is E bytes in length.  Each of the
          remaining N-I source blocks consist of A_small source symbols,
          each source symbol is E bytes in length except that the last
          source symbol of the last source block is L-(((L-1)/E) rounded
          down to the nearest integer)*E bytes in length.

   Note, this algorithm does not imply implementation by floating point
   arithmetic and integer arithmetic may be used to avoid potential
   floating point rounding errors.








<span class="grey">Paila, et al.                 Experimental                     [Page 24]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-25" id="page-25" name="page-25"> </a>
<span class="grey"><a href="rfc3926.html">RFC 3926</a>                         FLUTE                      October 2004</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.2.%20%20Use%20of%20FDT%20for%20delivery%20of%20FEC%20Object%20Transmission%20Information"></a><a class="selflink" href="#section-5.2" name="section-5.2">5.2</a>.  Use of FDT for delivery of FEC Object Transmission Information</span>

   The FDT delivers FEC Object Transmission Information for each file
   using an appropriate attribute within the "FDT-Instance" or the
   "File" element of the FDT structure.  For future FEC Encoding IDs, if
   the attributes listed below do not fulfill the needs of describing
   the FEC Object Transmission Information then additional new
   attributes MAY be used.

   *  "Transfer-Length" is semantically equivalent with the field
      "Transfer Length" of EXT_FTI.

   *  "FEC-OTI-FEC-Encoding-ID" is semantically equivalent with the
      field "FEC Encoding ID" as carried in the Codepoint field of the
      ALC/LCT header.

   *  "FEC-OTI-FEC-Instance-ID" is semantically equivalent with the
      field "FEC Instance ID" of EXT_FTI.

   *  "FEC-OTI-Maximum-Source-Block-Length" is semantically equivalent
      with the field "Maximum Source Block Length" of EXT_FTI for FEC
      Encoding IDs 0, 128 and 130, and semantically equivalent with the
      field "Maximum Source Block Length" of EXT_FTI for FEC Encoding ID
      129.

   *  "FEC-OTI-Encoding-Symbol-Length" is semantically equivalent with
      the field "Encoding Symbol Length" of EXT_FTI for FEC Encoding IDs
      0, 128, 129 and 130.

   *  "FEC-OTI-Max-Number-of-Encoding-Symbols" is semantically
      equivalent with the field "Maximum Number of Encoding Symbols" of
      EXT_FTI for FEC Encoding ID 129.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/6.%20%20Describing%20file%20delivery%20sessions"></a><a class="selflink" href="#section-6" name="section-6">6</a>.  Describing file delivery sessions</span>

      To start receiving a file delivery session, the receiver needs to
      know transport parameters associated with the session.
      Interpreting these parameters and starting the reception therefore
      represents the entry point from which thereafter the receiver
      operation falls into the scope of this specification.  According
      to [<a href="#ref-2" title='"Asynchronous Layered Coding (ALC) Protocol Instantiation"'>2</a>], the transport parameters of an ALC/LCT session that the
      receiver needs to know are:

   *  The source IP address;

   *  The number of channels in the session;





<span class="grey">Paila, et al.                 Experimental                     [Page 25]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-26" id="page-26" name="page-26"> </a>
<span class="grey"><a href="rfc3926.html">RFC 3926</a>                         FLUTE                      October 2004</span>


   *  The destination IP address and port number for each channel in the
      session;

   *  The Transport Session Identifier (TSI) of the session;

   *  An indication that the session is a FLUTE session.  The need to
      demultiplex objects upon reception is implicit in any use of
      FLUTE, and this fulfills the ALC requirement of an indication of
      whether or not a session carries packets for more than one object
      (all FLUTE sessions carry packets for more than one object).

      Optionally, the following parameters MAY be associated with the
      session (Note, the list is not exhaustive):

   *  The start time and end time of the session;

   *  FEC Encoding ID and FEC Instance ID when the default FEC Encoding
      ID 0 is not used for the delivery of FDT;

   *  Content Encoding format if optional content encoding of FDT
      Instance is used, e.g., compression;

   *  Some information that tells receiver, in the first place, that the
      session contains files that are of interest.

   It is envisioned that these parameters would be described according
   to some session description syntax (such as SDP [<a href="#ref-12" title='"SDP: Session Description Protocol"'>12</a>] or XML based)
   and held in a file which would be acquired by the receiver before the
   FLUTE session begins by means of some transport protocol (such as
   Session Announcement Protocol [<a href="#ref-11" title='"Session Announcement Protocol"'>11</a>], email, HTTP [<a href="#ref-6" title='"Hypertext Transfer Protocol -- HTTP/1.1"'>6</a>], SIP [<a href="#ref-22" title='"SIP: session initiation protocol"'>22</a>], manual
   pre-configuration, etc.) However, the way in which the receiver
   discovers the above-mentioned parameters is out of scope of this
   document, as it is for LCT and ALC.  In particular, this
   specification does not mandate or exclude any mechanism.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/7.%20%20Security%20Considerations"></a><a class="selflink" href="#section-7" name="section-7">7</a>.  Security Considerations</span>

   The security considerations that apply to, and are described in, ALC
   [<a href="#ref-2" title='"Asynchronous Layered Coding (ALC) Protocol Instantiation"'>2</a>], LCT [<a href="#ref-3" title='"Layered Coding Transport (LCT) Building Block"'>3</a>] and FEC [<a href="#ref-4" title='"Forward Error Correction (FEC) Building Block"'>4</a>] also apply to FLUTE.  In addition, any
   security considerations that apply to any congestion control building
   block used in conjunction with FLUTE also apply to FLUTE.

   Because of the use of FEC, FLUTE is especially vulnerable to denial-
   of-service attacks by attackers that try to send forged packets to
   the session which would prevent successful reconstruction or cause
   inaccurate reconstruction of large portions of the FDT or file by
   receivers.  Like ALC, FLUTE is particularly affected by such an




<span class="grey">Paila, et al.                 Experimental                     [Page 26]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-27" id="page-27" name="page-27"> </a>
<span class="grey"><a href="rfc3926.html">RFC 3926</a>                         FLUTE                      October 2004</span>


   attack because many receivers may receive the same forged packet.  A
   malicious attacker may spoof file packets and cause incorrect
   recovery of a file.

   Even more damaging, a malicious forger may spoof FDT Instance
   packets, for example sending packets with erroneous FDT-Instance
   fields.  Many attacks can follow this approach.  For instance a
   malicious attacker may alter the Content-Location field of TOI 'n',
   to make it point to a system file or a user configuration file.
   Then, TOI 'n' can carry a Trojan Horse or some other type of virus.
   It is thus STRONGLY RECOMMENDED that the FLUTE delivery service at
   the receiver does not have write access to the system files or
   directories, or any other critical areas.  As described for MIME
   [<a href="#ref-20" title='"Multipurpose Internet Mail Extensions (MIME) Part Four: Registration Procedures"'>20</a>][21], special consideration should be paid to the security
   implications of any MIME types that can cause the remote execution of
   any actions in the recipient's environment.  Note, <a href="rfc1521.html">RFC 1521</a> [<a href="#ref-21" title='"MIME (Multipurpose Internet Mail Extensions) Part Three: Message Header Extensions for Non-ASCII Text"'>21</a>]
   describes important security issues for this environment, even though
   its protocol is obsoleted by <a href="rfc2048.html">RFC 2048</a> [<a href="#ref-20" title='"Multipurpose Internet Mail Extensions (MIME) Part Four: Registration Procedures"'>20</a>].

   Another example is generating a bad Content-MD5 sum, leading
   receivers to reject the associated file that will be declared
   corrupted.  The Content-Encoding can also be modified, which also
   prevents the receivers to correctly handle the associated file.
   These examples show that the FDT information is critical to the FLUTE
   delivery service.

   At the application level, it is RECOMMENDED that an integrity check
   on the entire received object be done once the object is
   reconstructed to ensure it is the same as the sent object, especially
   for objects that are FDT Instances.  Moreover, in order to obtain
   strong cryptographic integrity protection a digital signature
   verifiable by the receiver SHOULD be used to provide this application
   level integrity check.  However, if even one corrupted or forged
   packet is used to reconstruct the object, it is likely that the
   received object will be reconstructed incorrectly.  This will
   appropriately cause the integrity check to fail and, in this case,
   the inaccurately reconstructed object SHOULD be discarded.  Thus, the
   acceptance of a single forged packet can be an effective denial of
   service attack for distributing objects, but an object integrity
   check at least prevents inadvertent use of inaccurately reconstructed
   objects.  The specification of an application level integrity check
   of the received object is outside the scope of this document.

   At the packet level, it is RECOMMENDED that a packet level
   authentication be used to ensure that each received packet is an
   authentic and uncorrupted packet containing FEC data for the object
   arriving from the specified sender.  Packet level authentication has
   the advantage that corrupt or forged packets can be discarded



<span class="grey">Paila, et al.                 Experimental                     [Page 27]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-28" id="page-28" name="page-28"> </a>
<span class="grey"><a href="rfc3926.html">RFC 3926</a>                         FLUTE                      October 2004</span>


   individually and the received authenticated packets can be used to
   accurately reconstruct the object.  Thus, the effect of a denial of
   service attack that injects forged packets is proportional only to
   the number of forged packets, and not to the object size.  Although
   there is currently no IETF standard that specifies how to do
   multicast packet level authentication, TESLA [<a href="#ref-14" title='"Efficient and Secure Source Authentication for Multicast, Network and Distributed System Security Symposium, NDSS 2001, pp. 35-46."'>14</a>] is a known
   multicast packet authentication scheme that would work.

   In addition to providing protection against reconstruction of
   inaccurate objects, packet level authentication can also provide some
   protection against denial of service attacks on the multiple rate
   congestion control.  Attackers can try to inject forged packets with
   incorrect congestion control information into the multicast stream,
   thereby potentially adversely affecting network elements and
   receivers downstream of the attack, and much less significantly the
   rest of the network and other receivers.  Thus, it is also
   RECOMMENDED that packet level authentication be used to protect
   against such attacks.  TESLA [<a href="#ref-14" title='"Efficient and Secure Source Authentication for Multicast, Network and Distributed System Security Symposium, NDSS 2001, pp. 35-46."'>14</a>] can also be used to some extent to
   limit the damage caused by such attacks.  However, with TESLA a
   receiver can only determine if a packet is authentic several seconds
   after it is received, and thus an attack against the congestion
   control protocol can be effective for several seconds before the
   receiver can react to slow down the session reception rate.

   Reverse Path Forwarding checks SHOULD be enabled in all network
   routers and switches along the path from the sender to receivers to
   limit the possibility of a bad agent injecting forged packets into
   the multicast tree data path.

   A receiver with an incorrect or corrupted implementation of the
   multiple rate congestion control building block may affect health of
   the network in the path between the sender and the receiver, and may
   also affect the reception rates of other receivers joined to the
   session.  It is therefore RECOMMENDED that receivers be required to
   identify themselves as legitimate before they receive the Session
   Description needed to join the session.  How receivers identify
   themselves as legitimate is outside the scope of this document.

   Another vulnerability of FLUTE is the potential of receivers
   obtaining an incorrect Session Description for the session.  The
   consequences of this could be that legitimate receivers with the
   wrong Session Description are unable to correctly receive the session
   content, or that receivers inadvertently try to receive at a much
   higher rate than they are capable of, thereby disrupting traffic in
   portions of the network.  To avoid these problems, it is RECOMMENDED
   that measures be taken to prevent receivers from accepting incorrect
   Session Descriptions, e.g., by using source authentication to ensure




<span class="grey">Paila, et al.                 Experimental                     [Page 28]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-29" id="page-29" name="page-29"> </a>
<span class="grey"><a href="rfc3926.html">RFC 3926</a>                         FLUTE                      October 2004</span>


   that receivers only accept legitimate Session Descriptions from
   authorized senders.  How this is done is outside the scope of this
   document.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/8.%20%20IANA%20Considerations"></a><a class="selflink" href="#section-8" name="section-8">8</a>.  IANA Considerations</span>

   No information in this specification is directly subject to IANA
   registration.  However, building blocks components used by ALC may
   introduce additional IANA considerations.  In particular, the FEC
   building block used by FLUTE does require IANA registration of the
   FEC codec used.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/9.%20%20Acknowledgements"></a><a class="selflink" href="#section-9" name="section-9">9</a>.  Acknowledgements</span>

   The following persons have contributed to this specification: Brian
   Adamson, Mark Handley, Esa Jalonen, Roger Kermode, Juha-Pekka Luoma,
   Jani Peltotalo, Sami Peltotalo, Topi Pohjolainen, and Lorenzo
   Vicisano.  The authors would like to thank all the contributors for
   their valuable work in reviewing and providing feedback regarding
   this specification.

Normative References

   [<a id="ref-1" name="ref-1">1</a>]   Bradner, S., "Key words for use in RFCs to Indicate Requirement
         Levels", <a href="https://tools.ietf.org/html/bcp14">BCP 14</a>, <a href="rfc2119.html">RFC 2119</a>, March 1997.

   [<a id="ref-2" name="ref-2">2</a>]   Luby, M., Gemmell, J., Vicisano, L., Rizzo, L., and J.
         Crowcroft, "Asynchronous Layered Coding (ALC) Protocol
         Instantiation", <a href="rfc3450.html">RFC 3450</a>, December 2002.

   [<a id="ref-3" name="ref-3">3</a>]   Luby, M., Gemmell, J., Vicisano, L., Rizzo, L., Handley, M.,
         and J. Crowcroft, "Layered Coding Transport (LCT) Building
         Block", <a href="rfc3451.html">RFC 3451</a>, December 2002.

   [<a id="ref-4" name="ref-4">4</a>]   Luby, M., Vicisano, L., Gemmell, J., Rizzo, L., Handley, M.,
         and J. Crowcroft, "Forward Error Correction (FEC) Building
         Block", <a href="rfc3452.html">RFC 3452</a>, December 2002.

   [<a id="ref-5" name="ref-5">5</a>]   Mills, D., "Network Time Protocol (Version 3) Specification,
         Implementation", <a href="rfc1305.html">RFC 1305</a>, March 1992.

   [<a id="ref-6" name="ref-6">6</a>]   Fielding,  R., Gettys, J., Mogul, J., Frystyk, H., Masinter,
         L., Leach, P., and T. Berners-Lee, "Hypertext Transfer Protocol
         -- HTTP/1.1", <a href="rfc2616.html">RFC 2616</a>, June 1999.

   [<a id="ref-7" name="ref-7">7</a>]   Luby, M. and L. Vicisano, "Compact Forward Error Correction
         (FEC) Schemes", <a href="rfc3695.html">RFC 3695</a>, February 2004.




<span class="grey">Paila, et al.                 Experimental                     [Page 29]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-30" id="page-30" name="page-30"> </a>
<span class="grey"><a href="rfc3926.html">RFC 3926</a>                         FLUTE                      October 2004</span>


   [<a id="ref-8" name="ref-8">8</a>]   Thompson, H., Beech, D., Maloney, M. and N. Mendelsohn, "XML
         Schema Part 1: Structures", W3C Recommendation, May 2001.

   [<a id="ref-9" name="ref-9">9</a>]   Biron, P. and A. Malhotra, "XML Schema Part 2: Datatypes", W3C
         Recommendation, May 2001.

Informative References

   [<a id="ref-10" name="ref-10">10</a>]  Deutsch, P. and J-L. Gailly, "ZLIB Compressed Data Format
         Specification version 3.3", <a href="rfc1950.html">RFC 1950</a>, May 1996.

   [<a id="ref-11" name="ref-11">11</a>]  Handley, M., Perkins, C., and E. Whelan, "Session Announcement
         Protocol", <a href="rfc2974.html">RFC 2974</a>, October 2000.

   [<a id="ref-12" name="ref-12">12</a>]  Handley, M. and V. Jacobson, "SDP: Session Description
         Protocol", <a href="rfc2327.html">RFC 2327</a>, April 1998.

   [<a id="ref-13" name="ref-13">13</a>]  Deering, S., "Host extensions for IP multicasting", STD 5, <a href="rfc1112.html">RFC</a>
         <a href="rfc1112.html">1112</a>, August 1989.

   [<a id="ref-14" name="ref-14">14</a>]  Perrig, A., Canetti, R., Song, D., and J. Tygar, "Efficient and
         Secure Source Authentication for Multicast, Network and
         Distributed System Security Symposium, NDSS 2001, pp. 35-46.",
         February 2001.

   [<a id="ref-15" name="ref-15">15</a>]  Holbrook, H., "A Channel Model for Multicast, Ph.D.
         Dissertation, Stanford University, Department of Computer
         Science, Stanford, California", August 2001.

   [<a id="ref-16" name="ref-16">16</a>]  Deutsch, P., "DEFLATE Compressed Data Format Specification
         version 1.3", <a href="rfc1951.html">RFC 1951</a>, May 1996.

   [<a id="ref-17" name="ref-17">17</a>]  Deutsch, P., "GZIP file format specification version 4.3", <a href="rfc1952.html">RFC</a>
         <a href="rfc1952.html">1952</a>, May 1996.

   [<a id="ref-18" name="ref-18">18</a>]  Ramsdell, B., "Secure/Multipurpose Internet Mail Extensions
         (S/MIME) Version 3.1 Message Specification", <a href="rfc3851.html">RFC 3851</a>, July
         2004.

   [<a id="ref-19" name="ref-19">19</a>]  Eastlake, D., Reagle, J., and D. Solo, "(Extensible Markup
         Language) XML-Signature Syntax and Processing", <a href="rfc3275.html">RFC 3275</a>, March
         2002.

   [<a id="ref-20" name="ref-20">20</a>]  Freed, N., Klensin, J., and J. Postel, "Multipurpose Internet
         Mail Extensions (MIME) Part Four: Registration Procedures", <a href="rfc2048.html">RFC</a>
         <a href="rfc2048.html">2048</a>, November 1996.





<span class="grey">Paila, et al.                 Experimental                     [Page 30]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-31" id="page-31" name="page-31"> </a>
<span class="grey"><a href="rfc3926.html">RFC 3926</a>                         FLUTE                      October 2004</span>


   [<a id="ref-21" name="ref-21">21</a>]  Moore, K., "MIME (Multipurpose Internet Mail Extensions) Part
         Three: Message Header Extensions for Non-ASCII Text", <a href="rfc1521.html">RFC 1521</a>,
         November 1996.

   [<a id="ref-22" name="ref-22">22</a>]  Rosenberg, J., Schulzrinne, H., Camarillo, G., Johnston, A.,
         Peterson, J., Sparks, R., Handley, M., and E. Schooler, "SIP:
         session initiation protocol", <a href="rfc3261.html">RFC 3261</a>, June 2002.












































<span class="grey">Paila, et al.                 Experimental                     [Page 31]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-32" id="page-32" name="page-32"> </a>
<span class="grey"><a href="rfc3926.html">RFC 3926</a>                         FLUTE                      October 2004</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/Appendix%20A.%20%20Receiver%20operation%20%28informative%29"></a><a class="selflink" href="#appendix-A" name="appendix-A">Appendix A</a>.  Receiver operation (informative)</span>

   This section gives an example how the receiver of the file delivery
   session may operate.  Instead of a detailed state-by-state
   specification the following should be interpreted as a rough sequence
   of an envisioned file delivery receiver.

   1. The receiver obtains the description of the file delivery session
      identified by the pair: (source IP address,  Transport Session
      Identifier).  The receiver also obtains the destination IP
      addresses and respective ports associated with the file delivery
      session.

   2. The receiver joins the channels in order to receive packets
      associated with the file delivery session.  The receiver may
      schedule this join operation utilizing the timing information
      contained in a possible description of the file delivery session.

   3. The receiver receives ALC/LCT packets associated with the file
      delivery session.  The receiver checks that the packets match the
      declared Transport Session Identifier.  If not, packets are
      silently discarded.

   4. While receiving, the receiver demultiplexes packets based on their
      TOI and stores the relevant packet information in an appropriate
      area for recovery of the corresponding file.  Multiple files can
      be reconstructed concurrently.

   5. Receiver recovers an object.  An object can be recovered when an
      appropriate set of packets containing Encoding Symbols for the
      transport object have been received.  An appropriate set of
      packets is dependent on the properties of the FEC Encoding ID and
      FEC Instance ID, and on other information contained in the FEC
      Object Transmission Information.

   6. If the recovered object was an FDT Instance with FDT Instance ID
      'N', the receiver parses the payload of the instance 'N' of FDT
      and updates its FDT database accordingly.  The receiver identifies
      FDT Instances within a file delivery session by the EXT_FDT header
      extension.  Any object that is delivered using EXT_FDT header
      extension is an FDT Instance, uniquely identified by the FDT
      Instance ID.  Note that TOI '0' is exclusively reserved for FDT
      delivery.

   7. If the object recovered is not an FDT Instance but a file, the
      receiver looks up its FDT database to get the properties described
      in the database, and assigns file with the given properties.  The
      receiver also checks that received content length matches with the



<span class="grey">Paila, et al.                 Experimental                     [Page 32]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-33" id="page-33" name="page-33"> </a>
<span class="grey"><a href="rfc3926.html">RFC 3926</a>                         FLUTE                      October 2004</span>


      description in the database.  Optionally, if MD5 checksum has been
      used, the receiver checks that calculated MD5 matches with the
      description in the FDT database.

   8. The actions the receiver takes with imperfectly received files
      (missing data, mismatching digestive, etc.) is outside the scope
      of this specification.  When a file is recovered before the
      associated file description entry is available, a possible
      behavior is to wait until an FDT Instance is received that
      includes the missing properties.

   9. If the file delivery session end time has not been reached go back
      to 3.  Otherwise end.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/Appendix%20B.%20%20Example%20of%20FDT%20Instance%20%28informative%29"></a><a class="selflink" href="#appendix-B" name="appendix-B">Appendix B</a>.  Example of FDT Instance (informative)</span>

&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;FDT-Instance xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xmlns:fl="http://www.example.com/flute"
xsi:schemaLocation="http://www.example.com/flute-fdt.xsd"
Expires="2890842807"&gt;
        &lt;File
           Content-Location="http://www.example.com/menu/tracklist.html"
           TOI="1"
           Content-Type="text/html"/&gt;
        &lt;File
           Content-Location="http://www.example.com/tracks/track1.mp3"
           TOI="2"
           Content-Length="6100"
           Content-Type="audio/mp3"
           Content-Encoding="gzip"
           Content-MD5="+VP5IrWploFkZWc11iLDdA=="
           Some-Private-Extension-Tag="abc123"/&gt;
&lt;/FDT-Instance&gt;

















<span class="grey">Paila, et al.                 Experimental                     [Page 33]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-34" id="page-34" name="page-34"> </a>
<span class="grey"><a href="rfc3926.html">RFC 3926</a>                         FLUTE                      October 2004</span>


Authors' Addresses

   Toni Paila
   Nokia
   Itamerenkatu 11-13
   Helsinki  FIN-00180
   Finland

   EMail: toni.paila@nokia.com


   Michael Luby
   Digital Fountain
   39141 Civic Center Dr.
   Suite 300
   Fremont, CA  94538
   USA

   EMail: luby@digitalfountain.com


   Rami Lehtonen
   TeliaSonera
   Hatanpaan valtatie 18
   Tampere  FIN-33100
   Finland

   EMail: rami.lehtonen@teliasonera.com


   Vincent Roca
   INRIA Rhone-Alpes
   655, av. de l'Europe
   Montbonnot
   St Ismier cedex  38334
   France

   EMail: vincent.roca@inrialpes.fr


   Rod Walsh
   Nokia
   Visiokatu 1
   Tampere  FIN-33720
   Finland

   EMail: rod.walsh@nokia.com




<span class="grey">Paila, et al.                 Experimental                     [Page 34]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-35" id="page-35" name="page-35"> </a>
<span class="grey"><a href="rfc3926.html">RFC 3926</a>                         FLUTE                      October 2004</span>


Full Copyright Statement

   Copyright (C) The Internet Society (2004).

   This document is subject to the rights, licenses and restrictions
   contained in <a href="https://tools.ietf.org/html/bcp78">BCP 78</a>, and except as set forth therein, the authors
   retain all their rights.

   This document and the information contained herein are provided on an
   "AS IS" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/S HE
   REPRESENTS OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE
   INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR
   IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF
   THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED
   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.

Intellectual Property

   The IETF takes no position regarding the validity or scope of any
   Intellectual Property Rights or other rights that might be claimed to
   pertain to the implementation or use of the technology described in
   this document or the extent to which any license under such rights
   might or might not be available; nor does it represent that it has
   made any independent effort to identify any such rights.  Information
   on the IETF's procedures with respect to rights in IETF Documents can
   be found in <a href="https://tools.ietf.org/html/bcp78">BCP 78</a> and <a href="https://tools.ietf.org/html/bcp79">BCP 79</a>.

   Copies of IPR disclosures made to the IETF Secretariat and any
   assurances of licenses to be made available, or the result of an
   attempt made to obtain a general license or permission for the use of
   such proprietary rights by implementers or users of this
   specification can be obtained from the IETF on-line IPR repository at
   <a href="http://www.ietf.org/ipr">http://www.ietf.org/ipr</a>.

   The IETF invites any interested party to bring to its attention any
   copyrights, patents or patent applications, or other proprietary
   rights that may cover technology that may be required to implement
   this standard.  Please address the information to the IETF at ietf-
   ipr@ietf.org.

Acknowledgement

   Funding for the RFC Editor function is currently provided by the
   Internet Society.







Paila, et al.                 Experimental                     [Page 35]

</pre><br/>
    <span class="noprint"><small><small>Html markup produced by rfcmarkup 1.126, available from
      <a href="https://tools.ietf.org/tools/rfcmarkup/">https://tools.ietf.org/tools/rfcmarkup/</a>
    </small></small></span>
  </div>




</body><!-- Mirrored from tools.ietf.org/html/rfc3926 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 06 Mar 2018 23:18:44 GMT --></html>