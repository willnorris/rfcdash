<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml"><!-- Mirrored from tools.ietf.org/html/rfc1681 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 14 Aug 2018 14:27:55 GMT --><!-- Added by HTTrack --><head><meta content="text/html;charset=utf-8" http-equiv="content-type"/><!-- /Added by HTTrack -->

    <meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
    <meta content="index,follow" name="robots"/>
    <meta content="rfcmarkup version 1.127" name="creator"/>
    <link href="http://purl.org/dc/elements/1.1/" rel="schema.DC"/>
<meta content="urn:ietf:rfc:1681" name="DC.Identifier"/>
<meta content="This document was submitted to the IETF IPng area in response to RFC
1550.This memo provides information for the Internet community. This
memo does not specify an Internet standard of any kind." name="DC.Description.Abstract"/>
<meta content="S. Bellovin" name="DC.Creator"/>
<meta content="August, 1994" name="DC.Date.Issued"/>
<meta content="On Many Addresses per Host" name="DC.Title"/>

    <link href="https://tools.ietf.org/images/rfc.png" rel="icon" type="image/png"/>
    <link href="https://tools.ietf.org/images/rfc.png" rel="shortcut icon" type="image/png"/>
    <title>RFC 1681 - On Many Addresses per Host</title>
    
    
    <style type="text/css">
	@media only screen 
	  and (min-width: 992px)
	  and (max-width: 1199px) {
	    body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 768px)
	  and (max-width: 991px) {
            body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 480px)
	  and (max-width: 767px) {
            body { font-size: 11pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (max-width: 479px) {
            body { font-size: 8pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-device-width : 375px) 
	  and (max-device-width : 667px) {
            body { font-size: 9.5pt; }
            div.content { width: 96ex; margin: 0 1px; }
        }
	@media only screen 
	  and (min-device-width: 1200px) {
            body { font-size: 10pt; margin: 0 4em; }
            div.content { width: 96ex; margin: 0; }
        }
        h1, h2, h3, h4, h5, h6, .h1, .h2, .h3, .h4, .h5, .h6 {
	    font-weight: bold;
            line-height: 0pt;
            display: inline;
            white-space: pre;
            font-family: monospace;
            font-size: 1em;
	    font-weight: bold;
        }
        pre {
            font-size: 1em;
            margin-top: 0px;
            margin-bottom: 0px;
        }
	.pre {
	    white-space: pre;
	    font-family: monospace;
	}
	.header{
	    font-weight: bold;
	}
        .newpage {
            page-break-before: always;
        }
        .invisible {
            text-decoration: none;
            color: white;
        }
        a.selflink {
          color: black;
          text-decoration: none;
        }
        @media print {
            body {
                font-family: monospace;
                font-size: 10.5pt;
            }
            h1, h2, h3, h4, h5, h6 {
                font-size: 1em;
            }
        
            a:link, a:visited {
                color: inherit;
                text-decoration: none;
            }
            .noprint {
                display: none;
            }
        }
	@media screen {
	    .grey, .grey a:link, .grey a:visited {
		color: #777;
	    }
            .docinfo {
                background-color: #EEE;
            }
            .top {
                border-top: 7px solid #EEE;
            }
            .bgwhite  { background-color: white; }
            .bgred    { background-color: #F44; }
            .bggrey   { background-color: #666; }
            .bgbrown  { background-color: #840; }            
            .bgorange { background-color: #FA0; }
            .bgyellow { background-color: #EE0; }
            .bgmagenta{ background-color: #F4F; }
            .bgblue   { background-color: #66F; }
            .bgcyan   { background-color: #4DD; }
            .bggreen  { background-color: #4F4; }

            .legend   { font-size: 90%; }
            .cplate   { font-size: 70%; border: solid grey 1px; }
	}
    </style>
    <!--[if IE]>
    <style>
    body {
       font-size: 13px;
       margin: 10px 10px;
    }
    </style>
    <![endif]-->

    <script type="text/javascript"><!--
    function addHeaderTags() {
	var spans = document.getElementsByTagName("span");
	for (var i=0; i < spans.length; i++) {
	    var elem = spans[i];
	    if (elem) {
		var level = elem.getAttribute("class");
                if (level == "h1" || level == "h2" || level == "h3" || level == "h4" || level == "h5" || level == "h6") {
                    elem.innerHTML = "<"+level+">"+elem.innerHTML+"</"+level+">";		
                }
	    }
	}
    }
    var legend_html = "Colour legend:<br />      <table>         <tr><td>Unknown:</td>                   <td><span class='cplate bgwhite'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft:</td>                     <td><span class='cplate bgred'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Informational:</td>             <td><span class='cplate bgorange'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Experimental:</td>              <td><span class='cplate bgyellow'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Best Common Practice:</td>      <td><span class='cplate bgmagenta'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Proposed Standard:</td>         <td><span class='cplate bgblue'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft Standard (old designation):</td> <td><span class='cplate bgcyan'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Internet Standard:</td>         <td><span class='cplate bggreen'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Historic:</td>                  <td><span class='cplate bggrey'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Obsolete:</td>                  <td><span class='cplate bgbrown'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>     </table>";
    function showElem(id) {
        var elem = document.getElementById(id);
        elem.innerHTML = eval(id+"_html");
        elem.style.visibility='visible';
    }
    function hideElem(id) {
        var elem = document.getElementById(id);
        elem.style.visibility='hidden';        
        elem.innerHTML = "";
    }
    // -->
    </script>
</head>
<body onload="addHeaderTags()">
  <div class="content">
   <div style="height: 13px;">
      <div class="pre noprint docinfo bgorange" onclick="showElem('legend');" onmouseout="hideElem('legend')" onmouseover="this.style.cursor='pointer';" style="height: 6px; position: absolute;" title="Click for colour legend.">                                                                        </div>
      <div class="docinfo noprint pre legend" id="legend" onmouseout="hideElem('legend');" onmouseover="showElem('legend');" style="position:absolute; top: 4px; left: 4ex; visibility:hidden; background-color: white; padding: 4px 9px 5px 7px; border: solid #345 1px; ">
      </div>
   </div>
<span class="pre noprint docinfo top">[<a href="index.html" title="Document search and retrieval page">Docs</a>] [<a href="https://tools.ietf.org/rfc/rfc1681.txt" title="Plaintext version of this document">txt</a>|<a href="https://tools.ietf.org/pdf/rfc1681" title="PDF version of this document">pdf</a>] [<a href="https://tools.ietf.org/html/draft-bellovin-ipng-addr-per-host" title="draft-bellovin-ipng-addr-per-host">draft-bellovin-...</a>] [<a href="https://datatracker.ietf.org/doc/rfc1681" title="IESG Datatracker information for this document">Tracker</a>] [<a href="https://tools.ietf.org/rfcdiff?difftype=--hwdiff&amp;url2=rfc1681" title="Inline diff (wdiff)">Diff1</a>] [<a href="https://tools.ietf.org/rfcdiff?url2=rfc1681" title="Side-by-side diff">Diff2</a>]         </span><br/>
<span class="pre noprint docinfo">                                                                        </span><br/>
<span class="pre noprint docinfo">                                                           INFORMATIONAL</span><br/>
<span class="pre noprint docinfo">                                                                        </span><br/>
<pre>Network Working Group                                        S. Bellovin
Request for Comments: 1681                        AT&amp;T Bell Laboratories
Category: Informational                                      August 1994


                       <span class="h1">On Many Addresses per Host</span>

Status of this Memo

   This memo provides information for the Internet community.  This memo
   does not specify an Internet standard of any kind.  Distribution of
   this memo is unlimited.

Abstract

   This document was submitted to the IETF IPng area in response to <a href="rfc1550.html">RFC</a>
   <a href="rfc1550.html">1550</a>.  Publication of this document does not imply acceptance by the
   IPng area of any ideas expressed within.  Comments should be
   submitted to the big-internet@munnari.oz.au mailing list.

Overview and Rational

   Currently, most hosts have only one address.  With comparatively rare
   exceptions, hosts as hosts -- as opposed to hosts acting as routers
   or PPP servers -- are single-homed.  Our address space calculations
   reflect this; we are assuming that we can estimate the size of the
   address space by counting hosts.  But this may be a serious error.  I
   suggest that that model may -- and should -- change.

   For the ideas outlined below, I do not claim that multiple addresses
   per host is the only or even necessarily the best way to accomplish
   the goal.  I do claim that my ideas are at the very least plausible,
   and that I expect that many of them will be tried.

Encoding Services

   More and more often, services are being encoded in the host name.
   One can fetch files from ftp.research.att.com, look up an IP address
   on ns.uu.net, synchronize clocks from ntp.udel.edu, etc.  Should this
   practice be generalized to the IP address domain?

   In some cases it would be a very good idea.  Certain services need to
   be configured by IP address; they are either used when the DNS is
   being bootstrapped (such as in glue records and root server cache
   records), or when its unavailable (i.e., when booting after a power
   hit, and the local name servers are slower to reboot than their
   diskless clients.




<span class="grey">Bellovin                                                        [Page 1]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-2" id="page-2" name="page-2"> </a>
<span class="grey"><a href="rfc1681.html">RFC 1681</a>               On Many Addresses per Host            August 1994</span>


   Security is another reason, in some cases.  Address-based
   authentication is bad enough; relying on the name service adds
   another layer of risk.  An attacker can go after the DNS, in that
   case.  A risk-averse system manager might prefer to avoid the extra
   exposure, instead granting privileges (i.e., rlogin or NFS) by
   address instead of name.  But that, of course, leads to all the usual
   headaches when the location of the service changes.  If the address
   for the service could be held constant, there would be much more
   freedom to move it to another machine.  One way to do that is by
   assigning the serving host a secondary address.

   A related notion comes from the need to offer different views of a
   service from a single host.  For example, research.att.com has long
   offered two distinct FTP archives, with slightly different access
   policies.  It would be nice if both could live on the same machine,
   without asking the user community to learn new protocols or custom
   port numbers.

   Archie is an even better example.  There are three principal ways to
   use Archie:  use a special protocol, and hence a special application
   program, on a dedicated port and host that is probably named
   archie.foo.bar; telnet to archie.foo.bar and go through an extra and
   gratuitous login as archie, or telnet to some special port on
   archie.foo.bar.  The latter two are examples of using a standard
   protocol (telnet) to offer a different service.  Neither alternative
   is very convenient.

   It would be better if archie.foo.bar provided the Archie service,
   while host.foo.bar provided a login prompt.  Again -- an easy way to
   do this is to assign the host a separate IP address for its extra
   service.

   Note that there are security advantages here, too.  A firewall could
   be configured to allow access to the address associated with the
   Archie server, but not the other addresses on that host.  That would
   provide a high degree of safety, assuming, of course, that the other
   servers on that host were bound to its primary addresses, and not the
   exposed address.

   Another way to implement this concept would be to extend the DNS, to
   return port number information as well as IP addresses.  Thus,
   netlib.att.com might return 192.20.225.3/221.  But that would
   necessitate changing every FTP client program, a daunting task.

   We could also look on this as the extension of the MX concept.  MX
   records are very valuable, but they apply only to mail, and they
   don't supply port numbers.  Again, changing this would require
   massive client program changes.



<span class="grey">Bellovin                                                        [Page 2]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-3" id="page-3" name="page-3"> </a>
<span class="grey"><a href="rfc1681.html">RFC 1681</a>               On Many Addresses per Host            August 1994</span>


Accounting and Billing

   For better or worse, some parts of the Internet are moving towards
   usage-sensitive charging.  At least four charging schemes seem
   possible; doubtless, the marketeers in charge of such things can and
   will come up with more.

   The first is the traditional "pay as you go" approach.  Each host is
   responsible for its own packets.  Of course, that means that in a
   typical conversation, both parties pay -- and the providers of free
   FTP archives will end up paying dearly for their beneficence.  That
   leads to our second model:  caller pays.  Other people might want to
   make collect calls, much as is done on the telephone today.  Finally,
   there might be the equivalent of American "900" numbers:  the caller
   pays a premium to the server.

   This is not at all far-fetched; UUNET already has a 900 number for
   anonymous uucp clients.  No need to register in advance; just dial
   in, and let the phone company act as your agent.

   Given all these schemes, it is vital that the caller and recipient
   know in advance who will pay.  It is not acceptable for users to
   learn, only after the fact, that they have incurred a cost.  We could
   envision use of IP options, but again, that would preclude use of
   today's standard clients.

   It is not sufficient to present a message at connection time warning
   of the charges.  Many interactions do not provide a hook for user
   interaction.  And there are security concerns -- suppose that someone
   puts up a gopher server that redirects a caller to some pay-to-play
   address, without displaying the required warning.  A scam?  Sure --
   but it's already happened with the phone network, and I see no reason
   to think that the Internet will be far behind.

   My suggestion, of course, is to encode the charge algorithm in the
   destination address (and perhaps in the DNS name space as well).  The
   bits themselves would determine who pays.  Organizational border
   routers could implement policies on pay services; the anonymous
   workstations in a dorm computer lab wouldn't be allowed to call
   collect.

   An extension of this scheme would use a comparatively large number of
   bits, letting the address act not just as a policy indicator, but
   also as an index to a charge algorithm table.







<span class="grey">Bellovin                                                        [Page 3]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-4" id="page-4" name="page-4"> </a>
<span class="grey"><a href="rfc1681.html">RFC 1681</a>               On Many Addresses per Host            August 1994</span>


Addresses per User

   It may be useful to assign each user on a host a separate IP address,
   for the duration of the login session.  This has a number of
   advantages.

   The first ties in with the charging scheme given above.  Usage-
   sensitive accounting today is done by routers, and they have no
   notion of who is using the hosts.  If each user had a separate IP
   address, we could continue to gather the accounting data at the
   router.  The host would simply have to record the address
   assignments; billing could be done offline.

   Similarly, different classes of users could have different forms of
   addresses.  Those with hard-money accounts might have some bits set
   in the address that would allow for access to costly services.  The
   border routers could make this sort of distinction, using today's
   technology.

   An IP address per user also fits in well with encryption.  There is a
   lot of attention today focused on network-layer encryption.  But that
   provides host-level granularity of protection, which is sometimes
   insufficient.  Transport-layer encryptors provide finer-grained
   protection, but does the Internet need two different low-level
   encryption schemes?  If each user had a separate IP address -- and
   perhaps had it only on hosts that cared about such matters -- we
   could provide user-level protection and accounability, with the same
   infrastructure used to support host-level accountability.

Low-Grade Mobility

   There are several schemes under discussion for mobile IP hosts.
   These are aimed at a fairly general model of hosts moving anywhere.
   While that is important, there is also some need for limited
   mobility, within a subnet.  This could be used for load-balancing.  A
   mail relay that had just been asked to send a large message to a huge
   mailing list could offload some of its IP addresses to its peers.
   That would divert future incoming messages without invalidating
   thousands of cached MX records and their associated IP addresses.
   Similarly, servers for low-speed X terminals could reside on
   different physical machines, all the while not disturbing sessions in
   progress.

Merging Subnets

   There has long been some need to merge subnets.  Sometimes this is
   due to organizational changes; other times, people have installed
   bridges when routers would have been a more appropriate choice.  Some



<span class="grey">Bellovin                                                        [Page 4]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-5" id="page-5" name="page-5"> </a>
<span class="grey"><a href="rfc1681.html">RFC 1681</a>               On Many Addresses per Host            August 1994</span>


   hosts need to live on both logical networks at once, to avoid an
   extra hop through a router.  It would be useful to be able to assign
   them such addresses.

How Many Addresses Do We Need?

   Assuming that some of these ideas bear fruit, how many addresses do
   we need, per host?

   Most of these schemes are fairly cheap.  Few people would offer more
   than a handful of distinct service views per system.  But the
   address-per-user notion could be quite costly.  We also have to
   account for address mask assignment policies.  In many of today's
   networks, enough bits of host address have to be allocated to allow
   for the largest subnet in an organization.  Even if we assume that
   IPng's routing protocols will be smarter about such things, foresight
   in address allocation will be needed to allow headroom for some
   networks to grow, while still maintaining a contiguous netmask.  This
   in turn will contribute to sparse utilization of the address space.
   Accordingly, I recommend that we allow for 2^6, and perhaps as many
   as 2^8, extra addresses per host, to leave room for the ideas
   presented here.

   I should note that the idea of encoding the service in the transport
   address bears some relation to OSI's model.  That similarity should
   not, of course, invalidate the idea.

Acknowledgements

   Some of these ideas were derived from conversations with Matt Blaze.

Security Considerations

   Security issues are discussed throughout this memo.

Author's Address

   Steven M. Bellovin
   Software Engineering Research Department
   AT&amp;T Bell Laboratories
   600 Mountain Avenue
   Murray Hill, NJ  07974, USA

   Phone: +1 908-582-5886
   Fax: +1 908-582-3063
   EMail:  smb@research.att.com





Bellovin                                                        [Page 5]

</pre><br/>
    <span class="noprint"><small><small>Html markup produced by rfcmarkup 1.127, available from
      <a href="https://tools.ietf.org/tools/rfcmarkup/">https://tools.ietf.org/tools/rfcmarkup/</a>
    </small></small></span>
  </div>




</body><!-- Mirrored from tools.ietf.org/html/rfc1681 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 14 Aug 2018 14:27:55 GMT --></html>