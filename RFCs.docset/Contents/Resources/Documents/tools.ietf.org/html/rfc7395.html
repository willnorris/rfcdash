<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml"><!-- Mirrored from tools.ietf.org/html/rfc7395 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 06 Mar 2018 23:18:22 GMT --><!-- Added by HTTrack --><head><meta content="text/html;charset=utf-8" http-equiv="content-type"/><!-- /Added by HTTrack -->

    <meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
    <meta content="index,follow" name="robots"/>
    <meta content="rfcmarkup version 1.126" name="creator"/>
    <link href="http://purl.org/dc/elements/1.1/" rel="schema.DC"/>
<meta content="draft-moffitt-xmpp-over-websocket" name="DC.Relation.Replaces"/>
<meta content="urn:ietf:rfc:7395" name="DC.Identifier"/>
<meta content="October, 2014" name="DC.Date.Issued"/>
<meta content="Cestari, Eric" name="DC.Creator"/>
<meta content="Stout, Lance" name="DC.Creator"/>
<meta content="Moffitt, Jack" name="DC.Creator"/>
<meta content="This document defines a binding for the Extensible Messaging and
Presence Protocol (XMPP) over a WebSocket transport layer. A WebSocket
binding for XMPP provides higher performance than the current HTTP
binding for XMPP." name="DC.Description.Abstract"/>
<meta content="An Extensible Messaging and Presence Protocol (XMPP) Subprotocol for WebSocket" name="DC.Title"/>

    <link href="https://tools.ietf.org/images/rfc.png" rel="icon" type="image/png"/>
    <link href="https://tools.ietf.org/images/rfc.png" rel="shortcut icon" type="image/png"/>
    <title>RFC 7395 - An Extensible Messaging and Presence Protocol (XMPP) Subprotocol for WebSocket</title>
    
    
    <style type="text/css">
	@media only screen 
	  and (min-width: 992px)
	  and (max-width: 1199px) {
	    body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 768px)
	  and (max-width: 991px) {
            body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 480px)
	  and (max-width: 767px) {
            body { font-size: 11pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (max-width: 479px) {
            body { font-size: 8pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-device-width : 375px) 
	  and (max-device-width : 667px) {
            body { font-size: 9.5pt; }
            div.content { width: 96ex; margin: 0 1px; }
        }
	@media only screen 
	  and (min-device-width: 1200px) {
            body { font-size: 10pt; margin: 0 4em; }
            div.content { width: 96ex; margin: 0; }
        }
        h1, h2, h3, h4, h5, h6, .h1, .h2, .h3, .h4, .h5, .h6 {
	    font-weight: bold;
            line-height: 0pt;
            display: inline;
            white-space: pre;
            font-family: monospace;
            font-size: 1em;
	    font-weight: bold;
        }
        pre {
            font-size: 1em;
            margin-top: 0px;
            margin-bottom: 0px;
        }
	.pre {
	    white-space: pre;
	    font-family: monospace;
	}
	.header{
	    font-weight: bold;
	}
        .newpage {
            page-break-before: always;
        }
        .invisible {
            text-decoration: none;
            color: white;
        }
        a.selflink {
          color: black;
          text-decoration: none;
        }
        @media print {
            body {
                font-family: monospace;
                font-size: 10.5pt;
            }
            h1, h2, h3, h4, h5, h6 {
                font-size: 1em;
            }
        
            a:link, a:visited {
                color: inherit;
                text-decoration: none;
            }
            .noprint {
                display: none;
            }
        }
	@media screen {
	    .grey, .grey a:link, .grey a:visited {
		color: #777;
	    }
            .docinfo {
                background-color: #EEE;
            }
            .top {
                border-top: 7px solid #EEE;
            }
            .bgwhite  { background-color: white; }
            .bgred    { background-color: #F44; }
            .bggrey   { background-color: #666; }
            .bgbrown  { background-color: #840; }            
            .bgorange { background-color: #FA0; }
            .bgyellow { background-color: #EE0; }
            .bgmagenta{ background-color: #F4F; }
            .bgblue   { background-color: #66F; }
            .bgcyan   { background-color: #4DD; }
            .bggreen  { background-color: #4F4; }

            .legend   { font-size: 90%; }
            .cplate   { font-size: 70%; border: solid grey 1px; }
	}
    </style>
    <!--[if IE]>
    <style>
    body {
       font-size: 13px;
       margin: 10px 10px;
    }
    </style>
    <![endif]-->

    <script type="text/javascript"><!--
    function addHeaderTags() {
	var spans = document.getElementsByTagName("span");
	for (var i=0; i < spans.length; i++) {
	    var elem = spans[i];
	    if (elem) {
		var level = elem.getAttribute("class");
                if (level == "h1" || level == "h2" || level == "h3" || level == "h4" || level == "h5" || level == "h6") {
                    elem.innerHTML = "<"+level+">"+elem.innerHTML+"</"+level+">";		
                }
	    }
	}
    }
    var legend_html = "Colour legend:<br />      <table>         <tr><td>Unknown:</td>                   <td><span class='cplate bgwhite'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft:</td>                     <td><span class='cplate bgred'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Informational:</td>             <td><span class='cplate bgorange'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Experimental:</td>              <td><span class='cplate bgyellow'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Best Common Practice:</td>      <td><span class='cplate bgmagenta'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Proposed Standard:</td>         <td><span class='cplate bgblue'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft Standard (old designation):</td> <td><span class='cplate bgcyan'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Internet Standard:</td>         <td><span class='cplate bggreen'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Historic:</td>                  <td><span class='cplate bggrey'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Obsolete:</td>                  <td><span class='cplate bgbrown'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>     </table>";
    function showElem(id) {
        var elem = document.getElementById(id);
        elem.innerHTML = eval(id+"_html");
        elem.style.visibility='visible';
    }
    function hideElem(id) {
        var elem = document.getElementById(id);
        elem.style.visibility='hidden';        
        elem.innerHTML = "";
    }
    // -->
    </script>
</head>
<body onload="addHeaderTags()">
  <div class="content">
   <div style="height: 13px;">
      <div class="pre noprint docinfo bgblue" onclick="showElem('legend');" onmouseout="hideElem('legend')" onmouseover="this.style.cursor='pointer';" style="height: 6px; position: absolute;" title="Click for colour legend.">                                                                        </div>
      <div class="docinfo noprint pre legend" id="legend" onmouseout="hideElem('legend');" onmouseover="showElem('legend');" style="position:absolute; top: 4px; left: 4ex; visibility:hidden; background-color: white; padding: 4px 9px 5px 7px; border: solid #345 1px; ">
      </div>
   </div>
<span class="pre noprint docinfo top">[<a href="index.html" title="Document search and retrieval page">Docs</a>] [<a href="https://tools.ietf.org/rfc/rfc7395.txt" title="Plaintext version of this document">txt</a>|<a href="https://tools.ietf.org/pdf/rfc7395" title="PDF version of this document">pdf</a>] [<a href="https://tools.ietf.org/html/draft-ietf-xmpp-websocket" title="draft-ietf-xmpp-websocket">draft-ietf-xmpp...</a>] [<a href="https://datatracker.ietf.org/doc/rfc7395" title="IESG Datatracker information for this document">Tracker</a>] [<a href="https://tools.ietf.org/rfcdiff?difftype=--hwdiff&amp;url2=rfc7395" title="Inline diff (wdiff)">Diff1</a>] [<a href="https://tools.ietf.org/rfcdiff?url2=rfc7395" title="Side-by-side diff">Diff2</a>]         </span><br/>
<span class="pre noprint docinfo">                                                                        </span><br/>
<span class="pre noprint docinfo">                                                       PROPOSED STANDARD</span><br/>
<span class="pre noprint docinfo">                                                                        </span><br/>
<pre>Internet Engineering Task Force (IETF)                     L. Stout, Ed.
Request for Comments: 7395                                          &amp;yet
Category: Standards Track                                     J. Moffitt
ISSN: 2070-1721                                                  Mozilla
                                                              E. Cestari
                                                        cstar industries
                                                            October 2014


  <span class="h1">An Extensible Messaging and Presence Protocol (XMPP) Subprotocol for</span>
                               <span class="h1">WebSocket</span>

Abstract

   This document defines a binding for the Extensible Messaging and
   Presence Protocol (XMPP) over a WebSocket transport layer.  A
   WebSocket binding for XMPP provides higher performance than the
   current HTTP binding for XMPP.

Status of This Memo

   This is an Internet Standards Track document.

   This document is a product of the Internet Engineering Task Force
   (IETF).  It represents the consensus of the IETF community.  It has
   received public review and has been approved for publication by the
   Internet Engineering Steering Group (IESG).  Further information on
   Internet Standards is available in <a href="rfc5741.html#section-2">Section 2 of RFC 5741</a>.

   Information about the current status of this document, any errata,
   and how to provide feedback on it may be obtained at
   <a href="http://www.rfc-editor.org/info/rfc7395">http://www.rfc-editor.org/info/rfc7395</a>.

Copyright Notice

   Copyright (c) 2014 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to <a href="https://tools.ietf.org/html/bcp78">BCP 78</a> and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (<a href="http://trustee.ietf.org/license-info">http://trustee.ietf.org/license-info</a>) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.




<span class="grey">Stout, et al.                Standards Track                    [Page 1]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-2" id="page-2" name="page-2"> </a>
<span class="grey"><a href="rfc7395.html">RFC 7395</a>                   XMPP over WebSocket              October 2014</span>


Table of Contents

   <a href="#section-1">1</a>. Introduction ....................................................<a href="#page-2">2</a>
   <a href="#section-2">2</a>. Terminology .....................................................<a href="#page-3">3</a>
   <a href="#section-3">3</a>. XMPP Subprotocol ................................................<a href="#page-3">3</a>
      <a href="#section-3.1">3.1</a>. Handshake ..................................................<a href="#page-3">3</a>
      <a href="#section-3.2">3.2</a>. WebSocket Messages .........................................<a href="#page-4">4</a>
      <a href="#section-3.3">3.3</a>. XMPP Framing ...............................................<a href="#page-5">5</a>
           <a href="#section-3.3.1">3.3.1</a>. Framed XML Stream ...................................<a href="#page-5">5</a>
           <a href="#section-3.3.2">3.3.2</a>. Framed Stream Namespace .............................<a href="#page-5">5</a>
           <a href="#section-3.3.3">3.3.3</a>. Stream Frames .......................................<a href="#page-5">5</a>
      <a href="#section-3.4">3.4</a>. Stream Initiation ..........................................<a href="#page-6">6</a>
      <a href="#section-3.5">3.5</a>. Stream Errors ..............................................<a href="#page-7">7</a>
      <a href="#section-3.6">3.6</a>. Closing the Connection .....................................<a href="#page-7">7</a>
           <a href="#section-3.6.1">3.6.1</a>. see-other-uri .......................................<a href="#page-8">8</a>
      <a href="#section-3.7">3.7</a>. Stream Restarts ............................................<a href="#page-9">9</a>
      <a href="#section-3.8">3.8</a>. Pings and Keepalives .......................................<a href="#page-9">9</a>
      <a href="#section-3.9">3.9</a>. Use of TLS .................................................<a href="#page-9">9</a>
      <a href="#section-3.10">3.10</a>. Stream Management ........................................<a href="#page-10">10</a>
   <a href="#section-4">4</a>. Discovering the WebSocket Connection Method ....................<a href="#page-10">10</a>
   <a href="#section-5">5</a>. IANA Considerations ............................................<a href="#page-11">11</a>
      <a href="#section-5.1">5.1</a>. WebSocket Subprotocol Name ................................<a href="#page-11">11</a>
      <a href="#section-5.2">5.2</a>. URN Sub-namespace .........................................<a href="#page-11">11</a>
   <a href="#section-6">6</a>. Security Considerations ........................................<a href="#page-12">12</a>
   <a href="#section-7">7</a>. References .....................................................<a href="#page-14">14</a>
      <a href="#section-7.1">7.1</a>. Normative References ......................................<a href="#page-14">14</a>
      <a href="#section-7.2">7.2</a>. Informative References ....................................<a href="#page-14">14</a>
   <a href="#appendix-A">Appendix A</a>. XML Schema ............................................<a href="#page-16">16</a>
   Acknowledgements ..................................................<a href="#page-17">17</a>
   Authors' Addresses ................................................<a href="#page-18">18</a>

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/1.%20%20Introduction"></a><a class="selflink" href="#section-1" name="section-1">1</a>.  Introduction</span>

   To date, applications using the Extensible Messaging and Presence
   Protocol (XMPP) (see [<a href="rfc6120.html" title='"Extensible Messaging and Presence Protocol (XMPP): Core"'>RFC6120</a>] and [<a href="rfc6121.html" title='"Extensible Messaging and Presence Protocol (XMPP): Instant Messaging and Presence"'>RFC6121</a>]) on the Web have made
   use of Bidirectional-streams Over Synchronous HTTP (BOSH) (see
   [<a href="#ref-XEP-0124" title='"Bidirectional-streams Over Synchronous HTTP (BOSH)"'>XEP-0124</a>] and [<a href="#ref-XEP-0206" title='"XMPP Over BOSH"'>XEP-0206</a>]), an XMPP binding to HTTP.  BOSH is based
   on the HTTP "long polling" technique, and it suffers from high
   transport overhead compared to XMPP's native binding to TCP.  In
   addition, there are a number of other known issues with long polling
   [<a href="rfc6202.html" title='"Known Issues and Best Practices for the Use of Long Polling and Streaming in Bidirectional HTTP"'>RFC6202</a>] that have an impact on BOSH-based systems.

   In most circumstances, it would be much better to avoid tunneling
   XMPP over HTTP long-polled connections and instead use XMPP directly.
   However, the APIs and sandbox that browsers have provided do not
   allow this.  The WebSocket protocol [<a href="rfc6455.html" title='"The WebSocket Protocol"'>RFC6455</a>] exists to solve these





<span class="grey">Stout, et al.                Standards Track                    [Page 2]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-3" id="page-3" name="page-3"> </a>
<span class="grey"><a href="rfc7395.html">RFC 7395</a>                   XMPP over WebSocket              October 2014</span>


   kinds of problems and is a bidirectional protocol that provides a
   simple message-based framing layer, allowing for more robust and
   efficient communication in web applications.

   The WebSocket protocol enables two-way communication between a client
   and a server, effectively emulating TCP at the application layer and,
   therefore, overcoming many of the problems with existing long-polling
   techniques for bidirectional HTTP.  This document defines a WebSocket
   subprotocol for XMPP.

   The WebSocket binding for XMPP is designed for use by browser-based
   applications (e.g., XMPP clients written in JavaScript).  Typically,
   these applications are used to access the same information and
   communication opportunities (e.g., the same XMPP "roster" of
   contacts) as clients that connect to an XMPP server over the TCP
   binding defined in [<a href="rfc6120.html" title='"Extensible Messaging and Presence Protocol (XMPP): Core"'>RFC6120</a>].  Although the only essential difference
   is the underlying transport binding, relevant implications (e.g.,
   framing methods and discovery processes) are highlighted in this
   specification.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/2.%20%20Terminology"></a><a class="selflink" href="#section-2" name="section-2">2</a>.  Terminology</span>

   The basic unit of framing in the WebSocket protocol is called a
   "message".  In XMPP, the basic unit is the stanza, which is a subset
   of the first-level children of each document in an XMPP stream (see
   <a href="rfc6120.html#section-9">Section 9 of [RFC6120]</a>).  XMPP also has a concept of messages, which
   are stanzas with a top-level element of &lt;message/&gt;.  In this
   document, the word "message" will mean a WebSocket message, not an
   XMPP message stanza (unless otherwise noted).

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
   "OPTIONAL" in this document are to be interpreted as described in
   [<a href="rfc2119.html" title='"Key words for use in RFCs to Indicate Requirement Levels"'>RFC2119</a>].

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/3.%20%20XMPP%20Subprotocol"></a><a class="selflink" href="#section-3" name="section-3">3</a>.  XMPP Subprotocol</span>

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.1.%20%20Handshake"></a><a class="selflink" href="#section-3.1" name="section-3.1">3.1</a>.  Handshake</span>

   The XMPP subprotocol is used to transport XMPP over a WebSocket
   connection.  The client and server agree to this protocol during the
   WebSocket handshake (see <a href="rfc6455.html#section-1.3">Section 1.3 of [RFC6455]</a>).

   During the WebSocket handshake, the client MUST include the value
   'xmpp' in the list of protocols for the 'Sec-WebSocket-Protocol'
   header.  The reply from the server MUST also contain 'xmpp' in its
   own 'Sec-WebSocket-Protocol' header in order for an XMPP subprotocol
   connection to be established.



<span class="grey">Stout, et al.                Standards Track                    [Page 3]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-4" id="page-4" name="page-4"> </a>
<span class="grey"><a href="rfc7395.html">RFC 7395</a>                   XMPP over WebSocket              October 2014</span>


   If a client receives a handshake response that does not include
   'xmpp' in the 'Sec-WebSocket-Protocol' header, then an XMPP
   subprotocol WebSocket connection was not established and the client
   MUST close the WebSocket connection.

   Once the handshake has successfully completed, WebSocket messages
   sent or received MUST conform to the protocol defined in the rest of
   this document.

   The following is an example of a WebSocket handshake, followed by
   opening an XMPP stream:

   C:  GET /xmpp-websocket HTTP/1.1
       Host: example.com
       Upgrade: websocket
       Connection: Upgrade
       Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
       Origin: http://example.com
       ...
       Sec-WebSocket-Protocol: xmpp
       Sec-WebSocket-Version: 13

   S:  HTTP/1.1 101 Switching Protocols
       Upgrade: websocket
       Connection: Upgrade
       ...
       Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=
       Sec-WebSocket-Protocol: xmpp

   [WebSocket connection established]

   C:  &lt;open xmlns="urn:ietf:params:xml:ns:xmpp-framing"
             to="example.com"
             version="1.0" /&gt;

   S:  &lt;open xmlns="urn:ietf:params:xml:ns:xmpp-framing"
             from="example.com"
             id="++TR84Sm6A3hnt3Q065SnAbbk3Y="
             xml:lang="en"
             version="1.0" /&gt;

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.2.%20%20WebSocket%20Messages"></a><a class="selflink" href="#section-3.2" name="section-3.2">3.2</a>.  WebSocket Messages</span>

   Data frame messages in the XMPP subprotocol MUST be of the text type
   and contain UTF-8 encoded data.






<span class="grey">Stout, et al.                Standards Track                    [Page 4]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-5" id="page-5" name="page-5"> </a>
<span class="grey"><a href="rfc7395.html">RFC 7395</a>                   XMPP over WebSocket              October 2014</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.3.%20%20XMPP%20Framing"></a><a class="selflink" href="#section-3.3" name="section-3.3">3.3</a>.  XMPP Framing</span>

   The framing method for the binding of XMPP to WebSocket differs from
   the framing method for the TCP binding as defined in [<a href="rfc6120.html" title='"Extensible Messaging and Presence Protocol (XMPP): Core"'>RFC6120</a>]; in
   particular, the WebSocket binding adopts the message framing provided
   by WebSocket to delineate the stream open and close headers, stanzas,
   and other top-level stream elements.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/3.3.1.%20%20Framed%20XML%20Stream"></a><a class="selflink" href="#section-3.3.1" name="section-3.3.1">3.3.1</a>.  Framed XML Stream</span>

   The start of a framed XML stream is marked by the use of an opening
   "stream header", which is an &lt;open/&gt; element with the appropriate
   attributes and namespace declarations (see <a href="#section-3.3.2">Section 3.3.2</a>).  The
   attributes of the &lt;open/&gt; element are the same as those of the
   &lt;stream/&gt; element defined for the 'http://etherx.jabber.org/streams'
   namespace [<a href="rfc6120.html" title='"Extensible Messaging and Presence Protocol (XMPP): Core"'>RFC6120</a>] and with the same semantics and restrictions.

   The end of a framed XML stream is denoted by the closing "stream
   header", which is a &lt;close/&gt; element with its associated attributes
   and namespace declarations (see <a href="#section-3.3.2">Section 3.3.2</a>).

   The introduction of the &lt;open/&gt; and &lt;close/&gt; elements is motivated by
   the parsable XML document framing restriction in <a href="#section-3.3.3">Section 3.3.3</a>.  As a
   consequence, note that a framed XML stream does not provide a
   wrapping &lt;stream:stream/&gt; [<a href="rfc6120.html" title='"Extensible Messaging and Presence Protocol (XMPP): Core"'>RFC6120</a>] element encompassing the entirety
   of the XML stream.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/3.3.2.%20%20Framed%20Stream%20Namespace"></a><a class="selflink" href="#section-3.3.2" name="section-3.3.2">3.3.2</a>.  Framed Stream Namespace</span>

   The XML stream headers (the &lt;open/&gt; and &lt;close/&gt; elements) MUST be
   qualified by the namespace 'urn:ietf:params:xml:ns:xmpp-framing' (the
   "framed stream namespace").  If this rule is violated, the entity
   that receives the offending stream header MUST close the stream with
   an error, which MUST be &lt;invalid-namespace&gt; (see <a href="rfc6120.html#section-4.9.3.10">Section 4.9.3.10 of
   [RFC6120]</a>).

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/3.3.3.%20%20Stream%20Frames"></a><a class="selflink" href="#section-3.3.3" name="section-3.3.3">3.3.3</a>.  Stream Frames</span>

   The individual frames of a framed XML stream have a one-to-one
   correspondence with WebSocket messages and MUST be parsable as
   standalone XML documents, complete with all relevant namespace and
   language declarations.  The inclusion of XML declarations, however,
   is NOT RECOMMENDED, as WebSocket messages are already mandated to be
   UTF-8 encoded.  Including declarations in each message would only
   increase the framing overhead of each message.

   The first character of each frame MUST be a '&lt;' character.




<span class="grey">Stout, et al.                Standards Track                    [Page 5]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-6" id="page-6" name="page-6"> </a>
<span class="grey"><a href="rfc7395.html">RFC 7395</a>                   XMPP over WebSocket              October 2014</span>


   Every XMPP stanza or other XML element (including the stream open and
   close headers) sent directly over the XML stream MUST be sent in its
   own frame.

   Example of a WebSocket message that contains an independently
   parsable XML document:

   &lt;message xmlns="jabber:client" xml:lang="en"&gt;
     &lt;body&gt;Every WebSocket message is parsable by itself.&lt;/body&gt;
   &lt;/message&gt;

   Note that for stream features and errors, there is no parent context
   element providing the "stream" namespace prefix as in [<a href="rfc6120.html" title='"Extensible Messaging and Presence Protocol (XMPP): Core"'>RFC6120</a>], and
   thus the stream prefix MUST be declared or use an unprefixed form:

   &lt;stream:features xmlns:stream="http://etherx.jabber.org/streams"&gt;
     &lt;bind xmlns="urn:ietf:params:xml:ns:xmpp-bind"/&gt;
   &lt;/stream:features&gt;

   -- OR --

   &lt;error xmlns="http://etherx.jabber.org/streams"&gt;
     &lt;host-unknown xmlns='urn:ietf:params:xml:ns:xmpp-streams'/&gt;
   &lt;/error&gt;

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.4.%20%20Stream%20Initiation"></a><a class="selflink" href="#section-3.4" name="section-3.4">3.4</a>.  Stream Initiation</span>

   The first message sent after the WebSocket opening handshake MUST be
   from the initiating entity and MUST be an &lt;open/&gt; element qualified
   by the 'urn:ietf:params:xml:ns:xmpp-framing' namespace and with the
   same attributes mandated for the &lt;stream&gt; opening tag as described in
   <a href="rfc6120.html#section-4.7">Section 4.7 of [RFC6120]</a>.

   The receiving entity MUST respond with either an &lt;open/&gt; element
   (whose attributes match those described in <a href="rfc6120.html#section-4.7">Section 4.7 of [RFC6120]</a>)
   or a &lt;close/&gt; element (see <a href="#section-3.6.1">Section 3.6.1</a>).















<span class="grey">Stout, et al.                Standards Track                    [Page 6]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-7" id="page-7" name="page-7"> </a>
<span class="grey"><a href="rfc7395.html">RFC 7395</a>                   XMPP over WebSocket              October 2014</span>


   An example of a successful stream initiation exchange:

   C:  &lt;open xmlns="urn:ietf:params:xml:ns:xmpp-framing"
             to="example.com"
             version="1.0" /&gt;

   S:  &lt;open xmlns="urn:ietf:params:xml:ns:xmpp-framing"
             from="example.com"
             id="++TR84Sm6A3hnt3Q065SnAbbk3Y="
             xml:lang="en"
             version="1.0" /&gt;

   Clients MUST NOT multiplex XMPP streams over the same WebSocket.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.5.%20%20Stream%20Errors"></a><a class="selflink" href="#section-3.5" name="section-3.5">3.5</a>.  Stream Errors</span>

   Stream-level errors in XMPP are fatal.  Should such an error occur,
   the server MUST send the stream error as a complete element in a
   message to the client.

   If the error occurs during the opening of a stream, the server MUST
   send the initial open element response, followed by the stream-level
   error in a second WebSocket message frame.  The server MUST then
   close the connection as specified in <a href="#section-3.6">Section 3.6</a>.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.6.%20%20Closing%20the%20Connection"></a><a class="selflink" href="#section-3.6" name="section-3.6">3.6</a>.  Closing the Connection</span>

   The closing process for the XMPP subprotocol mirrors that of the XMPP
   TCP binding as defined in <a href="rfc6120.html#section-4.4">Section 4.4 of [RFC6120]</a>, except that a
   &lt;close/&gt; element is used instead of the ending &lt;/stream:stream&gt; tag.

   Either the server or the client may close the connection at any time.
   Before closing the connection, the closing party is expected to first
   close the XMPP stream (if one has been opened) by sending a message
   with the &lt;close/&gt; element, qualified by the
   "urn:ietf:params:xml:ns:xmpp-framing" namespace.  The stream is
   considered closed when a corresponding &lt;close/&gt; element is received
   from the other party, and the XMPP session is ended.

   To then close the WebSocket connection, the closing party MUST
   initiate the WebSocket closing handshake (see <a href="rfc6455.html#section-7.1.2">Section 7.1.2 of
   [RFC6455]</a>).









<span class="grey">Stout, et al.                Standards Track                    [Page 7]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-8" id="page-8" name="page-8"> </a>
<span class="grey"><a href="rfc7395.html">RFC 7395</a>                   XMPP over WebSocket              October 2014</span>


   An example of ending an XMPP-over-WebSocket session by first closing
   the XMPP stream layer and then the WebSocket connection layer:

   Client                         (XMPP WSS)                      Server
   |  |                                                             |  |
   |  | &lt;close xmlns="urn:ietf:params:xml:ns:xmpp-framing" /&gt;       |  |
   |  |------------------------------------------------------------&gt;|  |
   |  |       &lt;close xmlns="urn:ietf:params:xml:ns:xmpp-framing" /&gt; |  |
   |  |&lt;------------------------------------------------------------|  |
   |  |                                                             |  |
   |  |                      (XMPP Stream Closed)                   |  |
   |  +-------------------------------------------------------------+  |
   |                                                                   |
   | WS CLOSE FRAME                                                    |
   |------------------------------------------------------------------&gt;|
   |                                                    WS CLOSE FRAME |
   |&lt;------------------------------------------------------------------|
   |                                                                   |
   |                         (Connection Closed)                       |
   +-------------------------------------------------------------------+

   If the WebSocket connection is closed or broken without the XMPP
   stream having been closed first, then the XMPP stream is considered
   implicitly closed and the XMPP session ended; however, if the use of
   stream management resumption was negotiated (see [<a href="#ref-XEP-0198" title='"Stream Management"'>XEP-0198</a>]), the
   server SHOULD consider the XMPP session still alive for a period of
   time based on server policy as specified in [<a href="#ref-XEP-0198" title='"Stream Management"'>XEP-0198</a>].

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/3.6.1.%20%20see-other-uri"></a><a class="selflink" href="#section-3.6.1" name="section-3.6.1">3.6.1</a>.  see-other-uri</span>

   At any point, if the server wishes to instruct the client to move to
   a different WebSocket endpoint (e.g., for load-balancing purposes),
   then a &lt;close/&gt; element is sent with the 'see-other-uri' attribute
   set to the URI of the new connection endpoint (which MAY be for a
   different transport method, such as BOSH (see [<a href="#ref-XEP-0124" title='"Bidirectional-streams Over Synchronous HTTP (BOSH)"'>XEP-0124</a>] and
   [<a href="#ref-XEP-0206" title='"XMPP Over BOSH"'>XEP-0206</a>])).

   Clients MUST NOT accept suggested endpoints with a lower security
   context (e.g., moving from a 'wss://' endpoint to a 'ws://' or
   'http://' endpoint).

   An example of the server closing a stream and instructing the client
   to connect at a different WebSocket endpoint:

   S: &lt;close xmlns="urn:ietf:params:xml:ns:xmpp-framing"
             see-other-uri="wss://otherendpoint.example/xmpp-bind" /&gt;





<span class="grey">Stout, et al.                Standards Track                    [Page 8]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-9" id="page-9" name="page-9"> </a>
<span class="grey"><a href="rfc7395.html">RFC 7395</a>                   XMPP over WebSocket              October 2014</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.7.%20%20Stream%20Restarts"></a><a class="selflink" href="#section-3.7" name="section-3.7">3.7</a>.  Stream Restarts</span>

   Whenever a stream restart is mandated (see <a href="rfc6120.html#section-4.3.3">Section 4.3.3 of
   [RFC6120]</a>), both the server and client streams are implicitly closed
   and new streams MUST be opened, using the same process as in
   <a href="#section-3.4">Section 3.4</a>.

   The client MUST send a new stream &lt;open/&gt; element and MUST NOT send a
   closing &lt;close/&gt; element.

   An example of restarting the stream after successful Simple
   Authentication and Security Layer (SASL) negotiation:

   S: &lt;success xmlns="urn:ietf:params:xml:ns:xmpp-sasl" /&gt;

   [Streams implicitly closed]

   C: &lt;open xmlns="urn:ietf:params:xml:ns:xmpp-framing"
            to="example.com"
            version="1.0" /&gt;

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.8.%20%20Pings%20and%20Keepalives"></a><a class="selflink" href="#section-3.8" name="section-3.8">3.8</a>.  Pings and Keepalives</span>

   Traditionally, XMPP servers and clients often send "whitespace
   keepalives" (see <a href="rfc6120.html#section-4.6.1">Section 4.6.1 of [RFC6120]</a>) between stanzas to
   maintain an XML stream.  However, for the XMPP subprotocol each
   message is required to start with a '&lt;' character, and, as such,
   whitespace keepalives MUST NOT be used.

   As alternatives, the XMPP Ping extension [<a href="#ref-XEP-0199" title='"XMPP Ping"'>XEP-0199</a>] and the XMPP
   Stream Management extension [<a href="#ref-XEP-0198" title='"Stream Management"'>XEP-0198</a>] provide pinging mechanisms.
   Either of these extensions (or both) MAY be used to determine the
   state of the connection.

   Clients and servers MAY also use WebSocket ping control frames for
   this purpose, but note that some environments, such as browsers, do
   not provide access for generating or monitoring ping control frames.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.9.%20%20Use%20of%20TLS"></a><a class="selflink" href="#section-3.9" name="section-3.9">3.9</a>.  Use of TLS</span>

   Transport Layer Security (TLS) cannot be used at the XMPP subprotocol
   layer because the subprotocol does not allow for raw binary data to
   be sent.  Instead, when TLS is used, it MUST be enabled at the
   WebSocket layer using secure WebSocket connections via the 'wss' URI
   scheme.  (See <a href="rfc6455.html#section-10.6">Section 10.6 of [RFC6455]</a>.)






<span class="grey">Stout, et al.                Standards Track                    [Page 9]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-10" id="page-10" name="page-10"> </a>
<span class="grey"><a href="rfc7395.html">RFC 7395</a>                   XMPP over WebSocket              October 2014</span>


   Because TLS is to be provided outside of the XMPP subprotocol layer,
   a server MUST NOT advertise TLS as a stream feature (see <a href="rfc6120.html#section-4.6">Section 4.6
   of [RFC6120]</a>) when using the XMPP subprotocol.  Likewise, a client
   MUST ignore any advertised TLS stream feature when using the XMPP
   subprotocol.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.10.%20%20Stream%20Management"></a><a class="selflink" href="#section-3.10" name="section-3.10">3.10</a>.  Stream Management</span>

   In order to alleviate the problems of temporary disconnections, the
   client MAY use the XMPP Stream Management extension [<a href="#ref-XEP-0198" title='"Stream Management"'>XEP-0198</a>] to
   confirm when stanzas have been received by the server.

   In particular, the client MAY use session resumption as described in
   [<a href="#ref-XEP-0198" title='"Stream Management"'>XEP-0198</a>] to recreate the same stream session state after a
   temporary network unavailability or after navigating to a new URL in
   a browser.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/4.%20%20Discovering%20the%20WebSocket%20Connection%20Method"></a><a class="selflink" href="#section-4" name="section-4">4</a>.  Discovering the WebSocket Connection Method</span>

   <a href="rfc6120.html#section-3">Section 3 of [RFC6120]</a> defines a procedure for connecting to an XMPP
   server, including ways to discover the TCP/IP address and port of the
   server using Domain Name System service (DNS SRV) records [<a href="rfc2782.html" title='"A DNS RR for specifying the location of services (DNS SRV)"'>RFC2782</a>].
   When using the WebSocket binding as specified in this document
   (instead of the TCP binding as specified in [<a href="rfc6120.html" title='"Extensible Messaging and Presence Protocol (XMPP): Core"'>RFC6120</a>]), a client
   needs an alternative way to discover information about the server's
   connection methods, since web browsers and other WebSocket-capable
   software applications typically cannot obtain such information from
   the DNS.

   The alternative lookup process uses Web-host Metadata [<a href="rfc6415.html" title='"Web Host Metadata"'>RFC6415</a>] and
   Web Linking [<a href="rfc5988.html" title='"Web Linking"'>RFC5988</a>], where the link relation type is
   "urn:xmpp:alt-connections:websocket" as described in "Discovering
   Alternative XMPP Connection Methods" [<a href="#ref-XEP-0156" title='"Discovering Alternative XMPP Connection Methods"'>XEP-0156</a>].  Conceptually, the
   host-meta lookup process used for the WebSocket binding is analogous
   to the DNS SRV lookup process used for the TCP binding.  The process
   is as follows.

   1.  Send a request over secure HTTP to the path
       "/.well-known/host-meta" at an HTTP origin [<a href="rfc6454.html" title='"The Web Origin Concept"'>RFC6454</a>] that matches
       the XMPP service domain (e.g., a URL of
       "https://im.example.org/.well-known/host-meta" if the XMPP
       service domain is "im.example.org").









<span class="grey">Stout, et al.                Standards Track                   [Page 10]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-11" id="page-11" name="page-11"> </a>
<span class="grey"><a href="rfc7395.html">RFC 7395</a>                   XMPP over WebSocket              October 2014</span>


   2.  Retrieve a host-meta document specifying a link relation type of
       "urn:xmpp:alt-connections:websocket", such as:

       &lt;XRD xmlns='http://docs.oasis-open.org/ns/xri/xrd-1.0'&gt;
         &lt;Link rel="urn:xmpp:alt-connections:websocket"
               href="wss://im.example.org:443/ws" /&gt;
       &lt;/XRD&gt;

   Servers MAY expose discovery information using host-meta documents,
   and clients MAY use such information to determine the WebSocket
   endpoint for a server.

   In cases where the XMPP service domain does not match the discovered
   web origin of the WebSocket endpoint, the Web-host Metadata SHOULD be
   used to establish trust between the XMPP server domain and the
   WebSocket endpoint as long as the host-meta request and response
   occurred over secure HTTP; this is especially relevant in multi-
   tenant situations where the same WebSocket endpoint is serving
   multiple XMPP domains (e.g., the XMPP service domains for both
   "example.com" and "im.example.org" might be serviced by the same
   WebSocket endpoint at "hosting.example.net").  See <a href="#section-6">Section 6</a> for
   related discussion.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/5.%20%20IANA%20Considerations"></a><a class="selflink" href="#section-5" name="section-5">5</a>.  IANA Considerations</span>

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.1.%20%20WebSocket%20Subprotocol%20Name"></a><a class="selflink" href="#section-5.1" name="section-5.1">5.1</a>.  WebSocket Subprotocol Name</span>

   IANA has registered the WebSocket XMPP subprotocol in the "WebSocket
   Subprotocol Name Registry", with the following data:

   Subprotocol Identifier:  xmpp

   Subprotocol Common Name:  WebSocket Transport for the Extensible
      Messaging and Presence Protocol (XMPP)

   Subprotocol Definition:  this document

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.2.%20%20URN%20Sub-namespace"></a><a class="selflink" href="#section-5.2" name="section-5.2">5.2</a>.  URN Sub-namespace</span>

   A URN sub-namespace for framing of Extensible Messaging and Presence
   Protocol (XMPP) streams is defined as follows.

   URI:  urn:ietf:params:xml:ns:xmpp-framing

   Specification:  this document






<span class="grey">Stout, et al.                Standards Track                   [Page 11]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-12" id="page-12" name="page-12"> </a>
<span class="grey"><a href="rfc7395.html">RFC 7395</a>                   XMPP over WebSocket              October 2014</span>


   Description:  This is the XML namespace name for framing of
      Extensible Messaging and Presence Protocol (XMPP) streams as
      defined by <a href="rfc7395.html">RFC 7395</a>.

   Registrant Contact:  IESG &lt;iesg@ietf.org&gt;

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/6.%20%20Security%20Considerations"></a><a class="selflink" href="#section-6" name="section-6">6</a>.  Security Considerations</span>

   The WebSocket binding for XMPP differs in several respects from the
   TCP binding defined in [<a href="rfc6120.html" title='"Extensible Messaging and Presence Protocol (XMPP): Core"'>RFC6120</a>]:

   1.  As described in <a href="#section-4">Section 4</a> of this document, the method for
       discovering a connection endpoint does not use DNS SRV records as
       in the TCP binding but instead uses Web-host Metadata files
       retrieved via HTTPS from a URL at the XMPP service domain.  From
       a security standpoint, this is functionally equivalent to
       resolution via DNS SRV records (and still relies on the DNS for
       resolution of the XMPP source domain).

   2.  The method for authenticating a connection endpoint uses TLS
       (typically with PKIX certificates) as in the TCP binding, but the
       identity to be authenticated is the connection endpoint address
       instead of the XMPP service domain; delegation from the XMPP
       service domain to the connection endpoint address (if any) is
       accomplished via the discovery method described in <a href="#section-4">Section 4</a>.
       Thus, the connection endpoint is still authenticated, and the
       delegation is secure as long as the Web-host Metadata file is
       retrieved via HTTPS.  However, note that, in practice, this
       option might not be employed when user agents are configured or
       deployed for a particular delegated domain.

   3.  The framing method described in <a href="#section-3.3">Section 3.3</a> follows the WebSocket
       pattern by sending one top-level XML element per WebSocket
       message, instead of using streaming XML as in the TCP binding.
       However, the framing method has no impact on the security
       properties of an XMPP session (e.g., end-to-end encryption of XML
       stanzas can be accomplished just as easily with WebSocket framing
       as with streaming XML).

   4.  In all other respects (e.g., user authentication via SASL,
       allowable characters in XMPP addresses, and reuse of various
       technologies such as Base 64, SASL mechanisms, UTF-8, and XML),
       the WebSocket binding does not differ from the TCP binding and,
       thus, does not modify the security properties of the protocol.
       In all these respects, the security considerations of [<a href="rfc6120.html" title='"Extensible Messaging and Presence Protocol (XMPP): Core"'>RFC6120</a>]
       apply directly to the WebSocket binding.





<span class="grey">Stout, et al.                Standards Track                   [Page 12]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-13" id="page-13" name="page-13"> </a>
<span class="grey"><a href="rfc7395.html">RFC 7395</a>                   XMPP over WebSocket              October 2014</span>


   In order to ensure that communications over the WebSocket binding are
   as secure as communications over the TCP binding, an operator needs
   to (1) serve the Web-host Metadata file for the XMPP service domain
   over secure HTTP ('https' URIs) only, (2) configure the WebSocket
   connection endpoint to use TLS ('wss' URIs) only, and (3) deploy
   certificates that properly identify the XMPP service domain and
   WebSocket connection endpoint for usages (1) and (2), respectively.

   Since application-level TLS cannot be used (see <a href="#section-3.9">Section 3.9</a>),
   applications need to protect the privacy of XMPP traffic at the
   WebSocket or other appropriate layer.

   Browser-based applications are not able to inspect and verify, at the
   application layer, the certificate used for the WebSocket connection
   to ensure that it corresponds to the domain specified as the 'to'
   address of the XMPP stream.  There are two cases:

   1.  If the XMPP service domain matches the origin for the WebSocket
       connection, the relevant check is already performed by the
       browser.  For example, the XMPP service domain might be
       "foo.example", and the WebSocket endpoint discovered for the link
       relation type of "urn:xmpp:alt-connections:websocket" might be
       "wss://foo.example/websocket".  As long as the certificate
       provided over WebSocket or HTTPS is verified according to the
       rules defined for secure HTTP [<a href="rfc2818.html" title='"HTTP Over TLS"'>RFC2818</a>], then the browser will
       report the successful establishment of a secure connection to the
       application.  (However, as noted, the application is still not
       able to independently inspect and verify the certificate, and
       needs to trust the browser; this is a limitation of existing
       browser technologies and thus cannot be worked around by
       WebSocket applications.)

   2.  In situations where the user agent has to deal with delegation
       and the domain of the XMPP server does not match the web origin
       of the WebSocket endpoint (such as multi-tenant hosting
       situations), the host-meta process described in <a href="#section-4">Section 4</a> SHOULD
       be used to delegate trust from the XMPP server domain to the
       WebSocket origin, as long as the host-meta request and response
       occurred over secure HTTP (with appropriate certificate
       verification as defined in [<a href="rfc2818.html" title='"HTTP Over TLS"'>RFC2818</a>]).

   When presented with a new WebSocket endpoint via the 'see-other-uri'
   attribute of a &lt;close/&gt; element, clients MUST NOT accept the
   suggestion if the security context of the new endpoint is lower than
   the current one in order to prevent downgrade attacks from a 'wss://'
   endpoint to 'ws://'.





<span class="grey">Stout, et al.                Standards Track                   [Page 13]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-14" id="page-14" name="page-14"> </a>
<span class="grey"><a href="rfc7395.html">RFC 7395</a>                   XMPP over WebSocket              October 2014</span>


   The security considerations for both WebSocket (see <a href="rfc6455.html#section-10">Section 10 of
   [RFC6455]</a>) and XMPP (see <a href="rfc6120.html#section-13">Section 13 of [RFC6120]</a>) apply to the
   WebSocket XMPP subprotocol.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/7.%20%20References"></a><a class="selflink" href="#section-7" name="section-7">7</a>.  References</span>

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/7.1.%20%20Normative%20References"></a><a class="selflink" href="#section-7.1" name="section-7.1">7.1</a>.  Normative References</span>

   [<a id="ref-RFC2119" name="ref-RFC2119">RFC2119</a>]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", <a href="https://tools.ietf.org/html/bcp14">BCP 14</a>, <a href="rfc2119.html">RFC 2119</a>, March 1997,
              &lt;<a href="http://www.rfc-editor.org/info/rfc2119">http://www.rfc-editor.org/info/rfc2119</a>&gt;.

   [<a id="ref-RFC2818" name="ref-RFC2818">RFC2818</a>]  Rescorla, E., "HTTP Over TLS", <a href="rfc2818.html">RFC 2818</a>, May 2000,
              &lt;<a href="http://www.rfc-editor.org/info/rfc2818">http://www.rfc-editor.org/info/rfc2818</a>&gt;.

   [<a id="ref-RFC5988" name="ref-RFC5988">RFC5988</a>]  Nottingham, M., "Web Linking", <a href="rfc5988.html">RFC 5988</a>, October 2010,
              &lt;<a href="http://www.rfc-editor.org/info/rfc5988">http://www.rfc-editor.org/info/rfc5988</a>&gt;.

   [<a id="ref-RFC6120" name="ref-RFC6120">RFC6120</a>]  Saint-Andre, P., "Extensible Messaging and Presence
              Protocol (XMPP): Core", <a href="rfc6120.html">RFC 6120</a>, March 2011,
              &lt;<a href="http://www.rfc-editor.org/info/rfc6120">http://www.rfc-editor.org/info/rfc6120</a>&gt;.

   [<a id="ref-RFC6415" name="ref-RFC6415">RFC6415</a>]  Hammer-Lahav, E. and B. Cook, "Web Host Metadata", <a href="rfc6415.html">RFC</a>
              <a href="rfc6415.html">6415</a>, October 2011,
              &lt;<a href="http://www.rfc-editor.org/info/rfc6415">http://www.rfc-editor.org/info/rfc6415</a>&gt;.

   [<a id="ref-RFC6455" name="ref-RFC6455">RFC6455</a>]  Fette, I. and A. Melnikov, "The WebSocket Protocol", <a href="rfc6455.html">RFC</a>
              <a href="rfc6455.html">6455</a>, December 2011,
              &lt;<a href="http://www.rfc-editor.org/info/rfc6455">http://www.rfc-editor.org/info/rfc6455</a>&gt;.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/7.2.%20%20Informative%20References"></a><a class="selflink" href="#section-7.2" name="section-7.2">7.2</a>.  Informative References</span>

   [<a id="ref-RFC2782" name="ref-RFC2782">RFC2782</a>]  Gulbrandsen, A., Vixie, P., and L. Esibov, "A DNS RR for
              specifying the location of services (DNS SRV)", <a href="rfc2782.html">RFC 2782</a>,
              February 2000, &lt;<a href="http://www.rfc-editor.org/info/rfc2782">http://www.rfc-editor.org/info/rfc2782</a>&gt;.

   [<a id="ref-RFC6121" name="ref-RFC6121">RFC6121</a>]  Saint-Andre, P., "Extensible Messaging and Presence
              Protocol (XMPP): Instant Messaging and Presence", <a href="rfc6121.html">RFC</a>
              <a href="rfc6121.html">6121</a>, March 2011,
              &lt;<a href="http://www.rfc-editor.org/info/rfc6121">http://www.rfc-editor.org/info/rfc6121</a>&gt;.

   [<a id="ref-RFC6202" name="ref-RFC6202">RFC6202</a>]  Loreto, S., Saint-Andre, P., Salsano, S., and G. Wilkins,
              "Known Issues and Best Practices for the Use of Long
              Polling and Streaming in Bidirectional HTTP", <a href="rfc6202.html">RFC 6202</a>,
              April 2011, &lt;<a href="http://www.rfc-editor.org/info/rfc6202">http://www.rfc-editor.org/info/rfc6202</a>&gt;.

   [<a id="ref-RFC6454" name="ref-RFC6454">RFC6454</a>]  Barth, A., "The Web Origin Concept", <a href="rfc6454.html">RFC 6454</a>,
              December 2011, &lt;<a href="http://www.rfc-editor.org/info/rfc6454">http://www.rfc-editor.org/info/rfc6454</a>&gt;.



<span class="grey">Stout, et al.                Standards Track                   [Page 14]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-15" id="page-15" name="page-15"> </a>
<span class="grey"><a href="rfc7395.html">RFC 7395</a>                   XMPP over WebSocket              October 2014</span>


   [<a id="ref-XEP-0124" name="ref-XEP-0124">XEP-0124</a>] Paterson, I., Smith, D., Saint-Andre, P., Moffitt, J.,
              Stout, L., and W. Tilanus, "Bidirectional-streams Over
              Synchronous HTTP (BOSH)", XSF XEP 0124, April 2014.

   [<a id="ref-XEP-0156" name="ref-XEP-0156">XEP-0156</a>] Hildebrand, J., Saint-Andre, P., and L. Stout,
              "Discovering Alternative XMPP Connection Methods",
              XSF XEP 0156, January 2014.

   [<a id="ref-XEP-0198" name="ref-XEP-0198">XEP-0198</a>] Karneges, J., Saint-Andre, P., Hildebrand, J., Forno, F.,
              Cridland, D., and M. Wild, "Stream Management",
              XSF XEP 0198, June 2011.

   [<a id="ref-XEP-0199" name="ref-XEP-0199">XEP-0199</a>] Saint-Andre, P., "XMPP Ping", XSF XEP 0199, June 2009.

   [<a id="ref-XEP-0206" name="ref-XEP-0206">XEP-0206</a>] Paterson, I., Saint-Andre, P., Stout, L., and W. Tilanus,
   "XMPP Over BOSH", XSF XEP 0206, April 2014.

   [<a id="ref-XML-SCHEMA" name="ref-XML-SCHEMA">XML-SCHEMA</a>]
              Thompson, H., Beech, D., Maloney, M., and N. Mendelsohn,
              "XML Schema Part 1: Structures Second Edition", World Wide
              Web Consortium Recommendation REC-xmlschema-1-20041028,
              October 2004,
              &lt;<a href="http://www.w3.org/TR/2004/REC-xmlschema-1-20041028">http://www.w3.org/TR/2004/REC-xmlschema-1-20041028</a>&gt;.




























<span class="grey">Stout, et al.                Standards Track                   [Page 15]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-16" id="page-16" name="page-16"> </a>
<span class="grey"><a href="rfc7395.html">RFC 7395</a>                   XMPP over WebSocket              October 2014</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/Appendix%20A.%20%20XML%20Schema"></a><a class="selflink" href="#appendix-A" name="appendix-A">Appendix A</a>.  XML Schema</span>

   The following schema formally defines the
   'urn:ietf:params:xml:ns:xmpp-framing' namespace used in this
   document, in conformance with W3C XML Schema [<a href="#ref-XML-SCHEMA">XML-SCHEMA</a>].  Because
   validation of XML streams and stanzas is optional, this schema is not
   normative and is provided for descriptive purposes only.

   &lt;?xml version='1.0' encoding='UTF-8'?&gt;

   &lt;xs:schema
       xmlns:xs='http://www.w3.org/2001/XMLSchema'
       targetNamespace='urn:ietf:params:xml:ns:xmpp-framing'
       xmlns='urn:ietf:params:xml:ns:xmpp-framing'
       elementFormDefault='unqualified'&gt;

     &lt;xs:element name='open'&gt;
       &lt;xs:complexType&gt;
         &lt;xs:simpleContent&gt;
           &lt;xs:extension base='empty'&gt;
             &lt;xs:attribute name='from' type='xs:string'
                           use='optional'/&gt;
             &lt;xs:attribute name='id' type='xs:string'
                           use='optional'/&gt;
             &lt;xs:attribute name='to' type='xs:string'
                           use='optional'/&gt;
             &lt;xs:attribute name='version' type='xs:decimal'
                           use='optional'/&gt;
             &lt;xs:attribute ref='xml:lang'
                           use='optional'/&gt;
           &lt;/xs:extension&gt;
         &lt;/xs:simpleContent&gt;
       &lt;/xs:complexType&gt;
     &lt;/xs:element&gt;

















<span class="grey">Stout, et al.                Standards Track                   [Page 16]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-17" id="page-17" name="page-17"> </a>
<span class="grey"><a href="rfc7395.html">RFC 7395</a>                   XMPP over WebSocket              October 2014</span>


     &lt;xs:element name='close'&gt;
       &lt;xs:complexType&gt;
         &lt;xs:simpleContent&gt;
           &lt;xs:extension base='empty'&gt;
             &lt;xs:attribute name='from' type='xs:string'
                           use='optional'/&gt;
             &lt;xs:attribute name='id' type='xs:string'
                           use='optional'/&gt;
             &lt;xs:attribute name='see-other-uri' type='xs:anyURI'
                           use='optional'/&gt;
             &lt;xs:attribute name='to' type='xs:string'
                           use='optional'/&gt;
             &lt;xs:attribute name='version' type='xs:decimal'
                           use='optional'/&gt;
             &lt;xs:attribute ref='xml:lang'
                           use='optional'/&gt;
           &lt;/xs:extension&gt;
         &lt;/xs:simpleContent&gt;
       &lt;/xs:complexType&gt;
     &lt;/xs:element&gt;

     &lt;xs:simpleType name='empty'&gt;
       &lt;xs:restriction base='xs:string'&gt;
         &lt;xs:enumeration value=''/&gt;
       &lt;/xs:restriction&gt;
     &lt;/xs:simpleType&gt;

   &lt;/xs:schema&gt;

Acknowledgements

   The authors wish to thank the following individuals for their
   feedback: Andreas Guth, Bjoern Hoerhmann, Dave Cridland, Florian
   Zeitz, Kurt Zeilenga, Matt Miller, Matthew Wild, Paul Aurich, Sergey
   Dobrov, and Waqas Hussain.

   Dan Romascanu reviewed the document on behalf of the General Area
   Review Team.

   During IESG review, Barry Leiba, Benoit Claise, Dan Romascanu, Jari
   Arkko, Juergen Schoenwaelder, Spencer Dawkins, Stephen Farrell, Ted
   Lemon, Kathleen Moriarty, and Pete Resnick caught several issues that
   needed to be addressed.

   The authors gratefully acknowledge the assistance of Peter Saint-
   Andre as document shepherd, Ben Campbell and Joe Hildebrand as the
   working group chairs, and Richard Barnes as the sponsoring Area
   Director.



<span class="grey">Stout, et al.                Standards Track                   [Page 17]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-18" id="page-18" name="page-18"> </a>
<span class="grey"><a href="rfc7395.html">RFC 7395</a>                   XMPP over WebSocket              October 2014</span>


Authors' Addresses

   Lance Stout (editor)
   &amp;yet

   EMail: lance@andyet.net


   Jack Moffitt
   Mozilla

   EMail: jack@metajack.im


   Eric Cestari
   cstar industries

   EMail: eric@cstar.io

































Stout, et al.                Standards Track                   [Page 18]

</pre><br/>
    <span class="noprint"><small><small>Html markup produced by rfcmarkup 1.126, available from
      <a href="https://tools.ietf.org/tools/rfcmarkup/">https://tools.ietf.org/tools/rfcmarkup/</a>
    </small></small></span>
  </div>




</body><!-- Mirrored from tools.ietf.org/html/rfc7395 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 06 Mar 2018 23:18:22 GMT --></html>