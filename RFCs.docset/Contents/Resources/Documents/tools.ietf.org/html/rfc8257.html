<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml"><!-- Mirrored from tools.ietf.org/html/rfc8257 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 14 Aug 2018 13:48:50 GMT --><!-- Added by HTTrack --><head><meta content="text/html;charset=utf-8" http-equiv="content-type"/><!-- /Added by HTTrack -->

    <meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
    <meta content="index,follow" name="robots"/>
    <meta content="rfcmarkup version 1.127" name="creator"/>
    <link href="http://purl.org/dc/elements/1.1/" rel="schema.DC"/>
<meta content="draft-bensley-tcpm-dctcp" name="DC.Relation.Replaces"/>
<meta content="urn:ietf:rfc:8257" name="DC.Identifier"/>
<meta content="October, 2017" name="DC.Date.Issued"/>
<meta content="Bensley, Stephen" name="DC.Creator"/>
<meta content="Balasubramanian, Praveen" name="DC.Creator"/>
<meta content="Judd, Glenn" name="DC.Creator"/>
<meta content="Eggert, Lars" name="DC.Creator"/>
<meta content="Thaler, Dave" name="DC.Creator"/>
<meta content="This Informational RFC describes Data Center TCP (DCTCP): a TCP
congestion control scheme for data-center traffic. DCTCP extends the
Explicit Congestion Notification (ECN) processing to estimate the
fraction of bytes that encounter congestion rather than simply
detecting that some congestion has occurred. DCTCP then scales the TCP
congestion window based on this estimate. This method achieves high-
burst tolerance, low latency, and high throughput with shallow-
buffered switches. This memo also discusses deployment issues related
to the coexistence of DCTCP and conventional TCP, discusses the lack
of a negotiating mechanism between sender and receiver, and presents
some possible mitigations. This memo documents DCTCP as currently
implemented by several major operating systems. DCTCP, as described in
this specification, is applicable to deployments in controlled
environments like data centers, but it must not be deployed over the
public Internet without additional measures." name="DC.Description.Abstract"/>
<meta content="Data Center TCP (DCTCP): TCP Congestion Control for Data Centers" name="DC.Title"/>

    <link href="https://tools.ietf.org/images/rfc.png" rel="icon" type="image/png"/>
    <link href="https://tools.ietf.org/images/rfc.png" rel="shortcut icon" type="image/png"/>
    <title>RFC 8257 - Data Center TCP (DCTCP): TCP Congestion Control for Data Centers</title>
    
    
    <style type="text/css">
	@media only screen 
	  and (min-width: 992px)
	  and (max-width: 1199px) {
	    body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 768px)
	  and (max-width: 991px) {
            body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 480px)
	  and (max-width: 767px) {
            body { font-size: 11pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (max-width: 479px) {
            body { font-size: 8pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-device-width : 375px) 
	  and (max-device-width : 667px) {
            body { font-size: 9.5pt; }
            div.content { width: 96ex; margin: 0 1px; }
        }
	@media only screen 
	  and (min-device-width: 1200px) {
            body { font-size: 10pt; margin: 0 4em; }
            div.content { width: 96ex; margin: 0; }
        }
        h1, h2, h3, h4, h5, h6, .h1, .h2, .h3, .h4, .h5, .h6 {
	    font-weight: bold;
            line-height: 0pt;
            display: inline;
            white-space: pre;
            font-family: monospace;
            font-size: 1em;
	    font-weight: bold;
        }
        pre {
            font-size: 1em;
            margin-top: 0px;
            margin-bottom: 0px;
        }
	.pre {
	    white-space: pre;
	    font-family: monospace;
	}
	.header{
	    font-weight: bold;
	}
        .newpage {
            page-break-before: always;
        }
        .invisible {
            text-decoration: none;
            color: white;
        }
        a.selflink {
          color: black;
          text-decoration: none;
        }
        @media print {
            body {
                font-family: monospace;
                font-size: 10.5pt;
            }
            h1, h2, h3, h4, h5, h6 {
                font-size: 1em;
            }
        
            a:link, a:visited {
                color: inherit;
                text-decoration: none;
            }
            .noprint {
                display: none;
            }
        }
	@media screen {
	    .grey, .grey a:link, .grey a:visited {
		color: #777;
	    }
            .docinfo {
                background-color: #EEE;
            }
            .top {
                border-top: 7px solid #EEE;
            }
            .bgwhite  { background-color: white; }
            .bgred    { background-color: #F44; }
            .bggrey   { background-color: #666; }
            .bgbrown  { background-color: #840; }            
            .bgorange { background-color: #FA0; }
            .bgyellow { background-color: #EE0; }
            .bgmagenta{ background-color: #F4F; }
            .bgblue   { background-color: #66F; }
            .bgcyan   { background-color: #4DD; }
            .bggreen  { background-color: #4F4; }

            .legend   { font-size: 90%; }
            .cplate   { font-size: 70%; border: solid grey 1px; }
	}
    </style>
    <!--[if IE]>
    <style>
    body {
       font-size: 13px;
       margin: 10px 10px;
    }
    </style>
    <![endif]-->

    <script type="text/javascript"><!--
    function addHeaderTags() {
	var spans = document.getElementsByTagName("span");
	for (var i=0; i < spans.length; i++) {
	    var elem = spans[i];
	    if (elem) {
		var level = elem.getAttribute("class");
                if (level == "h1" || level == "h2" || level == "h3" || level == "h4" || level == "h5" || level == "h6") {
                    elem.innerHTML = "<"+level+">"+elem.innerHTML+"</"+level+">";		
                }
	    }
	}
    }
    var legend_html = "Colour legend:<br />      <table>         <tr><td>Unknown:</td>                   <td><span class='cplate bgwhite'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft:</td>                     <td><span class='cplate bgred'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Informational:</td>             <td><span class='cplate bgorange'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Experimental:</td>              <td><span class='cplate bgyellow'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Best Common Practice:</td>      <td><span class='cplate bgmagenta'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Proposed Standard:</td>         <td><span class='cplate bgblue'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft Standard (old designation):</td> <td><span class='cplate bgcyan'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Internet Standard:</td>         <td><span class='cplate bggreen'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Historic:</td>                  <td><span class='cplate bggrey'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Obsolete:</td>                  <td><span class='cplate bgbrown'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>     </table>";
    function showElem(id) {
        var elem = document.getElementById(id);
        elem.innerHTML = eval(id+"_html");
        elem.style.visibility='visible';
    }
    function hideElem(id) {
        var elem = document.getElementById(id);
        elem.style.visibility='hidden';        
        elem.innerHTML = "";
    }
    // -->
    </script>
</head>
<body onload="addHeaderTags()">
  <div class="content">
   <div style="height: 13px;">
      <div class="pre noprint docinfo bgorange" onclick="showElem('legend');" onmouseout="hideElem('legend')" onmouseover="this.style.cursor='pointer';" style="height: 6px; position: absolute;" title="Click for colour legend.">                                                                        </div>
      <div class="docinfo noprint pre legend" id="legend" onmouseout="hideElem('legend');" onmouseover="showElem('legend');" style="position:absolute; top: 4px; left: 4ex; visibility:hidden; background-color: white; padding: 4px 9px 5px 7px; border: solid #345 1px; ">
      </div>
   </div>
<span class="pre noprint docinfo top">[<a href="index.html" title="Document search and retrieval page">Docs</a>] [<a href="https://tools.ietf.org/rfc/rfc8257.txt" title="Plaintext version of this document">txt</a>|<a href="https://tools.ietf.org/pdf/rfc8257" title="PDF version of this document">pdf</a>] [<a href="https://tools.ietf.org/html/draft-ietf-tcpm-dctcp" title="draft-ietf-tcpm-dctcp">draft-ietf-tcpm...</a>] [<a href="https://datatracker.ietf.org/doc/rfc8257" title="IESG Datatracker information for this document">Tracker</a>] [<a href="https://tools.ietf.org/rfcdiff?difftype=--hwdiff&amp;url2=rfc8257" title="Inline diff (wdiff)">Diff1</a>] [<a href="https://tools.ietf.org/rfcdiff?url2=rfc8257" title="Side-by-side diff">Diff2</a>]         </span><br/>
<span class="pre noprint docinfo">                                                                        </span><br/>
<span class="pre noprint docinfo">                                                           INFORMATIONAL</span><br/>
<span class="pre noprint docinfo">                                                                        </span><br/>
<pre>Internet Engineering Task Force (IETF)                        S. Bensley
Request for Comments: 8257                                     D. Thaler
Category: Informational                               P. Balasubramanian
ISSN: 2070-1721                                                Microsoft
                                                               L. Eggert
                                                                  NetApp
                                                                 G. Judd
                                                          Morgan Stanley
                                                            October 2017


    <span class="h1">Data Center TCP (DCTCP): TCP Congestion Control for Data Centers</span>

Abstract

   This Informational RFC describes Data Center TCP (DCTCP): a TCP
   congestion control scheme for data-center traffic.  DCTCP extends the
   Explicit Congestion Notification (ECN) processing to estimate the
   fraction of bytes that encounter congestion rather than simply
   detecting that some congestion has occurred.  DCTCP then scales the
   TCP congestion window based on this estimate.  This method achieves
   high-burst tolerance, low latency, and high throughput with shallow-
   buffered switches.  This memo also discusses deployment issues
   related to the coexistence of DCTCP and conventional TCP, discusses
   the lack of a negotiating mechanism between sender and receiver, and
   presents some possible mitigations.  This memo documents DCTCP as
   currently implemented by several major operating systems.  DCTCP, as
   described in this specification, is applicable to deployments in
   controlled environments like data centers, but it must not be
   deployed over the public Internet without additional measures.

Status of This Memo

   This document is not an Internet Standards Track specification; it is
   published for informational purposes.

   This document is a product of the Internet Engineering Task Force
   (IETF).  It represents the consensus of the IETF community.  It has
   received public review and has been approved for publication by the
   Internet Engineering Steering Group (IESG).  Not all documents
   approved by the IESG are a candidate for any level of Internet
   Standard; see <a href="rfc7841.html#section-2">Section 2 of RFC 7841</a>.

   Information about the current status of this document, any errata,
   and how to provide feedback on it may be obtained at
   <a href="https://www.rfc-editor.org/info/rfc8257">https://www.rfc-editor.org/info/rfc8257</a>.





<span class="grey">Bensley, et al.               Informational                     [Page 1]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-2" id="page-2" name="page-2"> </a>
<span class="grey"><a href="rfc8257.html">RFC 8257</a>                          DCTCP                     October 2017</span>


Copyright Notice

   Copyright (c) 2017 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to <a href="https://tools.ietf.org/html/bcp78">BCP 78</a> and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (<a href="https://trustee.ietf.org/license-info">https://trustee.ietf.org/license-info</a>) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.

Table of Contents

   <a href="#section-1">1</a>.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   <a href="#page-3">3</a>
   <a href="#section-2">2</a>.  Terminology . . . . . . . . . . . . . . . . . . . . . . . . .   <a href="#page-4">4</a>
   <a href="#section-3">3</a>.  DCTCP Algorithm . . . . . . . . . . . . . . . . . . . . . . .   <a href="#page-5">5</a>
     <a href="#section-3.1">3.1</a>.  Marking Congestion on the L3 Switches and Routers . . . .   <a href="#page-5">5</a>
     <a href="#section-3.2">3.2</a>.  Echoing Congestion Information on the Receiver  . . . . .   <a href="#page-5">5</a>
     3.3.  Processing Echoed Congestion Indications on the Sender  .   7
     <a href="#section-3.4">3.4</a>.  Handling of Congestion Window Growth  . . . . . . . . . .   <a href="#page-8">8</a>
     <a href="#section-3.5">3.5</a>.  Handling of Packet Loss . . . . . . . . . . . . . . . . .   <a href="#page-8">8</a>
     <a href="#section-3.6">3.6</a>.  Handling of SYN, SYN-ACK, and RST Packets . . . . . . . .   <a href="#page-9">9</a>
   <a href="#section-4">4</a>.  Implementation Issues . . . . . . . . . . . . . . . . . . . .   <a href="#page-9">9</a>
     <a href="#section-4.1">4.1</a>.  Configuration of DCTCP  . . . . . . . . . . . . . . . . .   <a href="#page-9">9</a>
     <a href="#section-4.2">4.2</a>.  Computation of DCTCP.Alpha  . . . . . . . . . . . . . . .  <a href="#page-10">10</a>
   <a href="#section-5">5</a>.  Deployment Issues . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-11">11</a>
   <a href="#section-6">6</a>.  Known Issues  . . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-12">12</a>
   <a href="#section-7">7</a>.  Security Considerations . . . . . . . . . . . . . . . . . . .  <a href="#page-12">12</a>
   <a href="#section-8">8</a>.  IANA Considerations . . . . . . . . . . . . . . . . . . . . .  <a href="#page-13">13</a>
   <a href="#section-9">9</a>.  References  . . . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-13">13</a>
     <a href="#section-9.1">9.1</a>.  Normative References  . . . . . . . . . . . . . . . . . .  <a href="#page-13">13</a>
     <a href="#section-9.2">9.2</a>.  Informative References  . . . . . . . . . . . . . . . . .  <a href="#page-14">14</a>
   Acknowledgments . . . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-16">16</a>
   Authors' Addresses  . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-16">16</a>













<span class="grey">Bensley, et al.               Informational                     [Page 2]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-3" id="page-3" name="page-3"> </a>
<span class="grey"><a href="rfc8257.html">RFC 8257</a>                          DCTCP                     October 2017</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/1.%20%20Introduction"></a><a class="selflink" href="#section-1" name="section-1">1</a>.  Introduction</span>

   Large data centers necessarily need many network switches to
   interconnect their many servers.  Therefore, a data center can
   greatly reduce its capital expenditure by leveraging low-cost
   switches.  However, such low-cost switches tend to have limited queue
   capacities; thus, they are more susceptible to packet loss due to
   congestion.

   Network traffic in a data center is often a mix of short and long
   flows, where the short flows require low latencies and the long flows
   require high throughputs.  Data centers also experience incast
   bursts, where many servers send traffic to a single server at the
   same time.  For example, this traffic pattern is a natural
   consequence of the MapReduce [<a href="#ref-MAPREDUCE" title='"MapReduce: Simplified Data Processing on Large Clusters"'>MAPREDUCE</a>] workload: the worker nodes
   complete at approximately the same time, and all reply to the master
   node concurrently.

   These factors place some conflicting demands on the queue occupancy
   of a switch:

   o  The queue must be short enough that it does not impose excessive
      latency on short flows.

   o  The queue must be long enough to buffer sufficient data for the
      long flows to saturate the path capacity.

   o  The queue must be long enough to absorb incast bursts without
      excessive packet loss.

   Standard TCP congestion control [<a href="rfc5681.html" title='"TCP Congestion Control"'>RFC5681</a>] relies on packet loss to
   detect congestion.  This does not meet the demands described above.
   First, short flows will start to experience unacceptable latencies
   before packet loss occurs.  Second, by the time TCP congestion
   control kicks in on the senders, most of the incast burst has already
   been dropped.

   [<a id="ref-RFC3168" name="ref-RFC3168">RFC3168</a>] describes a mechanism for using Explicit Congestion
   Notification (ECN) from the switches for detection of congestion.
   However, this method only detects the presence of congestion, not its
   extent.  In the presence of mild congestion, the TCP congestion
   window is reduced too aggressively, and this unnecessarily reduces
   the throughput of long flows.

   Data Center TCP (DCTCP) changes traditional ECN processing by
   estimating the fraction of bytes that encounter congestion rather
   than simply detecting that some congestion has occurred.  DCTCP then
   scales the TCP congestion window based on this estimate.  This method



<span class="grey">Bensley, et al.               Informational                     [Page 3]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-4" id="page-4" name="page-4"> </a>
<span class="grey"><a href="rfc8257.html">RFC 8257</a>                          DCTCP                     October 2017</span>


   achieves high-burst tolerance, low latency, and high throughput with
   shallow-buffered switches.  DCTCP is a modification to the processing
   of ECN by a conventional TCP and requires that standard TCP
   congestion control be used for handling packet loss.

   DCTCP should only be deployed in an intra-data-center environment
   where both endpoints and the switching fabric are under a single
   administrative domain.  DCTCP MUST NOT be deployed over the public
   Internet without additional measures, as detailed in <a href="#section-5">Section 5</a>.

   The objective of this Informational RFC is to document DCTCP as a new
   approach (which is known to be widely implemented and deployed) to
   address TCP congestion control in data centers.  The IETF TCPM
   Working Group reached consensus regarding the fact that a DCTCP
   standard would require further work.  A precise documentation of
   running code enables follow-up Experimental or Standards Track RFCs
   through the IETF stream.

   This document describes DCTCP as implemented in Microsoft Windows
   Server 2012 [<a href="#ref-WINDOWS" title='"Data Center Transmission Control Protocol (DCTCP)"'>WINDOWS</a>].  The Linux [<a href="#ref-LINUX" title='"net: tcp: add DCTCP congestion control algorithm"'>LINUX</a>] and FreeBSD [<a href="#ref-FREEBSD" title='"DCTCP (Data Center TCP) implementation"'>FREEBSD</a>]
   operating systems have also implemented support for DCTCP in a way
   that is believed to follow this document.  Deployment experiences
   with DCTCP have been documented in [<a href="#ref-MORGANSTANLEY" title='"Attaining the Promise and Avoiding the Pitfalls of TCP in the Datacenter"'>MORGANSTANLEY</a>].

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/2.%20%20Terminology"></a><a class="selflink" href="#section-2" name="section-2">2</a>.  Terminology</span>

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
   "OPTIONAL" in this document are to be interpreted as described in
   <a href="https://tools.ietf.org/html/bcp14">BCP 14</a> [<a href="rfc2119.html" title='"Key words for use in RFCs to Indicate Requirement Levels"'>RFC2119</a>] [<a href="rfc8174.html" title='"Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words"'>RFC8174</a>] when, and only when, they appear in all
   capitals, as shown here.

   Normative language is used to describe how necessary the various
   aspects of a DCTCP implementation are for interoperability, but even
   compliant implementations without the measures in Sections <a href="#section-4">4</a>-<a href="#section-6">6</a> would
   still only be safe to deploy in controlled environments, i.e., not
   over the public Internet.














<span class="grey">Bensley, et al.               Informational                     [Page 4]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-5" id="page-5" name="page-5"> </a>
<span class="grey"><a href="rfc8257.html">RFC 8257</a>                          DCTCP                     October 2017</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/3.%20%20DCTCP%20Algorithm"></a><a class="selflink" href="#section-3" name="section-3">3</a>.  DCTCP Algorithm</span>

   There are three components involved in the DCTCP algorithm:

   o  The switches (or other intermediate devices in the network) detect
      congestion and set the Congestion Encountered (CE) codepoint in
      the IP header.

   o  The receiver echoes the congestion information back to the sender,
      using the ECN-Echo (ECE) flag in the TCP header.

   o  The sender computes a congestion estimate and reacts by reducing
      the TCP congestion window (cwnd) accordingly.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.1.%20%20Marking%20Congestion%20on%20the%20L3%20Switches%20and%20Routers"></a><a class="selflink" href="#section-3.1" name="section-3.1">3.1</a>.  Marking Congestion on the L3 Switches and Routers</span>

   The Layer 3 (L3) switches and routers in a data-center fabric
   indicate congestion to the end nodes by setting the CE codepoint in
   the IP header as specified in <a href="rfc3168.html#section-5">Section 5 of [RFC3168]</a>.  For example,
   the switches may be configured with a congestion threshold.  When a
   packet arrives at a switch and its queue length is greater than the
   congestion threshold, the switch sets the CE codepoint in the packet.
   For example, Section 3.4 of [<a href="#ref-DCTCP10" title='"Data Center TCP (DCTCP)"'>DCTCP10</a>] suggests threshold marking with
   a threshold of K &gt; (RTT * C)/7, where C is the link rate in packets
   per second.  In typical deployments, the marking threshold is set to
   be a small value to maintain a short average queueing delay.
   However, the actual algorithm for marking congestion is an
   implementation detail of the switch and will generally not be known
   to the sender and receiver.  Therefore, the sender and receiver
   should not assume that a particular marking algorithm is implemented
   by the switching fabric.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.2.%20%20Echoing%20Congestion%20Information%20on%20the%20Receiver"></a><a class="selflink" href="#section-3.2" name="section-3.2">3.2</a>.  Echoing Congestion Information on the Receiver</span>

   According to <a href="rfc3168.html#section-6.1.3">Section 6.1.3 of [RFC3168]</a>, the receiver sets the ECE
   flag if any of the packets being acknowledged had the CE codepoint
   set.  The receiver then continues to set the ECE flag until it
   receives a packet with the Congestion Window Reduced (CWR) flag set.
   However, the DCTCP algorithm requires more-detailed congestion
   information.  In particular, the sender must be able to determine the
   number of bytes sent that encountered congestion.  Thus, the scheme
   described in [<a href="rfc3168.html" title='"The Addition of Explicit Congestion Notification (ECN) to IP"'>RFC3168</a>] does not suffice.

   One possible solution is to ACK every packet and set the ECE flag in
   the ACK if and only if the CE codepoint was set in the packet being
   acknowledged.  However, this prevents the use of delayed ACKs, which
   are an important performance optimization in data centers.  If the
   delayed ACK frequency is n, then an ACK is generated every n packets.



<span class="grey">Bensley, et al.               Informational                     [Page 5]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-6" id="page-6" name="page-6"> </a>
<span class="grey"><a href="rfc8257.html">RFC 8257</a>                          DCTCP                     October 2017</span>


   The typical value of n is 2, but it could be affected by ACK
   throttling or packet-coalescing techniques designed to improve
   performance.

   Instead, DCTCP introduces a new Boolean TCP state variable, DCTCP
   Congestion Encountered (DCTCP.CE), which is initialized to false and
   stored in the Transmission Control Block (TCB).  When sending an ACK,
   the ECE flag MUST be set if and only if DCTCP.CE is true.  When
   receiving packets, the CE codepoint MUST be processed as follows:

   1.  If the CE codepoint is set and DCTCP.CE is false, set DCTCP.CE to
       true and send an immediate ACK.

   2.  If the CE codepoint is not set and DCTCP.CE is true, set DCTCP.CE
       to false and send an immediate ACK.

   3.  Otherwise, ignore the CE codepoint.

   Since the immediate ACK reflects the new DCTCP.CE state, it may
   acknowledge any previously unacknowledged packets in the old state.
   This can lead to an incorrect rate computation at the sender per
   <a href="#section-3.3">Section 3.3</a>.  To avoid this, an implementation MAY choose to send two
   ACKs: one for previously unacknowledged packets and another
   acknowledging the most recently received packet.

   Receiver handling of the CWR bit is also per [<a href="rfc3168.html" title='"The Addition of Explicit Congestion Notification (ECN) to IP"'>RFC3168</a>] (including
   [<a href="#ref-Err3639" title="RFC 3168">Err3639</a>]).  That is, on receipt of a segment with both the CE and
   CWR bits set, CWR is processed first and then CE is processed.

                             Send immediate
                             ACK with ECE=0
                 .-----.     .--------------.     .-----.
    Send 1 ACK  /      v     v              |     |      \
     for every |     .------------.    .------------.     | Send 1 ACK
     n packets |     | DCTCP.CE=0 |    | DCTCP.CE=1 |     | for every
    with ECE=0 |     '------------'    '------------'     | n packets
                \      |     |              ^     ^      /  with ECE=1
                 '-----'     '--------------'     '-----'
                              Send immediate
                              ACK with ECE=1


                  Figure 1: ACK Generation State Machine








<span class="grey">Bensley, et al.               Informational                     [Page 6]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-7" id="page-7" name="page-7"> </a>
<span class="grey"><a href="rfc8257.html">RFC 8257</a>                          DCTCP                     October 2017</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.3.%20%20Processing%20Echoed%20Congestion%20Indications%20on%20the%20Sender"></a><a class="selflink" href="#section-3.3" name="section-3.3">3.3</a>.  Processing Echoed Congestion Indications on the Sender</span>

   The sender estimates the fraction of bytes sent that encountered
   congestion.  The current estimate is stored in a new TCP state
   variable, DCTCP.Alpha, which is initialized to 1 and SHOULD be
   updated as follows:

      DCTCP.Alpha = DCTCP.Alpha * (1 - g) + g * M

   where:

   o  g is the estimation gain, a real number between 0 and 1.  The
      selection of g is left to the implementation.  See <a href="#section-4">Section 4</a> for
      further considerations.

   o  M is the fraction of bytes sent that encountered congestion during
      the previous observation window, where the observation window is
      chosen to be approximately the Round-Trip Time (RTT).  In
      particular, an observation window ends when all bytes in flight at
      the beginning of the window have been acknowledged.

   In order to update DCTCP.Alpha, the TCP state variables defined in
   [<a href="https://tools.ietf.org/html/rfc0793" title='"Transmission Control Protocol"'>RFC0793</a>] are used, and three additional TCP state variables are
   introduced:

   o  DCTCP.WindowEnd: the TCP sequence number threshold when one
      observation window ends and another is to begin; initialized to
      SND.UNA.

   o  DCTCP.BytesAcked: the number of sent bytes acknowledged during the
      current observation window; initialized to 0.

   o  DCTCP.BytesMarked: the number of bytes sent during the current
      observation window that encountered congestion; initialized to 0.

   The congestion estimator on the sender MUST process acceptable ACKs
   as follows:

   1.  Compute the bytes acknowledged (TCP Selective Acknowledgment
       (SACK) options [<a href="rfc2018.html" title='"TCP Selective Acknowledgment Options"'>RFC2018</a>] are ignored for this computation):

          BytesAcked = SEG.ACK - SND.UNA

   2.  Update the bytes sent:

          DCTCP.BytesAcked += BytesAcked





<span class="grey">Bensley, et al.               Informational                     [Page 7]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-8" id="page-8" name="page-8"> </a>
<span class="grey"><a href="rfc8257.html">RFC 8257</a>                          DCTCP                     October 2017</span>


   3.  If the ECE flag is set, update the bytes marked:

          DCTCP.BytesMarked += BytesAcked

   4.  If the acknowledgment number is less than or equal to
       DCTCP.WindowEnd, stop processing.  Otherwise, the end of the
       observation window has been reached, so proceed to update the
       congestion estimate as follows:

   5.  Compute the congestion level for the current observation window:

          M = DCTCP.BytesMarked / DCTCP.BytesAcked

   6.  Update the congestion estimate:

          DCTCP.Alpha = DCTCP.Alpha * (1 - g) + g * M

   7.  Determine the end of the next observation window:

          DCTCP.WindowEnd = SND.NXT

   8.  Reset the byte counters:

          DCTCP.BytesAcked = DCTCP.BytesMarked = 0

   9.  Rather than always halving the congestion window as described in
       [<a href="rfc3168.html" title='"The Addition of Explicit Congestion Notification (ECN) to IP"'>RFC3168</a>], the sender SHOULD update cwnd as follows:

          cwnd = cwnd * (1 - DCTCP.Alpha / 2)

   Just as specified in [<a href="rfc3168.html" title='"The Addition of Explicit Congestion Notification (ECN) to IP"'>RFC3168</a>], DCTCP does not react to congestion
   indications more than once for every window of data.  The setting of
   the CWR bit is also as per [<a href="rfc3168.html" title='"The Addition of Explicit Congestion Notification (ECN) to IP"'>RFC3168</a>].  This is required for
   interoperation with classic ECN receivers due to potential
   misconfigurations.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.4.%20%20Handling%20of%20Congestion%20Window%20Growth"></a><a class="selflink" href="#section-3.4" name="section-3.4">3.4</a>.  Handling of Congestion Window Growth</span>

   A DCTCP sender grows its congestion window in the same way as
   conventional TCP.  Slow start and congestion avoidance algorithms are
   handled as specified in [<a href="rfc5681.html" title='"TCP Congestion Control"'>RFC5681</a>].

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.5.%20%20Handling%20of%20Packet%20Loss"></a><a class="selflink" href="#section-3.5" name="section-3.5">3.5</a>.  Handling of Packet Loss</span>

   A DCTCP sender MUST react to loss episodes in the same way as
   conventional TCP, including fast retransmit and fast recovery
   algorithms, as specified in [<a href="rfc5681.html" title='"TCP Congestion Control"'>RFC5681</a>].  For cases where the packet
   loss is inferred and not explicitly signaled by ECN, the cwnd and



<span class="grey">Bensley, et al.               Informational                     [Page 8]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-9" id="page-9" name="page-9"> </a>
<span class="grey"><a href="rfc8257.html">RFC 8257</a>                          DCTCP                     October 2017</span>


   other state variables like ssthresh MUST be changed in the same way
   that a conventional TCP would have changed them.  As with ECN, a
   DCTCP sender will only reduce the cwnd once per window of data across
   all loss signals.  Just as specified in [<a href="rfc5681.html" title='"TCP Congestion Control"'>RFC5681</a>], upon a timeout,
   the cwnd MUST be set to no more than the loss window (1 full-sized
   segment), regardless of previous cwnd reductions in a given window of
   data.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.6.%20%20Handling%20of%20SYN%2C%20SYN-ACK%2C%20and%20RST%20Packets"></a><a class="selflink" href="#section-3.6" name="section-3.6">3.6</a>.  Handling of SYN, SYN-ACK, and RST Packets</span>

   If SYN, SYN-ACK, and RST packets for DCTCP connections have the ECN-
   Capable Transport (ECT) codepoint set in the IP header, they will
   receive the same treatment as other DCTCP packets when forwarded by a
   switching fabric under load.  Lack of ECT in these packets can result
   in a higher drop rate, depending on the switching fabric
   configuration.  Hence, for DCTCP connections, the sender SHOULD set
   ECT for SYN, SYN-ACK, and RST packets.  A DCTCP receiver ignores CE
   codepoints set on any SYN, SYN-ACK, or RST packets.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/4.%20%20Implementation%20Issues"></a><a class="selflink" href="#section-4" name="section-4">4</a>.  Implementation Issues</span>

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.1.%20%20Configuration%20of%20DCTCP"></a><a class="selflink" href="#section-4.1" name="section-4.1">4.1</a>.  Configuration of DCTCP</span>

   An implementation needs to know when to use DCTCP.  Data-center
   servers may need to communicate with endpoints outside the data
   center, where DCTCP is unsuitable or unsupported.  Thus, a global
   configuration setting to enable DCTCP will generally not suffice.
   DCTCP provides no mechanism for negotiating its use.  Thus,
   additional management and configuration functionality is needed to
   ensure that DCTCP is not used with non-DCTCP endpoints.

   Known solutions rely on either configuration or heuristics.
   Heuristics need to allow endpoints to individually enable DCTCP to
   ensure a DCTCP sender is always paired with a DCTCP receiver.  One
   approach is to enable DCTCP based on the IP address of the remote
   endpoint.  Another approach is to detect connections that transmit
   within the bounds of a data center.  For example, an implementation
   could support automatic selection of DCTCP if the estimated RTT is
   less than a threshold (like 10 msec) and ECN is successfully
   negotiated under the assumption that if the RTT is low, then the two
   endpoints are likely in the same data-center network.

   [<a id="ref-RFC3168" name="ref-RFC3168">RFC3168</a>] forbids the ECN-marking of pure ACK packets because of the
   inability of TCP to mitigate ACK-path congestion.  <a href="rfc3168.html">RFC 3168</a> also
   forbids ECN-marking of retransmissions, window probes, and RSTs.
   However, dropping all these control packets -- rather than ECN-
   marking them -- has considerable performance disadvantages.  It is
   RECOMMENDED that an implementation provide a configuration knob that



<span class="grey">Bensley, et al.               Informational                     [Page 9]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-10" id="page-10" name="page-10"> </a>
<span class="grey"><a href="rfc8257.html">RFC 8257</a>                          DCTCP                     October 2017</span>


   will cause ECT to be set on such control packets, which can be used
   in environments where such concerns do not apply.  See
   [<a href="#ref-ECN-EXPERIMENTATION" title='"Explicit Congestion Notification (ECN) Experimentation"'>ECN-EXPERIMENTATION</a>] for details.

   It is useful to implement DCTCP as an additional action on top of an
   existing congestion control algorithm like Reno [<a href="rfc5681.html" title='"TCP Congestion Control"'>RFC5681</a>].  The DCTCP
   implementation MAY also allow configuration of resetting the value of
   DCTCP.Alpha as part of processing any loss episodes.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.2.%20%20Computation%20of%20DCTCP.Alpha"></a><a class="selflink" href="#section-4.2" name="section-4.2">4.2</a>.  Computation of DCTCP.Alpha</span>

   As noted in <a href="#section-3.3">Section 3.3</a>, the implementation will need to choose a
   suitable estimation gain.  [<a href="#ref-DCTCP10" title='"Data Center TCP (DCTCP)"'>DCTCP10</a>] provides a theoretical basis for
   selecting the gain.  However, it may be more practical to use
   experimentation to select a suitable gain for a particular network
   and workload.  A fixed estimation gain of 1/16 is used in some
   implementations.  (It should be noted that values of 0 or 1 for g
   result in problematic behavior; g=0 fixes DCTCP.Alpha to its initial
   value, and g=1 sets it to M without any smoothing.)

   The DCTCP.Alpha computation as per the formula in <a href="#section-3.3">Section 3.3</a>
   involves fractions.  An efficient kernel implementation MAY scale the
   DCTCP.Alpha value for efficient computation using shift operations.
   For example, if the implementation chooses g as 1/16, multiplications
   of DCTCP.Alpha by g become right-shifts by 4.  A scaling
   implementation SHOULD ensure that DCTCP.Alpha is able to reach 0 once
   it falls below the smallest shifted value (16 in the above example).
   At the other extreme, a scaled update needs to ensure DCTCP.Alpha
   does not exceed the scaling factor, which would be equivalent to
   greater than 100% congestion.  So, DCTCP.Alpha MUST be clamped after
   an update.

   This results in the following computations replacing steps 5 and 6 in
   <a href="#section-3.3">Section 3.3</a>, where SCF is the chosen scaling factor (65536 in the
   example), and SHF is the shift factor (4 in the example):

   1.  Compute the congestion level for the current observation window:

          ScaledM = SCF * DCTCP.BytesMarked / DCTCP.BytesAcked

   2.  Update the congestion estimate:

          if (DCTCP.Alpha &gt;&gt; SHF) == 0, then DCTCP.Alpha = 0

          DCTCP.Alpha += (ScaledM &gt;&gt; SHF) - (DCTCP.Alpha &gt;&gt; SHF)

          if DCTCP.Alpha &gt; SCF, then DCTCP.Alpha = SCF




<span class="grey">Bensley, et al.               Informational                    [Page 10]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-11" id="page-11" name="page-11"> </a>
<span class="grey"><a href="rfc8257.html">RFC 8257</a>                          DCTCP                     October 2017</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/5.%20%20Deployment%20Issues"></a><a class="selflink" href="#section-5" name="section-5">5</a>.  Deployment Issues</span>

   DCTCP and conventional TCP congestion control do not coexist well in
   the same network.  In typical DCTCP deployments, the marking
   threshold in the switching fabric is set to a very low value to
   reduce queueing delay, and a relatively small amount of congestion
   will exceed the marking threshold.  During such periods of
   congestion, conventional TCP will suffer packet loss and quickly and
   drastically reduce cwnd.  DCTCP, on the other hand, will use the
   fraction of marked packets to reduce cwnd more gradually.  Thus, the
   rate reduction in DCTCP will be much slower than that of conventional
   TCP, and DCTCP traffic will gain a larger share of the capacity
   compared to conventional TCP traffic traversing the same path.  If
   the traffic in the data center is a mix of conventional TCP and
   DCTCP, it is RECOMMENDED that DCTCP traffic be segregated from
   conventional TCP traffic.  [<a href="#ref-MORGANSTANLEY" title='"Attaining the Promise and Avoiding the Pitfalls of TCP in the Datacenter"'>MORGANSTANLEY</a>] describes a deployment
   that uses the IP Differentiated Services Codepoint (DSCP) bits to
   segregate the network such that Active Queue Management (AQM)
   [<a href="rfc7567.html" title='"IETF Recommendations Regarding Active Queue Management"'>RFC7567</a>] is applied to DCTCP traffic, whereas TCP traffic is managed
   via drop-tail queueing.

   Deployments should take into account segregation of non-TCP traffic
   as well.  Today's commodity switches allow configuration of different
   marking/drop profiles for non-TCP and non-IP packets.  Non-TCP and
   non-IP packets should be able to pass through such switches, unless
   they really run out of buffer space.

   Since DCTCP relies on congestion marking by the switches, DCTCP's
   potential can only be realized in data centers where the entire
   network infrastructure supports ECN.  The switches may also support
   configuration of the congestion threshold used for marking.  The
   proposed parameterization can be configured with switches that
   implement Random Early Detection (RED) [<a href="rfc2309.html" title='"Recommendations on Queue Management and Congestion Avoidance in the Internet"'>RFC2309</a>].  [<a href="#ref-DCTCP10" title='"Data Center TCP (DCTCP)"'>DCTCP10</a>] provides
   a theoretical basis for selecting the congestion threshold, but, as
   with the estimation gain, it may be more practical to rely on
   experimentation or simply to use the default configuration of the
   device.  DCTCP will revert to loss-based congestion control when
   packet loss is experienced (e.g., when transiting a congested drop-
   tail link, or a link with an AQM drop behavior).

   DCTCP requires changes on both the sender and the receiver, so both
   endpoints must support DCTCP.  Furthermore, DCTCP provides no
   mechanism for negotiating its use, so both endpoints must be
   configured through some out-of-band mechanism to use DCTCP.  A
   variant of DCTCP that can be deployed unilaterally and that only
   requires standard ECN behavior has been described in [<a href="#ref-ODCTCP" title='"Improving Transmission Performance with One- Sided Datacenter TCP"'>ODCTCP</a>] and
   [<a href="#ref-BSDCAN" title='"Extensions to FreeBSD Datacenter TCP for Incremental Deployment Support"'>BSDCAN</a>], but it requires additional experimental evaluation.




<span class="grey">Bensley, et al.               Informational                    [Page 11]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-12" id="page-12" name="page-12"> </a>
<span class="grey"><a href="rfc8257.html">RFC 8257</a>                          DCTCP                     October 2017</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/6.%20%20Known%20Issues"></a><a class="selflink" href="#section-6" name="section-6">6</a>.  Known Issues</span>

   DCTCP relies on the sender's ability to reconstruct the stream of CE
   codepoints received by the remote endpoint.  To accomplish this,
   DCTCP avoids using a single ACK packet to acknowledge segments
   received both with and without the CE codepoint set.  However, if one
   or more ACK packets are dropped, it is possible that a subsequent ACK
   will cumulatively acknowledge a mix of CE and non-CE segments.  This
   will, of course, result in a less-accurate congestion estimate.
   There are some potential considerations:

   o  Even with an inaccurate congestion estimate, DCTCP may still
      perform better than [<a href="rfc3168.html" title='"The Addition of Explicit Congestion Notification (ECN) to IP"'>RFC3168</a>].

   o  If the estimation gain is small relative to the packet loss rate,
      the estimate may not be too inaccurate.

   o  If ACK packet loss mostly occurs under heavy congestion, most
      drops will occur during an unbroken string of CE packets, and the
      estimate will be unaffected.

   However, the effect of packet drops on DCTCP under real-world
   conditions has not been analyzed.

   DCTCP provides no mechanism for negotiating its use.  The effect of
   using DCTCP with a standard ECN endpoint has been analyzed in
   [<a href="#ref-ODCTCP" title='"Improving Transmission Performance with One- Sided Datacenter TCP"'>ODCTCP</a>] and [<a href="#ref-BSDCAN" title='"Extensions to FreeBSD Datacenter TCP for Incremental Deployment Support"'>BSDCAN</a>].  Furthermore, it is possible that other
   implementations may also modify behavior in the [<a href="rfc3168.html" title='"The Addition of Explicit Congestion Notification (ECN) to IP"'>RFC3168</a>] style
   without negotiation, causing further interoperability issues.

   Much like standard TCP, DCTCP is biased against flows with longer
   RTTs.  A method for improving the RTT fairness of DCTCP has been
   proposed in [<a href="#ref-ADCTCP" title='"Analysis of DCTCP: Stability, Convergence, and Fairness"'>ADCTCP</a>], but it requires additional experimental
   evaluation.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/7.%20%20Security%20Considerations"></a><a class="selflink" href="#section-7" name="section-7">7</a>.  Security Considerations</span>

   DCTCP enhances ECN; thus, it inherits the general security
   considerations discussed in [<a href="rfc3168.html" title='"The Addition of Explicit Congestion Notification (ECN) to IP"'>RFC3168</a>], although additional mitigation
   options exist due to the limited intra-data-center deployment of
   DCTCP.

   The processing changes introduced by DCTCP do not exacerbate the
   considerations in [<a href="rfc3168.html" title='"The Addition of Explicit Congestion Notification (ECN) to IP"'>RFC3168</a>] or introduce new ones.  In particular,
   with either algorithm, the network infrastructure or the remote
   endpoint can falsely report congestion and, thus, cause the sender to
   reduce cwnd.  However, this is no worse than what can be achieved by
   simply dropping packets.



<span class="grey">Bensley, et al.               Informational                    [Page 12]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-13" id="page-13" name="page-13"> </a>
<span class="grey"><a href="rfc8257.html">RFC 8257</a>                          DCTCP                     October 2017</span>


   [<a id="ref-RFC3168" name="ref-RFC3168">RFC3168</a>] requires that a compliant TCP must not set ECT on SYN or
   SYN-ACK packets.  [<a href="rfc5562.html" title="&quot;Adding Explicit Congestion Notification (ECN) Capability to TCP's SYN/ACK Packets&quot;">RFC5562</a>] proposes setting ECT on SYN-ACK packets
   but maintains the restriction of no ECT on SYN packets.  Both these
   RFCs prohibit ECT in SYN packets due to security concerns regarding
   malicious SYN packets with ECT set.  However, these RFCs are intended
   for general Internet use; they do not directly apply to a controlled
   data-center environment.  The security concerns addressed by both of
   these RFCs might not apply in controlled environments like data
   centers, and it might not be necessary to account for the presence of
   non-ECN servers.  Beyond the security considerations related to
   virtual servers, additional security can be imposed in the physical
   servers to intercept and drop traffic resembling an attack.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/8.%20%20IANA%20Considerations"></a><a class="selflink" href="#section-8" name="section-8">8</a>.  IANA Considerations</span>

   This document does not require any IANA actions.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/9.%20%20References"></a><a class="selflink" href="#section-9" name="section-9">9</a>.  References</span>

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/9.1.%20%20Normative%20References"></a><a class="selflink" href="#section-9.1" name="section-9.1">9.1</a>.  Normative References</span>

   [<a id="ref-RFC0793" name="ref-RFC0793">RFC0793</a>]  Postel, J., "Transmission Control Protocol", STD 7,
              <a href="rfc793.html">RFC 793</a>, DOI 10.17487/RFC0793, September 1981,
              &lt;<a href="https://www.rfc-editor.org/info/rfc793">https://www.rfc-editor.org/info/rfc793</a>&gt;.

   [<a id="ref-RFC2018" name="ref-RFC2018">RFC2018</a>]  Mathis, M., Mahdavi, J., Floyd, S., and A. Romanow, "TCP
              Selective Acknowledgment Options", <a href="rfc2018.html">RFC 2018</a>,
              DOI 10.17487/RFC2018, October 1996,
              &lt;<a href="https://www.rfc-editor.org/info/rfc2018">https://www.rfc-editor.org/info/rfc2018</a>&gt;.

   [<a id="ref-RFC2119" name="ref-RFC2119">RFC2119</a>]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", <a href="https://tools.ietf.org/html/bcp14">BCP 14</a>, <a href="rfc2119.html">RFC 2119</a>,
              DOI 10.17487/RFC2119, March 1997,
              &lt;<a href="https://www.rfc-editor.org/info/rfc2119">https://www.rfc-editor.org/info/rfc2119</a>&gt;.

   [<a id="ref-RFC3168" name="ref-RFC3168">RFC3168</a>]  Ramakrishnan, K., Floyd, S., and D. Black, "The Addition
              of Explicit Congestion Notification (ECN) to IP",
              <a href="rfc3168.html">RFC 3168</a>, DOI 10.17487/RFC3168, September 2001,
              &lt;<a href="https://www.rfc-editor.org/info/rfc3168">https://www.rfc-editor.org/info/rfc3168</a>&gt;.

   [<a id="ref-RFC5562" name="ref-RFC5562">RFC5562</a>]  Kuzmanovic, A., Mondal, A., Floyd, S., and K.
              Ramakrishnan, "Adding Explicit Congestion Notification
              (ECN) Capability to TCP's SYN/ACK Packets", <a href="rfc5562.html">RFC 5562</a>,
              DOI 10.17487/RFC5562, June 2009,
              &lt;<a href="https://www.rfc-editor.org/info/rfc5562">https://www.rfc-editor.org/info/rfc5562</a>&gt;.






<span class="grey">Bensley, et al.               Informational                    [Page 13]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-14" id="page-14" name="page-14"> </a>
<span class="grey"><a href="rfc8257.html">RFC 8257</a>                          DCTCP                     October 2017</span>


   [<a id="ref-RFC5681" name="ref-RFC5681">RFC5681</a>]  Allman, M., Paxson, V., and E. Blanton, "TCP Congestion
              Control", <a href="rfc5681.html">RFC 5681</a>, DOI 10.17487/RFC5681, September 2009,
              &lt;<a href="https://www.rfc-editor.org/info/rfc5681">https://www.rfc-editor.org/info/rfc5681</a>&gt;.

   [<a id="ref-RFC8174" name="ref-RFC8174">RFC8174</a>]  Leiba, B., "Ambiguity of Uppercase vs Lowercase in <a href="rfc2119.html">RFC</a>
              <a href="rfc2119.html">2119</a> Key Words", <a href="https://tools.ietf.org/html/bcp14">BCP 14</a>, <a href="rfc8174.html">RFC 8174</a>, DOI 10.17487/RFC8174,
              May 2017, &lt;<a href="https://www.rfc-editor.org/info/rfc8174">https://www.rfc-editor.org/info/rfc8174</a>&gt;.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/9.2.%20%20Informative%20References"></a><a class="selflink" href="#section-9.2" name="section-9.2">9.2</a>.  Informative References</span>

   [<a id="ref-ADCTCP" name="ref-ADCTCP">ADCTCP</a>]   Alizadeh, M., Javanmard, A., and B. Prabhakar, "Analysis
              of DCTCP: Stability, Convergence, and Fairness",
              DOI 10.1145/1993744.1993753, Proceedings of the ACM
              SIGMETRICS Joint International Conference on Measurement
              and Modeling of Computer Systems, June 2011,
              &lt;<a href="https://dl.acm.org/citation.cfm?id=1993753">https://dl.acm.org/citation.cfm?id=1993753</a>&gt;.

   [<a id="ref-BSDCAN" name="ref-BSDCAN">BSDCAN</a>]   Kato, M., Eggert, L., Zimmermann, A., van Meter, R., and
              H. Tokuda, "Extensions to FreeBSD Datacenter TCP for
              Incremental Deployment Support", BSDCan 2015, June 2015,
              &lt;<a href="https://www.bsdcan.org/2015/schedule/events/559.en.html">https://www.bsdcan.org/2015/schedule/events/559.en.html</a>&gt;.

   [<a id="ref-DCTCP10" name="ref-DCTCP10">DCTCP10</a>]  Alizadeh, M., Greenberg, A., Maltz, D., Padhye, J., Patel,
              P., Prabhakar, B., Sengupta, S., and M. Sridharan, "Data
              Center TCP (DCTCP)", DOI 10.1145/1851182.1851192,
              Proceedings of the ACM SIGCOMM 2010 Conference, August
              2010,
              &lt;<a href="http://dl.acm.org/citation.cfm?doid=1851182.1851192">http://dl.acm.org/citation.cfm?doid=1851182.1851192</a>&gt;.

   [<a id="ref-ECN-EXPERIMENTATION" name="ref-ECN-EXPERIMENTATION">ECN-EXPERIMENTATION</a>]
              Black, D., "Explicit Congestion Notification (ECN)
              Experimentation", Work in Progress, <a href="https://tools.ietf.org/html/draft-ietf-tsvwg-ecn-experimentation-06">draft-ietf-tsvwg-ecn-</a>
              <a href="https://tools.ietf.org/html/draft-ietf-tsvwg-ecn-experimentation-06">experimentation-06</a>, September 2017.

   [<a id="ref-Err3639" name="ref-Err3639">Err3639</a>]  RFC Errata, Erratum ID 3639, <a href="rfc3168.html">RFC 3168</a>,
              &lt;<a href="https://www.rfc-editor.org/errata/eid3639">https://www.rfc-editor.org/errata/eid3639</a>&gt;.

   [<a id="ref-FREEBSD" name="ref-FREEBSD">FREEBSD</a>]  Kato, M. and H. Panchasara, "DCTCP (Data Center TCP)
              implementation", January 2015,
              &lt;<a href="https://github.com/freebsd/freebsd/commit/8ad879445281027858a7fa706d13e458095b595f">https://github.com/freebsd/freebsd/</a>
              <a href="https://github.com/freebsd/freebsd/commit/8ad879445281027858a7fa706d13e458095b595f">commit/8ad879445281027858a7fa706d13e458095b595f</a>&gt;.

   [<a id="ref-LINUX" name="ref-LINUX">LINUX</a>]    Borkmann, D., Westphal, F., and Glenn. Judd, "net: tcp:
              add DCTCP congestion control algorithm", LINUX DCTCP
              Patch, September 2014, &lt;<a href="https://git.kernel.org/cgit/linux/kernel/git/davem/net-next.git/commit/?id=e3118e8359bb7c59555aca60c725106e6d78c5ce">https://git.kernel.org/cgit/linux/</a>
              <a href="https://git.kernel.org/cgit/linux/kernel/git/davem/net-next.git/commit/?id=e3118e8359bb7c59555aca60c725106e6d78c5ce">kernel/git/davem/net-next.git/commit/</a>
              <a href="https://git.kernel.org/cgit/linux/kernel/git/davem/net-next.git/commit/?id=e3118e8359bb7c59555aca60c725106e6d78c5ce">?id=e3118e8359bb7c59555aca60c725106e6d78c5ce</a>&gt;.




<span class="grey">Bensley, et al.               Informational                    [Page 14]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-15" id="page-15" name="page-15"> </a>
<span class="grey"><a href="rfc8257.html">RFC 8257</a>                          DCTCP                     October 2017</span>


   [<a id="ref-MAPREDUCE" name="ref-MAPREDUCE">MAPREDUCE</a>]
              Dean, J. and S. Ghemawat, "MapReduce: Simplified Data
              Processing on Large Clusters", Proceedings of the 6th
              ACM/USENIX Symposium on Operating Systems Design and
              Implementation, October 2004, &lt;<a href="https://www.usenix.org/legacy/publications/library/proceedings/osdi04/tech/dean.html">https://www.usenix.org/</a>
              <a href="https://www.usenix.org/legacy/publications/library/proceedings/osdi04/tech/dean.html">legacy/publications/library/proceedings/osdi04/tech/</a>
              <a href="https://www.usenix.org/legacy/publications/library/proceedings/osdi04/tech/dean.html">dean.html</a>&gt;.

   [<a id="ref-MORGANSTANLEY" name="ref-MORGANSTANLEY">MORGANSTANLEY</a>]
              Judd, G., "Attaining the Promise and Avoiding the Pitfalls
              of TCP in the Datacenter", Proceedings of the 12th USENIX
              Symposium on Networked Systems Design and Implementation,
              May 2015, &lt;<a href="https://www.usenix.org/conference/nsdi15/technical-sessions/presentation/judd">https://www.usenix.org/conference/nsdi15/</a>
              <a href="https://www.usenix.org/conference/nsdi15/technical-sessions/presentation/judd">technical-sessions/presentation/judd</a>&gt;.

   [<a id="ref-ODCTCP" name="ref-ODCTCP">ODCTCP</a>]   Kato, M., "Improving Transmission Performance with One-
              Sided Datacenter TCP", M.S. Thesis, Keio University, 2013,
              &lt;<a href="http://eggert.org/students/kato-thesis.pdf">http://eggert.org/students/kato-thesis.pdf</a>&gt;.

   [<a id="ref-RFC2309" name="ref-RFC2309">RFC2309</a>]  Braden, B., Clark, D., Crowcroft, J., Davie, B., Deering,
              S., Estrin, D., Floyd, S., Jacobson, V., Minshall, G.,
              Partridge, C., Peterson, L., Ramakrishnan, K., Shenker,
              S., Wroclawski, J., and L. Zhang, "Recommendations on
              Queue Management and Congestion Avoidance in the
              Internet", <a href="rfc2309.html">RFC 2309</a>, DOI 10.17487/RFC2309, April 1998,
              &lt;<a href="https://www.rfc-editor.org/info/rfc2309">https://www.rfc-editor.org/info/rfc2309</a>&gt;.

   [<a id="ref-RFC7567" name="ref-RFC7567">RFC7567</a>]  Baker, F., Ed. and G. Fairhurst, Ed., "IETF
              Recommendations Regarding Active Queue Management",
              <a href="https://tools.ietf.org/html/bcp197">BCP 197</a>, <a href="rfc7567.html">RFC 7567</a>, DOI 10.17487/RFC7567, July 2015,
              &lt;<a href="https://www.rfc-editor.org/info/rfc7567">https://www.rfc-editor.org/info/rfc7567</a>&gt;.

   [<a id="ref-WINDOWS" name="ref-WINDOWS">WINDOWS</a>]  Microsoft, "Data Center Transmission Control Protocol
              (DCTCP)", May 2012, &lt;<a href="https://technet.microsoft.com/">https://technet.microsoft.com/</a>
              en-us/library/hh997028(v=ws.11).aspx&gt;.
















<span class="grey">Bensley, et al.               Informational                    [Page 15]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-16" id="page-16" name="page-16"> </a>
<span class="grey"><a href="rfc8257.html">RFC 8257</a>                          DCTCP                     October 2017</span>


Acknowledgments

   The DCTCP algorithm was originally proposed and analyzed in [<a href="#ref-DCTCP10" title='"Data Center TCP (DCTCP)"'>DCTCP10</a>]
   by Mohammad Alizadeh, Albert Greenberg, Dave Maltz, Jitu Padhye,
   Parveen Patel, Balaji Prabhakar, Sudipta Sengupta, and Murari
   Sridharan.

   We would like to thank Andrew Shewmaker for identifying the problem
   of clamping DCTCP.Alpha and proposing a solution for it.

   Lars Eggert has received funding from the European Union's Horizon
   2020 research and innovation program 2014-2018 under grant agreement
   No. 644866 ("SSICLOPS").  This document reflects only the authors'
   views and the European Commission is not responsible for any use that
   may be made of the information it contains.

Authors' Addresses

   Stephen Bensley
   Microsoft
   One Microsoft Way
   Redmond, WA  98052
   United States of America

   Phone: +1 425 703 5570
   Email: sbens@microsoft.com


   Dave Thaler
   Microsoft

   Phone: +1 425 703 8835
   Email: dthaler@microsoft.com


   Praveen Balasubramanian
   Microsoft

   Phone: +1 425 538 2782
   Email: pravb@microsoft.com











<span class="grey">Bensley, et al.               Informational                    [Page 16]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-17" id="page-17" name="page-17"> </a>
<span class="grey"><a href="rfc8257.html">RFC 8257</a>                          DCTCP                     October 2017</span>


   Lars Eggert
   NetApp
   Sonnenallee 1
   Kirchheim  85551
   Germany

   Phone: +49 151 120 55791
   Email: lars@netapp.com
   URI:   <a href="http://eggert.org/">http://eggert.org/</a>


   Glenn Judd
   Morgan Stanley

   Phone: +1 973 979 6481
   Email: glenn.judd@morganstanley.com



































Bensley, et al.               Informational                    [Page 17]

</pre><br/>
    <span class="noprint"><small><small>Html markup produced by rfcmarkup 1.127, available from
      <a href="https://tools.ietf.org/tools/rfcmarkup/">https://tools.ietf.org/tools/rfcmarkup/</a>
    </small></small></span>
  </div>




</body><!-- Mirrored from tools.ietf.org/html/rfc8257 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 14 Aug 2018 13:48:50 GMT --></html>