<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml"><!-- Mirrored from tools.ietf.org/html/rfc3760 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 06 Mar 2018 23:18:45 GMT --><!-- Added by HTTrack --><head><meta content="text/html;charset=utf-8" http-equiv="content-type"/><!-- /Added by HTTrack -->

    <meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
    <meta content="index,follow" name="robots"/>
    <meta content="rfcmarkup version 1.126" name="creator"/>
    <link href="http://purl.org/dc/elements/1.1/" rel="schema.DC"/>
<meta content="urn:ietf:rfc:3760" name="DC.Identifier"/>
<meta content="As the number, and more particularly the number of different types, of
devices connecting to the Internet increases, credential mobility
becomes an issue for IETF standardization. This document responds to
the requirements on protocols for secure exchange of credentials
listed in RFC 3157, by presenting an abstract protocol framework. This
memo provides information for the Internet community." name="DC.Description.Abstract"/>
<meta content="Just, Mike" name="DC.Creator"/>
<meta content="Nystrom, Magnus" name="DC.Creator"/>
<meta content="April, 2004" name="DC.Date.Issued"/>
<meta content="Securely Available Credentials (SACRED) - Credential Server Framework" name="DC.Title"/>

    <link href="https://tools.ietf.org/images/rfc.png" rel="icon" type="image/png"/>
    <link href="https://tools.ietf.org/images/rfc.png" rel="shortcut icon" type="image/png"/>
    <title>RFC 3760 - Securely Available Credentials (SACRED) - Credential Server Framework</title>
    
    
    <style type="text/css">
	@media only screen 
	  and (min-width: 992px)
	  and (max-width: 1199px) {
	    body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 768px)
	  and (max-width: 991px) {
            body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 480px)
	  and (max-width: 767px) {
            body { font-size: 11pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (max-width: 479px) {
            body { font-size: 8pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-device-width : 375px) 
	  and (max-device-width : 667px) {
            body { font-size: 9.5pt; }
            div.content { width: 96ex; margin: 0 1px; }
        }
	@media only screen 
	  and (min-device-width: 1200px) {
            body { font-size: 10pt; margin: 0 4em; }
            div.content { width: 96ex; margin: 0; }
        }
        h1, h2, h3, h4, h5, h6, .h1, .h2, .h3, .h4, .h5, .h6 {
	    font-weight: bold;
            line-height: 0pt;
            display: inline;
            white-space: pre;
            font-family: monospace;
            font-size: 1em;
	    font-weight: bold;
        }
        pre {
            font-size: 1em;
            margin-top: 0px;
            margin-bottom: 0px;
        }
	.pre {
	    white-space: pre;
	    font-family: monospace;
	}
	.header{
	    font-weight: bold;
	}
        .newpage {
            page-break-before: always;
        }
        .invisible {
            text-decoration: none;
            color: white;
        }
        a.selflink {
          color: black;
          text-decoration: none;
        }
        @media print {
            body {
                font-family: monospace;
                font-size: 10.5pt;
            }
            h1, h2, h3, h4, h5, h6 {
                font-size: 1em;
            }
        
            a:link, a:visited {
                color: inherit;
                text-decoration: none;
            }
            .noprint {
                display: none;
            }
        }
	@media screen {
	    .grey, .grey a:link, .grey a:visited {
		color: #777;
	    }
            .docinfo {
                background-color: #EEE;
            }
            .top {
                border-top: 7px solid #EEE;
            }
            .bgwhite  { background-color: white; }
            .bgred    { background-color: #F44; }
            .bggrey   { background-color: #666; }
            .bgbrown  { background-color: #840; }            
            .bgorange { background-color: #FA0; }
            .bgyellow { background-color: #EE0; }
            .bgmagenta{ background-color: #F4F; }
            .bgblue   { background-color: #66F; }
            .bgcyan   { background-color: #4DD; }
            .bggreen  { background-color: #4F4; }

            .legend   { font-size: 90%; }
            .cplate   { font-size: 70%; border: solid grey 1px; }
	}
    </style>
    <!--[if IE]>
    <style>
    body {
       font-size: 13px;
       margin: 10px 10px;
    }
    </style>
    <![endif]-->

    <script type="text/javascript"><!--
    function addHeaderTags() {
	var spans = document.getElementsByTagName("span");
	for (var i=0; i < spans.length; i++) {
	    var elem = spans[i];
	    if (elem) {
		var level = elem.getAttribute("class");
                if (level == "h1" || level == "h2" || level == "h3" || level == "h4" || level == "h5" || level == "h6") {
                    elem.innerHTML = "<"+level+">"+elem.innerHTML+"</"+level+">";		
                }
	    }
	}
    }
    var legend_html = "Colour legend:<br />      <table>         <tr><td>Unknown:</td>                   <td><span class='cplate bgwhite'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft:</td>                     <td><span class='cplate bgred'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Informational:</td>             <td><span class='cplate bgorange'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Experimental:</td>              <td><span class='cplate bgyellow'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Best Common Practice:</td>      <td><span class='cplate bgmagenta'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Proposed Standard:</td>         <td><span class='cplate bgblue'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft Standard (old designation):</td> <td><span class='cplate bgcyan'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Internet Standard:</td>         <td><span class='cplate bggreen'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Historic:</td>                  <td><span class='cplate bggrey'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Obsolete:</td>                  <td><span class='cplate bgbrown'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>     </table>";
    function showElem(id) {
        var elem = document.getElementById(id);
        elem.innerHTML = eval(id+"_html");
        elem.style.visibility='visible';
    }
    function hideElem(id) {
        var elem = document.getElementById(id);
        elem.style.visibility='hidden';        
        elem.innerHTML = "";
    }
    // -->
    </script>
</head>
<body onload="addHeaderTags()">
  <div class="content">
   <div style="height: 13px;">
      <div class="pre noprint docinfo bgorange" onclick="showElem('legend');" onmouseout="hideElem('legend')" onmouseover="this.style.cursor='pointer';" style="height: 6px; position: absolute;" title="Click for colour legend.">                                                                        </div>
      <div class="docinfo noprint pre legend" id="legend" onmouseout="hideElem('legend');" onmouseover="showElem('legend');" style="position:absolute; top: 4px; left: 4ex; visibility:hidden; background-color: white; padding: 4px 9px 5px 7px; border: solid #345 1px; ">
      </div>
   </div>
<span class="pre noprint docinfo top">[<a href="index.html" title="Document search and retrieval page">Docs</a>] [<a href="https://tools.ietf.org/rfc/rfc3760.txt" title="Plaintext version of this document">txt</a>|<a href="https://tools.ietf.org/pdf/rfc3760" title="PDF version of this document">pdf</a>] [<a href="https://tools.ietf.org/html/draft-ietf-sacred-framework" title="draft-ietf-sacred-framework">draft-ietf-sacr...</a>] [<a href="https://datatracker.ietf.org/doc/rfc3760" title="IESG Datatracker information for this document">Tracker</a>] [<a href="https://tools.ietf.org/rfcdiff?difftype=--hwdiff&amp;url2=rfc3760" title="Inline diff (wdiff)">Diff1</a>] [<a href="https://tools.ietf.org/rfcdiff?url2=rfc3760" title="Side-by-side diff">Diff2</a>]         </span><br/>
<span class="pre noprint docinfo">                                                                        </span><br/>
<span class="pre noprint docinfo">                                                           INFORMATIONAL</span><br/>
<span class="pre noprint docinfo">                                                                        </span><br/>
<pre>Network Working Group                                       D. Gustafson
Request for Comments: 3760                             Future Foundation
Category: Informational                                          M. Just
                                                Treasury Board of Canada
                                                              M. Nystrom
                                                            RSA Security
                                                              April 2004


 <span class="h1">Securely Available Credentials (SACRED) - Credential Server Framework</span>

Status of this Memo

   This memo provides information for the Internet community.  It does
   not specify an Internet standard of any kind.  Distribution of this
   memo is unlimited.

Copyright Notice

   Copyright (C) The Internet Society (2004).  All Rights Reserved.

Abstract

   As the number, and more particularly the number of different types,
   of devices connecting to the Internet increases, credential mobility
   becomes an issue for IETF standardization.  This document responds to
   the requirements on protocols for secure exchange of credentials
   listed in <a href="rfc3157.html">RFC 3157</a>, by presenting an abstract protocol framework.

Table of Contents

   <a href="#section-1">1</a>.  Introduction . . . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-2">2</a>
   <a href="#section-2">2</a>.  Functional Overview. . . . . . . . . . . . . . . . . . . . . .  <a href="#page-2">2</a>
       <a href="#section-2.1">2.1</a>.  Definitions. . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-2">2</a>
       <a href="#section-2.2">2.2</a>.  Credentials. . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-4">4</a>
       <a href="#section-2.3">2.3</a>.  Network Architecture . . . . . . . . . . . . . . . . . .  <a href="#page-5">5</a>
   <a href="#section-3">3</a>.  Protocol Framework . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-6">6</a>
       <a href="#section-3.1">3.1</a>.  Credential Upload. . . . . . . . . . . . . . . . . . . .  <a href="#page-8">8</a>
       <a href="#section-3.2">3.2</a>.  Credential Download. . . . . . . . . . . . . . . . . . . <a href="#page-10">10</a>
       <a href="#section-3.3">3.3</a>.  Credential Removal . . . . . . . . . . . . . . . . . . . <a href="#page-11">11</a>
       <a href="#section-3.4">3.4</a>.  Credential Management. . . . . . . . . . . . . . . . . . <a href="#page-12">12</a>
   <a href="#section-4">4</a>.  Protocol Considerations. . . . . . . . . . . . . . . . . . . . <a href="#page-12">12</a>
       <a href="#section-4.1">4.1</a>.  Secure Credential Formats. . . . . . . . . . . . . . . . <a href="#page-12">12</a>
       <a href="#section-4.2">4.2</a>.  Authentication Methods . . . . . . . . . . . . . . . . . <a href="#page-13">13</a>
       <a href="#section-4.3">4.3</a>.  Transport Protocol Suites. . . . . . . . . . . . . . . . <a href="#page-16">16</a>
   <a href="#section-5">5</a>.  Security Considerations. . . . . . . . . . . . . . . . . . . . <a href="#page-17">17</a>
       <a href="#section-5.1">5.1</a>.  Communications Security. . . . . . . . . . . . . . . . . <a href="#page-17">17</a>
       <a href="#section-5.2">5.2</a>.  Systems Security . . . . . . . . . . . . . . . . . . . . <a href="#page-18">18</a>



<span class="grey">Gustafson, et al.            Informational                      [Page 1]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-2" id="page-2" name="page-2"> </a>
<span class="grey"><a href="rfc3760.html">RFC 3760</a>        Securely Available Credentials (SACRED)       April 2004</span>


   <a href="#section-6">6</a>.  References . . . . . . . . . . . . . . . . . . . . . . . . . . <a href="#page-20">20</a>
       <a href="#section-6.1">6.1</a>.  Normative References . . . . . . . . . . . . . . . . . . <a href="#page-20">20</a>
       <a href="#section-6.2">6.2</a>.  Informative References . . . . . . . . . . . . . . . . . <a href="#page-20">20</a>
   <a href="#section-7">7</a>.  Authors' Addresses . . . . . . . . . . . . . . . . . . . . . . <a href="#page-21">21</a>
   <a href="#section-8">8</a>.  Full Copyright Statement . . . . . . . . . . . . . . . . . . . <a href="#page-22">22</a>

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/1%20Introduction"></a><a class="selflink" href="#section-1" name="section-1">1</a> Introduction</span>

   Digital credentials, such as private keys and corresponding
   certificates, are used to support various Internet protocols, e.g.,
   S/MIME, IPSec, and TLS.  In a number of environments end users wish
   to use the same credentials on different end-user devices.  In a
   "typical" desktop environment, the user already has many tools
   available to allow import/export of these credentials.  However, this
   is not very practical.  In addition, with some devices, especially
   wireless and other more constrained devices, the tools required
   simply do not exist.

   This document proposes a general framework for secure exchange of
   such credentials and provides a high level outline that will help
   guide the development of one or more securely available credentials
   (SACRED) credential exchange protocols.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/2.%20%20Functional%20Overview"></a><a class="selflink" href="#section-2" name="section-2">2</a>.  Functional Overview</span>

   Requirements for SACRED are fully described in [<a href="rfc3157.html" title='"Securely Available Credentials - Requirements"'>RFC3157</a>].  These
   requirements assume that two distinctly different network
   architectures will be created to support credential exchange for
   roaming users:

   a) Client/Server Credential Exchange
   b) Peer-to-Peer Credential Exchange

   This document describes the framework for one or more client/server
   credential exchange protocols.

   In all cases, adequate user authentication methods will be used to
   ensure credentials are not divulged to unauthorized parties.  As
   well, adequate server authentication methods will be used to ensure
   that each client's authentication information (see <a href="#section-2.1">Section 2.1</a>) is
   not compromised, and to ensure that roaming users interact with
   intended/authorized credential servers.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/2.1.%20%20Definitions"></a><a class="selflink" href="#section-2.1" name="section-2.1">2.1</a>.  Definitions</span>

   This section provides definitions for several terms or phrases used
   throughout this document.




<span class="grey">Gustafson, et al.            Informational                      [Page 2]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-3" id="page-3" name="page-3"> </a>
<span class="grey"><a href="rfc3760.html">RFC 3760</a>        Securely Available Credentials (SACRED)       April 2004</span>


   The key words "MUST", "MUST NOT", "SHOULD", "SHOULD NOT",
   "RECOMMENDED" and "MAY" in this document are to be interpreted as
   described in [<a href="rfc2119.html" title='"Key words for use in RFCs to Indicate Requirement Levels"'>RFC2119</a>].

   client authentication information: information that is presented by
           the client to a server to authenticate the client.  This may
           include a password token, a registration string that may have
           been received out-of-band (and possibly used for initially
           registering a roaming user) or data signed with a signature
           key belonging to the client (e.g., as part of TLS [<a href="rfc2246.html" title='"The TLS Protocol Version 1.0"'>RFC2246</a>]
           client authentication).

   credentials: cryptographic objects and related data used to support
           secure communications over the Internet.  Credentials may
           consist of public/private key pairs, symmetric keys, X.509
           public key certificates, attribute certificates, and/or
           application data.  Several standardized formats for the
           representation of credentials exist, e.g., [<a href="#ref-PKCS12" title='"PKCS 12 v1.0: Personal Information Exchange Syntax"'>PKCS12</a>], [<a href="#ref-PKCS15" title='"PKCS #15 v1.1: Cryptographic Token Information Syntax Standard"'>PKCS15</a>]
           (see "secured credentials" below).

   passkey: a symmetric key, derived from a password.

   password: a string of characters known only to a client and used for
           the purposes of authenticating to a server and/or securing
           credentials.  A user may be required to remember more than
           one password.

   password token: a value derived from a password using a one-way
           function that may be used by a client to authenticate to a
           server.  A password token may be derived from a password
           using a one-way hash function, for example.

   secured credentials: a set of one or more credentials that have been
           cryptographically secured, e.g., encrypted/MACed with a
           passkey.  Secured credentials may be protected using more
           than one layer of encryption, e.g., the credential is secured
           with a passkey corresponding to a user's password and also by
           a key known only to the server (the credential's stored
           form).  During network transfer, the passkey-protected
           credential may be protected with an additional encryption
           layer using a symmetric key chosen by the Credential Server
           (e.g., the transmitted form).

   strong password protocol: a protocol that authenticates clients to
           servers securely (see e.g., [<a href="#ref-SPEKE" title='"Strong Password-Only Authenticated Key Exchange"'>SPEKE</a>] for a more detailed
           definition of this), where the client need only memorize a
           small secret (a password) and carries no other secret
           information, and where the server carries a verifier



<span class="grey">Gustafson, et al.            Informational                      [Page 3]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-4" id="page-4" name="page-4"> </a>
<span class="grey"><a href="rfc3760.html">RFC 3760</a>        Securely Available Credentials (SACRED)       April 2004</span>


           (password token) which allows it to authenticate the client.
           A shared secret is negotiated between client and server and
           is used to protect data subsequently exchanged.

   Note the distinction between an "account password" and a "credential
   password."  An account password (and corresponding password token) is
   used to authenticate to a Credential Server and to negotiate a key
   that provides session level encryption between client and server.

   A credential password is used to derive a passkey that's used to
   provide persistent encryption and authentication for a stored
   credential.  Applicable secured credential standards documents (e.g.,
   [<a href="#ref-PKCS15" title='"PKCS #15 v1.1: Cryptographic Token Information Syntax Standard"'>PKCS15</a>]) describe the technical details of specific password-based-
   encryption (pbe) techniques that are used to protect credentials from
   unauthorized use.

   Although the same password value may be used to provide both
   services, it is likely that different, algorithm specific passkeys
   would be generated from this password (i.e., because of different
   salt values, etc.).

   In addition, although it may be more convenient for a user to
   remember only a single password, differing security policies (e.g.,
   password rules) between the credential server and the credential
   issuers may result in a user having to remember multiple passwords.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/2.2.%20%20Credentials"></a><a class="selflink" href="#section-2.2" name="section-2.2">2.2</a>.  Credentials</span>

   This document is concerned with the secure exchange and online
   management of credentials in a roaming or mobile environment.
   Credentials MAY be usable with any end user device that can connect
   to the Internet, such as:

   - desktop or laptop PC
   - mobile phone
   - personal digital assistant (PDA)
   - etc.

   The end user system may, optionally, store its credential information
   on special hardware devices that provide enhanced portability and
   protection for user credentials.

   Since the credential usually contains sensitive information that is
   known only to the credential holder, credentials MUST NOT be sent in
   the clear during network transmission and SHOULD NOT be in the clear
   when stored on an end user device such as a diskette or hard drive.
   For this reason, a secured credential is defined.  Throughout this
   document we assume that, at least from the point of view of the



<span class="grey">Gustafson, et al.            Informational                      [Page 4]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-5" id="page-5" name="page-5"> </a>
<span class="grey"><a href="rfc3760.html">RFC 3760</a>        Securely Available Credentials (SACRED)       April 2004</span>


   protocol, a secured credential is an opaque (and at least partially
   privacy and integrity protected) data object that can be used by a
   network connected device.  Once downloaded, clients must be able to
   recover their credentials from this opaque format.

   At a minimum, all supported credential formats SHOULD provide privacy
   and integrity protection for private keys, secret keys, and any other
   data objects that must be protected from disclosure or modification.
   Typically, these security capabilities are part of the basic
   credential format such that the credential (e.g., a data file) is
   protected when stored on hard drives, flexible diskettes, etc.

   During network transmission, the secured credential is protected with
   a second (outer) encryption layer.  The outer encryption layer is
   created using a session-level encryption key that was derived during
   the mutual authentication process.  Effectively, secured credentials
   traverse an "encrypted tunnel" that provides an additional layer of
   privacy protection for credentials (and any other) information
   exchanged.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/2.3.%20%20Network%20Architecture"></a><a class="selflink" href="#section-2.3" name="section-2.3">2.3</a>.  Network Architecture</span>

   The network diagram below shows the components involved in the SACRED
   client/server framework.

                     +--------+           +------------+
                     | Client +-----------| Credential |
                     +--------+     1     |   Server   |
                          \               +-----+------+
                           \                    |
                            \                   | 2
                             \                  |
                              \    3      +-----+------+
                               -----------| Credential |
                                          |  Store(s)  |
                                          +------------+

   Client - The entity that wants to retrieve their credentials from a
            credential server.

   Credential Server - The server that downloads secure credentials to
            and uploads them from the client.  The server is responsible
            for authenticating the client to ensure that the secured
            credentials are exchanged only with an appropriate end user.
            The credential server is authenticated to the client to
            ensure that the client's authentication information is not
            compromised and so that the user can trust the credentials
            retrieved.



<span class="grey">Gustafson, et al.            Informational                      [Page 5]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-6" id="page-6" name="page-6"> </a>
<span class="grey"><a href="rfc3760.html">RFC 3760</a>        Securely Available Credentials (SACRED)       April 2004</span>


   Credential Store - The repository for secured credentials.  There
            might be access control features but those generally aren't
            sufficient in themselves for securing credentials.  The
            credential server may be capable of splitting credentials
            across multiple credential stores for redundancy or to
            provide additional levels of protection for user
            credentials.

   Protocol 1 - The protocol used to authenticate the client and
            credential server, and download and upload user credentials
            from a credential server.

   Protocol 2 - The protocol used by the Credential Server to store and
            retrieve user credentials (LDAP, LDAP/SSL, or other).

   Protocol 3 - The protocol used by the client to store and retrieve
            user credentials from the credential store (LDAP, LDAP/SSL,
            or other).

   This framework describes the high level design for protocol 1.
   Protocols 2 and 3 are closely related (but out of scope for this
   document) and could be implemented using standard protocols, such as
   LDAP or secure LDAP, or other standard or proprietary protocols.
   Note also that any administrator-credential server protocols are
   assumed to be server vendor specific and are not the subject of
   SACRED standardization efforts at this time.

   Clients are not precluded from exchanging credentials directly with a
   credential store (or any other server of it's choosing).  However,
   mutual authentication with roaming users and a consistent level of
   protection for credential data while stored on network servers and
   while in transit is provided by SACRED protocols exchanged with the
   credential server.  Depending on credential server design, user
   credentials may flow through the credential server to the credential
   store or directly between the client and the credential store.

   Also, users may upload their credentials to several credential
   servers to obtain enhanced levels of availability.  Coordination
   (automatic replication) of user information or credential data among
   several credential servers is currently beyond the scope of this
   document.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/3.%20%20Protocol%20Framework"></a><a class="selflink" href="#section-3" name="section-3">3</a>.  Protocol Framework</span>

   This section provides a high level description of client/server
   protocols that can be used to exchange and manage SACRED credentials.





<span class="grey">Gustafson, et al.            Informational                      [Page 6]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-7" id="page-7" name="page-7"> </a>
<span class="grey"><a href="rfc3760.html">RFC 3760</a>        Securely Available Credentials (SACRED)       April 2004</span>


   The client/server credential exchange protocol is based on three
   basic and abstract operations; "GET", "PUT", and "DELETE".  The
   secured credential exchange protocol is accomplished as follows:

      connect - the client initiates a connection to a credential server
              for the purpose of secure credential exchange.

      mutual authentication/key negotiation - using a strong password
              protocol (or equivalent) the client authenticates to the
              server, the server authenticates to the client, and a
              session level encryption key is negotiated.  The details
              of the mutual authentication protocol exchange are
              dependent upon the particular authentication method used.
              In all cases, the end result is to authenticate the client
              to the server and server to the client, and establish a
              strong, shared secret between the two parties.

      client request(s) - the SACRED client issues one or more high
              level credential exchange requests (e.g., GET, PUT, or
              DELETE).

      server response(s) - the SACRED credential server responds to each
              request, either performing the operation successfully or
              indicating an appropriate error.

      close - the client indicates it has no more requests for the
              server at this time.  The security context between client
              and server is no longer needed.  Close is a logical,
              session management operation.

      disconnect - the parties disconnect the transport level connection
              between client and server.  Note that "connect" and
              "disconnect" are logical, transport-layer dependent
              operations that enclose the protocol exchange between the
              two communicating processes.

      Each high-level credential exchange operation is made up of a
      series of request-response pairs.  The client initiates each
      request, which the server processes before returning an
      appropriate response.  Each request must complete (server reports
      success or failure) before the client issues the next request. The
      server SHOULD be willing to service at least one upload or
      download request following successful mutual authentication but
      either party can terminate the logical connection at any time.







<span class="grey">Gustafson, et al.            Informational                      [Page 7]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-8" id="page-8" name="page-8"> </a>
<span class="grey"><a href="rfc3760.html">RFC 3760</a>        Securely Available Credentials (SACRED)       April 2004</span>


   In the following sections, secured credentials and related values are
   represented using the following notation:

      SC-x is the secured credential file, which includes a format
              identifier field and credential data.  The credential data
              is an opaque, encrypted data object (e.g., PKCS#15 or
              PKCS#12 file).  The format identifier is needed to
              correctly parse the credential data.

      Name-x is an account-defined selector or locator (a user friendly
              name) that is used to indicate a specific secured
              credential.  The name of each credential stored under a
              given user account MUST be unique e.g., there may be one
              credential called "financial" and another called
              "healthcare", etc.  At a minimum, credential names MUST be
              unique across a given account/user name.  When no name is
              supplied for a GET operation, all credentials stored for
              the given username will be returned.

      ID-x is a distinct credential version indicator that MAY be used
              to request a conditional GET/PUT/DELETE operation.  This
              credential-ID value SHOULD contain the server's "last-
              modified" date and time (e.g., the time that this
              particular credential version was stored on the server)
              and MAY contain additional information such as a sequence
              number or a (complete or partial) credential fingerprint
              that is used to ensure the credential-ID is unique from
              other credential versions stored under the same user
              account and credential name.

   All named credentials may be accessed by authenticating under a
   single username.  If a user needs or prefers to use more than one
   distinct authentication password (and/or authentication method) to
   protect access to several secured credentials, he/she SHOULD register
   those credentials under distinct user/account names, one for each
   different authentication method used.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.1.%20%20Credential%20Upload"></a><a class="selflink" href="#section-3.1" name="section-3.1">3.1</a>.  Credential Upload</span>

   The purpose of a credential upload operation is to allow a client to
   register new credentials, or replace currently stored credentials
   (e.g., credentials that may have been updated by the client using
   appropriate key management software).








<span class="grey">Gustafson, et al.            Informational                      [Page 8]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-9" id="page-9" name="page-9"> </a>
<span class="grey"><a href="rfc3760.html">RFC 3760</a>        Securely Available Credentials (SACRED)       April 2004</span>


   The framework for the credential upload, as implemented using the PUT
   operation, is:

   -  The client and server establish a mutually authenticated session
      and negotiate a shared secret.

   -  The client will then issue a PUT message that contains the upload
      credential and related data fields.

   -  The server will respond to the PUT, indicating the credential was
      successfully stored on the server or that an error occurred.

   The client's PUT request MAY contain an optional identifier
   (credential-ID) field.  If present, the new credential will only be
   stored if a credential with the same name and credential-ID is
   currently stored on the server (e.g., a logical REPLACE operation is
   performed).  The server MUST return an error if a client attempts to
   replace a credential that does not exist on the server.

   The credential server's response to a PUT request MUST contain a
   credential version identifier (credential-ID) for the newly stored
   credential that MAY be used by clients to optimize subsequent
   download operations and avoid credential version mismatches.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/3.1.1.%20%20Credential%20Upload%20Protocol%20Sequence"></a><a class="selflink" href="#section-3.1.1" name="section-3.1.1">3.1.1</a>.  Credential Upload Protocol Sequence</span>

   The following gives an example of a "credential upload" protocol
   sequence:

        client                               server
        -------                              -------

        &lt; connect &gt;                  --&gt;

        &lt;--- mutual authentication ---&gt;

        &lt; PUT SC-1, Name-1, [ID-1] &gt; --&gt;
                                     &lt;--     &lt; Name-1, new-ID-1 &gt;
        &lt; PUT SC-2, Name-2, [ID-2] &gt; --&gt;
                                     &lt;--     &lt; Name-2, new-ID-2 &gt;

                                     ...

        &lt; close &gt;                    --&gt;
                                     &lt;--     OK (+ disconnect)

   new-ID-x is the credential-ID of the newly stored credential.




<span class="grey">Gustafson, et al.            Informational                      [Page 9]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-10" id="page-10" name="page-10"> </a>
<span class="grey"><a href="rfc3760.html">RFC 3760</a>        Securely Available Credentials (SACRED)       April 2004</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.2.%20%20Credential%20Download"></a><a class="selflink" href="#section-3.2" name="section-3.2">3.2</a>.  Credential Download</span>

   Roaming clients can download their credentials at any time after they
   have been uploaded to the server.

   The framework for a credential download, as implemented using the GET
   operation, is:

   -  The client SHOULD authenticate the server.

   -  The user MUST be authenticated (by the server).

   -  A GET request for the credential download is issued.

   -  The response contains the credential and format identifier.

   The specific user credential being requested may be identified by
   name in the message sent to the credential server.  If successful,
   the response MUST contain the requested credential data element
   (format ID and data) as defined above.

   If the user issues a GET request with a NULL credential name field,
   the server SHOULD return all credentials stored under the current
   user account.

   Optionally, the client MAY include a credential-ID to indicate a
   conditional download request.  In this case, the server will return
   the requested credential if and only if the ID of the credential
   currently stored on the server does NOT match the ID specified.

   The server should return either the requested credential or a
   distinct response indicating that the conditional download was not
   performed (e.g., the client already has a copy of this exact
   credential).

















<span class="grey">Gustafson, et al.            Informational                     [Page 10]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-11" id="page-11" name="page-11"> </a>
<span class="grey"><a href="rfc3760.html">RFC 3760</a>        Securely Available Credentials (SACRED)       April 2004</span>


<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/3.2.1.%20%20Credential%20Download%20Protocol%20Sequence"></a><a class="selflink" href="#section-3.2.1" name="section-3.2.1">3.2.1</a>.  Credential Download Protocol Sequence</span>

   The following gives an example of a "credential download" protocol
   sequence:

          client                      server
          -------                    --------

        &lt; connect &gt;            --&gt;

        &lt;--- mutual authentication --&gt;

        &lt; GET Name-1, [ID-1] &gt;  --&gt;
                               &lt;--     &lt; SC-1, ID-1' &gt;
        &lt; GET Name-2, [ID-2] &gt;  --&gt;
                               &lt;--     &lt; GET response &gt;

                               ...

        &lt; close &gt;              --&gt;
                               &lt;--     OK (+ disconnect)

   Notice that for the second request, no credential has been returned
   since ID-2, as included in the client's request, matched the
   identifier for the Name-2 credential.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.3.%20%20Credential%20Removal"></a><a class="selflink" href="#section-3.3" name="section-3.3">3.3</a>.  Credential Removal</span>

   The framework for the credential removal, as implemented with the
   DELETE operation, is:

   -  The credential server MUST be authenticated (by the client) using
      a method-dependent protocol sequence.

   -  The user MUST be authenticated (by the server) using a method-
      dependent protocol sequence.

   -  The user then sends a DELETE request message that contains the
      credential name indicating which credential to remove.

   -  Optionally, the client may include a credential-ID in the DELETE
      request.  In this case, the credential will be deleted if the
      request ID matches the ID of the credential currently stored on
      the server.  This may be done to ensure that a client intending to
      delete their stored credential does not mistakenly delete a
      different version of the credential.





<span class="grey">Gustafson, et al.            Informational                     [Page 11]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-12" id="page-12" name="page-12"> </a>
<span class="grey"><a href="rfc3760.html">RFC 3760</a>        Securely Available Credentials (SACRED)       April 2004</span>


<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/3.3.1.%20%20Credential%20Removal%20Protocol%20Sequence"></a><a class="selflink" href="#section-3.3.1" name="section-3.3.1">3.3.1</a>.  Credential Removal Protocol Sequence</span>

   The following gives an example of a "credential removal" protocol
   sequence:

         client                            server
         -------                          --------

       &lt; connect &gt;               --&gt;

       &lt;-------- mutual authentication --------&gt;

       &lt; DEL Name-1, [ID1] &gt;     --&gt;
                                 &lt;--     &lt; Name-1 deleted &gt;
       &lt; DEL Name-2, [ID2] &gt;     --&gt;
                                 &lt;--     &lt; Name-2 deleted &gt;

                                 ...

       &lt; close &gt;                 --&gt;
                                 &lt;--     OK (+ disconnect)

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.4.%20%20Credential%20Management"></a><a class="selflink" href="#section-3.4" name="section-3.4">3.4</a>.  Credential Management</span>

   Note that the three operations defined above (GET, PUT, DELETE) can
   be used to perform the basic credential management operations:

   -  add a new credential on the server,
   -  update (replace) an existing credential, and
   -  delete an existing credential.

   The information provided for these basic operations might be used to
   help guide the design of more complex operations such as user
   registration (add account), user deregistration (remove account),
   change account password, or list all credentials.

   Note that, in the case where a credential with the same name exists
   on the server, uploading a NULL credential is logically equivalent to
   removing a previously stored credential.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/4.%20%20Protocol%20Considerations"></a><a class="selflink" href="#section-4" name="section-4">4</a>.  Protocol Considerations</span>

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.1.%20%20Secure%20Credential%20Formats"></a><a class="selflink" href="#section-4.1" name="section-4.1">4.1</a>.  Secure Credential Formats</span>

   To ensure that credentials created on, and uploaded from, one device
   can be downloaded and used on any other device, there is a need to
   define a single "mandatory to implement" credential format that must
   be supported by all conforming client implementations.



<span class="grey">Gustafson, et al.            Informational                     [Page 12]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-13" id="page-13" name="page-13"> </a>
<span class="grey"><a href="rfc3760.html">RFC 3760</a>        Securely Available Credentials (SACRED)       April 2004</span>


   At least two well-defined credential formats are available today:
   [<a href="#ref-PKCS12" title='"PKCS 12 v1.0: Personal Information Exchange Syntax"'>PKCS12</a>] and [<a href="#ref-PKCS15" title='"PKCS #15 v1.1: Cryptographic Token Information Syntax Standard"'>PKCS15</a>].

   Other optional credential formats may also be supported if necessary.
   For example, additional credential formats might be defined for use
   with specific (compatible) client devices.  Each credential format
   MUST provide adequate privacy protection for user credentials when
   they are stored on flexible diskettes, hard disks, etc.

   Throughout this document, the credential is treated as an opaque
   (encrypted) data object and, as such, the credential format does not
   affect the basic credential exchange protocol.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.2.%20%20Authentication%20Methods"></a><a class="selflink" href="#section-4.2" name="section-4.2">4.2</a>.  Authentication Methods</span>

   Authentication is vitally important to ensure that credentials are
   accepted from and delivered to the authorized end user only.  If an
   unsecured credential is delivered to some other party, the credential
   may be more easily compromised.  If a credential is accepted from an
   unauthorized party, the user might be tricked into using a credential
   that has been substituted by an attacker (e.g., an attacker might
   replace a newer credential with an older credential belonging to the
   same user).

   Ideally, the list of authentication methods should be open ended,
   allowing new methods to be added as needs are identified and as they
   become available.  For all credentials, the user authentication
   method and data is defined when a user is first registered with the
   credential server and may be updated from time to time thereafter by
   the authorized user.

   To adequately protect user credentials from unauthorized disclosure
   or modification in a roaming environment, all SACRED authentication
   methods MUST provide protection for user credentials in network
   environments where attackers might attempt to exploit potential
   security vulnerabilities.  See SACRED Requirements [<a href="rfc3157.html" title='"Securely Available Credentials - Requirements"'>RFC3157</a>], <a href="#section-3.1">Section</a>
   <a href="#section-3.1">3.1</a>, Vulnerabilities.

   At a minimum, each SACRED authentication method SHOULD ensure that:

         -  The server authenticates the client
         -  The client authenticates the server
         -  The client and server securely negotiate (or derive) a
            cryptographically strong, secret key (e.g., a session key).
         -  The exchange of one or more user credentials is protected
            using this session key.





<span class="grey">Gustafson, et al.            Informational                     [Page 13]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-14" id="page-14" name="page-14"> </a>
<span class="grey"><a href="rfc3760.html">RFC 3760</a>        Securely Available Credentials (SACRED)       April 2004</span>


   It is expected that all SACRED client/server protocols will provide
   each of these basic security functions.  Some existing authentication
   protocols that might be used for this purpose include:

   -  Strong password protocols
   -  TLS

   Sections <a href="#section-4.2.1">4.2.1</a> and <a href="#section-4.2.2">4.2.2</a> provide some guidance about when to use
   these authentication methods based on the generic security
   capabilities they provide and the security elements (passwords, key
   pairs, user certificates, CA certificates) that must be available to
   the SACRED client.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/4.2.1.%20%20Strong%20Password%20Protocols"></a><a class="selflink" href="#section-4.2.1" name="section-4.2.1">4.2.1</a>.  Strong Password Protocols</span>

   Strong password protocols such as those described in [<a href="rfc2945.html" title='"The SRP Authentication and Key Exchange System"'>RFC2945</a>],
   [<a href="#ref-BM92" title='"Encrypted Key Exchange: Password-based protocols secure against dictionary attacks"'>BM92</a>], [<a href="#ref-BM94" title="S. and M. Merritt">BM94</a>], and [<a href="#ref-SPEKE" title='"Strong Password-Only Authenticated Key Exchange"'>SPEKE</a>] MAY be used to provide mutual
   authentication and privacy for SACRED protocols.

   All strong password protocols require that user-specific values
   (i.e., a passtoken and related values) be configured within the
   server.  Only a party who knows the password can calculate the
   verifier value.  It must be securely delivered to the server at a
   time when the client establishes a relationship with the server.  At
   connect time, messages are exchanged between the two parties and
   complementary algorithms are used to compute a shared common value
   known only to the legitimate user and the server.  Both parties
   derive a strong (symmetric) key that may be used to secure
   communications between the two parties.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/4.2.2.%20%20TLS%20Authentication"></a><a class="selflink" href="#section-4.2.2" name="section-4.2.2">4.2.2</a>.  TLS Authentication</span>

   TLS authentication may either be mutual between the client and server
   or unilateral where only the server is authenticated to the client.
   These options are described in the next two subsections.

   In both cases, TLS can be used to authenticate the server whenever
   the TLS client has been pre-configured with the necessary
   certificates needed to validate the server's certificate chain
   (including revocation status checking).

   TLS Server Authentication (sTLS)

   TLS provides a basic secure session capability (sometimes called
   server-side TLS) whereby the client authenticates the server and a
   pair of session level encryption keys is securely exchanged between





<span class="grey">Gustafson, et al.            Informational                     [Page 14]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-15" id="page-15" name="page-15"> </a>
<span class="grey"><a href="rfc3760.html">RFC 3760</a>        Securely Available Credentials (SACRED)       April 2004</span>


   client and server.  Following server authentication and security
   context setup, all client requests and server responses exchanged are
   integrity and privacy protected.

   Protocol designers and implementors should be aware that the
   flexibility of the certificate-based TLS server authentication method
   creates security risks that need to be mitigated.  Specifically, the
   need to ensure the user is connected to the intended credential
   server (secure site), and no other.  The TLS v1.0 standard [<a href="rfc2246.html" title='"The TLS Protocol Version 1.0"'>RFC2246</a>]
   identifies the basis for managing this risk in section F.3 (see also
   <a href="#section-5.2">Section 5.2</a> in this document):

      "Implementations and users must be careful when deciding which
      certificates and certificate authorities are acceptable; a
      dishonest certificate authority can do tremendous damage."

   Note also that a faulty implementation of (increasingly complex) TLS
   server certificate chain processing, by the SACRED client, could lead
   to similar compromise, allowing successful credential server
   masquerade or man-in-the-middle attacks.

   An engineering approach that provides an enhanced or augmented server
   authentication method may be warranted for SACRED protocol designs.
   It is also important to understand that simple layering of
   independently developed security protocols (e.g., using BEEP or
   similar layering techniques) produces a complex, multilayer security
   protocol that might be easily defeated by a combination-specific
   attack that is able to expose and exploit known weaknesses of the
   individual protocol(s).

   When necessary, and after a TLS session has been established between
   the two parties, the credential server can request that the client
   provide her user id and password information to authenticate the
   remote user.  Preferably, client and server can cooperate to perform
   an authentication operation that allows the server to authenticate
   the client (and perhaps vice-versa) in a "zero knowledge manner".  In
   such cases, the client need not have a security credential.

   TLS with Client Authentication (cTLS)

   TLS provides an optional, secure session capability (sometimes called
   client-side TLS) whereby the TLS server can request client
   authentication by verifying the client's digital signature.

   In order to use cTLS to provide mutual authentication, the client
   must also be configured with at least one security credential that is
   acceptable to the TLS server for remote client authentication
   purposes.



<span class="grey">Gustafson, et al.            Informational                     [Page 15]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-16" id="page-16" name="page-16"> </a>
<span class="grey"><a href="rfc3760.html">RFC 3760</a>        Securely Available Credentials (SACRED)       April 2004</span>


<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/4.2.3.%20%20Other%20Authentication%20Methods"></a><a class="selflink" href="#section-4.2.3" name="section-4.2.3">4.2.3</a>.  Other Authentication Methods</span>

   Other authentication methods that provide the necessary security
   capabilities MAY also be suitable for use with SACRED credential
   exchange protocols.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.3.%20%20Transport%20Protocol%20Suites"></a><a class="selflink" href="#section-4.3" name="section-4.3">4.3</a>.  Transport Protocol Suites</span>

   It is intended that one or more underlying protocol stacks may carry
   the SACRED credential exchange protocols.  It is recognized at the
   outset that the use of several underlying protocol suites, although
   not ideal from an interoperability standpoint, may well be required
   to support the wide variety of needs anticipated.

   The SACRED list members have discussed several protocol suites that
   have been considered on their technical merits, each with distinct
   benefits and protocol design/implementation costs.  Among these
   protocols are:

      - TCP
      - BEEP
      - HTTP

   All protocol suites listed here depend on TCP to provide a reliable,
   end-to-end transport layer protocol.  Each of these building block
   approaches provides a different way of handling the remaining
   application layer issues (basic session management, session level
   security, presentation/formatting, application functionality).

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/4.3.1.%20%20TCP"></a><a class="selflink" href="#section-4.3.1" name="section-4.3.1">4.3.1</a>.  TCP</span>

   This approach (layering a SACRED credential exchange protocol
   directly on top of a TCP connection) requires the development of a
   custom credential exchange messaging protocol that interfaces to a
   TCP connection/socket.  The primary benefit of this approach is the
   ability to provide exactly the protocol functionality needed and no
   more.  Most server and client development environments already
   provide the socket level API needed.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/4.3.2.%20%20BEEP"></a><a class="selflink" href="#section-4.3.2" name="section-4.3.2">4.3.2</a>.  BEEP</span>

   This approach builds on the Blocks Extensible Exchange Protocol
   (BEEP) described in [<a href="rfc3080.html" title='"The Blocks Extensible Exchange Protocol Core"'>RFC3080</a>].  BEEP provides general purpose, peer-
   to-peer message exchange over any of several transport mechanisms
   where the necessary transport layer mappings have been defined for
   operation over TCP, TLS, etc.  See also [<a href="rfc3081.html" title='"Mapping the BEEP Core onto TCP"'>RFC3081</a>].





<span class="grey">Gustafson, et al.            Informational                     [Page 16]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-17" id="page-17" name="page-17"> </a>
<span class="grey"><a href="rfc3760.html">RFC 3760</a>        Securely Available Credentials (SACRED)       April 2004</span>


   BEEP provides the necessary user authentication/session security and
   session management capabilities needed to support SACRED credential
   exchange operations.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/4.3.3.%20%20HTTP"></a><a class="selflink" href="#section-4.3.3" name="section-4.3.3">4.3.3</a>.  HTTP</span>

   This approach builds on the Hypertext Transport Protocol (HTTP)
   described in [<a href="rfc1945.html" title='"Hypertext Transfer Protocol-- HTTP/1.0"'>RFC1945</a>] and [<a href="rfc2616.html" title='"Hypertext Transfer Protocol - HTTP/1.1"'>RFC2616</a>].  HTTP provides general purpose
   typing and negotiation of data representation, allowing systems to be
   built independently of the data objects being transferred.  HTTP
   support is available in a wide variety of server and client
   platforms, including portable devices that apply to roaming
   environments (laptop PCs, PDAs, mobile phones, etc.).

   HTTP is layered over TCP and can be used, optionally, with TLS to
   provide authenticated, session level security.  Either or both TLS
   authentication options, sTLS or cTLS, may be used whenever TLS is
   supported.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/5.%20%20Security%20Considerations"></a><a class="selflink" href="#section-5" name="section-5">5</a>.  Security Considerations</span>

   The following security considerations identify general observations
   and precautions to be considered for a framework supporting
   credential mobility.  When designing or implementing a protocol to
   support this framework, one should recognize these security
   considerations, and furthermore consult the SACRED Requirements
   document [<a href="rfc3157.html" title='"Securely Available Credentials - Requirements"'>RFC3157</a>] Security Considerations.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.1.%20%20Communications%20Security"></a><a class="selflink" href="#section-5.1" name="section-5.1">5.1</a>.  Communications Security</span>

   A SACRED PDU will contain information pertaining to client or server
   authentication, or communication of credentials. This information is
   subject to the traditional security concerns identified below.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/5.1.1.%20%20Confidentiality"></a><a class="selflink" href="#section-5.1.1" name="section-5.1.1">5.1.1</a>.  Confidentiality</span>

   The password or password verifier should be protected when
   communicated from the client to credential server.  The communicated
   value should be resistant to a dictionary attack.

   Similarly, the entity credentials must be confidentiality protected,
   when communicated from the client to the server and vice-versa.  The
   communicated value should also resist a dictionary attack.








<span class="grey">Gustafson, et al.            Informational                     [Page 17]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-18" id="page-18" name="page-18"> </a>
<span class="grey"><a href="rfc3760.html">RFC 3760</a>        Securely Available Credentials (SACRED)       April 2004</span>


<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/5.1.2.%20%20Integrity"></a><a class="selflink" href="#section-5.1.2" name="section-5.1.2">5.1.2</a>.  Integrity</span>

   Communication integrity between the client and the credential server
   is required.  In this way, intended client operations may not be
   altered (e.g., from an update to a deletion of credentials), nor may
   clients be maliciously given "old" credentials (e.g., possibly by an
   attacker replaying a previous credential download).

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/5.1.3.%20%20Entity%20Authentication"></a><a class="selflink" href="#section-5.1.3" name="section-5.1.3">5.1.3</a>.  Entity Authentication</span>

   Proper authentication of the client and server is required to achieve
   communication confidentiality and integrity.

   The server must properly authenticate the client, so that credentials
   are not mistakenly revealed to an attacker. The client must ensure
   the proper identification of the credential server so as to prevent
   revealing their password to an attacker.  These goals may be achieved
   implicitly with a strong password-based protocol or explicitly.  If
   the server is identified explicitly, the user or client must ensure
   that the user password is conveyed to a trusted server.  This might
   be achieved by installing appropriate trusted key(s) in the client.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/5.1.4.%20%20Non-repudiation"></a><a class="selflink" href="#section-5.1.4" name="section-5.1.4">5.1.4</a>.  Non-repudiation</span>

   There are no requirements upon the SACRED protocol itself to support
   non-repudiation, although the context in which the credentials are
   being used may have such requirements.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.2.%20%20Systems%20Security"></a><a class="selflink" href="#section-5.2" name="section-5.2">5.2</a>.  Systems Security</span>

   Systems security is concerned with protection of the protocol
   endpoints (i.e., the client and server) and information stored at the
   server in support of the SACRED protocol.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/5.2.1.%20%20Client%20Security"></a><a class="selflink" href="#section-5.2.1" name="section-5.2.1">5.2.1</a>.  Client Security</span>

   As with most security protocols, secure use of the client often
   relies, in part, upon secure behavior by the user.  In the case of a
   password-based SACRED protocol, users should be educated, or enforced
   through policy, to choose passwords with a reasonable amount of
   entropy.  Additionally, users should be made aware of the importance
   of protecting the confidentiality of their account password.

   In addition, the client interface should be designed to thwart
   "shoulder surfing" where an attacker can observe the password as
   entered by a user.  This is often achieved by not echoing the exact
   characters of the password when entered.




<span class="grey">Gustafson, et al.            Informational                     [Page 18]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-19" id="page-19" name="page-19"> </a>
<span class="grey"><a href="rfc3760.html">RFC 3760</a>        Securely Available Credentials (SACRED)       April 2004</span>


   As well, the interface should encourage the entering of the password
   in the appropriate interface field so that protections can be
   properly enforced.  For example, a user should be guided to not
   mistakenly enter their password in the "username" field (since their
   password would likely be echoed to the screen in this case, and might
   not be encrypted when communicated to the server).  This might be
   accomplished via the automatic insertion of the user name or several
   user name choices in the appropriate on-screen dialog field, for
   example.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/5.2.2.%20%20Client%20Security%2C%20TLS%20Server%20Authentication"></a><a class="selflink" href="#section-5.2.2" name="section-5.2.2">5.2.2</a>.  Client Security, TLS Server Authentication</span>

   When TLS is used as the SACRED transport protocol, the client
   interface should be designed to allow the user to verify that she is
   connected to the intended credential server.  For example, client
   software should allow for the visual display of identifying
   components from the TLS server's X.509 certificate, like the server's
   name, the certificate fingerprint, etc.

   Users should be guided to verify this information regularly, allowing
   ready recognition of trusted credential servers.  In addition, users
   should be made aware of the importance of verifying their credential
   server's identity before initiating any credential exchange
   operations.

   A SACRED client SHOULD only be configured with those SACRED trust
   anchors that are to be used by the client.  Re-use of trust anchors
   from other applications, e.g., Internet browsers is NOT RECOMMENDED.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/5.2.3.%20%20Server%20Security"></a><a class="selflink" href="#section-5.2.3" name="section-5.2.3">5.2.3</a>.  Server Security</span>

   Password verifiers and user credentials must be afforded a high level
   of protection at the credential server.  In addition to salting and
   super-encrypting each (to ensure resistance to offline dictionary
   attacks), a system should ensure that credential server keys are
   protected using sufficient procedural and physical access controls.

   The login to the credential server should be resistant to replay
   attacks.

   Online attempts to access a particular user account should be
   controlled, or at least monitored.  Control might be enforced by
   incorporating a time delay after a number of unsuccessful logins to a
   particular account, or possibly the locking of the account
   altogether.  Alternatively, one might simply log unsuccessful
   attempts where an administrative notice is produced once a threshold
   of unsuccessful credential access attempts is reached.




<span class="grey">Gustafson, et al.            Informational                     [Page 19]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-20" id="page-20" name="page-20"> </a>
<span class="grey"><a href="rfc3760.html">RFC 3760</a>        Securely Available Credentials (SACRED)       April 2004</span>


<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/5.2.4.%20%20Denial%20of%20Service"></a><a class="selflink" href="#section-5.2.4" name="section-5.2.4">5.2.4</a>.  Denial of Service</span>

   As with most protocols, Denial of Service (DoS) issues must also be
   considered.  In the case of SACRED, most DoS issues are a concern for
   the underlying transport protocol.  However, some concerns may still
   be mitigated.

   Service to a user might be denied in case their account is locked
   after numerous unsuccessful login attempts.  Consideration of
   protection against online attacks must therefore be considered (as
   described above).  Proper user authentication should ensure that an
   attacker does not maliciously overwrite a user's credentials.
   Credential servers should be wary of repeated logins to a particular
   account (which also identifies a possible security breach, as
   described above) or abnormal volumes of requests to a number of
   accounts (possibly identifying a DoS attack).

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/6.%20%20References"></a><a class="selflink" href="#section-6" name="section-6">6</a>.  References</span>

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/6.1.%20%20Normative%20References"></a><a class="selflink" href="#section-6.1" name="section-6.1">6.1</a>.  Normative References</span>

   [<a id="ref-RFC2119" name="ref-RFC2119">RFC2119</a>] Bradner, S., "Key words for use in RFCs to Indicate
             Requirement Levels", <a href="https://tools.ietf.org/html/bcp14">BCP 14</a>, <a href="rfc2119.html">RFC 2119</a>, March 1997.

   [<a id="ref-RFC3157" name="ref-RFC3157">RFC3157</a>] Arsenault, A. and S. Farrell, "Securely Available
             Credentials - Requirements", <a href="rfc3157.html">RFC 3157</a>, August 2001.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/6.2.%20%20Informative%20References"></a><a class="selflink" href="#section-6.2" name="section-6.2">6.2</a>.  Informative References</span>

   [<a id="ref-BM92" name="ref-BM92">BM92</a>]    Bellovin, S. and M. Merritt, "Encrypted Key Exchange:
             Password-based protocols secure against dictionary
             attacks", Proceedings of the IEEE Symposium on Research in
             Security and Privacy, May 1992.

   [<a id="ref-BM94" name="ref-BM94">BM94</a>]    Bellovin, S. and M. Merritt, "Augmented Encrypted Key
             Exchange: a Password-Based Protocol Secure Against
             Dictionary Attacks and Password File Compromise, ATT Labs
             Technical Report, 1994.

   [<a id="ref-PKCS12" name="ref-PKCS12">PKCS12</a>]  "PKCS 12 v1.0: Personal Information Exchange Syntax", RSA
             Laboratories, June 24, 1999.

   [<a id="ref-PKCS15" name="ref-PKCS15">PKCS15</a>]  "PKCS #15 v1.1: Cryptographic Token Information Syntax
             Standard", RSA Laboratories, June 2000.

   [<a id="ref-RFC1945" name="ref-RFC1945">RFC1945</a>] Berners-Lee, T., Fielding, R. and H. Frystyk, "Hypertext
             Transfer Protocol-- HTTP/1.0", <a href="rfc1945.html">RFC 1945</a>, May 1996.




<span class="grey">Gustafson, et al.            Informational                     [Page 20]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-21" id="page-21" name="page-21"> </a>
<span class="grey"><a href="rfc3760.html">RFC 3760</a>        Securely Available Credentials (SACRED)       April 2004</span>


   [<a id="ref-RFC2246" name="ref-RFC2246">RFC2246</a>] Dierks, T. and C. Allen, "The TLS Protocol Version 1.0",
             <a href="rfc2246.html">RFC 2246</a>, January 1999.

   [<a id="ref-RFC2616" name="ref-RFC2616">RFC2616</a>] Fielding, R., Gettys, J., Mogul, J., Frysyk, H., Masinter,
             L., Leach, M. and T. Berners-Lee, "Hypertext Transfer
             Protocol - HTTP/1.1", <a href="rfc2616.html">RFC 2616</a>, June 1999.

   [<a id="ref-RFC2945" name="ref-RFC2945">RFC2945</a>] Wu, T., "The SRP Authentication and Key Exchange System",
             <a href="rfc2945.html">RFC 2945</a>, September 2000.

   [<a id="ref-RFC3080" name="ref-RFC3080">RFC3080</a>] Rose, M., "The Blocks Extensible Exchange Protocol Core",
             <a href="rfc3080.html">RFC 3080</a>, March 2001.

   [<a id="ref-RFC3081" name="ref-RFC3081">RFC3081</a>] Rose, M., "Mapping the BEEP Core onto TCP", <a href="rfc3081.html">RFC 3081</a>, March
             2001.

   [<a id="ref-SPEKE" name="ref-SPEKE">SPEKE</a>]   Jablon, D., "Strong Password-Only Authenticated Key
             Exchange", September 1996.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/7.%20%20Authors%27%20Addresses"></a><a class="selflink" href="#section-7" name="section-7">7</a>.  Authors' Addresses</span>

   Dale Gustafson
   Future Foundation Inc.

   EMail: degustafson@comcast.net


   Mike Just
   Treasury Board of Canada, Secretariat

   EMail: Just.Mike@tbs-sct.gc.ca


   Magnus Nystrom
   RSA Security Inc.

   EMail: magnus@rsasecurity.com














<span class="grey">Gustafson, et al.            Informational                     [Page 21]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-22" id="page-22" name="page-22"> </a>
<span class="grey"><a href="rfc3760.html">RFC 3760</a>        Securely Available Credentials (SACRED)       April 2004</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/8.%20%20Full%20Copyright%20Statement"></a><a class="selflink" href="#section-8" name="section-8">8</a>.  Full Copyright Statement</span>

   Copyright (C) The Internet Society (2004).  This document is subject
   to the rights, licenses and restrictions contained in <a href="https://tools.ietf.org/html/bcp78">BCP 78</a> and
   except as set forth therein, the authors retain all their rights.

   This document and the information contained herein are provided on an
   "AS IS" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS
   OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET
   ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED,
   INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE
   INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED
   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.

Intellectual Property

   The IETF takes no position regarding the validity or scope of any
   Intellectual Property Rights or other rights that might be claimed to
   pertain to the implementation or use of the technology described in
   this document or the extent to which any license under such rights
   might or might not be available; nor does it represent that it has
   made any independent effort to identify any such rights.  Information
   on the procedures with respect to rights in RFC documents can be
   found in <a href="https://tools.ietf.org/html/bcp78">BCP 78</a> and <a href="https://tools.ietf.org/html/bcp79">BCP 79</a>.

   Copies of IPR disclosures made to the IETF Secretariat and any
   assurances of licenses to be made available, or the result of an
   attempt made to obtain a general license or permission for the use of
   such proprietary rights by implementers or users of this
   specification can be obtained from the IETF on-line IPR repository at
   <a href="http://www.ietf.org/ipr">http://www.ietf.org/ipr</a>.

   The IETF invites any interested party to bring to its attention any
   copyrights, patents or patent applications, or other proprietary
   rights that may cover technology that may be required to implement
   this standard.  Please address the information to the IETF at ietf-
   ipr@ietf.org.

Acknowledgement

   Funding for the RFC Editor function is currently provided by the
   Internet Society.









Gustafson, et al.            Informational                     [Page 22]

</pre><br/>
    <span class="noprint"><small><small>Html markup produced by rfcmarkup 1.126, available from
      <a href="https://tools.ietf.org/tools/rfcmarkup/">https://tools.ietf.org/tools/rfcmarkup/</a>
    </small></small></span>
  </div>




</body><!-- Mirrored from tools.ietf.org/html/rfc3760 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 06 Mar 2018 23:18:45 GMT --></html>