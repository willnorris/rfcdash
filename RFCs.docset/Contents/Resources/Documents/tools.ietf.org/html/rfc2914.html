<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml"><!-- Mirrored from tools.ietf.org/html/rfc2914 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 06 Mar 2018 23:18:49 GMT --><!-- Added by HTTrack --><head><meta content="text/html;charset=utf-8" http-equiv="content-type"/><!-- /Added by HTTrack -->

    <meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
    <meta content="index,follow" name="robots"/>
    <meta content="rfcmarkup version 1.126" name="creator"/>
    <link href="http://purl.org/dc/elements/1.1/" rel="schema.DC"/>
<meta content="urn:ietf:rfc:2914" name="DC.Identifier"/>
<meta content="The goal of this document is to explain the need for congestion
control in the Internet, and to discuss what constitutes correct
congestion control. This document specifies an Internet Best Current
Practices for the Internet Community, and requests discussion and
suggestions for improvements." name="DC.Description.Abstract"/>
<meta content="Sally Floyd &lt;research@icsi&gt;" name="DC.Creator"/>
<meta content="September, 2000" name="DC.Date.Issued"/>
<meta content="Congestion Control Principles" name="DC.Title"/>

    <link href="https://tools.ietf.org/images/rfc.png" rel="icon" type="image/png"/>
    <link href="https://tools.ietf.org/images/rfc.png" rel="shortcut icon" type="image/png"/>
    <title>RFC 2914 - Congestion Control Principles</title>
    
    
    <style type="text/css">
	@media only screen 
	  and (min-width: 992px)
	  and (max-width: 1199px) {
	    body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 768px)
	  and (max-width: 991px) {
            body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 480px)
	  and (max-width: 767px) {
            body { font-size: 11pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (max-width: 479px) {
            body { font-size: 8pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-device-width : 375px) 
	  and (max-device-width : 667px) {
            body { font-size: 9.5pt; }
            div.content { width: 96ex; margin: 0 1px; }
        }
	@media only screen 
	  and (min-device-width: 1200px) {
            body { font-size: 10pt; margin: 0 4em; }
            div.content { width: 96ex; margin: 0; }
        }
        h1, h2, h3, h4, h5, h6, .h1, .h2, .h3, .h4, .h5, .h6 {
	    font-weight: bold;
            line-height: 0pt;
            display: inline;
            white-space: pre;
            font-family: monospace;
            font-size: 1em;
	    font-weight: bold;
        }
        pre {
            font-size: 1em;
            margin-top: 0px;
            margin-bottom: 0px;
        }
	.pre {
	    white-space: pre;
	    font-family: monospace;
	}
	.header{
	    font-weight: bold;
	}
        .newpage {
            page-break-before: always;
        }
        .invisible {
            text-decoration: none;
            color: white;
        }
        a.selflink {
          color: black;
          text-decoration: none;
        }
        @media print {
            body {
                font-family: monospace;
                font-size: 10.5pt;
            }
            h1, h2, h3, h4, h5, h6 {
                font-size: 1em;
            }
        
            a:link, a:visited {
                color: inherit;
                text-decoration: none;
            }
            .noprint {
                display: none;
            }
        }
	@media screen {
	    .grey, .grey a:link, .grey a:visited {
		color: #777;
	    }
            .docinfo {
                background-color: #EEE;
            }
            .top {
                border-top: 7px solid #EEE;
            }
            .bgwhite  { background-color: white; }
            .bgred    { background-color: #F44; }
            .bggrey   { background-color: #666; }
            .bgbrown  { background-color: #840; }            
            .bgorange { background-color: #FA0; }
            .bgyellow { background-color: #EE0; }
            .bgmagenta{ background-color: #F4F; }
            .bgblue   { background-color: #66F; }
            .bgcyan   { background-color: #4DD; }
            .bggreen  { background-color: #4F4; }

            .legend   { font-size: 90%; }
            .cplate   { font-size: 70%; border: solid grey 1px; }
	}
    </style>
    <!--[if IE]>
    <style>
    body {
       font-size: 13px;
       margin: 10px 10px;
    }
    </style>
    <![endif]-->

    <script type="text/javascript"><!--
    function addHeaderTags() {
	var spans = document.getElementsByTagName("span");
	for (var i=0; i < spans.length; i++) {
	    var elem = spans[i];
	    if (elem) {
		var level = elem.getAttribute("class");
                if (level == "h1" || level == "h2" || level == "h3" || level == "h4" || level == "h5" || level == "h6") {
                    elem.innerHTML = "<"+level+">"+elem.innerHTML+"</"+level+">";		
                }
	    }
	}
    }
    var legend_html = "Colour legend:<br />      <table>         <tr><td>Unknown:</td>                   <td><span class='cplate bgwhite'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft:</td>                     <td><span class='cplate bgred'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Informational:</td>             <td><span class='cplate bgorange'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Experimental:</td>              <td><span class='cplate bgyellow'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Best Common Practice:</td>      <td><span class='cplate bgmagenta'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Proposed Standard:</td>         <td><span class='cplate bgblue'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft Standard (old designation):</td> <td><span class='cplate bgcyan'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Internet Standard:</td>         <td><span class='cplate bggreen'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Historic:</td>                  <td><span class='cplate bggrey'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Obsolete:</td>                  <td><span class='cplate bgbrown'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>     </table>";
    function showElem(id) {
        var elem = document.getElementById(id);
        elem.innerHTML = eval(id+"_html");
        elem.style.visibility='visible';
    }
    function hideElem(id) {
        var elem = document.getElementById(id);
        elem.style.visibility='hidden';        
        elem.innerHTML = "";
    }
    // -->
    </script>
</head>
<body onload="addHeaderTags()">
  <div class="content">
   <div style="height: 13px;">
      <div class="pre noprint docinfo bgmagenta" onclick="showElem('legend');" onmouseout="hideElem('legend')" onmouseover="this.style.cursor='pointer';" style="height: 6px; position: absolute;" title="Click for colour legend.">                                                                        </div>
      <div class="docinfo noprint pre legend" id="legend" onmouseout="hideElem('legend');" onmouseover="showElem('legend');" style="position:absolute; top: 4px; left: 4ex; visibility:hidden; background-color: white; padding: 4px 9px 5px 7px; border: solid #345 1px; ">
      </div>
   </div>
<span class="pre noprint docinfo top">[<a href="index.html" title="Document search and retrieval page">Docs</a>] [<a href="https://tools.ietf.org/rfc/rfc2914.txt" title="Plaintext version of this document">txt</a>|<a href="https://tools.ietf.org/pdf/rfc2914" title="PDF version of this document">pdf</a>] [<a href="https://tools.ietf.org/html/draft-floyd-cong" title="draft-floyd-cong">draft-floyd-cong</a>] [<a href="https://datatracker.ietf.org/doc/rfc2914" title="IESG Datatracker information for this document">Tracker</a>] [<a href="https://tools.ietf.org/rfcdiff?difftype=--hwdiff&amp;url2=rfc2914" title="Inline diff (wdiff)">Diff1</a>] [<a href="https://tools.ietf.org/rfcdiff?url2=rfc2914" title="Side-by-side diff">Diff2</a>]           </span><br/>
<span class="pre noprint docinfo">                                                                        </span><br/>
<span class="pre noprint docinfo">Updated by: <a href="rfc7141.html">7141</a>                                   BEST CURRENT PRACTICE</span><br/>
<span class="pre noprint docinfo">                                                                        </span><br/>
<pre>Network Working Group                                         S. Floyd
Request for Comments: 2914                                       ACIRI
BCP: 41                                                 September 2000
Category: Best Current Practice


                     <span class="h1">Congestion Control Principles</span>

Status of this Memo

   This document specifies an Internet Best Current Practices for the
   Internet Community, and requests discussion and suggestions for
   improvements.  Distribution of this memo is unlimited.

Copyright Notice

   Copyright (C) The Internet Society (2000).  All Rights Reserved.

Abstract

   The goal of this document is to explain the need for congestion
   control in the Internet, and to discuss what constitutes correct
   congestion control.  One specific goal is to illustrate the dangers
   of neglecting to apply proper congestion control.  A second goal is
   to discuss the role of the IETF in standardizing new congestion
   control protocols.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/1.%20%20Introduction"></a><a class="selflink" href="#section-1" name="section-1">1</a>.  Introduction</span>

   This document draws heavily from earlier RFCs, in some cases
   reproducing entire sections of the text of earlier documents
   [RFC2309, <a href="rfc2357.html">RFC2357</a>].  We have also borrowed heavily from earlier
   publications addressing the need for end-to-end congestion control
   [<a href="#ref-FF99" title='"Promoting the Use of End-to-End Congestion Control in the Internet"'>FF99</a>].

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/2.%20%20Current%20standards%20on%20congestion%20control"></a><a class="selflink" href="#section-2" name="section-2">2</a>.  Current standards on congestion control</span>

   IETF standards concerning end-to-end congestion control focus either
   on specific protocols (e.g., TCP [<a href="rfc2581.html" title='"TCP Congestion Control"'>RFC2581</a>], reliable multicast
   protocols [<a href="rfc2357.html" title='"IETF Criteria for Evaluating Reliable Multicast Transport and Application Protocols"'>RFC2357</a>]) or on the syntax and semantics of communications
   between the end nodes and routers about congestion information (e.g.,
   Explicit Congestion Notification [<a href="rfc2481.html" title='"A Proposal to add Explicit Congestion Notification (ECN) to IP"'>RFC2481</a>]) or desired quality-of-
   service (diff-serv)).  The role of end-to-end congestion control is
   also discussed in an Informational RFC on "Recommendations on Queue
   Management and Congestion Avoidance in the Internet" [<a href="rfc2309.html" title='"Recommendations on Queue Management and Congestion Avoidance in the Internet"'>RFC2309</a>].  <a href="rfc2309.html">RFC</a>
   <a href="rfc2309.html">2309</a> recommends the deployment of active queue management mechanisms
   in routers, and the continuation of design efforts towards mechanisms




<span class="grey">Floyd, ed.               Best Current Practice                  [Page 1]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-2" id="page-2" name="page-2"> </a>
<span class="grey"><a href="rfc2914.html">RFC 2914</a>             Congestion Control Principles        September 2000</span>


   in routers to deal with flows that are unresponsive to congestion
   notification.  We freely borrow from <a href="rfc2309.html">RFC 2309</a> some of their general
   discussion of end-to-end congestion control.

   In contrast to the RFCs discussed above, this document is a more
   general discussion of the principles of congestion control.  One of
   the keys to the success of the Internet has been the congestion
   avoidance mechanisms of TCP.  While TCP is still the dominant
   transport protocol in the Internet, it is not ubiquitous, and there
   are an increasing number of applications that, for one reason or
   another, choose not to use TCP.  Such traffic includes not only
   multicast traffic, but unicast traffic such as streaming multimedia
   that does not require reliability; and traffic such as DNS or routing
   messages that consist of short transfers deemed critical to the
   operation of the network.  Much of this traffic does not use any form
   of either bandwidth reservations or end-to-end congestion control.
   The continued use of end-to-end congestion control by best-effort
   traffic is critical for maintaining the stability of the Internet.

   This document also discusses the general role of the IETF in the
   standardization of new congestion control protocols.

   The discussion of congestion control principles for differentiated
   services or integrated services is not addressed in this document.
   Some categories of integrated or differentiated services include a
   guarantee by the network of end-to-end bandwidth, and as such do not
   require end-to-end congestion control mechanisms.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/3.%20%20The%20development%20of%20end-to-end%20congestion%20control."></a><a class="selflink" href="#section-3" name="section-3">3</a>.  The development of end-to-end congestion control.</span>

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.1.%20%20Preventing%20congestion%20collapse."></a><a class="selflink" href="#section-3.1" name="section-3.1">3.1</a>.  Preventing congestion collapse.</span>

   The Internet protocol architecture is based on a connectionless end-
   to-end packet service using the IP protocol.  The advantages of its
   connectionless design, flexibility and robustness, have been amply
   demonstrated.  However, these advantages are not without cost:
   careful design is required to provide good service under heavy load.
   In fact, lack of attention to the dynamics of packet forwarding can
   result in severe service degradation or "Internet meltdown".  This
   phenomenon was first observed during the early growth phase of the
   Internet of the mid 1980s [<a href="rfc896.html" title='"Congestion Control in IP/TCP"'>RFC896</a>], and is technically called
   "congestion collapse".

   The original specification of TCP [<a href="rfc793.html" title='"Transmission Control Protocol"'>RFC793</a>] included window-based flow
   control as a means for the receiver to govern the amount of data sent
   by the sender.  This flow control was used to prevent overflow of the
   receiver's data buffer space available for that connection.  [<a href="rfc793.html" title='"Transmission Control Protocol"'>RFC793</a>]




<span class="grey">Floyd, ed.               Best Current Practice                  [Page 2]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-3" id="page-3" name="page-3"> </a>
<span class="grey"><a href="rfc2914.html">RFC 2914</a>             Congestion Control Principles        September 2000</span>


   reported that segments could be lost due either to errors or to
   network congestion, but did not include dynamic adjustment of the
   flow-control window in response to congestion.

   The original fix for Internet meltdown was provided by Van Jacobson.
   Beginning in 1986, Jacobson developed the congestion avoidance
   mechanisms that are now required in TCP implementations [Jacobson88,
   <a href="rfc2581.html">RFC 2581</a>].  These mechanisms operate in the hosts to cause TCP
   connections to "back off" during congestion.  We say that TCP flows
   are "responsive" to congestion signals (i.e., dropped packets) from
   the network.  It is these TCP congestion avoidance algorithms that
   prevent the congestion collapse of today's Internet.

   However, that is not the end of the story.  Considerable research has
   been done on Internet dynamics since 1988, and the Internet has
   grown.  It has become clear that the TCP congestion avoidance
   mechanisms [<a href="rfc2581.html" title='"TCP Congestion Control"'>RFC2581</a>], while necessary and powerful, are not
   sufficient to provide good service in all circumstances.  In addition
   to the development of new congestion control mechanisms [<a href="rfc2357.html" title='"IETF Criteria for Evaluating Reliable Multicast Transport and Application Protocols"'>RFC2357</a>],
   router-based mechanisms are in development that complement the
   endpoint congestion avoidance mechanisms.

   A major issue that still needs to be addressed is the potential for
   future congestion collapse of the Internet due to flows that do not
   use responsible end-to-end congestion control.  <a href="rfc896.html">RFC 896</a> [<a href="rfc896.html" title='"Congestion Control in IP/TCP"'>RFC896</a>]
   suggested in 1984 that gateways should detect and `squelch'
   misbehaving hosts: "Failure to  respond  to  an  ICMP  Source  Quench
   message, though,  should be regarded as grounds for action by a
   gateway to disconnect a host.  Detecting such failure is non-trivial
   but  is a worthwhile area for further research."  Current papers
   still propose that routers detect and penalize flows that are not
   employing acceptable end-to-end congestion control [<a href="#ref-FF99" title='"Promoting the Use of End-to-End Congestion Control in the Internet"'>FF99</a>].

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.2.%20%20Fairness"></a><a class="selflink" href="#section-3.2" name="section-3.2">3.2</a>.  Fairness</span>

   In addition to a concern about congestion collapse, there is a
   concern about `fairness' for best-effort traffic.  Because TCP "backs
   off" during congestion, a large number of TCP connections can share a
   single, congested link in such a way that bandwidth is shared
   reasonably equitably among similarly situated flows.  The equitable
   sharing of bandwidth among flows depends on the fact that all flows
   are running compatible congestion control algorithms.  For TCP, this
   means congestion control algorithms conformant with the current TCP
   specification [RFC793, <a href="rfc1122.html">RFC1122</a>, <a href="rfc2581.html">RFC2581</a>].

   The issue of fairness among competing flows has become increasingly
   important for several reasons.  First, using window scaling
   [<a href="rfc1323.html" title='"TCP Extensions for High Performance"'>RFC1323</a>], individual TCPs can use high bandwidth even over high-



<span class="grey">Floyd, ed.               Best Current Practice                  [Page 3]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-4" id="page-4" name="page-4"> </a>
<span class="grey"><a href="rfc2914.html">RFC 2914</a>             Congestion Control Principles        September 2000</span>


   propagation-delay paths.  Second, with the growth of the web,
   Internet users increasingly want high-bandwidth and low-delay
   communications, rather than the leisurely transfer of a long file in
   the background.  The growth of best-effort traffic that does not use
   TCP underscores this concern about fairness between competing best-
   effort traffic in times of congestion.

   The popularity of the Internet has caused a proliferation in the
   number of TCP implementations.  Some of these may fail to implement
   the TCP congestion avoidance mechanisms correctly because of poor
   implementation [<a href="rfc2525.html" title='"Known TCP Implementation Problems"'>RFC2525</a>].  Others may deliberately be implemented
   with congestion avoidance algorithms that are more aggressive in
   their use of bandwidth than other TCP implementations; this would
   allow a vendor to claim to have a "faster TCP".  The logical
   consequence of such implementations would be a spiral of increasingly
   aggressive TCP implementations, or increasingly aggressive transport
   protocols, leading back to the point where there is effectively no
   congestion avoidance and the Internet is chronically congested.

   There is a well-known way to achieve more aggressive performance
   without even changing the transport protocol, by changing the level
   of granularity: open multiple connections to the same place, as has
   been done in the past by some Web browsers.  Thus, instead of a
   spiral of increasingly aggressive transport protocols, we would
   instead have a spiral of increasingly aggressive web browsers, or
   increasingly aggressive applications.

   This raises the issue of the appropriate granularity of a "flow",
   where we define a `flow' as the level of granularity appropriate for
   the application of both fairness and congestion control.  From <a href="rfc2309.html">RFC</a>
   <a href="rfc2309.html">2309</a>:  "There are a few `natural' answers: 1) a TCP or UDP connection
   (source address/port, destination address/port); 2) a
   source/destination host pair; 3) a given source host or a given
   destination host.  We would guess that the source/destination host
   pair gives the most appropriate granularity in many circumstances.
   The granularity of flows for congestion management is, at least in
   part, a policy question that needs to be addressed in the wider IETF
   community."

   Again borrowing from <a href="rfc2309.html">RFC 2309</a>, we use the term "TCP-compatible" for a
   flow that behaves under congestion like a flow produced by a
   conformant TCP.  A TCP-compatible flow is responsive to congestion
   notification, and in steady-state uses no more bandwidth than a
   conformant TCP running under comparable conditions (drop rate, RTT,
   MTU, etc.)






<span class="grey">Floyd, ed.               Best Current Practice                  [Page 4]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-5" id="page-5" name="page-5"> </a>
<span class="grey"><a href="rfc2914.html">RFC 2914</a>             Congestion Control Principles        September 2000</span>


   It is convenient to divide flows into three classes: (1) TCP-
   compatible flows, (2) unresponsive flows, i.e., flows that do not
   slow down when congestion occurs, and (3) flows that are responsive
   but are not TCP-compatible.  The last two classes contain more
   aggressive flows that pose significant threats to Internet
   performance, as we discuss below.

   In addition to steady-state fairness, the fairness of the initial
   slow-start is also a concern.  One concern is the transient effect on
   other flows of a flow with an overly-aggressive slow-start procedure.
   Slow-start performance is particularly important for the many flows
   that are short-lived, and only have a small amount of data to
   transfer.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.3.%20%20Optimizing%20performance%20regarding%20throughput%2C%20delay%2C%20and%20loss."></a><a class="selflink" href="#section-3.3" name="section-3.3">3.3</a>.  Optimizing performance regarding throughput, delay, and loss.</span>

   In addition to the prevention of congestion collapse and concerns
   about fairness, a third reason for a flow to use end-to-end
   congestion control can be to optimize its own performance regarding
   throughput, delay, and loss.  In some circumstances, for example in
   environments of high statistical multiplexing, the delay and loss
   rate experienced by a flow are largely independent of its own sending
   rate.  However, in environments with lower levels of statistical
   multiplexing or with per-flow scheduling, the delay and loss rate
   experienced by a flow is in part a function of the flow's own sending
   rate.  Thus, a flow can use end-to-end congestion control to limit
   the delay or loss experienced by its own packets.  We would note,
   however, that in an environment like the current best-effort
   Internet, concerns regarding congestion collapse and fairness with
   competing flows limit the range of congestion control behaviors
   available to a flow.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/4.%20%20The%20role%20of%20the%20standards%20process"></a><a class="selflink" href="#section-4" name="section-4">4</a>.  The role of the standards process</span>

   The standardization of a transport protocol includes not only
   standardization of aspects of the protocol that could affect
   interoperability (e.g., information exchanged by the end-nodes), but
   also standardization of mechanisms deemed critical to performance
   (e.g., in TCP, reduction of the congestion window in response to a
   packet drop).  At the same time, implementation-specific details and
   other aspects of the transport protocol that do not affect
   interoperability and do not significantly interfere with performance
   do not require standardization.  Areas of TCP that do not require
   standardization include the details of TCP's Fast Recovery procedure
   after a Fast Retransmit [<a href="rfc2582.html" title="&quot;The NewReno Modification to TCP's Fast Recovery Algorithm&quot;">RFC2582</a>].  The appendix uses examples from
   TCP to discuss in more detail the role of the standards process in
   the development of congestion control.




<span class="grey">Floyd, ed.               Best Current Practice                  [Page 5]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-6" id="page-6" name="page-6"> </a>
<span class="grey"><a href="rfc2914.html">RFC 2914</a>             Congestion Control Principles        September 2000</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.1.%20%20The%20development%20of%20new%20transport%20protocols."></a><a class="selflink" href="#section-4.1" name="section-4.1">4.1</a>.  The development of new transport protocols.</span>

   In addition to addressing the danger of congestion collapse, the
   standardization process for new transport protocols takes care to
   avoid a congestion control `arms race' among competing protocols.  As
   an example, in <a href="rfc2357.html">RFC 2357</a> [<a href="rfc2357.html" title='"IETF Criteria for Evaluating Reliable Multicast Transport and Application Protocols"'>RFC2357</a>] the TSV Area Directors and their
   Directorate outline criteria for the publication as RFCs of
   Internet-Drafts on reliable multicast transport protocols.  From
   [<a href="rfc2357.html" title='"IETF Criteria for Evaluating Reliable Multicast Transport and Application Protocols"'>RFC2357</a>]:  "A particular concern for the IETF is the impact of
   reliable multicast traffic on other traffic in the Internet in times
   of congestion, in particular the effect of reliable multicast traffic
   on competing TCP traffic....  The challenge to the IETF is to
   encourage research and implementations of reliable multicast, and to
   enable the needs of applications for reliable multicast to be met as
   expeditiously as possible, while at the same time protecting the
   Internet from the congestion disaster or collapse that could result
   from the widespread use of applications with inappropriate reliable
   multicast mechanisms."

   The list of technical criteria that must be addressed by RFCs on new
   reliable multicast transport protocols include the following:  "Is
   there a congestion control mechanism? How well does it perform? When
   does it fail?  Note that congestion control mechanisms that operate
   on the network more aggressively than TCP will face a great burden of
   proof that they don't threaten network stability."

   It is reasonable to expect that these concerns about the effect of
   new transport protocols on competing traffic will apply not only to
   reliable multicast protocols, but to unreliable unicast, reliable
   unicast, and unreliable multicast traffic as well.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.2.%20%20Application-level%20issues%20that%20affect%20congestion%20control"></a><a class="selflink" href="#section-4.2" name="section-4.2">4.2</a>.  Application-level issues that affect congestion control</span>

   The specific issue of a browser opening multiple connections to the
   same destination has been addressed by <a href="rfc2616.html">RFC 2616</a> [<a href="rfc2616.html" title='"Hypertext Transfer Protocol -- HTTP/1.1"'>RFC2616</a>], which
   states in <a href="#section-8.1.4">Section 8.1.4</a> that "Clients that use persistent connections
   SHOULD limit the number of simultaneous connections that they
   maintain to a given server.  A single-user client SHOULD NOT maintain
   more than 2 connections with any server or proxy."

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.3.%20%20New%20developments%20in%20the%20standards%20process"></a><a class="selflink" href="#section-4.3" name="section-4.3">4.3</a>.  New developments in the standards process</span>

   The most obvious developments in the IETF that could affect the
   evolution of congestion control are the development of integrated and
   differentiated services [RFC2212, <a href="rfc2475.html">RFC2475</a>] and of Explicit Congestion
   Notification (ECN) [<a href="rfc2481.html" title='"A Proposal to add Explicit Congestion Notification (ECN) to IP"'>RFC2481</a>].  However, other less dramatic
   developments are likely to affect congestion control as well.




<span class="grey">Floyd, ed.               Best Current Practice                  [Page 6]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-7" id="page-7" name="page-7"> </a>
<span class="grey"><a href="rfc2914.html">RFC 2914</a>             Congestion Control Principles        September 2000</span>


   One such effort is that to construct Endpoint Congestion Management
   [<a href="#ref-BS00" title='"The Congestion Manager"'>BS00</a>], to enable multiple concurrent flows from a sender to the same
   receiver to share congestion control state.  By allowing multiple
   connections to the same destination to act as one flow in terms of
   end-to-end congestion control, a Congestion Manager could allow
   individual connections slow-starting to take advantage of previous
   information about the congestion state of the end-to-end path.
   Further, the use of a Congestion Manager could remove the congestion
   control dangers of multiple flows being opened between the same
   source/destination pair, and could perhaps be used to allow a browser
   to open many simultaneous connections to the same destination.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/5.%20%20A%20description%20of%20congestion%20collapse"></a><a class="selflink" href="#section-5" name="section-5">5</a>.  A description of congestion collapse</span>

   This section discusses congestion collapse from undelivered packets
   in some detail, and shows how unresponsive flows could contribute to
   congestion collapse in the Internet.  This section draws heavily on
   material from [<a href="#ref-FF99" title='"Promoting the Use of End-to-End Congestion Control in the Internet"'>FF99</a>].

   Informally, congestion collapse occurs when an increase in the
   network load results in a decrease in the useful work done by the
   network.  As discussed in <a href="#section-3">Section 3</a>, congestion collapse was first
   reported in the mid 1980s [<a href="rfc896.html" title='"Congestion Control in IP/TCP"'>RFC896</a>], and was largely due to TCP
   connections unnecessarily retransmitting packets that were either in
   transit or had already been received at the receiver.  We call the
   congestion collapse that results from the unnecessary retransmission
   of packets classical congestion collapse.  Classical congestion
   collapse is a stable condition that can result in throughput that is
   a small fraction of normal [<a href="rfc896.html" title='"Congestion Control in IP/TCP"'>RFC896</a>].  Problems with classical
   congestion collapse have generally been corrected by the timer
   improvements and congestion control mechanisms in modern
   implementations of TCP [<a href="#ref-Jacobson88" title="Congestion Avoidance and Control">Jacobson88</a>].

   A second form of potential congestion collapse occurs due to
   undelivered packets.  Congestion collapse from undelivered packets
   arises when bandwidth is wasted by delivering packets through the
   network that are dropped before reaching their ultimate destination.
   This is probably the largest unresolved danger with respect to
   congestion collapse in the Internet today.  Different scenarios can
   result in different degrees of congestion collapse, in terms of the
   fraction of the congested links' bandwidth used for productive work.
   The danger of congestion collapse from undelivered packets is due
   primarily to the increasing deployment of open-loop applications not
   using end-to-end congestion control.  Even more destructive would be
   best-effort applications that *increase* their sending rate in
   response to an increased packet drop rate (e.g., automatically using
   an increased level of FEC).




<span class="grey">Floyd, ed.               Best Current Practice                  [Page 7]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-8" id="page-8" name="page-8"> </a>
<span class="grey"><a href="rfc2914.html">RFC 2914</a>             Congestion Control Principles        September 2000</span>


   Table 1 gives the results from a scenario with congestion collapse
   from undelivered packets, where scarce bandwidth is wasted by packets
   that never reach their destination.  The simulation uses a scenario
   with three TCP flows and one UDP flow competing over a congested 1.5
   Mbps link.  The access links for all nodes are 10 Mbps, except that
   the access link to the receiver of the UDP flow is 128 Kbps, only 9%
   of the bandwidth of shared link.  When the UDP source rate exceeds
   128 Kbps, most of the UDP packets will be dropped at the output port
   to that final link.

        UDP
        Arrival   UDP       TCP       Total
        Rate      Goodput   Goodput   Goodput
       --------------------------------------
         0.7       0.7      98.5      99.2
         1.8       1.7      97.3      99.1
         2.6       2.6      96.0      98.6
         5.3       5.2      92.7      97.9
         8.8       8.4      87.1      95.5
        10.5       8.4      84.8      93.2
        13.1       8.4      81.4      89.8
        17.5       8.4      77.3      85.7
        26.3       8.4      64.5      72.8
        52.6       8.4      38.1      46.4
        58.4       8.4      32.8      41.2
        65.7       8.4      28.5      36.8
        75.1       8.4      19.7      28.1
        87.6       8.4      11.3      19.7
       105.2       8.4       3.4      11.8
       131.5       8.4       2.4      10.7

   Table 1.  A simulation with three TCP flows and one UDP flow.

   Table 1 shows the UDP arrival rate from the sender, the UDP goodput
   (defined as the bandwidth delivered to the receiver), the TCP goodput
   (as delivered to the TCP receivers), and the aggregate goodput on the
   congested 1.5 Mbps link.  Each rate is given as a fraction of the
   bandwidth of the congested link.  As the UDP source rate increases,
   the TCP goodput decreases roughly linearly, and the UDP goodput is
   nearly constant.  Thus, as the UDP flow increases its offered load,
   its only effect is to hurt the TCP and aggregate goodput.  On the
   congested link, the UDP flow ultimately `wastes' the bandwidth that
   could have been used by the TCP flow, and reduces the goodput in the
   network as a whole down to a small fraction of the bandwidth of the
   congested link.






<span class="grey">Floyd, ed.               Best Current Practice                  [Page 8]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-9" id="page-9" name="page-9"> </a>
<span class="grey"><a href="rfc2914.html">RFC 2914</a>             Congestion Control Principles        September 2000</span>


   The simulations in Table 1 illustrate both unfairness and congestion
   collapse.  As [<a href="#ref-FF99" title='"Promoting the Use of End-to-End Congestion Control in the Internet"'>FF99</a>] discusses, compatible congestion control is not
   the only way to provide fairness; per-flow scheduling at the
   congested routers is an alternative mechanism at the routers that
   guarantees fairness.  However, as discussed in [<a href="#ref-FF99" title='"Promoting the Use of End-to-End Congestion Control in the Internet"'>FF99</a>], per-flow
   scheduling can not be relied upon to prevent congestion collapse.

   There are only two alternatives for eliminating the danger of
   congestion collapse from undelivered packets.  The first alternative
   for preventing congestion collapse from undelivered packets is the
   use of effective end-to-end congestion control by the end nodes.
   More specifically, the requirement would be that a flow avoid a
   pattern of significant losses at links downstream from the first
   congested link on the path.  (Here, we would consider any link a
   `congested link' if any flow is using bandwidth that would otherwise
   be used by other traffic on the link.) Given that an end-node is
   generally unable to distinguish between a path with one congested
   link and a path with multiple congested links, the most reliable way
   for a flow to avoid a pattern of significant losses at a downstream
   congested link is for the flow to use end-to-end congestion control,
   and reduce its sending rate in the presence of loss.

   A second alternative for preventing congestion collapse from
   undelivered packets would be a guarantee by the network that packets
   accepted at a congested link in the network will be delivered all the
   way to the receiver [RFC2212, <a href="rfc2475.html">RFC2475</a>].  We note that the choice
   between the first alternative of end-to-end congestion control and
   the second alternative of end-to-end bandwidth guarantees does not
   have to be an either/or decision; congestion collapse can be
   prevented by the use of effective end-to-end congestion by some of
   the traffic, and the use of end-to-end bandwidth guarantees from the
   network for the rest of the traffic.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/6.%20%20Forms%20of%20end-to-end%20congestion%20control"></a><a class="selflink" href="#section-6" name="section-6">6</a>.  Forms of end-to-end congestion control</span>

   This document has discussed concerns about congestion collapse and
   about fairness with TCP for new forms of congestion control.  This
   does not mean, however, that concerns about congestion collapse and
   fairness with TCP necessitate that all best-effort traffic deploy
   congestion control based on TCP's Additive-Increase Multiplicative-
   Decrease (AIMD) algorithm of reducing the sending rate in half in
   response to each packet drop.  This section separately discusses the
   implications of these two concerns of congestion collapse and
   fairness with TCP.







<span class="grey">Floyd, ed.               Best Current Practice                  [Page 9]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-10" id="page-10" name="page-10"> </a>
<span class="grey"><a href="rfc2914.html">RFC 2914</a>             Congestion Control Principles        September 2000</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/6.1.%20%20End-to-end%20congestion%20control%20for%20avoiding%20congestion%20collapse."></a><a class="selflink" href="#section-6.1" name="section-6.1">6.1</a>.  End-to-end congestion control for avoiding congestion collapse.</span>

   The avoidance of congestion collapse from undelivered packets
   requires that flows avoid a scenario of a high sending rate, multiple
   congested links, and a persistent high packet drop rate at the
   downstream link.  Because congestion collapse from undelivered
   packets consists of packets that waste valuable bandwidth only to be
   dropped downstream, this form of congestion collapse is not possible
   in an environment where each flow traverses only one congested link,
   or where only a small number of packets are dropped at links
   downstream of the first congested link.  Thus, any form of congestion
   control that successfully avoids a high sending rate in the presence
   of a high packet drop rate should be sufficient to avoid congestion
   collapse from undelivered packets.

   We would note that the addition of Explicit Congestion Notification
   (ECN) to the IP architecture would not, in and of itself, remove the
   danger of congestion collapse for best-effort traffic.  ECN allows
   routers to set a bit in packet headers as an indication of congestion
   to the end-nodes, rather than being forced to rely on packet drops to
   indicate congestion.  However, with ECN, packet-marking would replace
   packet-dropping only in times of moderate congestion.  In particular,
   when congestion is heavy, and a router's buffers overflow, the router
   has no choice but to drop arriving packets.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/6.2.%20%20End-to-end%20congestion%20control%20for%20fairness%20with%20TCP."></a><a class="selflink" href="#section-6.2" name="section-6.2">6.2</a>.  End-to-end congestion control for fairness with TCP.</span>

   The concern expressed in [<a href="rfc2357.html" title='"IETF Criteria for Evaluating Reliable Multicast Transport and Application Protocols"'>RFC2357</a>] about fairness with TCP places a
   significant though not crippling constraint on the range of viable
   end-to-end congestion control mechanisms for best-effort traffic.  An
   environment with per-flow scheduling at all congested links would
   isolate flows from each other, and eliminate the need for congestion
   control mechanisms to be TCP-compatible.  An environment with
   differentiated services, where flows marked as belonging to a certain
   diff-serv class would be scheduled in isolation from best-effort
   traffic, could allow the emergence of an entire diff-serv class of
   traffic where congestion control was not required to be TCP-
   compatible.  Similarly, a pricing-controlled environment, or a diff-
   serv class with its own pricing paradigm, could supercede the concern
   about fairness with TCP.  However, for the current Internet
   environment, where other best-effort traffic could compete in a FIFO
   queue with TCP traffic, the absence of fairness with TCP could lead
   to one flow `starving out' another flow in a time of high congestion,
   as was illustrated in Table 1 above.

   However, the list of TCP-compatible congestion control procedures is
   not limited to AIMD with the same increase/ decrease parameters as
   TCP.  Other TCP-compatible congestion control procedures include



<span class="grey">Floyd, ed.               Best Current Practice                 [Page 10]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-11" id="page-11" name="page-11"> </a>
<span class="grey"><a href="rfc2914.html">RFC 2914</a>             Congestion Control Principles        September 2000</span>


   rate-based variants of AIMD; AIMD with different sets of
   increase/decrease parameters that give the same steady-state
   behavior; equation-based congestion control where the sender adjusts
   its sending rate in response to information about the long-term
   packet drop rate; layered multicast where receivers subscribe and
   unsubscribe from layered multicast groups; and possibly other forms
   that we have not yet begun to consider.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/7.%20Acknowledgements"></a><a class="selflink" href="#section-7" name="section-7">7</a>. Acknowledgements</span>

   Much of this document draws directly on previous RFCs addressing
   end-to-end congestion control.  This attempts to be a summary of
   ideas that have been discussed for many years, and by many people.
   In particular, acknowledgement is due to the members of the End-to-
   End Research Group, the Reliable Multicast Research Group, and the
   Transport Area Directorate.  This document has also benefited from
   discussion and feedback from the Transport Area Working Group.
   Particular thanks are due to Mark Allman for feedback on an earlier
   version of this document.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/8.%20References"></a><a class="selflink" href="#section-8" name="section-8">8</a>. References</span>

   [<a id="ref-BS00" name="ref-BS00">BS00</a>]       Balakrishnan H. and S. Seshan, <a href="https://www.google.com/search?sitesearch=tools.ietf.org%2Fhtml%2F&amp;q=inurl:draft-+%22The+Congestion+Manager%22" style="text-decoration: none">"The Congestion Manager"</a>,
                Work in Progress.

   [<a id="ref-DMKM00" name="ref-DMKM00">DMKM00</a>]     Dawkins, S., Montenegro, G., Kojo, M. and V. Magret,
                "End-to-end Performance Implications of Slow Links",
                Work in Progress.

   [<a id="ref-FF99" name="ref-FF99">FF99</a>]       Floyd, S. and K. Fall, "Promoting the Use of End-to-End
                Congestion Control in the Internet", IEEE/ACM
                Transactions on Networking, August 1999.  URL
                <a href="http://www.aciri.org/floyd/end2end-paper.html">http://www.aciri.org/floyd/end2end-paper.html</a>

   [<a id="ref-HPF00" name="ref-HPF00">HPF00</a>]      Handley, M., Padhye, J. and S. Floyd, "TCP Congestion
                Window Validation", <a href="rfc2861.html">RFC 2861</a>, June 2000.

   [<a id="ref-Jacobson88" name="ref-Jacobson88">Jacobson88</a>] V. Jacobson, Congestion Avoidance and Control, ACM
                SIGCOMM '88, August 1988.

   [<a id="ref-RFC793" name="ref-RFC793">RFC793</a>]     Postel, J., "Transmission Control Protocol", STD 7, <a href="rfc793.html">RFC</a>
                <a href="rfc793.html">793</a>, September 1981.

   [<a id="ref-RFC896" name="ref-RFC896">RFC896</a>]     Nagle, J., "Congestion Control in IP/TCP", <a href="rfc896.html">RFC 896</a>,
                January 1984.

   [<a id="ref-RFC1122" name="ref-RFC1122">RFC1122</a>]    Braden, R., Ed., "Requirements for Internet Hosts --
                Communication Layers", STD 3, <a href="rfc1122.html">RFC 1122</a>, October 1989.



<span class="grey">Floyd, ed.               Best Current Practice                 [Page 11]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-12" id="page-12" name="page-12"> </a>
<span class="grey"><a href="rfc2914.html">RFC 2914</a>             Congestion Control Principles        September 2000</span>


   [<a id="ref-RFC1323" name="ref-RFC1323">RFC1323</a>]    Jacobson, V., Braden, R. and D. Borman, "TCP Extensions
                for High Performance", <a href="rfc1323.html">RFC 1323</a>, May 1992.

   [<a id="ref-RFC2119" name="ref-RFC2119">RFC2119</a>]    Bradner, S., "Key words for use in RFCs to Indicate
                Requirement Levels", <a href="https://tools.ietf.org/html/bcp14">BCP 14</a>, <a href="rfc2119.html">RFC 2119</a>, March 1997.

   [<a id="ref-RFC2212" name="ref-RFC2212">RFC2212</a>]    Shenker, S., Partridge, C. and R. Guerin, "Specification
                of Guaranteed Quality of Service", <a href="rfc2212.html">RFC 2212</a>, September
                1997.

   [<a id="ref-RFC2309" name="ref-RFC2309">RFC2309</a>]    Braden, R., Clark, D., Crowcroft, J., Davie, B.,
                Deering, S., Estrin, D., Floyd, S., Jacobson, V.,
                Minshall, G., Partridge, C., Peterson, L., Ramakrishnan,
                K.K., Shenker, S., Wroclawski, J., and L. Zhang,
                "Recommendations on Queue Management and Congestion
                Avoidance in the Internet", <a href="rfc2309.html">RFC 2309</a>, April 1998.

   [<a id="ref-RFC2357" name="ref-RFC2357">RFC2357</a>]    Mankin, A., Romanow, A., Bradner, S. and V. Paxson,
                "IETF Criteria for Evaluating Reliable Multicast
                Transport and Application Protocols", <a href="rfc2357.html">RFC 2357</a>, June
                1998.

   [<a id="ref-RFC2414" name="ref-RFC2414">RFC2414</a>]    Allman, M., Floyd, S. and C. Partridge, "Increasing
                TCP's Initial Window", <a href="rfc2414.html">RFC 2414</a>, September 1998.

   [<a id="ref-RFC2475" name="ref-RFC2475">RFC2475</a>]    Blake, S., Black, D., Carlson, M., Davies, E., Wang, Z.
                and W.  Weiss, "An Architecture for Differentiated
                Services", <a href="rfc2475.html">RFC 2475</a>, December 1998.

   [<a id="ref-RFC2481" name="ref-RFC2481">RFC2481</a>]    Ramakrishnan K. and S. Floyd, "A Proposal to add
                Explicit Congestion Notification (ECN) to IP", <a href="rfc2481.html">RFC 2481</a>,
                January 1999.

   [<a id="ref-RFC2525" name="ref-RFC2525">RFC2525</a>]    Paxson, V., Allman, M., Dawson, S., Fenner, W., Griner,
                J., Heavens, I., Lahey, K., Semke, J. and B. Volz,
                "Known TCP Implementation Problems", <a href="rfc2525.html">RFC 2525</a>, March
                1999.

   [<a id="ref-RFC2581" name="ref-RFC2581">RFC2581</a>]    Allman, M., Paxson, V. and W. Stevens, "TCP Congestion
                Control", <a href="rfc2581.html">RFC 2581</a>, April 1999.

   [<a id="ref-RFC2582" name="ref-RFC2582">RFC2582</a>]    Floyd, S. and T. Henderson, "The NewReno Modification to
                TCP's Fast Recovery Algorithm", <a href="rfc2582.html">RFC 2582</a>, April 1999.

   [<a id="ref-RFC2616" name="ref-RFC2616">RFC2616</a>]    Fielding, R., Gettys, J., Mogul, J., Frystyk, H.,
                Masinter, L., Leach, P. and T. Berners-Lee, "Hypertext
                Transfer Protocol -- HTTP/1.1", <a href="rfc2616.html">RFC 2616</a>, June 1999.




<span class="grey">Floyd, ed.               Best Current Practice                 [Page 12]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-13" id="page-13" name="page-13"> </a>
<span class="grey"><a href="rfc2914.html">RFC 2914</a>             Congestion Control Principles        September 2000</span>


   [<a id="ref-SCWA99" name="ref-SCWA99">SCWA99</a>]     S. Savage, N. Cardwell, D. Wetherall, and T. Anderson,
                TCP Congestion Control with a Misbehaving Receiver, ACM
                Computer Communications Review, October 1999.

   [<a id="ref-TCPB98" name="ref-TCPB98">TCPB98</a>]     Hari Balakrishnan, Venkata N. Padmanabhan, Srinivasan
                Seshan, Mark Stemm, and Randy H. Katz, TCP Behavior of a
                Busy Internet Server: Analysis and Improvements, IEEE
                Infocom, March 1998.  Available from:
                "<a href="http://www.cs.berkeley.edu/~hari/papers/infocom98.ps.gz">http://www.cs.berkeley.edu/~hari/papers/infocom98.ps.gz</a>".

   [<a id="ref-TCPF98" name="ref-TCPF98">TCPF98</a>]     Dong Lin and H.T. Kung, TCP Fast Recovery Strategies:
                Analysis and Improvements, IEEE Infocom, March 1998.
                Available from:
                "<a href="http://www.eecs.harvard.edu/networking/papers/infocom-tcp-final-198.pdf">http://www.eecs.harvard.edu/networking/papers/infocom-</a>
                <a href="http://www.eecs.harvard.edu/networking/papers/infocom-tcp-final-198.pdf">tcp-final-198.pdf</a>".

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/9.%20%20TCP-Specific%20issues"></a><a class="selflink" href="#section-9" name="section-9">9</a>.  TCP-Specific issues</span>

   In this section we discuss some of the particulars of TCP congestion
   control, to illustrate a realization of the congestion control
   principles, including some of the details that arise when
   incorporating them into a production transport protocol.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/9.1.%20%20Slow-start."></a><a class="selflink" href="#section-9.1" name="section-9.1">9.1</a>.  Slow-start.</span>

   The TCP sender can not open a new connection by sending a large burst
   of data (e.g., a receiver's advertised window) all at once.  The TCP
   sender is limited by a small initial value for the congestion window.
   During slow-start, the TCP sender can increase its sending rate by at
   most a factor of two in one roundtrip time.  Slow-start ends when
   congestion is detected, or when the sender's congestion window is
   greater than the slow-start threshold ssthresh.

   An issue that potentially affects global congestion control, and
   therefore has been explicitly addressed in the standards process,
   includes an increase in the value of the initial window
   [RFC2414,<a href="rfc2581.html">RFC2581</a>].

   Issues that have not been addressed in the standards process, and are
   generally considered not to require standardization, include such
   issues as the use (or non-use) of rate-based pacing, and mechanisms
   for ending slow-start early, before the congestion window reaches
   ssthresh.  Such mechanisms result in slow-start behavior that is as
   conservative or more conservative than standard TCP.







<span class="grey">Floyd, ed.               Best Current Practice                 [Page 13]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-14" id="page-14" name="page-14"> </a>
<span class="grey"><a href="rfc2914.html">RFC 2914</a>             Congestion Control Principles        September 2000</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/9.2.%20%20Additive%20Increase%2C%20Multiplicative%20Decrease."></a><a class="selflink" href="#section-9.2" name="section-9.2">9.2</a>.  Additive Increase, Multiplicative Decrease.</span>

   In the absence of congestion, the TCP sender increases its congestion
   window by at most one packet per roundtrip time. In response to a
   congestion indication, the TCP sender decreases its congestion window
   by half.  (More precisely, the new congestion window is half of the
   minimum of the congestion window and the receiver's advertised
   window.)

   An issue that potentially affects global congestion control, and
   therefore would be likely to be explicitly addressed in the standards
   process, would include a proposed addition of congestion control for
   the return stream of `pure acks'.

   An issue that has not been addressed in the standards process, and is
   generally not considered to require standardization, would be a
   change to the congestion window to apply as an upper bound on the
   number of bytes presumed to be in the pipe, instead of applying as a
   sliding window starting from the cumulative acknowledgement.
   (Clearly, the receiver's advertised window applies as a sliding
   window starting from the cumulative acknowledgement field, because
   packets received above the cumulative acknowledgement field are held
   in TCP's receive buffer, and have not been delivered to the
   application.  However, the congestion window applies to the number of
   packets outstanding in the pipe, and does not necessarily have to
   include packets that have been received out-of-order by the TCP
   receiver.)

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/9.3.%20%20Retransmit%20timers."></a><a class="selflink" href="#section-9.3" name="section-9.3">9.3</a>.  Retransmit timers.</span>

   The TCP sender sets a retransmit timer to infer that a packet has
   been dropped in the network.  When the retransmit timer expires, the
   sender infers that a packet has been lost, sets ssthresh to half of
   the current window, and goes into slow-start, retransmitting the lost
   packet.  If the retransmit timer expires because no acknowledgement
   has been received for a retransmitted packet, the retransmit timer is
   also "backed-off", doubling the value of the next retransmit timeout
   interval.

   An issue that potentially affects global congestion control, and
   therefore would be likely to be explicitly addressed in the standards
   process, might include a modified mechanism for setting the
   retransmit timer that could significantly increase the number of
   retransmit timers that expire prematurely, when the acknowledgement
   has not yet arrived at the sender, but in fact no packets have been
   dropped.  This could be of concern to the Internet standards process





<span class="grey">Floyd, ed.               Best Current Practice                 [Page 14]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-15" id="page-15" name="page-15"> </a>
<span class="grey"><a href="rfc2914.html">RFC 2914</a>             Congestion Control Principles        September 2000</span>


   because retransmit timers that expire prematurely could lead to an
   increase in the number of packets unnecessarily transmitted on a
   congested link.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/9.4.%20%20Fast%20Retransmit%20and%20Fast%20Recovery."></a><a class="selflink" href="#section-9.4" name="section-9.4">9.4</a>.  Fast Retransmit and Fast Recovery.</span>

   After seeing three duplicate acknowledgements, the TCP sender infers
   a packet loss.  The TCP sender sets ssthresh to half of the current
   window, reduces the congestion window to at most half of the previous
   window, and retransmits the lost packet.

   An issue that potentially affects global congestion control, and
   therefore would be likely to be explicitly addressed in the standards
   process, might include a proposal (if there was one) for inferring a
   lost packet after only one or two duplicate acknowledgements.  If
   poorly designed, such a proposal could lead to an increase in the
   number of packets unnecessarily transmitted on a congested path.

   An issue that has not been addressed in the standards process, and
   would not be expected to require standardization, would be a proposal
   to send a "new" or presumed-lost packet in response to a duplicate or
   partial acknowledgement, if allowed by the congestion window.  An
   example of this would be sending a new packet in response to a single
   duplicate acknowledgement, to keep the `ack clock' going in case no
   further acknowledgements would have arrived.  Such a proposal is an
   example of a beneficial change that does not involve interoperability
   and does not affect global congestion control, and that therefore
   could be implemented by vendors without requiring the intervention of
   the IETF standards process.  (This issue has in fact been addressed
   in [<a href="#ref-DMKM00" title='"End-to-end Performance Implications of Slow Links"'>DMKM00</a>], which suggests that "researchers may wish to experiment
   with injecting new traffic into the network when duplicate
   acknowledgements are being received, as described in [<a href="#ref-TCPB98" title='"http://www.cs.berkeley.edu/~hari/papers/infocom98.ps.gz"'>TCPB98</a>] and
   [<a href="#ref-TCPF98" title='"http://www.eecs.harvard.edu/networking/papers/infocom- tcp-final-198.pdf"'>TCPF98</a>]."

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/9.5.%20%20Other%20aspects%20of%20TCP%20congestion%20control."></a><a class="selflink" href="#section-9.5" name="section-9.5">9.5</a>.  Other aspects of TCP congestion control.</span>

   Other aspects of TCP congestion control that have not been discussed
   in any of the sections above include TCP's recovery from an idle or
   application-limited period [<a href="#ref-HPF00" title='"TCP Congestion Window Validation"'>HPF00</a>].

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/10.%20Security%20Considerations"></a><a class="selflink" href="#section-10" name="section-10">10</a>. Security Considerations</span>

   This document has been about the risks associated with congestion
   control, or with the absence of congestion control.  <a href="#section-3.2">Section 3.2</a>
   discusses the potentials for unfairness if competing flows don't use
   compatible congestion control mechanisms, and <a href="#section-5">Section 5</a> considers the
   dangers of congestion collapse if flows don't use end-to-end
   congestion control.



<span class="grey">Floyd, ed.               Best Current Practice                 [Page 15]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-16" id="page-16" name="page-16"> </a>
<span class="grey"><a href="rfc2914.html">RFC 2914</a>             Congestion Control Principles        September 2000</span>


   Because this document does not propose any specific congestion
   control mechanisms, it is also not necessary to present specific
   security measures associated with congestion control.  However, we
   would note that there are a range of security considerations
   associated with congestion control that should be considered in IETF
   documents.

   For example, individual congestion control mechanisms should be as
   robust as possible to the attempts of individual end-nodes to subvert
   end-to-end congestion control [<a href="#ref-SCWA99" title=" TCP Congestion Control with a Misbehaving Receiver">SCWA99</a>].  This is a particular concern
   in multicast congestion control, because of the far-reaching
   distribution of the traffic and the greater opportunities for
   individual receivers to fail to report congestion.

   <a href="rfc2309.html">RFC 2309</a> also discussed the potential dangers to the Internet of
   unresponsive flows, that is, flows that don't reduce their sending
   rate in the presence of congestion, and describes the need for
   mechanisms in the network to deal with flows that are unresponsive to
   congestion notification.  We would note that there is still a need
   for research, engineering, measurement, and deployment in these
   areas.

   Because the Internet aggregates very large numbers of flows, the risk
   to the whole infrastructure of subverting the congestion control of a
   few individual flows is limited.  Rather, the risk to the
   infrastructure would come from the widespread deployment of many
   end-nodes subverting end-to-end congestion control.

AUTHOR'S ADDRESS

   Sally Floyd
   AT&amp;T Center for Internet Research at ICSI (ACIRI)

   Phone: +1 (510) 642-4274 x189
   EMail: floyd@aciri.org
   URL: <a href="http://www.aciri.org/floyd/">http://www.aciri.org/floyd/</a>















<span class="grey">Floyd, ed.               Best Current Practice                 [Page 16]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-17" id="page-17" name="page-17"> </a>
<span class="grey"><a href="rfc2914.html">RFC 2914</a>             Congestion Control Principles        September 2000</span>


Full Copyright Statement

   Copyright (C) The Internet Society (2000).  All Rights Reserved.

   This document and translations of it may be copied and furnished to
   others, and derivative works that comment on or otherwise explain it
   or assist in its implementation may be prepared, copied, published
   and distributed, in whole or in part, without restriction of any
   kind, provided that the above copyright notice and this paragraph are
   included on all such copies and derivative works.  However, this
   document itself may not be modified in any way, such as by removing
   the copyright notice or references to the Internet Society or other
   Internet organizations, except as needed for the purpose of
   developing Internet standards in which case the procedures for
   copyrights defined in the Internet Standards process must be
   followed, or as required to translate it into languages other than
   English.

   The limited permissions granted above are perpetual and will not be
   revoked by the Internet Society or its successors or assigns.

   This document and the information contained herein is provided on an
   "AS IS" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING
   TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING
   BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION
   HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF
   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.

Acknowledgement

   Funding for the RFC Editor function is currently provided by the
   Internet Society.



















Floyd, ed.               Best Current Practice                 [Page 17]

</pre><br/>
    <span class="noprint"><small><small>Html markup produced by rfcmarkup 1.126, available from
      <a href="https://tools.ietf.org/tools/rfcmarkup/">https://tools.ietf.org/tools/rfcmarkup/</a>
    </small></small></span>
  </div>




</body><!-- Mirrored from tools.ietf.org/html/rfc2914 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 06 Mar 2018 23:18:49 GMT --></html>