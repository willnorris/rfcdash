<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

<!-- Mirrored from tools.ietf.org/html/rfc7766 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 06 Mar 2018 23:18:20 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head profile="http://dublincore.org/documents/2008/08/04/dc-html/">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="robots" content="index,follow" />
    <meta name="creator" content="rfcmarkup version 1.126" />
    <link rel="schema.DC" href="http://purl.org/dc/elements/1.1/" />
<meta name="DC.Relation.Replaces" content="rfc5966" />
<meta name="DC.Identifier" content="urn:ietf:rfc:7766" />
<meta name="DC.Date.Issued" content="March, 2016" />
<meta name="DC.Creator" content="Wessels, Duane" />
<meta name="DC.Creator" content="Dickinson, Sara" />
<meta name="DC.Creator" content="Bellis, Ray" />
<meta name="DC.Creator" content="Mankin, Allison" />
<meta name="DC.Creator" content="Dickinson, John" />
<meta name="DC.Description.Abstract" content="This document specifies the requirement for support of TCP as a
transport protocol for DNS implementations and provides guidelines
towards DNS-over-TCP performance on par with that of DNS-over-UDP.
This document obsoletes RFC 5966 and therefore updates RFC 1035 and
RFC 1123." />
<meta name="DC.Title" content="DNS Transport over TCP - Implementation Requirements" />

    <link rel="icon" href="https://tools.ietf.org/images/rfc.png" type="image/png" />
    <link rel="shortcut icon" href="https://tools.ietf.org/images/rfc.png" type="image/png" />
    <title>RFC 7766 - DNS Transport over TCP - Implementation Requirements</title>
    
    
    <style type="text/css">
	@media only screen 
	  and (min-width: 992px)
	  and (max-width: 1199px) {
	    body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 768px)
	  and (max-width: 991px) {
            body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 480px)
	  and (max-width: 767px) {
            body { font-size: 11pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (max-width: 479px) {
            body { font-size: 8pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-device-width : 375px) 
	  and (max-device-width : 667px) {
            body { font-size: 9.5pt; }
            div.content { width: 96ex; margin: 0 1px; }
        }
	@media only screen 
	  and (min-device-width: 1200px) {
            body { font-size: 10pt; margin: 0 4em; }
            div.content { width: 96ex; margin: 0; }
        }
        h1, h2, h3, h4, h5, h6, .h1, .h2, .h3, .h4, .h5, .h6 {
	    font-weight: bold;
            line-height: 0pt;
            display: inline;
            white-space: pre;
            font-family: monospace;
            font-size: 1em;
	    font-weight: bold;
        }
        pre {
            font-size: 1em;
            margin-top: 0px;
            margin-bottom: 0px;
        }
	.pre {
	    white-space: pre;
	    font-family: monospace;
	}
	.header{
	    font-weight: bold;
	}
        .newpage {
            page-break-before: always;
        }
        .invisible {
            text-decoration: none;
            color: white;
        }
        a.selflink {
          color: black;
          text-decoration: none;
        }
        @media print {
            body {
                font-family: monospace;
                font-size: 10.5pt;
            }
            h1, h2, h3, h4, h5, h6 {
                font-size: 1em;
            }
        
            a:link, a:visited {
                color: inherit;
                text-decoration: none;
            }
            .noprint {
                display: none;
            }
        }
	@media screen {
	    .grey, .grey a:link, .grey a:visited {
		color: #777;
	    }
            .docinfo {
                background-color: #EEE;
            }
            .top {
                border-top: 7px solid #EEE;
            }
            .bgwhite  { background-color: white; }
            .bgred    { background-color: #F44; }
            .bggrey   { background-color: #666; }
            .bgbrown  { background-color: #840; }            
            .bgorange { background-color: #FA0; }
            .bgyellow { background-color: #EE0; }
            .bgmagenta{ background-color: #F4F; }
            .bgblue   { background-color: #66F; }
            .bgcyan   { background-color: #4DD; }
            .bggreen  { background-color: #4F4; }

            .legend   { font-size: 90%; }
            .cplate   { font-size: 70%; border: solid grey 1px; }
	}
    </style>
    <!--[if IE]>
    <style>
    body {
       font-size: 13px;
       margin: 10px 10px;
    }
    </style>
    <![endif]-->

    <script type="text/javascript"><!--
    function addHeaderTags() {
	var spans = document.getElementsByTagName("span");
	for (var i=0; i < spans.length; i++) {
	    var elem = spans[i];
	    if (elem) {
		var level = elem.getAttribute("class");
                if (level == "h1" || level == "h2" || level == "h3" || level == "h4" || level == "h5" || level == "h6") {
                    elem.innerHTML = "<"+level+">"+elem.innerHTML+"</"+level+">";		
                }
	    }
	}
    }
    var legend_html = "Colour legend:<br />      <table>         <tr><td>Unknown:</td>                   <td><span class='cplate bgwhite'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft:</td>                     <td><span class='cplate bgred'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Informational:</td>             <td><span class='cplate bgorange'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Experimental:</td>              <td><span class='cplate bgyellow'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Best Common Practice:</td>      <td><span class='cplate bgmagenta'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Proposed Standard:</td>         <td><span class='cplate bgblue'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft Standard (old designation):</td> <td><span class='cplate bgcyan'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Internet Standard:</td>         <td><span class='cplate bggreen'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Historic:</td>                  <td><span class='cplate bggrey'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Obsolete:</td>                  <td><span class='cplate bgbrown'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>     </table>";
    function showElem(id) {
        var elem = document.getElementById(id);
        elem.innerHTML = eval(id+"_html");
        elem.style.visibility='visible';
    }
    function hideElem(id) {
        var elem = document.getElementById(id);
        elem.style.visibility='hidden';        
        elem.innerHTML = "";
    }
    // -->
    </script>
</head>
<body onload="addHeaderTags()">
  <div class="content">
   <div style="height: 13px;">
      <div onmouseover="this.style.cursor='pointer';"
         onclick="showElem('legend');"
         onmouseout="hideElem('legend')"
	 style="height: 6px; position: absolute;"
         class="pre noprint docinfo bgblue"
         title="Click for colour legend." >                                                                        </div>
      <div id="legend"
           class="docinfo noprint pre legend"
           style="position:absolute; top: 4px; left: 4ex; visibility:hidden; background-color: white; padding: 4px 9px 5px 7px; border: solid #345 1px; "
           onmouseover="showElem('legend');"
           onmouseout="hideElem('legend');">
      </div>
   </div>
<span class="pre noprint docinfo top">[<a href="index.html" title="Document search and retrieval page">Docs</a>] [<a href="https://tools.ietf.org/rfc/rfc7766.txt" title="Plaintext version of this document">txt</a>|<a href="https://tools.ietf.org/pdf/rfc7766" title="PDF version of this document">pdf</a>] [<a href="https://tools.ietf.org/html/draft-ietf-dnsop-5966bis" title="draft-ietf-dnsop-5966bis">draft-ietf-dnso...</a>] [<a href='https://datatracker.ietf.org/doc/rfc7766' title='IESG Datatracker information for this document'>Tracker</a>] [<a href="https://tools.ietf.org/rfcdiff?difftype=--hwdiff&amp;url2=rfc7766" title="Inline diff (wdiff)">Diff1</a>] [<a href="https://tools.ietf.org/rfcdiff?url2=rfc7766" title="Side-by-side diff">Diff2</a>]         </span><br />
<span class="pre noprint docinfo">                                                                        </span><br />
<span class="pre noprint docinfo">                                                       PROPOSED STANDARD</span><br />
<span class="pre noprint docinfo">                                                                        </span><br />
<pre>
Internet Engineering Task Force (IETF)                      J. Dickinson
Request for Comments: 7766                                  S. Dickinson
Obsoletes: <a href="rfc5966.html">5966</a>                                                  Sinodun
Updates: <a href="rfc1035.html">1035</a>, <a href="rfc1123.html">1123</a>                                            R. Bellis
Category: Standards Track                                            ISC
ISSN: 2070-1721                                                A. Mankin
                                                              D. Wessels
                                                           Verisign Labs
                                                              March 2016


          <span class="h1">DNS Transport over TCP - Implementation Requirements</span>

Abstract

   This document specifies the requirement for support of TCP as a
   transport protocol for DNS implementations and provides guidelines
   towards DNS-over-TCP performance on par with that of DNS-over-UDP.
   This document obsoletes <a href="rfc5966.html">RFC 5966</a> and therefore updates <a href="rfc1035.html">RFC 1035</a> and
   <a href="rfc1123.html">RFC 1123</a>.

Status of This Memo

   This is an Internet Standards Track document.

   This document is a product of the Internet Engineering Task Force
   (IETF).  It represents the consensus of the IETF community.  It has
   received public review and has been approved for publication by the
   Internet Engineering Steering Group (IESG).  Further information on
   Internet Standards is available in <a href="rfc5741.html#section-2">Section&nbsp;2 of RFC 5741</a>.

   Information about the current status of this document, any errata,
   and how to provide feedback on it may be obtained at
   <a href="http://www.rfc-editor.org/info/rfc7766">http://www.rfc-editor.org/info/rfc7766</a>.

















<span class="grey">Dickinson, et al.            Standards Track                    [Page 1]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-2" id="page-2" href="#page-2" class="invisible"> </a>
<span class="grey"><a href="rfc7766.html">RFC 7766</a>                      DNS over TCP                    March 2016</span>


Copyright Notice

   Copyright (c) 2016 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to <a href="https://tools.ietf.org/html/bcp78">BCP 78</a> and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (<a href="http://trustee.ietf.org/license-info">http://trustee.ietf.org/license-info</a>) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.

Table of Contents

   <a href="#section-1">1</a>.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   <a href="#page-3">3</a>
   <a href="#section-2">2</a>.  Requirements Terminology  . . . . . . . . . . . . . . . . . .   <a href="#page-4">4</a>
   <a href="#section-3">3</a>.  Terminology . . . . . . . . . . . . . . . . . . . . . . . . .   <a href="#page-4">4</a>
   <a href="#section-4">4</a>.  Discussion  . . . . . . . . . . . . . . . . . . . . . . . . .   <a href="#page-4">4</a>
   <a href="#section-5">5</a>.  Transport Protocol Selection  . . . . . . . . . . . . . . . .   <a href="#page-5">5</a>
   <a href="#section-6">6</a>.  Connection Handling . . . . . . . . . . . . . . . . . . . . .   <a href="#page-6">6</a>
     <a href="#section-6.1">6.1</a>.  Current Practices . . . . . . . . . . . . . . . . . . . .   <a href="#page-6">6</a>
       <a href="#section-6.1.1">6.1.1</a>.  Clients . . . . . . . . . . . . . . . . . . . . . . .   <a href="#page-7">7</a>
       <a href="#section-6.1.2">6.1.2</a>.  Servers . . . . . . . . . . . . . . . . . . . . . . .   <a href="#page-7">7</a>
     <a href="#section-6.2">6.2</a>.  Recommendations . . . . . . . . . . . . . . . . . . . . .   <a href="#page-8">8</a>
       <a href="#section-6.2.1">6.2.1</a>.  Connection Reuse  . . . . . . . . . . . . . . . . . .   <a href="#page-8">8</a>
         <a href="#section-6.2.1.1">6.2.1.1</a>.  Query Pipelining  . . . . . . . . . . . . . . . .   <a href="#page-8">8</a>
       <a href="#section-6.2.2">6.2.2</a>.  Concurrent Connections  . . . . . . . . . . . . . . .   <a href="#page-9">9</a>
       <a href="#section-6.2.3">6.2.3</a>.  Idle Timeouts . . . . . . . . . . . . . . . . . . . .   <a href="#page-9">9</a>
       <a href="#section-6.2.4">6.2.4</a>.  Teardown  . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-10">10</a>
   <a href="#section-7">7</a>.  Response Reordering . . . . . . . . . . . . . . . . . . . . .  <a href="#page-10">10</a>
   <a href="#section-8">8</a>.  TCP Message Length Field  . . . . . . . . . . . . . . . . . .  <a href="#page-11">11</a>
   <a href="#section-9">9</a>.  TCP Fast Open . . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-11">11</a>
   <a href="#section-10">10</a>. Security Considerations . . . . . . . . . . . . . . . . . . .  <a href="#page-12">12</a>
   <a href="#section-11">11</a>. References  . . . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-13">13</a>
     <a href="#section-11.1">11.1</a>.  Normative References . . . . . . . . . . . . . . . . . .  <a href="#page-13">13</a>
     <a href="#section-11.2">11.2</a>.  Informative References . . . . . . . . . . . . . . . . .  <a href="#page-14">14</a>
   <a href="#appendix-A">Appendix A</a>.  Summary of Advantages and Disadvantages to Using TCP
                for DNS  . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-16">16</a>
   <a href="#appendix-B">Appendix B</a>.  Changes to <a href="rfc5966.html">RFC 5966</a>  . . . . . . . . . . . . . . . .  <a href="#page-16">16</a>
   Acknowledgements  . . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-17">17</a>
   Authors' Addresses  . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-18">18</a>







<span class="grey">Dickinson, et al.            Standards Track                    [Page 2]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-3" id="page-3" href="#page-3" class="invisible"> </a>
<span class="grey"><a href="rfc7766.html">RFC 7766</a>                      DNS over TCP                    March 2016</span>


<span class="h2"><a class="selflink" name="section-1" href="#section-1">1</a>.  Introduction</span>

   Most DNS [<a href="rfc1034.html" title="&quot;Domain names - concepts and facilities&quot;">RFC1034</a>] transactions take place over UDP [<a href="rfc768.html" title="&quot;User Datagram Protocol&quot;">RFC768</a>].  TCP
   [<a href="rfc793.html" title="&quot;Transmission Control Protocol&quot;">RFC793</a>] is always used for full zone transfers (using AXFR) and is
   often used for messages whose sizes exceed the DNS protocol's
   original 512-byte limit.  The growing deployment of DNS Security
   (DNSSEC) and IPv6 has increased response sizes and therefore the use
   of TCP.  The need for increased TCP use has also been driven by the
   protection it provides against address spoofing and therefore
   exploitation of DNS in reflection/amplification attacks.  It is now
   widely used in Response Rate Limiting [<a href="#ref-RRL1" title="&quot;DNS Response Rate Limiting (DNS RRL)&quot;">RRL1</a>] [<a href="#ref-RRL2" title="&quot;Using the Response Rate Limiting Feature in BIND 9.10&quot;">RRL2</a>].  Additionally,
   recent work on DNS privacy solutions such as [<a href="#ref-DNS-over-TLS">DNS-over-TLS</a>] is
   another motivation to revisit DNS-over-TCP requirements.

   <a href="rfc1123.html#section-6.1.3.2">Section&nbsp;6.1.3.2 of [RFC1123]</a> states:

      DNS resolvers and recursive servers MUST support UDP, and SHOULD
      support TCP, for sending (non-zone-transfer) queries.

   However, some implementors have taken the text quoted above to mean
   that TCP support is an optional feature of the DNS protocol.

   The majority of DNS server operators already support TCP, and the
   default configuration for most software implementations is to support
   TCP.  The primary audience for this document is those implementors
   whose limited support for TCP restricts interoperability and hinders
   deployment of new DNS features.

   This document therefore updates the core DNS protocol specifications
   such that support for TCP is henceforth a REQUIRED part of a full DNS
   protocol implementation.

   There are several advantages and disadvantages to the increased use
   of TCP (see <a href="#appendix-A">Appendix A</a>) as well as implementation details that need
   to be considered.  This document addresses these issues and presents
   TCP as a valid transport alternative for DNS.  It extends the content
   of [<a href="rfc5966.html" title="&quot;DNS Transport over TCP - Implementation Requirements&quot;">RFC5966</a>], with additional considerations and lessons learned from
   research, developments, and implementation of TCP in DNS and in other
   Internet protocols.

   Whilst this document makes no specific requirements for operators of
   DNS servers to meet, it does offer some suggestions to operators to
   help ensure that support for TCP on their servers and network is
   optimal.  It should be noted that failure to support TCP (or the
   blocking of DNS over TCP at the network layer) will probably result
   in resolution failure and/or application-level timeouts.





<span class="grey">Dickinson, et al.            Standards Track                    [Page 3]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-4" id="page-4" href="#page-4" class="invisible"> </a>
<span class="grey"><a href="rfc7766.html">RFC 7766</a>                      DNS over TCP                    March 2016</span>


<span class="h2"><a class="selflink" name="section-2" href="#section-2">2</a>.  Requirements Terminology</span>

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in [<a href="rfc2119.html" title="&quot;Key words for use in RFCs to Indicate Requirement Levels&quot;">RFC2119</a>].

<span class="h2"><a class="selflink" name="section-3" href="#section-3">3</a>.  Terminology</span>

   o  Persistent connection: a TCP connection that is not closed either
      by the server after sending the first response nor by the client
      after receiving the first response.

   o  Connection Reuse: the sending of multiple queries and responses
      over a single TCP connection.

   o  Idle DNS-over-TCP session: Clients and servers view application-
      level idleness differently.  A DNS client considers an established
      DNS-over-TCP session to be idle when it has no pending queries to
      send and there are no outstanding responses.  A DNS server
      considers an established DNS-over-TCP session to be idle when it
      has sent responses to all the queries it has received on that
      connection.

   o  Pipelining: the sending of multiple queries and responses over a
      single TCP connection but not waiting for any outstanding replies
      before sending another query.

   o  Out-of-Order Processing: The processing of queries concurrently
      and the returning of individual responses as soon as they are
      available, possibly out of order.  This will most likely occur in
      recursive servers; however, it is possible in authoritative
      servers that, for example, have different backend data stores.

<span class="h2"><a class="selflink" name="section-4" href="#section-4">4</a>.  Discussion</span>

   In the absence of EDNS0 (Extension Mechanisms for DNS 0 [<a href="rfc6891.html" title="&quot;Extension Mechanisms for DNS (EDNS(0))&quot;">RFC6891</a>];
   see below), the normal behaviour of any DNS server that needs to send
   a UDP response that would exceed the 512-byte limit is for the server
   to truncate the response so that it fits within that limit and then
   set the TC flag in the response header.  When the client receives
   such a response, it takes the TC flag as an indication that it should
   retry over TCP instead.









<span class="grey">Dickinson, et al.            Standards Track                    [Page 4]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-5" id="page-5" href="#page-5" class="invisible"> </a>
<span class="grey"><a href="rfc7766.html">RFC 7766</a>                      DNS over TCP                    March 2016</span>


   <a href="rfc1123.html">RFC 1123</a> also says:

      ... it is also clear that some new DNS record types defined in the
      future will contain information exceeding the 512 byte limit that
      applies to UDP, and hence will require TCP.  Thus, resolvers and
      name servers should implement TCP services as a backup to UDP
      today, with the knowledge that they will require the TCP service
      in the future.

   Existing deployments of DNSSEC [<a href="rfc4033.html" title="&quot;DNS Security Introduction and Requirements&quot;">RFC4033</a>] have shown that truncation
   at the 512-byte boundary is now commonplace.  For example, a Non-
   Existent Domain (NXDOMAIN) (RCODE == 3) response from a DNSSEC-signed
   zone using NextSECure 3 (NSEC3) [<a href="rfc5155.html" title="&quot;DNS Security (DNSSEC) Hashed Authenticated Denial of Existence&quot;">RFC5155</a>] is almost invariably larger
   than 512 bytes.

   Since the original core specifications for DNS were written, the
   extension mechanisms for DNS have been introduced.  These extensions
   can be used to indicate that the client is prepared to receive UDP
   responses larger than 512 bytes.  An EDNS0-compatible server
   receiving a request from an EDNS0-compatible client may send UDP
   packets up to that client's announced buffer size without truncation.

   However, transport of UDP packets that exceed the size of the path
   MTU causes IP packet fragmentation, which has been found to be
   unreliable in many circumstances.  Many firewalls routinely block
   fragmented IP packets, and some do not implement the algorithms
   necessary to reassemble fragmented packets.  Worse still, some
   network devices deliberately refuse to handle DNS packets containing
   EDNS0 options.  Other issues relating to UDP transport and packet
   size are discussed in [<a href="rfc5625.html" title="&quot;DNS Proxy Implementation Guidelines&quot;">RFC5625</a>].

   The MTU most commonly found in the core of the Internet is around
   1500 bytes, and even that limit is routinely exceeded by DNSSEC-
   signed responses.

   The future that was anticipated in <a href="rfc1123.html">RFC 1123</a> has arrived, and the only
   standardised UDP-based mechanism that may have resolved the packet
   size issue has been found inadequate.

<span class="h2"><a class="selflink" name="section-5" href="#section-5">5</a>.  Transport Protocol Selection</span>

   <a href="rfc1123.html#section-6.1.3.2">Section&nbsp;6.1.3.2 of [RFC1123]</a> is updated: All general-purpose DNS
   implementations MUST support both UDP and TCP transport.

   o  Authoritative server implementations MUST support TCP so that they
      do not limit the size of responses to what fits in a single UDP
      packet.




<span class="grey">Dickinson, et al.            Standards Track                    [Page 5]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-6" id="page-6" href="#page-6" class="invisible"> </a>
<span class="grey"><a href="rfc7766.html">RFC 7766</a>                      DNS over TCP                    March 2016</span>


   o  Recursive server (or forwarder) implementations MUST support TCP
      so that they do not prevent large responses from a TCP-capable
      server from reaching its TCP-capable clients.

   o  Stub resolver implementations (e.g., an operating system's DNS
      resolution library) MUST support TCP since to do otherwise would
      limit the interoperability between their own clients and upstream
      servers.

   Regarding the choice of when to use UDP or TCP, <a href="rfc1123.html#section-6.1.3.2">Section&nbsp;6.1.3.2 of
   RFC 1123</a> also says:

      ... a DNS resolver or server that is sending a non-zone-transfer
      query MUST send a UDP query first.

   This requirement is hereby relaxed.  Stub resolvers and recursive
   resolvers MAY elect to send either TCP or UDP queries depending on
   local operational reasons.  TCP MAY be used before sending any UDP
   queries.  If the resolver already has an open TCP connection to the
   server, it SHOULD reuse this connection.  In essence, TCP ought to be
   considered a valid alternative transport to UDP, not purely a retry
   option.

   In addition, it is noted that all recursive and authoritative servers
   MUST send responses using the same transport as the query arrived on.
   In the case of TCP, this MUST also be the same connection.

<span class="h2"><a class="selflink" name="section-6" href="#section-6">6</a>.  Connection Handling</span>

<span class="h3"><a class="selflink" name="section-6.1" href="#section-6.1">6.1</a>.  Current Practices</span>

   <a href="rfc1035.html#section-4.2.2">Section&nbsp;4.2.2 of [RFC1035]</a> says:

   -  The server should assume that the client will initiate connection
      closing, and should delay closing its end of the connection until
      all outstanding client requests have been satisfied.

   -  If the server needs to close a dormant connection to reclaim
      resources, it should wait until the connection has been idle for a
      period on the order of two minutes.  In particular, the server
      should allow the SOA and AXFR request sequence (which begins a
      refresh operation) to be made on a single connection.  Since the
      server would be unable to answer queries anyway, a unilateral
      close or reset may be used instead of graceful close.







<span class="grey">Dickinson, et al.            Standards Track                    [Page 6]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-7" id="page-7" href="#page-7" class="invisible"> </a>
<span class="grey"><a href="rfc7766.html">RFC 7766</a>                      DNS over TCP                    March 2016</span>


   Other more modern protocols (e.g., HTTP/1.1 [<a href="rfc7230.html" title="&quot;Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing&quot;">RFC7230</a>], HTTP/2
   [<a href="rfc7540.html" title="&quot;Hypertext Transfer Protocol Version 2 (HTTP/2)&quot;">RFC7540</a>]) have support by default for persistent TCP connections for
   all requests.  Connections are then normally closed via a 'connection
   close' signal from one party.

   The description in [<a href="rfc1035.html" title="&quot;Domain names - implementation and specification&quot;">RFC1035</a>] is clear that servers should view
   connections as persistent (particularly after receiving an SOA), but
   unfortunately does not provide enough detail for an unambiguous
   interpretation of client behaviour for queries other than a SOA.
   Additionally, DNS does not yet have a signalling mechanism for
   connection timeout or close, although some have been proposed.

<span class="h4"><a class="selflink" name="section-6.1.1" href="#section-6.1.1">6.1.1</a>.  Clients</span>

   There is no clear guidance today in any RFC as to when a DNS client
   should close a TCP connection, and there are no specific
   recommendations with regard to DNS client idle timeouts.  However, at
   the time of writing, it is common practice for clients to close the
   TCP connection after sending a single request (apart from the SOA/
   AXFR case).

<span class="h4"><a class="selflink" name="section-6.1.2" href="#section-6.1.2">6.1.2</a>.  Servers</span>

   Many DNS server implementations use a long fixed idle timeout and
   default to a small number of TCP connections.  They also offer little
   in the way of TCP connection management options.  The disadvantages
   of this include:

   o  Operational experience has shown that long server timeouts can
      easily cause resource exhaustion and poor response under heavy
      load.

   o  Intentionally opening many connections and leaving them idle can
      trivially create a TCP denial of service (DoS) attack as many DNS
      servers are poorly equipped to defend against this by modifying
      their idle timeouts or other connection management policies.

   o  A modest number of clients that all concurrently attempt to use
      persistent connections with non-zero idle timeouts to such a
      server could unintentionally cause the same DoS problem.

   Note that this DoS is only on the TCP service.  However, in these
   cases, it affects not only clients that wish to use TCP for their
   queries for operational reasons, but all clients that choose to fall
   back to TCP from UDP after receiving a TC=1 flag.






<span class="grey">Dickinson, et al.            Standards Track                    [Page 7]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-8" id="page-8" href="#page-8" class="invisible"> </a>
<span class="grey"><a href="rfc7766.html">RFC 7766</a>                      DNS over TCP                    March 2016</span>


<span class="h3"><a class="selflink" name="section-6.2" href="#section-6.2">6.2</a>.  Recommendations</span>

   The following sections include recommendations that are intended to
   result in more consistent and scalable implementations of DNS-over-
   TCP.

<span class="h4"><a class="selflink" name="section-6.2.1" href="#section-6.2.1">6.2.1</a>.  Connection Reuse</span>

   One perceived disadvantage to DNS over TCP is the added connection
   setup latency, generally equal to one RTT.  To amortise connection
   setup costs, both clients and servers SHOULD support connection reuse
   by sending multiple queries and responses over a single persistent
   TCP connection.

   When sending multiple queries over a TCP connection, clients MUST NOT
   reuse the DNS Message ID of an in-flight query on that connection in
   order to avoid Message ID collisions.  This is especially important
   if the server could be performing out-of-order processing (see
   <a href="#section-7">Section 7</a>).

<span class="h5"><a class="selflink" name="section-6.2.1.1" href="#section-6.2.1.1">6.2.1.1</a>.  Query Pipelining</span>

   Due to the historical use of TCP primarily for zone transfer and
   truncated responses, no existing RFC discusses the idea of pipelining
   DNS queries over a TCP connection.

   In order to achieve performance on par with UDP, DNS clients SHOULD
   pipeline their queries.  When a DNS client sends multiple queries to
   a server, it SHOULD NOT wait for an outstanding reply before sending
   the next query.  Clients SHOULD treat TCP and UDP equivalently when
   considering the time at which to send a particular query.

   It is likely that DNS servers need to process pipelined queries
   concurrently and also send out-of-order responses over TCP in order
   to provide the level of performance possible with UDP transport.  If
   TCP performance is of importance, clients might find it useful to use
   server processing times as input to server and transport selection
   algorithms.

   DNS servers (especially recursive) MUST expect to receive pipelined
   queries.  The server SHOULD process TCP queries concurrently, just as
   it would for UDP.  The server SHOULD answer all pipelined queries,
   even if they are received in quick succession.  The handling of
   responses to pipelined queries is covered in <a href="#section-7">Section 7</a>.







<span class="grey">Dickinson, et al.            Standards Track                    [Page 8]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-9" id="page-9" href="#page-9" class="invisible"> </a>
<span class="grey"><a href="rfc7766.html">RFC 7766</a>                      DNS over TCP                    March 2016</span>


<span class="h4"><a class="selflink" name="section-6.2.2" href="#section-6.2.2">6.2.2</a>.  Concurrent Connections</span>

   To mitigate the risk of unintentional server overload, DNS clients
   MUST take care to minimize the number of concurrent TCP connections
   made to any individual server.  It is RECOMMENDED that for any given
   client/server interaction there SHOULD be no more than one connection
   for regular queries, one for zone transfers, and one for each
   protocol that is being used on top of TCP (for example, if the
   resolver was using TLS).  However, it is noted that certain primary/
   secondary configurations with many busy zones might need to use more
   than one TCP connection for zone transfers for operational reasons
   (for example, to support concurrent transfers of multiple zones).

   Similarly, servers MAY impose limits on the number of concurrent TCP
   connections being handled for any particular client IP address or
   subnet.  These limits SHOULD be much looser than the client
   guidelines above, because the server does not know, for example, if a
   client IP address belongs to a single client, is multiple resolvers
   on a single machine, or is multiple clients behind a device
   performing Network Address Translation (NAT).

<span class="h4"><a class="selflink" name="section-6.2.3" href="#section-6.2.3">6.2.3</a>.  Idle Timeouts</span>

   To mitigate the risk of unintentional server overload, DNS clients
   MUST take care to minimise the idle time of established DNS-over-TCP
   sessions made to any individual server.  DNS clients SHOULD close the
   TCP connection of an idle session, unless an idle timeout has been
   established using some other signalling mechanism, for example,
   [<a href="#ref-edns-tcp-keepalive">edns-tcp-keepalive</a>].

   To mitigate the risk of unintentional server overload, it is
   RECOMMENDED that the default server application-level idle period be
   on the order of seconds, but no particular value is specified.  In
   practice, the idle period can vary dynamically, and servers MAY allow
   idle connections to remain open for longer periods as resources
   permit.  A timeout of at least a few seconds is advisable for normal
   operations to support those clients that expect the SOA and AXFR
   request sequence to be made on a single connection as originally
   specified in [<a href="rfc1035.html" title="&quot;Domain names - implementation and specification&quot;">RFC1035</a>].  Servers MAY use zero timeouts when they are
   experiencing heavy load or are under attack.

   DNS messages delivered over TCP might arrive in multiple segments.  A
   DNS server that resets its idle timeout after receiving a single
   segment might be vulnerable to a "slow-read attack".  For this
   reason, servers SHOULD reset the idle timeout on the receipt of a
   full DNS message, rather than on receipt of any part of a DNS
   message.




<span class="grey">Dickinson, et al.            Standards Track                    [Page 9]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-10" id="page-10" href="#page-10" class="invisible"> </a>
<span class="grey"><a href="rfc7766.html">RFC 7766</a>                      DNS over TCP                    March 2016</span>


<span class="h4"><a class="selflink" name="section-6.2.4" href="#section-6.2.4">6.2.4</a>.  Teardown</span>

   Under normal operation DNS clients typically initiate connection
   closing on idle connections; however, DNS servers can close the
   connection if the idle timeout set by local policy is exceeded.
   Also, connections can be closed by either end under unusual
   conditions such as defending against an attack or system failure/
   reboot.

   DNS clients SHOULD retry unanswered queries if the connection closes
   before receiving all outstanding responses.  No specific retry
   algorithm is specified in this document.

   If a DNS server finds that a DNS client has closed a TCP session (or
   if the session has been otherwise interrupted) before all pending
   responses have been sent, then the server MUST NOT attempt to send
   those responses.  Of course, the DNS server MAY cache those
   responses.

<span class="h2"><a class="selflink" name="section-7" href="#section-7">7</a>.  Response Reordering</span>

   <a href="rfc1035.html">RFC 1035</a> is ambiguous on the question of whether TCP responses may be
   reordered -- the only relevant text is in <a href="#section-4.2.1">Section 4.2.1</a>, which
   relates to UDP:

      Queries or their responses may be reordered by the network, or by
      processing in name servers, so resolvers should not depend on them
      being returned in order.

   For the avoidance of future doubt, this requirement is clarified.
   Authoritative servers and recursive resolvers are RECOMMENDED to
   support the preparing of responses in parallel and sending them out
   of order, regardless of the transport protocol in use.  Stub and
   recursive resolvers MUST be able to process responses that arrive in
   a different order than that in which the requests were sent,
   regardless of the transport protocol in use.

   In order to achieve performance on par with UDP, recursive resolvers
   SHOULD process TCP queries in parallel and return individual
   responses as soon as they are available, possibly out of order.

   Since pipelined responses can arrive out of order, clients MUST match
   responses to outstanding queries on the same TCP connection using the
   Message ID.  If the response contains a question section, the client
   MUST match the QNAME, QCLASS, and QTYPE fields.  Failure by clients
   to properly match responses to outstanding queries can have serious
   consequences for interoperability.




<span class="grey">Dickinson, et al.            Standards Track                   [Page 10]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-11" id="page-11" href="#page-11" class="invisible"> </a>
<span class="grey"><a href="rfc7766.html">RFC 7766</a>                      DNS over TCP                    March 2016</span>


<span class="h2"><a class="selflink" name="section-8" href="#section-8">8</a>.  TCP Message Length Field</span>

   DNS clients and servers SHOULD pass the two-octet length field, and
   the message described by that length field, to the TCP layer at the
   same time (e.g., in a single "write" system call) to make it more
   likely that all the data will be transmitted in a single TCP segment.
   This is for reasons of both efficiency and to avoid problems due to
   some DNS server implementations behaving undesirably when reading
   data from the TCP layer (due to a lack of clarity in previous
   documents).  For example, some DNS server implementations might abort
   a TCP session if the first "read" from the TCP layer does not contain
   both the length field and the entire message.

   To clarify, DNS servers MUST NOT close a connection simply because
   the first "read" from the TCP layer does not contain the entire DNS
   message, and servers SHOULD apply the connection timeouts as
   specified in <a href="#section-6.2.3">Section 6.2.3</a>.

<span class="h2"><a class="selflink" name="section-9" href="#section-9">9</a>.  TCP Fast Open</span>

   This section is non-normative.

   TCP Fast Open (TFO) [<a href="rfc7413.html" title="&quot;TCP Fast Open&quot;">RFC7413</a>] allows data to be carried in the SYN
   packet, reducing the cost of reopening TCP connections.  It also
   saves up to one RTT compared to standard TCP.

   TFO mitigates the security vulnerabilities inherent in sending data
   in the SYN, especially on a system like DNS where amplification
   attacks are possible, by use of a server-supplied cookie.  TFO
   clients request a server cookie in the initial SYN packet at the
   start of a new connection.  The server returns a cookie in its SYN-
   ACK.  The client caches the cookie and reuses it when opening
   subsequent connections to the same server.

   The cookie is stored by the client's TCP stack (kernel) and persists
   if either the client or server processes are restarted.  TFO also
   falls back to a regular TCP handshake gracefully.

   DNS services taking advantage of IP anycast [<a href="rfc4786.html" title="&quot;Operation of Anycast Services&quot;">RFC4786</a>] might need to
   take additional steps when enabling TFO.  From [<a href="rfc7413.html" title="&quot;TCP Fast Open&quot;">RFC7413</a>]:

      Servers behind load balancers that accept connection requests to
      the same server IP address should use the same key such that they
      generate identical Fast Open cookies for a particular client IP
      address.  Otherwise, a client may get different cookies across
      connections; its Fast Open attempts would fall back to the regular
      3WHS.




<span class="grey">Dickinson, et al.            Standards Track                   [Page 11]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-12" id="page-12" href="#page-12" class="invisible"> </a>
<span class="grey"><a href="rfc7766.html">RFC 7766</a>                      DNS over TCP                    March 2016</span>


   When DNS-over-TCP is a transport for DNS private exchange, as in
   [<a href="#ref-DNS-over-TLS">DNS-over-TLS</a>], the implementor needs to be aware of TFO and to
   ensure that data requiring protection (e.g. data for a DNS query) is
   not accidentally transported in the clear.  See [<a href="#ref-DNS-over-TLS">DNS-over-TLS</a>] for
   discussion.

<span class="h2"><a class="selflink" name="section-10" href="#section-10">10</a>.  Security Considerations</span>

   Some DNS server operators have expressed concern that wider promotion
   and use of DNS over TCP will expose them to a higher risk of DoS
   attacks on TCP (both accidental and deliberate).

   Although there is a higher risk of some specific attacks against TCP-
   enabled servers, techniques for the mitigation of DoS attacks at the
   network level have improved substantially since DNS was first
   designed.

   Readers are advised to familiarise themselves with [<a href="#ref-CPNI-TCP">CPNI-TCP</a>], a
   security assessment of TCP that details known TCP attacks and
   countermeasures and that references most of the relevant RFCs on this
   topic.

   To mitigate the risk of DoS attacks, DNS servers are advised to
   engage in TCP connection management.  This could include maintaining
   state on existing connections, reusing existing connections, and
   controlling request queues to enable fair use.  It is likely to be
   advantageous to provide configurable connection management options,
   for example:

   o  total number of TCP connections

   o  maximum TCP connections per source IP address or subnet

   o  TCP connection idle timeout

   o  maximum DNS transactions per TCP connection

   o  maximum TCP connection duration

   No specific values are recommended for these parameters.

   Operators are advised to familiarise themselves with the
   configuration and tuning parameters available in the TCP stack of the
   operating system.  However, detailed advice on this is outside the
   scope of this document.






<span class="grey">Dickinson, et al.            Standards Track                   [Page 12]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-13" id="page-13" href="#page-13" class="invisible"> </a>
<span class="grey"><a href="rfc7766.html">RFC 7766</a>                      DNS over TCP                    March 2016</span>


   Operators of recursive servers are advised to ensure that they only
   accept connections from expected clients (for example, by the use of
   an Access Control List (ACL)) and do not accept them from unknown
   sources.  In the case of UDP traffic, this will help protect against
   reflection attacks [<a href="rfc5358.html" title="&quot;Preventing Use of Recursive Nameservers in Reflector Attacks&quot;">RFC5358</a>]; and in the case of TCP traffic, it will
   prevent an unknown client from exhausting the server's limits on the
   number of concurrent connections.

<span class="h2"><a class="selflink" name="section-11" href="#section-11">11</a>.  References</span>

<span class="h3"><a class="selflink" name="section-11.1" href="#section-11.1">11.1</a>.  Normative References</span>

   [<a name="ref-RFC768" id="ref-RFC768">RFC768</a>]   Postel, J., "User Datagram Protocol", STD 6, <a href="rfc768.html">RFC 768</a>,
              DOI 10.17487/RFC0768, August 1980,
              &lt;<a href="http://www.rfc-editor.org/info/rfc768">http://www.rfc-editor.org/info/rfc768</a>&gt;.

   [<a name="ref-RFC793" id="ref-RFC793">RFC793</a>]   Postel, J., "Transmission Control Protocol", STD 7,
              <a href="rfc793.html">RFC 793</a>, DOI 10.17487/RFC0793, September 1981,
              &lt;<a href="http://www.rfc-editor.org/info/rfc793">http://www.rfc-editor.org/info/rfc793</a>&gt;.

   [<a name="ref-RFC1034" id="ref-RFC1034">RFC1034</a>]  Mockapetris, P., "Domain names - concepts and facilities",
              STD 13, <a href="rfc1034.html">RFC 1034</a>, DOI 10.17487/RFC1034, November 1987,
              &lt;<a href="http://www.rfc-editor.org/info/rfc1034">http://www.rfc-editor.org/info/rfc1034</a>&gt;.

   [<a name="ref-RFC1035" id="ref-RFC1035">RFC1035</a>]  Mockapetris, P., "Domain names - implementation and
              specification", STD 13, <a href="rfc1035.html">RFC 1035</a>, DOI 10.17487/RFC1035,
              November 1987, &lt;<a href="http://www.rfc-editor.org/info/rfc1035">http://www.rfc-editor.org/info/rfc1035</a>&gt;.

   [<a name="ref-RFC1123" id="ref-RFC1123">RFC1123</a>]  Braden, R., Ed., "Requirements for Internet Hosts -
              Application and Support", STD 3, <a href="rfc1123.html">RFC 1123</a>,
              DOI 10.17487/RFC1123, October 1989,
              &lt;<a href="http://www.rfc-editor.org/info/rfc1123">http://www.rfc-editor.org/info/rfc1123</a>&gt;.

   [<a name="ref-RFC2119" id="ref-RFC2119">RFC2119</a>]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", <a href="https://tools.ietf.org/html/bcp14">BCP 14</a>, <a href="rfc2119.html">RFC 2119</a>,
              DOI 10.17487/RFC2119, March 1997,
              &lt;<a href="http://www.rfc-editor.org/info/rfc2119">http://www.rfc-editor.org/info/rfc2119</a>&gt;.

   [<a name="ref-RFC4033" id="ref-RFC4033">RFC4033</a>]  Arends, R., Austein, R., Larson, M., Massey, D., and S.
              Rose, "DNS Security Introduction and Requirements",
              <a href="rfc4033.html">RFC 4033</a>, DOI 10.17487/RFC4033, March 2005,
              &lt;<a href="http://www.rfc-editor.org/info/rfc4033">http://www.rfc-editor.org/info/rfc4033</a>&gt;.

   [<a name="ref-RFC4786" id="ref-RFC4786">RFC4786</a>]  Abley, J. and K. Lindqvist, "Operation of Anycast
              Services", <a href="https://tools.ietf.org/html/bcp126">BCP 126</a>, <a href="rfc4786.html">RFC 4786</a>, DOI 10.17487/RFC4786,
              December 2006, &lt;<a href="http://www.rfc-editor.org/info/rfc4786">http://www.rfc-editor.org/info/rfc4786</a>&gt;.





<span class="grey">Dickinson, et al.            Standards Track                   [Page 13]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-14" id="page-14" href="#page-14" class="invisible"> </a>
<span class="grey"><a href="rfc7766.html">RFC 7766</a>                      DNS over TCP                    March 2016</span>


   [<a name="ref-RFC5155" id="ref-RFC5155">RFC5155</a>]  Laurie, B., Sisson, G., Arends, R., and D. Blacka, "DNS
              Security (DNSSEC) Hashed Authenticated Denial of
              Existence", <a href="rfc5155.html">RFC 5155</a>, DOI 10.17487/RFC5155, March 2008,
              &lt;<a href="http://www.rfc-editor.org/info/rfc5155">http://www.rfc-editor.org/info/rfc5155</a>&gt;.

   [<a name="ref-RFC5358" id="ref-RFC5358">RFC5358</a>]  Damas, J. and F. Neves, "Preventing Use of Recursive
              Nameservers in Reflector Attacks", <a href="https://tools.ietf.org/html/bcp140">BCP 140</a>, <a href="rfc5358.html">RFC 5358</a>,
              DOI 10.17487/RFC5358, October 2008,
              &lt;<a href="http://www.rfc-editor.org/info/rfc5358">http://www.rfc-editor.org/info/rfc5358</a>&gt;.

   [<a name="ref-RFC5625" id="ref-RFC5625">RFC5625</a>]  Bellis, R., "DNS Proxy Implementation Guidelines",
              <a href="https://tools.ietf.org/html/bcp152">BCP 152</a>, <a href="rfc5625.html">RFC 5625</a>, DOI 10.17487/RFC5625, August 2009,
              &lt;<a href="http://www.rfc-editor.org/info/rfc5625">http://www.rfc-editor.org/info/rfc5625</a>&gt;.

   [<a name="ref-RFC5966" id="ref-RFC5966">RFC5966</a>]  Bellis, R., "DNS Transport over TCP - Implementation
              Requirements", <a href="rfc5966.html">RFC 5966</a>, DOI 10.17487/RFC5966, August
              2010, &lt;<a href="http://www.rfc-editor.org/info/rfc5966">http://www.rfc-editor.org/info/rfc5966</a>&gt;.

   [<a name="ref-RFC6891" id="ref-RFC6891">RFC6891</a>]  Damas, J., Graff, M., and P. Vixie, "Extension Mechanisms
              for DNS (EDNS(0))", STD 75, <a href="rfc6891.html">RFC 6891</a>,
              DOI 10.17487/RFC6891, April 2013,
              &lt;<a href="http://www.rfc-editor.org/info/rfc6891">http://www.rfc-editor.org/info/rfc6891</a>&gt;.

   [<a name="ref-RFC7230" id="ref-RFC7230">RFC7230</a>]  Fielding, R., Ed. and J. Reschke, Ed., "Hypertext Transfer
              Protocol (HTTP/1.1): Message Syntax and Routing",
              <a href="rfc7230.html">RFC 7230</a>, DOI 10.17487/RFC7230, June 2014,
              &lt;<a href="http://www.rfc-editor.org/info/rfc7230">http://www.rfc-editor.org/info/rfc7230</a>&gt;.

   [<a name="ref-RFC7540" id="ref-RFC7540">RFC7540</a>]  Belshe, M., Peon, R., and M. Thomson, Ed., "Hypertext
              Transfer Protocol Version 2 (HTTP/2)", <a href="rfc7540.html">RFC 7540</a>,
              DOI 10.17487/RFC7540, May 2015,
              &lt;<a href="http://www.rfc-editor.org/info/rfc7540">http://www.rfc-editor.org/info/rfc7540</a>&gt;.

<span class="h3"><a class="selflink" name="section-11.2" href="#section-11.2">11.2</a>.  Informative References</span>

   [<a name="ref-Connection-Oriented-DNS" id="ref-Connection-Oriented-DNS">Connection-Oriented-DNS</a>]
              Zhu, L., Hu, Z., Heidemann, J., Wessels, D., Mankin, A.,
              and N. Somaiya, "Connection-Oriented DNS to Improve
              Privacy and Security", 2015 IEEE Symposium on Security and
              Privacy (SP), DOI 10.1109/SP.2015.18,
              &lt;<a href="http://ieeexplore.ieee.org/xpl/articleDetails.jsp?arnumber=7163025">http://ieeexplore.ieee.org/xpl/</a>
              <a href="http://ieeexplore.ieee.org/xpl/articleDetails.jsp?arnumber=7163025">articleDetails.jsp?arnumber=7163025</a>&gt;.

   [<a name="ref-CPNI-TCP" id="ref-CPNI-TCP">CPNI-TCP</a>]
              CPNI, "Security Assessment of the Transmission Control
              Protocol (TCP)", 2009, &lt;<a href="http://www.gont.com.ar/papers/tn-03-09-security-assessment-TCP.pdf">http://www.gont.com.ar/papers/</a>
              <a href="http://www.gont.com.ar/papers/tn-03-09-security-assessment-TCP.pdf">tn-03-09-security-assessment-TCP.pdf</a>&gt;.




<span class="grey">Dickinson, et al.            Standards Track                   [Page 14]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-15" id="page-15" href="#page-15" class="invisible"> </a>
<span class="grey"><a href="rfc7766.html">RFC 7766</a>                      DNS over TCP                    March 2016</span>


   [<a name="ref-DNS-over-TLS" id="ref-DNS-over-TLS">DNS-over-TLS</a>]
              Hu, Z., Zhu, L., Heidemann, J., Mankin, A., Wessels, D.,
              and P. Hoffman, "Specification for DNS over TLS", Work in
              Progress, <a href="https://tools.ietf.org/html/draft-ietf-dprive-dns-over-tls-06">draft-ietf-dprive-dns-over-tls-06</a>, February
              2016.

   [<a name="ref-edns-tcp-keepalive" id="ref-edns-tcp-keepalive">edns-tcp-keepalive</a>]
              Wouters, P., Abley, J., Dickinson, S., and R. Bellis, "The
              edns-tcp-keepalive EDNS0 Option", Work in Progress,
              <a href="https://tools.ietf.org/html/draft-ietf-dnsop-edns-tcp-keepalive-03">draft-ietf-dnsop-edns-tcp-keepalive-03</a>, September 2015.

   [<a name="ref-fragmentation-considered-poisonous" id="ref-fragmentation-considered-poisonous">fragmentation-considered-poisonous</a>]
              Herzberg, A. and H. Shulman, "Fragmentation Considered
              Poisonous", May 2012, &lt;<a href="http://arxiv.org/abs/1205.4011">http://arxiv.org/abs/1205.4011</a>&gt;.

   [<a name="ref-RFC5405" id="ref-RFC5405">RFC5405</a>]  Eggert, L. and G. Fairhurst, "Unicast UDP Usage Guidelines
              for Application Designers", <a href="https://tools.ietf.org/html/bcp145">BCP 145</a>, <a href="rfc5405.html">RFC 5405</a>,
              DOI 10.17487/RFC5405, November 2008,
              &lt;<a href="http://www.rfc-editor.org/info/rfc5405">http://www.rfc-editor.org/info/rfc5405</a>&gt;.

   [<a name="ref-RFC6824" id="ref-RFC6824">RFC6824</a>]  Ford, A., Raiciu, C., Handley, M., and O. Bonaventure,
              "TCP Extensions for Multipath Operation with Multiple
              Addresses", <a href="rfc6824.html">RFC 6824</a>, DOI 10.17487/RFC6824, January 2013,
              &lt;<a href="http://www.rfc-editor.org/info/rfc6824">http://www.rfc-editor.org/info/rfc6824</a>&gt;.

   [<a name="ref-RFC7413" id="ref-RFC7413">RFC7413</a>]  Cheng, Y., Chu, J., Radhakrishnan, S., and A. Jain, "TCP
              Fast Open", <a href="rfc7413.html">RFC 7413</a>, DOI 10.17487/RFC7413, December 2014,
              &lt;<a href="http://www.rfc-editor.org/info/rfc7413">http://www.rfc-editor.org/info/rfc7413</a>&gt;.

   [<a name="ref-RRL1" id="ref-RRL1">RRL1</a>]     Vixie, P. and V. Schryver, "DNS Response Rate Limiting
              (DNS RRL)", ISC-TN 2012-1-Draft1, April 2012,
              &lt;<a href="https://ftp.isc.org/isc/pubs/tn/isc-tn-2012-1.txt">https://ftp.isc.org/isc/pubs/tn/isc-tn-2012-1.txt</a>&gt;.

   [<a name="ref-RRL2" id="ref-RRL2">RRL2</a>]     ISC Support, "Using the Response Rate Limiting Feature in
              BIND 9.10", ISC Knowledge Base AA-00994, June 2013,
              &lt;<a href="https://kb.isc.org/article/AA-00994/">https://kb.isc.org/article/AA-00994/</a>&gt;.















<span class="grey">Dickinson, et al.            Standards Track                   [Page 15]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-16" id="page-16" href="#page-16" class="invisible"> </a>
<span class="grey"><a href="rfc7766.html">RFC 7766</a>                      DNS over TCP                    March 2016</span>


<span class="h2"><a class="selflink" name="appendix-A" href="#appendix-A">Appendix A</a>.  Summary of Advantages and Disadvantages to Using TCP for</span>
             DNS

   The TCP handshake generally prevents address spoofing and, therefore,
   the reflection/amplification attacks that plague UDP.

   IP fragmentation is less of a problem for TCP than it is for UDP.
   TCP stacks generally implement Path MTU Discovery so they can avoid
   IP fragmentation of TCP segments.  UDP, on the other hand, does not
   provide reassembly; this means datagrams that exceed the path MTU
   size must experience fragmentation [<a href="rfc5405.html" title="&quot;Unicast UDP Usage Guidelines for Application Designers&quot;">RFC5405</a>].  Middleboxes are known
   to block IP fragments, leading to timeouts and forcing client
   implementations to "hunt" for EDNS0 reply size values supported by
   the network path.  Additionally, fragmentation may lead to cache
   poisoning [<a href="#ref-fragmentation-considered-poisonous">fragmentation-considered-poisonous</a>].

   TCP setup costs an additional RTT compared to UDP queries.  Setup
   costs can be amortised by reusing connections, pipelining queries,
   and enabling TCP Fast Open.

   TCP imposes additional state-keeping requirements on clients and
   servers.  The use of TCP Fast Open reduces the cost of closing and
   reopening TCP connections.

   Long-lived TCP connections to anycast servers might be disrupted due
   to routing changes.  Clients utilizing TCP for DNS need to always be
   prepared to re-establish connections or otherwise retry outstanding
   queries.  It might also be possible for Multipath TCP [<a href="rfc6824.html" title="&quot;TCP Extensions for Multipath Operation with Multiple Addresses&quot;">RFC6824</a>] to
   allow a server to hand a connection over from the anycast address to
   a unicast address.

   There are many "middleboxes" in use today that interfere with TCP
   over port 53 [<a href="rfc5625.html" title="&quot;DNS Proxy Implementation Guidelines&quot;">RFC5625</a>].  This document does not propose any
   solutions, other than to make it absolutely clear that TCP is a valid
   transport for DNS and support for it is a requirement for all
   implementations.

   A more in-depth discussion of connection-oriented DNS can be found
   elsewhere [<a href="#ref-Connection-Oriented-DNS">Connection-Oriented-DNS</a>].

<span class="h2"><a class="selflink" name="appendix-B" href="#appendix-B">Appendix B</a>.  Changes to <a href="rfc5966.html">RFC 5966</a></span>

   This document obsoletes [<a href="rfc5966.html" title="&quot;DNS Transport over TCP - Implementation Requirements&quot;">RFC5966</a>] and differs from it in several
   respects.  An overview of the most substantial changes/updates that
   implementors should take note of is given below.

   1.   A Terminology section (<a href="#section-3">Section 3</a>) is added defining several new
        concepts.



<span class="grey">Dickinson, et al.            Standards Track                   [Page 16]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-17" id="page-17" href="#page-17" class="invisible"> </a>
<span class="grey"><a href="rfc7766.html">RFC 7766</a>                      DNS over TCP                    March 2016</span>


   2.   Paragraph 3 of <a href="#section-5">Section 5</a> puts TCP on a more equal footing with
        UDP than <a href="rfc5966.html">RFC 5966</a> does.  For example, it states:

        1.  TCP MAY be used before sending any UDP queries.

        2.  TCP ought to be considered a valid alternative transport to
            UDP, not purely a fallback option.

   3.   <a href="#section-6.2.1">Section 6.2.1</a> adds a new recommendation that TCP connection
        reuse SHOULD be supported.

   4.   <a href="#section-6.2.1.1">Section 6.2.1.1</a> adds a new recommendation that DNS clients
        SHOULD pipeline their queries and DNS servers SHOULD process
        pipelined queries concurrently.

   5.   <a href="#section-6.2.2">Section 6.2.2</a> adds new recommendations on the number and usage
        of TCP connections for client/server interactions.

   6.   <a href="#section-6.2.3">Section 6.2.3</a> adds a new recommendation that DNS clients SHOULD
        close idle sessions unless using a signalling mechanism.

   7.   <a href="#section-7">Section 7</a> clarifies that servers are RECOMMENDED to prepare TCP
        responses in parallel and send answers out of order.  It also
        clarifies how TCP queries and responses should be matched by
        clients.

   8.   <a href="#section-8">Section 8</a> adds a new recommendation about how DNS clients and
        servers should handle the 2-byte message length field for TCP
        messages.

   9.   <a href="#section-9">Section 9</a> adds a non-normative discussion of the use of TCP Fast
        Open.

   10.  <a href="#section-10">Section 10</a> adds new advice regarding DoS mitigation techniques.

Acknowledgements

   The authors would like to thank Francis Dupont and Paul Vixie for
   their detailed reviews, as well as Andrew Sullivan, Tony Finch,
   Stephane Bortzmeyer, Joe Abley, Tatuya Jinmei, and the many others
   who contributed to the mailing list discussion.  Also, the authors
   thank Liang Zhu, Zi Hu, and John Heidemann for extensive DNS-over-TCP
   discussions and code, and Lucie Guiraud and Danny McPherson for
   reviewing early draft versions of this document.  We would also like
   to thank all those who contributed to <a href="rfc5966.html">RFC 5966</a>.






<span class="grey">Dickinson, et al.            Standards Track                   [Page 17]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-18" id="page-18" href="#page-18" class="invisible"> </a>
<span class="grey"><a href="rfc7766.html">RFC 7766</a>                      DNS over TCP                    March 2016</span>


Authors' Addresses

   John Dickinson
   Sinodun Internet Technologies
   Magdalen Centre
   Oxford Science Park
   Oxford  OX4 4GA
   United Kingdom

   Email: jad@sinodun.com
   URI:   <a href="http://sinodun.com/">http://sinodun.com</a>


   Sara Dickinson
   Sinodun Internet Technologies
   Magdalen Centre
   Oxford Science Park
   Oxford  OX4 4GA
   United Kingdom

   Email: sara@sinodun.com
   URI:   <a href="http://sinodun.com/">http://sinodun.com</a>


   Ray Bellis
   Internet Systems Consortium, Inc
   950 Charter Street
   Redwood City, CA  94063
   United States

   Phone: +1 650 423 1200
   Email: ray@isc.org
   URI:   <a href="http://www.isc.org/">http://www.isc.org</a>


   Allison Mankin
   Verisign Labs
   12061 Bluemont Way
   Reston, VA  20190
   United States

   Phone: +1 301 728 7198
   Email: allison.mankin@gmail.com








<span class="grey">Dickinson, et al.            Standards Track                   [Page 18]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-19" id="page-19" href="#page-19" class="invisible"> </a>
<span class="grey"><a href="rfc7766.html">RFC 7766</a>                      DNS over TCP                    March 2016</span>


   Duane Wessels
   Verisign Labs
   12061 Bluemont Way
   Reston, VA  20190
   United States

   Phone: +1 703 948 3200
   Email: dwessels@verisign.com











































Dickinson, et al.            Standards Track                   [Page 19]

</pre><br />
    <span class="noprint"><small><small>Html markup produced by rfcmarkup 1.126, available from
      <a href="https://tools.ietf.org/tools/rfcmarkup/">https://tools.ietf.org/tools/rfcmarkup/</a>
    </small></small></span>
  </div>
</body>

<!-- Mirrored from tools.ietf.org/html/rfc7766 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 06 Mar 2018 23:18:20 GMT -->
</html>
