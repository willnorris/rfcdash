<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml"><!-- Mirrored from tools.ietf.org/html/rfc4251 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 06 Mar 2018 23:18:42 GMT --><!-- Added by HTTrack --><head><meta content="text/html;charset=utf-8" http-equiv="content-type"/><!-- /Added by HTTrack -->

    <meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
    <meta content="index,follow" name="robots"/>
    <meta content="rfcmarkup version 1.126" name="creator"/>
    <link href="http://purl.org/dc/elements/1.1/" rel="schema.DC"/>
<meta content="urn:ietf:rfc:4251" name="DC.Identifier"/>
<meta content="The Secure Shell (SSH) Protocol is a protocol for secure remote login
and other secure network services over an insecure network. This
document describes the architecture of the SSH protocol, as well as
the notation and terminology used in SSH protocol documents. It also
discusses the SSH algorithm naming system that allows local
extensions. The SSH protocol consists of three major components: The
Transport Layer Protocol provides server authentication,
confidentiality, and integrity with perfect forward secrecy. The User
Authentication Protocol authenticates the client to the server. The
Connection Protocol multiplexes the encrypted tunnel into several
logical channels. Details of these protocols are described in separate
documents. [STANDARDS-TRACK]" name="DC.Description.Abstract"/>
<meta content="Ylonen, Tatu" name="DC.Creator"/>
<meta content="Lonvick, Chris" name="DC.Creator"/>
<meta content="January, 2006" name="DC.Date.Issued"/>
<meta content="The Secure Shell (SSH) Protocol Architecture" name="DC.Title"/>

    <link href="https://tools.ietf.org/images/rfc.png" rel="icon" type="image/png"/>
    <link href="https://tools.ietf.org/images/rfc.png" rel="shortcut icon" type="image/png"/>
    <title>RFC 4251 - The Secure Shell (SSH) Protocol Architecture</title>
    
    
    <style type="text/css">
	@media only screen 
	  and (min-width: 992px)
	  and (max-width: 1199px) {
	    body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 768px)
	  and (max-width: 991px) {
            body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 480px)
	  and (max-width: 767px) {
            body { font-size: 11pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (max-width: 479px) {
            body { font-size: 8pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-device-width : 375px) 
	  and (max-device-width : 667px) {
            body { font-size: 9.5pt; }
            div.content { width: 96ex; margin: 0 1px; }
        }
	@media only screen 
	  and (min-device-width: 1200px) {
            body { font-size: 10pt; margin: 0 4em; }
            div.content { width: 96ex; margin: 0; }
        }
        h1, h2, h3, h4, h5, h6, .h1, .h2, .h3, .h4, .h5, .h6 {
	    font-weight: bold;
            line-height: 0pt;
            display: inline;
            white-space: pre;
            font-family: monospace;
            font-size: 1em;
	    font-weight: bold;
        }
        pre {
            font-size: 1em;
            margin-top: 0px;
            margin-bottom: 0px;
        }
	.pre {
	    white-space: pre;
	    font-family: monospace;
	}
	.header{
	    font-weight: bold;
	}
        .newpage {
            page-break-before: always;
        }
        .invisible {
            text-decoration: none;
            color: white;
        }
        a.selflink {
          color: black;
          text-decoration: none;
        }
        @media print {
            body {
                font-family: monospace;
                font-size: 10.5pt;
            }
            h1, h2, h3, h4, h5, h6 {
                font-size: 1em;
            }
        
            a:link, a:visited {
                color: inherit;
                text-decoration: none;
            }
            .noprint {
                display: none;
            }
        }
	@media screen {
	    .grey, .grey a:link, .grey a:visited {
		color: #777;
	    }
            .docinfo {
                background-color: #EEE;
            }
            .top {
                border-top: 7px solid #EEE;
            }
            .bgwhite  { background-color: white; }
            .bgred    { background-color: #F44; }
            .bggrey   { background-color: #666; }
            .bgbrown  { background-color: #840; }            
            .bgorange { background-color: #FA0; }
            .bgyellow { background-color: #EE0; }
            .bgmagenta{ background-color: #F4F; }
            .bgblue   { background-color: #66F; }
            .bgcyan   { background-color: #4DD; }
            .bggreen  { background-color: #4F4; }

            .legend   { font-size: 90%; }
            .cplate   { font-size: 70%; border: solid grey 1px; }
	}
    </style>
    <!--[if IE]>
    <style>
    body {
       font-size: 13px;
       margin: 10px 10px;
    }
    </style>
    <![endif]-->

    <script type="text/javascript"><!--
    function addHeaderTags() {
	var spans = document.getElementsByTagName("span");
	for (var i=0; i < spans.length; i++) {
	    var elem = spans[i];
	    if (elem) {
		var level = elem.getAttribute("class");
                if (level == "h1" || level == "h2" || level == "h3" || level == "h4" || level == "h5" || level == "h6") {
                    elem.innerHTML = "<"+level+">"+elem.innerHTML+"</"+level+">";		
                }
	    }
	}
    }
    var legend_html = "Colour legend:<br />      <table>         <tr><td>Unknown:</td>                   <td><span class='cplate bgwhite'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft:</td>                     <td><span class='cplate bgred'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Informational:</td>             <td><span class='cplate bgorange'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Experimental:</td>              <td><span class='cplate bgyellow'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Best Common Practice:</td>      <td><span class='cplate bgmagenta'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Proposed Standard:</td>         <td><span class='cplate bgblue'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft Standard (old designation):</td> <td><span class='cplate bgcyan'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Internet Standard:</td>         <td><span class='cplate bggreen'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Historic:</td>                  <td><span class='cplate bggrey'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Obsolete:</td>                  <td><span class='cplate bgbrown'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>     </table>";
    function showElem(id) {
        var elem = document.getElementById(id);
        elem.innerHTML = eval(id+"_html");
        elem.style.visibility='visible';
    }
    function hideElem(id) {
        var elem = document.getElementById(id);
        elem.style.visibility='hidden';        
        elem.innerHTML = "";
    }
    // -->
    </script>
</head>
<body onload="addHeaderTags()">
  <div class="content">
   <div style="height: 13px;">
      <div class="pre noprint docinfo bgblue" onclick="showElem('legend');" onmouseout="hideElem('legend')" onmouseover="this.style.cursor='pointer';" style="height: 6px; position: absolute;" title="Click for colour legend.">                                                                        </div>
      <div class="docinfo noprint pre legend" id="legend" onmouseout="hideElem('legend');" onmouseover="showElem('legend');" style="position:absolute; top: 4px; left: 4ex; visibility:hidden; background-color: white; padding: 4px 9px 5px 7px; border: solid #345 1px; ">
      </div>
   </div>
<span class="pre noprint docinfo top">[<a href="index.html" title="Document search and retrieval page">Docs</a>] [<a href="https://tools.ietf.org/rfc/rfc4251.txt" title="Plaintext version of this document">txt</a>|<a href="https://tools.ietf.org/pdf/rfc4251" title="PDF version of this document">pdf</a>] [<a href="https://tools.ietf.org/html/draft-ietf-secsh-architecture" title="draft-ietf-secsh-architecture">draft-ietf-secs...</a>] [<a href="https://datatracker.ietf.org/doc/rfc4251" title="IESG Datatracker information for this document">Tracker</a>] [<a href="https://tools.ietf.org/rfcdiff?difftype=--hwdiff&amp;url2=rfc4251" title="Inline diff (wdiff)">Diff1</a>] [<a href="https://tools.ietf.org/rfcdiff?url2=rfc4251" title="Side-by-side diff">Diff2</a>]         </span><br/>
<span class="pre noprint docinfo">                                                                        </span><br/>
<span class="pre noprint docinfo">                                                       PROPOSED STANDARD</span><br/>
<span class="pre noprint docinfo">                                                                        </span><br/>
<pre>Network Working Group                                          T. Ylonen
Request for Comments: 4251              SSH Communications Security Corp
Category: Standards Track                                C. Lonvick, Ed.
                                                     Cisco Systems, Inc.
                                                            January 2006


              <span class="h1">The Secure Shell (SSH) Protocol Architecture</span>

Status of This Memo

   This document specifies an Internet standards track protocol for the
   Internet community, and requests discussion and suggestions for
   improvements.  Please refer to the current edition of the "Internet
   Official Protocol Standards" (STD 1) for the standardization state
   and status of this protocol.  Distribution of this memo is unlimited.

Copyright Notice

   Copyright (C) The Internet Society (2006).

Abstract

   The Secure Shell (SSH) Protocol is a protocol for secure remote login
   and other secure network services over an insecure network.  This
   document describes the architecture of the SSH protocol, as well as
   the notation and terminology used in SSH protocol documents.  It also
   discusses the SSH algorithm naming system that allows local
   extensions.  The SSH protocol consists of three major components: The
   Transport Layer Protocol provides server authentication,
   confidentiality, and integrity with perfect forward secrecy.  The
   User Authentication Protocol authenticates the client to the server.
   The Connection Protocol multiplexes the encrypted tunnel into several
   logical channels.  Details of these protocols are described in
   separate documents.
















<span class="grey">Ylonen &amp; Lonvick            Standards Track                     [Page 1]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-2" id="page-2" name="page-2"> </a>
<span class="grey"><a href="rfc4251.html">RFC 4251</a>               SSH Protocol Architecture            January 2006</span>


Table of Contents

   <a href="#section-1">1</a>. Introduction ....................................................<a href="#page-3">3</a>
   <a href="#section-2">2</a>. Contributors ....................................................<a href="#page-3">3</a>
   <a href="#section-3">3</a>. Conventions Used in This Document ...............................<a href="#page-4">4</a>
   <a href="#section-4">4</a>. Architecture ....................................................<a href="#page-4">4</a>
      <a href="#section-4.1">4.1</a>. Host Keys ..................................................<a href="#page-4">4</a>
      <a href="#section-4.2">4.2</a>. Extensibility ..............................................<a href="#page-6">6</a>
      <a href="#section-4.3">4.3</a>. Policy Issues ..............................................<a href="#page-6">6</a>
      <a href="#section-4.4">4.4</a>. Security Properties ........................................<a href="#page-7">7</a>
      <a href="#section-4.5">4.5</a>. Localization and Character Set Support .....................<a href="#page-7">7</a>
   <a href="#section-5">5</a>. Data Type Representations Used in the SSH Protocols .............<a href="#page-8">8</a>
   <a href="#section-6">6</a>. Algorithm and Method Naming ....................................<a href="#page-10">10</a>
   <a href="#section-7">7</a>. Message Numbers ................................................<a href="#page-11">11</a>
   <a href="#section-8">8</a>. IANA Considerations ............................................<a href="#page-12">12</a>
   <a href="#section-9">9</a>. Security Considerations ........................................<a href="#page-13">13</a>
      <a href="#section-9.1">9.1</a>. Pseudo-Random Number Generation ...........................<a href="#page-13">13</a>
      <a href="#section-9.2">9.2</a>. Control Character Filtering ...............................<a href="#page-14">14</a>
      <a href="#section-9.3">9.3</a>. Transport .................................................<a href="#page-14">14</a>
           <a href="#section-9.3.1">9.3.1</a>. Confidentiality ....................................<a href="#page-14">14</a>
           <a href="#section-9.3.2">9.3.2</a>. Data Integrity .....................................<a href="#page-16">16</a>
           <a href="#section-9.3.3">9.3.3</a>. Replay .............................................<a href="#page-16">16</a>
           <a href="#section-9.3.4">9.3.4</a>. Man-in-the-middle ..................................<a href="#page-17">17</a>
           <a href="#section-9.3.5">9.3.5</a>. Denial of Service ..................................<a href="#page-19">19</a>
           <a href="#section-9.3.6">9.3.6</a>. Covert Channels ....................................<a href="#page-20">20</a>
           <a href="#section-9.3.7">9.3.7</a>. Forward Secrecy ....................................<a href="#page-20">20</a>
           <a href="#section-9.3.8">9.3.8</a>. Ordering of Key Exchange Methods ...................<a href="#page-20">20</a>
           <a href="#section-9.3.9">9.3.9</a>. Traffic Analysis ...................................<a href="#page-21">21</a>
      <a href="#section-9.4">9.4</a>. Authentication Protocol ...................................<a href="#page-21">21</a>
           <a href="#section-9.4.1">9.4.1</a>. Weak Transport .....................................<a href="#page-21">21</a>
           <a href="#section-9.4.2">9.4.2</a>. Debug Messages .....................................<a href="#page-22">22</a>
           <a href="#section-9.4.3">9.4.3</a>. Local Security Policy ..............................<a href="#page-22">22</a>
           <a href="#section-9.4.4">9.4.4</a>. Public Key Authentication ..........................<a href="#page-23">23</a>
           <a href="#section-9.4.5">9.4.5</a>. Password Authentication ............................<a href="#page-23">23</a>
           <a href="#section-9.4.6">9.4.6</a>. Host-Based Authentication ..........................<a href="#page-23">23</a>
      <a href="#section-9.5">9.5</a>. Connection Protocol .......................................<a href="#page-24">24</a>
           <a href="#section-9.5.1">9.5.1</a>. End Point Security .................................<a href="#page-24">24</a>
           <a href="#section-9.5.2">9.5.2</a>. Proxy Forwarding ...................................<a href="#page-24">24</a>
           <a href="#section-9.5.3">9.5.3</a>. X11 Forwarding .....................................<a href="#page-24">24</a>
   <a href="#section-10">10</a>. References ....................................................<a href="#page-26">26</a>
      <a href="#section-10.1">10.1</a>. Normative References .....................................<a href="#page-26">26</a>
      <a href="#section-10.2">10.2</a>. Informative References ...................................<a href="#page-26">26</a>
   Authors' Addresses ................................................<a href="#page-29">29</a>
   Trademark Notice ..................................................<a href="#page-29">29</a>







<span class="grey">Ylonen &amp; Lonvick            Standards Track                     [Page 2]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-3" id="page-3" name="page-3"> </a>
<span class="grey"><a href="rfc4251.html">RFC 4251</a>               SSH Protocol Architecture            January 2006</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/1.%20%20Introduction"></a><a class="selflink" href="#section-1" name="section-1">1</a>.  Introduction</span>

   Secure Shell (SSH) is a protocol for secure remote login and other
   secure network services over an insecure network.  It consists of
   three major components:

   o  The Transport Layer Protocol [<a href="#ref-SSH-TRANS" title='"The Secure Shell (SSH) Transport Layer Protocol"'>SSH-TRANS</a>] provides server
      authentication, confidentiality, and integrity.  It may optionally
      also provide compression.  The transport layer will typically be
      run over a TCP/IP connection, but might also be used on top of any
      other reliable data stream.

   o  The User Authentication Protocol [<a href="#ref-SSH-USERAUTH" title='"The Secure Shell (SSH) Authentication Protocol"'>SSH-USERAUTH</a>] authenticates the
      client-side user to the server.  It runs over the transport layer
      protocol.

   o  The Connection Protocol [<a href="#ref-SSH-CONNECT" title='"The Secure Shell (SSH) Connection Protocol"'>SSH-CONNECT</a>] multiplexes the encrypted
      tunnel into several logical channels.  It runs over the user
      authentication protocol.

   The client sends a service request once a secure transport layer
   connection has been established.  A second service request is sent
   after user authentication is complete.  This allows new protocols to
   be defined and coexist with the protocols listed above.

   The connection protocol provides channels that can be used for a wide
   range of purposes.  Standard methods are provided for setting up
   secure interactive shell sessions and for forwarding ("tunneling")
   arbitrary TCP/IP ports and X11 connections.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/2.%20%20Contributors"></a><a class="selflink" href="#section-2" name="section-2">2</a>.  Contributors</span>

   The major original contributors of this set of documents have been:
   Tatu Ylonen, Tero Kivinen, Timo J. Rinne, Sami Lehtinen (all of SSH
   Communications Security Corp), and Markku-Juhani O. Saarinen
   (University of Jyvaskyla).  Darren Moffat was the original editor of
   this set of documents and also made very substantial contributions.

   Many people contributed to the development of this document over the
   years.  People who should be acknowledged include Mats Andersson, Ben
   Harris, Bill Sommerfeld, Brent McClure, Niels Moller, Damien Miller,
   Derek Fawcus, Frank Cusack, Heikki Nousiainen, Jakob Schlyter, Jeff
   Van Dyke, Jeffrey Altman, Jeffrey Hutzelman, Jon Bright, Joseph
   Galbraith, Ken Hornstein, Markus Friedl, Martin Forssen, Nicolas
   Williams, Niels Provos, Perry Metzger, Peter Gutmann, Simon
   Josefsson, Simon Tatham, Wei Dai, Denis Bider, der Mouse, and
   Tadayoshi Kohno.  Listing their names here does not mean that they
   endorse this document, but that they have contributed to it.



<span class="grey">Ylonen &amp; Lonvick            Standards Track                     [Page 3]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-4" id="page-4" name="page-4"> </a>
<span class="grey"><a href="rfc4251.html">RFC 4251</a>               SSH Protocol Architecture            January 2006</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/3.%20%20Conventions%20Used%20in%20This%20Document"></a><a class="selflink" href="#section-3" name="section-3">3</a>.  Conventions Used in This Document</span>

   All documents related to the SSH protocols shall use the keywords
   "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD",
   "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" to describe
   requirements.  These keywords are to be interpreted as described in
   [<a href="rfc2119.html" title='"Key words for use in RFCs to Indicate Requirement Levels"'>RFC2119</a>].

   The keywords "PRIVATE USE", "HIERARCHICAL ALLOCATION", "FIRST COME
   FIRST SERVED", "EXPERT REVIEW", "SPECIFICATION REQUIRED", "IESG
   APPROVAL", "IETF CONSENSUS", and "STANDARDS ACTION" that appear in
   this document when used to describe namespace allocation are to be
   interpreted as described in [<a href="rfc2434.html" title='"Guidelines for Writing an IANA Considerations Section in RFCs"'>RFC2434</a>].

   Protocol fields and possible values to fill them are defined in this
   set of documents.  Protocol fields will be defined in the message
   definitions.  As an example, SSH_MSG_CHANNEL_DATA is defined as
   follows.

      byte      SSH_MSG_CHANNEL_DATA
      uint32    recipient channel
      string    data

   Throughout these documents, when the fields are referenced, they will
   appear within single quotes.  When values to fill those fields are
   referenced, they will appear within double quotes.  Using the above
   example, possible values for 'data' are "foo" and "bar".

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/4.%20%20Architecture"></a><a class="selflink" href="#section-4" name="section-4">4</a>.  Architecture</span>

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.1.%20%20Host%20Keys"></a><a class="selflink" href="#section-4.1" name="section-4.1">4.1</a>.  Host Keys</span>

   Each server host SHOULD have a host key.  Hosts MAY have multiple
   host keys using multiple different algorithms.  Multiple hosts MAY
   share the same host key.  If a host has keys at all, it MUST have at
   least one key that uses each REQUIRED public key algorithm (DSS
   [<a href="#ref-FIPS-186-2" title='"Digital Signature Standard (DSS)"'>FIPS-186-2</a>]).

   The server host key is used during key exchange to verify that the
   client is really talking to the correct server.  For this to be
   possible, the client must have a priori knowledge of the server's
   public host key.

   Two different trust models can be used:

   o  The client has a local database that associates each host name (as
      typed by the user) with the corresponding public host key.  This
      method requires no centrally administered infrastructure, and no



<span class="grey">Ylonen &amp; Lonvick            Standards Track                     [Page 4]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-5" id="page-5" name="page-5"> </a>
<span class="grey"><a href="rfc4251.html">RFC 4251</a>               SSH Protocol Architecture            January 2006</span>


      third-party coordination.  The downside is that the database of
      name-to-key associations may become burdensome to maintain.

   o  The host name-to-key association is certified by a trusted
      certification authority (CA).  The client only knows the CA root
      key, and can verify the validity of all host keys certified by
      accepted CAs.

   The second alternative eases the maintenance problem, since ideally
   only a single CA key needs to be securely stored on the client.  On
   the other hand, each host key must be appropriately certified by a
   central authority before authorization is possible.  Also, a lot of
   trust is placed on the central infrastructure.

   The protocol provides the option that the server name - host key
   association is not checked when connecting to the host for the first
   time.  This allows communication without prior communication of host
   keys or certification.  The connection still provides protection
   against passive listening; however, it becomes vulnerable to active
   man-in-the-middle attacks.  Implementations SHOULD NOT normally allow
   such connections by default, as they pose a potential security
   problem.  However, as there is no widely deployed key infrastructure
   available on the Internet at the time of this writing, this option
   makes the protocol much more usable during the transition time until
   such an infrastructure emerges, while still providing a much higher
   level of security than that offered by older solutions (e.g., telnet
   [<a href="https://tools.ietf.org/html/rfc0854" title='"Telnet Protocol Specification"'>RFC0854</a>] and rlogin [<a href="rfc1282.html" title='"BSD Rlogin"'>RFC1282</a>]).

   Implementations SHOULD try to make the best effort to check host
   keys.  An example of a possible strategy is to only accept a host key
   without checking the first time a host is connected, save the key in
   a local database, and compare against that key on all future
   connections to that host.

   Implementations MAY provide additional methods for verifying the
   correctness of host keys, e.g., a hexadecimal fingerprint derived
   from the SHA-1 hash [<a href="#ref-FIPS-180-2" title='"Secure Hash Standard (SHS)"'>FIPS-180-2</a>] of the public key.  Such
   fingerprints can easily be verified by using telephone or other
   external communication channels.

   All implementations SHOULD provide an option not to accept host keys
   that cannot be verified.

   The members of this Working Group believe that 'ease of use' is
   critical to end-user acceptance of security solutions, and no
   improvement in security is gained if the new solutions are not used.
   Thus, providing the option not to check the server host key is




<span class="grey">Ylonen &amp; Lonvick            Standards Track                     [Page 5]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-6" id="page-6" name="page-6"> </a>
<span class="grey"><a href="rfc4251.html">RFC 4251</a>               SSH Protocol Architecture            January 2006</span>


   believed to improve the overall security of the Internet, even though
   it reduces the security of the protocol in configurations where it is
   allowed.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.2.%20%20Extensibility"></a><a class="selflink" href="#section-4.2" name="section-4.2">4.2</a>.  Extensibility</span>

   We believe that the protocol will evolve over time, and some
   organizations will want to use their own encryption, authentication,
   and/or key exchange methods.  Central registration of all extensions
   is cumbersome, especially for experimental or classified features.
   On the other hand, having no central registration leads to conflicts
   in method identifiers, making interoperability difficult.

   We have chosen to identify algorithms, methods, formats, and
   extension protocols with textual names that are of a specific format.
   DNS names are used to create local namespaces where experimental or
   classified extensions can be defined without fear of conflicts with
   other implementations.

   One design goal has been to keep the base protocol as simple as
   possible, and to require as few algorithms as possible.  However, all
   implementations MUST support a minimal set of algorithms to ensure
   interoperability (this does not imply that the local policy on all
   hosts would necessarily allow these algorithms).  The mandatory
   algorithms are specified in the relevant protocol documents.

   Additional algorithms, methods, formats, and extension protocols can
   be defined in separate documents.  See <a href="#section-6">Section 6</a>, Algorithm Naming,
   for more information.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.3.%20%20Policy%20Issues"></a><a class="selflink" href="#section-4.3" name="section-4.3">4.3</a>.  Policy Issues</span>

   The protocol allows full negotiation of encryption, integrity, key
   exchange, compression, and public key algorithms and formats.
   Encryption, integrity, public key, and compression algorithms can be
   different for each direction.

   The following policy issues SHOULD be addressed in the configuration
   mechanisms of each implementation:

   o  Encryption, integrity, and compression algorithms, separately for
      each direction.  The policy MUST specify which is the preferred
      algorithm (e.g., the first algorithm listed in each category).

   o  Public key algorithms and key exchange method to be used for host
      authentication.  The existence of trusted host keys for different
      public key algorithms also affects this choice.




<span class="grey">Ylonen &amp; Lonvick            Standards Track                     [Page 6]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-7" id="page-7" name="page-7"> </a>
<span class="grey"><a href="rfc4251.html">RFC 4251</a>               SSH Protocol Architecture            January 2006</span>


   o  The authentication methods that are to be required by the server
      for each user.  The server's policy MAY require multiple
      authentication for some or all users.  The required algorithms MAY
      depend on the location from where the user is trying to gain
      access.

   o  The operations that the user is allowed to perform using the
      connection protocol.  Some issues are related to security; for
      example, the policy SHOULD NOT allow the server to start sessions
      or run commands on the client machine, and MUST NOT allow
      connections to the authentication agent unless forwarding such
      connections has been requested.  Other issues, such as which
      TCP/IP ports can be forwarded and by whom, are clearly issues of
      local policy.  Many of these issues may involve traversing or
      bypassing firewalls, and are interrelated with the local security
      policy.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.4.%20%20Security%20Properties"></a><a class="selflink" href="#section-4.4" name="section-4.4">4.4</a>.  Security Properties</span>

   The primary goal of the SSH protocol is to improve security on the
   Internet.  It attempts to do this in a way that is easy to deploy,
   even at the cost of absolute security.

   o  All encryption, integrity, and public key algorithms used are
      well-known, well-established algorithms.

   o  All algorithms are used with cryptographically sound key sizes
      that are believed to provide protection against even the strongest
      cryptanalytic attacks for decades.

   o  All algorithms are negotiated, and in case some algorithm is
      broken, it is easy to switch to some other algorithm without
      modifying the base protocol.

   Specific concessions were made to make widespread, fast deployment
   easier.  The particular case where this comes up is verifying that
   the server host key really belongs to the desired host; the protocol
   allows the verification to be left out, but this is NOT RECOMMENDED.
   This is believed to significantly improve usability in the short
   term, until widespread Internet public key infrastructures emerge.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.5.%20%20Localization%20and%20Character%20Set%20Support"></a><a class="selflink" href="#section-4.5" name="section-4.5">4.5</a>.  Localization and Character Set Support</span>

   For the most part, the SSH protocols do not directly pass text that
   would be displayed to the user.  However, there are some places where
   such data might be passed.  When applicable, the character set for





<span class="grey">Ylonen &amp; Lonvick            Standards Track                     [Page 7]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-8" id="page-8" name="page-8"> </a>
<span class="grey"><a href="rfc4251.html">RFC 4251</a>               SSH Protocol Architecture            January 2006</span>


   the data MUST be explicitly specified.  In most places, ISO-10646
   UTF-8 encoding is used [<a href="rfc3629.html" title='"UTF-8, a transformation format of ISO 10646"'>RFC3629</a>].  When applicable, a field is also
   provided for a language tag [<a href="rfc3066.html" title='"Tags for the Identification of Languages"'>RFC3066</a>].

   One big issue is the character set of the interactive session.  There
   is no clear solution, as different applications may display data in
   different formats.  Different types of terminal emulation may also be
   employed in the client, and the character set to be used is
   effectively determined by the terminal emulation.  Thus, no place is
   provided for directly specifying the character set or encoding for
   terminal session data.  However, the terminal emulation type (e.g.,
   "vt100") is transmitted to the remote site, and it implicitly
   specifies the character set and encoding.  Applications typically use
   the terminal type to determine what character set they use, or the
   character set is determined using some external means.  The terminal
   emulation may also allow configuring the default character set.  In
   any case, the character set for the terminal session is considered
   primarily a client local issue.

   Internal names used to identify algorithms or protocols are normally
   never displayed to users, and must be in US-ASCII.

   The client and server user names are inherently constrained by what
   the server is prepared to accept.  They might, however, occasionally
   be displayed in logs, reports, etc.  They MUST be encoded using ISO
   10646 UTF-8, but other encodings may be required in some cases.  It
   is up to the server to decide how to map user names to accepted user
   names.  Straight bit-wise, binary comparison is RECOMMENDED.

   For localization purposes, the protocol attempts to minimize the
   number of textual messages transmitted.  When present, such messages
   typically relate to errors, debugging information, or some externally
   configured data.  For data that is normally displayed, it SHOULD be
   possible to fetch a localized message instead of the transmitted
   message by using a numerical code.  The remaining messages SHOULD be
   configurable.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/5.%20%20Data%20Type%20Representations%20Used%20in%20the%20SSH%20Protocols"></a><a class="selflink" href="#section-5" name="section-5">5</a>.  Data Type Representations Used in the SSH Protocols</span>

   byte

      A byte represents an arbitrary 8-bit value (octet).  Fixed length
      data is sometimes represented as an array of bytes, written
      byte[n], where n is the number of bytes in the array.







<span class="grey">Ylonen &amp; Lonvick            Standards Track                     [Page 8]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-9" id="page-9" name="page-9"> </a>
<span class="grey"><a href="rfc4251.html">RFC 4251</a>               SSH Protocol Architecture            January 2006</span>


   boolean

      A boolean value is stored as a single byte.  The value 0
      represents FALSE, and the value 1 represents TRUE.  All non-zero
      values MUST be interpreted as TRUE; however, applications MUST NOT
      store values other than 0 and 1.

   uint32

      Represents a 32-bit unsigned integer.  Stored as four bytes in the
      order of decreasing significance (network byte order).  For
      example: the value 699921578 (0x29b7f4aa) is stored as 29 b7 f4
      aa.

   uint64

      Represents a 64-bit unsigned integer.  Stored as eight bytes in
      the order of decreasing significance (network byte order).

   string

      Arbitrary length binary string.  Strings are allowed to contain
      arbitrary binary data, including null characters and 8-bit
      characters.  They are stored as a uint32 containing its length
      (number of bytes that follow) and zero (= empty string) or more
      bytes that are the value of the string.  Terminating null
      characters are not used.

      Strings are also used to store text.  In that case, US-ASCII is
      used for internal names, and ISO-10646 UTF-8 for text that might
      be displayed to the user.  The terminating null character SHOULD
      NOT normally be stored in the string.  For example: the US-ASCII
      string "testing" is represented as 00 00 00 07 t e s t i n g.  The
      UTF-8 mapping does not alter the encoding of US-ASCII characters.

   mpint

      Represents multiple precision integers in two's complement format,
      stored as a string, 8 bits per byte, MSB first.  Negative numbers
      have the value 1 as the most significant bit of the first byte of
      the data partition.  If the most significant bit would be set for
      a positive number, the number MUST be preceded by a zero byte.
      Unnecessary leading bytes with the value 0 or 255 MUST NOT be
      included.  The value zero MUST be stored as a string with zero
      bytes of data.

      By convention, a number that is used in modular computations in
      Z_n SHOULD be represented in the range 0 &lt;= x &lt; n.



<span class="grey">Ylonen &amp; Lonvick            Standards Track                     [Page 9]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-10" id="page-10" name="page-10"> </a>
<span class="grey"><a href="rfc4251.html">RFC 4251</a>               SSH Protocol Architecture            January 2006</span>


         Examples:

         value (hex)        representation (hex)
         -----------        --------------------
         0                  00 00 00 00
         9a378f9b2e332a7    00 00 00 08 09 a3 78 f9 b2 e3 32 a7
         80                 00 00 00 02 00 80
         -1234              00 00 00 02 ed cc
         -deadbeef          00 00 00 05 ff 21 52 41 11

   name-list

      A string containing a comma-separated list of names.  A name-list
      is represented as a uint32 containing its length (number of bytes
      that follow) followed by a comma-separated list of zero or more
      names.  A name MUST have a non-zero length, and it MUST NOT
      contain a comma (",").  As this is a list of names, all of the
      elements contained are names and MUST be in US-ASCII.  Context may
      impose additional restrictions on the names.  For example, the
      names in a name-list may have to be a list of valid algorithm
      identifiers (see <a href="#section-6">Section 6</a> below), or a list of [<a href="rfc3066.html" title='"Tags for the Identification of Languages"'>RFC3066</a>] language
      tags.  The order of the names in a name-list may or may not be
      significant.  Again, this depends on the context in which the list
      is used.  Terminating null characters MUST NOT be used, neither
      for the individual names, nor for the list as a whole.

       Examples:

       value                      representation (hex)
       -----                      --------------------
       (), the empty name-list    00 00 00 00
       ("zlib")                   00 00 00 04 7a 6c 69 62
       ("zlib,none")              00 00 00 09 7a 6c 69 62 2c 6e 6f 6e 65

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/6.%20%20Algorithm%20and%20Method%20Naming"></a><a class="selflink" href="#section-6" name="section-6">6</a>.  Algorithm and Method Naming</span>

   The SSH protocols refer to particular hash, encryption, integrity,
   compression, and key exchange algorithms or methods by name.  There
   are some standard algorithms and methods that all implementations
   MUST support.  There are also algorithms and methods that are defined
   in the protocol specification, but are OPTIONAL.  Furthermore, it is
   expected that some organizations will want to use their own
   algorithms or methods.

   In this protocol, all algorithm and method identifiers MUST be
   printable US-ASCII, non-empty strings no longer than 64 characters.
   Names MUST be case-sensitive.




<span class="grey">Ylonen &amp; Lonvick            Standards Track                    [Page 10]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-11" id="page-11" name="page-11"> </a>
<span class="grey"><a href="rfc4251.html">RFC 4251</a>               SSH Protocol Architecture            January 2006</span>


   There are two formats for algorithm and method names:

   o  Names that do not contain an at-sign ("@") are reserved to be
      assigned by IETF CONSENSUS.  Examples include "3des-cbc", "sha-1",
      "hmac-sha1", and "zlib" (the doublequotes are not part of the
      name).  Names of this format are only valid if they are first
      registered with the IANA.  Registered names MUST NOT contain an
      at-sign ("@"), comma (","), whitespace, control characters (ASCII
      codes 32 or less), or the ASCII code 127 (DEL).  Names are case-
      sensitive, and MUST NOT be longer than 64 characters.

   o  Anyone can define additional algorithms or methods by using names
      in the format name@domainname, e.g., "ourcipher-cbc@example.com".
      The format of the part preceding the at-sign is not specified;
      however, these names MUST be printable US-ASCII strings, and MUST
      NOT contain the comma character (","), whitespace, control
      characters (ASCII codes 32 or less), or the ASCII code 127 (DEL).
      They MUST have only a single at-sign in them.  The part following
      the at-sign MUST be a valid, fully qualified domain name [<a href="rfc1034.html" title='"Domain names - concepts and facilities"'>RFC1034</a>]
      controlled by the person or organization defining the name.  Names
      are case-sensitive, and MUST NOT be longer than 64 characters.  It
      is up to each domain how it manages its local namespace.  It
      should be noted that these names resemble STD 11 [<a href="https://tools.ietf.org/html/rfc0822" title='"Standard for the format of ARPA Internet text messages"'>RFC0822</a>] email
      addresses.  This is purely coincidental and has nothing to do with
      STD 11 [<a href="https://tools.ietf.org/html/rfc0822" title='"Standard for the format of ARPA Internet text messages"'>RFC0822</a>].

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/7.%20%20Message%20Numbers"></a><a class="selflink" href="#section-7" name="section-7">7</a>.  Message Numbers</span>

   SSH packets have message numbers in the range 1 to 255.  These
   numbers have been allocated as follows:

   Transport layer protocol:

      1 to 19    Transport layer generic (e.g., disconnect, ignore,
                 debug, etc.)
      20 to 29   Algorithm negotiation
      30 to 49   Key exchange method specific (numbers can be reused
                 for different authentication methods)

   User authentication protocol:

      50 to 59   User authentication generic
      60 to 79   User authentication method specific (numbers can be
                 reused for different authentication methods)







<span class="grey">Ylonen &amp; Lonvick            Standards Track                    [Page 11]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-12" id="page-12" name="page-12"> </a>
<span class="grey"><a href="rfc4251.html">RFC 4251</a>               SSH Protocol Architecture            January 2006</span>


   Connection protocol:

      80 to 89   Connection protocol generic
      90 to 127  Channel related messages

   Reserved for client protocols:

      128 to 191 Reserved

   Local extensions:

      192 to 255 Local extensions

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/8.%20%20IANA%20Considerations"></a><a class="selflink" href="#section-8" name="section-8">8</a>.  IANA Considerations</span>

   This document is part of a set.  The instructions for the IANA for
   the SSH protocol, as defined in this document, [<a href="#ref-SSH-USERAUTH" title='"The Secure Shell (SSH) Authentication Protocol"'>SSH-USERAUTH</a>],
   [<a href="#ref-SSH-TRANS" title='"The Secure Shell (SSH) Transport Layer Protocol"'>SSH-TRANS</a>], and [<a href="#ref-SSH-CONNECT" title='"The Secure Shell (SSH) Connection Protocol"'>SSH-CONNECT</a>], are detailed in [<a href="#ref-SSH-NUMBERS" title='"The Secure Shell (SSH) Protocol Assigned Numbers"'>SSH-NUMBERS</a>].  The
   following is a brief summary for convenience, but note well that
   [<a href="#ref-SSH-NUMBERS" title='"The Secure Shell (SSH) Protocol Assigned Numbers"'>SSH-NUMBERS</a>] contains the actual instructions to the IANA, which may
   be superseded in the future.

   Allocation of the following types of names in the SSH protocols is
   assigned by IETF consensus:

   o  Service Names
      *  Authentication Methods
      *  Connection Protocol Channel Names
      *  Connection Protocol Global Request Names
      *  Connection Protocol Channel Request Names

   o  Key Exchange Method Names

   o  Assigned Algorithm Names
      *  Encryption Algorithm Names
      *  MAC Algorithm Names
      *  Public Key Algorithm Names
      *  Compression Algorithm Names

   These names MUST be printable US-ASCII strings, and MUST NOT contain
   the characters at-sign ("@"), comma (","), whitespace, control
   characters (ASCII codes 32 or less), or the ASCII code 127 (DEL).
   Names are case-sensitive, and MUST NOT be longer than 64 characters.

   Names with the at-sign ("@") are locally defined extensions and are
   not controlled by the IANA.





<span class="grey">Ylonen &amp; Lonvick            Standards Track                    [Page 12]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-13" id="page-13" name="page-13"> </a>
<span class="grey"><a href="rfc4251.html">RFC 4251</a>               SSH Protocol Architecture            January 2006</span>


   Each category of names listed above has a separate namespace.
   However, using the same name in multiple categories SHOULD be avoided
   to minimize confusion.

   Message numbers (see <a href="#section-7">Section 7</a>) in the range of 0 to 191 are
   allocated via IETF CONSENSUS, as described in [<a href="rfc2434.html" title='"Guidelines for Writing an IANA Considerations Section in RFCs"'>RFC2434</a>].  Message
   numbers in the 192 to 255 range (local extensions) are reserved for
   PRIVATE USE, also as described in [<a href="rfc2434.html" title='"Guidelines for Writing an IANA Considerations Section in RFCs"'>RFC2434</a>].

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/9.%20%20Security%20Considerations"></a><a class="selflink" href="#section-9" name="section-9">9</a>.  Security Considerations</span>

   In order to make the entire body of Security Considerations more
   accessible, Security Considerations for the transport,
   authentication, and connection documents have been gathered here.

   The transport protocol [<a href="#ref-SSH-TRANS" title='"The Secure Shell (SSH) Transport Layer Protocol"'>SSH-TRANS</a>] provides a confidential channel
   over an insecure network.  It performs server host authentication,
   key exchange, encryption, and integrity protection.  It also derives
   a unique session id that may be used by higher-level protocols.

   The authentication protocol [<a href="#ref-SSH-USERAUTH" title='"The Secure Shell (SSH) Authentication Protocol"'>SSH-USERAUTH</a>] provides a suite of
   mechanisms that can be used to authenticate the client user to the
   server.  Individual mechanisms specified in the authentication
   protocol use the session id provided by the transport protocol and/or
   depend on the security and integrity guarantees of the transport
   protocol.

   The connection protocol [<a href="#ref-SSH-CONNECT" title='"The Secure Shell (SSH) Connection Protocol"'>SSH-CONNECT</a>] specifies a mechanism to
   multiplex multiple streams (channels) of data over the confidential
   and authenticated transport.  It also specifies channels for
   accessing an interactive shell, for proxy-forwarding various external
   protocols over the secure transport (including arbitrary TCP/IP
   protocols), and for accessing secure subsystems on the server host.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/9.1.%20%20Pseudo-Random%20Number%20Generation"></a><a class="selflink" href="#section-9.1" name="section-9.1">9.1</a>.  Pseudo-Random Number Generation</span>

   This protocol binds each session key to the session by including
   random, session specific data in the hash used to produce session
   keys.  Special care should be taken to ensure that all of the random
   numbers are of good quality.  If the random data here (e.g., Diffie-
   Hellman (DH) parameters) are pseudo-random, then the pseudo-random
   number generator should be cryptographically secure (i.e., its next
   output not easily guessed even when knowing all previous outputs)
   and, furthermore, proper entropy needs to be added to the pseudo-
   random number generator.  [<a href="rfc4086.html" title='"Randomness Requirements for Security"'>RFC4086</a>] offers suggestions for sources of
   random numbers and entropy.  Implementers should note the importance
   of entropy and the well-meant, anecdotal warning about the difficulty
   in properly implementing pseudo-random number generating functions.



<span class="grey">Ylonen &amp; Lonvick            Standards Track                    [Page 13]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-14" id="page-14" name="page-14"> </a>
<span class="grey"><a href="rfc4251.html">RFC 4251</a>               SSH Protocol Architecture            January 2006</span>


   The amount of entropy available to a given client or server may
   sometimes be less than what is required.  In this case, one must
   either resort to pseudo-random number generation regardless of
   insufficient entropy or refuse to run the protocol.  The latter is
   preferable.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/9.2.%20%20Control%20Character%20Filtering"></a><a class="selflink" href="#section-9.2" name="section-9.2">9.2</a>.  Control Character Filtering</span>

   When displaying text to a user, such as error or debug messages, the
   client software SHOULD replace any control characters (except tab,
   carriage return, and newline) with safe sequences to avoid attacks by
   sending terminal control characters.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/9.3.%20%20Transport"></a><a class="selflink" href="#section-9.3" name="section-9.3">9.3</a>.  Transport</span>

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/9.3.1.%20%20Confidentiality"></a><a class="selflink" href="#section-9.3.1" name="section-9.3.1">9.3.1</a>.  Confidentiality</span>

   It is beyond the scope of this document and the Secure Shell Working
   Group to analyze or recommend specific ciphers other than the ones
   that have been established and accepted within the industry.  At the
   time of this writing, commonly used ciphers include 3DES, ARCFOUR,
   twofish, serpent, and blowfish.  AES has been published by The US
   Federal Information Processing Standards as [<a href="#ref-FIPS-197" title='"Advanced Encryption Standard (AES)"'>FIPS-197</a>], and the
   cryptographic community has accepted AES as well.  As always,
   implementers and users should check current literature to ensure that
   no recent vulnerabilities have been found in ciphers used within
   products.  Implementers should also check to see which ciphers are
   considered to be relatively stronger than others and should recommend
   their use to users over relatively weaker ciphers.  It would be
   considered good form for an implementation to politely and
   unobtrusively notify a user that a stronger cipher is available and
   should be used when a weaker one is actively chosen.

   The "none" cipher is provided for debugging and SHOULD NOT be used
   except for that purpose.  Its cryptographic properties are
   sufficiently described in [<a href="rfc2410.html" title='"The NULL Encryption Algorithm and Its Use With IPsec"'>RFC2410</a>], which will show that its use
   does not meet the intent of this protocol.

   The relative merits of these and other ciphers may also be found in
   current literature.  Two references that may provide information on
   the subject are [<a href="#ref-SCHNEIER" title='"Applied Cryptography Second Edition: protocols algorithms and source in code in C"'>SCHNEIER</a>] and [<a href="#ref-KAUFMAN" title='"Network Security: PRIVATE Communication in a PUBLIC World"'>KAUFMAN</a>].  Both of these describe the
   CBC mode of operation of certain ciphers and the weakness of this
   scheme.  Essentially, this mode is theoretically vulnerable to chosen
   cipher-text attacks because of the high predictability of the start
   of packet sequence.  However, this attack is deemed difficult and not
   considered fully practicable, especially if relatively long block
   sizes are used.




<span class="grey">Ylonen &amp; Lonvick            Standards Track                    [Page 14]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-15" id="page-15" name="page-15"> </a>
<span class="grey"><a href="rfc4251.html">RFC 4251</a>               SSH Protocol Architecture            January 2006</span>


   Additionally, another CBC mode attack may be mitigated through the
   insertion of packets containing SSH_MSG_IGNORE.  Without this
   technique, a specific attack may be successful.  For this attack
   (commonly known as the Rogaway attack [<a href="#ref-ROGAWAY" title='"Problems with Proposed IP Cryptography"'>ROGAWAY</a>], [<a href="#ref-DAI" title='"An attack against SSH2 protocol"'>DAI</a>], [<a href="#ref-BELLARE" title='"Authenticated Encryption in SSH: Fixing the SSH Binary Packet Protocol"'>BELLARE</a>]) to
   work, the attacker would need to know the Initialization Vector (IV)
   of the next block that is going to be encrypted.  In CBC mode that is
   the output of the encryption of the previous block.  If the attacker
   does not have any way to see the packet yet (i.e., it is in the
   internal buffers of the SSH implementation or even in the kernel),
   then this attack will not work.  If the last packet has been sent out
   to the network (i.e., the attacker has access to it), then he can use
   the attack.

   In the optimal case, an implementer would need to add an extra packet
   only if the packet has been sent out onto the network and there are
   no other packets waiting for transmission.  Implementers may wish to
   check if there are any unsent packets awaiting transmission;
   unfortunately, it is not normally easy to obtain this information
   from the kernel or buffers.  If there are no unsent packets, then a
   packet containing SSH_MSG_IGNORE SHOULD be sent.  If a new packet is
   added to the stream every time the attacker knows the IV that is
   supposed to be used for the next packet, then the attacker will not
   be able to guess the correct IV, thus the attack will never be
   successful.

   As an example, consider the following case:

      Client                                                  Server
      ------                                                  ------
      TCP(seq=x, len=500)             ----&gt;
       contains Record 1

                          [500 ms passes, no ACK]

      TCP(seq=x, len=1000)            ----&gt;
       contains Records 1,2

                                                                ACK

   1. The Nagle algorithm + TCP retransmits mean that the two records
      get coalesced into a single TCP segment.

   2. Record 2 is not at the beginning of the TCP segment and never will
      be because it gets ACKed.

   3. Yet, the attack is possible because Record 1 has already been
      seen.




<span class="grey">Ylonen &amp; Lonvick            Standards Track                    [Page 15]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-16" id="page-16" name="page-16"> </a>
<span class="grey"><a href="rfc4251.html">RFC 4251</a>               SSH Protocol Architecture            January 2006</span>


   As this example indicates, it is unsafe to use the existence of
   unflushed data in the TCP buffers proper as a guide to whether an
   empty packet is needed, since when the second write() is performed
   the buffers will contain the un-ACKed Record 1.

   On the other hand, it is perfectly safe to have the following
   situation:

      Client                                                  Server
      ------                                                  ------
      TCP(seq=x, len=500)             ----&gt;
         contains SSH_MSG_IGNORE

      TCP(seq=y, len=500)             ----&gt;
         contains Data

      Provided that the IV for the second SSH Record is fixed after the
      data for the Data packet is determined, then the following should
      be performed:

         read from user
         encrypt null packet
         encrypt data packet

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/9.3.2.%20%20Data%20Integrity"></a><a class="selflink" href="#section-9.3.2" name="section-9.3.2">9.3.2</a>.  Data Integrity</span>

   This protocol does allow the Data Integrity mechanism to be disabled.
   Implementers SHOULD be wary of exposing this feature for any purpose
   other than debugging.  Users and administrators SHOULD be explicitly
   warned anytime the "none" MAC is enabled.

   So long as the "none" MAC is not used, this protocol provides data
   integrity.

   Because MACs use a 32-bit sequence number, they might start to leak
   information after 2**32 packets have been sent.  However, following
   the rekeying recommendations should prevent this attack.  The
   transport protocol [<a href="#ref-SSH-TRANS" title='"The Secure Shell (SSH) Transport Layer Protocol"'>SSH-TRANS</a>] recommends rekeying after one gigabyte
   of data, and the smallest possible packet is 16 bytes.  Therefore,
   rekeying SHOULD happen after 2**28 packets at the very most.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/9.3.3.%20%20Replay"></a><a class="selflink" href="#section-9.3.3" name="section-9.3.3">9.3.3</a>.  Replay</span>

   The use of a MAC other than "none" provides integrity and
   authentication.  In addition, the transport protocol provides a
   unique session identifier (bound in part to pseudo-random data that
   is part of the algorithm and key exchange process) that can be used
   by higher level protocols to bind data to a given session and prevent



<span class="grey">Ylonen &amp; Lonvick            Standards Track                    [Page 16]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-17" id="page-17" name="page-17"> </a>
<span class="grey"><a href="rfc4251.html">RFC 4251</a>               SSH Protocol Architecture            January 2006</span>


   replay of data from prior sessions.  For example, the authentication
   protocol ([<a href="#ref-SSH-USERAUTH" title='"The Secure Shell (SSH) Authentication Protocol"'>SSH-USERAUTH</a>]) uses this to prevent replay of signatures
   from previous sessions.  Because public key authentication exchanges
   are cryptographically bound to the session (i.e., to the initial key
   exchange), they cannot be successfully replayed in other sessions.
   Note that the session id can be made public without harming the
   security of the protocol.

   If two sessions have the same session id (hash of key exchanges),
   then packets from one can be replayed against the other.  It must be
   stressed that the chances of such an occurrence are, needless to say,
   minimal when using modern cryptographic methods.  This is all the
   more true when specifying larger hash function outputs and DH
   parameters.

   Replay detection using monotonically increasing sequence numbers as
   input to the MAC, or HMAC in some cases, is described in [<a href="rfc2085.html" title='"HMAC-MD5 IP Authentication with Replay Prevention"'>RFC2085</a>],
   [<a href="rfc2246.html" title='"The TLS Protocol Version 1.0"'>RFC2246</a>], [<a href="rfc2743.html" title='"Generic Security Service Application Program Interface Version 2, Update 1"'>RFC2743</a>], [<a href="rfc1964.html" title='"The Kerberos Version 5 GSS-API Mechanism"'>RFC1964</a>], [<a href="rfc2025.html" title='"The Simple Public-Key GSS-API Mechanism (SPKM)"'>RFC2025</a>], and [<a href="rfc4120.html" title='"The Kerberos Network Authentication Service (V5)"'>RFC4120</a>].  The
   underlying construct is discussed in [<a href="rfc2104.html" title='"HMAC: Keyed-Hashing for Message Authentication"'>RFC2104</a>].  Essentially, a
   different sequence number in each packet ensures that at least this
   one input to the MAC function will be unique and will provide a
   nonrecurring MAC output that is not predictable to an attacker.  If
   the session stays active long enough, however, this sequence number
   will wrap.  This event may provide an attacker an opportunity to
   replay a previously recorded packet with an identical sequence number
   but only if the peers have not rekeyed since the transmission of the
   first packet with that sequence number.  If the peers have rekeyed,
   then the replay will be detected since the MAC check will fail.  For
   this reason, it must be emphasized that peers MUST rekey before a
   wrap of the sequence numbers.  Naturally, if an attacker does attempt
   to replay a captured packet before the peers have rekeyed, then the
   receiver of the duplicate packet will not be able to validate the MAC
   and it will be discarded.  The reason that the MAC will fail is
   because the receiver will formulate a MAC based upon the packet
   contents, the shared secret, and the expected sequence number.  Since
   the replayed packet will not be using that expected sequence number
   (the sequence number of the replayed packet will have already been
   passed by the receiver), the calculated MAC will not match the MAC
   received with the packet.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/9.3.4.%20%20Man-in-the-middle"></a><a class="selflink" href="#section-9.3.4" name="section-9.3.4">9.3.4</a>.  Man-in-the-middle</span>

   This protocol makes no assumptions or provisions for an
   infrastructure or means for distributing the public keys of hosts.
   It is expected that this protocol will sometimes be used without
   first verifying the association between the server host key and the
   server host name.  Such usage is vulnerable to man-in-the-middle
   attacks.  This section describes this and encourages administrators



<span class="grey">Ylonen &amp; Lonvick            Standards Track                    [Page 17]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-18" id="page-18" name="page-18"> </a>
<span class="grey"><a href="rfc4251.html">RFC 4251</a>               SSH Protocol Architecture            January 2006</span>


   and users to understand the importance of verifying this association
   before any session is initiated.

   There are three cases of man-in-the-middle attacks to consider.  The
   first is where an attacker places a device between the client and the
   server before the session is initiated.  In this case, the attack
   device is trying to mimic the legitimate server and will offer its
   public key to the client when the client initiates a session.  If it
   were to offer the public key of the server, then it would not be able
   to decrypt or sign the transmissions between the legitimate server
   and the client unless it also had access to the private key of the
   host.  The attack device will also, simultaneously to this, initiate
   a session to the legitimate server, masquerading itself as the
   client.  If the public key of the server had been securely
   distributed to the client prior to that session initiation, the key
   offered to the client by the attack device will not match the key
   stored on the client.  In that case, the user SHOULD be given a
   warning that the offered host key does not match the host key cached
   on the client.  As described in <a href="#section-4.1">Section 4.1</a>, the user may be free to
   accept the new key and continue the session.  It is RECOMMENDED that
   the warning provide sufficient information to the user of the client
   device so the user may make an informed decision.  If the user
   chooses to continue the session with the stored public key of the
   server (not the public key offered at the start of the session), then
   the session-specific data between the attacker and server will be
   different between the client-to-attacker session and the attacker-
   to-server sessions due to the randomness discussed above.  From this,
   the attacker will not be able to make this attack work since the
   attacker will not be able to correctly sign packets containing this
   session-specific data from the server, since he does not have the
   private key of that server.

   The second case that should be considered is similar to the first
   case in that it also happens at the time of connection, but this case
   points out the need for the secure distribution of server public
   keys.  If the server public keys are not securely distributed, then
   the client cannot know if it is talking to the intended server.  An
   attacker may use social engineering techniques to pass off server
   keys to unsuspecting users and may then place a man-in-the-middle
   attack device between the legitimate server and the clients.  If this
   is allowed to happen, then the clients will form client-to-attacker
   sessions, and the attacker will form attacker-to-server sessions and
   will be able to monitor and manipulate all of the traffic between the
   clients and the legitimate servers.  Server administrators are
   encouraged to make host key fingerprints available for checking by
   some means whose security does not rely on the integrity of the
   actual host keys.  Possible mechanisms are discussed in <a href="#section-4.1">Section 4.1</a>
   and may also include secured Web pages, physical pieces of paper,



<span class="grey">Ylonen &amp; Lonvick            Standards Track                    [Page 18]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-19" id="page-19" name="page-19"> </a>
<span class="grey"><a href="rfc4251.html">RFC 4251</a>               SSH Protocol Architecture            January 2006</span>


   etc.  Implementers SHOULD provide recommendations on how best to do
   this with their implementation.  Because the protocol is extensible,
   future extensions to the protocol may provide better mechanisms for
   dealing with the need to know the server's host key before
   connecting.  For example, making the host key fingerprint available
   through a secure DNS lookup, or using Kerberos ([<a href="rfc4120.html" title='"The Kerberos Network Authentication Service (V5)"'>RFC4120</a>]) over
   GSS-API ([<a href="rfc1964.html" title='"The Kerberos Version 5 GSS-API Mechanism"'>RFC1964</a>]) during key exchange to authenticate the server
   are possibilities.

   In the third man-in-the-middle case, attackers may attempt to
   manipulate packets in transit between peers after the session has
   been established.  As described in <a href="#section-9.3.3">Section 9.3.3</a>, a successful attack
   of this nature is very improbable.  As in <a href="#section-9.3.3">Section 9.3.3</a>, this
   reasoning does assume that the MAC is secure and that it is
   infeasible to construct inputs to a MAC algorithm to give a known
   output.  This is discussed in much greater detail in <a href="rfc2104.html#section-6">Section 6 of
   [RFC2104]</a>.  If the MAC algorithm has a vulnerability or is weak
   enough, then the attacker may be able to specify certain inputs to
   yield a known MAC.  With that, they may be able to alter the contents
   of a packet in transit.  Alternatively, the attacker may be able to
   exploit the algorithm vulnerability or weakness to find the shared
   secret by reviewing the MACs from captured packets.  In either of
   those cases, an attacker could construct a packet or packets that
   could be inserted into an SSH stream.  To prevent this, implementers
   are encouraged to utilize commonly accepted MAC algorithms, and
   administrators are encouraged to watch current literature and
   discussions of cryptography to ensure that they are not using a MAC
   algorithm that has a recently found vulnerability or weakness.

   In summary, the use of this protocol without a reliable association
   of the binding between a host and its host keys is inherently
   insecure and is NOT RECOMMENDED.  However, it may be necessary in
   non-security-critical environments, and will still provide protection
   against passive attacks.  Implementers of protocols and applications
   running on top of this protocol should keep this possibility in mind.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/9.3.5.%20%20Denial%20of%20Service"></a><a class="selflink" href="#section-9.3.5" name="section-9.3.5">9.3.5</a>.  Denial of Service</span>

   This protocol is designed to be used over a reliable transport.  If
   transmission errors or message manipulation occur, the connection is
   closed.  The connection SHOULD be re-established if this occurs.
   Denial of service attacks of this type (wire cutter) are almost
   impossible to avoid.

   In addition, this protocol is vulnerable to denial of service attacks
   because an attacker can force the server to go through the CPU and
   memory intensive tasks of connection setup and key exchange without
   authenticating.  Implementers SHOULD provide features that make this



<span class="grey">Ylonen &amp; Lonvick            Standards Track                    [Page 19]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-20" id="page-20" name="page-20"> </a>
<span class="grey"><a href="rfc4251.html">RFC 4251</a>               SSH Protocol Architecture            January 2006</span>


   more difficult, for example, only allowing connections from a subset
   of clients known to have valid users.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/9.3.6.%20%20Covert%20Channels"></a><a class="selflink" href="#section-9.3.6" name="section-9.3.6">9.3.6</a>.  Covert Channels</span>

   The protocol was not designed to eliminate covert channels.  For
   example, the padding, SSH_MSG_IGNORE messages, and several other
   places in the protocol can be used to pass covert information, and
   the recipient has no reliable way of verifying whether such
   information is being sent.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/9.3.7.%20%20Forward%20Secrecy"></a><a class="selflink" href="#section-9.3.7" name="section-9.3.7">9.3.7</a>.  Forward Secrecy</span>

   It should be noted that the Diffie-Hellman key exchanges may provide
   perfect forward secrecy (PFS).  PFS is essentially defined as the
   cryptographic property of a key-establishment protocol in which the
   compromise of a session key or long-term private key after a given
   session does not cause the compromise of any earlier session
   [<a href="#ref-ANSI-T1.523-2001" title='"Telecom Glossary 2000"'>ANSI-T1.523-2001</a>].  SSH sessions resulting from a key exchange using
   the diffie-hellman methods described in the section Diffie-Hellman
   Key Exchange of [<a href="#ref-SSH-TRANS" title='"The Secure Shell (SSH) Transport Layer Protocol"'>SSH-TRANS</a>] (including "diffie-hellman-group1-sha1"
   and "diffie-hellman-group14-sha1") are secure even if private
   keying/authentication material is later revealed, but not if the
   session keys are revealed.  So, given this definition of PFS, SSH
   does have PFS.  However, this property is not commuted to any of the
   applications or protocols using SSH as a transport.  The transport
   layer of SSH provides confidentiality for password authentication and
   other methods that rely on secret data.

   Of course, if the DH private parameters for the client and server are
   revealed, then the session key is revealed, but these items can be
   thrown away after the key exchange completes.  It's worth pointing
   out that these items should not be allowed to end up on swap space
   and that they should be erased from memory as soon as the key
   exchange completes.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/9.3.8.%20%20Ordering%20of%20Key%20Exchange%20Methods"></a><a class="selflink" href="#section-9.3.8" name="section-9.3.8">9.3.8</a>.  Ordering of Key Exchange Methods</span>

   As stated in the section on Algorithm Negotiation of [<a href="#ref-SSH-TRANS" title='"The Secure Shell (SSH) Transport Layer Protocol"'>SSH-TRANS</a>],
   each device will send a list of preferred methods for key exchange.
   The most-preferred method is the first in the list.  It is
   RECOMMENDED that the algorithms be sorted by cryptographic strength,
   strongest first.  Some additional guidance for this is given in
   [<a href="rfc3766.html" title='"Determining Strengths For Public Keys Used For Exchanging Symmetric Keys"'>RFC3766</a>].







<span class="grey">Ylonen &amp; Lonvick            Standards Track                    [Page 20]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-21" id="page-21" name="page-21"> </a>
<span class="grey"><a href="rfc4251.html">RFC 4251</a>               SSH Protocol Architecture            January 2006</span>


<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/9.3.9.%20%20Traffic%20Analysis"></a><a class="selflink" href="#section-9.3.9" name="section-9.3.9">9.3.9</a>.  Traffic Analysis</span>

   Passive monitoring of any protocol may give an attacker some
   information about the session, the user, or protocol specific
   information that they would otherwise not be able to garner.  For
   example, it has been shown that traffic analysis of an SSH session
   can yield information about the length of the password - [<a href="#ref-Openwall" title='"SSH Traffic Analysis Attacks"'>Openwall</a>]
   and [<a href="#ref-USENIX" title='"Timing Analysis of Keystrokes and SSH Timing Attacks"'>USENIX</a>].  Implementers should use the SSH_MSG_IGNORE packet,
   along with the inclusion of random lengths of padding, to thwart
   attempts at traffic analysis.  Other methods may also be found and
   implemented.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/9.4.%20%20Authentication%20Protocol"></a><a class="selflink" href="#section-9.4" name="section-9.4">9.4</a>.  Authentication Protocol</span>

   The purpose of this protocol is to perform client user
   authentication.  It assumes that this runs over a secure transport
   layer protocol, which has already authenticated the server machine,
   established an encrypted communications channel, and computed a
   unique session identifier for this session.

   Several authentication methods with different security
   characteristics are allowed.  It is up to the server's local policy
   to decide which methods (or combinations of methods) it is willing to
   accept for each user.  Authentication is no stronger than the weakest
   combination allowed.

   The server may go into a sleep period after repeated unsuccessful
   authentication attempts to make key search more difficult for
   attackers.  Care should be taken so that this doesn't become a self-
   denial of service vector.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/9.4.1.%20%20Weak%20Transport"></a><a class="selflink" href="#section-9.4.1" name="section-9.4.1">9.4.1</a>.  Weak Transport</span>

   If the transport layer does not provide confidentiality,
   authentication methods that rely on secret data SHOULD be disabled.
   If it does not provide strong integrity protection, requests to
   change authentication data (e.g., a password change) SHOULD be
   disabled to prevent an attacker from modifying the ciphertext without
   being noticed, or rendering the new authentication data unusable
   (denial of service).

   The assumption stated above, that the Authentication Protocol only
   runs over a secure transport that has previously authenticated the
   server, is very important to note.  People deploying SSH are reminded
   of the consequences of man-in-the-middle attacks if the client does
   not have a very strong a priori association of the server with the
   host key of that server.  Specifically, for the case of the
   Authentication Protocol, the client may form a session to a man-in-



<span class="grey">Ylonen &amp; Lonvick            Standards Track                    [Page 21]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-22" id="page-22" name="page-22"> </a>
<span class="grey"><a href="rfc4251.html">RFC 4251</a>               SSH Protocol Architecture            January 2006</span>


   the-middle attack device and divulge user credentials such as their
   username and password.  Even in the cases of authentication where no
   user credentials are divulged, an attacker may still gain information
   they shouldn't have by capturing key-strokes in much the same way
   that a honeypot works.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/9.4.2.%20%20Debug%20Messages"></a><a class="selflink" href="#section-9.4.2" name="section-9.4.2">9.4.2</a>.  Debug Messages</span>

   Special care should be taken when designing debug messages.  These
   messages may reveal surprising amounts of information about the host
   if not properly designed.  Debug messages can be disabled (during
   user authentication phase) if high security is required.
   Administrators of host machines should make all attempts to
   compartmentalize all event notification messages and protect them
   from unwarranted observation.  Developers should be aware of the
   sensitive nature of some of the normal event and debug messages, and
   may want to provide guidance to administrators on ways to keep this
   information away from unauthorized people.  Developers should
   consider minimizing the amount of sensitive information obtainable by
   users during the authentication phase, in accordance with the local
   policies.  For this reason, it is RECOMMENDED that debug messages be
   initially disabled at the time of deployment and require an active
   decision by an administrator to allow them to be enabled.  It is also
   RECOMMENDED that a message expressing this concern be presented to
   the administrator of a system when the action is taken to enable
   debugging messages.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/9.4.3.%20%20Local%20Security%20Policy"></a><a class="selflink" href="#section-9.4.3" name="section-9.4.3">9.4.3</a>.  Local Security Policy</span>

   The implementer MUST ensure that the credentials provided validate
   the professed user and also MUST ensure that the local policy of the
   server permits the user the access requested.  In particular, because
   of the flexible nature of the SSH connection protocol, it may not be
   possible to determine the local security policy, if any, that should
   apply at the time of authentication because the kind of service being
   requested is not clear at that instant.  For example, local policy
   might allow a user to access files on the server, but not start an
   interactive shell.  However, during the authentication protocol, it
   is not known whether the user will be accessing files, attempting to
   use an interactive shell, or even both.  In any event, where local
   security policy for the server host exists, it MUST be applied and
   enforced correctly.

   Implementers are encouraged to provide a default local policy and
   make its parameters known to administrators and users.  At the
   discretion of the implementers, this default policy may be along the
   lines of anything-goes where there are no restrictions placed upon
   users, or it may be along the lines of excessively-restrictive, in



<span class="grey">Ylonen &amp; Lonvick            Standards Track                    [Page 22]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-23" id="page-23" name="page-23"> </a>
<span class="grey"><a href="rfc4251.html">RFC 4251</a>               SSH Protocol Architecture            January 2006</span>


   which case, the administrators will have to actively make changes to
   the initial default parameters to meet their needs.  Alternatively,
   it may be some attempt at providing something practical and
   immediately useful to the administrators of the system so they don't
   have to put in much effort to get SSH working.  Whatever choice is
   made must be applied and enforced as required above.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/9.4.4%20%20Public%20Key%20Authentication"></a><a class="selflink" href="#section-9.4.4" name="section-9.4.4">9.4.4</a>  Public Key Authentication</span>

   The use of public key authentication assumes that the client host has
   not been compromised.  It also assumes that the private key of the
   server host has not been compromised.

   This risk can be mitigated by the use of passphrases on private keys;
   however, this is not an enforceable policy.  The use of smartcards,
   or other technology to make passphrases an enforceable policy is
   suggested.

   The server could require both password and public key authentication;
   however, this requires the client to expose its password to the
   server (see the section on Password Authentication below.)

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/9.4.5.%20%20Password%20Authentication"></a><a class="selflink" href="#section-9.4.5" name="section-9.4.5">9.4.5</a>.  Password Authentication</span>

   The password mechanism, as specified in the authentication protocol,
   assumes that the server has not been compromised.  If the server has
   been compromised, using password authentication will reveal a valid
   username/password combination to the attacker, which may lead to
   further compromises.

   This vulnerability can be mitigated by using an alternative form of
   authentication.  For example, public key authentication makes no
   assumptions about security on the server.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/9.4.6.%20%20Host-Based%20Authentication"></a><a class="selflink" href="#section-9.4.6" name="section-9.4.6">9.4.6</a>.  Host-Based Authentication</span>

   Host-based authentication assumes that the client has not been
   compromised.  There are no mitigating strategies, other than to use
   host-based authentication in combination with another authentication
   method.











<span class="grey">Ylonen &amp; Lonvick            Standards Track                    [Page 23]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-24" id="page-24" name="page-24"> </a>
<span class="grey"><a href="rfc4251.html">RFC 4251</a>               SSH Protocol Architecture            January 2006</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/9.5.%20%20Connection%20Protocol"></a><a class="selflink" href="#section-9.5" name="section-9.5">9.5</a>.  Connection Protocol</span>

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/9.5.1.%20%20End%20Point%20Security"></a><a class="selflink" href="#section-9.5.1" name="section-9.5.1">9.5.1</a>.  End Point Security</span>

   End point security is assumed by the connection protocol.  If the
   server has been compromised, any terminal sessions, port forwarding,
   or systems accessed on the host are compromised.  There are no
   mitigating factors for this.

   If the client has been compromised, and the server fails to stop the
   attacker at the authentication protocol, all services exposed (either
   as subsystems or through forwarding) will be vulnerable to attack.
   Implementers SHOULD provide mechanisms for administrators to control
   which services are exposed to limit the vulnerability of other
   services.  These controls might include controlling which machines
   and ports can be targeted in port-forwarding operations, which users
   are allowed to use interactive shell facilities, or which users are
   allowed to use exposed subsystems.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/9.5.2.%20%20Proxy%20Forwarding"></a><a class="selflink" href="#section-9.5.2" name="section-9.5.2">9.5.2</a>.  Proxy Forwarding</span>

   The SSH connection protocol allows for proxy forwarding of other
   protocols such as SMTP, POP3, and HTTP.  This may be a concern for
   network administrators who wish to control the access of certain
   applications by users located outside of their physical location.
   Essentially, the forwarding of these protocols may violate site-
   specific security policies, as they may be undetectably tunneled
   through a firewall.  Implementers SHOULD provide an administrative
   mechanism to control the proxy forwarding functionality so that
   site-specific security policies may be upheld.

   In addition, a reverse proxy forwarding functionality is available,
   which, again, can be used to bypass firewall controls.

   As indicated above, end-point security is assumed during proxy
   forwarding operations.  Failure of end-point security will compromise
   all data passed over proxy forwarding.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/9.5.3.%20%20X11%20Forwarding"></a><a class="selflink" href="#section-9.5.3" name="section-9.5.3">9.5.3</a>.  X11 Forwarding</span>

   Another form of proxy forwarding provided by the SSH connection
   protocol is the forwarding of the X11 protocol.  If end-point
   security has been compromised, X11 forwarding may allow attacks
   against the X11 server.  Users and administrators should, as a matter
   of course, use appropriate X11 security mechanisms to prevent
   unauthorized use of the X11 server.  Implementers, administrators,
   and users who wish to further explore the security mechanisms of X11
   are invited to read [<a href="#ref-SCHEIFLER" title='"X Window System : The Complete Reference to Xlib, X Protocol, Icccm, Xlfd, 3rd edition."'>SCHEIFLER</a>] and analyze previously reported



<span class="grey">Ylonen &amp; Lonvick            Standards Track                    [Page 24]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-25" id="page-25" name="page-25"> </a>
<span class="grey"><a href="rfc4251.html">RFC 4251</a>               SSH Protocol Architecture            January 2006</span>


   problems with the interactions between SSH forwarding and X11 in CERT
   vulnerabilities VU#363181 and VU#118892 [<a href="#ref-CERT" title='"http://www.cert.org/nav/index_red.html"'>CERT</a>].

   X11 display forwarding with SSH, by itself, is not sufficient to
   correct well known problems with X11 security [<a href="#ref-VENEMA" title="&quot;Murphy's Law and Computer Security&quot;">VENEMA</a>].  However, X11
   display forwarding in SSH (or other secure protocols), combined with
   actual and pseudo-displays that accept connections only over local
   IPC mechanisms authorized by permissions or access control lists
   (ACLs), does correct many X11 security problems, as long as the
   "none" MAC is not used.  It is RECOMMENDED that X11 display
   implementations default to allow the display to open only over local
   IPC.  It is RECOMMENDED that SSH server implementations that support
   X11 forwarding default to allow the display to open only over local
   IPC.  On single-user systems, it might be reasonable to default to
   allow the local display to open over TCP/IP.

   Implementers of the X11 forwarding protocol SHOULD implement the
   magic cookie access-checking spoofing mechanism, as described in
   [<a href="#ref-SSH-CONNECT" title='"The Secure Shell (SSH) Connection Protocol"'>SSH-CONNECT</a>], as an additional mechanism to prevent unauthorized use
   of the proxy.































<span class="grey">Ylonen &amp; Lonvick            Standards Track                    [Page 25]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-26" id="page-26" name="page-26"> </a>
<span class="grey"><a href="rfc4251.html">RFC 4251</a>               SSH Protocol Architecture            January 2006</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/10.%20%20References"></a><a class="selflink" href="#section-10" name="section-10">10</a>.  References</span>

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/10.1.%20%20Normative%20References"></a><a class="selflink" href="#section-10.1" name="section-10.1">10.1</a>.  Normative References</span>

   [<a id="ref-SSH-TRANS" name="ref-SSH-TRANS">SSH-TRANS</a>]        Ylonen, T. and C. Lonvick, Ed., "The Secure Shell
                      (SSH) Transport Layer Protocol", <a href="rfc4253.html">RFC 4253</a>, January
                      2006.

   [<a id="ref-SSH-USERAUTH" name="ref-SSH-USERAUTH">SSH-USERAUTH</a>]     Ylonen, T. and C. Lonvick, Ed., "The Secure Shell
                      (SSH) Authentication Protocol", <a href="rfc4252.html">RFC 4252</a>, January
                      2006.

   [<a id="ref-SSH-CONNECT" name="ref-SSH-CONNECT">SSH-CONNECT</a>]      Ylonen, T. and C. Lonvick, Ed., "The Secure Shell
                      (SSH) Connection Protocol", <a href="rfc4254.html">RFC 4254</a>, January
                      2006.

   [<a id="ref-SSH-NUMBERS" name="ref-SSH-NUMBERS">SSH-NUMBERS</a>]      Lehtinen, S. and C. Lonvick, Ed., "The Secure
                      Shell (SSH) Protocol Assigned Numbers", <a href="rfc4250.html">RFC 4250</a>,
                      January 2006.

   [<a id="ref-RFC2119" name="ref-RFC2119">RFC2119</a>]          Bradner, S., "Key words for use in RFCs to
                      Indicate Requirement Levels", <a href="https://tools.ietf.org/html/bcp14">BCP 14</a>, <a href="rfc2119.html">RFC 2119</a>,
                      March 1997.

   [<a id="ref-RFC2434" name="ref-RFC2434">RFC2434</a>]          Narten, T. and H. Alvestrand, "Guidelines for
                      Writing an IANA Considerations Section in RFCs",
                      <a href="https://tools.ietf.org/html/bcp26">BCP 26</a>, <a href="rfc2434.html">RFC 2434</a>, October 1998.

   [<a id="ref-RFC3066" name="ref-RFC3066">RFC3066</a>]          Alvestrand, H., "Tags for the Identification of
                      Languages", <a href="https://tools.ietf.org/html/bcp47">BCP 47</a>, <a href="rfc3066.html">RFC 3066</a>, January 2001.

   [<a id="ref-RFC3629" name="ref-RFC3629">RFC3629</a>]          Yergeau, F., "UTF-8, a transformation format of
                      ISO 10646", STD 63, <a href="rfc3629.html">RFC 3629</a>, November 2003.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/10.2.%20%20Informative%20References"></a><a class="selflink" href="#section-10.2" name="section-10.2">10.2</a>.  Informative References</span>

   [<a id="ref-RFC0822" name="ref-RFC0822">RFC0822</a>]          Crocker, D., "Standard for the format of ARPA
                      Internet text messages", STD 11, <a href="rfc822.html">RFC 822</a>, August
                      1982.

   [<a id="ref-RFC0854" name="ref-RFC0854">RFC0854</a>]          Postel, J. and J. Reynolds, "Telnet Protocol
                      Specification", STD 8, <a href="rfc854.html">RFC 854</a>, May 1983.

   [<a id="ref-RFC1034" name="ref-RFC1034">RFC1034</a>]          Mockapetris, P., "Domain names - concepts and
                      facilities", STD 13, <a href="rfc1034.html">RFC 1034</a>, November 1987.






<span class="grey">Ylonen &amp; Lonvick            Standards Track                    [Page 26]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-27" id="page-27" name="page-27"> </a>
<span class="grey"><a href="rfc4251.html">RFC 4251</a>               SSH Protocol Architecture            January 2006</span>


   [<a id="ref-RFC1282" name="ref-RFC1282">RFC1282</a>]          Kantor, B., "BSD Rlogin", <a href="rfc1282.html">RFC 1282</a>, December 1991.

   [<a id="ref-RFC4120" name="ref-RFC4120">RFC4120</a>]          Neuman, C., Yu, T., Hartman, S., and K. Raeburn,
                      "The Kerberos Network Authentication Service
                      (V5)", <a href="rfc4120.html">RFC 4120</a>, July 2005.

   [<a id="ref-RFC1964" name="ref-RFC1964">RFC1964</a>]          Linn, J., "The Kerberos Version 5 GSS-API
                      Mechanism", <a href="rfc1964.html">RFC 1964</a>, June 1996.

   [<a id="ref-RFC2025" name="ref-RFC2025">RFC2025</a>]          Adams, C., "The Simple Public-Key GSS-API
                      Mechanism (SPKM)", <a href="rfc2025.html">RFC 2025</a>, October 1996.

   [<a id="ref-RFC2085" name="ref-RFC2085">RFC2085</a>]          Oehler, M. and R. Glenn, "HMAC-MD5 IP
                      Authentication with Replay Prevention", <a href="rfc2085.html">RFC 2085</a>,
                      February 1997.

   [<a id="ref-RFC2104" name="ref-RFC2104">RFC2104</a>]          Krawczyk, H., Bellare, M., and R. Canetti, "HMAC:
                      Keyed-Hashing for Message Authentication", <a href="rfc2104.html">RFC</a>
                      <a href="rfc2104.html">2104</a>, February 1997.

   [<a id="ref-RFC2246" name="ref-RFC2246">RFC2246</a>]          Dierks, T. and C. Allen, "The TLS Protocol Version
                      1.0", <a href="rfc2246.html">RFC 2246</a>, January 1999.

   [<a id="ref-RFC2410" name="ref-RFC2410">RFC2410</a>]          Glenn, R. and S. Kent, "The NULL Encryption
                      Algorithm and Its Use With IPsec", <a href="rfc2410.html">RFC 2410</a>,
                      November 1998.

   [<a id="ref-RFC2743" name="ref-RFC2743">RFC2743</a>]          Linn, J., "Generic Security Service Application
                      Program Interface Version 2, Update 1", <a href="rfc2743.html">RFC 2743</a>,
                      January 2000.

   [<a id="ref-RFC3766" name="ref-RFC3766">RFC3766</a>]          Orman, H. and P. Hoffman, "Determining Strengths
                      For Public Keys Used For Exchanging Symmetric
                      Keys", <a href="https://tools.ietf.org/html/bcp86">BCP 86</a>, <a href="rfc3766.html">RFC 3766</a>, April 2004.

   [<a id="ref-RFC4086" name="ref-RFC4086">RFC4086</a>]          Eastlake, D., 3rd, Schiller, J., and S. Crocker,
                      "Randomness Requirements for Security", <a href="https://tools.ietf.org/html/bcp106">BCP 106</a>,
                      <a href="rfc4086.html">RFC 4086</a>, June 2005.

   [<a id="ref-FIPS-180-2" name="ref-FIPS-180-2">FIPS-180-2</a>]       US National Institute of Standards and Technology,
                      "Secure Hash Standard (SHS)", Federal Information
                      Processing Standards Publication 180-2, August
                      2002.

   [<a id="ref-FIPS-186-2" name="ref-FIPS-186-2">FIPS-186-2</a>]       US National Institute of Standards and Technology,
                      "Digital Signature Standard (DSS)", Federal
                      Information Processing Standards Publication 186-
                      2, January 2000.



<span class="grey">Ylonen &amp; Lonvick            Standards Track                    [Page 27]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-28" id="page-28" name="page-28"> </a>
<span class="grey"><a href="rfc4251.html">RFC 4251</a>               SSH Protocol Architecture            January 2006</span>


   [<a id="ref-FIPS-197" name="ref-FIPS-197">FIPS-197</a>]         US National Institute of Standards and Technology,
                      "Advanced Encryption Standard (AES)", Federal
                      Information Processing Standards Publication 197,
                      November 2001.

   [<a id="ref-ANSI-T1.523-2001" name="ref-ANSI-T1.523-2001">ANSI-T1.523-2001</a>] American National Standards Institute, Inc.,
                      "Telecom Glossary 2000", ANSI T1.523-2001,
                      February 2001.

   [<a id="ref-SCHNEIER" name="ref-SCHNEIER">SCHNEIER</a>]         Schneier, B., "Applied Cryptography Second
                      Edition:  protocols algorithms and source in code
                      in C", John Wiley and Sons, New York, NY, 1996.

   [<a id="ref-SCHEIFLER" name="ref-SCHEIFLER">SCHEIFLER</a>]        Scheifler, R., "X Window System : The Complete
                      Reference to Xlib, X Protocol, Icccm, Xlfd, 3rd
                      edition.", Digital Press, ISBN 1555580882,
                      February 1992.

   [<a id="ref-KAUFMAN" name="ref-KAUFMAN">KAUFMAN</a>]          Kaufman, C., Perlman, R., and M. Speciner,
                      "Network Security: PRIVATE Communication in a
                      PUBLIC World", Prentice Hall Publisher, 1995.

   [<a id="ref-CERT" name="ref-CERT">CERT</a>]             CERT Coordination Center, The.,
                      "<a href="http://www.cert.org/nav/index_red.html">http://www.cert.org/nav/index_red.html</a>".

   [<a id="ref-VENEMA" name="ref-VENEMA">VENEMA</a>]           Venema, W., "Murphy's Law and Computer Security",
                      Proceedings of 6th USENIX Security Symposium, San
                      Jose CA
                      <a href="http://www.usenix.org/publications/library/proceedings/sec96/venema.html">http://www.usenix.org/publications/library/</a>
                      <a href="http://www.usenix.org/publications/library/proceedings/sec96/venema.html">proceedings/sec96/venema.html</a>, July 1996.

   [<a id="ref-ROGAWAY" name="ref-ROGAWAY">ROGAWAY</a>]          Rogaway, P., "Problems with Proposed IP
                      Cryptography", Unpublished paper
                      <a href="http://www.cs.ucdavis.edu/~rogaway/">http://www.cs.ucdavis.edu/~rogaway/</a> papers/draft-
                      rogaway-ipsec-comments-00.txt, 1996.

   [<a id="ref-DAI" name="ref-DAI">DAI</a>]              Dai, W., "An attack against SSH2 protocol", Email
                      to the SECSH Working Group ietf-ssh@netbsd.org
                      ftp:// ftp.ietf.org/ietf-mail-archive/secsh/2002-
                      02.mail, Feb 2002.

   [<a id="ref-BELLARE" name="ref-BELLARE">BELLARE</a>]          Bellaire, M., Kohno, T., and C. Namprempre,
                      "Authenticated Encryption in SSH: Fixing the SSH
                      Binary Packet Protocol", Proceedings of the 9th
                      ACM Conference on Computer and Communications
                      Security, Sept 2002.





<span class="grey">Ylonen &amp; Lonvick            Standards Track                    [Page 28]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-29" id="page-29" name="page-29"> </a>
<span class="grey"><a href="rfc4251.html">RFC 4251</a>               SSH Protocol Architecture            January 2006</span>


   [<a id="ref-Openwall" name="ref-Openwall">Openwall</a>]         Solar Designer and D. Song, "SSH Traffic Analysis
                      Attacks", Presentation given at HAL2001 and
                      NordU2002 Conferences, Sept 2001.

   [<a id="ref-USENIX" name="ref-USENIX">USENIX</a>]           Song, X.D., Wagner, D., and X. Tian, "Timing
                      Analysis of Keystrokes and SSH Timing Attacks",
                      Paper given at 10th USENIX Security Symposium,
                      2001.

Authors' Addresses

   Tatu Ylonen
   SSH Communications Security Corp
   Valimotie 17
   00380 Helsinki
   Finland

   EMail: ylo@ssh.com


   Chris Lonvick (editor)
   Cisco Systems, Inc.
   12515 Research Blvd.
   Austin  78759
   USA

   EMail: clonvick@cisco.com

Trademark Notice

   "ssh" is a registered trademark in the United States and/or other
   countries.



















<span class="grey">Ylonen &amp; Lonvick            Standards Track                    [Page 29]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-30" id="page-30" name="page-30"> </a>
<span class="grey"><a href="rfc4251.html">RFC 4251</a>               SSH Protocol Architecture            January 2006</span>


Full Copyright Statement

   Copyright (C) The Internet Society (2006).

   This document is subject to the rights, licenses and restrictions
   contained in <a href="https://tools.ietf.org/html/bcp78">BCP 78</a>, and except as set forth therein, the authors
   retain all their rights.

   This document and the information contained herein are provided on an
   "AS IS" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS
   OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET
   ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED,
   INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE
   INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED
   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.

Intellectual Property

   The IETF takes no position regarding the validity or scope of any
   Intellectual Property Rights or other rights that might be claimed to
   pertain to the implementation or use of the technology described in
   this document or the extent to which any license under such rights
   might or might not be available; nor does it represent that it has
   made any independent effort to identify any such rights.  Information
   on the procedures with respect to rights in RFC documents can be
   found in <a href="https://tools.ietf.org/html/bcp78">BCP 78</a> and <a href="https://tools.ietf.org/html/bcp79">BCP 79</a>.

   Copies of IPR disclosures made to the IETF Secretariat and any
   assurances of licenses to be made available, or the result of an
   attempt made to obtain a general license or permission for the use of
   such proprietary rights by implementers or users of this
   specification can be obtained from the IETF on-line IPR repository at
   <a href="http://www.ietf.org/ipr">http://www.ietf.org/ipr</a>.

   The IETF invites any interested party to bring to its attention any
   copyrights, patents or patent applications, or other proprietary
   rights that may cover technology that may be required to implement
   this standard.  Please address the information to the IETF at
   ietf-ipr@ietf.org.

Acknowledgement

   Funding for the RFC Editor function is provided by the IETF
   Administrative Support Activity (IASA).







Ylonen &amp; Lonvick            Standards Track                    [Page 30]

</pre><br/>
    <span class="noprint"><small><small>Html markup produced by rfcmarkup 1.126, available from
      <a href="https://tools.ietf.org/tools/rfcmarkup/">https://tools.ietf.org/tools/rfcmarkup/</a>
    </small></small></span>
  </div>




</body><!-- Mirrored from tools.ietf.org/html/rfc4251 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 06 Mar 2018 23:18:42 GMT --></html>