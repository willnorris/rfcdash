<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml"><!-- Mirrored from tools.ietf.org/html/rfc4507 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 06 Mar 2018 23:18:40 GMT --><!-- Added by HTTrack --><head><meta content="text/html;charset=utf-8" http-equiv="content-type"/><!-- /Added by HTTrack -->

    <meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
    <meta content="index,follow" name="robots"/>
    <meta content="rfcmarkup version 1.126" name="creator"/>
    <link href="http://purl.org/dc/elements/1.1/" rel="schema.DC"/>
<meta content="urn:ietf:rfc:4507" name="DC.Identifier"/>
<meta content="This document describes a mechanism that enables the Transport Layer
Security (TLS) server to resume sessions and avoid keeping \%per-
client session state. The TLS server encapsulates the session state
into a ticket and forwards it to the client. The client can
subsequently resume a session using the obtained ticket. [STANDARDS-
TRACK]" name="DC.Description.Abstract"/>
<meta content="Eronen, Pasi" name="DC.Creator"/>
<meta content="Tschofenig, Hannes" name="DC.Creator"/>
<meta content="Zhou, Hao" name="DC.Creator"/>
<meta content="Salowey, Joseph" name="DC.Creator"/>
<meta content="May, 2006" name="DC.Date.Issued"/>
<meta content="Transport Layer Security (TLS) Session Resumption without Server-Side State" name="DC.Title"/>

    <link href="https://tools.ietf.org/images/rfc.png" rel="icon" type="image/png"/>
    <link href="https://tools.ietf.org/images/rfc.png" rel="shortcut icon" type="image/png"/>
    <title>RFC 4507 - Transport Layer Security (TLS) Session Resumption without Server-Side State</title>
    
    
    <style type="text/css">
	@media only screen 
	  and (min-width: 992px)
	  and (max-width: 1199px) {
	    body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 768px)
	  and (max-width: 991px) {
            body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 480px)
	  and (max-width: 767px) {
            body { font-size: 11pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (max-width: 479px) {
            body { font-size: 8pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-device-width : 375px) 
	  and (max-device-width : 667px) {
            body { font-size: 9.5pt; }
            div.content { width: 96ex; margin: 0 1px; }
        }
	@media only screen 
	  and (min-device-width: 1200px) {
            body { font-size: 10pt; margin: 0 4em; }
            div.content { width: 96ex; margin: 0; }
        }
        h1, h2, h3, h4, h5, h6, .h1, .h2, .h3, .h4, .h5, .h6 {
	    font-weight: bold;
            line-height: 0pt;
            display: inline;
            white-space: pre;
            font-family: monospace;
            font-size: 1em;
	    font-weight: bold;
        }
        pre {
            font-size: 1em;
            margin-top: 0px;
            margin-bottom: 0px;
        }
	.pre {
	    white-space: pre;
	    font-family: monospace;
	}
	.header{
	    font-weight: bold;
	}
        .newpage {
            page-break-before: always;
        }
        .invisible {
            text-decoration: none;
            color: white;
        }
        a.selflink {
          color: black;
          text-decoration: none;
        }
        @media print {
            body {
                font-family: monospace;
                font-size: 10.5pt;
            }
            h1, h2, h3, h4, h5, h6 {
                font-size: 1em;
            }
        
            a:link, a:visited {
                color: inherit;
                text-decoration: none;
            }
            .noprint {
                display: none;
            }
        }
	@media screen {
	    .grey, .grey a:link, .grey a:visited {
		color: #777;
	    }
            .docinfo {
                background-color: #EEE;
            }
            .top {
                border-top: 7px solid #EEE;
            }
            .bgwhite  { background-color: white; }
            .bgred    { background-color: #F44; }
            .bggrey   { background-color: #666; }
            .bgbrown  { background-color: #840; }            
            .bgorange { background-color: #FA0; }
            .bgyellow { background-color: #EE0; }
            .bgmagenta{ background-color: #F4F; }
            .bgblue   { background-color: #66F; }
            .bgcyan   { background-color: #4DD; }
            .bggreen  { background-color: #4F4; }

            .legend   { font-size: 90%; }
            .cplate   { font-size: 70%; border: solid grey 1px; }
	}
    </style>
    <!--[if IE]>
    <style>
    body {
       font-size: 13px;
       margin: 10px 10px;
    }
    </style>
    <![endif]-->

    <script type="text/javascript"><!--
    function addHeaderTags() {
	var spans = document.getElementsByTagName("span");
	for (var i=0; i < spans.length; i++) {
	    var elem = spans[i];
	    if (elem) {
		var level = elem.getAttribute("class");
                if (level == "h1" || level == "h2" || level == "h3" || level == "h4" || level == "h5" || level == "h6") {
                    elem.innerHTML = "<"+level+">"+elem.innerHTML+"</"+level+">";		
                }
	    }
	}
    }
    var legend_html = "Colour legend:<br />      <table>         <tr><td>Unknown:</td>                   <td><span class='cplate bgwhite'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft:</td>                     <td><span class='cplate bgred'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Informational:</td>             <td><span class='cplate bgorange'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Experimental:</td>              <td><span class='cplate bgyellow'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Best Common Practice:</td>      <td><span class='cplate bgmagenta'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Proposed Standard:</td>         <td><span class='cplate bgblue'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft Standard (old designation):</td> <td><span class='cplate bgcyan'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Internet Standard:</td>         <td><span class='cplate bggreen'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Historic:</td>                  <td><span class='cplate bggrey'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Obsolete:</td>                  <td><span class='cplate bgbrown'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>     </table>";
    function showElem(id) {
        var elem = document.getElementById(id);
        elem.innerHTML = eval(id+"_html");
        elem.style.visibility='visible';
    }
    function hideElem(id) {
        var elem = document.getElementById(id);
        elem.style.visibility='hidden';        
        elem.innerHTML = "";
    }
    // -->
    </script>
</head>
<body onload="addHeaderTags()">
  <div class="content">
   <div style="height: 13px;">
      <div class="pre noprint docinfo bgbrown" onclick="showElem('legend');" onmouseout="hideElem('legend')" onmouseover="this.style.cursor='pointer';" style="height: 6px; position: absolute;" title="Click for colour legend.">                                                                        </div>
      <div class="docinfo noprint pre legend" id="legend" onmouseout="hideElem('legend');" onmouseover="showElem('legend');" style="position:absolute; top: 4px; left: 4ex; visibility:hidden; background-color: white; padding: 4px 9px 5px 7px; border: solid #345 1px; ">
      </div>
   </div>
<span class="pre noprint docinfo top">[<a href="index.html" title="Document search and retrieval page">Docs</a>] [<a href="https://tools.ietf.org/rfc/rfc4507.txt" title="Plaintext version of this document">txt</a>|<a href="https://tools.ietf.org/pdf/rfc4507" title="PDF version of this document">pdf</a>] [<a href="https://tools.ietf.org/html/draft-salowey-tls-ticket" title="draft-salowey-tls-ticket">draft-salowey-t...</a>] [<a href="https://datatracker.ietf.org/doc/rfc4507" title="IESG Datatracker information for this document">Tracker</a>] [<a href="https://tools.ietf.org/rfcdiff?difftype=--hwdiff&amp;url2=rfc4507" title="Inline diff (wdiff)">Diff1</a>] [<a href="https://tools.ietf.org/rfcdiff?url2=rfc4507" title="Side-by-side diff">Diff2</a>] [<a href="https://datatracker.ietf.org/ipr/search/?rfc=4507&amp;submit=rfc" title="IPR disclosures related to this document">IPR</a>]   </span><br/>
<span class="pre noprint docinfo">                                                                        </span><br/>
<span class="pre noprint docinfo">Obsoleted by: <a href="rfc5077.html">5077</a>                                     PROPOSED STANDARD</span><br/>
<span class="pre noprint docinfo">                                                                        </span><br/>
<pre>Network Working Group                                         J. Salowey
Request for Comments: 4507                                       H. Zhou
Category: Standards Track                                  Cisco Systems
                                                               P. Eronen
                                                                   Nokia
                                                           H. Tschofenig
                                                                 Siemens
                                                                May 2006


                 <span class="h1">Transport Layer Security (TLS) Session</span>
                  <span class="h1">Resumption without Server-Side State</span>

Status of This Memo

   This document specifies an Internet standards track protocol for the
   Internet community, and requests discussion and suggestions for
   improvements.  Please refer to the current edition of the "Internet
   Official Protocol Standards" (STD 1) for the standardization state
   and status of this protocol.  Distribution of this memo is unlimited.

Copyright Notice

   Copyright (C) The Internet Society (2006).

Abstract

   This document describes a mechanism that enables the Transport Layer
   Security (TLS) server to resume sessions and avoid keeping per-client
   session state.  The TLS server encapsulates the session state into a
   ticket and forwards it to the client.  The client can subsequently
   resume a session using the obtained ticket.



















<span class="grey">Salowey, et al.             Standards Track                     [Page 1]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-2" id="page-2" name="page-2"> </a>
<span class="grey"><a href="rfc4507.html">RFC 4507</a>            Stateless TLS Session Resumption            May 2006</span>


Table of Contents

   <a href="#section-1">1</a>. Introduction ....................................................<a href="#page-3">3</a>
   <a href="#section-2">2</a>. Terminology .....................................................<a href="#page-3">3</a>
   <a href="#section-3">3</a>. Protocol ........................................................<a href="#page-3">3</a>
      <a href="#section-3.1">3.1</a>. Overview ...................................................<a href="#page-4">4</a>
      <a href="#section-3.2">3.2</a>. SessionTicket TLS Extension ................................<a href="#page-6">6</a>
      <a href="#section-3.3">3.3</a>. NewSessionTicket Handshake Message .........................<a href="#page-7">7</a>
      <a href="#section-3.4">3.4</a>. Interaction with TLS Session ID ............................<a href="#page-8">8</a>
   <a href="#section-4">4</a>. Recommended Ticket Construction .................................<a href="#page-9">9</a>
   <a href="#section-5">5</a>. Security Considerations ........................................<a href="#page-10">10</a>
      <a href="#section-5.1">5.1</a>. Invalidating Sessions .....................................<a href="#page-11">11</a>
      <a href="#section-5.2">5.2</a>. Stolen Tickets ............................................<a href="#page-11">11</a>
      <a href="#section-5.3">5.3</a>. Forged Tickets ............................................<a href="#page-11">11</a>
      <a href="#section-5.4">5.4</a>. Denial of Service Attacks .................................<a href="#page-11">11</a>
      <a href="#section-5.5">5.5</a>. Ticket Protection Key Management ..........................<a href="#page-12">12</a>
      <a href="#section-5.6">5.6</a>. Ticket Lifetime ...........................................<a href="#page-12">12</a>
      <a href="#section-5.7">5.7</a>. Alternate Ticket Formats and Distribution Schemes .........<a href="#page-12">12</a>
      <a href="#section-5.8">5.8</a>. Identity Privacy, Anonymity, and Unlinkability ............<a href="#page-12">12</a>
   <a href="#section-6">6</a>. Acknowledgements ...............................................<a href="#page-13">13</a>
   <a href="#section-7">7</a>. IANA Considerations ............................................<a href="#page-13">13</a>
   <a href="#section-8">8</a>. References .....................................................<a href="#page-14">14</a>
      <a href="#section-8.1">8.1</a>. Normative References ......................................<a href="#page-14">14</a>
      <a href="#section-8.2">8.2</a>. Informative References ....................................<a href="#page-14">14</a>



























<span class="grey">Salowey, et al.             Standards Track                     [Page 2]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-3" id="page-3" name="page-3"> </a>
<span class="grey"><a href="rfc4507.html">RFC 4507</a>            Stateless TLS Session Resumption            May 2006</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/1.%20%20Introduction"></a><a class="selflink" href="#section-1" name="section-1">1</a>.  Introduction</span>

   This document defines a way to resume a Transport Layer Security
   (TLS) session without requiring session-specific state at the TLS
   server.  This mechanism may be used with any TLS ciphersuite.  This
   document applies to both TLS 1.0 defined in [<a href="rfc2246.html" title='"The TLS Protocol Version 1.0"'>RFC2246</a>] and TLS 1.1
   defined in [<a href="rfc4346.html" title='"The Transport Layer Security (TLS) Protocol Version 1.1"'>RFC4346</a>].  The mechanism makes use of TLS extensions
   defined in [<a href="rfc4366.html" title='"Transport Layer Security (TLS) Extensions"'>RFC4366</a>] and defines a new TLS message type.

   This mechanism is useful in the following situations:

   1.  servers that handle a large number of transactions from different
       users
   2.  servers that desire to cache sessions for a long time
   3.  ability to load balance requests across servers
   4.  embedded servers with little memory

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/2.%20%20Terminology"></a><a class="selflink" href="#section-2" name="section-2">2</a>.  Terminology</span>

   Within this document, the term 'ticket' refers to a cryptographically
   protected data structure that is created by the server and consumed
   by the server to rebuild session-specific state.

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in [<a href="rfc2119.html" title='"Key words for use in RFCs to Indicate Requirement Levels"'>RFC2119</a>].

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/3.%20%20Protocol"></a><a class="selflink" href="#section-3" name="section-3">3</a>.  Protocol</span>

   This specification describes a mechanism to distribute encrypted
   session-state information in the form of a ticket.  The ticket is
   created by a TLS server and sent to a TLS client.  The TLS client
   presents the ticket to the TLS server to resume a session.
   Implementations of this specification are expected to support both
   mechanisms.  Other specifications can take advantage of the session
   tickets, perhaps specifying alternative means for distribution or
   selection.  For example, a separate specification may describe an
   alternate way to distribute a ticket and use the TLS extension in
   this document to resume the session.  This behavior is beyond the
   scope of the document and would need to be described in a separate
   specification.










<span class="grey">Salowey, et al.             Standards Track                     [Page 3]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-4" id="page-4" name="page-4"> </a>
<span class="grey"><a href="rfc4507.html">RFC 4507</a>            Stateless TLS Session Resumption            May 2006</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.1.%20%20Overview"></a><a class="selflink" href="#section-3.1" name="section-3.1">3.1</a>.  Overview</span>

   The client indicates that it supports this mechanism by including a
   SessionTicket TLS extension in the ClientHello message.  The
   extension will be empty if the client does not already possess a
   ticket for the server.  The extension is described in <a href="#section-3.2">Section 3.2</a>.

   If the server wants to use this mechanism, it stores its session
   state (such as ciphersuite and master secret) to a ticket that is
   encrypted and integrity-protected by a key known only to the server.
   The ticket is distributed to the client using the NewSessionTicket
   TLS handshake message described in <a href="#section-3.3">Section 3.3</a>.  This message is sent
   during the TLS handshake before the ChangeCipherSpec message, after
   the server has successfully verified the client's Finished message.

      Client                                               Server

      ClientHello
      (empty SessionTicket extension)-------&gt;
                                                      ServerHello
                                  (empty SessionTicket extension)
                                                     Certificate*
                                               ServerKeyExchange*
                                              CertificateRequest*
                                   &lt;--------      ServerHelloDone
      Certificate*
      ClientKeyExchange
      CertificateVerify*
      [ChangeCipherSpec]
      Finished                     --------&gt;
                                                 NewSessionTicket
                                               [ChangeCipherSpec]
                                   &lt;--------             Finished
      Application Data             &lt;-------&gt;     Application Data

   Figure 1: Message flow for full handshake issuing new session ticket

   The client caches this ticket along with the master secret and other
   parameters associated with the current session.  When the client
   wishes to resume the session, it includes the ticket in the
   SessionTicket extension within the ClientHello message.  The server
   then decrypts the received ticket, verifies the ticket's validity,
   retrieves the session state from the contents of the ticket, and uses
   this state to resume the session.  The interaction with the TLS
   Session ID is described in <a href="#section-3.4">Section 3.4</a>.  If the server successfully
   verifies the client's ticket, then it may renew the ticket by
   including a NewSessionTicket handshake message after the ServerHello.




<span class="grey">Salowey, et al.             Standards Track                     [Page 4]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-5" id="page-5" name="page-5"> </a>
<span class="grey"><a href="rfc4507.html">RFC 4507</a>            Stateless TLS Session Resumption            May 2006</span>


      Client                                                Server

      ClientHello
      (SessionTicket extension)      --------&gt;
                                                       ServerHello
                                   (empty SessionTicket extension)
                                                  NewSessionTicket
                                                [ChangeCipherSpec]
                                    &lt;--------             Finished
      [ChangeCipherSpec]
      Finished                      --------&gt;
      Application Data              &lt;-------&gt;     Application Data

        Figure 2: Message flow for abbreviated handshake using new
                              session ticket

   A recommended ticket format is given in <a href="#section-4">Section 4</a>.

   If the server cannot or does not want to honor the ticket, then it
   can initiate a full handshake with the client.

   In the case that the server does not wish to issue a new ticket at
   this time, it just completes the handshake without including a
   SessionTicket extension or NewSessionTicket handshake message.  This
   is shown below (this flow is identical to Figure 1 in <a href="rfc2246.html">RFC 2246</a>,
   except for the session ticket extension in the first message):

      Client                                               Server

      ClientHello
      (SessionTicket extension)    --------&gt;
                                                      ServerHello
                                                     Certificate*
                                               ServerKeyExchange*
                                              CertificateRequest*
                                   &lt;--------      ServerHelloDone
      Certificate*
      ClientKeyExchange
      CertificateVerify*
      [ChangeCipherSpec]
      Finished                     --------&gt;
                                               [ChangeCipherSpec]
                                   &lt;--------             Finished
      Application Data             &lt;-------&gt;     Application Data

       Figure 3: Message flow for server completing full handshake
                    without issuing new session ticket




<span class="grey">Salowey, et al.             Standards Track                     [Page 5]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-6" id="page-6" name="page-6"> </a>
<span class="grey"><a href="rfc4507.html">RFC 4507</a>            Stateless TLS Session Resumption            May 2006</span>


   If the server rejects the ticket, it may still wish to issue a new
   ticket after performing the full handshake as shown below (this flow
   is identical to Figure 1, except the SessionTicket extension in the
   Client Hello is not empty):

      Client                                               Server

      ClientHello
      (SessionTicket extension) --------&gt;
                                                      ServerHello
                                  (empty SessionTicket extension)
                                                     Certificate*
                                               ServerKeyExchange*
                                              CertificateRequest*
                               &lt;--------          ServerHelloDone
      Certificate*
      ClientKeyExchange
      CertificateVerify*
      [ChangeCipherSpec]
      Finished                 --------&gt;
                                                 NewSessionTicket
                                               [ChangeCipherSpec]
                               &lt;--------                 Finished
      Application Data         &lt;-------&gt;         Application Data

   Figure 4: Message flow for server rejecting ticket, performing full
                 handshake and issuing new session ticket

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.2.%20%20SessionTicket%20TLS%20Extension"></a><a class="selflink" href="#section-3.2" name="section-3.2">3.2</a>.  SessionTicket TLS Extension</span>

   The SessionTicket TLS extension is based on [<a href="rfc4366.html" title='"Transport Layer Security (TLS) Extensions"'>RFC4366</a>].  The format of
   the ticket is an opaque structure used to carry session-specific
   state information.  This extension may be sent in the ClientHello and
   ServerHello.

   If the client possesses a ticket that it wants to use to resume a
   session, then it includes the ticket in the SessionTicket extension
   in the ClientHello.  If the client does not have a ticket and is
   prepared to receive one in the NewSessionTicket handshake message,
   then it MUST include a zero-length ticket in the SessionTicket
   extension.  If the client is not prepared to receive a ticket in the
   NewSessionTicket handshake message then it MUST NOT include a
   SessionTicket extension unless it is sending a non-empty ticket it
   received through some other means from the server.

   The server uses an zero length SessionTicket extension to indicate to
   the client that it will send a new session ticket using the
   NewSessionTicket handshake message described in <a href="#section-3.3">Section 3.3</a>.  The



<span class="grey">Salowey, et al.             Standards Track                     [Page 6]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-7" id="page-7" name="page-7"> </a>
<span class="grey"><a href="rfc4507.html">RFC 4507</a>            Stateless TLS Session Resumption            May 2006</span>


   server MUST send this extension in the ServerHello if it wishes to
   issue a new ticket to the client using the NewSessionTicket handshake
   message.  The server MUST NOT send this extension if it does not
   receive one in the ClientHello.

   If the server fails to verify the ticket, then it falls back to
   performing a full handshake.  If the ticket is accepted by the server
   but the handshake fails, the client SHOULD delete the ticket.

   The SessionTicket extension has been assigned the number 35.  The
   format of the SessionTicket extension is given at the end of this
   section.

      struct {
          opaque ticket&lt;0..2^16-1&gt;;
      } SessionTicket;

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.3.%20%20NewSessionTicket%20Handshake%20Message"></a><a class="selflink" href="#section-3.3" name="section-3.3">3.3</a>.  NewSessionTicket Handshake Message</span>

   This message is sent by the server during the TLS handshake before
   the ChangeCipherSpec message.  This message MUST be sent if the
   server included a SessionTicket extension in the ServerHello.  This
   message MUST NOT be sent if the server did not include a
   SessionTicket extension in the ServerHello.  In the case of a full
   handshake, the server MUST verify the client's Finished message
   before sending the ticket.  The client MUST NOT treat the ticket as
   valid until it has verified the server's Finished message.  If the
   server determines that it does not want to include a ticket after it
   has included the SessionTicket extension in the ServerHello, then it
   sends a zero-length ticket in the NewSessionTicket handshake message.

   If the server successfully verifies the client's ticket, then it MAY
   renew the ticket by including a NewSessionTicket handshake message
   after the ServerHello in the abbreviated handshake.  The client
   should start using the new ticket as soon as possible after it
   verifies the server's Finished message for new connections.  Note
   that since the updated ticket is issued before the handshake
   completes, it is possible that the client may not put the new ticket
   into use before it initiates new connections.  The server MUST NOT
   assume that the client actually received the updated ticket until it
   successfully verifies the client's Finished message.

   The NewSessionTicket handshake message has been assigned the number 4
   and its definition is given at the end of this section.  The
   ticket_lifetime_hint field contains a hint from the server about how
   long the ticket should be stored.  The value indicates the lifetime
   in seconds as a 32-bit unsigned integer in network byte order.  A
   value of zero is reserved to indicate that the lifetime of the ticket



<span class="grey">Salowey, et al.             Standards Track                     [Page 7]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-8" id="page-8" name="page-8"> </a>
<span class="grey"><a href="rfc4507.html">RFC 4507</a>            Stateless TLS Session Resumption            May 2006</span>


   is unspecified.  A client SHOULD delete the ticket and associated
   state when the time expires.  It MAY delete the ticket earlier based
   on local policy.  A server MAY treat a ticket as valid for a shorter
   or longer period of time than what is stated in the
   ticket_lifetime_hint.

      struct {
          HandshakeType msg_type;
          uint24 length;
          select (HandshakeType) {
              case hello_request:       HelloRequest;
              case client_hello:        ClientHello;
              case server_hello:        ServerHello;
              case certificate:         Certificate;
              case server_key_exchange: ServerKeyExchange;
              case certificate_request: CertificateRequest;
              case server_hello_done:   ServerHelloDone;
              case certificate_verify:  CertificateVerify;
              case client_key_exchange: ClientKeyExchange;
              case finished:            Finished;
              case session_ticket:      NewSessionTicket; /* NEW */
          } body;
      } Handshake;


      struct {
          uint32 ticket_lifetime_hint;
          opaque ticket&lt;0..2^16-1&gt;;
      } NewSessionTicket;

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.4.%20%20Interaction%20with%20TLS%20Session%20ID"></a><a class="selflink" href="#section-3.4" name="section-3.4">3.4</a>.  Interaction with TLS Session ID</span>

   If a server is planning on issuing a SessionTicket to a client that
   does not present one, it SHOULD include an empty Session ID in the
   ServerHello.  If the server includes a non-empty session ID, then it
   is indicating intent to use stateful session resume.  If the client
   receives a SessionTicket from the server, then it discards any
   Session ID that was sent in the ServerHello.

   When presenting a ticket, the client MAY generate and include a
   Session ID in the TLS ClientHello.  If the server accepts the ticket
   and the Session ID is not empty, then it MUST respond with the same
   Session ID present in the ClientHello.  This allows the client to
   easily differentiate when the server is resuming a session from when
   it is falling back to a full handshake.  Since the client generates a
   Session ID, the server MUST NOT rely upon the Session ID having a
   particular value when validating the ticket.  If a ticket is
   presented by the client, the server MUST NOT attempt to use the



<span class="grey">Salowey, et al.             Standards Track                     [Page 8]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-9" id="page-9" name="page-9"> </a>
<span class="grey"><a href="rfc4507.html">RFC 4507</a>            Stateless TLS Session Resumption            May 2006</span>


   Session ID in the ClientHello for stateful session resume.
   Alternatively, the client MAY include an empty Session ID in the
   ClientHello.  In this case, the client ignores the Session ID sent in
   the ServerHello and determines if the server is resuming a session by
   the subsequent handshake messages.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/4.%20%20Recommended%20Ticket%20Construction"></a><a class="selflink" href="#section-4" name="section-4">4</a>.  Recommended Ticket Construction</span>

   This section describes a recommended format and protection for the
   ticket.  Note that the ticket is opaque to the client, so the
   structure is not subject to interoperability concerns, and
   implementations may diverge from this format.  If implementations do
   diverge from this format, they must take security concerns seriously.
   Clients MUST NOT examine the ticket under the assumption that it
   complies with this document.

   The server uses two different keys: one 128-bit key for AES [<a href="#ref-AES" title='"Advanced Encryption Standard (AES)"'>AES</a>] in
   CBC mode [<a href="#ref-CBC" title='"Recommendation for Block Cipher Modes of Operation - Methods and Techniques"'>CBC</a>] encryption and one 128-bit key for HMAC-SHA1 [<a href="rfc2104.html" title='"HMAC: Keyed- Hashing for Message Authentication"'>RFC2104</a>]
   [<a href="#ref-SHA1" title='"Secure Hash Standard (SHS)"'>SHA1</a>].

   The ticket is structured as follows:

      struct {
          opaque key_name[16];
          opaque iv[16];
          opaque encrypted_state&lt;0..2^16-1&gt;;
          opaque mac[20];
      } ticket;

   Here, key_name serves to identify a particular set of keys used to
   protect the ticket.  It enables the server to easily recognize
   tickets it has issued.  The key_name should be randomly generated to
   avoid collisions between servers.  One possibility is to generate new
   random keys and key_name every time the server is started.

   The actual state information in encrypted_state is encrypted using
   128-bit AES in CBC mode with the given IV.  The MAC is calculated
   using HMAC-SHA1 over key_name (16 octets)and IV (16 octets), followed
   by the length of the encrypted_state field (2 octets) and its
   contents (variable length).











<span class="grey">Salowey, et al.             Standards Track                     [Page 9]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-10" id="page-10" name="page-10"> </a>
<span class="grey"><a href="rfc4507.html">RFC 4507</a>            Stateless TLS Session Resumption            May 2006</span>


      struct {
          ProtocolVersion protocol_version;
          CipherSuite cipher_suite;
          CompressionMethod compression_method;
          opaque master_secret[48];
          ClientIdentity client_identity;
          uint32 timestamp;
      } StatePlaintext;

      enum {
         anonymous(0),
         certificate_based(1),
         psk(2)
     } ClientAuthenticationType;

      struct {
          ClientAuthenticationType client_authentication_type;
          select (ClientAuthenticationType) {
              case anonymous: struct {};
              case certificate_based:
                  ASN.1Cert certificate_list&lt;0..2^24-1&gt;;
              case psk:
                  opaque psk_identity&lt;0..2^16-1&gt;; /* from [<a href="rfc4279.html" title='"Pre-Shared Key Ciphersuites for Transport Layer Security (TLS)"'>RFC4279</a>] */

          }
       } ClientIdentity;

   The structure StatePlaintext stores the TLS session state including
   the master_secret.  The timestamp within this structure allows the
   TLS server to expire tickets.  To cover the authentication and key
   exchange protocols provided by TLS, the ClientIdentity structure
   contains the authentication type of the client used in the initial
   exchange (see ClientAuthenticationType).  To offer the TLS server
   with the same capabilities for authentication and authorization, a
   certificate list is included in case of public-key-based
   authentication.  The TLS server is therefore able to inspect a number
   of different attributes within these certificates.  A specific
   implementation might choose to store a subset of this information or
   additional information.  Other authentication mechanisms, such as
   Kerberos [<a href="rfc2712.html" title='"Addition of Kerberos Cipher Suites to Transport Layer Security (TLS)"'>RFC2712</a>], would require different client identity data.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/5.%20%20Security%20Considerations"></a><a class="selflink" href="#section-5" name="section-5">5</a>.  Security Considerations</span>

   This section addresses security issues related to the usage of a
   ticket.  Tickets must be authenticated and encrypted to prevent
   modification or eavesdropping by an attacker.  Several attacks
   described below will be possible if this is not carefully done.




<span class="grey">Salowey, et al.             Standards Track                    [Page 10]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-11" id="page-11" name="page-11"> </a>
<span class="grey"><a href="rfc4507.html">RFC 4507</a>            Stateless TLS Session Resumption            May 2006</span>


   Implementations should take care to ensure that the processing of
   tickets does not increase the chance of denial of service as
   described below.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.1.%20%20Invalidating%20Sessions"></a><a class="selflink" href="#section-5.1" name="section-5.1">5.1</a>.  Invalidating Sessions</span>

   The TLS specification requires that TLS sessions be invalidated when
   errors occur.  [<a href="#ref-CSSC" title='"Client-side caching for TLS"'>CSSC</a>] discusses the security implications of this in
   detail.  In the analysis in this paper, failure to invalidate
   sessions does not pose a security risk.  This is because the TLS
   handshake uses a non-reversible function to derive keys for a session
   so information about one session does not provide an advantage to
   attack the master secret or a different session.  If a session
   invalidation scheme is used, the implementation should verify the
   integrity of the ticket before using the contents to invalidate a
   session to ensure that an attacker cannot invalidate a chosen
   session.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.2.%20%20Stolen%20Tickets"></a><a class="selflink" href="#section-5.2" name="section-5.2">5.2</a>.  Stolen Tickets</span>

   An eavesdropper or man-in-the-middle may obtain the ticket and
   attempt to use the ticket to establish a session with the server;
   however, since the ticket is encrypted and the attacker does not know
   the secret key, a stolen ticket does not help an attacker resume a
   session.  A TLS server MUST use strong encryption and integrity
   protection for the ticket to prevent an attacker from using a brute
   force mechanism to obtain the ticket's contents.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.3.%20%20Forged%20Tickets"></a><a class="selflink" href="#section-5.3" name="section-5.3">5.3</a>.  Forged Tickets</span>

   A malicious user could forge or alter a ticket in order to resume a
   session, to extend its lifetime, to impersonate as another user, or
   to gain additional privileges.  This attack is not possible if the
   ticket is protected using a strong integrity protection algorithm
   such as a keyed HMAC-SHA1.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.4.%20%20Denial%20of%20Service%20Attacks"></a><a class="selflink" href="#section-5.4" name="section-5.4">5.4</a>.  Denial of Service Attacks</span>

   The key_name field defined in the recommended ticket format helps the
   server efficiently reject tickets that it did not issue.  However, an
   adversary could store or generate a large number of tickets to send
   to the TLS server for verification.  To minimize the possibility of a
   denial of service, the verification of the ticket should be
   lightweight (e.g., using efficient symmetric key cryptographic
   algorithms).






<span class="grey">Salowey, et al.             Standards Track                    [Page 11]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-12" id="page-12" name="page-12"> </a>
<span class="grey"><a href="rfc4507.html">RFC 4507</a>            Stateless TLS Session Resumption            May 2006</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.5.%20%20Ticket%20Protection%20Key%20Management"></a><a class="selflink" href="#section-5.5" name="section-5.5">5.5</a>.  Ticket Protection Key Management</span>

   A full description of the management of the keys used to protect the
   ticket is beyond the scope of this document.  A list of RECOMMENDED
   practices is given below.

   o  The keys should be generated securely following the randomness
      recommendations in [<a href="rfc4086.html" title='"Randomness Requirements for Security"'>RFC4086</a>].
   o  The keys and cryptographic protection algorithms should be at
      least 128 bits in strength.
   o  The keys should not be used for any other purpose than generating
      and verifying tickets.
   o  The keys should be changed regularly.
   o  The keys should be changed if the ticket format or cryptographic
      protection algorithms change.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.6.%20%20Ticket%20Lifetime"></a><a class="selflink" href="#section-5.6" name="section-5.6">5.6</a>.  Ticket Lifetime</span>

   The TLS server controls the lifetime of the ticket.  Servers
   determine the acceptable lifetime based on the operational and
   security requirements of the environments in which they are deployed.
   The ticket lifetime may be longer than the 24-hour lifetime
   recommended in [<a href="rfc2246.html" title='"The TLS Protocol Version 1.0"'>RFC2246</a>].  TLS clients may be given a hint of the
   lifetime of the ticket.  Since the lifetime of a ticket may be
   unspecified, a client has its own local policy that determines when
   it discards tickets.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.7.%20%20Alternate%20Ticket%20Formats%20and%20Distribution%20Schemes"></a><a class="selflink" href="#section-5.7" name="section-5.7">5.7</a>.  Alternate Ticket Formats and Distribution Schemes</span>

   If the ticket format or distribution scheme defined in this document
   is not used, then great care must be taken in analyzing the security
   of the solution.  In particular, if confidential information, such as
   a secret key, is transferred to the client, it MUST be done using
   secure communication so as to prevent attackers from obtaining or
   modifying the key.  Also, the ticket MUST have its integrity and
   confidentiality protected with strong cryptographic techniques to
   prevent a breach in the security of the system.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.8.%20%20Identity%20Privacy%2C%20Anonymity%2C%20and%20Unlinkability"></a><a class="selflink" href="#section-5.8" name="section-5.8">5.8</a>.  Identity Privacy, Anonymity, and Unlinkability</span>

   This document mandates that the content of the ticket is
   confidentiality protected in order to avoid leakage of its content,
   such as user-relevant information.  As such, it prevents disclosure
   of potentially sensitive information carried within the ticket.

   The initial handshake exchange, which was used to obtain the ticket,
   might not provide identity confidentiality of the client based on the
   properties of TLS.  Another relevant security threat is the ability



<span class="grey">Salowey, et al.             Standards Track                    [Page 12]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-13" id="page-13" name="page-13"> </a>
<span class="grey"><a href="rfc4507.html">RFC 4507</a>            Stateless TLS Session Resumption            May 2006</span>


   for an on-path adversary to observe multiple TLS handshakes where the
   same ticket is used and therefore to conclude that they belong to the
   same communication endpoints.  Application designers that use the
   ticket mechanism described in this document should consider that
   unlinkability [<a href="#ref-ANON" title='"Anonymity, Unlinkability, Unobservability, Pseudonymity, and Identity Management - A Consolidated Proposal for Terminology"'>ANON</a>] is not necessarily provided.

   While a full discussion of these topics is beyond the scope of this
   document, it should be noted that it is possible to issue a ticket
   using a TLS renegotiation handshake that occurs after a secure tunnel
   has been established by a previous handshake.  This may help address
   some privacy and unlinkability issues in some environments.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/6.%20%20Acknowledgements"></a><a class="selflink" href="#section-6" name="section-6">6</a>.  Acknowledgements</span>

   The authors would like to thank the following people for their help
   with preparing and reviewing this document: Eric Rescorla, Mohamad
   Badra, Tim Dierks, Nelson Bolyard, Nancy Cam-Winget, David McGrew,
   Rob Dugal, Russ Housley, Amir Herzberg, Bernard Aboba, and members of
   the TLS working group.

   [<a id="ref-CSSC" name="ref-CSSC">CSSC</a>] describes a solution that is very similar to the one described
   in this document and gives a detailed analysis of the security
   considerations involved.  [<a href="rfc2712.html" title='"Addition of Kerberos Cipher Suites to Transport Layer Security (TLS)"'>RFC2712</a>] describes a mechanism for using
   Kerberos [<a href="rfc4120.html" title='"The Kerberos Network Authentication Service (V5)"'>RFC4120</a>] in TLS ciphersuites, which helped inspire the use
   of tickets to avoid server state.  [<a href="#ref-EAP-FAST" title='"EAP Flexible Authentication via Secure Tunneling (EAP- FAST)"'>EAP-FAST</a>] makes use of a similar
   mechanism to avoid maintaining server state for the cryptographic
   tunnel.  [<a href="#ref-SC97" title='"Stateless Connections"'>SC97</a>] also investigates the concept of stateless sessions.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/7.%20%20IANA%20Considerations"></a><a class="selflink" href="#section-7" name="section-7">7</a>.  IANA Considerations</span>

   IANA has assigned a TLS extension number of 35 to the SessionTicket
   TLS extension from the TLS registry of ExtensionType values defined
   in [<a href="rfc4366.html" title='"Transport Layer Security (TLS) Extensions"'>RFC4366</a>].

   IANA has assigned a TLS HandshakeType number 4 to the
   NewSessionTicket handshake type from the TLS registry of
   HandshakeType values defined in [<a href="rfc4346.html" title='"The Transport Layer Security (TLS) Protocol Version 1.1"'>RFC4346</a>].














<span class="grey">Salowey, et al.             Standards Track                    [Page 13]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-14" id="page-14" name="page-14"> </a>
<span class="grey"><a href="rfc4507.html">RFC 4507</a>            Stateless TLS Session Resumption            May 2006</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/8.%20%20References"></a><a class="selflink" href="#section-8" name="section-8">8</a>.  References</span>

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/8.1.%20%20Normative%20References"></a><a class="selflink" href="#section-8.1" name="section-8.1">8.1</a>.  Normative References</span>

   [<a id="ref-RFC2119" name="ref-RFC2119">RFC2119</a>]   Bradner, S., "Key words for use in RFCs to Indicate
               Requirement Levels", <a href="https://tools.ietf.org/html/bcp14">BCP 14</a>, <a href="rfc2119.html">RFC 2119</a>, March 1997.

   [<a id="ref-RFC2246" name="ref-RFC2246">RFC2246</a>]   Dierks, T. and C. Allen, "The TLS Protocol Version 1.0",
               <a href="rfc2246.html">RFC 2246</a>, January 1999.

   [<a id="ref-RFC4346" name="ref-RFC4346">RFC4346</a>]   Dierks, T. and E. Rescorla, "The Transport Layer Security
               (TLS) Protocol Version 1.1", <a href="rfc4346.html">RFC 4346</a>, April 2006.

   [<a id="ref-RFC4366" name="ref-RFC4366">RFC4366</a>]   Blake-Wilson, S., Nystrom, M., Hopwood, D., Mikkelsen,
               J., and T. Wright, "Transport Layer Security (TLS)
               Extensions", <a href="rfc4366.html">RFC 4366</a>, April 2006.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/8.2.%20%20Informative%20References"></a><a class="selflink" href="#section-8.2" name="section-8.2">8.2</a>.  Informative References</span>

   [<a id="ref-AES" name="ref-AES">AES</a>]       National Institute of Standards and Technology, "Advanced
               Encryption Standard (AES)", Federal Information
               Processing Standards (FIPS) Publication 197,
               November 2001.

   [<a id="ref-ANON" name="ref-ANON">ANON</a>]      Pfitzmann, A. and M. Hansen, "Anonymity, Unlinkability,
               Unobservability, Pseudonymity, and Identity Management -
               A Consolidated Proposal for Terminology",
               <a href="http://dud.inf.tu-dresden.de/literatur/Anon_Terminology_v0.26-1.pdf">http://dud.inf.tu-dresden.de/literatur/</a>
               <a href="http://dud.inf.tu-dresden.de/literatur/Anon_Terminology_v0.26-1.pdf">Anon_Terminology_v0.26-1.pdf</a>, Draft 0.26, December 2005.

   [<a id="ref-CBC" name="ref-CBC">CBC</a>]       National Institute of Standards and Technology,
               "Recommendation for Block Cipher Modes of Operation -
               Methods and Techniques", NIST Special Publication 800-
               38A, December 2001.

   [<a id="ref-CSSC" name="ref-CSSC">CSSC</a>]      Shacham, H., Boneh, D., and E. Rescorla, "Client-side
               caching for TLS", Transactions on Information and System
               Security (TISSEC) , Volume 7, Issue 4, November 2004.

   [<a id="ref-EAP-FAST" name="ref-EAP-FAST">EAP-FAST</a>]  Cam-Winget, N., McGrew, D., Salowey, J., and H. Zhou,
               "EAP Flexible Authentication via Secure Tunneling (EAP-
               FAST)", Work in Progress, April 2005.

   [<a id="ref-RFC2104" name="ref-RFC2104">RFC2104</a>]   Krawczyk, H., Bellare, M., and R. Canetti, "HMAC: Keyed-
               Hashing for Message Authentication", <a href="rfc2104.html">RFC 2104</a>,
               February 1997.





<span class="grey">Salowey, et al.             Standards Track                    [Page 14]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-15" id="page-15" name="page-15"> </a>
<span class="grey"><a href="rfc4507.html">RFC 4507</a>            Stateless TLS Session Resumption            May 2006</span>


   [<a id="ref-RFC2712" name="ref-RFC2712">RFC2712</a>]   Medvinsky, A. and M. Hur, "Addition of Kerberos Cipher
               Suites to Transport Layer Security (TLS)", <a href="rfc2712.html">RFC 2712</a>,
               October 1999.

   [<a id="ref-RFC4086" name="ref-RFC4086">RFC4086</a>]   Eastlake, D., Schiller, J., and S. Crocker, "Randomness
               Requirements for Security", <a href="https://tools.ietf.org/html/bcp106">BCP 106</a>, <a href="rfc4086.html">RFC 4086</a>, June 2005.

   [<a id="ref-RFC4120" name="ref-RFC4120">RFC4120</a>]   Neuman, C., Yu, T., Hartman, S., and K. Raeburn, "The
               Kerberos Network Authentication Service (V5)", <a href="rfc4120.html">RFC 4120</a>,
               July 2005.

   [<a id="ref-RFC4279" name="ref-RFC4279">RFC4279</a>]   Eronen, P. and H. Tschofenig, "Pre-Shared Key
               Ciphersuites for Transport Layer Security (TLS)",
               <a href="rfc4279.html">RFC 4279</a>, December 2005.

   [<a id="ref-SC97" name="ref-SC97">SC97</a>]      Aura, T. and P. Nikander, "Stateless Connections",
               Proceedings of the First International Conference on
               Information and Communication Security (ICICS '97), 1997.

   [<a id="ref-SHA1" name="ref-SHA1">SHA1</a>]      National Institute of Standards and Technology, "Secure
               Hash Standard (SHS)", Federal Information Processing
               Standards (FIPS) Publication 180-2, August 2002.





























<span class="grey">Salowey, et al.             Standards Track                    [Page 15]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-16" id="page-16" name="page-16"> </a>
<span class="grey"><a href="rfc4507.html">RFC 4507</a>            Stateless TLS Session Resumption            May 2006</span>


Authors' Addresses

   Joseph Salowey
   Cisco Systems
   2901 3rd Ave
   Seattle, WA  98121
   US

   EMail: jsalowey@cisco.com


   Hao Zhou
   Cisco Systems
   4125 Highlander Parkway
   Richfield, OH  44286
   US

   EMail: hzhou@cisco.com


   Pasi Eronen
   Nokia Research Center
   P.O. Box 407
   FIN-00045 Nokia Group
   Finland

   EMail: pasi.eronen@nokia.com


   Hannes Tschofenig
   Siemens
   Otto-Hahn-Ring 6
   Munich, Bayern  81739
   Germany

   EMail: Hannes.Tschofenig@siemens.com















<span class="grey">Salowey, et al.             Standards Track                    [Page 16]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-17" id="page-17" name="page-17"> </a>
<span class="grey"><a href="rfc4507.html">RFC 4507</a>            Stateless TLS Session Resumption            May 2006</span>


Full Copyright Statement

   Copyright (C) The Internet Society (2006).

   This document is subject to the rights, licenses and restrictions
   contained in <a href="https://tools.ietf.org/html/bcp78">BCP 78</a>, and except as set forth therein, the authors
   retain all their rights.

   This document and the information contained herein are provided on an
   "AS IS" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS
   OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET
   ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED,
   INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE
   INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED
   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.

Intellectual Property

   The IETF takes no position regarding the validity or scope of any
   Intellectual Property Rights or other rights that might be claimed to
   pertain to the implementation or use of the technology described in
   this document or the extent to which any license under such rights
   might or might not be available; nor does it represent that it has
   made any independent effort to identify any such rights.  Information
   on the procedures with respect to rights in RFC documents can be
   found in <a href="https://tools.ietf.org/html/bcp78">BCP 78</a> and <a href="https://tools.ietf.org/html/bcp79">BCP 79</a>.

   Copies of IPR disclosures made to the IETF Secretariat and any
   assurances of licenses to be made available, or the result of an
   attempt made to obtain a general license or permission for the use of
   such proprietary rights by implementers or users of this
   specification can be obtained from the IETF on-line IPR repository at
   <a href="http://www.ietf.org/ipr">http://www.ietf.org/ipr</a>.

   The IETF invites any interested party to bring to its attention any
   copyrights, patents or patent applications, or other proprietary
   rights that may cover technology that may be required to implement
   this standard.  Please address the information to the IETF at
   ietf-ipr@ietf.org.

Acknowledgement

   Funding for the RFC Editor function is provided by the IETF
   Administrative Support Activity (IASA).







Salowey, et al.             Standards Track                    [Page 17]

</pre><br/>
    <span class="noprint"><small><small>Html markup produced by rfcmarkup 1.126, available from
      <a href="https://tools.ietf.org/tools/rfcmarkup/">https://tools.ietf.org/tools/rfcmarkup/</a>
    </small></small></span>
  </div>




</body><!-- Mirrored from tools.ietf.org/html/rfc4507 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 06 Mar 2018 23:18:40 GMT --></html>