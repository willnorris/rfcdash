<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml"><!-- Mirrored from tools.ietf.org/html/rfc5047 by HTTrack Website Copier/3.x [XR&CO'2013], Tue, 23 Aug 2016 18:42:54 GMT --><!-- Added by HTTrack --><head><meta content="text/html;charset=utf-8" http-equiv="content-type"/><!-- /Added by HTTrack -->

    <meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
    <meta content="index,follow" name="robots"/>
    <meta content="rfcmarkup version 1.119" name="creator"/>
    <link href="http://purl.org/dc/elements/1.1/" rel="schema.DC"/>
<meta content="urn:ietf:rfc:5047" name="DC.Identifier"/>
<meta content="The Internet Small Computer System Interface (iSCSI) is a SCSI
transport protocol that maps the SCSI family of application protocols
onto TCP/IP. Datamover Architecture for iSCSI (DA) defines an abstract
model in which the movement of data between iSCSI end nodes is
logically separated from the rest of the iSCSI protocol in order to
allow iSCSI to adapt to innovations available in new IP transports.
While DA defines the architectural functions required of the class of
Datamover protocols, it does not define any specific Datamover
protocols. Each such Datamover protocol, defined in a separate
document, provides a reliable transport for all iSCSI PDUs, but
actually moves the data required for certain iSCSI PDUs without
involving the remote iSCSI layer itself. This document begins with an
introduction of a few new abstractions, defines a layered architecture
for iSCSI and Datamover protocols, and then models the interactions
within an iSCSI end node between the iSCSI layer and the Datamover
layer that happen in order to transparently perform remote data
movement within an IP fabric. It is intended that this definition will
help map iSCSI to generic Remote Direct Memory Access (RDMA)-capable
IP fabrics in the future comprising TCP, the Stream Control
Transmission Protocol (SCTP), and possibly other underlying network
transport layers, such as InfiniBand. This memo provides information
for the Internet community." name="DC.Description.Abstract"/>
<meta content="Hufferd, John L." name="DC.Creator"/>
<meta content="Chadalapaka, Mallikarjun" name="DC.Creator"/>
<meta content="Shah, Hemal" name="DC.Creator"/>
<meta content="Satran, Julian" name="DC.Creator"/>
<meta content="October, 2007" name="DC.Date.Issued"/>
<meta content="DA: Datamover Architecture for the Internet Small Computer System Interface (iSCSI)" name="DC.Title"/>

    <link href="https://tools.ietf.org/images/rfc.png" rel="icon" type="image/png"/>
    <link href="https://tools.ietf.org/images/rfc.png" rel="shortcut icon" type="image/png"/>
    <title>RFC 5047 - DA: Datamover Architecture for the Internet Small Computer System Interface (iSCSI)</title>
    
    
    <style type="text/css">
	@media only screen 
	  and (min-width: 992px)
	  and (max-width: 1199px) {
	    body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 768px)
	  and (max-width: 991px) {
            body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 480px)
	  and (max-width: 767px) {
            body { font-size: 11pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (max-width: 479px) {
            body { font-size: 8pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-device-width : 375px) 
	  and (max-device-width : 667px) {
            body { font-size: 9.5pt; }
            div.content { width: 96ex; margin: 0 1px; }
        }
	@media only screen 
	  and (min-device-width: 1200px) {
            body { font-size: 10pt; margin: 0 4em; }
            div.content { width: 96ex; margin: 0; }
        }
        h1, h2, h3, h4, h5, h6, .h1, .h2, .h3, .h4, .h5, .h6 {
	    font-weight: bold;
            line-height: 0pt;
            display: inline;
            white-space: pre;
            font-family: monospace;
            font-size: 1em;
	    font-weight: bold;
        }
        pre {
            font-size: 1em;
            margin-top: 0px;
            margin-bottom: 0px;
        }
	.pre {
	    white-space: pre;
	    font-family: monospace;
	}
	.header{
	    font-weight: bold;
	}
        .newpage {
            page-break-before: always;
        }
        .invisible {
            text-decoration: none;
            color: white;
        }
        a.selflink {
          color: black;
          text-decoration: none;
        }
        @media print {
            body {
                font-family: monospace;
                font-size: 10.5pt;
            }
            h1, h2, h3, h4, h5, h6 {
                font-size: 1em;
            }
        
            a:link, a:visited {
                color: inherit;
                text-decoration: none;
            }
            .noprint {
                display: none;
            }
        }
	@media screen {
	    .grey, .grey a:link, .grey a:visited {
		color: #777;
	    }
            .docinfo {
                background-color: #EEE;
            }
            .top {
                border-top: 7px solid #EEE;
            }
            .bgwhite  { background-color: white; }
            .bgred    { background-color: #F44; }
            .bggrey   { background-color: #666; }
            .bgbrown  { background-color: #840; }            
            .bgorange { background-color: #FA0; }
            .bgyellow { background-color: #EE0; }
            .bgmagenta{ background-color: #F4F; }
            .bgblue   { background-color: #66F; }
            .bgcyan   { background-color: #4DD; }
            .bggreen  { background-color: #4F4; }

            .legend   { font-size: 90%; }
            .cplate   { font-size: 70%; border: solid grey 1px; }
	}
    </style>
    <!--[if IE]>
    <style>
    body {
       font-size: 13px;
       margin: 10px 10px;
    }
    </style>
    <![endif]-->

    <script type="text/javascript"><!--
    function addHeaderTags() {
	var spans = document.getElementsByTagName("span");
	for (var i=0; i < spans.length; i++) {
	    var elem = spans[i];
	    if (elem) {
		var level = elem.getAttribute("class");
                if (level == "h1" || level == "h2" || level == "h3" || level == "h4" || level == "h5" || level == "h6") {
                    elem.innerHTML = "<"+level+">"+elem.innerHTML+"</"+level+">";		
                }
	    }
	}
    }
    var legend_html = "Colour legend:<br />      <table>         <tr><td>Unknown:</td>                   <td><span class='cplate bgwhite'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft:</td>                     <td><span class='cplate bgred'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Informational:</td>             <td><span class='cplate bgorange'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Experimental:</td>              <td><span class='cplate bgyellow'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Best Common Practice:</td>      <td><span class='cplate bgmagenta'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Proposed Standard:</td>         <td><span class='cplate bgblue'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft Standard (old designation):</td> <td><span class='cplate bgcyan'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Internet Standard:</td>         <td><span class='cplate bggreen'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Historic:</td>                  <td><span class='cplate bggrey'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Obsolete:</td>                  <td><span class='cplate bgbrown'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>     </table>";
    function showElem(id) {
        var elem = document.getElementById(id);
        elem.innerHTML = eval(id+"_html");
        elem.style.visibility='visible';
    }
    function hideElem(id) {
        var elem = document.getElementById(id);
        elem.style.visibility='hidden';        
        elem.innerHTML = "";
    }
    // -->
    </script>
</head>
<body onload="addHeaderTags()">
  <div class="content">
   <div style="height: 13px;">
      <div class="pre noprint docinfo bgorange" onclick="showElem('legend');" onmouseout="hideElem('legend')" onmouseover="this.style.cursor='pointer';" style="height: 6px; position: absolute;" title="Click for colour legend.">                                                                        </div>
      <div class="docinfo noprint pre legend" id="legend" onmouseout="hideElem('legend');" onmouseover="showElem('legend');" style="position:absolute; top: 4px; left: 4ex; visibility:hidden; background-color: white; padding: 4px 9px 5px 7px; border: solid #345 1px; ">
      </div>
   </div>
<span class="pre noprint docinfo top">[<a href="index.html" title="Document search and retrieval page">Docs</a>] [<a href="https://tools.ietf.org/rfc/rfc5047.txt" title="Plaintext version of this document">txt</a>|<a href="https://tools.ietf.org/pdf/rfc5047" title="PDF version of this document">pdf</a>] [<a href="https://tools.ietf.org/html/draft-ietf-ips-iwarp-da" title="draft-ietf-ips-iwarp-da">draft-ietf-ips-iw...</a>] [<a href="https://tools.ietf.org/rfcdiff?difftype=--hwdiff&amp;url2=rfc5047" title="Inline diff (wdiff)">Diff1</a>] [<a href="https://tools.ietf.org/rfcdiff?url2=rfc5047" title="Side-by-side diff">Diff2</a>]                 </span><br/>
<span class="pre noprint docinfo">                                                                        </span><br/>
<span class="pre noprint docinfo">Updated by: <a href="rfc7146.html">7146</a>                                           INFORMATIONAL</span><br/>
<span class="pre noprint docinfo">                                                                        </span><br/>
<pre>Network Working Group                                     M. Chadalapaka
Request for Comments: 5047                                            HP
Category: Informational                                       J. Hufferd
                                                            Brocade Inc.
                                                               J. Satran
                                                                     IBM
                                                                 H. Shah
                                                    Broadcom Corporation
                                                            October 2007


                    <span class="h1">DA: Datamover Architecture for</span>
         <span class="h1">the Internet Small Computer System Interface (iSCSI)</span>

Status of This Memo

   This memo provides information for the Internet community.  It does
   not specify an Internet standard of any kind.  Distribution of this
   memo is unlimited.

Abstract

   The Internet Small Computer System Interface (iSCSI) is a SCSI
   transport protocol that maps the SCSI family of application protocols
   onto TCP/IP.  Datamover Architecture for iSCSI (DA) defines an
   abstract model in which the movement of data between iSCSI end nodes
   is logically separated from the rest of the iSCSI protocol in order
   to allow iSCSI to adapt to innovations available in new IP
   transports.  While DA defines the architectural functions required of
   the class of Datamover protocols, it does not define any specific
   Datamover protocols.  Each such Datamover protocol, defined in a
   separate document, provides a reliable transport for all iSCSI PDUs,
   but actually moves the data required for certain iSCSI PDUs without
   involving the remote iSCSI layer itself.  This document begins with
   an introduction of a few new abstractions, defines a layered
   architecture for iSCSI and Datamover protocols, and then models the
   interactions within an iSCSI end node between the iSCSI layer and the
   Datamover layer that happen in order to transparently perform remote
   data movement within an IP fabric.  It is intended that this
   definition will help map iSCSI to generic Remote Direct Memory Access
   (RDMA)-capable IP fabrics in the future comprising TCP, the Stream
   Control Transmission Protocol (SCTP), and possibly other underlying
   network transport layers, such as InfiniBand.








<span class="grey">Chadalapaka, et al.          Informational                      [Page 1]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-2" id="page-2" name="page-2"> </a>
<span class="grey"><a href="rfc5047.html">RFC 5047</a>                           DA                       October 2007</span>


Table of Contents

   <a href="#section-1">1</a>. Motivation ......................................................<a href="#page-4">4</a>
      <a href="#section-1.1">1.1</a>. Intent .....................................................<a href="#page-4">4</a>
      <a href="#section-1.2">1.2</a>. Interpretation of Requirements .............................<a href="#page-5">5</a>
   <a href="#section-2">2</a>. Definitions and Acronyms ........................................<a href="#page-5">5</a>
      <a href="#section-2.1">2.1</a>. Definitions ................................................<a href="#page-5">5</a>
      <a href="#section-2.2">2.2</a>. Acronyms ...................................................<a href="#page-6">6</a>
   <a href="#section-3">3</a>. Architectural Layering of iSCSI and Datamover Layers ............<a href="#page-7">7</a>
   <a href="#section-4">4</a>. Design Overview .................................................<a href="#page-9">9</a>
   <a href="#section-5">5</a>. Architectural Concepts .........................................<a href="#page-10">10</a>
      <a href="#section-5.1">5.1</a>. iSCSI PDU Types ...........................................<a href="#page-10">10</a>
           <a href="#section-5.1.1">5.1.1</a>. iSCSI Data-Type PDUs ...............................<a href="#page-10">10</a>
           <a href="#section-5.1.2">5.1.2</a>. iSCSI Control-Type PDUs ............................<a href="#page-11">11</a>
      <a href="#section-5.2">5.2</a>. Data_Descriptor ...........................................<a href="#page-11">11</a>
      <a href="#section-5.3">5.3</a>. Connection_Handle .........................................<a href="#page-11">11</a>
      <a href="#section-5.4">5.4</a>. Operational Primitive .....................................<a href="#page-12">12</a>
      <a href="#section-5.5">5.5</a>. Transport Connection ......................................<a href="#page-13">13</a>
   <a href="#section-6">6</a>. Datamover Layer and Datamover Protocol .........................<a href="#page-13">13</a>
   <a href="#section-7">7</a>. Functional Overview ............................................<a href="#page-14">14</a>
      <a href="#section-7.1">7.1</a>. Startup ...................................................<a href="#page-14">14</a>
      <a href="#section-7.2">7.2</a>. Full Feature Phase ........................................<a href="#page-15">15</a>
      <a href="#section-7.3">7.3</a>. Wrap-up ...................................................<a href="#page-15">15</a>
   <a href="#section-8">8</a>. Operational Primitives Provided by the Datamover Layer .........<a href="#page-16">16</a>
      <a href="#section-8.1">8.1</a>. Send_Control ..............................................<a href="#page-16">16</a>
      <a href="#section-8.2">8.2</a>. Put_Data ..................................................<a href="#page-17">17</a>
      <a href="#section-8.3">8.3</a>. Get_Data ..................................................<a href="#page-17">17</a>
      <a href="#section-8.4">8.4</a>. Allocate_Connection_Resources .............................<a href="#page-18">18</a>
      <a href="#section-8.5">8.5</a>. Deallocate_Connection_Resources ...........................<a href="#page-19">19</a>
      <a href="#section-8.6">8.6</a>. Enable_Datamover ..........................................<a href="#page-19">19</a>
      <a href="#section-8.7">8.7</a>. Connection_Terminate ......................................<a href="#page-20">20</a>
      <a href="#section-8.8">8.8</a>. Notice_Key_Values .........................................<a href="#page-20">20</a>
      <a href="#section-8.9">8.9</a>. Deallocate_Task_Resources .................................<a href="#page-20">20</a>
   <a href="#section-9">9</a>. Operational Primitives Provided by the iSCSI Layer .............<a href="#page-21">21</a>
      <a href="#section-9.1">9.1</a>. Control_Notify ............................................<a href="#page-21">21</a>
      <a href="#section-9.2">9.2</a>. Connection_Terminate_Notify ...............................<a href="#page-22">22</a>
      <a href="#section-9.3">9.3</a>. Data_Completion_Notify ....................................<a href="#page-22">22</a>
      <a href="#section-9.4">9.4</a>. Data_ACK_Notify ...........................................<a href="#page-23">23</a>
   <a href="#section-10">10</a>. Datamover Interface (DI) ......................................<a href="#page-23">23</a>
      <a href="#section-10.1">10.1</a>. Overview .................................................<a href="#page-23">23</a>
      <a href="#section-10.2">10.2</a>. Interactions for Handling Asynchronous Notifications .....<a href="#page-24">24</a>
           <a href="#section-10.2.1">10.2.1</a>. Connection Termination ............................<a href="#page-24">24</a>
           <a href="#section-10.2.2">10.2.2</a>. Data Transfer Completion ..........................<a href="#page-24">24</a>
           <a href="#section-10.2.3">10.2.3</a>. Data Acknowledgement ..............................<a href="#page-25">25</a>
      <a href="#section-10.3">10.3</a>. Interactions for Sending an iSCSI PDU ....................<a href="#page-25">25</a>
           <a href="#section-10.3.1">10.3.1</a>. SCSI Command ......................................<a href="#page-26">26</a>
           <a href="#section-10.3.2">10.3.2</a>. SCSI Response .....................................<a href="#page-26">26</a>
           <a href="#section-10.3.3">10.3.3</a>. Task Management Function Request ..................<a href="#page-26">26</a>



<span class="grey">Chadalapaka, et al.          Informational                      [Page 2]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-3" id="page-3" name="page-3"> </a>
<span class="grey"><a href="rfc5047.html">RFC 5047</a>                           DA                       October 2007</span>


           <a href="#section-10.3.4">10.3.4</a>. Task Management Function Response .................<a href="#page-27">27</a>
           <a href="#section-10.3.5">10.3.5</a>. SCSI Data-Out and SCSI Data-In ....................<a href="#page-27">27</a>
           <a href="#section-10.3.6">10.3.6</a>. Ready To Transfer (R2T) ...........................<a href="#page-28">28</a>
           <a href="#section-10.3.7">10.3.7</a>. Asynchronous Message ..............................<a href="#page-28">28</a>
           <a href="#section-10.3.8">10.3.8</a>. Text Request ......................................<a href="#page-28">28</a>
           <a href="#section-10.3.9">10.3.9</a>. Text Response .....................................<a href="#page-28">28</a>
           <a href="#section-10.3.10">10.3.10</a>. Login Request ....................................<a href="#page-29">29</a>
           <a href="#section-10.3.11">10.3.11</a>. Login Response ...................................<a href="#page-29">29</a>
           <a href="#section-10.3.12">10.3.12</a>. Logout Command ...................................<a href="#page-29">29</a>
           <a href="#section-10.3.13">10.3.13</a>. Logout Response ..................................<a href="#page-30">30</a>
           <a href="#section-10.3.14">10.3.14</a>. SNACK Request ....................................<a href="#page-30">30</a>
           <a href="#section-10.3.15">10.3.15</a>. Reject ...........................................<a href="#page-30">30</a>
           <a href="#section-10.3.16">10.3.16</a>. NOP-Out ..........................................<a href="#page-30">30</a>
           <a href="#section-10.3.17">10.3.17</a>. NOP-In ...........................................<a href="#page-30">30</a>
      <a href="#section-10.4">10.4</a>. Interactions for Receiving an iSCSI PDU ..................<a href="#page-31">31</a>
           <a href="#section-10.4.1">10.4.1</a>. General Control-Type PDU Notification .............<a href="#page-31">31</a>
           <a href="#section-10.4.2">10.4.2</a>. SCSI Data Transfer PDUs ...........................<a href="#page-31">31</a>
           <a href="#section-10.4.3">10.4.3</a>. Login Request .....................................<a href="#page-32">32</a>
           <a href="#section-10.4.4">10.4.4</a>. Login Response ....................................<a href="#page-32">32</a>
   <a href="#section-11">11</a>. Security Considerations .......................................<a href="#page-33">33</a>
      <a href="#section-11.1">11.1</a>. Architectural Considerations .............................<a href="#page-33">33</a>
      <a href="#section-11.2">11.2</a>. Wire Protocol Considerations .............................<a href="#page-33">33</a>
   <a href="#section-12">12</a>. References ....................................................<a href="#page-34">34</a>
      <a href="#section-12.1">12.1</a>. Normative References .....................................<a href="#page-34">34</a>
      <a href="#section-12.2">12.2</a>. Informative References ...................................<a href="#page-34">34</a>
   <a href="#appendix-A">Appendix A</a>. Design Considerations and Examples ....................<a href="#page-35">35</a>
      <a href="#appendix-A.1">A.1</a>. Design Considerations for a Datamover Protocol ............<a href="#page-35">35</a>
      <a href="#appendix-A.2">A.2</a>. Examples of Datamover Interactions ........................<a href="#page-35">35</a>
   Acknowledgements ..................................................<a href="#page-44">44</a>

Table of Figures

   Figure 1. Datamover Architecture Diagram, with the RDMAP Example ...<a href="#page-8">8</a>
   Figure 2. A Successful iSCSI Login on Initiator ...................<a href="#page-37">37</a>
   Figure 3. A Successful iSCSI Login on Target ......................<a href="#page-37">37</a>
   Figure 4. A Failed iSCSI Login on Initiator .......................<a href="#page-38">38</a>
   Figure 5. A Failed iSCSI Login on Target ..........................<a href="#page-38">38</a>
   Figure 6. iSCSI Does Not Enable the Datamover .....................<a href="#page-39">39</a>
   Figure 7. A Normal iSCSI Connection Termination ...................<a href="#page-40">40</a>
   Figure 8. An Abnormal iSCSI Connection Termination ................<a href="#page-40">40</a>
   Figure 9. A SCSI Write Data Transfer ..............................<a href="#page-41">41</a>
   Figure 10. A SCSI Read Data Transfer ..............................<a href="#page-42">42</a>
   Figure 11. A SCSI Read Data Acknowledgement .......................<a href="#page-43">43</a>
   Figure 12. Task Resource Cleanup on Abort .........................<a href="#page-44">44</a>







<span class="grey">Chadalapaka, et al.          Informational                      [Page 3]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-4" id="page-4" name="page-4"> </a>
<span class="grey"><a href="rfc5047.html">RFC 5047</a>                           DA                       October 2007</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/1.%20%20Motivation"></a><a class="selflink" href="#section-1" name="section-1">1</a>.  Motivation</span>

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/1.1.%20%20Intent"></a><a class="selflink" href="#section-1.1" name="section-1.1">1.1</a>.  Intent</span>

   There are relatively new standard protocols that enable Remote Direct
   Memory Access (RDMA) and Remote Direct Data Placement (RDDP)
   technologies to work over IP fabrics.  The principal value
   proposition of these technologies is that they enable one end node to
   place data in the final intended buffer on the remote end node, thus
   eliminating the need for a receive path data copy that moves the data
   to its final location.  The data copy avoidance in turn eliminates
   unnecessary memory bandwidth consumption, substantially decreases the
   reassembly buffer size requirements, and preserves CPU cycles that
   would otherwise be spent in copying.

   The iSCSI specification [<a href="rfc3720.html" title='"Internet Small Computer Systems Interface (iSCSI)"'>RFC3720</a>] defines a very detailed data
   transfer model that employs SCSI Data-In PDUs, SCSI Data-Out PDUs,
   and R2T PDUs, in addition to the SCSI Command and SCSI Response PDUs
   that respectively create and conclude the task context for the data
   transfer.  In the traditional iSCSI model, the iSCSI protocol layer
   plays the central role in pacing the data transfer and carrying out
   the ensuing data transfer itself.  An alternative architecture would
   be for iSCSI to delegate a large part of this data transfer role to a
   separate protocol layer exclusively designed to move data, which in
   turn is possibly aided by a data movement and placement technology
   such as RDMA.

   If iSCSI were operating in such RDMA environments, iSCSI would be
   shielded from the low-level data transfer mechanics but would only be
   privy to the conclusion of the requested data transfer.  Thus, there
   would be an effective "off-loading" of the work that an iSCSI
   protocol layer is expected to perform, compared to today's iSCSI end
   nodes.  For such RDMA environments, it is highly desirable that there
   be a standard architecture to separate the data movement part of the
   iSCSI protocol definition from the rest of the iSCSI functionality.
   This architecture precisely defines what a Datamover layer is and
   also describes the model of interactions between the iSCSI layer and
   the Datamover layer (<a href="#section-6">Section 6</a>).  In order to satisfy this need, this
   document presents a Datamover Architecture for iSCSI (DA) and
   summarizes a reasonable model for interactions between the iSCSI
   layer and the Datamover layer for each of the iSCSI PDUs that are
   defined in [<a href="rfc3720.html" title='"Internet Small Computer Systems Interface (iSCSI)"'>RFC3720</a>].  Note that while DA is motivated by the advent
   of RDMA over TCP/IP technology, the architecture is not dependent on
   RDMA in its design.  DA is intended to be a generic architectural
   framework for allowing different types of Datamovers based on
   different types of RDMA and transport protocols.  Adoption of this
   model will help iSCSI proliferate into more environments.




<span class="grey">Chadalapaka, et al.          Informational                      [Page 4]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-5" id="page-5" name="page-5"> </a>
<span class="grey"><a href="rfc5047.html">RFC 5047</a>                           DA                       October 2007</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/1.2.%20%20Interpretation%20of%20Requirements"></a><a class="selflink" href="#section-1.2" name="section-1.2">1.2</a>.  Interpretation of Requirements</span>

   This document introduces certain architectural abstractions and
   builds an abstract functional interface model between iSCSI and
   Datamover protocol layers based on those abstractions.  This
   architectural style is motivated by the following desires:

      a) Provide guidance to Datamover protocol designers with respect
         to the functional boundary between iSCSI and the Datamover
         protocols.  This guidance is critical since a significant part
         of the [<a href="rfc3720.html" title='"Internet Small Computer Systems Interface (iSCSI)"'>RFC3720</a>] protocol definition is left unchanged by DA
         architecture and the iSCSI notions from [<a href="rfc3720.html" title='"Internet Small Computer Systems Interface (iSCSI)"'>RFC3720</a>] (e.g., tasks,
         ITTs) are leveraged by the Datamover protocol.

      b) Aid existing iSCSI implementations to rapidly adapt to DA
         architecture, largely by leveraging the architectural
         abstractions into implementation constructs -- e.g., functions,
         APIs, modules.

   However, note that DA architecture does not intend to impose any
   implementation specifics per se.  When a DA architectural concept
   (e.g., Operational Primitive) is described as mandatory ("MUST") or
   recommended ("SHOULD") of a layer (iSCSI or Datamover) in this
   document, the intent is that an implementation respectively MUST or
   SHOULD produce the same protocol action as what the model describes.
   Specifically, no implementation compliance in terms of names, modules
   or API arguments etc. is implied by this Architecture by such use of
   [<a href="rfc2119.html" title='"Key words for use in RFCs to Indicate Requirement Levels"'>RFC2119</a>] terms, only a functional compliance is sought.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/2.%20%20Definitions%20and%20Acronyms"></a><a class="selflink" href="#section-2" name="section-2">2</a>.  Definitions and Acronyms</span>

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/2.1.%20%20Definitions"></a><a class="selflink" href="#section-2.1" name="section-2.1">2.1</a>.  Definitions</span>

   I/O Buffer - A buffer that is used in a SCSI Read or Write operation
      so that SCSI data may be sent from or received by the buffer.

   Datamover protocol  - A Datamover protocol is a data transfer wire
      protocol for iSCSI that meets the requirements stated in <a href="#section-6">Section</a>
      <a href="#section-6">6</a>.

   Datamover layer - A Datamover layer is a protocol layer within an end
      node that implements the Datamover protocol.

   Datamover-assisted - An iSCSI connection is said to be "Datamover-
      assisted" when a Datamover layer is enabled for moving control and
      data information on that iSCSI connection.





<span class="grey">Chadalapaka, et al.          Informational                      [Page 5]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-6" id="page-6" name="page-6"> </a>
<span class="grey"><a href="rfc5047.html">RFC 5047</a>                           DA                       October 2007</span>


   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in [<a href="rfc2119.html" title='"Key words for use in RFCs to Indicate Requirement Levels"'>RFC2119</a>].

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/2.2.%20%20Acronyms"></a><a class="selflink" href="#section-2.2" name="section-2.2">2.2</a>.  Acronyms</span>

   Acronym        Definition
   -------------------------------------------------------------

   DA             Datamover Architecture for iSCSI

   DDP            Direct Data Placement Protocol

   DI             Datamover Interface

   IANA           Internet Assigned Numbers Authority

   IETF           Internet Engineering Task Force

   I/O            Input - Output

   IP             Internet Protocol

   iSCSI          Internet SCSI

   iSER           iSCSI Extensions for RDMA

   ITT            Initiator Task Tag

   LO             Leading Only

   MPA            Marker PDU Aligned Framing for TCP

   PDU            Protocol Data Unit

   RDDP           Remote Direct Data Placement

   RDMA           Remote Direct Memory Access

   R2T            Ready To Transfer

   R2TSN          Ready To Transfer Sequence Number

   RDMA           Remote Direct Memory Access

   RDMAP          Remote Direct Memory Access Protocol

   RFC            Request For Comments



<span class="grey">Chadalapaka, et al.          Informational                      [Page 6]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-7" id="page-7" name="page-7"> </a>
<span class="grey"><a href="rfc5047.html">RFC 5047</a>                           DA                       October 2007</span>


   SAM            SCSI Architecture Model

   SCSI           Small Computer Systems Interface

   SN             Sequence Number

   SNACK          Selective Negative Acknowledgment - also
                  Sequence Number Acknowledgement for Data

   TCP            Transmission Control Protocol

   TTT            Target Transfer Tag

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/3.%20%20Architectural%20Layering%20of%20iSCSI%20and%20Datamover%20Layers"></a><a class="selflink" href="#section-3" name="section-3">3</a>.  Architectural Layering of iSCSI and Datamover Layers</span>

   Figure 1 illustrates an example of the architectural layering of
   iSCSI and Datamover layers, in conjunction with a TCP/IP
   implementation of RDMAP/DDP ([<a href="#ref-DDP" title='"Direct Data Placement over Reliable Transports"'>DDP</a>]) layers in an iSCSI end node.
   Note that RDMAP/DDP/MPA and TCP protocol layers are shown here only
   as an example, and in reality, DA is completely oblivious to protocol
   layers below the Datamover layer.  The RDMAP/DDP/MPA protocol stack
   provides a generic transport service with direct data placement.
   There is no need to tailor the implementation of this protocol stack
   to the specific ULP to benefit from these services.



























<span class="grey">Chadalapaka, et al.          Informational                      [Page 7]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-8" id="page-8" name="page-8"> </a>
<span class="grey"><a href="rfc5047.html">RFC 5047</a>                           DA                       October 2007</span>


          Initiator stack                            Target stack

      +----------------+     SCSI application   +----------------+
      | SCSI Layer     |     protocols          | SCSI Layer     |
      +----------------+                        +----------------+
             ^                                          ^
             |                                          |
             v                                          v
      +----------------+     iSCSI protocol     +----------------+
      | iSCSI Layer    |    (excluding data     | iSCSI Layer    |
      +----------------+       movement)        +----------------+
             ^                                          ^
      --  ---+--  ---- DI (Datamover Interface)---  ----+---  ----
             v                                          v
      +----------------+      a Datamover       +----------------+
      | Datamover Layer|       protocol         | Datamover Layer|
      +----------------+                        +----------------+
             ^                                          ^
     +-------+----------+                     +---------+-----------+
     |       v          |                     |         v           |
     |+---------------+ |                     | +-----------------+ |
     || RDMAP/DDP/MPA | |    RDMAP/DDP/MPA    | | RDMAP/DDP/MPA   | |
     || Layers        | |    protocols        | | Layers          | |
     |+---------------+ |                     | +-----------------+ |
     |       ^          |                     |         ^           |
     |       | network  |                     |         | network   |
     |       | transport|                     |         | transport |
     |       v          |                     |         v           |
     |+---------------+ |                     | +----------------+  |
     || TCP Layer     | |    TCP protocol     | | TCP Layer      |  |
     |+---------------+ |                     | +----------------+  |
     |       ^          |                     |         ^           |
     +-------+----------+                     +---------+-----------+
             +------------------------------------------+

              Figure 1.  Datamover Architecture Diagram,
                        with the RDMAP Example

   The scope of this document is limited to:

      1. Defining the notion of a Datamover layer and a Datamover
         protocol (<a href="#section-6">Section 6</a>).

      2. Defining the functionality distribution between the iSCSI layer
         and the Datamover layer, along with the communication model
         between the two (Operational Primitives).





<span class="grey">Chadalapaka, et al.          Informational                      [Page 8]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-9" id="page-9" name="page-9"> </a>
<span class="grey"><a href="rfc5047.html">RFC 5047</a>                           DA                       October 2007</span>


      3. Modeling the interactions between the blocks labeled as "iSCSI
         Layer" and "Datamover Layer" in Figure 1 -- i.e., defining the
         interface labeled "DI" in the figure -- for each defined iSCSI
         PDU, based on the Operational Primitives.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/4.%20%20Design%20Overview"></a><a class="selflink" href="#section-4" name="section-4">4</a>.  Design Overview</span>

   This document discusses and defines a model for interactions between
   the iSCSI layer and a "Datamover layer" (see <a href="#section-6">Section 6</a>) operating
   within an iSCSI end node, presumably communicating with one or more
   iSCSI end nodes with similar layering.  The model for interactions
   for handling different iSCSI operations is called the "Datamover
   Interface" (DI, <a href="#section-10">Section 10</a>), while the architecture itself is called
   the "Datamover Architecture for iSCSI" (DA).  It is likely that the
   architecture will have implications on the Datamover wire protocols
   as DA places certain requirements and functionality expectations on
   the Datamover layer.  However, this document itself neither defines
   any new wire protocol for the Datamover layer, nor any potential
   modifications to the iSCSI wire protocol to employ the Datamover
   layer.  The scope of this document is strictly limited to specifying
   the architectural framework and the minimally required interactions
   that happen within an iSCSI end node to leverage the Datamover layer.

   The design ideas behind DA can be summarized as follows:

      1) DA defines an abstract functional interface model of the iSCSI
         layer's interactions with a Datamover layer below -- i.e., DA
         models the interactions between the logical "bottom" interface
         of iSCSI and the logical "top" interface of a Datamover.

      2) DA guides the wire protocol for a Datamover layer by defining
         the iSCSI knowledge that the Datamover layer may utilize in its
         protocol definition (as an example, this document completely
         limits the notion of "iSCSI session" to the iSCSI layer).

      3) DA is designed to allow implementation of the Datamover layer
         either in hardware or in software.

      4) DA is not a wire protocol spec, but an architecture that also
         models the interactions between iSCSI and Datamover layers
         operating within an iSCSI end node.

      5) DA by design seeks to model the iSCSI-Datamover interactions in
         a way that the modeling is independent of the specifics of
         either a particular iSCSI revision or an instantiation of a
         Datamover layer.





<span class="grey">Chadalapaka, et al.          Informational                      [Page 9]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-10" id="page-10" name="page-10"> </a>
<span class="grey"><a href="rfc5047.html">RFC 5047</a>                           DA                       October 2007</span>


      6) DA introduces and relies on the notion of a defined set of
         Operational Primitives (could be seen as entry point
         definitions in implementation terms) provided by each layer to
         the other to carry out the request-response interactions.

      7) DA is intended to allow Datamover protocol definitions with
         minimal changes to existing iSCSI implementations.

      8) DA is designed to allow the iSCSI layer to completely rely on
         the Datamover layer for all data transport needs.

      9) DA models the architecturally required minimal interactions
         between an operational iSCSI layer and a Datamover layer to
         realize the iSCSI-transparent data movement.  There may be
         several other interactions in a typical implementation in order
         to bootstrap a Datamover layer (or an iSCSI layer) into
         operation, but they are outside the scope of this document.

   Note that in summary, DA is architected to support many different
   Datamover protocols operating under the iSCSI layer.  One such
   example of a Datamover protocol is iSER [<a href="#ref-iSER" title='"Internet Small Computer System Interface (iSCSI) Extensions for Remote Direct Memory Access (RDMA)"'>iSER</a>].

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/5.%20%20Architectural%20Concepts"></a><a class="selflink" href="#section-5" name="section-5">5</a>.  Architectural Concepts</span>

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.1.%20%20iSCSI%20PDU%20Types"></a><a class="selflink" href="#section-5.1" name="section-5.1">5.1</a>.  iSCSI PDU Types</span>

   This section defines the iSCSI PDU classification terminology, as
   defined and used in this document.  Out of the set of legal iSCSI
   PDUs defined in [<a href="rfc3720.html" title='"Internet Small Computer Systems Interface (iSCSI)"'>RFC3720</a>], as we will see in <a href="#section-5.1.1">Section 5.1.1</a>, the iSCSI
   layer does not request a SCSI Data-Out PDU carrying solicited data
   for transmission across the Datamover Interface per this
   architecture.  For this reason, the SCSI Data-Out PDU carrying
   solicited data is excluded in the iSCSI PDU classification we
   introduce in this section (for SCSI Data-Out PDUs for unsolicited
   Data, see <a href="#section-5.1.2">Section 5.1.2</a>).  The rest of the legal iSCSI PDUs that may
   be exchanged across the Datamover Interface are defined to consist of
   two classes:

      1) iSCSI data-type PDUs

      2) iSCSI control-type PDUs

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/5.1.1.%20%20iSCSI%20Data-Type%20PDUs"></a><a class="selflink" href="#section-5.1.1" name="section-5.1.1">5.1.1</a>.  iSCSI Data-Type PDUs</span>

   An iSCSI data-type PDU is defined as an iSCSI PDU that causes data
   transfer, transparent to the remote iSCSI layer, to take place
   between the peer iSCSI nodes on a Full Feature Phase iSCSI
   connection.  A data-type PDU, when requested for transmission by the



<span class="grey">Chadalapaka, et al.          Informational                     [Page 10]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-11" id="page-11" name="page-11"> </a>
<span class="grey"><a href="rfc5047.html">RFC 5047</a>                           DA                       October 2007</span>


   sender iSCSI layer, results in the associated data transfer without
   the participation of the remote iSCSI layer, i.e., the PDU itself is
   not delivered as-is to the remote iSCSI layer.  The following iSCSI
   PDUs constitute the set of iSCSI data-type PDUs:

      1) SCSI Data-In PDU

      2) R2T PDU

   In an iSCSI end node structured as an iSCSI layer and a Datamover
   layer as defined in this document, the solicitation for Data-Out
   (i.e., R2T PDU) is not delivered to the initiator iSCSI layer, per
   the definition of an iSCSI data-type PDU.  The data transfer is
   instead performed via the mechanisms known to the Datamover layer
   (e.g., RDMA Read).  This in turn implies that a SCSI Data-Out PDU for
   solicited data is never requested for transmission across the
   Datamover Interface at the initiator.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/5.1.2.%20%20iSCSI%20Control-Type%20PDUs"></a><a class="selflink" href="#section-5.1.2" name="section-5.1.2">5.1.2</a>.  iSCSI Control-Type PDUs</span>

   Any iSCSI PDU that is not an iSCSI data-type PDU and also not a
   solicited SCSI Data-Out PDU is defined as an iSCSI control-type PDU.
   Specifically, note that SCSI Data-Out PDUs for unsolicited Data are
   defined as iSCSI control-type PDUs.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.2.%20%20Data_Descriptor"></a><a class="selflink" href="#section-5.2" name="section-5.2">5.2</a>.  Data_Descriptor</span>

   A Data_Descriptor is an information element that describes an
   iSCSI/SCSI data buffer, provided by the iSCSI layer to its local
   Datamover layer or provided by the Datamover layer to its local iSCSI
   layer for identifying the data associated respectively with the
   requested or completed operation.

   In implementation terms, a Data_Descriptor may be a scatter-gather
   list describing a local buffer, the exact structure of which is
   subject to the constraints imposed by the operating environment on
   the local iSCSI node.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.3.%20%20Connection_Handle"></a><a class="selflink" href="#section-5.3" name="section-5.3">5.3</a>.  Connection_Handle</span>

   A Connection_Handle is an information element that identifies the
   particular iSCSI connection for which an inbound or outbound iSCSI
   PDU is intended.  A connection handle is unique for a given pair of
   an iSCSI layer instance and a Datamover layer instance.  The
   Connection_Handle qualifier is used in all invocations of any
   Operational Primitive for connection identification.





<span class="grey">Chadalapaka, et al.          Informational                     [Page 11]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-12" id="page-12" name="page-12"> </a>
<span class="grey"><a href="rfc5047.html">RFC 5047</a>                           DA                       October 2007</span>


   Note that the Connection_Handle is conceptually different from the
   Connection Identifier (CID) defined by the iSCSI specification.
   While the CID is a unique identifier of an iSCSI connection within an
   iSCSI session, the uniqueness of the Connection_Handle extends to the
   entire iSCSI layer instance coupled with the Datamover layer
   instance, across possibly multiple iSCSI sessions.

   In implementation terms, a Connection_Handle could be an opaque
   identifier exchanged between the iSCSI layer and the Datamover layer
   at the connection login time.  One may also consider it to be similar
   in scope of uniqueness to a socket identifier.  The exact structure
   and modalities of exchange of a Connection_Handle between the two
   layers is implementation-specific.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.4.%20%20Operational%20Primitive"></a><a class="selflink" href="#section-5.4" name="section-5.4">5.4</a>.  Operational Primitive</span>

   An Operational Primitive, in this document, is an abstract functional
   interface procedure that requests another layer perform a specific
   action on the requestor's behalf or notifies the other layer of some
   event.  The Datamover Interface between an iSCSI layer instance and a
   Datamover layer instance within an iSCSI end node uses a set of
   Operational Primitives to define the functional interface between the
   two layers.  Note that not every invocation of an Operational
   Primitive may elicit a response from the requested layer.  This
   document describes the types of Operational Primitives that are
   implicitly required and provided by the iSCSI protocol layer as
   defined in [<a href="rfc3720.html" title='"Internet Small Computer Systems Interface (iSCSI)"'>RFC3720</a>], and the semantics of these Primitives.

   Note that ownership of buffers and data structures is likely to be
   exchanged between the iSCSI layer and its local Datamover layer in
   invoking the Operational Primitives defined in this architecture.
   The buffer management details, including how buffers are allocated
   and released, are implementation-specific and thus are outside the
   scope of this document.

   Each Operational Primitive invocation needs a certain "information
   context" (e.g., Connection_Handle) for performing the specific action
   being requested.  The required information context is described in
   this document by a listing of "qualifiers" on each invocation, in the
   style of function call arguments.  There is no specific
   implementation implied in this notation.  The "qualifiers" of any
   Operational Primitive invocation specified in this document thus
   represent the mandatory information context that the Operational
   Primitive invocation MUST consider in performing the action.  While
   the qualifiers are required, the method of realizing the qualifiers
   (passed synchronously with invocation, or retrieved from task
   context, or retrieved from shared memory etc.) is really up to the
   implementations.



<span class="grey">Chadalapaka, et al.          Informational                     [Page 12]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-13" id="page-13" name="page-13"> </a>
<span class="grey"><a href="rfc5047.html">RFC 5047</a>                           DA                       October 2007</span>


   When an Operational Primitive implementation is described as
   mandatory ("MUST") or recommended ("SHOULD") of a layer (iSCSI or
   Datamover) in this document, the intent is that an implementation
   respectively MUST or SHOULD produce the same protocol action as what
   the model describes.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.5.%20%20Transport%20Connection"></a><a class="selflink" href="#section-5.5" name="section-5.5">5.5</a>.  Transport Connection</span>

   The term "Transport Connection" is used in this document as a generic
   term to represent the end-to-end logical connection as defined by the
   underlying reliable transport protocol.  For this document, all
   instances of Transport Connection refer to a TCP connection.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/6.%20%20Datamover%20Layer%20and%20Datamover%20Protocol"></a><a class="selflink" href="#section-6" name="section-6">6</a>.  Datamover Layer and Datamover Protocol</span>

   This section introduces the notion of a "Datamover layer" and
   "Datamover protocol" as meant in this document, and defines the
   requirements on a Datamover protocol.

   A Datamover layer is the implementation component that realizes a
   Datamover protocol functionality in an iSCSI-capable end node in
   communicating with other iSCSI end nodes with similar capabilities.
   More specifically, a "Datamover layer" MUST provide the following
   functionality and the "Datamover protocol" MUST consist of the wire
   protocol required to realize the following functionality:

      1) guarantee that all the necessary data transfers take place when
         the local iSCSI layer requests transmitting a command (in order
         to complete a SCSI command, for an initiator), or
         sending/receiving an iSCSI data sequence (in order to complete
         part of a SCSI command for a target).

      2) transport an iSCSI control-type PDU as-is to the peer Datamover
         layer when requested to do so by the local iSCSI layer.

      3) provide notification and delivery to the iSCSI layer upon
         arrival of an iSCSI control-type PDU.

      4) provide an initiator-to-target data acknowledgement of SCSI
         read data back to the target iSCSI layer, when requested.

      5) provide an asynchronous notification upon completion of a
         requested data transfer operation that moved data without
         involving the iSCSI layer.

      6) place the SCSI data into the I/O buffers or pick up the SCSI
         data for transmission out of the data buffers that the iSCSI
         layer had requested to be used for a SCSI I/O.



<span class="grey">Chadalapaka, et al.          Informational                     [Page 13]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-14" id="page-14" name="page-14"> </a>
<span class="grey"><a href="rfc5047.html">RFC 5047</a>                           DA                       October 2007</span>


      7) provide an error-free (i.e., must have at least the same level
         of assurance of data integrity as the CRC32C iSCSI data
         digest), reliable, in-order delivery transport mechanism over
         IP networks in performing the data transfer, and asynchronously
         notify the iSCSI layer upon iSCSI connection termination.

   Note that this architecture expects that each compliant Datamover
   protocol will define the precise means of satisfying the requirements
   specified in this section.

   In order to meet the functional requirements listed in this section,
   certain Datamover protocols may require pre-posted buffers from the
   local iSCSI protocol layer via mechanisms outside the scope of this
   document.  In some implementations, the absence of such buffers may
   result in a connection failure.  Datamover protocols may also realize
   these functional requirements via methods not explicitly listed in
   this document.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/7.%20%20Functional%20Overview"></a><a class="selflink" href="#section-7" name="section-7">7</a>.  Functional Overview</span>

   This section presents an overview of the functional interactions
   between the iSCSI layer and the Datamover layer as intended by this
   Architecture.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/7.1.%20%20Startup"></a><a class="selflink" href="#section-7.1" name="section-7.1">7.1</a>.  Startup</span>

   The iSCSI Login Phase on an iSCSI connection occurs as defined in
   [<a href="rfc3720.html" title='"Internet Small Computer Systems Interface (iSCSI)"'>RFC3720</a>].  The Architecture assumes that at the end of the Login
   Phase, both the initiator and target, if they had so decided,
   transition the connection to being Datamover-assisted.  The precise
   means of how an iSCSI initiator and an iSCSI target agree on having
   the connection Datamover-assisted is defined by the Datamover
   protocol.  The only architectural requirement is that all iSCSI
   interactions in the iSCSI Full Feature Phase MUST be Datamover-
   assisted subject to the prior agreement, meaning that the Datamover
   protocol is in the iSCSI-to-iSCSI communication path below the iSCSI
   layer on either side as shown in Figure 1.  DA defines the
   Enable_Datamover Operational Primitive (<a href="#section-8.6">Section 8.6</a>) to bring about
   this transition to a Datamover-assisted connection.

   The Architecture also assumes that the Datamover layer may require a
   certain number of opaque local resources for making a connection
   Datamover-assisted.  DA thus defines the
   Allocate_Connection_Resources Operational Primitive (<a href="#section-8.4">Section 8.4</a>) to
   model this interaction.  This Primitive is intended to be invoked on
   each side once the two sides decide (as previously noted) to have the
   connection be Datamover-assisted.  The expected sequence of Primitive
   invocations is depicted in Figures 2 and 3 in <a href="#section-13.2">Section 13.2</a>.  Figures



<span class="grey">Chadalapaka, et al.          Informational                     [Page 14]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-15" id="page-15" name="page-15"> </a>
<span class="grey"><a href="rfc5047.html">RFC 5047</a>                           DA                       October 2007</span>


   4, 5, and 6 illustrate how the Primitives may be employed to deal
   with various legal login outcomes.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/7.2.%20%20Full%20Feature%20Phase"></a><a class="selflink" href="#section-7.2" name="section-7.2">7.2</a>.  Full Feature Phase</span>

   All iSCSI peer communication in the Full Feature Phase happens
   through the Datamover layers if the iSCSI connection is Datamover-
   assisted.  The Architecture assumes that a Datamover layer may
   require a certain number of opaque local resources for each new iSCSI
   task.  In the normal course of execution, these task-level resources
   in the Datamover layer are assumed to be transparently allocated on
   each task initiation and deallocated on the conclusion of each task
   as appropriate.  In exception scenarios however -- scenarios that do
   not yield a SCSI Response for each task such as ABORT TASK operation
   -- the Architecture assumes that the Datamover layer needs to be
   notified of the individual task terminations to aid its task-level
   resource management.  DA thus defines the Deallocate_Task_Resources
   Operational Primitive (<a href="#section-8.9">Section 8.9</a>) to model this task-resource
   management.  In specifying the ITT qualifier for the
   Deallocate_Task_Resources Primitive, the Architecture further assumes
   that the Datamover layer tracks its opaque task-level local resources
   by the iSCSI ITT.  DA also defines Send_Control (<a href="#section-8.1">Section 8.1</a>),
   Put_Data (<a href="#section-8.2">Section 8.2</a>), Get_Data (<a href="#section-8.3">Section 8.3</a>),
   Data_Completion_Notify (<a href="#section-9.3">Section 9.3</a>), Data_ACK_Notify (<a href="#section-9.4">Section 9.4</a>),
   and Control_Notify (<a href="#section-9.1">Section 9.1</a>) Operational Primitives to model the
   various Full Feature Phase interactions.

   Figures 9, 10, and 11 in <a href="#section-13.2">Section 13.2</a> show some Full Feature Phase
   interactions -- SCSI Write task, SCSI Read task, and a SCSI Read Data
   acknowledgement, respectively.  Figure 12 in <a href="#section-13.2">Section 13.2</a> illustrates
   how an ABORT TASK operation can be modeled leading to deterministic
   resource cleanup on the Datamover layer.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/7.3.%20%20Wrap-up"></a><a class="selflink" href="#section-7.3" name="section-7.3">7.3</a>.  Wrap-up</span>

   Once an iSCSI connection becomes Datamover-assisted, the connection
   continues in that state until the end of the Full Feature Phase,
   i.e., the termination of the connection.  The Architecture assumes
   that when a connection is normally logged out, the Datamover layer
   needs to be notified so that its connection-level opaque resources
   (see <a href="#section-7.1">Section 7.1</a>) may be freed up.  DA thus defines a
   Connection_Terminate Operational Primitive (<a href="#section-8.7">Section 8.7</a>) to model
   this interaction.  The Architecture further assumes that when a
   connection termination happens without iSCSI layer's involvement
   (e.g., TCP RST), the Datamover layer is capable of locally cleaning
   up its task-level and connection-level resources before notifying the
   iSCSI layer of the fact.  DA thus defines the




<span class="grey">Chadalapaka, et al.          Informational                     [Page 15]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-16" id="page-16" name="page-16"> </a>
<span class="grey"><a href="rfc5047.html">RFC 5047</a>                           DA                       October 2007</span>


   Connection_Terminate_Notify Operational Primitive (<a href="#section-9.2">Section 9.2</a>) to
   model this interaction.

   Figures 7 and 8 in <a href="#section-13.2">Section 13.2</a> illustrate the interactions between
   the iSCSI and Datamover layers in normal and unexpected connection
   termination scenarios.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/8.%20%20Operational%20Primitives%20Provided%20by%20the%20Datamover%20Layer"></a><a class="selflink" href="#section-8" name="section-8">8</a>.  Operational Primitives Provided by the Datamover Layer</span>

   While the iSCSI specification itself does not have a notion of
   Operational Primitives, any iSCSI layer implementing the iSCSI
   specification functionally requires the following Operational
   Primitives from its Datamover layer.  Thus, any Datamover protocol
   compliant with this architecture MUST implement the Operational
   Primitives described in this section.  These Operational Primitives
   are invoked by the iSCSI layer as appropriate.  Unless otherwise
   stated, all the following Operational Primitives may be used both on
   the initiator side and the target side.  In general programming
   terminology, this set of Operational Primitives may be construed as
   "down calls".

      1) Send_Control

      2) Put_Data

      3) Get_Data

      4) Allocate_Connection_Resources

      5) Deallocate_Connection_Resources

      6) Enable_Datamover

      7) Connection_Terminate

      8) Notice_Key_Values

      9) Deallocate_Task_Resources

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/8.1.%20%20Send_Control"></a><a class="selflink" href="#section-8.1" name="section-8.1">8.1</a>.  Send_Control</span>

   Input qualifiers: Connection_Handle, iSCSI PDU-specific qualifiers

   Return Results: Not specified.

   An iSCSI layer requests that its local Datamover layer transmit an
   iSCSI control-type PDU to the peer iSCSI layer operating in the
   remote iSCSI node by this Operational Primitive.  The Datamover layer



<span class="grey">Chadalapaka, et al.          Informational                     [Page 16]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-17" id="page-17" name="page-17"> </a>
<span class="grey"><a href="rfc5047.html">RFC 5047</a>                           DA                       October 2007</span>


   performs the requested operation, and may add its own protocol
   headers in doing so.  The iSCSI layer MUST NOT invoke the
   Send_Control Operational Primitive on an iSCSI connection that is not
   yet Datamover-assisted.

   An initiator iSCSI layer requesting the transfer of a SCSI Command
   PDU or a target iSCSI layer requesting the transfer of a SCSI
   response PDU are examples of invoking the Send_Control Operational
   Primitive.  As <a href="#section-10.3.1">Section 10.3.1</a> illustrates later on, the iSCSI PDU-
   specific qualifiers in this example are: BHS and AHS,
   DataDescriptorOut, DataDescriptorIn, ImmediateDataSize, and
   UnsolicitedDataSize.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/8.2.%20%20Put_Data"></a><a class="selflink" href="#section-8.2" name="section-8.2">8.2</a>.  Put_Data</span>

   Input qualifiers: Connection_Handle, contents of a SCSI Data-In PDU
   header, Data_Descriptor, Notify_Enable

   Return Results: Not specified.

   An iSCSI layer requests that its local Datamover layer transmit the
   data identified by the Data_Descriptor for the SCSI Data-In PDU to
   the peer iSCSI layer on the remote iSCSI node by this Operational
   Primitive.  The Datamover layer performs the operation by using its
   own protocol means, completely transparent to the remote iSCSI layer.
   The iSCSI layer MUST NOT invoke the Put_Data Operational Primitive on
   an iSCSI connection that is not yet Datamover-assisted.

   The Notify_Enable qualifier is used to request the local Datamover
   layer to generate or not generate the eventual local completion
   notification to the iSCSI layer for this Put_Data invocation.  For
   detailed semantics of this qualifier, see <a href="#section-9.3">Section 9.3</a>.

   A Put_Data Primitive may only be invoked by an iSCSI layer on the
   target to its local Datamover layer.

   A target iSCSI layer requesting the transfer of an iSCSI read data
   sequence (also known as a read burst) is an example of invoking the
   Put_Data Operational Primitive.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/8.3.%20%20Get_Data"></a><a class="selflink" href="#section-8.3" name="section-8.3">8.3</a>.  Get_Data</span>

   Input qualifiers: Connection_Handle, contents of an R2T PDU,
   Data_Descriptor, Notify_Enable

   Return Results: Not specified.





<span class="grey">Chadalapaka, et al.          Informational                     [Page 17]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-18" id="page-18" name="page-18"> </a>
<span class="grey"><a href="rfc5047.html">RFC 5047</a>                           DA                       October 2007</span>


   An iSCSI layer requests that its local Datamover layer retrieve
   certain data identified by the R2T PDU from the peer iSCSI layer on
   the remote iSCSI node and place it into the buffer identified by the
   Data_Descriptor by invoking this Operational Primitive.  The
   Datamover layer performs the operation by using its own protocol
   means, completely transparent to the remote iSCSI layer.  The iSCSI
   layer MUST NOT invoke the Get_Data Operational Primitive on an iSCSI
   connection that is not yet Datamover-assisted.

   The Notify_Enable qualifier is used to request that the local
   Datamover layer generate or not generate the eventual local
   completion notification to the iSCSI layer for this Get_Data
   invocation.  For detailed semantics of this qualifier, see <a href="#section-9.3">Section</a>
   <a href="#section-9.3">9.3</a>.

   A Get_Data Primitive may only be invoked by an iSCSI layer on the
   target to its local Datamover layer.

   A target iSCSI layer requesting the transfer of an iSCSI write data
   sequence (also known as a write burst) is an example of invoking the
   Get_Data Operational Primitive.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/8.4.%20%20Allocate_Connection_Resources"></a><a class="selflink" href="#section-8.4" name="section-8.4">8.4</a>.  Allocate_Connection_Resources</span>

   Input qualifiers: Connection_Handle[, Resource_Descriptor ]

   Return Results: Status.

   By invoking this Operational Primitive, an iSCSI layer requests that
   its local Datamover layer perform all the Datamover-specific resource
   allocations required for the Full Feature Phase of an iSCSI
   connection.  The Connection_Handle identifies the connection for
   which the iSCSI layer is requesting resources to be allocated.
   Allocation of these resources is a step towards eventually
   transitioning the connection to become a Datamover-assisted iSCSI
   connection.  Note that the Datamover layer however does not allocate
   any Datamover-specific task-level resources upon invocation of this
   Primitive.

   An iSCSI layer, in addition, optionally specifies the
   implementation-specific resource requirements for the iSCSI
   connection to the Datamover layer by passing an input qualifier
   called Resource_Descriptor.  The exact structure of a
   Resource_Descriptor is implementation-dependent, and hence
   structurally opaque to DA.

   A return result of Status=success means that the
   Allocate_Connection_Resources invocation corresponding to that



<span class="grey">Chadalapaka, et al.          Informational                     [Page 18]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-19" id="page-19" name="page-19"> </a>
<span class="grey"><a href="rfc5047.html">RFC 5047</a>                           DA                       October 2007</span>


   Connection_Handle succeeded.  If an Allocate_Connection_Resources
   invocation is made for a Connection_Handle for which an earlier
   invocation succeeded, the return Status must be success and the
   request will be ignored by the Datamover layer.  A return result of
   Status=failure means that the Allocate_Connection_Resources
   invocation corresponding to that Connection_Handle failed.  There
   MUST NOT be more than one Allocate_Connection_Resources Primitive
   invocation outstanding for a given Connection_Handle at any time.

   The iSCSI layer must invoke the Allocate_Connection_Resources
   Primitive before the invocation of the Enable_Datamover Primitive.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/8.5.%20%20Deallocate_Connection_Resources"></a><a class="selflink" href="#section-8.5" name="section-8.5">8.5</a>.  Deallocate_Connection_Resources</span>

   Input qualifiers: Connection_Handle

   Return Results: Not specified.

   By invoking this Operational Primitive, an iSCSI layer requests that
   its local Datamover layer deallocate all the Datamover-specific
   resources that may have been allocated earlier for the Transport
   Connection identified by the Connection_Handle.  The iSCSI layer may
   invoke this Operational Primitive when the Datamover-specific
   resources associated with the Connection_Handle are no longer
   necessary (such as the Login failure of the corresponding iSCSI
   connection).

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/8.6.%20%20Enable_Datamover"></a><a class="selflink" href="#section-8.6" name="section-8.6">8.6</a>.  Enable_Datamover</span>

   Input qualifiers: Connection_Handle, Transport_Connection_Descriptor
   [, Final_Login_Response_PDU]

   Return Results: Not specified.

   By invoking this Operational Primitive, an iSCSI layer requests that
   its local Datamover layer assist all further iSCSI exchanges on the
   iSCSI connection (i.e., to make the connection Datamover-assisted)
   identified by the Connection_Handle, for which the Datamover-specific
   resource allocation was earlier made.  The iSCSI layer MUST NOT
   invoke the Enable_Datamover Operational Primitive for an iSCSI
   connection unless there is a corresponding prior resource allocation.

   The Final_Login_Response_PDU input qualifier is applicable only for a
   target, and contains the final Login Response that concludes the
   iSCSI Login Phase and which must be sent as a byte stream as expected
   by the initiator iSCSI layer.  When this qualifier is used, the
   target-Datamover layer MUST transmit this final Login Response before
   Datamover assistance is enabled for the Transport Connection.



<span class="grey">Chadalapaka, et al.          Informational                     [Page 19]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-20" id="page-20" name="page-20"> </a>
<span class="grey"><a href="rfc5047.html">RFC 5047</a>                           DA                       October 2007</span>


   The iSCSI layer identifies the specific Transport Connection
   associated with the Connection_Handle to the Datamover layer by
   specifying the Transport_Connection_Descriptor.  The exact structure
   of this Descriptor is implementation-dependent.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/8.7.%20%20Connection_Terminate"></a><a class="selflink" href="#section-8.7" name="section-8.7">8.7</a>.  Connection_Terminate</span>

   Input qualifiers: Connection_Handle

   Return Results: Not specified.

   By invoking this Operational Primitive, an iSCSI layer requests that
   its local Datamover layer terminate the Transport Connection and
   deallocate all the connection and task resources associated with the
   Connection_Handle.  When this Operational Primitive invocation
   returns to the iSCSI layer, the iSCSI layer may assume the full
   ownership of all the iSCSI-level resources, e.g., I/O Buffers,
   associated with the connection.  This Operational Primitive may be
   invoked only with a valid Connection_Handle, and the Transport
   Connection associated with the Connection_Handle must already be
   Datamover-assisted.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/8.8.%20%20Notice_Key_Values"></a><a class="selflink" href="#section-8.8" name="section-8.8">8.8</a>.  Notice_Key_Values</span>

   Input qualifiers: Connection_Handle, Number of keys, a list of Key-
   Value pairs.

   Return Results: Not specified.

   By invoking this Operational Primitive, an iSCSI layer requests that
   its local Datamover layer take note of the negotiated values of the
   listed keys for the Transport Connection.  This Operational Primitive
   may be invoked only with a valid Connection_Handle, and the Key-Value
   pairs MUST be the current values that were successfully agreed upon
   by the iSCSI peers for the connection.  The Datamover layer may use
   the values of the keys to aid the Datamover operation as it deems
   appropriate.  The specific keys to be passed as input qualifiers and
   the point(s) in time this Operational Primitive is invoked are
   implementation-dependent.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/8.9.%20%20Deallocate_Task_Resources"></a><a class="selflink" href="#section-8.9" name="section-8.9">8.9</a>.  Deallocate_Task_Resources</span>

   Input qualifiers: Connection_Handle, ITT

   Return Results: Not specified.

   By invoking this Operational Primitive, an iSCSI layer requests that
   its local Datamover layer deallocate all Datamover-specific resources



<span class="grey">Chadalapaka, et al.          Informational                     [Page 20]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-21" id="page-21" name="page-21"> </a>
<span class="grey"><a href="rfc5047.html">RFC 5047</a>                           DA                       October 2007</span>


   that earlier may have been allocated for the task identified by the
   ITT qualifier.  The iSCSI layer uses this Operational Primitive
   during exception processing when one or more active tasks are to be
   terminated without corresponding SCSI Response PDUs.  This Primitive
   MUST be invoked for each active task terminated without a SCSI
   Response PDU.  This Primitive MUST NOT be invoked by the iSCSI layer
   when a SCSI Response PDU normally concludes a task.  When a SCSI
   Response PDU normally concludes a task (even if the SCSI Status was
   not a success), the Datamover layer is assumed to have automatically
   deallocated all Datamover-specific task resources for that task.
   Refer to <a href="#section-7.2">Section 7.2</a> for a related discussion on the Architectural
   assumptions on the task-level Datamover resource management,
   especially with respect to when the resources are assumed to be
   allocated.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/9.%20%20Operational%20Primitives%20Provided%20by%20the%20iSCSI%20Layer"></a><a class="selflink" href="#section-9" name="section-9">9</a>.  Operational Primitives Provided by the iSCSI Layer</span>

   While the iSCSI specification itself does not have a notion of
   Operational Primitives, any iSCSI layer implementing the iSCSI
   specification would have to provide the following Operational
   Primitives to its local Datamover layer.  Thus, any iSCSI protocol
   implementation compliant with this architecture MUST implement the
   Operational Primitives described in this section.  These Operational
   Primitives are invoked by the Datamover layer as appropriate and when
   the iSCSI connection is Datamover-assisted.  Unless otherwise stated,
   all the following Operational Primitives may be used both on the
   initiator side and the target side.  In general programming
   terminology, this set of Operational Primitives may be construed as
   "up calls".

      1) Control_Notify

      2) Connection_Terminate_Notify

      3) Data_Completion_Notify

      4) Data_ACK_Notify

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/9.1.%20%20Control_Notify"></a><a class="selflink" href="#section-9.1" name="section-9.1">9.1</a>.  Control_Notify</span>

   Input qualifiers: Connection_Handle, an iSCSI control-type PDU.

   Return Results: Not specified.

   A Datamover layer notifies its local iSCSI layer, via this
   Operational Primitive, of the arrival of an iSCSI control-type PDU
   from the peer Datamover layer on the remote iSCSI node.  The iSCSI
   layer processes the control-type PDU as defined in [<a href="rfc3720.html" title='"Internet Small Computer Systems Interface (iSCSI)"'>RFC3720</a>].



<span class="grey">Chadalapaka, et al.          Informational                     [Page 21]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-22" id="page-22" name="page-22"> </a>
<span class="grey"><a href="rfc5047.html">RFC 5047</a>                           DA                       October 2007</span>


   A target iSCSI layer being notified of the arrival of a SCSI command
   is an example of invoking the Control_Notify Operational Primitive.

   Note that implementations may choose to describe the "iSCSI control-
   type PDU" qualifier in this notification using a Data_Descriptor
   (<a href="#section-5.2">Section 5.2</a>) and not necessarily one contiguous buffer.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/9.2.%20%20Connection_Terminate_Notify"></a><a class="selflink" href="#section-9.2" name="section-9.2">9.2</a>.  Connection_Terminate_Notify</span>

   Input qualifiers: Connection_Handle

   Return Results: Not specified.

   A Datamover layer notifies its local iSCSI layer on an unsolicited
   termination or failure of an iSCSI connection providing the
   Connection_Handle associated with the iSCSI Connection.  The iSCSI
   layer MUST consider the Connection_Handle to be invalid upon being so
   notified.  The iSCSI layer processes the connection termination as
   defined in [<a href="rfc3720.html" title='"Internet Small Computer Systems Interface (iSCSI)"'>RFC3720</a>].  The Datamover layer MUST deallocate the
   connection and task resources associated with the terminated
   connection before notifying the iSCSI layer of the termination via
   this Operational Primitive.

   A target iSCSI layer is notified of an ungraceful connection
   termination by the Datamover layer when the underlying Transport
   Connection is torn down.  Such a Connection_Terminate_Notify
   Operational Primitive may be triggered, for example, by a TCP RESET
   in cases where the underlying Transport Connection uses TCP.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/9.3.%20%20Data_Completion_Notify"></a><a class="selflink" href="#section-9.3" name="section-9.3">9.3</a>.  Data_Completion_Notify</span>

   Input qualifiers: Connection_Handle, ITT, SN

   Return Results: Not specified.

   A Datamover layer notifies its local iSCSI layer on completing the
   retrieval of the data or upon sending the data, as requested in a
   prior iSCSI data-type PDU, from/to the peer Datamover layer on the
   remote iSCSI node via this Operational Primitive.  The iSCSI layer
   processes the operation as defined in [<a href="rfc3720.html" title='"Internet Small Computer Systems Interface (iSCSI)"'>RFC3720</a>].

   SN may be either the DataSN associated with the SCSI Data-In PDU or
   R2TSN associated with the R2T PDU depending on the SCSI operation.
   Note that, for targets, a TTT (see [<a href="rfc3720.html" title='"Internet Small Computer Systems Interface (iSCSI)"'>RFC3720</a>]) could have been
   specified instead of an SN.  However, the considered choice was to
   leave the SN to be the qualifier for two reasons -- a) it is generic
   and applicable to initiators and targets as well as Data-In and
   Data-Out, and b) having both SN and TTT qualifiers for the



<span class="grey">Chadalapaka, et al.          Informational                     [Page 22]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-23" id="page-23" name="page-23"> </a>
<span class="grey"><a href="rfc5047.html">RFC 5047</a>                           DA                       October 2007</span>


   notification is considered onerous on the Datamover layer, in terms
   of state maintenance for each completion notification.  The
   implication of this choice is that iSCSI target implementations will
   have to adapt to using the ITT-SN tuple in associating the solicited
   data to the appropriate task, rather than the ITT-TTT tuple for doing
   the same.

   If Notify_Enable is set in either a Put_Data or a Get_Data
   invocation, the Datamover layer MUST invoke the
   Data_Completion_Notify Operational Primitive upon completing that
   requested data transfer.  If the Notify_Enable was cleared in either
   a Put_Data or a Get_Data invocation, the Datamover layer MUST NOT
   invoke the Data_Completion_Notify Operational Primitive upon
   completing that requested data transfer.

   A Data_Completion_Notify invocation serves to notify the iSCSI layer
   of the Put_Data or Get_Data completion, respectively.  As earlier
   noted in Sections <a href="#section-8.2">8.2</a> and <a href="#section-8.3">8.3</a>, specific Datamover protocol
   definitions may restrict the usage scope of Put_Data and Get_Data,
   and thus implicitly the usage scope of Data_Completion_Notify.

   A target iSCSI layer being notified of the retrieval of a write data
   sequence is an example of invoking the Data_Completion_Notify
   Operational Primitive.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/9.4.%20%20Data_ACK_Notify"></a><a class="selflink" href="#section-9.4" name="section-9.4">9.4</a>.  Data_ACK_Notify</span>

   Input qualifiers: Connection_Handle, ITT, DataSN

   Return Results: Not specified.

   A target Datamover layer notifies its local iSCSI layer of the
   arrival of a previously requested data acknowledgement from the peer
   Datamover layer on the remote (initiator) iSCSI node via this
   Operational Primitive.  The iSCSI layer processes the data
   acknowledgement notification as defined in [<a href="rfc3720.html" title='"Internet Small Computer Systems Interface (iSCSI)"'>RFC3720</a>].

   A target iSCSI layer being notified of the arrival of a data
   acknowledgement for a certain SCSI Read data PDU is the only example
   of invoking the Data_ACK_Notify Operational Primitive.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/10.%20%20Datamover%20Interface%20%28DI%29"></a><a class="selflink" href="#section-10" name="section-10">10</a>.  Datamover Interface (DI)</span>

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/10.1.%20%20Overview"></a><a class="selflink" href="#section-10.1" name="section-10.1">10.1</a>.  Overview</span>

   This section describes the model of interactions between iSCSI and
   Datamover layers when the iSCSI connection is Datamover-assisted so
   the iSCSI layer may carry out the following:



<span class="grey">Chadalapaka, et al.          Informational                     [Page 23]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-24" id="page-24" name="page-24"> </a>
<span class="grey"><a href="rfc5047.html">RFC 5047</a>                           DA                       October 2007</span>


      -  send iSCSI data-type PDUs and exchange iSCSI control-type PDUs,
         and

      -  handle asynchronous notifications such as completion of data
         sequence transfer and connection failure.

   This chapter relies on the notion of Operational Primitives (<a href="#section-5.4">Section</a>
   <a href="#section-5.4">5.4</a>) to define DI.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/10.2.%20%20Interactions%20for%20Handling%20Asynchronous%20Notifications"></a><a class="selflink" href="#section-10.2" name="section-10.2">10.2</a>.  Interactions for Handling Asynchronous Notifications</span>

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/10.2.1.%20%20Connection%20Termination"></a><a class="selflink" href="#section-10.2.1" name="section-10.2.1">10.2.1</a>.  Connection Termination</span>

   As stated in <a href="#section-9.2">Section 9.2</a>, the Datamover layer notifies the iSCSI
   layer of a failed or terminated connection via the
   Connection_Terminate_Notify Operational Primitive.  The iSCSI layer
   MUST consider the connection unusable upon the invocation of this
   Primitive and handle the connection termination as specified in
   [<a href="rfc3720.html" title='"Internet Small Computer Systems Interface (iSCSI)"'>RFC3720</a>].

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/10.2.2.%20%20Data%20Transfer%20Completion"></a><a class="selflink" href="#section-10.2.2" name="section-10.2.2">10.2.2</a>.  Data Transfer Completion</span>

   As stated in <a href="#section-9.3">Section 9.3</a>, the Datamover layer notifies the iSCSI
   layer of a completed data transfer operation via the
   Data_Completion_Notify Operational Primitive.  The iSCSI layer
   processes the transfer completion as specified in [<a href="rfc3720.html" title='"Internet Small Computer Systems Interface (iSCSI)"'>RFC3720</a>].

<span class="h5"><a class="dashAnchor" name="//apple_ref/Section/10.2.2.1.%20%20Completion%20of%20a%20Requested%20SCSI%20Data%20Transfer"></a><a class="selflink" href="#section-10.2.2.1" name="section-10.2.2.1">10.2.2.1</a>.  Completion of a Requested SCSI Data Transfer</span>

   To notify the iSCSI layer of the completion of a requested iSCSI
   data-type PDU transfer, the Datamover layer uses the
   Data_Completion_Notify Operational Primitive with the following input
   qualifiers.

      a) Connection_Handle.

      b) ITT: Initiator Task Tag semantics as defined in [<a href="rfc3720.html" title='"Internet Small Computer Systems Interface (iSCSI)"'>RFC3720</a>].

      c) SN: DataSN for a SCSI Data-in/Data-out PDU, and R2TSN for an
         iSCSI R2T PDU.  The semantics for both types of sequence
         numbers are as defined in [<a href="rfc3720.html" title='"Internet Small Computer Systems Interface (iSCSI)"'>RFC3720</a>].

   The rationale for choosing SN is explained in <a href="#section-9.3">Section 9.3</a>.

   Every invocation of the Data_Completion_Notify Operational Primitive
   MUST be preceded by an invocation of the Put_Data or Get_Data
   Operational Primitive with the Notify_Enable qualifier set by the
   iSCSI layer at an earlier point in time.



<span class="grey">Chadalapaka, et al.          Informational                     [Page 24]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-25" id="page-25" name="page-25"> </a>
<span class="grey"><a href="rfc5047.html">RFC 5047</a>                           DA                       October 2007</span>


<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/10.2.3.%20%20Data%20Acknowledgement"></a><a class="selflink" href="#section-10.2.3" name="section-10.2.3">10.2.3</a>.  Data Acknowledgement</span>

   [<a id="ref-RFC3720" name="ref-RFC3720">RFC3720</a>] allows the iSCSI targets to optionally solicit data
   acknowledgement from the initiator for one or more Data-In PDUs, via
   setting of the A-bit on a Data-In PDU.  The Data_ACK_Notify
   Operational Primitive with the following input qualifiers is used by
   the target Datamover layer to notify the local iSCSI layer of the
   arrival of data acknowledgement of a previously solicited iSCSI read
   data acknowledgement.  This Operational Primitive thus is applicable
   only to iSCSI targets.

      a) Connection_Handle.

      b) ITT: Initiator Task Tag semantics as defined in [<a href="rfc3720.html" title='"Internet Small Computer Systems Interface (iSCSI)"'>RFC3720</a>].

      c) DataSN: of the next SCSI Data-In PDU, which immediately follows
         the SCSI Data-In PDU with the A-bit set to which this
         notification corresponds, with semantics as defined in
         [<a href="rfc3720.html" title='"Internet Small Computer Systems Interface (iSCSI)"'>RFC3720</a>].

   Every invocation of the Data_ACK_Notify Operational Primitive MUST be
   preceded by an invocation of the Put_Data Operational Primitive by
   the iSCSI target layer with the A-bit set to 1 at an earlier point in
   time.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/10.3.%20%20Interactions%20for%20Sending%20an%20iSCSI%20PDU"></a><a class="selflink" href="#section-10.3" name="section-10.3">10.3</a>.  Interactions for Sending an iSCSI PDU</span>

   This section discusses the model of interactions for sending each of
   the iSCSI PDUs defined in [<a href="rfc3720.html" title='"Internet Small Computer Systems Interface (iSCSI)"'>RFC3720</a>].  A Connection_Handle (see
   <a href="#section-5.3">Section 5.3</a>) is assumed to qualify each of these interactions so that
   the Datamover layer can route it to the appropriate Transport
   Connection.  The qualifying Connection_Handle is not explicitly
   listed in the subsequent sections.

   Note that the defined list of input qualifiers represents the
   semantically required set for the Datamover layer to consider in
   implementing the Primitive in each interaction described in this
   section (see <a href="#section-5.4">Section 5.4</a> for an elaboration).  Implementations may
   choose to deduce the qualifiers in ways that are optimized for the
   implementation specifics.  Two examples of this are:

      1. For SCSI command (<a href="#section-10.3.1">Section 10.3.1</a>), deducing the
         ImmediateDataSize input qualifier from the DataSegmentLength
         field of the SCSI Command PDU.

      2. For SCSI Data-Out (<a href="#section-10.3.5.1">Section 10.3.5.1</a>), deducing the
         DataDescriptorOut input qualifier from the associated SCSI
         command invocation qualifiers (assuming such state is



<span class="grey">Chadalapaka, et al.          Informational                     [Page 25]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-26" id="page-26" name="page-26"> </a>
<span class="grey"><a href="rfc5047.html">RFC 5047</a>                           DA                       October 2007</span>


         maintained) in conjunction with BHS fields of the SCSI Data-Out
         PDU.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/10.3.1.%20%20SCSI%20Command"></a><a class="selflink" href="#section-10.3.1" name="section-10.3.1">10.3.1</a>.  SCSI Command</span>

   The Send_Control Operational Primitive with the following input
   qualifiers is used for requesting the transmission of a SCSI Command
   PDU.

      a) BHS and AHS, if any, of the SCSI Command PDU as defined in
         [<a href="rfc3720.html" title='"Internet Small Computer Systems Interface (iSCSI)"'>RFC3720</a>].

      b) DataDescriptorOut: that defines the I/O Buffer meant for Data-
         Out for the entire command, in the case of a write or
         bidirectional command.

      c) DataDescriptorIn: that defines the I/O Buffer meant for Data-In
         for the entire command, in the case of a read or bidirectional
         command.

      d) ImmediateDataSize: that defines the number of octets of
         immediate unsolicited data for a write/bidirectional command.

      e) UnsolicitedDataSize: that defines the number of octets of
         immediate and non-immediate unsolicited data for a
         write/bidirectional command.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/10.3.2.%20%20SCSI%20Response"></a><a class="selflink" href="#section-10.3.2" name="section-10.3.2">10.3.2</a>.  SCSI Response</span>

   The Send_Control Operational Primitive with the following input
   qualifiers is used for requesting the transmission of a SCSI Response
   PDU.

      a) BHS of the SCSI Response PDU as defined in [<a href="rfc3720.html" title='"Internet Small Computer Systems Interface (iSCSI)"'>RFC3720</a>].

      b) DataDescriptorStatus: that defines the iSCSI buffer that
         contains the sense and response information for the command.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/10.3.3.%20%20Task%20Management%20Function%20Request"></a><a class="selflink" href="#section-10.3.3" name="section-10.3.3">10.3.3</a>.  Task Management Function Request</span>

   The Send_Control Operational Primitive with the following input
   qualifiers is used for requesting the transmission of a Task
   Management Function Request PDU.

      a) BHS of the Task Management Function Request PDU as defined in
         [<a href="rfc3720.html" title='"Internet Small Computer Systems Interface (iSCSI)"'>RFC3720</a>].





<span class="grey">Chadalapaka, et al.          Informational                     [Page 26]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-27" id="page-27" name="page-27"> </a>
<span class="grey"><a href="rfc5047.html">RFC 5047</a>                           DA                       October 2007</span>


      b) DataDescriptorOut: that defines the I/O Buffer meant for Data-
         Out for the entire command, in the case of a write or
         bidirectional command.  (Only valid if Function="TASK REASSIGN"
         - [<a href="rfc3720.html" title='"Internet Small Computer Systems Interface (iSCSI)"'>RFC3720</a>].)

      c) DataDescriptorIn: that defines the I/O Buffer meant for Data-In
         for the entire command, in the case of a read or bidirectional
         command.  (Only valid if Function="TASK REASSIGN" - [<a href="rfc3720.html" title='"Internet Small Computer Systems Interface (iSCSI)"'>RFC3720</a>].)

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/10.3.4.%20%20Task%20Management%20Function%20Response"></a><a class="selflink" href="#section-10.3.4" name="section-10.3.4">10.3.4</a>.  Task Management Function Response</span>

   The Send_Control Operational Primitive with the following input
   qualifier is used for requesting the transmission of a Task
   Management Function Response PDU.

      a) BHS of the Task Management Function Response PDU as defined in
         [<a href="rfc3720.html" title='"Internet Small Computer Systems Interface (iSCSI)"'>RFC3720</a>].

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/10.3.5.%20%20SCSI%20Data-Out%20and%20SCSI%20Data-In"></a><a class="selflink" href="#section-10.3.5" name="section-10.3.5">10.3.5</a>.  SCSI Data-Out and SCSI Data-In</span>

<span class="h5"><a class="dashAnchor" name="//apple_ref/Section/10.3.5.1.%20%20SCSI%20Data-Out"></a><a class="selflink" href="#section-10.3.5.1" name="section-10.3.5.1">10.3.5.1</a>.  SCSI Data-Out</span>

   The Send_Control Operational Primitive with the following input
   qualifiers is used by the initiator iSCSI layer for requesting the
   transmission of a SCSI Data-Out PDU carrying the non-immediate
   unsolicited data.

      a) BHS of the SCSI Data-Out PDU as defined in [<a href="rfc3720.html" title='"Internet Small Computer Systems Interface (iSCSI)"'>RFC3720</a>].

      b) DataDescriptorOut: that defines the I/O Buffer with the Data-
         Out to be carried in the iSCSI data segment of the PDU.

<span class="h5"><a class="dashAnchor" name="//apple_ref/Section/10.3.5.2.%20%20SCSI%20Data-In"></a><a class="selflink" href="#section-10.3.5.2" name="section-10.3.5.2">10.3.5.2</a>.  SCSI Data-In</span>

   The Put_Data Operational Primitive with the following input
   qualifiers is used by the target iSCSI layer for requesting the
   transmission of the data carried by a SCSI Data-In PDU.

      a) BHS of the SCSI Data-In PDU as defined in [<a href="rfc3720.html" title='"Internet Small Computer Systems Interface (iSCSI)"'>RFC3720</a>].

      b) DataDescriptorIn: that defines the I/O Buffer with the Data-In
         being requested for transmission.









<span class="grey">Chadalapaka, et al.          Informational                     [Page 27]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-28" id="page-28" name="page-28"> </a>
<span class="grey"><a href="rfc5047.html">RFC 5047</a>                           DA                       October 2007</span>


<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/10.3.6.%20%20Ready%20To%20Transfer%20%28R2T%29"></a><a class="selflink" href="#section-10.3.6" name="section-10.3.6">10.3.6</a>.  Ready To Transfer (R2T)</span>

   The Get_Data Operational Primitive with the following input
   qualifiers is used by the target iSCSI layer for requesting the
   retrieval of the data as specified by the semantic content of an R2T
   PDU.

      a) BHS of the Ready To Transfer PDU as defined in [<a href="rfc3720.html" title='"Internet Small Computer Systems Interface (iSCSI)"'>RFC3720</a>].

      b) DataDescriptorOut: that defines the I/O Buffer for the Data-Out
         being requested for retrieval.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/10.3.7.%20%20Asynchronous%20Message"></a><a class="selflink" href="#section-10.3.7" name="section-10.3.7">10.3.7</a>.  Asynchronous Message</span>

   The Send_Control Operational Primitive with the following input
   qualifiers is used for requesting the transmission of an Asynchronous
   Message PDU.

      a) BHS of the Asynchronous Message PDU as defined in [<a href="rfc3720.html" title='"Internet Small Computer Systems Interface (iSCSI)"'>RFC3720</a>].

      b) DataDescriptorSense: that defines an iSCSI buffer that contains
         the sense and iSCSI Event information.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/10.3.8.%20%20Text%20Request"></a><a class="selflink" href="#section-10.3.8" name="section-10.3.8">10.3.8</a>.  Text Request</span>

   The Send_Control Operational Primitive with the following input
   qualifiers is used for requesting the transmission of a Text Request
   PDU.

      a) BHS of the Text Request PDU as defined in [<a href="rfc3720.html" title='"Internet Small Computer Systems Interface (iSCSI)"'>RFC3720</a>].

      b) DataDescriptorTextOut: that defines the iSCSI Text Request
         buffer.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/10.3.9.%20%20Text%20Response"></a><a class="selflink" href="#section-10.3.9" name="section-10.3.9">10.3.9</a>.  Text Response</span>

   The Send_Control Operational Primitive with the following input
   qualifiers is used for requesting the transmission of a Text Response
   PDU.

      a) BHS of the Text Response PDU as defined in [<a href="rfc3720.html" title='"Internet Small Computer Systems Interface (iSCSI)"'>RFC3720</a>].

      b) DataDescriptorTextIn: that defines the iSCSI Text Response
         buffer.







<span class="grey">Chadalapaka, et al.          Informational                     [Page 28]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-29" id="page-29" name="page-29"> </a>
<span class="grey"><a href="rfc5047.html">RFC 5047</a>                           DA                       October 2007</span>


<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/10.3.10.%20%20Login%20Request"></a><a class="selflink" href="#section-10.3.10" name="section-10.3.10">10.3.10</a>.  Login Request</span>

   The Send_Control Operational Primitive with the following input
   qualifiers is used for requesting the transmission of a Login Request
   PDU.

      a) BHS of the Login Request PDU as defined in [<a href="rfc3720.html" title='"Internet Small Computer Systems Interface (iSCSI)"'>RFC3720</a>].

      b) DataDescriptorLoginRequest: that defines the iSCSI Login
         Request buffer.

   Note that specific Datamover protocols may choose to disallow the
   standard DA Primitives from being used for the iSCSI Login Phase.
   When used in conjunction with such Datamover protocols, an attempt to
   send a Login Request via the Send_Control Operational Primitive
   invocation is clearly an error scenario, as the Login Request PDU is
   being sent while the connection is in the iSCSI Full Feature Phase.
   It is outside the scope of this document to specify the resulting
   implementation behavior in this case -- [<a href="rfc3720.html" title='"Internet Small Computer Systems Interface (iSCSI)"'>RFC3720</a>] already defines the
   error handling for this error scenario.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/10.3.11.%20%20Login%20Response"></a><a class="selflink" href="#section-10.3.11" name="section-10.3.11">10.3.11</a>.  Login Response</span>

   The Send_Control Operational Primitive with the following input
   qualifiers is used for requesting the transmission of a Login
   Response PDU.

      a) BHS of the Login Response PDU as defined in [<a href="rfc3720.html" title='"Internet Small Computer Systems Interface (iSCSI)"'>RFC3720</a>].

      b) DataDescriptorLoginResponse: that defines the iSCSI Login
         Response buffer.

   Note that specific Datamover protocols may choose to disallow the
   standard DA Primitives from being used for the iSCSI Login Phase.
   When used in conjunction with such Datamover protocols, an attempt to
   send a Login Response via the Send_Control Operational Primitive
   invocation is clearly an error scenario, as the Login Response PDU is
   being sent while in the iSCSI Full Feature Phase.  It is outside the
   scope of this document to specify the resulting implementation
   behavior in this case -- [<a href="rfc3720.html" title='"Internet Small Computer Systems Interface (iSCSI)"'>RFC3720</a>] already defines the error handling
   for this error scenario.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/10.3.12.%20%20Logout%20Command"></a><a class="selflink" href="#section-10.3.12" name="section-10.3.12">10.3.12</a>.  Logout Command</span>

   The Send_Control Operational Primitive with the following input
   qualifier is used for requesting the transmission of a Logout Command
   PDU.




<span class="grey">Chadalapaka, et al.          Informational                     [Page 29]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-30" id="page-30" name="page-30"> </a>
<span class="grey"><a href="rfc5047.html">RFC 5047</a>                           DA                       October 2007</span>


      a) BHS of the Logout Command PDU as defined in [<a href="rfc3720.html" title='"Internet Small Computer Systems Interface (iSCSI)"'>RFC3720</a>].

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/10.3.13.%20%20Logout%20Response"></a><a class="selflink" href="#section-10.3.13" name="section-10.3.13">10.3.13</a>.  Logout Response</span>

   The Send_Control Operational Primitive with the following input
   qualifier is used for requesting the transmission of a Logout
   Response PDU.

      a) BHS of the Logout Response PDU as defined in [<a href="rfc3720.html" title='"Internet Small Computer Systems Interface (iSCSI)"'>RFC3720</a>].

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/10.3.14.%20%20SNACK%20Request"></a><a class="selflink" href="#section-10.3.14" name="section-10.3.14">10.3.14</a>.  SNACK Request</span>

   The Send_Control Operational Primitive with the following input
   qualifier is used for requesting the transmission of a SNACK Request
   PDU.

      a) BHS of the SNACK Request PDU as defined in [<a href="rfc3720.html" title='"Internet Small Computer Systems Interface (iSCSI)"'>RFC3720</a>].

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/10.3.15.%20%20Reject"></a><a class="selflink" href="#section-10.3.15" name="section-10.3.15">10.3.15</a>.  Reject</span>

   The Send_Control Operational Primitive with the following input
   qualifiers is used for requesting the transmission of a Reject PDU.

      a) BHS of the Reject PDU as defined in [<a href="rfc3720.html" title='"Internet Small Computer Systems Interface (iSCSI)"'>RFC3720</a>].

      b) DataDescriptorReject: that defines the iSCSI Reject buffer.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/10.3.16.%20%20NOP-Out"></a><a class="selflink" href="#section-10.3.16" name="section-10.3.16">10.3.16</a>.  NOP-Out</span>

   The Send_Control Operational Primitive with the following input
   qualifiers is used for requesting the transmission of a NOP-Out PDU.

      a) BHS of the NOP-Out PDU as defined in [<a href="rfc3720.html" title='"Internet Small Computer Systems Interface (iSCSI)"'>RFC3720</a>].

      b) DataDescriptorNOPOut: that defines the iSCSI Ping data buffer.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/10.3.17.%20%20NOP-In"></a><a class="selflink" href="#section-10.3.17" name="section-10.3.17">10.3.17</a>.  NOP-In</span>

   The Send_Control Operational Primitive with the following input
   qualifiers is used for requesting the transmission of a NOP-In PDU.

      a) BHS of the NOP-In PDU as defined in [<a href="rfc3720.html" title='"Internet Small Computer Systems Interface (iSCSI)"'>RFC3720</a>].

      b) DataDescriptorNOPIn: that defines the iSCSI Return Ping data
         buffer.






<span class="grey">Chadalapaka, et al.          Informational                     [Page 30]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-31" id="page-31" name="page-31"> </a>
<span class="grey"><a href="rfc5047.html">RFC 5047</a>                           DA                       October 2007</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/10.4.%20%20Interactions%20for%20Receiving%20an%20iSCSI%20PDU"></a><a class="selflink" href="#section-10.4" name="section-10.4">10.4</a>.  Interactions for Receiving an iSCSI PDU</span>

   The only PDUs that are received by an iSCSI layer operating on a
   Datamover layer are the iSCSI control-type PDUs.  The Datamover layer
   delivers the iSCSI control-type PDUs as they arrive, qualifying each
   with the Connection_Handle (see <a href="#section-5.3">Section 5.3</a>) that identifies the
   iSCSI connection for which the PDU is meant.  The subsequent
   processing of the iSCSI control-type PDUs proceeds as defined in
   [<a href="rfc3720.html" title='"Internet Small Computer Systems Interface (iSCSI)"'>RFC3720</a>].

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/10.4.1.%20%20General%20Control-Type%20PDU%20Notification"></a><a class="selflink" href="#section-10.4.1" name="section-10.4.1">10.4.1</a>.  General Control-Type PDU Notification</span>

   This sub-section describes the general mechanics applicable to
   several control-type PDUs.  The following sub-sections note
   additional considerations for control-type PDUs that are not covered
   in this sub-section.

   The Control_Notify Operational Primitive is used to notify the iSCSI
   layer of the arrival of the following iSCSI control-type PDUs: SCSI
   Command, SCSI Response, Task Management Function Request, Task
   Management Function Response, Asynchronous Message, Text Request,
   Text Response, Logout Command, Logout Response, SNACK, Reject, NOP-
   Out, NOP-In.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/10.4.2.%20%20SCSI%20Data%20Transfer%20PDUs"></a><a class="selflink" href="#section-10.4.2" name="section-10.4.2">10.4.2</a>.  SCSI Data Transfer PDUs</span>

<span class="h5"><a class="dashAnchor" name="//apple_ref/Section/10.4.2.1.%20%20SCSI%20Data-Out"></a><a class="selflink" href="#section-10.4.2.1" name="section-10.4.2.1">10.4.2.1</a>.  SCSI Data-Out</span>

   The Control_Notify Operational Primitive is used to notify the iSCSI
   layer of the arrival of a SCSI Data-Out PDU carrying the non-
   immediate unsolicited data.  Note however that the solicited SCSI
   Data-Out arriving on the target does not cause a notification to the
   iSCSI layer using the Control_Notify Primitive because the solicited
   SCSI Data-Out was not sent by the initiator iSCSI layer as control-
   type PDUs.

<span class="h5"><a class="dashAnchor" name="//apple_ref/Section/10.4.2.2.%20%20SCSI%20Data-In"></a><a class="selflink" href="#section-10.4.2.2" name="section-10.4.2.2">10.4.2.2</a>.  SCSI Data-In</span>

   The Datamover layer does not notify the iSCSI layer of the arrival of
   the SCSI Data-in at the initiator, because SCSI Data-in is an iSCSI
   data-type PDU (see <a href="#section-5.1">section 5.1</a>).  The iSCSI layer at the initiator
   however may infer the arrival of the SCSI Data-In when it receives a
   subsequent notification of the SCSI Response PDU via a Control_Notify
   invocation.

   While this document does not contemplate the possibility of a Data-In
   PDU being received at the initiator iSCSI layer, specific Datamover
   protocols may define how to deal with an unexpected inbound SCSI



<span class="grey">Chadalapaka, et al.          Informational                     [Page 31]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-32" id="page-32" name="page-32"> </a>
<span class="grey"><a href="rfc5047.html">RFC 5047</a>                           DA                       October 2007</span>


   Data-In PDU that may result in the initiator iSCSI layer receiving
   the Data-In PDU.  This document leaves the details of handling this
   error scenario to the specific Datamover protocols, so each may
   define the appropriate error handling specific to the Datamover
   environment.

<span class="h5"><a class="dashAnchor" name="//apple_ref/Section/10.4.2.3.%20%20Ready%20To%20Transfer%20%28R2T%29"></a><a class="selflink" href="#section-10.4.2.3" name="section-10.4.2.3">10.4.2.3</a>.  Ready To Transfer (R2T)</span>

   Because an R2T PDU is an iSCSI data-type PDU (see <a href="#section-5.1">Section 5.1</a>) that
   is not delivered as-is to the initiator iSCSI layer, the Datamover
   layer does not notify the iSCSI layer of the arrival of an R2T PDU.
   When an iSCSI node sends an R2T PDU to its local Datamover layer, the
   local and remote Datamover layers transparently bring about the data
   transfer requested by the R2T PDU.

   While this document does not contemplate the possibility of an R2T
   PDU being received at the initiator iSCSI layer, specific Datamover
   protocols may define how to deal with an unexpected inbound R2T PDU
   that may result in the initiator iSCSI layer receiving the R2T PDU.
   This document leaves the details of handling this error scenario to
   the specific Datamover protocols, so each may define the appropriate
   error handling specific to the Datamover environment.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/10.4.3.%20%20Login%20Request"></a><a class="selflink" href="#section-10.4.3" name="section-10.4.3">10.4.3</a>.  Login Request</span>

   The Control_Notify Operational Primitive is used for notifying the
   target iSCSI layer of the arrival of a Login Request PDU.  Note that
   specific Datamover protocols may choose to disallow the standard DA
   Primitives from being used for the iSCSI Login Phase.  When used in
   conjunction with such Datamover protocols, the arrival of a Login
   Request necessitating the Control_Notify Operational Primitive
   invocation is clearly an error scenario, as the Login Request PDU is
   arriving in the iSCSI Full Feature Phase.  It is outside the scope of
   this document to specify the resulting implementation behavior in
   this case -- [<a href="rfc3720.html" title='"Internet Small Computer Systems Interface (iSCSI)"'>RFC3720</a>] already defines the error handling in this
   error scenario.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/10.4.4.%20%20Login%20Response"></a><a class="selflink" href="#section-10.4.4" name="section-10.4.4">10.4.4</a>.  Login Response</span>

   The Control_Notify Operational Primitive is used to notify the
   initiator iSCSI layer of the arrival of a Login Response PDU.  Note
   that specific Datamover protocols may choose to disallow the standard
   DA Primitives from being used for the iSCSI Login Phase.  When used
   in conjunction with such Datamover protocols, the arrival of a Login
   Response necessitating the Control_Notify Operational Primitive
   invocation is clearly an error scenario, as the Login Response PDU is
   arriving in the iSCSI Full Feature Phase.  It is outside the scope of
   this document to specify the resulting implementation behavior in



<span class="grey">Chadalapaka, et al.          Informational                     [Page 32]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-33" id="page-33" name="page-33"> </a>
<span class="grey"><a href="rfc5047.html">RFC 5047</a>                           DA                       October 2007</span>


   this case -- [<a href="rfc3720.html" title='"Internet Small Computer Systems Interface (iSCSI)"'>RFC3720</a>] already defines the error handling in this
   error scenario.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/11.%20%20Security%20Considerations"></a><a class="selflink" href="#section-11" name="section-11">11</a>.  Security Considerations</span>

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/11.1.%20%20Architectural%20Considerations"></a><a class="selflink" href="#section-11.1" name="section-11.1">11.1</a>.  Architectural Considerations</span>

   DA enables compliant iSCSI implementations to realize a control and
   data separation in the way they interact with their Datamover
   protocols.  Note however that this separation does not imply a
   separation in transport mediums between control traffic and data
   traffic -- the basic iSCSI architecture with respect to tasks and PDU
   relationships to tasks remains unchanged.  [<a href="rfc3720.html" title='"Internet Small Computer Systems Interface (iSCSI)"'>RFC3720</a>] defines several
   MUST requirements on ordering relationships across control and data
   for a given task besides a mandatory deterministic task allegiance
   model -- DA does not change this basic architecture (DA has a
   normative reference to [<a href="rfc3720.html" title='"Internet Small Computer Systems Interface (iSCSI)"'>RFC3720</a>]) for allow any additional
   flexibility in compliance in this area.  To summarize, sending bulk
   data transfers (prompted by Put_Data and Get_Data Primitive
   invocations) on a different transport medium would be as ill-advised
   as sending just the Data-Out/Data-In PDUs on a different TCP
   connection in <a href="rfc3720.html">RFC 3720</a>-based iSCSI implementations.  Consequently,
   all the iSCSI-related security text in [<a href="rfc3723.html" title='"Securing Block Storage Protocols over IP"'>RFC3723</a>] is directly
   applicable to a DA-enabled iSCSI implementation.

   Another area with security implications is the Datamover connection
   resource management model, which DA defines -- particularly the
   Allocate_Connection_Resources Primitive.  An inadvertent realization
   of this model could leave an iSCSI implementation exposed to denial-
   of-service attacks.  As Figures 2 and 3 in <a href="#section-13.2">Section 13.2</a> illustrate,
   the most effective countermeasure to this potential attack consists
   of performing the Datamover resource allocation when the iSCSI layer
   is sufficiently far along in the iSCSI Login Phase that it is
   reasonably certain that the peer side is not an attacker.  In
   particular, if the Login Phase includes a SecurityNegotiation stage,
   an iSCSI end node MUST defer the Datamover connection resource
   allocation (i.e., invoking the Allocate_Connection_Resources
   Primitive) to the LoginOperationalNegotiation stage [<a href="rfc3720.html" title='"Internet Small Computer Systems Interface (iSCSI)"'>RFC3720</a>] so that
   the resource allocation happens post-authentication.  This
   considerably minimizes the potential for a denial-of service attack.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/11.2.%20%20Wire%20Protocol%20Considerations"></a><a class="selflink" href="#section-11.2" name="section-11.2">11.2</a>.  Wire Protocol Considerations</span>

   In view of the fact that the DA architecture itself does not define
   any new wire protocol or propose modifications to the existing
   protocols, there are no additional wire protocol security
   considerations in employing DA itself.  However, a DA-compliant iSCSI
   implementation MUST comply with all the iSCSI-related requirements



<span class="grey">Chadalapaka, et al.          Informational                     [Page 33]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-34" id="page-34" name="page-34"> </a>
<span class="grey"><a href="rfc5047.html">RFC 5047</a>                           DA                       October 2007</span>


   stipulated in [<a href="rfc3723.html" title='"Securing Block Storage Protocols over IP"'>RFC3723</a>] and [<a href="rfc3720.html" title='"Internet Small Computer Systems Interface (iSCSI)"'>RFC3720</a>].  Note further that in
   realizing DA, each Datamover protocol must define and elaborate as
   appropriate on any additional security considerations resulting from
   the use of that Datamover protocol.

   All Datamover protocol designers are strongly recommended to refer to
   [<a href="#ref-RDDPSEC" title='"Direct Data Placement Protocol (DDP) / Remote Direct Memory Access Protocol (RDMAP) Security"'>RDDPSEC</a>] for the types of security issues to consider.  While
   [<a href="#ref-RDDPSEC" title='"Direct Data Placement Protocol (DDP) / Remote Direct Memory Access Protocol (RDMAP) Security"'>RDDPSEC</a>] elaborates on the security considerations applicable to an
   RDDP-based Datamover [<a href="#ref-iSER" title='"Internet Small Computer System Interface (iSCSI) Extensions for Remote Direct Memory Access (RDMA)"'>iSER</a>], the document is representative of the
   type of analysis of resource exhaustion and the application of
   countermeasures that need to be done for any Datamover protocol.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/12.%20%20References"></a><a class="selflink" href="#section-12" name="section-12">12</a>.  References</span>

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/12.1.%20%20Normative%20References"></a><a class="selflink" href="#section-12.1" name="section-12.1">12.1</a>.  Normative References</span>

   [<a id="ref-RFC3720" name="ref-RFC3720">RFC3720</a>] Satran, J., Meth, K., Sapuntzakis, C., Chadalapaka, M., and
             E. Zeidner, "Internet Small Computer Systems Interface
             (iSCSI)", <a href="rfc3720.html">RFC 3720</a>, April 2004.

   [<a id="ref-RFC3723" name="ref-RFC3723">RFC3723</a>] Aboba, B., Tseng, J., Walker, J., Rangan, V., and F.
             Travostino, "Securing Block Storage Protocols over IP", <a href="rfc3723.html">RFC</a>
             <a href="rfc3723.html">3723</a>, April 2004.

   [<a id="ref-RFC2119" name="ref-RFC2119">RFC2119</a>] Bradner, S., "Key words for use in RFCs to Indicate
             Requirement Levels", <a href="https://tools.ietf.org/html/bcp14">BCP 14</a>, <a href="rfc2119.html">RFC 2119</a>, March 1997.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/12.2.%20%20Informative%20References"></a><a class="selflink" href="#section-12.2" name="section-12.2">12.2</a>.  Informative References</span>

   [<a id="ref-DDP" name="ref-DDP">DDP</a>]     Shah, H., Pinkerton, J., Recio, R., and P. Culley, "Direct
             Data Placement over Reliable Transports", <a href="rfc5041.html">RFC 5041</a>, October
             2007.

   [<a id="ref-iSER" name="ref-iSER">iSER</a>]    Ko, M., Chadalapaka, M., Hufferd, J., Elzur, U., Shah, H.,
             and P. Thaler, "Internet Small Computer System Interface
             (iSCSI) Extensions for Remote Direct Memory Access (RDMA)",
             <a href="rfc5046.html">RFC 5046</a>, October 2007.

   [<a id="ref-RDDPSEC" name="ref-RDDPSEC">RDDPSEC</a>] Pinkerton, J. and E. Deleganes, "Direct Data Placement
             Protocol (DDP) / Remote Direct Memory Access Protocol
             (RDMAP) Security", <a href="rfc5042.html">RFC 5042</a>, October 2007.










<span class="grey">Chadalapaka, et al.          Informational                     [Page 34]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-35" id="page-35" name="page-35"> </a>
<span class="grey"><a href="rfc5047.html">RFC 5047</a>                           DA                       October 2007</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/Appendix%20A.%20%20Design%20Considerations%20and%20Examples"></a><a class="selflink" href="#appendix-A" name="appendix-A">Appendix A</a>.  Design Considerations and Examples</span>

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/A.1.%20%20Design%20Considerations%20for%20a%20Datamover%20Protocol"></a><a class="selflink" href="#appendix-A.1" name="appendix-A.1">A.1</a>.  Design Considerations for a Datamover Protocol</span>

   This section discusses the specific considerations for RDMA-based and
   RDDP-based Datamover protocols.

      a) Note that the modeling of interactions for SCSI Data-Out
         (<a href="#section-10.3.5.1">Section 10.3.5.1</a>) is only used for unsolicited data transfer.

      b) The modeling of interactions for SNACK (Sections <a href="#section-10.3.14">10.3.14</a> and
         10.4.1) is not expected to be used given that one of the design
         requirements on the Datamover is that it "guarantees an error-
         free, reliable, in-order transport mechanism" (<a href="#section-6">Section 6</a>).  The
         interactions for sending and receiving a SNACK are nevertheless
         modeled in this document because the receiving iSCSI layer can
         deterministically deal with an inadvertent SNACK.  This also
         shows the DA designers' intent that DI is not meant to filter
         certain types of PDUs.

      c) The onus is on a reliable Datamover (per requirements stated in
         <a href="#section-6">Section 6</a>) to realize end-to-end data acknowledgements via
         Datamover-specific means.  In view of this, even use of data-
         ACK-type SNACKs are unnecessary.  Consequently, an initiator
         may never request sending a SNACK Request in this model
         assuming that the proactive (timeout-driven) SNACK
         functionality is turned off in the legacy iSCSI code.

      d) Note that the current DA model for bootstrapping a
         Connection_Handle into service -- i.e., associating a new iSCSI
         connection with a Connection_Handle -- clearly implies that the
         iSCSI connection must already be in Full Feature Phase when the
         Datamover layer comes into the stack.  This further implies
         that the iSCSI Login Phase must be carried out in the
         traditional "Byte streaming mode" with no assistance or
         involvement from the Datamover layer.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/A.2.%20%20Examples%20of%20Datamover%20Interactions"></a><a class="selflink" href="#appendix-A.2" name="appendix-A.2">A.2</a>.  Examples of Datamover Interactions</span>

   The figures described in this section provide some examples of the
   usage of Operational Primitives in interactions between the iSCSI
   layer and the Datamover layer.  The following abbreviations are used
   in this section.

   Avail - Available

   Abted - Aborted




<span class="grey">Chadalapaka, et al.          Informational                     [Page 35]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-36" id="page-36" name="page-36"> </a>
<span class="grey"><a href="rfc5047.html">RFC 5047</a>                           DA                       October 2007</span>


   Buf - I/O Buffer

   Cmd - Command

   Compl - Complete

   Conn - Connection

   Ctrl_Ntfy - Control_Notify

   Dal_Tk_Res - Deallocate_Task_Resources

   Data_Cmp_Nfy - Data_Completion_Notify

   Data_ACK_Nfy - Data_ACK_Notify

   DM - Datamover

   Imm - Immediate

   Snd_Ctrl - Send_Control

   Msg - Message

   Resp - Response

   Sol - Solicited

   TMF Req - Task Management Function Request

   TMF Res - Task Management Function Response

   Trans - Transfer

   Unsol - Unsolicited
















<span class="grey">Chadalapaka, et al.          Informational                     [Page 36]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-37" id="page-37" name="page-37"> </a>
<span class="grey"><a href="rfc5047.html">RFC 5047</a>                           DA                       October 2007</span>


         |   | Allocate_Connection_Resources  | D |    ^
         |   |-------------------------------&gt;| a |    |
         |   |    Connection resources are    | t |    |
         | i |     successfully allocated     | a |    |   iSCSI
         | S |                                | m |    |   Login
         | C |                                | o |    |   Phase
         | S |                                | v |    |
         | I |                                | e |    |
         |   |                                | r |    | Login Phase
         | L | Final Login Response (success)          v succeeds
         | a |&lt;----------------------------------------^
         | y |                                | L |    |   iSCSI
         | e |       Enable_Datamover         | a |    |   Full
         | r |-------------------------------&gt;| y |    |   Feature
         |   |     Datamover is enabled       | e |    |   Phase
         |   |                                | r |    |
         |   |   Full Feature Phase           |   |    |
         |   |   control and data Transfer    |   |    v

           Figure 2.  A Successful iSCSI Login on Initiator


         |   | Notice_Key_Values              |   |      |
         |   |-------------------------------&gt;|   |      |
         |   |  Datamover layer is notified   |   |      |
         |   |  of the negotiated key values  |   |      |
         |   |                                |   |      |
         |   | Allocate_Connection_Resources  |   |      |
         |   |-------------------------------&gt;| D |      |
         |   |    Connection resources are    | a |      |
         | i |     successfully allocated     | t |      |   iSCSI
         | S |                                | a |      |   Login
         | C |                                | m |Final |   Phase
         | S |                                | o |Login |
         | I |Enable_Datamover(Login Response)| v |Resp  |
         |   |-------------------------------&gt;| e |----&gt;vLogin Phase
         | L |     Datamover is enabled       | r |      ^ succeeds
         | a |                                |   |      |
         | y |                                | L |      |   iSCSI
         | e |                                | a |      |   Full
         | r |                                | y |      |   Feature
         |   |                                | e |      |   Phase
         |   |      Full Feature Phase        | r |      |
         |   |   control and data Transfer    |   |      |
         |   |                                |   |      v

           Figure 3.  A Successful iSCSI Login on Target




<span class="grey">Chadalapaka, et al.          Informational                     [Page 37]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-38" id="page-38" name="page-38"> </a>
<span class="grey"><a href="rfc5047.html">RFC 5047</a>                           DA                       October 2007</span>


         |   | Allocate_Connection_Resources  | D |      ^
         |   |-------------------------------&gt;| a |      |
         |   |    Connection resources are    | t |      |
         | i |     successfully allocated     | a |      |   iSCSI
         | S |                                | m |      |   Login
         | C |                                | o |      |   Phase
         | S |                                | v |      |
         | I |                                | e |      |
         |   |                                | r |      | Login
         |   |                                |   |      | Phase
         | L | Final Login Response (failure)            v fails
         | a |&lt;------------------------------------------
         | y |                                | L |
         | e | Deallocate_Connection_Resources| a |
         | r |-------------------------------&gt;| y |
         |   |     Datamover-specific         | e |
         |   |     connection resources freed | r |
         |   |                                |   |
         |   |
         |   | Connection terminated by standard means
         |   |---------------------------------------------&gt;

            Figure 4.  A Failed iSCSI Login on Initiator


         |   | Allocate_Connection_Resources  | D |      ^
         |   |-------------------------------&gt;| a |      |
         |   |    Connection resources are    | t |      |
         | i |     successfully allocated     | a |      |   iSCSI
         | S |                                | m |      |   Login
         | C |                                | o |      |   Phase
         | S |                                | v |      |
         | I |                                | e |      |
         |   |                                | r |      | Login
         |   |                                |   |      | Phase
         | L | Final Login Response (failure)            v fails
         | a |----------------------------------------------&gt;
         | y |                                | L |
         | e | Deallocate_Connection_Resources| a |
         | r |-------------------------------&gt;| y |
         |   |     Datamover-specific         | e |
         |   |     connection resources freed | r |
         |   |                                |   |
         |   |
         |   | Connection terminated by standard means
         |   |--------------------------------------------&gt;

             Figure 5.  A Failed iSCSI Login on Target



<span class="grey">Chadalapaka, et al.          Informational                     [Page 38]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-39" id="page-39" name="page-39"> </a>
<span class="grey"><a href="rfc5047.html">RFC 5047</a>                           DA                       October 2007</span>



         |   | Allocate_Connection_Resources  | D |     ^
         |   |-------------------------------&gt;| a |     |
         |   |    Connection resources are    | t |     |
         | i |     successfully allocated     | a |     |   iSCSI
         | S |                                | m |     |   Login
         | C |                                | o |     |   Phase
         | S |                                | v |     |
         | I |                                | e |     |
         |   |                                | r |     |
         | L | Login non-Final Request/Response         |
         | a |&lt;-----------------------------------------|
         | y |    iSCSI layer decides not to  | L |     |
         | e |    enable Datamover for this   | a |     |
         | r |    connection                  | y |     |
         |   |                                | e |     |
         |   | Deallocate_Connection_Resources| r |     |
         |   |-------------------------------&gt;|   |     |
         |   |     All Datamover-specific     |   |     |
         |   |     resources deallocated      |   |     |
         |   |                                |   |     | Login
         |   |                                |   |     | Phase
         |   |                                          | continues
         |   | Regular Login negotiation continues      |
         |   |&lt;----------------------------------------&gt;|
         |   |                                          .
         |   |                                          .
         |   |                                          .

          Figure 6.  iSCSI Does Not Enable the Datamover





















<span class="grey">Chadalapaka, et al.          Informational                     [Page 39]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-40" id="page-40" name="page-40"> </a>
<span class="grey"><a href="rfc5047.html">RFC 5047</a>                           DA                       October 2007</span>


         |   |                                |   |   ^
         |   |  Full Feature Phase Control &amp;  |   |   |
         |   |    Data Transfer Using DM      | D |   | iSCSI
         |   |                                | a |   | Full Feature
         | i |                                | t |   | Phase
         | S |                                | a |   | (DM Enabled)
         | C |                                | m |   |
         | S |    Successful iSCSI Logout     | o |   |
         | I |                                | v |   v
         |   |     Connection_Terminate       | e |
         | L |-------------------------------&gt;| r |
         | a |   Connection is terminated     |   |
         | y |   Datamover-specific resources | L | Transport
         | e |   deallocated, both connection | a | Connection
         | r |   level &amp; task level           | y | is terminated
         |   |                                | e |
         |   |                                | r |
         |   |                                |   |
         |   |                                |   |

           Figure 7.  A Normal iSCSI Connection Termination


         |   |                                |   |   ^
         |   |  Full Feature Phase Control &amp;  | D |   | iSCSI
         |   |    Data Transfer Using DM      | a |   | Full Feature
         | i |                                | t |   | Phase
         | S |                                | a |   | (DM Enabled)
         | C |                                | m |   v
         | S |                                | o |&lt;--Transport
         | I |   Datamover-specific resources | v | Connection
         |   |   deallocated, both connection | e | Terminated (e.g.
         | L |   level &amp; task level           | r | unexpected
         | a |                                |   | FIN/RESET)
         | y |                                | L |
         | e |   Connection_Terminate_Notify  | a |
         | r |&lt;-------------------------------| y |
         |   |                                | e |
         |   |                                | r |
         |   |                                |   |

           Figure 8.  An Abnormal iSCSI Connection Termination









<span class="grey">Chadalapaka, et al.          Informational                     [Page 40]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-41" id="page-41" name="page-41"> </a>
<span class="grey"><a href="rfc5047.html">RFC 5047</a>                           DA                       October 2007</span>


        &lt;-----Initiator-----&gt;                &lt;-------Target-------&gt;

        |  |          |  | DM Msg holding |  |            |  |
   SCSI |  |          |  | SCSI Cmd PDU &amp; |  |            |  |SCSI
   Cmd  |  | Snd_Ctrl |  |Unsol Imm Data  |  |Ctrl_Notify |  |Cmd
   ----&gt;|  |---------&gt;|  |---------------&gt;|  |-----------&gt;|  |---&gt;
        |  |          |  |                |  |            |  |
        |  |          |  | DM Msg holding |  |            |  |
        |  | Snd_Ctrl |  |SCSI Dataout PDU|  |Ctrl_Notify |  |
        |  |---------&gt;|  |---------------&gt;|  |-----------&gt;|  |
        |  |    .     |  |        .       |  |     .      |  |Unsol
        |  |    .     | D|        .       | D|     .      |  |Data
        |  |    .     | a| DM Msg holding | a|     .      |  |Trans
        | i| Snd_Ctrl | t|SCSI Dataout PDU| t|Ctrl_Notify | i|
        | S|---------&gt;| a|---------------&gt;| a|-----------&gt;| S|
        | C|          | m|                | m|            | C|Buf
        | S|          | o|                | o|            | S|Avail
        | I|          | v|                | v|  Get_Data  | I|(R2T)
        |  |          | e|----------------| e|&lt;-----------|  |&lt;----
        | L|          | r||Solicited Data | r|            | L|  .
        | a|          |  ||  Transfer     |  |            | a|  .
        | y|          | L|---------------&gt;| L|      .     | y|Buf
        | e|          | a|        .       | a|      .     | e|Avail
        | r|          | y|        .       | y|  Get_Data  | r|(R2T)
        |  |          | e|----------------| e|&lt;-----------|  |&lt;----
        |  |          | r||Solicited Data | r|            |  |
        |  |          |  ||   Transfer    |  |            |  |
        |  |          |  |---------------&gt;|  |Data_Cmp_Nfy|  |Data
        |  |          |  |                |  |-----------&gt;|  |Trans
        |  |          |  |                |  |            |  |Compl
        |  |          |  | DM Msg holding |  |            |  |
   SCSI |  |          |  |SCSI Resp PDU &amp; |  |            |  |SCSI
   Resp |  |Ctrl_Ntfy |  |  Sense Data    |  |  Snd_Ctrl  |  |Resp
   &lt;----|  |&lt;---------|  |&lt;---------------|  |&lt;-----------|  |&lt;----
        |  |          |  |                |  |            |  |

                 Figure 9.  A SCSI Write Data Transfer














<span class="grey">Chadalapaka, et al.          Informational                     [Page 41]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-42" id="page-42" name="page-42"> </a>
<span class="grey"><a href="rfc5047.html">RFC 5047</a>                           DA                       October 2007</span>


        &lt;-----Initiator-----&gt;                &lt;-------Target-------&gt;

        |  |          |  |                |  |            |  |
   SCSI |  |          |  | DM Msg holding |  |            |  |SCSI
   Cmd  |  | Snd_Ctrl |  |  SCSI Cmd PDU  |  |Ctrl_Notify |  |Cmd
   ----&gt;|  |---------&gt;|  |---------------&gt;|  |-----------&gt;|  |---&gt;
        |  |          |  |                |  |            |  |
        |  |          | D|    SCSI Read   | D|            |  |Buf
        |  |          | a|  Data Transfer | a|  Put_Data  |  |Avail
        | i|          | t|&lt;---------------| t|&lt;-----------| i|&lt;----
        | S|          | a|        .       | a|     .      | S|  .
        | C|          | m|        .       | m|     .      | C|  .
        | S|          | o|        .       | o|     .      | S|  .
        | I|          | v|    SCSI Read   | v|     .      | I|Buf
        |  |          | e|  Data Transfer | e|  Put_Data  |  |Avail
        | L|          | r|&lt;---------------| r|&lt;-----------| L|&lt;----
        | a|          |  |                |  |            | a|
        | y|          | L|                | L|            | y|
        | e|          | a|                | a|Data_Cmp_Nfy| e|Data
        | r|          | y|                | y|-----------&gt;| r|Trans
        |  |          | e|                | e|            |  |Compl
        |  |          | r| DM Msg holding | r|            |  |
   SCSI |  |          |  |SCSI Resp PDU &amp; |  |            |  |SCSI
   Resp |  |Ctrl_Ntfy |  |  Sense Data    |  |  Snd_Ctrl  |  |Resp
   &lt;----|  |&lt;---------|  |&lt;---------------|  |&lt;-----------|  |&lt;----
        |  |          |  |                |  |            |  |

                 Figure 10.  A SCSI Read Data Transfer























<span class="grey">Chadalapaka, et al.          Informational                     [Page 42]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-43" id="page-43" name="page-43"> </a>
<span class="grey"><a href="rfc5047.html">RFC 5047</a>                           DA                       October 2007</span>


        &lt;-----Initiator-----&gt;                &lt;-------Target-------&gt;

        |  |          |  |                |  |            |  |
   SCSI |  |          |  | DM Msg holding |  |            |  |SCSI
   Cmd  |  | Snd_Ctrl |  |  SCSI Cmd PDU  |  |Ctrl_Notify |  |Cmd
   ----&gt;|  |---------&gt;|  |---------------&gt;|  |-----------&gt;|  |----&gt;
        |  |          |  |                |  |            |  |
        |  |          | D|    SCSI Read   | D|  Put_Data  |  |Buf
        |  |          | a|  Data Transfer | a|Data_in.A=1 |  |Avail
        | i|          | t|&lt;---------------| t|&lt;-----------| i|&lt;----
        | S|          | a|        .       | a|     .      | S|  .
        | C|          | m|        .       | m|Data_ACK_Nfy| C|  .
        | S|          | o|                | o|-----------&gt;| S|  .
        | I|          | v|                | v|     .      | I|
        |  |          | e|                | e|     .      |  |
        | L|          | r|                | r|            | L|
        | a|          |  |                |  |            | a|
        | y|          | L|                | L|            | y|
        | e|          | a|                | a|            | e|Data
        | r|          | y|                | y|            | r|Trans
        |  |          | e|                | e|            |  |Compl
        |  |          | r| DM Msg holding | r|            |  |
   SCSI |  |          |  |SCSI Resp PDU &amp; |  |            |  |SCSI
   Resp |  |Ctrl_Ntfy |  |  Sense Data    |  |  Snd_Ctrl  |  |Resp
   &lt;----|  |&lt;---------|  |&lt;---------------|  |&lt;-----------|  |&lt;----
        |  |          |  |                |  |            |  |

           Figure 11.  A SCSI Read Data Acknowledgement























<span class="grey">Chadalapaka, et al.          Informational                     [Page 43]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-44" id="page-44" name="page-44"> </a>
<span class="grey"><a href="rfc5047.html">RFC 5047</a>                           DA                       October 2007</span>


        &lt;-----Initiator-----&gt;                &lt;-------Target-------&gt;

        |  |          |  |                |  |            |  |
   SCSI |  |          |  | DM Msg holding |  |            |  |SCSI
   Cmd  |  | Snd_Ctrl |  |  SCSI Cmd PDU  |  |Ctrl_Notify |  |Cmd
   ----&gt;|  |---------&gt;|  |---------------&gt;|  |-----------&gt;|  |----&gt;
        |  |          |  |                |  |            |  |
        |  |          | D|    SCSI Read   | D|            |  |Buf
        |  |          | a|  Data Transfer | a|  Put_Data  |  |Avail
        | i|          | t|&lt;---------------| t|&lt;-----------| i|&lt;----
        | S|          | a|        .       | a|     .      | S|  .
   Abort| C|          | m| DM Msg holding | m|     .      | C|Abort
   Task | S| Snd_Ctrl | o|  Abort TMF Req | o|Ctrl_Notify | S|Task
   ----&gt;| I|---------&gt;| v|---------------&gt;| v|-----------&gt;| I|----&gt;
        |  |          | e|       .        | e|     .      |  |
   Abort| L|          | r|  DM Msg holding| r|            | L| .
   Done | a|Ctrl_Ntfy |  |   Abort TMF Res|  | Snd_Ctrl   |  |Abted
   &lt;----| y|&lt;---------| L|&lt;---------------| L|&lt;-----------| y|&lt;----
        | e|          | a|                | a|            | e|
        | r|          | y|                | y|            | r|
        |  |          | e|                | e|            |  |
        |  |          | r|                | r|            |  |
        |  |          |  |                |  |            |  |
        |  |Dal_Tk_Res|  |                |  |Dal_Tk_Res  |  |
        |  |---------&gt;|  |                |  |&lt;-----------|  |
        |  |          |  |                |  |            |  |

            Figure 12.  Task Resource Cleanup on Abort

Acknowledgements

   The IP Storage (IPS) Working Group in the Transport Area of
   IETF has been responsible for defining the iSCSI protocol
   (apart from a host of other relevant IP Storage protocols).
   The authors are grateful to the entire working group, whose
   work allowed this document to build on the concepts and
   details of the iSCSI protocol.

   In addition, the following individuals reviewed and
   contributed to the improvement of this document.  The authors
   are grateful for their contribution.

   John Carrier
   Adaptec, Inc.
   691 S. Milpitas Blvd., Milpitas, CA 95035, USA
   Phone: +1 (360) 378-8526
   EMail: john_carrier@adaptec.com




<span class="grey">Chadalapaka, et al.          Informational                     [Page 44]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-45" id="page-45" name="page-45"> </a>
<span class="grey"><a href="rfc5047.html">RFC 5047</a>                           DA                       October 2007</span>


   Hari Ghadia
   Adaptec, Inc.
   691 S. Milpitas Blvd., Milpitas, CA 95035, USA
   Phone: +1 (408) 957-5608
   EMail: hari_ghadia@adaptec.com

   Hari Mudaliar
   Adaptec, Inc.
   691 S. Milpitas Blvd., Milpitas, CA 95035, USA
   Phone: +1 (408) 957-6012
   EMail: hari_mudaliar@adaptec.com

   Patricia Thaler
   Agilent Technologies, Inc.
   1101 Creekside Ridge Drive, #100, M/S-RG10,
   Roseville, CA 95678, USA
   Phone: +1-916-788-5662
   EMail: pat_thaler@agilent.com

   Uri Elzur
   Broadcom Corporation
   16215 Alton Parkway, Irvine, CA 92619-7013, USA
   Phone: +1 (949) 585-6432
   EMail: Uri@Broadcom.com

   Mike Penna
   Broadcom Corporation
   16215 Alton Parkway,Irvine, CA 92619-7013, USA
   Phone: +1 (949) 926-7149
   EMail: MPenna@Broadcom.com

   David Black
   EMC Corporation
   176 South St., Hopkinton, MA 01748, USA
   Phone: +1 (508) 293-7953
   EMail: black_david@emc.com

   Ted Compton
   EMC Corporation
   Research Triangle Park, NC 27709, USA
   Phone: +1-919-248-6075
   EMail: compton_ted@emc.com

   Dwight Barron
   Hewlett-Packard Company
   20555 SH 249, Houston, TX 77070-2698, USA
   Phone: +1 (281) 514-2769
   EMail: Dwight.Barron@Hp.com



<span class="grey">Chadalapaka, et al.          Informational                     [Page 45]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-46" id="page-46" name="page-46"> </a>
<span class="grey"><a href="rfc5047.html">RFC 5047</a>                           DA                       October 2007</span>


   Paul R. Culley
   Hewlett-Packard Company
   20555 SH 249, Houston, TX 77070-2698, USA
   Phone: +1 (281) 514-5543
   EMail: paul.culley@hp.com

   Dave Garcia
   Hewlett-Packard Company
   19333 Vallco Parkway, Cupertino, CA 95014, USA
   Phone: +1 (408) 285-6116
   EMail: dave.garcia@hp.com

   Randy Haagens
   Hewlett-Packard Company
   8000 Foothills Blvd, MS 5668, Roseville CA, USA
   Phone: +1-916-785-4578
   EMail: randy_haagens@hp.com

   Jeff Hilland
   Hewlett-Packard Company
   20555 SH 249, Houston, TX 77070-2698, USA
   Phone: +1 (281) 514-9489
   EMail: jeff.hilland@hp.com

   Mike Krause
   Hewlett-Packard Company, 43LN
   19410 Homestead Road, Cupertino, CA 95014, USA
   Phone: +1 (408) 447-3191
   EMail: krause@cup.hp.com

   Jim Wendt
   Hewlett-Packard Company
   8000 Foothills Blvd, MS 5668, Roseville CA, USA
   Phone: +1-916-785-5198
   EMail: jim_wendt@hp.com

   Mike Ko
   IBM
   650 Harry Rd, San Jose, CA 95120, USA
   Phone: +1 (408) 927-2085
   EMail: mako@us.ibm.com

   Renato Recio
   IBM Corporation
   11501 Burnett Road, Austin, TX 78758, USA
   Phone: +1 (512) 838-1365
   EMail: recio@us.ibm.com




<span class="grey">Chadalapaka, et al.          Informational                     [Page 46]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-47" id="page-47" name="page-47"> </a>
<span class="grey"><a href="rfc5047.html">RFC 5047</a>                           DA                       October 2007</span>


   Howard C. Herbert
   Intel Corporation
   MS CH7-404,5000 West Chandler Blvd., Chandler, AZ 85226, USA
   Phone: +1 (480) 554-3116
   EMail: howard.c.herbert@intel.com

   Dave Minturn
   Intel Corporation
   MS JF1-210, 5200 North East Elam Young Parkway
   Hillsboro, OR 97124, USA
   Phone: +1 (503) 712-4106
   EMail: dave.b.minturn@intel.com

   James Pinkerton
   Microsoft Corporation
   One Microsoft Way, Redmond, WA 98052, USA
   Phone: +1 (425) 705-5442
   EMail: jpink@microsoft.com

   Tom Talpey
   Network Appliance
   375 Totten Pond Road, Waltham, MA 02451, USA
   Phone: +1 (781) 768-5329
   EMail: thomas.talpey@netapp.com



























<span class="grey">Chadalapaka, et al.          Informational                     [Page 47]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-48" id="page-48" name="page-48"> </a>
<span class="grey"><a href="rfc5047.html">RFC 5047</a>                           DA                       October 2007</span>


Authors' Addresses

   Mallikarjun Chadalapaka
   Hewlett-Packard Company
   8000 Foothills Blvd.
   Roseville, CA 95747-5668, USA

   Phone: +1-916-785-5621
   EMail: cbm@rose.hp.com


   John L. Hufferd
   Brocade, Inc.
   1745 Technology Drive
   San Jose, CA 95110, USA

   Phone: +1-408-333-5244
   EMail: jhufferd@brocade.com


   Julian Satran
   IBM, Haifa Research Lab
   Haifa University Campus - Mount Carmel
   Haifa 31905, Israel

   Phone +972-4-829-6264
   EMail: Julian_Satran@il.ibm.com


   Hemal Shah
   Broadcom Corporation
   5300 California Avenue
   Irvine, California 92617, USA

   Phone: +1-949-926-6941
   EMail: hemal@broadcom.com

   Comments may be sent to Mallikarjun Chadalapaka.













<span class="grey">Chadalapaka, et al.          Informational                     [Page 48]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-49" id="page-49" name="page-49"> </a>
<span class="grey"><a href="rfc5047.html">RFC 5047</a>                           DA                       October 2007</span>


Full Copyright Statement

   Copyright (C) The IETF Trust (2007).

   This document is subject to the rights, licenses and restrictions
   contained in <a href="https://tools.ietf.org/html/bcp78">BCP 78</a>, and except as set forth therein, the authors
   retain all their rights.

   This document and the information contained herein are provided on an
   "AS IS" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS
   OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST AND
   THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS
   OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF
   THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED
   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.

Intellectual Property

   The IETF takes no position regarding the validity or scope of any
   Intellectual Property Rights or other rights that might be claimed to
   pertain to the implementation or use of the technology described in
   this document or the extent to which any license under such rights
   might or might not be available; nor does it represent that it has
   made any independent effort to identify any such rights.  Information
   on the procedures with respect to rights in RFC documents can be
   found in <a href="https://tools.ietf.org/html/bcp78">BCP 78</a> and <a href="https://tools.ietf.org/html/bcp79">BCP 79</a>.

   Copies of IPR disclosures made to the IETF Secretariat and any
   assurances of licenses to be made available, or the result of an
   attempt made to obtain a general license or permission for the use of
   such proprietary rights by implementers or users of this
   specification can be obtained from the IETF on-line IPR repository at
   <a href="http://www.ietf.org/ipr">http://www.ietf.org/ipr</a>.

   The IETF invites any interested party to bring to its attention any
   copyrights, patents or patent applications, or other proprietary
   rights that may cover technology that may be required to implement
   this standard.  Please address the information to the IETF at
   ietf-ipr@ietf.org.












Chadalapaka, et al.          Informational                     [Page 49]

</pre><br/>
    <span class="noprint"><small><small>Html markup produced by rfcmarkup 1.119, available from
      <a href="https://tools.ietf.org/tools/rfcmarkup/">https://tools.ietf.org/tools/rfcmarkup/</a>
    </small></small></span>
  </div>




</body><!-- Mirrored from tools.ietf.org/html/rfc5047 by HTTrack Website Copier/3.x [XR&CO'2013], Tue, 23 Aug 2016 18:42:54 GMT --></html>