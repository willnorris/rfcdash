<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml"><!-- Mirrored from tools.ietf.org/html/rfc8290 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 06 Mar 2018 23:18:15 GMT --><!-- Added by HTTrack --><head><meta content="text/html;charset=utf-8" http-equiv="content-type"/><!-- /Added by HTTrack -->

    <meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
    <meta content="index,follow" name="robots"/>
    <meta content="rfcmarkup version 1.126" name="creator"/>
    <link href="http://purl.org/dc/elements/1.1/" rel="schema.DC"/>
<meta content="draft-hoeiland-joergensen-aqm-fq-codel" name="DC.Relation.Replaces"/>
<meta content="urn:ietf:rfc:8290" name="DC.Identifier"/>
<meta content="January, 2018" name="DC.Date.Issued"/>
<meta content="Taht, D." name="DC.Creator"/>
<meta content="Gettys, Jim" name="DC.Creator"/>
<meta content="Hoeiland-Joergensen, T." name="DC.Creator"/>
<meta content="Hoeiland-Joergensen, Toke" name="DC.Creator"/>
<meta content="Dumazet, Eric" name="DC.Creator"/>
<meta content="Gettys, J." name="DC.Creator"/>
<meta content="Dumazet, E." name="DC.Creator"/>
<meta content="McKenney, P." name="DC.Creator"/>
<meta content="This memo presents the FQ-CoDel hybrid packet scheduler and Active
Queue Management (AQM) algorithm, a powerful tool for fighting
bufferbloat and reducing latency.  FQ-CoDel mixes packets from
multiple flows and reduces the impact of head-of-line blocking from
bursty traffic. It provides isolation for low-rate traffic such as
DNS, web, and videoconferencing traffic. It improves utilisation
across the networking fabric, especially for bidirectional traffic, by
keeping queue lengths short, and it can be implemented in a memory-
and CPU-efficient fashion across a wide range of hardware." name="DC.Description.Abstract"/>
<meta content="The Flow Queue CoDel Packet Scheduler and Active Queue Management Algorithm" name="DC.Title"/>

    <link href="https://tools.ietf.org/images/rfc.png" rel="icon" type="image/png"/>
    <link href="https://tools.ietf.org/images/rfc.png" rel="shortcut icon" type="image/png"/>
    <title>RFC 8290 - The Flow Queue CoDel Packet Scheduler and Active Queue Management Algorithm</title>
    
    
    <style type="text/css">
	@media only screen 
	  and (min-width: 992px)
	  and (max-width: 1199px) {
	    body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 768px)
	  and (max-width: 991px) {
            body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 480px)
	  and (max-width: 767px) {
            body { font-size: 11pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (max-width: 479px) {
            body { font-size: 8pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-device-width : 375px) 
	  and (max-device-width : 667px) {
            body { font-size: 9.5pt; }
            div.content { width: 96ex; margin: 0 1px; }
        }
	@media only screen 
	  and (min-device-width: 1200px) {
            body { font-size: 10pt; margin: 0 4em; }
            div.content { width: 96ex; margin: 0; }
        }
        h1, h2, h3, h4, h5, h6, .h1, .h2, .h3, .h4, .h5, .h6 {
	    font-weight: bold;
            line-height: 0pt;
            display: inline;
            white-space: pre;
            font-family: monospace;
            font-size: 1em;
	    font-weight: bold;
        }
        pre {
            font-size: 1em;
            margin-top: 0px;
            margin-bottom: 0px;
        }
	.pre {
	    white-space: pre;
	    font-family: monospace;
	}
	.header{
	    font-weight: bold;
	}
        .newpage {
            page-break-before: always;
        }
        .invisible {
            text-decoration: none;
            color: white;
        }
        a.selflink {
          color: black;
          text-decoration: none;
        }
        @media print {
            body {
                font-family: monospace;
                font-size: 10.5pt;
            }
            h1, h2, h3, h4, h5, h6 {
                font-size: 1em;
            }
        
            a:link, a:visited {
                color: inherit;
                text-decoration: none;
            }
            .noprint {
                display: none;
            }
        }
	@media screen {
	    .grey, .grey a:link, .grey a:visited {
		color: #777;
	    }
            .docinfo {
                background-color: #EEE;
            }
            .top {
                border-top: 7px solid #EEE;
            }
            .bgwhite  { background-color: white; }
            .bgred    { background-color: #F44; }
            .bggrey   { background-color: #666; }
            .bgbrown  { background-color: #840; }            
            .bgorange { background-color: #FA0; }
            .bgyellow { background-color: #EE0; }
            .bgmagenta{ background-color: #F4F; }
            .bgblue   { background-color: #66F; }
            .bgcyan   { background-color: #4DD; }
            .bggreen  { background-color: #4F4; }

            .legend   { font-size: 90%; }
            .cplate   { font-size: 70%; border: solid grey 1px; }
	}
    </style>
    <!--[if IE]>
    <style>
    body {
       font-size: 13px;
       margin: 10px 10px;
    }
    </style>
    <![endif]-->

    <script type="text/javascript"><!--
    function addHeaderTags() {
	var spans = document.getElementsByTagName("span");
	for (var i=0; i < spans.length; i++) {
	    var elem = spans[i];
	    if (elem) {
		var level = elem.getAttribute("class");
                if (level == "h1" || level == "h2" || level == "h3" || level == "h4" || level == "h5" || level == "h6") {
                    elem.innerHTML = "<"+level+">"+elem.innerHTML+"</"+level+">";		
                }
	    }
	}
    }
    var legend_html = "Colour legend:<br />      <table>         <tr><td>Unknown:</td>                   <td><span class='cplate bgwhite'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft:</td>                     <td><span class='cplate bgred'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Informational:</td>             <td><span class='cplate bgorange'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Experimental:</td>              <td><span class='cplate bgyellow'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Best Common Practice:</td>      <td><span class='cplate bgmagenta'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Proposed Standard:</td>         <td><span class='cplate bgblue'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft Standard (old designation):</td> <td><span class='cplate bgcyan'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Internet Standard:</td>         <td><span class='cplate bggreen'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Historic:</td>                  <td><span class='cplate bggrey'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Obsolete:</td>                  <td><span class='cplate bgbrown'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>     </table>";
    function showElem(id) {
        var elem = document.getElementById(id);
        elem.innerHTML = eval(id+"_html");
        elem.style.visibility='visible';
    }
    function hideElem(id) {
        var elem = document.getElementById(id);
        elem.style.visibility='hidden';        
        elem.innerHTML = "";
    }
    // -->
    </script>
</head>
<body onload="addHeaderTags()">
  <div class="content">
   <div style="height: 13px;">
      <div class="pre noprint docinfo bgyellow" onclick="showElem('legend');" onmouseout="hideElem('legend')" onmouseover="this.style.cursor='pointer';" style="height: 6px; position: absolute;" title="Click for colour legend.">                                                                        </div>
      <div class="docinfo noprint pre legend" id="legend" onmouseout="hideElem('legend');" onmouseover="showElem('legend');" style="position:absolute; top: 4px; left: 4ex; visibility:hidden; background-color: white; padding: 4px 9px 5px 7px; border: solid #345 1px; ">
      </div>
   </div>
<span class="pre noprint docinfo top">[<a href="index.html" title="Document search and retrieval page">Docs</a>] [<a href="https://tools.ietf.org/rfc/rfc8290.txt" title="Plaintext version of this document">txt</a>|<a href="https://tools.ietf.org/pdf/rfc8290" title="PDF version of this document">pdf</a>] [<a href="https://tools.ietf.org/html/draft-ietf-aqm-fq-codel" title="draft-ietf-aqm-fq-codel">draft-ietf-aqm-...</a>] [<a href="https://datatracker.ietf.org/doc/rfc8290" title="IESG Datatracker information for this document">Tracker</a>] [<a href="https://tools.ietf.org/rfcdiff?difftype=--hwdiff&amp;url2=rfc8290" title="Inline diff (wdiff)">Diff1</a>] [<a href="https://tools.ietf.org/rfcdiff?url2=rfc8290" title="Side-by-side diff">Diff2</a>]         </span><br/>
<span class="pre noprint docinfo">                                                                        </span><br/>
<span class="pre noprint docinfo">                                                            EXPERIMENTAL</span><br/>
<span class="pre noprint docinfo">                                                                        </span><br/>
<pre>Internet Engineering Task Force (IETF)            T. Hoeiland-Joergensen
Request for Comments: 8290                           Karlstad University
Category: Experimental                                       P. McKenney
ISSN: 2070-1721                              IBM Linux Technology Center
                                                                 D. Taht
                                                                Teklibre
                                                               J. Gettys

                                                              E. Dumazet
                                                            Google, Inc.
                                                            January 2018


               <span class="h1">The Flow Queue CoDel Packet Scheduler and</span>
                   <span class="h1">Active Queue Management Algorithm</span>

Abstract

   This memo presents the FQ-CoDel hybrid packet scheduler and Active
   Queue Management (AQM) algorithm, a powerful tool for fighting
   bufferbloat and reducing latency.

   FQ-CoDel mixes packets from multiple flows and reduces the impact of
   head-of-line blocking from bursty traffic.  It provides isolation for
   low-rate traffic such as DNS, web, and videoconferencing traffic.  It
   improves utilisation across the networking fabric, especially for
   bidirectional traffic, by keeping queue lengths short, and it can be
   implemented in a memory- and CPU-efficient fashion across a wide
   range of hardware.

Status of This Memo

   This document is not an Internet Standards Track specification; it is
   published for examination, experimental implementation, and
   evaluation.

   This document defines an Experimental Protocol for the Internet
   community.  This document is a product of the Internet Engineering
   Task Force (IETF).  It represents the consensus of the IETF
   community.  It has received public review and has been approved for
   publication by the Internet Engineering Steering Group (IESG).  Not
   all documents approved by the IESG are a candidate for any level of
   Internet Standard; see <a href="rfc7841.html#section-2">Section 2 of RFC 7841</a>.

   Information about the current status of this document, any errata,
   and how to provide feedback on it may be obtained at
   <a href="https://www.rfc-editor.org/info/rfc8290">https://www.rfc-editor.org/info/rfc8290</a>.




<span class="grey">Hoeiland-Joergensen, et al.   Experimental                      [Page 1]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-2" id="page-2" name="page-2"> </a>
<span class="grey"><a href="rfc8290.html">RFC 8290</a>                        FQ-CoDel                    January 2018</span>


Copyright Notice

   Copyright (c) 2018 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to <a href="https://tools.ietf.org/html/bcp78">BCP 78</a> and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (<a href="https://trustee.ietf.org/license-info">https://trustee.ietf.org/license-info</a>) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.





































<span class="grey">Hoeiland-Joergensen, et al.   Experimental                      [Page 2]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-3" id="page-3" name="page-3"> </a>
<span class="grey"><a href="rfc8290.html">RFC 8290</a>                        FQ-CoDel                    January 2018</span>


Table of Contents

   <a href="#section-1">1</a>.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   <a href="#page-4">4</a>
     <a href="#section-1.1">1.1</a>.  Conventions Used in This Document . . . . . . . . . . . .   <a href="#page-4">4</a>
     <a href="#section-1.2">1.2</a>.  Terminology and Concepts  . . . . . . . . . . . . . . . .   <a href="#page-5">5</a>
     <a href="#section-1.3">1.3</a>.  Informal Summary of FQ-CoDel  . . . . . . . . . . . . . .   <a href="#page-5">5</a>
   <a href="#section-2">2</a>.  CoDel . . . . . . . . . . . . . . . . . . . . . . . . . . . .   <a href="#page-7">7</a>
   <a href="#section-3">3</a>.  Flow Queueing . . . . . . . . . . . . . . . . . . . . . . . .   <a href="#page-7">7</a>
   <a href="#section-4">4</a>.  The FQ-CoDel Scheduler  . . . . . . . . . . . . . . . . . . .   <a href="#page-8">8</a>
     <a href="#section-4.1">4.1</a>.  Enqueue . . . . . . . . . . . . . . . . . . . . . . . . .   <a href="#page-8">8</a>
       <a href="#section-4.1.1">4.1.1</a>.  Alternative Classification Schemes  . . . . . . . . .   <a href="#page-9">9</a>
     <a href="#section-4.2">4.2</a>.  Dequeue . . . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-10">10</a>
   <a href="#section-5">5</a>.  Implementation Considerations . . . . . . . . . . . . . . . .  <a href="#page-11">11</a>
     <a href="#section-5.1">5.1</a>.  Data Structures . . . . . . . . . . . . . . . . . . . . .  <a href="#page-11">11</a>
     <a href="#section-5.2">5.2</a>.  Parameters  . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-12">12</a>
       <a href="#section-5.2.1">5.2.1</a>.  Interval  . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-12">12</a>
       <a href="#section-5.2.2">5.2.2</a>.  Target  . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-12">12</a>
       <a href="#section-5.2.3">5.2.3</a>.  Packet Limit  . . . . . . . . . . . . . . . . . . . .  <a href="#page-13">13</a>
       <a href="#section-5.2.4">5.2.4</a>.  Quantum . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-13">13</a>
       <a href="#section-5.2.5">5.2.5</a>.  Flows . . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-13">13</a>
       <a href="#section-5.2.6">5.2.6</a>.  Explicit Congestion Notification (ECN)  . . . . . . .  <a href="#page-14">14</a>
       <a href="#section-5.2.7">5.2.7</a>.  CE Threshold  . . . . . . . . . . . . . . . . . . . .  <a href="#page-14">14</a>
     <a href="#section-5.3">5.3</a>.  Probability of Hash Collisions  . . . . . . . . . . . . .  <a href="#page-14">14</a>
     <a href="#section-5.4">5.4</a>.  Memory Overhead . . . . . . . . . . . . . . . . . . . . .  <a href="#page-15">15</a>
     <a href="#section-5.5">5.5</a>.  Per-Packet Timestamping . . . . . . . . . . . . . . . . .  <a href="#page-16">16</a>
     <a href="#section-5.6">5.6</a>.  Limiting Queueing in Lower Layers . . . . . . . . . . . .  <a href="#page-16">16</a>
     <a href="#section-5.7">5.7</a>.  Other Forms of Fair Queueing  . . . . . . . . . . . . . .  <a href="#page-17">17</a>
     <a href="#section-5.8">5.8</a>.  Differences between CoDel and FQ-CoDel Behaviour  . . . .  <a href="#page-17">17</a>
   <a href="#section-6">6</a>.  Limitations of Flow Queueing  . . . . . . . . . . . . . . . .  <a href="#page-18">18</a>
     <a href="#section-6.1">6.1</a>.  Fairness between Things Other Than Flows  . . . . . . . .  <a href="#page-18">18</a>
     <a href="#section-6.2">6.2</a>.  Flow Bunching by Opaque Encapsulation . . . . . . . . . .  <a href="#page-18">18</a>
     <a href="#section-6.3">6.3</a>.  Low-Priority Congestion Control Algorithms  . . . . . . .  <a href="#page-19">19</a>
   <a href="#section-7">7</a>.  Deployment Status and Future Work . . . . . . . . . . . . . .  <a href="#page-19">19</a>
   <a href="#section-8">8</a>.  Security Considerations . . . . . . . . . . . . . . . . . . .  <a href="#page-20">20</a>
   <a href="#section-9">9</a>.  IANA Considerations . . . . . . . . . . . . . . . . . . . . .  <a href="#page-21">21</a>
   <a href="#section-10">10</a>. References  . . . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-21">21</a>
     <a href="#section-10.1">10.1</a>.  Normative References . . . . . . . . . . . . . . . . . .  <a href="#page-21">21</a>
     <a href="#section-10.2">10.2</a>.  Informative References . . . . . . . . . . . . . . . . .  <a href="#page-21">21</a>
   Acknowledgements  . . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-24">24</a>
   Authors' Addresses  . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-25">25</a>











<span class="grey">Hoeiland-Joergensen, et al.   Experimental                      [Page 3]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-4" id="page-4" name="page-4"> </a>
<span class="grey"><a href="rfc8290.html">RFC 8290</a>                        FQ-CoDel                    January 2018</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/1.%20%20Introduction"></a><a class="selflink" href="#section-1" name="section-1">1</a>.  Introduction</span>

   The Flow Queue CoDel (FQ-CoDel) algorithm is a combined packet
   scheduler and Active Queue Management (AQM) [<a href="rfc3168.html" title='"The Addition of Explicit Congestion Notification (ECN) to IP"'>RFC3168</a>] algorithm
   developed as part of the bufferbloat-fighting community effort
   [<a href="#ref-BLOATWEB" title='"Bufferbloat"'>BLOATWEB</a>].  It is based on a modified Deficit Round Robin (DRR)
   queue scheduler [<a href="#ref-DRR" title='"Efficient Fair Queueing Using Deficit Round Robin"'>DRR</a>] [<a href="#ref-DRRPP" title='"Deficits for Bursty Latency- Critical Flows: DRR++"'>DRRPP</a>] with the CoDel AQM [<a href="rfc8289.html" title='"Controlled Delay Active Queue Management"'>RFC8289</a>] algorithm
   operating on each queue.  This document describes the combined
   algorithm; reference implementations are available for the ns-2 [<a href="#ref-NS2" title='"ns-2"'>NS2</a>]
   and ns-3 [<a href="#ref-NS3" title='"ns-3"'>NS3</a>] network simulators, and the algorithm is included in
   the mainline Linux kernel as the fq_codel queueing discipline
   [<a href="#ref-LINUXSRC" title='"Linux Kernel Source Tree"'>LINUXSRC</a>].

   FQ-CoDel is a general, efficient, nearly parameterless queue
   management approach combining flow queueing with CoDel.  It is a
   powerful tool for solving bufferbloat [<a href="#ref-BLOAT" title='"Bufferbloat: Dark Buffers in the Internet"'>BLOAT</a>] and has already been
   turned on by default in a number of Linux distributions.  In this
   document, we describe the Linux implementation in sufficient detail
   for others to independently implement the algorithm for deployment
   outside the Linux ecosystem.

   Since the FQ-CoDel algorithm was originally developed in the Linux
   kernel, that implementation is still considered canonical.  This
   document describes the algorithm in the abstract in Sections <a href="#section-1">1</a>-<a href="#section-4">4</a> and
   separates out most implementation details in subsequent sections;
   however, the Linux implementation is used as a reference for default
   behaviour in the abstract algorithm description.

   This document is structured as follows.  This section gives some
   concepts and terminology used in the rest of the document and gives a
   short informal summary of the FQ-CoDel algorithm.  <a href="#section-2">Section 2</a> gives an
   overview of the CoDel algorithm.  <a href="#section-3">Section 3</a> covers the flow hashing
   and DRR portion.  <a href="#section-4">Section 4</a> then describes the working of the
   algorithm in detail, while <a href="#section-5">Section 5</a> describes implementation details
   and considerations.  <a href="#section-6">Section 6</a> lists some of the limitations of using
   flow queueing.  <a href="#section-7">Section 7</a> outlines the current status of FQ-CoDel
   deployment and lists some possible future areas of inquiry.  Finally,
   <a href="#section-8">Section 8</a> reiterates some important security points that must be
   observed in the implementation.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/1.1.%20%20Conventions%20Used%20in%20This%20Document"></a><a class="selflink" href="#section-1.1" name="section-1.1">1.1</a>.  Conventions Used in This Document</span>

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
   "OPTIONAL" in this document are to be interpreted as described in
   <a href="https://tools.ietf.org/html/bcp14">BCP 14</a> [<a href="rfc2119.html" title='"Key words for use in RFCs to Indicate Requirement Levels"'>RFC2119</a>] [<a href="rfc8174.html" title='"Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words"'>RFC8174</a>] when, and only when, they appear in all
   capitals, as shown here.




<span class="grey">Hoeiland-Joergensen, et al.   Experimental                      [Page 4]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-5" id="page-5" name="page-5"> </a>
<span class="grey"><a href="rfc8290.html">RFC 8290</a>                        FQ-CoDel                    January 2018</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/1.2.%20%20Terminology%20and%20Concepts"></a><a class="selflink" href="#section-1.2" name="section-1.2">1.2</a>.  Terminology and Concepts</span>

   Flow:  A flow is typically identified by a 5-tuple of source IP
      address, destination IP address, source port number, destination
      port number, and protocol number.  It can also be identified by a
      superset or subset of those parameters, by Media Access Control
      (MAC) address, or by other means.  FQ-CoDel hashes flows into a
      configurable number of buckets to assign packets to internal
      queues.

   Queue:  A queue of packets represented internally in FQ-CoDel.  In
      most instances, each flow gets its own queue; however, because of
      the possibility of hash collisions, this is not always the case.
      In an attempt to avoid confusion, the word "queue" is used to
      refer to the internal data structure, and "flow" is used to refer
      to the actual stream of packets being delivered to the FQ-CoDel
      algorithm.

   Scheduler:  A mechanism to select which queue a packet is dequeued
      from.

   CoDel AQM:  The Active Queue Management algorithm employed by
      FQ-CoDel as described in [<a href="rfc8289.html" title='"Controlled Delay Active Queue Management"'>RFC8289</a>].

   DRR:  Deficit Round Robin scheduling [<a href="#ref-DRR" title='"Efficient Fair Queueing Using Deficit Round Robin"'>DRR</a>].

   Quantum:  The maximum amount of bytes to be dequeued from a queue at
      once.

   Interval:  Characteristic time period used by the control loop of
      CoDel to detect when a persistent queue is developing (see
      <a href="rfc8289.html#section-4.2">Section 4.2 of [RFC8289]</a>).

   Target:  Setpoint value of the minimum sojourn time of packets in a
      queue used as the target of the control loop in CoDel (see
      <a href="rfc8289.html#section-4.3">Section 4.3 of [RFC8289]</a>).

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/1.3.%20%20Informal%20Summary%20of%20FQ-CoDel"></a><a class="selflink" href="#section-1.3" name="section-1.3">1.3</a>.  Informal Summary of FQ-CoDel</span>

   FQ-CoDel is a hybrid of DRR [<a href="#ref-DRR" title='"Efficient Fair Queueing Using Deficit Round Robin"'>DRR</a>] and CoDel [<a href="rfc8289.html" title='"Controlled Delay Active Queue Management"'>RFC8289</a>], with an
   optimisation for sparse flows similar to Shortest Queue First (SQF)
   [<a href="#ref-SQF" title='"On the Impact of TCP and Per-Flow Scheduling on Internet Performance"'>SQF</a>] and DRR++ [<a href="#ref-DRRPP" title='"Deficits for Bursty Latency- Critical Flows: DRR++"'>DRRPP</a>].  We call this "flow queueing" rather than
   "fair queueing", as flows that build a queue are treated differently
   from flows that do not.







<span class="grey">Hoeiland-Joergensen, et al.   Experimental                      [Page 5]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-6" id="page-6" name="page-6"> </a>
<span class="grey"><a href="rfc8290.html">RFC 8290</a>                        FQ-CoDel                    January 2018</span>


   By default, FQ-CoDel stochastically classifies incoming packets into
   different queues by hashing the 5-tuple of protocol number, source
   and destination IP addresses, and source and destination port
   numbers, perturbed with a random number selected at initiation time
   (although other flow classification schemes can optionally be
   configured instead; see <a href="#section-4.1.1">Section 4.1.1</a>).  Each queue is managed by the
   CoDel AQM algorithm [<a href="#ref-CODEL" title='"Controlling Queue Delay"'>CODEL</a>] [<a href="rfc8289.html" title='"Controlled Delay Active Queue Management"'>RFC8289</a>].  Packet ordering within a
   queue is preserved, since queues have FIFO ordering.

   The FQ-CoDel algorithm consists of two logical parts: (1) the
   scheduler, which selects which queue to dequeue a packet from, and
   (2) the CoDel AQM, which works on each of the queues.  The subtleties
   of FQ-CoDel are mostly in the scheduling part, whereas the
   interaction between the scheduler and the CoDel algorithm are fairly
   straightforward.

   At initialisation, each queue is set up to have a separate set of
   CoDel state variables.  By default, 1024 queues are created.  The
   Linux implementation at the time of writing supports anywhere from
   one to 65535 separate queues, and each queue maintains the state
   variables throughout its lifetime, and so acts the same as the non-FQ
   variant of CoDel would.  This means that with only one queue,
   FQ-CoDel behaves essentially the same as CoDel by itself.

   On dequeue, FQ-CoDel selects a queue from which to dequeue by a two-
   tier, round-robin scheme, in which each queue is allowed to dequeue
   up to a configurable quantum of bytes for each iteration.  Deviations
   from this quantum are maintained as byte credits for the queue, which
   serves to make the fairness scheme byte-based rather than packet-
   based.  The two-tier, round-robin mechanism distinguishes between
   "new" queues (which don't build up a standing queue) and "old" queues
   (which have queued enough data to be active for more than one
   iteration of the round-robin scheduler).

   This new/old queue distinction has a particular consequence for
   queues that don't build up more than a quantum of bytes before being
   visited by the scheduler: such a queue will be removed from the list
   after it empties and then re-added as a new queue the next time a
   packet arrives for it.  This means it will effectively get priority
   over queues that do not empty out each round (a minor caveat is
   required here to protect against starvation, see below).  Exactly how
   little data a flow has to send to keep its queue in this state is
   somewhat difficult to reason about, because it depends on both the
   egress link speed and the number of concurrent flows.  However, in
   practice, many things that are beneficial to have prioritised for
   typical internet use (ACKs, DNS lookups, interactive Secure Shell
   (SSH), HTTP requests, Voice over IP (VoIP)) _tend_ to fall in this
   category, which is why FQ-CoDel performs so well for many practical



<span class="grey">Hoeiland-Joergensen, et al.   Experimental                      [Page 6]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-7" id="page-7" name="page-7"> </a>
<span class="grey"><a href="rfc8290.html">RFC 8290</a>                        FQ-CoDel                    January 2018</span>


   applications.  However, the implicitness of the prioritisation means
   that for applications that require guaranteed priority (for instance,
   multiplexing the network control plane over the network itself),
   explicit classification is still needed.

   This scheduling scheme has some subtlety to it, which is explained in
   detail in the remainder of this document.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/2.%20%20CoDel"></a><a class="selflink" href="#section-2" name="section-2">2</a>.  CoDel</span>

   CoDel is described in the Communications of the ACM paper [<a href="#ref-CODEL" title='"Controlling Queue Delay"'>CODEL</a>] and
   the IETF document [<a href="rfc8289.html" title='"Controlled Delay Active Queue Management"'>RFC8289</a>].  The basic idea is to control queue
   length, maintaining sufficient queueing to keep the outgoing link
   busy but avoiding building up the queue beyond that point.  This is
   done by preferentially dropping packets that remain in the queue for
   "too long".  Packets are dropped by head drop, which lowers the time
   for the drop signal to propagate back to the sender by the length of
   the queue and helps trigger TCP fast retransmit sooner.

   The CoDel algorithm itself will not be described here; instead, we
   refer the reader to the CoDel document [<a href="rfc8289.html" title='"Controlled Delay Active Queue Management"'>RFC8289</a>].

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/3.%20%20Flow%20Queueing"></a><a class="selflink" href="#section-3" name="section-3">3</a>.  Flow Queueing</span>

   The intention of FQ-CoDel's scheduler is to give each flow its own
   queue, hence the term "flow queueing".  Rather than a perfect
   realisation of this, a hashing-based scheme is used, where flows are
   hashed into a number of buckets, each of which has its own queue.
   The number of buckets is configurable and presently defaults to 1024
   in the Linux implementation.  This is enough to avoid hash collisions
   on a moderate number of flows as seen, for instance, in a home
   gateway.  Depending on the characteristics of the link, this can be
   tuned to trade off memory for a lower probability of hash collisions.
   See Sections <a href="#section-5.3">5.3</a> and <a href="#section-5.4">5.4</a> for a more in-depth discussion of this.

   By default, the flow hashing is performed on the 5-tuple of source
   and destination IP addresses, source and destination port numbers,
   and protocol number.  While the hashing can be customised to match on
   arbitrary packet bytes, care should be taken when doing so; much of
   the benefit of the FQ-CoDel scheduler comes from this per-flow
   distinction.  However, the default hashing does have some
   limitations, as discussed in <a href="#section-6">Section 6</a>.

   FQ-CoDel's DRR scheduler is byte-based, employing a deficit round-
   robin mechanism between queues.  This works by keeping track of the
   current number of "byte credits" of each queue.  This number is
   initialised to the configurable quantum; each time a queue gets a
   dequeue opportunity, it gets to dequeue packets, thus decreasing the



<span class="grey">Hoeiland-Joergensen, et al.   Experimental                      [Page 7]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-8" id="page-8" name="page-8"> </a>
<span class="grey"><a href="rfc8290.html">RFC 8290</a>                        FQ-CoDel                    January 2018</span>


   number of credits by the packet size for each packet.  This continues
   until the value of the byte credits counter becomes zero or less, at
   which point the counter is increased by one quantum, and the dequeue
   opportunity ends.

   This means that if one queue contains packets of, for instance, size
   quantum/3, and another contains quantum-sized packets, the first
   queue will dequeue three packets each time it gets a turn, whereas
   the second only dequeues one.  This means that flows that send small
   packets are not penalised by the difference in packet sizes; rather,
   the DRR scheme approximates a byte-based fairness queueing scheme.
   The size of the quantum determines the scheduling granularity, with
   the trade-off from too small a quantum being scheduling overhead.
   For small bandwidths, lowering the quantum from the default MTU size
   can be advantageous.

   Unlike plain DRR, there are two sets of flows: a "new" list for flows
   that have not built a queue recently and an "old" list for queues
   that build a backlog.  This distinction is an integral part of the
   FQ-CoDel scheduler and is described in more detail in <a href="#section-4">Section 4</a>.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/4.%20%20The%20FQ-CoDel%20Scheduler"></a><a class="selflink" href="#section-4" name="section-4">4</a>.  The FQ-CoDel Scheduler</span>

   To make its scheduling decisions, FQ-CoDel maintains two ordered
   lists of active queues: new and old queues.  When a packet is added
   to a queue that is not currently active, that queue becomes active by
   being added to the list of new queues.  Later on, it is moved to the
   list of old queues, from which it is removed when it is no longer
   active.  This behaviour is the source of some subtlety in the packet
   scheduling at dequeue time, as explained below.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.1.%20%20Enqueue"></a><a class="selflink" href="#section-4.1" name="section-4.1">4.1</a>.  Enqueue</span>

   The packet enqueue mechanism consists of three stages: classifying
   into a queue, timestamping and bookkeeping, and optionally dropping a
   packet when the total number of enqueued packets goes over the
   maximum.

   When a packet is enqueued, it is first classified into the
   appropriate queue.  By default, this is done by hashing (using a
   Jenkins hash function [<a href="#ref-JENKINS" title='"A Hash Function for Hash Table Lookup"'>JENKINS</a>]) on the 5-tuple of IP protocol,
   source and destination IP addresses, and source and destination port
   numbers (if they exist) and then taking the hash value modulo the
   number of queues.  The hash is salted by modulo addition of a random
   value selected at initialisation time to prevent possible DoS attacks
   if the hash is predictable ahead of time (see <a href="#section-8">Section 8</a>).  The Linux





<span class="grey">Hoeiland-Joergensen, et al.   Experimental                      [Page 8]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-9" id="page-9" name="page-9"> </a>
<span class="grey"><a href="rfc8290.html">RFC 8290</a>                        FQ-CoDel                    January 2018</span>


   kernel implements the Jenkins hash function by mixing three 32-bit
   values into a single 32-bit output value.  Inputs larger than 96 bits
   are reduced by additional mixing steps, 96 bits at a time.

   Once the packet has been successfully classified into a queue, it is
   handed over to the CoDel algorithm for timestamping.  It is then
   added to the tail of the selected queue, and the queue's byte count
   is updated by the packet size.  Then, if the queue is not currently
   active (i.e., if it is not in either the list of new queues or the
   list of old queues), it is added to the end of the list of new
   queues, and its number of credits is initiated to the configured
   quantum.  Otherwise, the queue is left in its current queue list.

   Finally, to protect against overload, the total number of enqueued
   packets is compared with the configured limit.  If the limit is
   exceeded (which can happen since a packet was just enqueued), the
   queue with the largest current byte count is selected and half the
   number of packets from this queue (up to a maximum of 64 packets) are
   dropped from the head of that queue.  Dropping several packets at
   once helps amortise the cost of finding the longest queue,
   significantly lowering CPU usage in an overload situation.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/4.1.1.%20%20Alternative%20Classification%20Schemes"></a><a class="selflink" href="#section-4.1.1" name="section-4.1.1">4.1.1</a>.  Alternative Classification Schemes</span>

   As mentioned previously, it is possible to modify the classification
   scheme to provide a different notion of a flow.  The Linux
   implementation provides this option in the form of the "tc filter"
   command.  While this can add capabilities (for instance, matching on
   other possible parameters such as MAC address, Diffserv code point
   values, firewall rules, flow-specific markings, IPv6 flow label,
   etc.), care should be taken to preserve the notion of flow because
   much of the benefit of the FQ-CoDel scheduler comes from keeping
   flows in separate queues.

   For protocols that do not contain a port number (such as ICMP), the
   Linux implementation simply sets the port numbers to zero and
   performs the hashing as usual.  In practice, this results in such
   protocols each getting their own queue (except in the case of hash
   collisions).  An implementation can perform other classifications for
   protocols that have their own notion of a flow but SHOULD fall back
   to simply hashing on source and destination IP address and protocol
   number in the absence of other information.

   The default classification scheme can additionally be improved by
   performing decapsulation of tunnelled packets prior to hashing on the
   5-tuple in the encapsulated payload.  The Linux implementation does
   this for common encapsulations known to the kernel, such as 6in4
   [<a href="rfc4213.html" title='"Basic Transition Mechanisms for IPv6 Hosts and Routers"'>RFC4213</a>], IP-in-IP [<a href="rfc2003.html" title='"IP Encapsulation within IP"'>RFC2003</a>], and Generic Routing Encapsulation



<span class="grey">Hoeiland-Joergensen, et al.   Experimental                      [Page 9]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-10" id="page-10" name="page-10"> </a>
<span class="grey"><a href="rfc8290.html">RFC 8290</a>                        FQ-CoDel                    January 2018</span>


   (GRE) [<a href="rfc2890.html" title='"Key and Sequence Number Extensions to GRE"'>RFC2890</a>].  This helps to distinguish between flows that share
   the same (outer) 5-tuple but, of course, is limited to unencrypted
   tunnels (see <a href="#section-6.2">Section 6.2</a> for a discussion of encrypted tunnels).

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.2.%20%20Dequeue"></a><a class="selflink" href="#section-4.2" name="section-4.2">4.2</a>.  Dequeue</span>

   Most of FQ-CoDel's work is done at packet dequeue time.  It consists
   of three parts: selecting a queue from which to dequeue a packet,
   actually dequeueing it (employing the CoDel algorithm in the
   process), and some final bookkeeping.

   For the first part, the scheduler first looks at the list of new
   queues; for the queue at the head of that list, if that queue has a
   negative number of credits (i.e., it has already dequeued at least a
   quantum of bytes), it is given an additional quantum of credits, the
   queue is put onto _the end of_ the list of old queues, and the
   routine selects the next queue and starts again.

   Otherwise, that queue is selected for dequeue.  If the list of new
   queues is empty, the scheduler proceeds down the list of old queues
   in the same fashion (checking the credits and either selecting the
   queue for dequeueing or adding credits and putting the queue back at
   the end of the list).

   After having selected a queue from which to dequeue a packet, the
   CoDel algorithm is invoked on that queue.  This applies the CoDel
   control law, which is the mechanism CoDel uses to determine when to
   drop packets (see [<a href="rfc8289.html" title='"Controlled Delay Active Queue Management"'>RFC8289</a>]).  As a result of this, one or more
   packets may be discarded from the head of the selected queue before
   the packet that should be dequeued is returned (or nothing is
   returned if the queue is or becomes empty while being handled by the
   CoDel algorithm).

   Finally, if the CoDel algorithm does not return a packet, then the
   queue must be empty, and the scheduler does one of two things.  If
   the queue selected for dequeue came from the list of new queues, it
   is moved to _the end of_ the list of old queues.  If instead it came
   from the list of old queues, that queue is removed from the list, to
   be added back (as a new queue) the next time a packet arrives that
   hashes to that queue.  Then (since no packet was available for
   dequeue), the whole dequeue process is restarted from the beginning.

   If, instead, the scheduler _did_ get a packet back from the CoDel
   algorithm, it subtracts the size of the packet from the byte credits
   for the selected queue and returns the packet as the result of the
   dequeue operation.





<span class="grey">Hoeiland-Joergensen, et al.   Experimental                     [Page 10]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-11" id="page-11" name="page-11"> </a>
<span class="grey"><a href="rfc8290.html">RFC 8290</a>                        FQ-CoDel                    January 2018</span>


   The step that moves an empty queue from the list of new queues to the
   end of the list of old queues before it is removed is crucial to
   prevent starvation.  Otherwise, the queue could reappear (the next
   time a packet arrives for it) before the list of old queues is
   visited; this can go on indefinitely, even with a small number of
   active flows, if the flow providing packets to the queue in question
   transmits at just the right rate.  This is prevented by first moving
   the queue to the end of the list of old queues, forcing the scheduler
   to service all old queues before the empty queue is removed and thus
   preventing starvation.

   The resulting migration of queues between the different states is
   summarised in the state diagram shown in Figure 1.  Note that both
   the new and old queue states can additionally have arrival and
   dequeue events that do not change the state; these are omitted in the
   figure.

   +-----------------+                +------------------+
   |                 |     Empty      |                  |
   |     Empty       |&lt;---------------+       Old        +----+
   |                 |                |                  |    |
   +-------+---------+                +------------------+    |
           |                             ^            ^       |Credits
           |Arrival                      |            |       |Exhausted
           v                             |            |       |
   +-----------------+                   |            |       |
   |                 |      Empty or     |            |       |
   |      New        +-------------------+            +-------+
   |                 | Credits Exhausted
   +-----------------+

   Figure 1: Partial State Diagram for Queues between Different States

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/5.%20%20Implementation%20Considerations"></a><a class="selflink" href="#section-5" name="section-5">5</a>.  Implementation Considerations</span>

   This section contains implementation details for the FQ-CoDel
   algorithm.  This includes the data structures and parameters used in
   the Linux implementation, as well as discussion of some required
   features of the target platform and other considerations.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.1.%20%20Data%20Structures"></a><a class="selflink" href="#section-5.1" name="section-5.1">5.1</a>.  Data Structures</span>

   The main data structure of FQ-CoDel is the array of queues, which is
   instantiated with the number of queues specified by the "flows"
   parameter at instantiation time.  Each queue consists simply of an
   ordered list of packets with FIFO semantics, two state variables
   tracking the queue credits and total number of bytes enqueued, and
   the set of CoDel state variables.  Other state variables to track



<span class="grey">Hoeiland-Joergensen, et al.   Experimental                     [Page 11]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-12" id="page-12" name="page-12"> </a>
<span class="grey"><a href="rfc8290.html">RFC 8290</a>                        FQ-CoDel                    January 2018</span>


   queue statistics can also be included; for instance, the Linux
   implementation keeps a count of dropped packets.

   In addition to the queue structures themselves, FQ-CoDel maintains
   two ordered lists containing references to the subset of queues that
   are currently active.  These are the lists of new and old queues, as
   explained in <a href="#section-4">Section 4</a> above.

   In the Linux implementation, queue space is shared: there's a global
   limit on the number of packets the queues can hold, but not a limit
   for each queue.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.2.%20%20Parameters"></a><a class="selflink" href="#section-5.2" name="section-5.2">5.2</a>.  Parameters</span>

   The following are the user configuration parameters exposed by the
   Linux implementation of FQ-CoDel.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/5.2.1.%20%20Interval"></a><a class="selflink" href="#section-5.2.1" name="section-5.2.1">5.2.1</a>.  Interval</span>

   The "interval" parameter has the same semantics as CoDel and is used
   to ensure that the minimum sojourn time of packets in a queue used as
   an estimator by the CoDel control algorithm is a relatively up-to-
   date value.  That is, CoDel only reacts to delay experienced in the
   last epoch of length interval.  It SHOULD be set to be on the order
   of the worst-case RTT through the bottleneck to give end points
   sufficient time to react.

   The default interval value is 100 ms.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/5.2.2.%20%20Target"></a><a class="selflink" href="#section-5.2.2" name="section-5.2.2">5.2.2</a>.  Target</span>

   The "target" parameter has the same semantics as CoDel.  It is the
   acceptable minimum standing/persistent queue delay for each FQ-CoDel
   queue.  This minimum delay is identified by tracking the local
   minimum queue delay that packets experience.

   The default target value is 5 ms, but this value should be tuned to
   be at least the transmission time of a single MTU-sized packet at the
   prevalent egress link speed (which, for example, is ~15 ms for 1 Mbps
   and MTU 1500).  This prevents CoDel from being too aggressive at low
   bandwidths.  It should otherwise be set to 5-10% of the configured
   interval.









<span class="grey">Hoeiland-Joergensen, et al.   Experimental                     [Page 12]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-13" id="page-13" name="page-13"> </a>
<span class="grey"><a href="rfc8290.html">RFC 8290</a>                        FQ-CoDel                    January 2018</span>


<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/5.2.3.%20%20Packet%20Limit"></a><a class="selflink" href="#section-5.2.3" name="section-5.2.3">5.2.3</a>.  Packet Limit</span>

   Routers do not have infinite memory, so some packet limit MUST be
   enforced.

   The "limit" parameter is the hard limit on the real queue size,
   measured in number of packets.  This limit is a global limit on the
   number of packets in all queues; each individual queue does not have
   an upper limit.  When the limit is reached and a new packet arrives
   for enqueue, packets are dropped from the head of the largest queue
   (measured in bytes) to make room for the new packet.

   In Linux, the default packet limit is 10240 packets, which is
   suitable for up to 10-Gigabit Ethernet speeds.  In practice, the hard
   limit is rarely (if ever) hit, as drops are performed by the CoDel
   algorithm long before the limit is hit.  For platforms that are
   severely memory constrained, a lower limit can be used.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/5.2.4.%20%20Quantum"></a><a class="selflink" href="#section-5.2.4" name="section-5.2.4">5.2.4</a>.  Quantum</span>

   The "quantum" parameter is the number of bytes each queue gets to
   dequeue on each round of the scheduling algorithm.  The default is
   set to 1514 bytes, which corresponds to the Ethernet MTU plus the
   hardware header length of 14 bytes.

   In systems employing TCP Segmentation Offload (TSO), where a "packet"
   consists of an offloaded packet train, it can presently be as large
   as 64 kilobytes.  In systems using Generic Receive Offload (GRO),
   they can be up to 17 times the TCP max segment size (or 25
   kilobytes).  These mega-packets severely impact FQ-CoDel's ability to
   schedule traffic, and they hurt latency needlessly.  There is ongoing
   work in Linux to make smarter use of offload engines.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/5.2.5.%20%20Flows"></a><a class="selflink" href="#section-5.2.5" name="section-5.2.5">5.2.5</a>.  Flows</span>

   The "flows" parameter sets the number of queues into which the
   incoming packets are classified.  Due to the stochastic nature of
   hashing, multiple flows may end up being hashed into the same slot.

   This parameter can be set only at initialisation time in the current
   implementation, since memory has to be allocated for the hash table.

   The default value is 1024 in the current Linux implementation.








<span class="grey">Hoeiland-Joergensen, et al.   Experimental                     [Page 13]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-14" id="page-14" name="page-14"> </a>
<span class="grey"><a href="rfc8290.html">RFC 8290</a>                        FQ-CoDel                    January 2018</span>


<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/5.2.6.%20%20Explicit%20Congestion%20Notification%20%28ECN%29"></a><a class="selflink" href="#section-5.2.6" name="section-5.2.6">5.2.6</a>.  Explicit Congestion Notification (ECN)</span>

   ECN [<a href="rfc3168.html" title='"The Addition of Explicit Congestion Notification (ECN) to IP"'>RFC3168</a>] is enabled by default.  Rather than do anything special
   with misbehaved ECN flows, FQ-CoDel relies on the packet scheduling
   system to minimise their impact; thus, the number of unresponsive
   packets in a flow being marked with ECN can grow to the overall
   packet limit but will not otherwise affect the performance of the
   system.

   ECN can be disabled by specifying the "noecn" parameter.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/5.2.7.%20%20CE%20Threshold"></a><a class="selflink" href="#section-5.2.7" name="section-5.2.7">5.2.7</a>.  CE Threshold</span>

   This parameter enables DCTCP-like processing resulting in Congestion
   Encountered (CE) marking on ECN-Capable Transport (ECT) packets
   [<a href="rfc3168.html" title='"The Addition of Explicit Congestion Notification (ECN) to IP"'>RFC3168</a>] starting at a lower sojourn delay setpoint than the default
   CoDel target.  Details of Data Center TCP (DCTCP) can be found in
   [<a href="rfc8257.html" title='"Data Center TCP (DCTCP): TCP Congestion Control for Data Centers"'>RFC8257</a>].

   The "ce_threshold" parameter is disabled by default; it can be
   enabled by setting it to a number of microseconds.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.3.%20%20Probability%20of%20Hash%20Collisions"></a><a class="selflink" href="#section-5.3" name="section-5.3">5.3</a>.  Probability of Hash Collisions</span>

   Since the Linux FQ-CoDel implementation by default uses 1024 hash
   buckets, the probability that (say) 100 flows will all hash to the
   same bucket is something like ten to the power of minus 300.  Thus,
   at least one of the flows will almost certainly hash to some other
   queue.

   Expanding on this, based on analytical equations for hash collision
   probabilities, for 100 flows, the probability of no collision is
   90.78%; the probability that no more than two of the 100 flows will
   be involved in any given collision is 99.57%; and the probability
   that no more than three of the 100 flows will be involved in any
   given collision is 99.99%.  These probabilities assume a hypothetical
   perfect hashing function, so in practice, they may be a bit lower.
   We have not found this difference to matter in practice.

   These probabilities can be improved upon by using set-associative
   hashing, a technique used in the Cake algorithm currently being
   developed as a further refinement of the FQ-CoDel principles [<a href="#ref-CAKE" title='"Cake - Common Applications Kept Enhanced"'>CAKE</a>].
   For a 4-way associative hash with the same number of total queues,
   the probability of no collisions for 100 flows is 99.93%, while for
   an 8-way associative hash, it is ~100%.






<span class="grey">Hoeiland-Joergensen, et al.   Experimental                     [Page 14]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-15" id="page-15" name="page-15"> </a>
<span class="grey"><a href="rfc8290.html">RFC 8290</a>                        FQ-CoDel                    January 2018</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.4.%20%20Memory%20Overhead"></a><a class="selflink" href="#section-5.4" name="section-5.4">5.4</a>.  Memory Overhead</span>

   FQ-CoDel can be implemented with a low memory footprint (less than 64
   bytes per queue on 64-bit systems).  These are the data structures
   used in the Linux implementation:

   &lt;CODE BEGINS&gt;

   struct codel_vars {
      u32             count;             /* number of dropped packets */
      u32             lastcount;     /* count entry to dropping state */
      bool            dropping;                /* currently dropping? */
      u16             rec_inv_sqrt;    /* reciprocal sqrt computation */
      codel_time_t    first_above_time;    /* when delay above target */
      codel_time_t    drop_next;                 /* next time to drop */
      codel_time_t    ldelay; /* sojourn time of last dequeued packet */
   };

   struct fq_codel_flow {
      struct sk_buff    *head;
      struct sk_buff    *tail;
      struct list_head  flowchain;
      int               credits;   /* current number of queue credits */
      u32               dropped; /* # of drops (or ECN marks) on flow */
      struct codel_vars cvars;
   };

   &lt;CODE ENDS&gt;























<span class="grey">Hoeiland-Joergensen, et al.   Experimental                     [Page 15]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-16" id="page-16" name="page-16"> </a>
<span class="grey"><a href="rfc8290.html">RFC 8290</a>                        FQ-CoDel                    January 2018</span>


   The master table managing all queues looks like this:

   &lt;CODE BEGINS&gt;

   struct fq_codel_sched_data {
      struct tcf_proto *filter_list;  /* optional external classifier */
      struct fq_codel_flow *flows;    /* Flows table [flows_cnt] */
      u32             *backlogs;      /* backlog table [flows_cnt] */
      u32             flows_cnt;      /* number of flows */
      u32             perturbation;   /* hash perturbation */
      u32             quantum;        /* psched_mtu(qdisc_dev(sch)); */
      struct codel_params cparams;
      struct codel_stats cstats;
      u32             drop_overlimit;
      u32             new_flow_count;

      struct list_head new_flows;     /* list of new flows */
      struct list_head old_flows;     /* list of old flows */
   };

   &lt;CODE ENDS&gt;

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.5.%20%20Per-Packet%20Timestamping"></a><a class="selflink" href="#section-5.5" name="section-5.5">5.5</a>.  Per-Packet Timestamping</span>

   The CoDel portion of the algorithm requires per-packet timestamps be
   stored along with the packet.  While this approach works well for
   software-based routers, it may be impossible to retrofit devices that
   do most of their processing in silicon and lack the space or
   mechanism for timestamping.

   Also, while perfect resolution is not needed, timestamp resolution
   finer than the CoDel target setting is necessary.  Furthermore,
   timestamping functions in the core OS need to be efficient, as they
   are called at least once on each packet enqueue and dequeue.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.6.%20%20Limiting%20Queueing%20in%20Lower%20Layers"></a><a class="selflink" href="#section-5.6" name="section-5.6">5.6</a>.  Limiting Queueing in Lower Layers</span>

   When deploying a queue management algorithm such as FQ-CoDel, it is
   important to ensure that the algorithm actually runs in the right
   place to control the queue.  In particular, lower layers of the
   operating system networking stack can have queues of their own, as
   can device drivers and hardware.  Thus, it is desirable that the
   queue management algorithm runs as close to the hardware as possible.
   However, scheduling such complexity at interrupt time is difficult,
   so a small standing queue between the algorithm and the wire is often
   needed at higher transmit rates.





<span class="grey">Hoeiland-Joergensen, et al.   Experimental                     [Page 16]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-17" id="page-17" name="page-17"> </a>
<span class="grey"><a href="rfc8290.html">RFC 8290</a>                        FQ-CoDel                    January 2018</span>


   In Linux, the mechanism to ensure these different needs are balanced
   is called "Byte Queue Limits" [<a href="#ref-BQL" title='"bql: Byte Queue Limits"'>BQL</a>]; it controls the device driver
   ring buffer (for physical line rates).  For cases where this
   functionality is not available, the queue can be controlled by means
   of a software rate limiter such as Hierarchical Token Bucket [<a href="#ref-HTB" title='"Token Bucket: Variations"'>HTB</a>] or
   Hierarchical Fair-Service Curve [<a href="#ref-HFSC" title='"A Hierarchical Fair Service Curve Algorithm for Link-Sharing, Real-Time and Priority Services"'>HFSC</a>].  The Cake algorithm [<a href="#ref-CAKE" title='"Cake - Common Applications Kept Enhanced"'>CAKE</a>]
   integrates a software rate limiter for this purpose.

   Other issues with queues at lower layers are described in [<a href="#ref-CODEL" title='"Controlling Queue Delay"'>CODEL</a>].

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.7.%20%20Other%20Forms%20of%20Fair%20Queueing"></a><a class="selflink" href="#section-5.7" name="section-5.7">5.7</a>.  Other Forms of Fair Queueing</span>

   Much of the scheduling portion of FQ-CoDel is derived from DRR and is
   substantially similar to DRR++.  Versions based on Stochastic Fair
   Queueing [<a href="#ref-SFQ" title='"Stochastic Fairness Queueing"'>SFQ</a>] have also been produced and tested in ns2.  Other
   forms of fair queueing, such as Weighted Fair Queueing [<a href="#ref-WFQ" title='"Analysis and Simulation of a Fair Queueing Algorithm"'>WFQ</a>] or Quick
   Fair Queueing [<a href="#ref-QFQ" title='"QFQ: Efficient Packet Scheduling with Tight Guarantees"'>QFQ</a>], have not been thoroughly explored, but there's
   no a priori reason why the round-robin scheduling of FQ-CoDel
   couldn't be replaced with something else.

   For a comprehensive discussion of fairness queueing algorithms and
   their combination with AQM, see [<a href="rfc7806.html" title='"On Queuing, Marking, and Dropping"'>RFC7806</a>].

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.8.%20%20Differences%20between%20CoDel%20and%20FQ-CoDel%20Behaviour"></a><a class="selflink" href="#section-5.8" name="section-5.8">5.8</a>.  Differences between CoDel and FQ-CoDel Behaviour</span>

   CoDel can be applied to a single queue system as a straight AQM,
   where it converges towards an "ideal" drop rate (i.e., one that
   minimises delay while keeping a high link utilisation) and then
   optimises around that control point.

   The scheduling of FQ-CoDel mixes packets of competing flows, which
   acts to pace bursty flows to better fill the pipe.  Additionally, a
   new flow gets substantial leeway over other flows until CoDel finds
   an ideal drop rate for it.  However, for a new flow that exceeds the
   configured quantum, more time passes before all of its data is
   delivered (as packets from it, too, are mixed across the other
   existing queue-building flows).  Thus, FQ-CoDel takes longer (as
   measured in time) to converge towards an ideal drop rate for a given
   new flow but does so within fewer delivered _packets_ from that flow.

   Finally, the flow isolation provided by FQ-CoDel means that the CoDel
   drop mechanism operates on the flows actually building queues; this
   results in packets being dropped more accurately from the largest
   flows than when only CoDel is used.  Additionally, flow isolation
   radically improves the transient behaviour of the network when
   traffic or link characteristics change (e.g., when new flows start up
   or the link bandwidth changes); while CoDel itself can take a while
   to respond, FQ-CoDel reacts almost immediately.



<span class="grey">Hoeiland-Joergensen, et al.   Experimental                     [Page 17]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-18" id="page-18" name="page-18"> </a>
<span class="grey"><a href="rfc8290.html">RFC 8290</a>                        FQ-CoDel                    January 2018</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/6.%20%20Limitations%20of%20Flow%20Queueing"></a><a class="selflink" href="#section-6" name="section-6">6</a>.  Limitations of Flow Queueing</span>

   While FQ-CoDel has been shown in many scenarios to offer significant
   performance gains compared to alternative queue management
   strategies, there are some scenarios where the scheduling algorithm
   in particular is not a good fit.  This section documents some of the
   known cases in which either the default behaviour may require
   tweaking or alternatives to flow queueing should be considered.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/6.1.%20%20Fairness%20between%20Things%20Other%20Than%20Flows"></a><a class="selflink" href="#section-6.1" name="section-6.1">6.1</a>.  Fairness between Things Other Than Flows</span>

   In some parts of the network, enforcing flow-level fairness may not
   be desirable, or some other form of fairness may be more important.
   Some examples of this include an ISP that may be more interested in
   ensuring fairness between customers than between flows or a hosting
   or transit provider that wishes to ensure fairness between connecting
   Autonomous Systems or networks.  Another issue can be that the number
   of simultaneous flows experienced at a particular link can be too
   high for flow-based fairness queueing to be effective.

   Whatever the reason, in a scenario where fairness between flows is
   not desirable, reconfiguring FQ-CoDel to match on a different
   characteristic can be a way forward.  The implementation in Linux can
   leverage the packet matching mechanism of the "tc" subsystem to use
   any available packet field to partition packets into virtual queues,
   for instance, to match on address or subnet source/destination pairs,
   application-layer characteristics, etc.

   Furthermore, as commonly deployed today, FQ-CoDel is used with three
   or more tiers of service classification, based on Diffserv markings:
   priority, best effort, and background.  Some products do more
   detailed classification, including deep packet inspection and
   destination-specific filters to achieve their desired result.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/6.2.%20%20Flow%20Bunching%20by%20Opaque%20Encapsulation"></a><a class="selflink" href="#section-6.2" name="section-6.2">6.2</a>.  Flow Bunching by Opaque Encapsulation</span>

   Where possible, FQ-CoDel will attempt to decapsulate packets before
   matching on the header fields for the flow hashing.  However, for
   some encapsulation techniques, most notably encrypted VPNs, this is
   not possible.  If several flows are bunched into one such
   encapsulated tunnel, they will be seen as one flow by the FQ-CoDel
   algorithm.  This means that they will share a queue and drop
   behaviour, so flows inside the encapsulation will not benefit from
   the implicit prioritisation of FQ-CoDel but will continue to benefit
   from the reduced overall queue length from the CoDel algorithm
   operating on the queue.  In addition, when such an encapsulated bunch





<span class="grey">Hoeiland-Joergensen, et al.   Experimental                     [Page 18]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-19" id="page-19" name="page-19"> </a>
<span class="grey"><a href="rfc8290.html">RFC 8290</a>                        FQ-CoDel                    January 2018</span>


   competes against other flows, it will count as one flow and not
   assigned a share of the bandwidth based on how many flows are inside
   the encapsulation.

   Depending on the application, this may or may not be desirable
   behaviour.  In cases where it is not, changing FQ-CoDel's matching to
   not be flow-based (as detailed in the previous subsection above) can
   be a mitigation.  Going forward, having some mechanism for opaque
   encapsulations to express to the outer layer which flow a packet
   belongs to could be a way to mitigate this.  Naturally, care needs to
   be taken when designing such a mechanism to ensure no new privacy and
   security issues are raised by exposing information from inside the
   encapsulation to the outside world.  Keeping the extra information
   out of band and dropping it before it hits the network could be one
   way to achieve this.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/6.3.%20%20Low-Priority%20Congestion%20Control%20Algorithms"></a><a class="selflink" href="#section-6.3" name="section-6.3">6.3</a>.  Low-Priority Congestion Control Algorithms</span>

   In the presence of queue management schemes that limit latency under
   load, low-priority congestion control algorithms such as Low Extra
   Delay Background Transport (LEDBAT) [<a href="rfc6817.html" title='"Low Extra Delay Background Transport (LEDBAT)"'>RFC6817</a>] (or, in general,
   algorithms that try to voluntarily use up less than their fair share
   of bandwidth) experience little added latency when the link is
   congested.  Thus, they lack the signal to back off that added latency
   previously afforded them.  This effect is seen with FQ-CoDel as well
   as with any effective AQM [<a href="#ref-GONG2014" title='"Fighting the bufferbloat: On the coexistence of AQM and low priority congestion control"'>GONG2014</a>].

   As such, these delay-based algorithms tend to revert to loss-based
   congestion control and will consume the fair share of bandwidth
   afforded to them by the FQ-CoDel scheduler.  However, low-priority
   congestion control mechanisms may be able to take steps to continue
   to be low priority, for instance, by taking into account the vastly
   reduced level of delay afforded by an AQM or by using a coupled
   approach to observing the behaviour of multiple flows.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/7.%20%20Deployment%20Status%20and%20Future%20Work"></a><a class="selflink" href="#section-7" name="section-7">7</a>.  Deployment Status and Future Work</span>

   The FQ-CoDel algorithm as described in this document has been shipped
   as part of the Linux kernel since version 3.5 (released on the 21st
   of July, 2012), with the ce_threshold being added in version 4.2.
   The algorithm has seen widespread testing in a variety of contexts
   and is configured as the default queueing discipline in a number of
   mainline Linux distributions (as of this writing, at least OpenWRT,
   Arch Linux, and Fedora).  In addition, a BSD implementation is
   available.  All data resulting from these trials have shown FQ-CoDel
   to be a massive improvement over the previous default FIFO queue, and
   people are encouraged to turn it on.




<span class="grey">Hoeiland-Joergensen, et al.   Experimental                     [Page 19]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-20" id="page-20" name="page-20"> </a>
<span class="grey"><a href="rfc8290.html">RFC 8290</a>                        FQ-CoDel                    January 2018</span>


   Of course, there is always room for improvement, and this document
   has listed some of the known limitations of the algorithm.  As such,
   we encourage further research into algorithm refinements and
   addressing of limitations.  One such effort has been undertaken by
   the bufferbloat community in the form of the Cake queue management
   scheme [<a href="#ref-CAKE" title='"Cake - Common Applications Kept Enhanced"'>CAKE</a>].  In addition to this, we believe the following
   (non-exhaustive) list of issues to be worthy of further enquiry:

   o  Variations on the flow classification mechanism to fit different
      notions of flows.  For instance, an ISP might want to deploy per-
      subscriber scheduling, while in other cases, several flows can
      share a 5-tuple, as exemplified by the RTCWEB QoS recommendations
      [<a href="#ref-WEBRTC-QOS">WEBRTC-QOS</a>].

   o  Interactions between flow queueing and delay-based congestion
      control algorithms and scavenger protocols.

   o  Other scheduling mechanisms to replace the DRR portion of the
      algorithm, e.g., QFQ or WFQ.

   o  Sensitivity of parameters, most notably, the number of queues and
      the CoDel parameters.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/8.%20%20Security%20Considerations"></a><a class="selflink" href="#section-8" name="section-8">8</a>.  Security Considerations</span>

   There are no specific security exposures associated with FQ-CoDel
   that are not also present in current FIFO systems.  On the contrary,
   some vulnerabilities of FIFO systems are reduced with FQ-CoDel (e.g.,
   simple minded packet floods).  However, some care is needed in the
   implementation to ensure this is the case.  These are included in the
   description above, but we reiterate them here:

   o  To prevent packets in the new queues from starving old queues, it
      is important that when a queue on the list of new queues empties,
      it is moved to _the end of_ the list of old queues.  This is
      described at the end of <a href="#section-4.2">Section 4.2</a>.

   o  To prevent an attacker targeting a specific flow for a denial-of-
      service attack, the hash that maps packets to queues should not be
      predictable.  To achieve this, FQ-CoDel salts the hash, as
      described in the beginning of <a href="#section-4.1">Section 4.1</a>.  The size of the salt
      and the strength of the hash function is obviously a trade-off
      between performance and security.  The Linux implementation uses a
      32-bit random value as the salt and a Jenkins hash function.  This
      makes it possible to achieve high throughput, and we consider it
      sufficient to ward off the most obvious attacks.





<span class="grey">Hoeiland-Joergensen, et al.   Experimental                     [Page 20]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-21" id="page-21" name="page-21"> </a>
<span class="grey"><a href="rfc8290.html">RFC 8290</a>                        FQ-CoDel                    January 2018</span>


   o  Packet fragments without a Layer 4 header can be hashed into
      different bins than the first fragment with the header intact.
      This can cause reordering and/or adversely affect the performance
      of the flow.  Keeping state to match the fragments to the
      beginning of the packet or simply putting all packet fragments
      (including the first fragment of each fragmented packet) into the
      same queue are two ways to alleviate this.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/9.%20%20IANA%20Considerations"></a><a class="selflink" href="#section-9" name="section-9">9</a>.  IANA Considerations</span>

   This document does not require any IANA actions.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/10.%20%20References"></a><a class="selflink" href="#section-10" name="section-10">10</a>.  References</span>

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/10.1.%20%20Normative%20References"></a><a class="selflink" href="#section-10.1" name="section-10.1">10.1</a>.  Normative References</span>

   [<a id="ref-RFC2119" name="ref-RFC2119">RFC2119</a>]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", <a href="https://tools.ietf.org/html/bcp14">BCP 14</a>, <a href="rfc2119.html">RFC 2119</a>,
              DOI 10.17487/RFC2119, March 1997,
              &lt;<a href="https://www.rfc-editor.org/info/rfc2119">https://www.rfc-editor.org/info/rfc2119</a>&gt;.

   [<a id="ref-RFC7806" name="ref-RFC7806">RFC7806</a>]  Baker, F. and R. Pan, "On Queuing, Marking, and Dropping",
              <a href="rfc7806.html">RFC 7806</a>, DOI 10.17487/RFC7806, April 2016,
              &lt;<a href="https://www.rfc-editor.org/info/rfc7806">https://www.rfc-editor.org/info/rfc7806</a>&gt;.

   [<a id="ref-RFC8174" name="ref-RFC8174">RFC8174</a>]  Leiba, B., "Ambiguity of Uppercase vs Lowercase in <a href="rfc2119.html">RFC</a>
              <a href="rfc2119.html">2119</a> Key Words", <a href="https://tools.ietf.org/html/bcp14">BCP 14</a>, <a href="rfc8174.html">RFC 8174</a>, DOI 10.17487/RFC8174,
              May 2017, &lt;<a href="https://www.rfc-editor.org/info/rfc8174">https://www.rfc-editor.org/info/rfc8174</a>&gt;.

   [<a id="ref-RFC8289" name="ref-RFC8289">RFC8289</a>]  Nichols, K., Jacobson, V., McGregor, A., Ed., and J.
              Iyengar, Ed., "Controlled Delay Active Queue Management",
              <a href="rfc8289.html">RFC 8289</a>, DOI 10.17487/RFC8289, January 2018,
              &lt;<a href="https://www.rfc-editor.org/info/rfc8289">https://www.rfc-editor.org/info/rfc8289</a>&gt;.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/10.2.%20%20Informative%20References"></a><a class="selflink" href="#section-10.2" name="section-10.2">10.2</a>.  Informative References</span>

   [<a id="ref-BLOAT" name="ref-BLOAT">BLOAT</a>]    Gettys, J. and K. Nichols, "Bufferbloat: Dark Buffers in
              the Internet", Communications of the ACM, Volume 55, Issue
              1, DOI 10.1145/2063176.2063196, January 2012.

   [<a id="ref-BLOATWEB" name="ref-BLOATWEB">BLOATWEB</a>] "Bufferbloat", &lt;<a href="https://www.bufferbloat.net/">https://www.bufferbloat.net</a>&gt;.

   [<a id="ref-BQL" name="ref-BQL">BQL</a>]      Herbert, T., "bql: Byte Queue Limits", August 2011,
              &lt;<a href="https://lwn.net/Articles/454378/">https://lwn.net/Articles/454378/</a>&gt;.

   [<a id="ref-CAKE" name="ref-CAKE">CAKE</a>]     "Cake - Common Applications Kept Enhanced",
              &lt;<a href="http://www.bufferbloat.net/projects/codel/wiki/Cake">http://www.bufferbloat.net/projects/codel/wiki/Cake</a>&gt;.




<span class="grey">Hoeiland-Joergensen, et al.   Experimental                     [Page 21]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-22" id="page-22" name="page-22"> </a>
<span class="grey"><a href="rfc8290.html">RFC 8290</a>                        FQ-CoDel                    January 2018</span>


   [<a id="ref-CODEL" name="ref-CODEL">CODEL</a>]    Nichols, K. and V. Jacobson, "Controlling Queue Delay",
              ACM Queue, Volume 10, Issue 5,
              DOI 10.1145/2208917.2209336, May 2012,
              &lt;<a href="http://queue.acm.org/detail.cfm?id=2209336">http://queue.acm.org/detail.cfm?id=2209336</a>&gt;.

   [<a id="ref-DRR" name="ref-DRR">DRR</a>]      Shreedhar, M. and G. Varghese, "Efficient Fair Queueing
              Using Deficit Round Robin", IEEE/ACM Transactions on
              Networking, Volume 4, Issue 3, DOI 10.1109/90.502236, June
              1996.

   [<a id="ref-DRRPP" name="ref-DRRPP">DRRPP</a>]    MacGregor, M. and W. Shi, "Deficits for Bursty Latency-
              Critical Flows: DRR++", Proceedings of the IEEE
              International Conference on Networks 2000 (ICON 2000),
              DOI 10.1109/ICON.2000.875803, September 2000,
              &lt;<a href="http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=875803">http://ieeexplore.ieee.org/xpls/</a>
              <a href="http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=875803">abs_all.jsp?arnumber=875803</a>&gt;.

   [<a id="ref-GONG2014" name="ref-GONG2014">GONG2014</a>] Gong, Y., Rossi, D., Testa, C., Valenti, S., and D. Taht,
              "Fighting the bufferbloat: On the coexistence of AQM and
              low priority congestion control", Elsevier Computer
              Networks, Volume 65, DOI 10.1016/j.bjp.2014.01.009, June
              2014, &lt;<a href="https://www.sciencedirect.com/science/article/pii/S1389128614000188">https://www.sciencedirect.com/science/article/pii/</a>
              <a href="https://www.sciencedirect.com/science/article/pii/S1389128614000188">S1389128614000188</a>&gt;.

   [<a id="ref-HFSC" name="ref-HFSC">HFSC</a>]     Stoica, I., Zhang, H., and T. Eugene Ng, "A Hierarchical
              Fair Service Curve Algorithm for Link-Sharing, Real-Time
              and Priority Services", Proceedings of ACM SIGCOMM,
              DOI 10.1145/263105.263175, September 1997,
              &lt;<a href="http://conferences.sigcomm.org/sigcomm/1997/papers/p011.pdf">http://conferences.sigcomm.org/sigcomm/1997/papers/</a>
              <a href="http://conferences.sigcomm.org/sigcomm/1997/papers/p011.pdf">p011.pdf</a>&gt;.

   [<a id="ref-HTB" name="ref-HTB">HTB</a>]      Wikipedia, "Token Bucket: Variations", October 2017,
              &lt;<a href="https://en.wikipedia.org/w/index.php?title=Token_bucket&amp;oldid=803574657">https://en.wikipedia.org/w/</a>
              <a href="https://en.wikipedia.org/w/index.php?title=Token_bucket&amp;oldid=803574657">index.php?title=Token_bucket&amp;oldid=803574657</a>&gt;.

   [<a id="ref-JENKINS" name="ref-JENKINS">JENKINS</a>]  Jenkins, B., "A Hash Function for Hash Table Lookup",
              &lt;<a href="http://www.burtleburtle.net/bob/hash/doobs.html">http://www.burtleburtle.net/bob/hash/doobs.html</a>&gt;.

   [<a id="ref-LINUXSRC" name="ref-LINUXSRC">LINUXSRC</a>] "Linux Kernel Source Tree", &lt;<a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/net/sched/sch_fq_codel.c">https://git.kernel.org/cgit/l</a>
              <a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/net/sched/sch_fq_codel.c">inux/kernel/git/torvalds/linux.git/tree/net/sched/</a>
              <a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/net/sched/sch_fq_codel.c">sch_fq_codel.c</a>&gt;.

   [<a id="ref-NS2" name="ref-NS2">NS2</a>]      "ns-2", December 2014, &lt;<a href="http://nsnam.sourceforge.net/wiki/index.php?title=Main_Page&amp;oldid=8076">http://nsnam.sourceforge.net/wiki/</a>
              <a href="http://nsnam.sourceforge.net/wiki/index.php?title=Main_Page&amp;oldid=8076">index.php?title=Main_Page&amp;oldid=8076</a>&gt;.

   [<a id="ref-NS3" name="ref-NS3">NS3</a>]      "ns-3", February 2016, &lt;<a href="https://www.nsnam.org/mediawiki/index.php?title=Main_Page&amp;oldid=9883">https://www.nsnam.org/mediawiki/</a>
              <a href="https://www.nsnam.org/mediawiki/index.php?title=Main_Page&amp;oldid=9883">index.php?title=Main_Page&amp;oldid=9883</a>&gt;.




<span class="grey">Hoeiland-Joergensen, et al.   Experimental                     [Page 22]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-23" id="page-23" name="page-23"> </a>
<span class="grey"><a href="rfc8290.html">RFC 8290</a>                        FQ-CoDel                    January 2018</span>


   [<a id="ref-QFQ" name="ref-QFQ">QFQ</a>]      Checconi, F., Rizzo, L., and P. Valente, "QFQ: Efficient
              Packet Scheduling with Tight Guarantees", IEEE/ACM
              Transactions on Networking (TON), Volume 21, Issue 3, pp.
              802-816, DOI 10.1109/TNET.2012.2215881, June 2013,
              &lt;<a href="http://dl.acm.org/citation.cfm?id=2525552">http://dl.acm.org/citation.cfm?id=2525552</a>&gt;.

   [<a id="ref-RFC2003" name="ref-RFC2003">RFC2003</a>]  Perkins, C., "IP Encapsulation within IP", <a href="rfc2003.html">RFC 2003</a>,
              DOI 10.17487/RFC2003, October 1996,
              &lt;<a href="https://www.rfc-editor.org/info/rfc2003">https://www.rfc-editor.org/info/rfc2003</a>&gt;.

   [<a id="ref-RFC2890" name="ref-RFC2890">RFC2890</a>]  Dommety, G., "Key and Sequence Number Extensions to GRE",
              <a href="rfc2890.html">RFC 2890</a>, DOI 10.17487/RFC2890, September 2000,
              &lt;<a href="https://www.rfc-editor.org/info/rfc2890">https://www.rfc-editor.org/info/rfc2890</a>&gt;.

   [<a id="ref-RFC3168" name="ref-RFC3168">RFC3168</a>]  Ramakrishnan, K., Floyd, S., and D. Black, "The Addition
              of Explicit Congestion Notification (ECN) to IP",
              <a href="rfc3168.html">RFC 3168</a>, DOI 10.17487/RFC3168, September 2001,
              &lt;<a href="https://www.rfc-editor.org/info/rfc3168">https://www.rfc-editor.org/info/rfc3168</a>&gt;.

   [<a id="ref-RFC4213" name="ref-RFC4213">RFC4213</a>]  Nordmark, E. and R. Gilligan, "Basic Transition Mechanisms
              for IPv6 Hosts and Routers", <a href="rfc4213.html">RFC 4213</a>,
              DOI 10.17487/RFC4213, October 2005,
              &lt;<a href="https://www.rfc-editor.org/info/rfc4213">https://www.rfc-editor.org/info/rfc4213</a>&gt;.

   [<a id="ref-RFC6817" name="ref-RFC6817">RFC6817</a>]  Shalunov, S., Hazel, G., Iyengar, J., and M. Kuehlewind,
              "Low Extra Delay Background Transport (LEDBAT)", <a href="rfc6817.html">RFC 6817</a>,
              DOI 10.17487/RFC6817, December 2012,
              &lt;<a href="https://www.rfc-editor.org/info/rfc6817">https://www.rfc-editor.org/info/rfc6817</a>&gt;.

   [<a id="ref-RFC8257" name="ref-RFC8257">RFC8257</a>]  Bensley, S., Thaler, D., Balasubramanian, P., Eggert, L.,
              and G. Judd, "Data Center TCP (DCTCP): TCP Congestion
              Control for Data Centers", <a href="rfc8257.html">RFC 8257</a>, DOI 10.17487/RFC8257,
              October 2017, &lt;<a href="https://www.rfc-editor.org/info/rfc8257">https://www.rfc-editor.org/info/rfc8257</a>&gt;.

   [<a id="ref-SFQ" name="ref-SFQ">SFQ</a>]      McKenney, P., "Stochastic Fairness Queueing", Proceedings
              of IEEE INFOCOM, DOI 10.1109/INFCOM.1990.91316, June 1990,
              &lt;<a href="http://perso.telecom-paristech.fr/~bonald/Publications_files/BMO2011.pdf">http://perso.telecom-</a>
              <a href="http://perso.telecom-paristech.fr/~bonald/Publications_files/BMO2011.pdf">paristech.fr/~bonald/Publications_files/BMO2011.pdf</a>&gt;.

   [<a id="ref-SQF" name="ref-SQF">SQF</a>]      Carofiglio, G. and L. Muscariello, "On the Impact of TCP
              and Per-Flow Scheduling on Internet Performance", IEEE/ACM
              Transactions on Networking, Volume 20, Issue 2,
              DOI 10.1109/TNET.2011.2164553, August 2011.

   [<a id="ref-WEBRTC-QOS" name="ref-WEBRTC-QOS">WEBRTC-QOS</a>]
              Jones, P., Dhesikan, S., Jennings, C., and D. Druta, "DSCP
              Packet Markings for WebRTC QoS", Work in Progress,
              <a href="https://tools.ietf.org/html/draft-ietf-tsvwg-rtcweb-qos-18">draft-ietf-tsvwg-rtcweb-qos-18</a>, August 2016.



<span class="grey">Hoeiland-Joergensen, et al.   Experimental                     [Page 23]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-24" id="page-24" name="page-24"> </a>
<span class="grey"><a href="rfc8290.html">RFC 8290</a>                        FQ-CoDel                    January 2018</span>


   [<a id="ref-WFQ" name="ref-WFQ">WFQ</a>]      Demers, A., Keshav, S., and S. Shenker, "Analysis and
              Simulation of a Fair Queueing Algorithm", ACM SIGCOMM
              Computer Communication Review, Volume 19, Issue 4, pp.
              1-12, DOI 10.1145/75247.75248, September 1989,
              &lt;<a href="http://doi.acm.org/10.1145/75247.75248">http://doi.acm.org/10.1145/75247.75248</a>&gt;.

Acknowledgements

   Our deepest thanks to Kathie Nichols, Van Jacobson, and all the
   members of the bufferbloat.net effort for all the help on developing
   and testing the algorithm.  In addition, our thanks to Anil Agarwal
   for his help with getting the hash collision probabilities in this
   document right.






































<span class="grey">Hoeiland-Joergensen, et al.   Experimental                     [Page 24]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-25" id="page-25" name="page-25"> </a>
<span class="grey"><a href="rfc8290.html">RFC 8290</a>                        FQ-CoDel                    January 2018</span>


Authors' Addresses

   Toke Hoeiland-Joergensen
   Karlstad University
   Dept. of Computer Science
   Karlstad  65188
   Sweden
   Email: toke@toke.dk


   Paul McKenney
   IBM Linux Technology Center
   1385 NW Amberglen Parkway
   Hillsboro, OR  97006
   United States of America
   Email: paulmck@linux.vnet.ibm.com
   URI:   <a href="http://www2.rdrop.com/~paulmck/">http://www2.rdrop.com/~paulmck/</a>


   Dave Taht
   Teklibre
   2104 W First street
   Apt 2002
   FT Myers, FL  33901
   United States of America
   Email: dave.taht@gmail.com
   URI:   <a href="http://www.teklibre.com/">http://www.teklibre.com/</a>


   Jim Gettys
   21 Oak Knoll Road
   Carlisle, MA  993
   United States of America
   Email: jg@freedesktop.org
   URI:   <a href="https://en.wikipedia.org/wiki/Jim_Gettys">https://en.wikipedia.org/wiki/Jim_Gettys</a>


   Eric Dumazet
   Google, Inc.
   1600 Amphitheatre Pkwy
   Mountain View, CA  94043
   United States of America
   Email: edumazet@gmail.com








Hoeiland-Joergensen, et al.   Experimental                     [Page 25]

</pre><br/>
    <span class="noprint"><small><small>Html markup produced by rfcmarkup 1.126, available from
      <a href="https://tools.ietf.org/tools/rfcmarkup/">https://tools.ietf.org/tools/rfcmarkup/</a>
    </small></small></span>
  </div>




</body><!-- Mirrored from tools.ietf.org/html/rfc8290 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 06 Mar 2018 23:18:15 GMT --></html>