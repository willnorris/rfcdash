<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml"><!-- Mirrored from tools.ietf.org/html/rfc5338 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 06 Mar 2018 23:18:35 GMT --><!-- Added by HTTrack --><head><meta content="text/html;charset=utf-8" http-equiv="content-type"/><!-- /Added by HTTrack -->

    <meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
    <meta content="index,follow" name="robots"/>
    <meta content="rfcmarkup version 1.126" name="creator"/>
    <link href="http://purl.org/dc/elements/1.1/" rel="schema.DC"/>
<meta content="draft-henderson-hip-applications" name="DC.Relation.Replaces"/>
<meta content="urn:ietf:rfc:5338" name="DC.Identifier"/>
<meta content="September, 2008" name="DC.Date.Issued"/>
<meta content="Henderson, Thomas" name="DC.Creator"/>
<meta content="Komu, Miika" name="DC.Creator"/>
<meta content="Nikander, Pekka" name="DC.Creator"/>
<meta content="This document is an informative overview of how legacy applications
can be made to work with the Host Identity Protocol (HIP). HIP
proposes to add a cryptographic name space for network stack names.
From an application viewpoint, HIP-enabled systems support a new
address family of host identifiers, but it may be a long time until
such HIP-aware applications are widely deployed even if host systems
are upgraded. This informational document discusses implementation and
Application Programming Interface (API) issues relating to using HIP
in situations in which the system is HIP-aware but the applications
are not, and is intended to aid implementors and early adopters in
thinking about and locally solving systems issues regarding the
incremental deployment of HIP." name="DC.Description.Abstract"/>
<meta content="Using the Host Identity Protocol with Legacy Applications" name="DC.Title"/>

    <link href="https://tools.ietf.org/images/rfc.png" rel="icon" type="image/png"/>
    <link href="https://tools.ietf.org/images/rfc.png" rel="shortcut icon" type="image/png"/>
    <title>RFC 5338 - Using the Host Identity Protocol with Legacy Applications</title>
    
    
    <style type="text/css">
	@media only screen 
	  and (min-width: 992px)
	  and (max-width: 1199px) {
	    body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 768px)
	  and (max-width: 991px) {
            body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 480px)
	  and (max-width: 767px) {
            body { font-size: 11pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (max-width: 479px) {
            body { font-size: 8pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-device-width : 375px) 
	  and (max-device-width : 667px) {
            body { font-size: 9.5pt; }
            div.content { width: 96ex; margin: 0 1px; }
        }
	@media only screen 
	  and (min-device-width: 1200px) {
            body { font-size: 10pt; margin: 0 4em; }
            div.content { width: 96ex; margin: 0; }
        }
        h1, h2, h3, h4, h5, h6, .h1, .h2, .h3, .h4, .h5, .h6 {
	    font-weight: bold;
            line-height: 0pt;
            display: inline;
            white-space: pre;
            font-family: monospace;
            font-size: 1em;
	    font-weight: bold;
        }
        pre {
            font-size: 1em;
            margin-top: 0px;
            margin-bottom: 0px;
        }
	.pre {
	    white-space: pre;
	    font-family: monospace;
	}
	.header{
	    font-weight: bold;
	}
        .newpage {
            page-break-before: always;
        }
        .invisible {
            text-decoration: none;
            color: white;
        }
        a.selflink {
          color: black;
          text-decoration: none;
        }
        @media print {
            body {
                font-family: monospace;
                font-size: 10.5pt;
            }
            h1, h2, h3, h4, h5, h6 {
                font-size: 1em;
            }
        
            a:link, a:visited {
                color: inherit;
                text-decoration: none;
            }
            .noprint {
                display: none;
            }
        }
	@media screen {
	    .grey, .grey a:link, .grey a:visited {
		color: #777;
	    }
            .docinfo {
                background-color: #EEE;
            }
            .top {
                border-top: 7px solid #EEE;
            }
            .bgwhite  { background-color: white; }
            .bgred    { background-color: #F44; }
            .bggrey   { background-color: #666; }
            .bgbrown  { background-color: #840; }            
            .bgorange { background-color: #FA0; }
            .bgyellow { background-color: #EE0; }
            .bgmagenta{ background-color: #F4F; }
            .bgblue   { background-color: #66F; }
            .bgcyan   { background-color: #4DD; }
            .bggreen  { background-color: #4F4; }

            .legend   { font-size: 90%; }
            .cplate   { font-size: 70%; border: solid grey 1px; }
	}
    </style>
    <!--[if IE]>
    <style>
    body {
       font-size: 13px;
       margin: 10px 10px;
    }
    </style>
    <![endif]-->

    <script type="text/javascript"><!--
    function addHeaderTags() {
	var spans = document.getElementsByTagName("span");
	for (var i=0; i < spans.length; i++) {
	    var elem = spans[i];
	    if (elem) {
		var level = elem.getAttribute("class");
                if (level == "h1" || level == "h2" || level == "h3" || level == "h4" || level == "h5" || level == "h6") {
                    elem.innerHTML = "<"+level+">"+elem.innerHTML+"</"+level+">";		
                }
	    }
	}
    }
    var legend_html = "Colour legend:<br />      <table>         <tr><td>Unknown:</td>                   <td><span class='cplate bgwhite'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft:</td>                     <td><span class='cplate bgred'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Informational:</td>             <td><span class='cplate bgorange'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Experimental:</td>              <td><span class='cplate bgyellow'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Best Common Practice:</td>      <td><span class='cplate bgmagenta'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Proposed Standard:</td>         <td><span class='cplate bgblue'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft Standard (old designation):</td> <td><span class='cplate bgcyan'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Internet Standard:</td>         <td><span class='cplate bggreen'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Historic:</td>                  <td><span class='cplate bggrey'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Obsolete:</td>                  <td><span class='cplate bgbrown'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>     </table>";
    function showElem(id) {
        var elem = document.getElementById(id);
        elem.innerHTML = eval(id+"_html");
        elem.style.visibility='visible';
    }
    function hideElem(id) {
        var elem = document.getElementById(id);
        elem.style.visibility='hidden';        
        elem.innerHTML = "";
    }
    // -->
    </script>
</head>
<body onload="addHeaderTags()">
  <div class="content">
   <div style="height: 13px;">
      <div class="pre noprint docinfo bgyellow" onclick="showElem('legend');" onmouseout="hideElem('legend')" onmouseover="this.style.cursor='pointer';" style="height: 6px; position: absolute;" title="Click for colour legend.">                                                                        </div>
      <div class="docinfo noprint pre legend" id="legend" onmouseout="hideElem('legend');" onmouseover="showElem('legend');" style="position:absolute; top: 4px; left: 4ex; visibility:hidden; background-color: white; padding: 4px 9px 5px 7px; border: solid #345 1px; ">
      </div>
   </div>
<span class="pre noprint docinfo top">[<a href="index.html" title="Document search and retrieval page">Docs</a>] [<a href="https://tools.ietf.org/rfc/rfc5338.txt" title="Plaintext version of this document">txt</a>|<a href="https://tools.ietf.org/pdf/rfc5338" title="PDF version of this document">pdf</a>] [<a href="https://tools.ietf.org/html/draft-ietf-hip-applications" title="draft-ietf-hip-applications">draft-ietf-hip-...</a>] [<a href="https://datatracker.ietf.org/doc/rfc5338" title="IESG Datatracker information for this document">Tracker</a>] [<a href="https://tools.ietf.org/rfcdiff?difftype=--hwdiff&amp;url2=rfc5338" title="Inline diff (wdiff)">Diff1</a>] [<a href="https://tools.ietf.org/rfcdiff?url2=rfc5338" title="Side-by-side diff">Diff2</a>]         </span><br/>
<span class="pre noprint docinfo">                                                                        </span><br/>
<span class="pre noprint docinfo">                                                            EXPERIMENTAL</span><br/>
<span class="pre noprint docinfo">                                                                        </span><br/>
<pre>Network Working Group                                       T. Henderson
Request for Comments: 5338                            The Boeing Company
Category: Informational                                      P. Nikander
                                            Ericsson Research NomadicLab
                                                                 M. Komu
                           Helsinki Institute for Information Technology
                                                          September 2008


       <span class="h1">Using the Host Identity Protocol with Legacy Applications</span>

Status of This Memo

   This memo provides information for the Internet community.  It does
   not specify an Internet standard of any kind.  Distribution of this
   memo is unlimited.

Abstract

   This document is an informative overview of how legacy applications
   can be made to work with the Host Identity Protocol (HIP).  HIP
   proposes to add a cryptographic name space for network stack names.
   From an application viewpoint, HIP-enabled systems support a new
   address family of host identifiers, but it may be a long time until
   such HIP-aware applications are widely deployed even if host systems
   are upgraded.  This informational document discusses implementation
   and Application Programming Interface (API) issues relating to using
   HIP in situations in which the system is HIP-aware but the
   applications are not, and is intended to aid implementors and early
   adopters in thinking about and locally solving systems issues
   regarding the incremental deployment of HIP.




















<span class="grey">Henderson, et al.            Informational                      [Page 1]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-2" id="page-2" name="page-2"> </a>
<span class="grey"><a href="rfc5338.html">RFC 5338</a>           Using HIP with Legacy Applications     September 2008</span>


Table of Contents

   <a href="#section-1">1</a>. Introduction ....................................................<a href="#page-2">2</a>
   <a href="#section-2">2</a>. Terminology .....................................................<a href="#page-3">3</a>
   <a href="#section-3">3</a>. Enabling HIP Transparently within the System ....................<a href="#page-4">4</a>
      <a href="#section-3.1">3.1</a>. Applying HIP to Cases in Which IP Addresses Are Used .......<a href="#page-4">4</a>
      <a href="#section-3.2">3.2</a>. Interposing a HIP-Aware Agent in the DNS Resolution ........<a href="#page-6">6</a>
      <a href="#section-3.3">3.3</a>. Discussion .................................................<a href="#page-7">7</a>
   <a href="#section-4">4</a>. Users Invoking HIP with a Legacy Application ....................<a href="#page-8">8</a>
      <a href="#section-4.1">4.1</a>. Connecting to a HIT or LSI .................................<a href="#page-8">8</a>
      <a href="#section-4.2">4.2</a>. Using a Modified DNS Name ..................................<a href="#page-9">9</a>
      <a href="#section-4.3">4.3</a>. Other Techniques ...........................................<a href="#page-9">9</a>
   <a href="#section-5">5</a>. Local Address Management ........................................<a href="#page-9">9</a>
   <a href="#section-6">6</a>. Security Considerations ........................................<a href="#page-11">11</a>
   <a href="#section-7">7</a>. Acknowledgments ................................................<a href="#page-12">12</a>
   <a href="#section-8">8</a>. Informative References .........................................<a href="#page-12">12</a>

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/1.%20%20Introduction"></a><a class="selflink" href="#section-1" name="section-1">1</a>.  Introduction</span>

   The Host Identity Protocol (HIP) [<a href="rfc5201.html" title='"Host Identity Protocol"'>RFC5201</a>] is an experimental effort
   in the IETF and IRTF to study a new public-key-based name space for
   use as host identifiers in Internet protocols.  Fully deployed, the
   HIP architecture would permit applications and users to explicitly
   request the system to send packets to another host by expressing a
   location-independent unique name of a peer host when the system call
   to connect or send packets is performed.  However, there will be a
   transition period during which systems become HIP-enabled but
   applications are not.  This informational document does not propose
   normative specification or even suggest that different HIP
   implementations use more uniform methods for legacy application
   support, but is intended instead to aid implementors and early
   adopters in thinking about and solving systems issues regarding the
   incremental deployment of HIP.

   When applications and systems are both HIP-aware, the coordination
   between the application and the system can be straightforward.  For
   example, using the terminology of the widely used sockets Application
   Programming Interface (API), the application can issue a system call
   to send packets to another host by naming it explicitly, and the
   system can perform the necessary name-to-address mapping to assign
   appropriate routable addresses to the packets.  To enable this, a new
   address family for hosts could be defined, and additional API
   extensions could be defined (such as allowing IP addresses to be
   passed in the system call, along with the host name, as hints of
   where to initially try to reach the host).






<span class="grey">Henderson, et al.            Informational                      [Page 2]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-3" id="page-3" name="page-3"> </a>
<span class="grey"><a href="rfc5338.html">RFC 5338</a>           Using HIP with Legacy Applications     September 2008</span>


   This document does not define a native HIP API such as described
   above.  Rather, this document is concerned with the scenario in which
   the application is not HIP-aware and a traditional IP-address-based
   API is used by the application.

   The discussion so far assumes that applications are written directly
   to a sockets API.  However, many applications are built on top of
   middleware that exports a higher-level API to the application.  In
   this case, for the purpose of this document, we refer to the
   combination of the middleware and the middleware-based application as
   an overall application, or client of the sockets API.

   When HIP is enabled on a system, but the applications are not HIP-
   aware, there are a few basic possibilities to use HIP, each of which
   may or may not be supported by a given HIP implementation.  We report
   here on techniques that have been used or considered by experimental
   HIP implementations.  We organize the discussion around the policy
   chosen to use or expose HIP to the applications.  The first option is
   that users are completely unaware of HIP, or are unable to control
   whether or not HIP is invoked, but rather the system chooses to
   enable HIP for some or all sessions based on policy.  The second
   option is that the user makes a decision to try to use HIP by
   conveying this information somehow within the constraints of the
   unmodified application.  We discuss both of these use cases in detail
   below.

   HIP was designed to work with unmodified applications, to ease
   incremental deployment.  For instance, the HIT is the same size as
   the IPv6 address, and the design thinking was that, during initial
   experiments and transition periods, the HITs could substitute in data
   structures where IPv6 addresses were expected.  However, to a varying
   degree depending on the mechanism employed, such use of HIP can alter
   the semantics of what is considered to be an IP address by
   applications.  Applications use IP addresses as short-lived local
   handles, long-lived application associations, callbacks, referrals,
   and identity comparisons [APP-REF].  The transition techniques
   described below have implications on these different uses of IP
   addresses by legacy applications, and we will try to clarify these
   implications in the below discussions.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/2.%20%20Terminology"></a><a class="selflink" href="#section-2" name="section-2">2</a>.  Terminology</span>

   Callback:   The application at one end retrieves the IP address of
      the peer and uses that to later communicate "back" to the peer.
      An example is the FTP PORT command.

   Host Identity:  An abstract concept applied to a computing platform.




<span class="grey">Henderson, et al.            Informational                      [Page 3]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-4" id="page-4" name="page-4"> </a>
<span class="grey"><a href="rfc5338.html">RFC 5338</a>           Using HIP with Legacy Applications     September 2008</span>


   Host Identifier (HI):  A public key of an asymmetric key pair used as
      a name for a Host Identity.  More details are available in
      [<a href="rfc5201.html" title='"Host Identity Protocol"'>RFC5201</a>].

   Host Identity Tag (HIT):  A 128-bit quantity composed with the hash
      of a Host Identity.  More details are available in [<a href="rfc4843.html" title='"An IPv6 Prefix for Overlay Routable Cryptographic Hash Identifiers (ORCHID)"'>RFC4843</a>] and
      [<a href="rfc5201.html" title='"Host Identity Protocol"'>RFC5201</a>].

   Local Scope Identifier (LSI):  A 32- or 128-bit quantity locally
      representing the Host Identity at the IPv4 or IPv6 API.

   Long-lived application associations:  The IP address is retained by
      the application for several instances of communication.

   Referral:   In an application with more than two parties, party B
      takes the IP address of party A and passes that to party C.  After
      this, party C uses the IP address to communicate with A.

   Resolver:  The system function used by applications to resolve domain
      names to IP addresses.

   Short-lived local handle:  The IP addresses is never retained by the
      application.  The only usage is for the application to pass it
      from the DNS APIs (e.g., getaddrinfo()) and the API to the
      protocol stack (e.g., connect() or sendto()).

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/3.%20%20Enabling%20HIP%20Transparently%20within%20the%20System"></a><a class="selflink" href="#section-3" name="section-3">3</a>.  Enabling HIP Transparently within the System</span>

   When both users and applications are unaware of HIP, but the host
   administrator chooses to use HIP between hosts, a few options are
   possible.  The first basic option is to perform a mapping of the
   application-provided IP address to a host identifier within the
   stack.  The second option, if DNS is used, is to interpose a local
   agent in the DNS resolution process and to return to the application
   a HIT or a locally scoped handle, formatted like an IP address.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.1.%20%20Applying%20HIP%20to%20Cases%20in%20Which%20IP%20Addresses%20Are%20Used"></a><a class="selflink" href="#section-3.1" name="section-3.1">3.1</a>.  Applying HIP to Cases in Which IP Addresses Are Used</span>

   Consider the case in which an application issues a "connect(ip)"
   system call to set the default destination to a system named by
   address "ip", but for which the host administrator would like to
   enable HIP to protect the communications.  The user or application
   intends for the system to communicate with the host reachable at that
   IP address.  The decision to invoke HIP must be done on the basis of
   host policy.  For example, when an IPsec-based implementation of HIP
   is being used, a policy may be entered into the security policy
   database that mandates to use or to try HIP based on a match on the
   source or destination IP address, port numbers, or other factors.



<span class="grey">Henderson, et al.            Informational                      [Page 4]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-5" id="page-5" name="page-5"> </a>
<span class="grey"><a href="rfc5338.html">RFC 5338</a>           Using HIP with Legacy Applications     September 2008</span>


   The mapping of IP address to host identifier may be implemented by
   modifying the host operating system or by wrapping the existing
   sockets API, such as in the TESLA approach [<a href="#ref-TESLA" title='"TESLA: A Transparent, Extensible Session-Layer Architecture for End-to-end Network Services"'>TESLA</a>].

   There are a number of ways that HIP could be configured by the host
   administrator in such a scenario.

   Manual configuration:

      Pre-existing Security Associations (SAs) may be available due to
      previous administrative action, or a binding between an IP address
      and a HIT could be stored in a configuration file or database.

   Opportunistically:

      The system could send an I1 to the Responder with an empty value
      for Responder HIT.

   Using DNS to map IP addresses to HIs:

      If the Responder has host identifiers registered in the forward
      DNS zone and has a PTR record in the reverse zone, the Initiator
      could perform a reverse+forward lookup to learn the HIT associated
      with the address.  Although the approach should work under normal
      circumstances, it has not been tested to verify that there are no
      recursion or bootstrapping issues, particularly if HIP is used to
      secure the connection to the DNS servers.  Discussion of the
      security implications of the use or absence of DNS Security
      (DNSSEC) is deferred to the Security Considerations section.

   Using HIP in the above fashion can cause additional setup delays
   compared to using plain IP.  For opportunistic mode, a host must wait
   to learn whether the peer is HIP-capable, although the delays may be
   mitigated in some implementations by sending initial packets (e.g.,
   TCP SYN) in parallel to the HIP I1 packet and waiting some time to
   receive a HIP R1 before processing a TCP SYN/ACK.  Note that there
   presently does not exist specification for how to invoke such
   connections in parallel.  Resolution latencies may also be incurred
   when using DNS in the above fashion.

   A possible way to reduce the above-noted latencies, in the case that
   the application uses DNS, would be for the system to
   opportunistically query for HIP records in parallel to other DNS
   resource records, and to temporarily cache the HITs returned with a
   DNS lookup, indexed by the IP addresses returned in the same entry,
   and pass the IP addresses up to the application as usual.  If an
   application connects to one of those IP addresses within a short time
   after the lookup, the host should initiate a base exchange using the



<span class="grey">Henderson, et al.            Informational                      [Page 5]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-6" id="page-6" name="page-6"> </a>
<span class="grey"><a href="rfc5338.html">RFC 5338</a>           Using HIP with Legacy Applications     September 2008</span>


   cached HITs.  The benefit is that this removes the uncertainty/delay
   associated with opportunistic HIP, because the DNS record suggests
   that the peer is HIP-capable.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.2.%20%20Interposing%20a%20HIP-Aware%20Agent%20in%20the%20DNS%20Resolution"></a><a class="selflink" href="#section-3.2" name="section-3.2">3.2</a>.  Interposing a HIP-Aware Agent in the DNS Resolution</span>

   In the previous section, it was noted that a HIP-unaware application
   might typically use the DNS to fetch IP addresses prior to invoking
   socket calls.  A HIP-enabled system might make use of DNS to
   transparently fetch host identifiers for such domain names prior to
   the onset of communication.

   A system with a local DNS agent could alternately return a Local
   Scope Identifier (LSI) or HIT rather than an IP address, if HIP
   information is available in the DNS or other directory that binds a
   particular domain name to a host identifier, and otherwise to return
   an IP address as usual.  The system can then maintain a mapping
   between LSI and host identifier and perform the appropriate
   conversion at the system call interface or below.  The application
   uses the LSI or HIT as it would an IP address.  This technique has
   been used in overlay networking experiments such as the Internet
   Indirection Infrastructure (i3) and by at least one HIP
   implementation.

   In the case when resolvers can return multiple destination
   identifiers for an application, it may be configured that some of the
   identifiers can be HIP-based identifiers, and the rest can be IPv4 or
   IPv6 addresses.  The system resolver may return HIP-based identifiers
   in front of the list of identifiers when the underlying system and
   policies support HIP.  An application processing the identifiers
   sequentially will then first try a HIP-based connection and only then
   other non-HIP based connections.  However, certain applications may
   launch the connections in parallel.  In such a case, the non-HIP
   connections may succeed before HIP connections.  Based on local
   system policies, a system may disallow such behavior and return only
   HIP-based identifiers when they are found from DNS.

   If the application obtains LSIs or HITs that it treats as IP
   addresses, a few potential hazards arise.  First, applications that
   perform referrals may pass the LSI to another system that has no
   system context to resolve the LSI back to a host identifier or an IP
   address.  Note that these are the same type of applications that will
   likely break if used over certain types of network address
   translators (NATs).  Second, applications may cache the results of
   DNS queries for a long time, and it may be hard for a HIP system to
   determine when to perform garbage collection on the LSI bindings.
   However, when using HITs, the security of using the HITs for identity
   comparison may be stronger than in the case of using IP addresses.



<span class="grey">Henderson, et al.            Informational                      [Page 6]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-7" id="page-7" name="page-7"> </a>
<span class="grey"><a href="rfc5338.html">RFC 5338</a>           Using HIP with Legacy Applications     September 2008</span>


   Finally, applications may generate log files, and administrators or
   other consumers of these log files may become confused to find LSIs
   or HITs instead of IP addresses.  Therefore, it is recommended that
   the HIP software logs the HITs, LSIs (if applicable), corresponding
   IP addresses, and Fully Qualified Domain Name (FQDN)-related
   information so that administrators can correlate other logs with HIP
   identifiers.

   It may be possible for an LSI or HIT to be routable or resolvable,
   either directly or through an overlay, in which case it would be
   preferable for applications to handle such names instead of IP
   addresses.  However, such networks are out of scope of this document.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.3.%20%20Discussion"></a><a class="selflink" href="#section-3.3" name="section-3.3">3.3</a>.  Discussion</span>

   Solutions preserving the use of IP addresses in the applications have
   the benefit of better support for applications that use IP addresses
   for long-lived application associations, callbacks, and referrals,
   although it should be noted that applications are discouraged from
   using IP addresses in this manner due to the frequent presence of
   NATs [<a href="rfc1958.html" title='"Architectural Principles of the Internet"'>RFC1958</a>].  However, they have weaker security properties than
   the approaches outlined in <a href="#section-3.2">Section 3.2</a> and <a href="#section-4">Section 4</a>, because the
   binding between host identifier and address is weak and not visible
   to the application or user.  In fact, the semantics of the
   application's "connect(ip)" call may be interpreted as "connect me to
   the system reachable at IP address ip" but perhaps no stronger
   semantics than that.  HIP can be used in this case to provide perfect
   forward secrecy and authentication, but not to strongly authenticate
   the peer at the onset of communications.

   Using IP addresses at the application layer may not provide the full
   potential benefits of HIP mobility support.  It allows for mobility
   if the system is able to readdress long-lived, connected sockets upon
   a HIP readdress event.  However, as in current systems, mobility will
   break in the connectionless case, when an application caches the IP
   address and repeatedly calls sendto(), or in the case of TCP when the
   system later opens additional sockets to the same destination.

   <a href="#section-4.1.6">Section 4.1.6</a> of the base HIP protocol specification [<a href="rfc5201.html" title='"Host Identity Protocol"'>RFC5201</a>] states
   that implementations that learn of HIT-to-IP address bindings through
   the use of HIP opportunistic mode must not enforce those bindings on
   later communications sessions.  This implies that when IP addresses
   are used by the applications, systems that attempt to
   opportunistically set up HIP must not assume that later sessions to
   the same address will communicate with the same host.






<span class="grey">Henderson, et al.            Informational                      [Page 7]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-8" id="page-8" name="page-8"> </a>
<span class="grey"><a href="rfc5338.html">RFC 5338</a>           Using HIP with Legacy Applications     September 2008</span>


   The legacy application is unaware of HIP and therefore cannot notify
   the user when the application uses HIP.  However, the operating
   system can notify the user of the usage of HIP through a user agent.
   Further, it is possible for the user agent to name the network
   application that caused a HIP-related event.  This way, the user is
   aware when he or she is using HIP even though the legacy network
   application is not.  Based on usability tests from initial
   deployments, displaying the HITs and LSIs should be avoided in user
   interfaces.  Instead, traditional security measures (lock pictures,
   colored address bars) should be used where possible.

   One drawback to spoofing the DNS resolution is that some
   applications, or selected instances of an application, actually may
   want to fetch IP addresses (e.g., diagnostic applications such as
   ping).  One way to provide finer granularity on whether the resolver
   returns an IP address or an LSI is to have the user form a modified
   domain name when he or she wants to invoke HIP.  This leads us to
   consider, in the next section, use cases for which the end user
   explicitly and selectively chooses to enable HIP.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/4.%20%20Users%20Invoking%20HIP%20with%20a%20Legacy%20Application"></a><a class="selflink" href="#section-4" name="section-4">4</a>.  Users Invoking HIP with a Legacy Application</span>

   The previous section described approaches for configuring HIP for
   legacy applications that did not necessarily involve the user.
   However, there may be cases in which a legacy application user wants
   to use HIP for a given application instance by signaling to the HIP-
   enabled system in some way.  If the application user interface or
   configuration file accepts IP addresses, there may be an opportunity
   to provide a HIT or an LSI in its place.  Furthermore, if the
   application uses DNS, a user may provide a specially crafted domain
   name to signal to the resolver to fetch HIP records and to signal to
   the system to use HIP.  We describe both of these approaches below.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.1.%20%20Connecting%20to%20a%20HIT%20or%20LSI"></a><a class="selflink" href="#section-4.1" name="section-4.1">4.1</a>.  Connecting to a HIT or LSI</span>

   <a href="#section-3.2">Section 3.2</a> above describes the use of HITs or LSIs as spoofed return
   values of the DNS resolution process.  A similar approach that is
   more explicit is to configure the application to connect directly to
   a HIT (e.g., "connect(HIT)" as a socket call).  This scenario has
   stronger security semantics, because the application is asking the
   system to send packets specifically to the named peer system.  HITs
   have been defined as Overlay Routable Cryptographic Hash Identifiers
   (ORCHIDs) such that they cannot be confused with routable IP
   addresses; see [<a href="rfc4843.html" title='"An IPv6 Prefix for Overlay Routable Cryptographic Hash Identifiers (ORCHID)"'>RFC4843</a>].

   This approach also has a few challenges.  Using HITs can be more
   cumbersome for human users (due to the flat HIT name space) than
   using either IPv6 addresses or domain names.  Another challenge with



<span class="grey">Henderson, et al.            Informational                      [Page 8]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-9" id="page-9" name="page-9"> </a>
<span class="grey"><a href="rfc5338.html">RFC 5338</a>           Using HIP with Legacy Applications     September 2008</span>


   this approach is in actually finding the IP addresses to use, based
   on the HIT.  Some type of HIT resolution service would be needed in
   this case.  A third challenge of this approach is in supporting
   callbacks and referrals to possibly non-HIP-aware hosts.  However,
   since most communications in this case would likely be to other HIP-
   aware hosts (else the initial HIP associations would fail to
   establish), the resulting referral problem may be that the peer host
   supports HIP but is not able to perform HIT resolution for some
   reason.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.2.%20%20Using%20a%20Modified%20DNS%20Name"></a><a class="selflink" href="#section-4.2" name="section-4.2">4.2</a>.  Using a Modified DNS Name</span>

   Specifically, if the application requests to resolve "HIP-
   www.example.com" (or some similar prefix string), then the system
   returns an LSI, while if the application requests to resolve
   "www.example.com", IP address(es) are returned as usual.  The use of
   a prefix rather than suffix is recommended, and the use of a string
   delimiter that is not a dot (".") is also recommended, to reduce the
   likelihood that such modified DNS names are mistakenly treated as
   names rooted at a new top-level domain.  Limits of domain name length
   or label length (255 or 63, respectively) should be considered when
   prepending any prefixes.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.3.%20%20Other%20Techniques"></a><a class="selflink" href="#section-4.3" name="section-4.3">4.3</a>.  Other Techniques</span>

   Alternatives to using a modified DNS name that have been experimented
   with include the following.  Command-line tools or tools with a
   graphical user interface (GUI) can be provided by the system to allow
   a user to set the policy on which applications use HIP.  Another
   common technique, for dynamically linked applications, is to
   dynamically link the application to a modified library that wraps the
   system calls and interposes HIP layer communications on them; this
   can be invoked by the user by running commands through a special
   shell, for example.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/5.%20%20Local%20Address%20Management"></a><a class="selflink" href="#section-5" name="section-5">5</a>.  Local Address Management</span>

   The previous two sections focused mainly on controlling client
   behavior (HIP initiator).  We must also consider the behavior for
   servers.  Typically, a server binds to a wildcard IP address and
   well-known port.  In the case of HIP use with legacy server
   implementations, there are again a few options.  The system may be
   configured manually to always, optionally (depending on the client
   behavior), or never use HIP with a particular service, as a matter of
   policy, when the server specifies a wildcard (IP) address.






<span class="grey">Henderson, et al.            Informational                      [Page 9]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-10" id="page-10" name="page-10"> </a>
<span class="grey"><a href="rfc5338.html">RFC 5338</a>           Using HIP with Legacy Applications     September 2008</span>


   When a system API call such as getaddrinfo [<a href="rfc3493.html" title='"Basic Socket Interface Extensions for IPv6"'>RFC3493</a>] is used for
   resolving local addresses, it may also return HITs or LSIs, if the
   system has assigned HITs or LSIs to internal virtual interfaces
   (common in many HIP implementations).  The application may use such
   identifiers as addresses in subsequent socket calls.

   Some applications may try to bind a socket to a specific local
   address, or may implement server-side access control lists based on
   socket calls such as getsockname() and getpeername() in the C-based
   socket APIs.  If the local address specified is an IP address, again,
   the underlying system may be configured to still use HIP.  If the
   local address specified is a HIT (<a href="#section-4">Section 4</a>), the system should
   enforce that connections to the local application can only arrive to
   the specified HIT.  If a system has many HIs, an application that
   binds to a single HIT cannot accept connections to the other HIs but
   the one corresponding to the specified HIT.

   When a host has multiple HIs and the socket behavior does not
   prescribe the use of any particular HI as a local identifier, it is a
   matter of local policy as to how to select a HI to serve as a local
   identifier.  However, systems that bind to a wildcard may face
   problems when multiple HITs or LSIs are defined.  These problems are
   not specific to HIP per se, but are also encountered in non-HIP
   multihoming scenarios with applications not designed for multihoming.

   As an example, consider a client application that sends a UDP
   datagram to a server that is bound to a wildcard.  The server
   application receives the packet using recvfrom() and sends a response
   using sendto().  The problem here is that sendto() may actually use a
   different server HIT than the client assumes.  The client will drop
   the response packet when the client implements access control on the
   UDP socket (e.g., using connect()).

   Reimplementing the server application using the sendmsg() and
   recvmsg() to support multihoming (particularly considering the
   ancillary data) would be the ultimate solution to this problem, but
   with legacy applications is not an option.  As a workaround, we make
   suggestion for servers providing UDP-based services with non-
   multihoming-capable services.  Such servers should announce only the
   HIT or public key that matches to the default outgoing HIT of the
   host to avoid such problems.

   Finally, some applications may create a connection to a local HIT.
   In such a case, the local system may use NULL encryption to avoid
   unnecessary encryption overhead, and may be otherwise more permissive
   than usual such as excluding authentication, Diffie-Hellman exchange,
   and puzzle.




<span class="grey">Henderson, et al.            Informational                     [Page 10]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-11" id="page-11" name="page-11"> </a>
<span class="grey"><a href="rfc5338.html">RFC 5338</a>           Using HIP with Legacy Applications     September 2008</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/6.%20%20Security%20Considerations"></a><a class="selflink" href="#section-6" name="section-6">6</a>.  Security Considerations</span>

   In this section, we discuss the security of the system in general
   terms, outlining some of the security properties.  However, this
   section is not intended to provide a complete risk analysis.  Such an
   analysis would, in any case, be dependent on the actual application
   using HIP, and is therefore considered out of scope.

   The scenarios outlined above differ considerably in their security
   properties.  When the DNS is used, there are further differences
   related to whether or not DNSSEC [<a href="rfc4033.html" title='"DNS Security Introduction and Requirements"'>RFC4033</a>] is used, and whether the
   DNS zones are considered trustworthy enough.  Here we mean that there
   should exist a delegation chain to whatever trust anchors are
   available in the respective trees, and the DNS zone administrators in
   charge of the netblock should be trusted to put in the right
   information.

   When IP addresses are used by applications to name the peer system,
   the security properties depend on the configuration method.  With
   manual configuration, the security of the system is comparable to a
   non-HIP system with similar IPsec policies.  The security semantics
   of an initial opportunistic key exchange are roughly equal to non-
   secured IP; the exchange is vulnerable to man-in-the-middle attacks.
   However, the system is less vulnerable to connection hijacking
   attacks.  If the DNS is used, if both zones are secured (or the HITs
   are stored in the reverse DNS record) and the client trusts the
   DNSSEC signatures, the system may provide a fairly high security
   level.  However, much depends on the details of the implementation,
   the security and administrative practices used when signing the DNS
   zones, and other factors.

   Using the forward DNS to map a domain name into an LSI is a case that
   is closest to the most typical use scenarios today.  If DNSSEC is
   used, the result is fairly similar to the current use of certificates
   with Transport Layer Security (TLS).  If DNSSEC is not used, the
   result is fairly similar to the current use of plain IP, with the
   additional protection of data integrity, confidentiality, and
   prevention of connection hijacking that opportunistic HIP provides.
   If DNSSEC is used, data integrity and data origin authentication
   services are added to the normal DNS query protocol, thereby
   providing more certainty that the desired host is being contacted, if
   the DNS records themselves are trustworthy.









<span class="grey">Henderson, et al.            Informational                     [Page 11]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-12" id="page-12" name="page-12"> </a>
<span class="grey"><a href="rfc5338.html">RFC 5338</a>           Using HIP with Legacy Applications     September 2008</span>


   If the application is basing its operations on HITs, the connections
   become automatically secured due to the implicit channel bindings in
   HIP.  That is, when the application makes a connect(HIT) system call,
   either the resulting packets will be sent to a node possessing the
   corresponding private key or the security association will fail to be
   established.

   When the system provides (spoofs) LSIs or HITs instead of IP
   addresses as the result of name resolution, the resultant fields may
   inadvertently show up in user interfaces and system logs, which may
   cause operational concerns for some network administrators.
   Therefore, it is recommended that the HIP software logs the HITs,
   LSIs (if applicable), corresponding IP addresses, and FQDN-related
   information so that administrators can correlate other logs with HIP
   identifiers.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/7.%20%20Acknowledgments"></a><a class="selflink" href="#section-7" name="section-7">7</a>.  Acknowledgments</span>

   Jeff Ahrenholz, Gonzalo Camarillo, Alberto Garcia, Teemu Koponen,
   Julien Laganier, and Jukka Ylitalo have provided comments on
   different versions of this document.  The document received
   substantial and useful comments during the review phase from David
   Black, Lars Eggert, Peter Koch, Thomas Narten, and Pekka Savola.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/8.%20%20Informative%20References"></a><a class="selflink" href="#section-8" name="section-8">8</a>.  Informative References</span>

   [<a id="ref-RFC5201" name="ref-RFC5201">RFC5201</a>]  Moskowitz, R., Nikander, P., Jokela, P., Ed., and T.
              Henderson, "Host Identity Protocol", <a href="rfc5201.html">RFC 5201</a>, April 2008.

   [<a id="ref-RFC4843" name="ref-RFC4843">RFC4843</a>]   Nikander, P., Laganier, J., and F. Dupont, "An IPv6
              Prefix for Overlay Routable Cryptographic Hash Identifiers
              (ORCHID)", <a href="rfc4843.html">RFC 4843</a>, April 2007.

   [<a id="ref-TESLA" name="ref-TESLA">TESLA</a>]     Salz, J., Balakrishnan, H., and A. Snoeren, "TESLA:  A
              Transparent, Extensible Session-Layer Architecture for
              End-to-end Network Services",  Proceedings of USENIX
              Symposium on Internet Technologies and Systems (USITS),
              pages 211-224, March 2003.

   [<a id="ref-RFC1958" name="ref-RFC1958">RFC1958</a>]  Carpenter, B., Ed., "Architectural Principles of the
              Internet", <a href="rfc1958.html">RFC 1958</a>, June 1996.

   [<a id="ref-RFC4033" name="ref-RFC4033">RFC4033</a>]  Arends, R., Austein, R., Larson, M., Massey, D., and S.
              Rose, "DNS Security Introduction and Requirements", <a href="rfc4033.html">RFC</a>
              <a href="rfc4033.html">4033</a>, March 2005.






<span class="grey">Henderson, et al.            Informational                     [Page 12]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-13" id="page-13" name="page-13"> </a>
<span class="grey"><a href="rfc5338.html">RFC 5338</a>           Using HIP with Legacy Applications     September 2008</span>


   [<a id="ref-RFC3493" name="ref-RFC3493">RFC3493</a>]  Gilligan, R., Thomson, S., Bound, J., McCann, J., and W.
              Stevens, "Basic Socket Interface Extensions for IPv6", <a href="rfc3493.html">RFC</a>
              <a href="rfc3493.html">3493</a>, February 2003.

   [<a id="ref-APP_REF" name="ref-APP_REF">APP_REF</a>]  Nordmark, E., <a href="https://www.google.com/search?sitesearch=tools.ietf.org%2Fhtml%2F&amp;q=inurl:draft-+%22Shim6+Application+Referral+Issues%22" style="text-decoration: none">"Shim6 Application Referral Issues"</a>, Work in
              Progress, July 2005.

Authors' Addresses

   Thomas Henderson
   The Boeing Company
   P.O. Box 3707
   Seattle, WA
   USA

   EMail: thomas.r.henderson@boeing.com


   Pekka Nikander
   Ericsson Research NomadicLab
   JORVAS  FIN-02420
   FINLAND

   Phone: +358 9 299 1
   EMail: pekka.nikander@nomadiclab.com


   Miika Komu
   Helsinki Institute for Information Technology
   Metsaenneidonkuja 4
   Helsinki  FIN-02420
   FINLAND

   Phone: +358503841531
   EMail: miika@iki.fi
















<span class="grey">Henderson, et al.            Informational                     [Page 13]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-14" id="page-14" name="page-14"> </a>
<span class="grey"><a href="rfc5338.html">RFC 5338</a>           Using HIP with Legacy Applications     September 2008</span>


Full Copyright Statement

   Copyright (C) The IETF Trust (2008).

   This document is subject to the rights, licenses and restrictions
   contained in <a href="https://tools.ietf.org/html/bcp78">BCP 78</a>, and except as set forth therein, the authors
   retain all their rights.

   This document and the information contained herein are provided on an
   "AS IS" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS
   OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST AND
   THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS
   OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF
   THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED
   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.

Intellectual Property

   The IETF takes no position regarding the validity or scope of any
   Intellectual Property Rights or other rights that might be claimed to
   pertain to the implementation or use of the technology described in
   this document or the extent to which any license under such rights
   might or might not be available; nor does it represent that it has
   made any independent effort to identify any such rights.  Information
   on the procedures with respect to rights in RFC documents can be
   found in <a href="https://tools.ietf.org/html/bcp78">BCP 78</a> and <a href="https://tools.ietf.org/html/bcp79">BCP 79</a>.

   Copies of IPR disclosures made to the IETF Secretariat and any
   assurances of licenses to be made available, or the result of an
   attempt made to obtain a general license or permission for the use of
   such proprietary rights by implementers or users of this
   specification can be obtained from the IETF on-line IPR repository at
   <a href="http://www.ietf.org/ipr">http://www.ietf.org/ipr</a>.

   The IETF invites any interested party to bring to its attention any
   copyrights, patents or patent applications, or other proprietary
   rights that may cover technology that may be required to implement
   this standard.  Please address the information to the IETF at
   ietf-ipr@ietf.org.












Henderson, et al.            Informational                     [Page 14]

</pre><br/>
    <span class="noprint"><small><small>Html markup produced by rfcmarkup 1.126, available from
      <a href="https://tools.ietf.org/tools/rfcmarkup/">https://tools.ietf.org/tools/rfcmarkup/</a>
    </small></small></span>
  </div>




</body><!-- Mirrored from tools.ietf.org/html/rfc5338 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 06 Mar 2018 23:18:35 GMT --></html>