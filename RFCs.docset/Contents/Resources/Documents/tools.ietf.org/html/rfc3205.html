<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml"><!-- Mirrored from tools.ietf.org/html/rfc3205 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 06 Mar 2018 23:18:47 GMT --><!-- Added by HTTrack --><head><meta content="text/html;charset=utf-8" http-equiv="content-type"/><!-- /Added by HTTrack -->

    <meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
    <meta content="index,follow" name="robots"/>
    <meta content="rfcmarkup version 1.126" name="creator"/>
    <link href="http://purl.org/dc/elements/1.1/" rel="schema.DC"/>
<meta content="urn:ietf:rfc:3205" name="DC.Identifier"/>
<meta content="Recently there has been widespread interest in using Hypertext
Transport Protocol (HTTP) as a substrate for other applications-level
protocols. This document recommends technical particulars of such use,
including use of default ports, URL schemes, and HTTP security
mechanisms." name="DC.Description.Abstract"/>
<meta content="Keith Moore &lt;moore@cs.utk.edu&gt;" name="DC.Creator"/>
<meta content="February, 2002" name="DC.Date.Issued"/>
<meta content="On the use of HTTP as a Substrate for Other Protocols" name="DC.Title"/>

    <link href="https://tools.ietf.org/images/rfc.png" rel="icon" type="image/png"/>
    <link href="https://tools.ietf.org/images/rfc.png" rel="shortcut icon" type="image/png"/>
    <title>RFC 3205 - On the use of HTTP as a Substrate for Other Protocols</title>
    
    
    <style type="text/css">
	@media only screen 
	  and (min-width: 992px)
	  and (max-width: 1199px) {
	    body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 768px)
	  and (max-width: 991px) {
            body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 480px)
	  and (max-width: 767px) {
            body { font-size: 11pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (max-width: 479px) {
            body { font-size: 8pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-device-width : 375px) 
	  and (max-device-width : 667px) {
            body { font-size: 9.5pt; }
            div.content { width: 96ex; margin: 0 1px; }
        }
	@media only screen 
	  and (min-device-width: 1200px) {
            body { font-size: 10pt; margin: 0 4em; }
            div.content { width: 96ex; margin: 0; }
        }
        h1, h2, h3, h4, h5, h6, .h1, .h2, .h3, .h4, .h5, .h6 {
	    font-weight: bold;
            line-height: 0pt;
            display: inline;
            white-space: pre;
            font-family: monospace;
            font-size: 1em;
	    font-weight: bold;
        }
        pre {
            font-size: 1em;
            margin-top: 0px;
            margin-bottom: 0px;
        }
	.pre {
	    white-space: pre;
	    font-family: monospace;
	}
	.header{
	    font-weight: bold;
	}
        .newpage {
            page-break-before: always;
        }
        .invisible {
            text-decoration: none;
            color: white;
        }
        a.selflink {
          color: black;
          text-decoration: none;
        }
        @media print {
            body {
                font-family: monospace;
                font-size: 10.5pt;
            }
            h1, h2, h3, h4, h5, h6 {
                font-size: 1em;
            }
        
            a:link, a:visited {
                color: inherit;
                text-decoration: none;
            }
            .noprint {
                display: none;
            }
        }
	@media screen {
	    .grey, .grey a:link, .grey a:visited {
		color: #777;
	    }
            .docinfo {
                background-color: #EEE;
            }
            .top {
                border-top: 7px solid #EEE;
            }
            .bgwhite  { background-color: white; }
            .bgred    { background-color: #F44; }
            .bggrey   { background-color: #666; }
            .bgbrown  { background-color: #840; }            
            .bgorange { background-color: #FA0; }
            .bgyellow { background-color: #EE0; }
            .bgmagenta{ background-color: #F4F; }
            .bgblue   { background-color: #66F; }
            .bgcyan   { background-color: #4DD; }
            .bggreen  { background-color: #4F4; }

            .legend   { font-size: 90%; }
            .cplate   { font-size: 70%; border: solid grey 1px; }
	}
    </style>
    <!--[if IE]>
    <style>
    body {
       font-size: 13px;
       margin: 10px 10px;
    }
    </style>
    <![endif]-->

    <script type="text/javascript"><!--
    function addHeaderTags() {
	var spans = document.getElementsByTagName("span");
	for (var i=0; i < spans.length; i++) {
	    var elem = spans[i];
	    if (elem) {
		var level = elem.getAttribute("class");
                if (level == "h1" || level == "h2" || level == "h3" || level == "h4" || level == "h5" || level == "h6") {
                    elem.innerHTML = "<"+level+">"+elem.innerHTML+"</"+level+">";		
                }
	    }
	}
    }
    var legend_html = "Colour legend:<br />      <table>         <tr><td>Unknown:</td>                   <td><span class='cplate bgwhite'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft:</td>                     <td><span class='cplate bgred'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Informational:</td>             <td><span class='cplate bgorange'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Experimental:</td>              <td><span class='cplate bgyellow'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Best Common Practice:</td>      <td><span class='cplate bgmagenta'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Proposed Standard:</td>         <td><span class='cplate bgblue'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft Standard (old designation):</td> <td><span class='cplate bgcyan'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Internet Standard:</td>         <td><span class='cplate bggreen'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Historic:</td>                  <td><span class='cplate bggrey'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Obsolete:</td>                  <td><span class='cplate bgbrown'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>     </table>";
    function showElem(id) {
        var elem = document.getElementById(id);
        elem.innerHTML = eval(id+"_html");
        elem.style.visibility='visible';
    }
    function hideElem(id) {
        var elem = document.getElementById(id);
        elem.style.visibility='hidden';        
        elem.innerHTML = "";
    }
    // -->
    </script>
</head>
<body onload="addHeaderTags()">
  <div class="content">
   <div style="height: 13px;">
      <div class="pre noprint docinfo bgmagenta" onclick="showElem('legend');" onmouseout="hideElem('legend')" onmouseover="this.style.cursor='pointer';" style="height: 6px; position: absolute;" title="Click for colour legend.">                                                                        </div>
      <div class="docinfo noprint pre legend" id="legend" onmouseout="hideElem('legend');" onmouseover="showElem('legend');" style="position:absolute; top: 4px; left: 4ex; visibility:hidden; background-color: white; padding: 4px 9px 5px 7px; border: solid #345 1px; ">
      </div>
   </div>
<span class="pre noprint docinfo top">[<a href="index.html" title="Document search and retrieval page">Docs</a>] [<a href="https://tools.ietf.org/rfc/rfc3205.txt" title="Plaintext version of this document">txt</a>|<a href="https://tools.ietf.org/pdf/rfc3205" title="PDF version of this document">pdf</a>] [<a href="https://tools.ietf.org/html/draft-moore-using-http" title="draft-moore-using-http">draft-moore-usi...</a>] [<a href="https://datatracker.ietf.org/doc/rfc3205" title="IESG Datatracker information for this document">Tracker</a>] [<a href="https://tools.ietf.org/rfcdiff?difftype=--hwdiff&amp;url2=rfc3205" title="Inline diff (wdiff)">Diff1</a>] [<a href="https://tools.ietf.org/rfcdiff?url2=rfc3205" title="Side-by-side diff">Diff2</a>] [<a href="https://www.rfc-editor.org/errata_search.php?rfc=3205">Errata</a>]</span><br/>
<span class="pre noprint docinfo">                                                                        </span><br/>
<span class="pre noprint docinfo">                                                   BEST CURRENT PRACTICE</span><br/>
<span class="pre noprint docinfo">                                                            <span style="color: #C00;">Errata Exist</span></span><br/>
<pre>Network Working Group                                           K. Moore
Request for Comments: 3205                       University of Tennessee
BCP: 56                                                    February 2002
Category: Best Current Practice


                   <span class="h1">On the use of HTTP as a Substrate</span>

Status of this Memo

   This document specifies an Internet Best Current Practices for the
   Internet Community, and requests discussion and suggestions for
   improvements.  Distribution of this memo is unlimited.

Copyright Notice

   Copyright (C) The Internet Society (2002).  All Rights Reserved.

Abstract

   Recently there has been widespread interest in using Hypertext
   Transfer Protocol (HTTP) as a substrate for other applications-level
   protocols.  This document recommends technical particulars of such
   use, including use of default ports, URL schemes, and HTTP security
   mechanisms.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/1.%20Introduction"></a><a class="selflink" href="#section-1" name="section-1">1</a>. Introduction</span>

   Recently there has been widespread interest in using Hypertext
   Transfer Protocol (HTTP) [<a href="#ref-1" title='"Hypertext Transfer Protocol -- HTTP/1.1"'>1</a>] as a substrate for other applications-
   level protocols.  Various reasons cited for this interest have
   included:

   o  familiarity and mindshare,

   o  compatibility with widely deployed browsers,

   o  ability to reuse existing servers and client libraries,

   o  ease of prototyping servers using CGI scripts and similar
      extension mechanisms,

   o  ability to use existing security mechanisms such as HTTP digest
      authentication [<a href="#ref-2" title='"HTTP Authentication: Basic and Digest Access Authentication"'>2</a>] and SSL or TLS [<a href="#ref-3" title='"The TLS Protocol Version 1.0"'>3</a>],

   o  the ability of HTTP to traverse firewalls, and

   o  cases where a server often needs to support HTTP anyway.



<span class="grey">Moore                    Best Current Practice                  [Page 1]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-2" id="page-2" name="page-2"> </a>
<span class="grey"><a href="rfc3205.html">RFC 3205</a>                     HTTP Layering                 February 2002</span>


   The Internet community has a long tradition of protocol reuse, dating
   back to the use of Telnet [<a href="#ref-4" title='"Telnet Protocol Specification"'>4</a>] as a substrate for FTP [<a href="#ref-5" title='"File Transfer Protocol"'>5</a>] and SMTP
   [<a href="#ref-6" title='"Simple Mail Transfer Protocol"'>6</a>].  However, the recent interest in layering new protocols over
   HTTP has raised a number of questions when such use is appropriate,
   and the proper way to use HTTP in contexts where it is appropriate.
   Specifically, for a given application that is layered on top of HTTP:

   o  Should the application use a different port than the HTTP default
      of 80?

   o  Should the application use traditional HTTP methods (GET, POST,
      etc.) or should it define new methods?

   o  Should the application use http: URLs or define its own prefix?

   o  Should the application define its own MIME-types, or use something
      that already exists (like registering a new type of MIME-directory
      structure)?

   This memo recommends certain design decisions in answer to these
   questions.

   This memo is intended as advice and recommendation for protocol
   designers, working groups, implementors, and IESG, rather than as a
   strict set of rules which must be adhered to in all cases.
   Accordingly, the capitalized key words defined in <a href="rfc2119.html">RFC 2119</a>, which are
   intended to indicate conformance to a specification, are not used in
   this memo.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/2.%20Issues%20Regarding%20the%20Design%20Choice%20to%20use%20HTTP"></a><a class="selflink" href="#section-2" name="section-2">2</a>. Issues Regarding the Design Choice to use HTTP</span>

   Despite the advantages listed above, it's worth asking the question
   as to whether HTTP should be used at all, or whether the entire HTTP
   protocol should be used.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/2.1%20Complexity"></a><a class="selflink" href="#section-2.1" name="section-2.1">2.1</a> Complexity</span>

   HTTP started out as a simple protocol, but quickly became much more
   complex due to the addition of several features unanticipated by its
   original design.  These features include persistent connections, byte
   ranges, content negotiation, and cache support.  All of these are
   useful for traditional web applications but may not be useful for the
   layered application.  The need to support (or circumvent) these
   features can add additional complexity to the design and
   implementation of a protocol layered on top of HTTP.  Even when HTTP
   can be "profiled" to minimize implementation overhead, the effort of
   specifying such a profile might be more than the effort of specifying
   a purpose-built protocol which is better suited to the task at hand.



<span class="grey">Moore                    Best Current Practice                  [Page 2]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-3" id="page-3" name="page-3"> </a>
<span class="grey"><a href="rfc3205.html">RFC 3205</a>                     HTTP Layering                 February 2002</span>


   Even if existing HTTP client and server code can often be re-used,
   the additional complexity of layering something over HTTP vs. using a
   purpose-built protocol can increase the number of interoperability
   problems.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/2.2%20Overhead"></a><a class="selflink" href="#section-2.2" name="section-2.2">2.2</a> Overhead</span>

   Further, although HTTP can be used as the transport for a "remote
   procedure call" paradigm, HTTP's protocol overhead, along with the
   connection setup overhead of TCP, can make HTTP a poor choice.  A
   protocol based on UDP, or with both UDP and TCP variants, should be
   considered if the payloads are very likely to be small (less than a
   few hundred bytes) for the foreseeable future.  This is especially
   true if the protocol might be heavily used, or if it might be used
   over slow or expensive links.

   On the other hand, the connection setup overhead can become
   negligible if the layered protocol can utilize HTTP/1.1's persistent
   connections, and if the same client and server are likely to perform
   several transactions during the time the HTTP connection is open.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/2.3%20Security"></a><a class="selflink" href="#section-2.3" name="section-2.3">2.3</a> Security</span>

   Although HTTP appears at first glance to be one of the few "mature"
   Internet protocols that can provide good security, there are many
   applications for which neither HTTP's digest authentication nor TLS
   are sufficient by themselves.

   Digest authentication requires a secret (e.g., a password) to be
   shared between client and server.  This further requires that each
   client know the secret to be used with each server, but it does not
   provide any means of securely transmitting such secrets between the
   parties.  Shared secrets can work fine for small groups where
   everyone is physically co-located; they don't work as well for large
   or dispersed communities of users.  Further, if the server is
   compromised a large number of secrets may be exposed, which is
   especially dangerous if the same secret (or password) is used for
   several applications.  (Similar concerns exist with TLS based clients
   or servers - if a private key is compromised then the attacker can
   impersonate the party whose key it has.)

   TLS and its predecessor SSL were originally designed to authenticate
   web servers to clients, so that a user could be assured (for example)
   that his credit card number was not being sent to an imposter.
   However, many applications need to authenticate clients to servers,
   or to provide mutual authentication of client and server.  TLS does





<span class="grey">Moore                    Best Current Practice                  [Page 3]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-4" id="page-4" name="page-4"> </a>
<span class="grey"><a href="rfc3205.html">RFC 3205</a>                     HTTP Layering                 February 2002</span>


   have a capability to provide authentication in each direction, but
   such authentication may or may not be suitable for a particular
   application.

   Web browsers which support TLS or SSL are typically shipped with the
   public keys of several certificate authorities (CAs) "wired in" so
   that they can verify the identity of any server whose public key was
   signed by one of those CAs.  For this to work well, every secure web
   server's public key has to be signed by one of the CAs whose keys are
   wired into popular browsers.  This deployment model works when there
   are a (relatively) small number of servers whose identities can be
   verified, and their public keys signed, by the small number of CAs
   whose keys are included in a small number of different browsers.

   This scheme does not work as well to authenticate millions of
   potential clients to servers.  It would take a much larger number of
   CAs to do the job, each of which would need to be widely trusted by
   servers.  Those CAs would also have a more difficult time verifying
   the identities of (large numbers of) ordinary users than they do in
   verifying the identities of (a smaller number of) commercial and
   other enterprises that need to run secure web servers.

   Also, in a situation where there were a large number of clients
   authenticating with TLS, it seems unlikely that there would be a set
   of CAs whose keys were trusted by every server.  A client that
   potentially needed to authenticate to multiple servers would
   therefore need to be configured as to which key to use with which
   server when attempting to establish a secure connection to the
   server.

   For the reasons stated above, client authentication is rarely used
   with TLS.  A common technique is to use TLS to authenticate the
   server to the client and to establish a private channel, and for the
   client to authenticate to the server using some other means - for
   example, a username and password using HTTP basic or digest
   authentication.

   For any application that requires privacy, the 40-bit ciphersuites
   provided by some SSL implementations (to conform to outdated US
   export regulations or to regulations on the use or export of
   cryptography in other countries) are unsuitable.  Even 56-bit DES
   encryption, which is required of conforming TLS implementations, has
   been broken in a matter of days with a modest investment in
   resources.  So if TLS is chosen it may be necessary to discourage use
   of small key lengths, or of weak ciphersuites, in order to provide
   adequate privacy assurance.  If TLS is used to provide privacy for
   passwords sent by clients then it is especially important to support
   longer keys.



<span class="grey">Moore                    Best Current Practice                  [Page 4]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-5" id="page-5" name="page-5"> </a>
<span class="grey"><a href="rfc3205.html">RFC 3205</a>                     HTTP Layering                 February 2002</span>


   None of the above should be taken to mean that either digest
   authentication or TLS are generally inferior to other authentication
   systems, or that they are unsuitable for use in other applications
   besides HTTP.  Many of the limitations of TLS and digest
   authentication also apply to other authentication and privacy
   systems.  The point here is that neither TLS nor digest
   authentication is a "magic pixie dust" solution to authentication or
   privacy.  In every case, an application's designers must carefully
   determine the application's users' requirements for authentication
   and privacy before choosing an authentication or privacy mechanism.

   Note also that TLS can be used with other TCP-based protocols, and
   there are SASL [<a href="#ref-7" title='"Simple Authentication and Security Layer (SASL)"'>7</a>] mechanisms similar to HTTP's digest
   authentication.  So it is not necessary to use HTTP in order to
   benefit from either TLS or digest-like authentication.  However, HTTP
   APIs may already support TLS and/or digest.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/2.4%20Compatibility%20with%20Proxies%2C%20Firewalls%2C%20and%20NATs"></a><a class="selflink" href="#section-2.4" name="section-2.4">2.4</a> Compatibility with Proxies, Firewalls, and NATs</span>

   One oft-cited reason for the use of HTTP is its ability to pass
   through proxies, firewalls, or network address translators (NATs).
   One unfortunate consequence of firewalls and NATs is that they make
   it harder to deploy new Internet applications, by requiring explicit
   permission (or even a software upgrade of the firewall or NAT) to
   accommodate each new protocol.  The existence of firewalls and NATs
   creates a strong incentive for protocol designers to layer new
   applications on top of existing protocols, including HTTP.

   However, if a site's firewall prevents the use of unknown protocols,
   this is presumably a conscious policy decision on the part of the
   firewall administrator.  While it is arguable that such policies are
   of limited value in enhancing security, this is beside the point -
   well-known port numbers are quite useful for a variety of purposes,
   and the overloading of port numbers erodes this utility.  Attempting
   to circumvent a site's security policy is not an acceptable
   justification for doing so.

   It would be useful to establish guidelines for "firewall-friendly"
   protocols, to make it easier for existing firewalls to be compatible
   with new protocols.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/2.5%20Questions%20to%20be%20asked%20when%20considering%20use%20of%20HTTP"></a><a class="selflink" href="#section-2.5" name="section-2.5">2.5</a> Questions to be asked when considering use of HTTP</span>

   o  When considering payload size and traffic patterns, is HTTP an
      appropriate transport for the anticipated use of this protocol?






<span class="grey">Moore                    Best Current Practice                  [Page 5]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-6" id="page-6" name="page-6"> </a>
<span class="grey"><a href="rfc3205.html">RFC 3205</a>                     HTTP Layering                 February 2002</span>


      (In other words: will the payload size be worth the overhead
      associated with TCP and HTTP?  Or will the application be able to
      make use of HTTP persistent connections to amortize the cost of
      that overhead over several requests?)

   o  Is this new protocol usable by existing web browsers without
      modification?

      (For example: Is the request transmitted as if it were a filled-in
      HTML form?  Is the response which is returned viewable from a web
      browser, say as HTML?)

   o  Are the existing HTTP security mechanisms appropriate for the new
      application?

   o  Are HTTP status codes and the HTTP status code paradigm suitable
      for this application?  (see <a href="#section-8">section 8</a>)

   o  Does the server for this application need to support HTTP anyway?

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/3.%20Issues%20Regarding%20Reuse%20of%20Port%2080"></a><a class="selflink" href="#section-3" name="section-3">3</a>. Issues Regarding Reuse of Port 80</span>

   IANA has reserved TCP port number 80 for use by HTTP.  It would not
   be appropriate for a substantially new service, even one which uses
   HTTP as a substrate, to usurp port 80 from its traditional use.  A
   new use of HTTP might be considered a "substantially new service",
   thus requiring a new port, if any of the following are true:

   o  The "new service" and traditional HTTP service are likely to
      reference different sets of data, even when they both operate on
      the same host.

   o  There is a good reason for the "new service" to be implemented by
      a separate server process, or separate code, than traditional HTTP
      service on the same host, at least on some platforms.

   o  There is a good reason to want to easily distinguish the traffic
      of the "new service" from traditional HTTP, e.g., for the purposes
      of firewall access control or traffic analysis.

   o  If none of the above are true, it is arguable that the new use of
      HTTP is an "extension" to traditional HTTP, rather than a "new
      service".  Extensions to HTTP which share data with traditional
      HTTP services should probably define new HTTP methods to describe
      those extensions, rather than using separate ports.  If separate
      ports are used, there is no way for a client to know whether they
      are separate services or different ways of accessing the same
      underlying service.



<span class="grey">Moore                    Best Current Practice                  [Page 6]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-7" id="page-7" name="page-7"> </a>
<span class="grey"><a href="rfc3205.html">RFC 3205</a>                     HTTP Layering                 February 2002</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/4.%20Issues%20Regarding%20Reuse%20of%20the%20http%3A%20Scheme%20in%20URLs"></a><a class="selflink" href="#section-4" name="section-4">4</a>. Issues Regarding Reuse of the http: Scheme in URLs</span>

   A number of different URL schemes are in widespread use and many more
   are in the process of being standardized.  In practice, the URL
   scheme not only serves as a "tag" to govern the interpretation of the
   remaining portion of the URL, it also provides coarse identification
   of the kind of resource or service which is being accessed.  For
   example, web browsers typically provide a different response when a
   user mouse-clicks on an "http" URL, than when the user clicks on a
   "mailto" URL.

   Some criteria that might be used in making this determination are:

   o  Whether this URL scheme is likely to become widely used, versus
      used only in limited communities or by private agreement.

   o  Whether a new "default port" is needed.  If reuse of port 80 is
      not appropriate (see above), a new "default port" is needed.  A
      new default port in turn requires that a new URL scheme be
      registered if that URL scheme is expected to be widely used.
      Explicit port numbers in URLs are regarded as an "escape hatch",
      not something for use in ordinary circumstances.

   o  Whether use of the new service is likely to require a
      substantially different setup or protocol interaction with the
      server, than ordinary HTTP service.  This could include the need
      to request a different type of service from the network, or to
      reserve bandwidth, or to present different TLS authentication
      credentials to the server, or different kind of server
      provisioning, or any number of other needs.

   o  Whether user interfaces (such as web browsers) are likely to be
      able to exploit the difference in the URL prefix to produce a
      significant improvement in usability.

   According to the rules in [<a href="#ref-8" title='"Registration Procedures for URL Scheme Names"'>8</a>] the "http:" URI is part of the "IETF
   Tree" for URL scheme names, and IETF is the maintainer of the "IETF
   Tree".  Since IESG is the decision-making body for IETF, IESG has the
   authority to determine whether a resource accessed by a protocol that
   is layered on top of HTTP, should use http: or some other URL prefix.

   Note that the convention of appending an "s" to the URL scheme to
   mean "use TLS or SSL" (as in "http:" vs "https:") is nonstandard and
   of limited value.  For most applications, a single "use TLS or SSL"
   bit is not sufficient to adequately convey the information that a
   client needs to authenticate itself to a server, even if it has the
   proper credentials.  For instance, in order to ensure that adequate
   security is provided with TLS an application may need to be



<span class="grey">Moore                    Best Current Practice                  [Page 7]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-8" id="page-8" name="page-8"> </a>
<span class="grey"><a href="rfc3205.html">RFC 3205</a>                     HTTP Layering                 February 2002</span>


   configured with a list of acceptable ciphersuites, or with the client
   certificate to be used to authenticate to a particular server.  When
   it is necessary to specify authentication or other connection setup
   information in a URL these should be communicated in URL parameters,
   rather than in the URL prefix.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/5.%20Issues%20regarding%20use%20of%20MIME%20media%20types"></a><a class="selflink" href="#section-5" name="section-5">5</a>. Issues regarding use of MIME media types</span>

   Since HTTP uses the MIME media type system [<a href="#ref-9" title='"Multipurpose Internet Mail Extensions (MIME) Part Two: Media Types"'>9</a>] to label its payload,
   many applications which layer on HTTP will need to define, or select,
   MIME media types for use by that application.  Especially when using
   a multipart structure, the choice of media types requires careful
   consideration.  In particular:

   o  Should some existing framework be used, such as text/directory
      [<a href="#ref-10" title='"A MIME Content-Type for Directory Information"'>10</a>], or XML [<a href="#ref-11" title='"Extensible Markup Language (XML)"'>11</a>,<a href="#ref-12" title='"XML Media Types"'>12</a>], or should the new content-types be built
      from scratch?  Just as with HTTP, it's useful if code can be
      reused, but protocol designers should not be over-eager to
      incorporate a general but complex framework into a new protocol.
      Experience with ASN.1, for example, suggests that the advantage of
      using a general framework may not be worth the cost.

   o  Should MIME multipart or message types be allowed?  This can be an
      advantage if it is desirable to incorporate (for example) the
      multipart/alternative construct or the MIME security framework.
      On the other hand, these constructs were designed specifically for
      use in store-and-forward electronic mail systems, and other
      mechanisms may be more appropriate for the application being
      considered.

      The point here is that a decision to use MIME content-type names
      to describe protocol payloads (which is generally desirable if the
      same payloads may appear in other applications) does not imply
      that the application must accept arbitrary MIME content-types,
      including MIME multipart or security mechanisms.  Nor does it
      imply that the application must use MIME syntax or that it must
      recognize or even tolerate existing MIME header fields.

   o  If the same payload is likely to be sent over electronic mail, the
      differences between HTTP encoding of the payload and email
      encoding of the payload should be minimized.  Ideally, there
      should be no differences in the "canonical form" used in the two
      environments.  Text/* media types can be problematic in this
      regard because MIME email requires CRLF for line endings of text/*
      body parts, where HTTP traditionally uses LF only.






<span class="grey">Moore                    Best Current Practice                  [Page 8]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-9" id="page-9" name="page-9"> </a>
<span class="grey"><a href="rfc3205.html">RFC 3205</a>                     HTTP Layering                 February 2002</span>


   o  A MIME content-type label describes the nature of the object being
      labeled.  It does not describe, and should not be used to
      describe, the semantics which should be applied when the object is
      received.  For instance, the transmission of an object with a
      particular content-type using HTTP POST, should not be taken as a
      request for some operation based solely on the type.  The request
      should be separate from the content-type label and it should be
      explicit.

      When it is necessary for a protocol layered on HTTP to allow
      different operations on the same type of object, this can be
      communicated in a number of different ways: HTTP methods, HTTP
      request-URI, HTTP request headers, the MIME Content-Disposition
      header field, or as part of the payload.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/6.%20Issues%20Regarding%20Existing%20vs."></a><a class="selflink" href="#section-6" name="section-6">6</a>. Issues Regarding Existing vs.  </span>New HTTP Methods

   It has been suggested that a new service layered on top of HTTP
   should define one or more new HTTP methods, rather than allocating a
   new port.  The use of new methods may be appropriate, but is not
   sufficient in all cases.  The definition of one or more new methods
   for use in a new protocol, does not by itself alleviate the need for
   use of a new port, or a new URL type.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/7.%20Issues%20regarding%20reuse%20of%20HTTP%20client%2C%20server%2C%20and%20proxy%20code"></a><a class="selflink" href="#section-7" name="section-7">7</a>. Issues regarding reuse of HTTP client, server, and proxy code</span>

   As mentioned earlier, one of the primary reasons for the use of HTTP
   as a substrate for new protocols, is to allow reuse of existing HTTP
   client, server, or proxy code.  However, HTTP was not designed for
   such layering.  Existing HTTP client and code may have "http"
   assumptions wired into them.  For instance, client libraries and
   proxies may expect "http:" URLs, and clients and servers may send
   (and expect) "HTTP/1.1", in requests and responses, as opposed to the
   name of the layered protocol and its version number.

   Existing client libraries may not understand new URL types.  In order
   to get a new HTTP-layered application client to work with an existing
   client library, it may be necessary for the application to convert
   its URLs to an "http equivalent" form.  For instance, if service
   "xyz" is layered on top of HTTP using port ###, the xyz client may
   need, when invoking an HTTP client library, to translate its URLs
   from "xyz://host/something" format to "<a href="http://host:/###/something">http://host:###/something</a>" for
   the purpose of calling that library.  This should be done ONLY when
   calling the HTTP client library - such URLs should not be used in
   other parts of the protocol, nor should they be exposed to users.






<span class="grey">Moore                    Best Current Practice                  [Page 9]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-10" id="page-10" name="page-10"> </a>
<span class="grey"><a href="rfc3205.html">RFC 3205</a>                     HTTP Layering                 February 2002</span>


   Note that when a client is sending requests directly to an origin
   server, the URL prefix ("http:") is not normally sent.  So
   translating xyz: URLs to http: URLs when calling the client library
   should not actually cause http: URLs to be sent over the wire.  But
   when the same client is sending requests to a proxy server, the
   client will normally send the entire URL (including the http: prefix)
   in those requests.  The proxy will remove the http: prefix when the
   request is communicated to the origin server.

   Existing HTTP client libraries and servers will transmit "HTTP/1.1"
   (or a different version) in requests and responses.  To facilitate
   reuse of such libraries and servers by a new protocol, such a
   protocol may therefore need to transmit and accept "HTTP/1.1" rather
   than its own protocol name and version number.  Designers of
   protocols which are layered on top of HTTP should explicitly choose
   whether or not to accept "HTTP/1.1" in protocol exchanges.

   For certain applications it may be necessary to require or limit use
   of certain HTTP features, for example, to defeat caching of responses
   by proxies.  Each protocol layered on HTTP must therefore specify the
   specific way that HTTP will be used, and in particular, how the
   client and server should interact with HTTP proxies.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/8.%20%20Issues%20regarding%20use%20of%20HTTP%20status%20codes"></a><a class="selflink" href="#section-8" name="section-8">8</a>.  Issues regarding use of HTTP status codes</span>

   HTTP's three-digit status codes were designed for use with
   traditional HTTP applications (e.g., document retrieval, forms-based
   queries), and are unlikely to be suitable to communicate the
   specifics of errors encountered in dissimilar applications.  Even
   when it seems like there is a close match between HTTP status codes
   and the codes needed by the application, experience with reuse of
   other protocols indicates that subtle variations in usage are likely;
   and that this is likely to degrade interoperability of both the
   original protocol (in this case HTTP) and any layered applications.

   HTTP status codes therefore should not be used to indicate subtle
   errors of layered applications.  At most, the "generic" HTTP codes
   200 (for complete success) and 500 (for complete failure) should be
   used to indicate errors resulting from the content of the request
   message-body.  Under certain circumstances, additional detail about
   the nature of the error can then be included in the response
   message-body.  Other status codes than 200 or 500 should only appear
   if the error was detected by the HTTP server or by an intermediary.

   A layered application should not define new HTTP status codes.  The
   set of available status codes is small, conflicts in code assignment
   between different layered applications are likely, and they may be
   needed by future versions of, or extensions to, mainstream HTTP.



<span class="grey">Moore                    Best Current Practice                 [Page 10]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-11" id="page-11" name="page-11"> </a>
<span class="grey"><a href="rfc3205.html">RFC 3205</a>                     HTTP Layering                 February 2002</span>


   Use of HTTP's error codes is problematic when the layered application
   does not share same notion of success or failure as HTTP.  The
   problem exists when the client does not connect directly to the
   origin server, but via one or more HTTP caches or proxies.  (Since
   the ability of HTTP to communicate through intermediaries is often
   the primary motivation for reusing HTTP, the ability of the
   application to operate in the presence of such intermediaries is
   considered very important.)  Such caches and proxies will interpret
   HTTP's error codes and may take additional action based on those
   codes.  For instance, on receipt of a 200 error code from an origin
   server (and under other appropriate conditions) a proxy may cache the
   response and re-issue it in response to a similar request.  Or a
   proxy may modify the result of a request which returns a 500 error
   code in order to add a "helpful" error message.  Other response codes
   may produce other behaviors.

   A few guidelines are therefore in order:

   o  A layered application should use appropriate HTTP error codes to
      report errors resulting from information in the HTTP request-line
      and header fields associated with the request.  This request
      information is part of the HTTP protocol and errors which are
      associated with that information should therefore be reported
      using HTTP protocol mechanisms.

   o  A layered application for which all errors resulting from the
      message-body can be classified as either "complete success" or
      "complete failure" may use 200 and 500 for those conditions,
      respectively.  However, the specification for such an application
      must define the mechanism which ensures that its successful (200)
      responses are not cached by intermediaries, or demonstrate that
      such caching will do no harm; and it must be able to operate even
      if the message-body of an error (500) response is not transmitted
      back to the client intact.

   o  A layered application may return a 200 response code for both
      successfully processed requests and errors (or other exceptional
      conditions) resulting from the request message-body (but not from
      the request headers).  Such an application must return its error
      code as part of the response message body, and the specification
      for that application protocol must define the mechanism by which
      the application ensures that its responses are not cached by
      intermediaries.  In this case a response other than 200 should be
      used only to indicate errors with, or the status of, the HTTP
      protocol layer (including the request headers), or to indicate the
      inability of the HTTP server to communicate with the application
      server.




<span class="grey">Moore                    Best Current Practice                 [Page 11]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-12" id="page-12" name="page-12"> </a>
<span class="grey"><a href="rfc3205.html">RFC 3205</a>                     HTTP Layering                 February 2002</span>


   o  A layered application which cannot operate in the presence of
      intermediaries or proxies that cache and/or alter error responses,
      should not use HTTP as a substrate.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/9.%20Summary%20of%20recommendations%20regarding%20reuse%20of%20HTTP"></a><a class="selflink" href="#section-9" name="section-9">9</a>. Summary of recommendations regarding reuse of HTTP</span>

   1. All protocols should provide adequate security.  The security
      needs of a particular application will vary widely depending on
      the application and its anticipated use environment.  Merely using
      HTTP and/or TLS as a substrate for a protocol does not
      automatically provide adequate security for all environments, nor
      does it relieve the protocol developers of the need to analyze
      security considerations for their particular application.

   2. New protocols - including but not limited to those using HTTP -
      should not attempt to circumvent users' firewall policies,
      particularly by masquerading as existing protocols.
      "Substantially new services" should not reuse existing ports.

   3. In general, new protocols or services should not reuse http: or
      other URL schemes.

   4. Each new protocol specification that uses HTTP as a substrate
      should describe the specific way that HTTP is to be used by that
      protocol, including how the client and server interact with
      proxies.

   5. New services should follow the guidelines in <a href="#section-8">section 8</a> regarding
      use of HTTP status codes.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/10.%20%20Security%20Considerations"></a><a class="selflink" href="#section-10" name="section-10">10</a>.  Security Considerations</span>

   Much of this document is about security.  <a href="#section-2.3">Section 2.3</a> discusses
   whether HTTP security is adequate for the needs of a particular
   application, <a href="#section-2.4">section 2.4</a> discusses interactions between new HTTP-
   based protocols and firewalls, <a href="#section-3">section 3</a> discusses use of separate
   ports so that firewalls are not circumvented, and <a href="#section-4">section 4</a> discusses
   the inadequacy of the "s" suffix of a URL prefix for specifying
   security levels.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/11.%20%20References"></a><a class="selflink" href="#section-11" name="section-11">11</a>.  References</span>

   [<a id="ref-1" name="ref-1">1</a>]   Fielding, R., Gettys, J., Mogul, J., Frystyk, H., Masinter, L.,
         Leach, P. and T. Berners-Lee, "Hypertext Transfer Protocol --
         HTTP/1.1", <a href="rfc2616.html">RFC 2616</a>, June 1999.






<span class="grey">Moore                    Best Current Practice                 [Page 12]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-13" id="page-13" name="page-13"> </a>
<span class="grey"><a href="rfc3205.html">RFC 3205</a>                     HTTP Layering                 February 2002</span>


   [<a id="ref-2" name="ref-2">2</a>]   Franks, J., Hallam-Baker, P., Hostetler, J., Lawrence, S.,
         Leach, P., Luotonen, A. and L. Stewart, "HTTP Authentication:
         Basic and Digest Access Authentication", <a href="rfc2617.html">RFC 2617</a>, June 1999.

   [<a id="ref-3" name="ref-3">3</a>]   Dierks, T. and C. Allen, "The TLS Protocol Version 1.0", <a href="rfc2246.html">RFC</a>
         <a href="rfc2246.html">2246</a>, January 1999.

   [<a id="ref-4" name="ref-4">4</a>]   Postel, J. and J. Reynolds, "Telnet Protocol Specification",
         STD 8, <a href="rfc854.html">RFC 854</a>, May 1983.

   [<a id="ref-5" name="ref-5">5</a>]   Postel, J. and J. Reynolds, "File Transfer Protocol", STD 9,
         <a href="rfc959.html">RFC 959</a>, October 1985.

   [<a id="ref-6" name="ref-6">6</a>]   Klensin, J., "Simple Mail Transfer Protocol", <a href="rfc2821.html">RFC 2821</a>, April
         2001.

   [<a id="ref-7" name="ref-7">7</a>]   Myers, J., "Simple Authentication and Security Layer (SASL)",
         <a href="rfc2222.html">RFC 2222</a>, October 1997.

   [<a id="ref-8" name="ref-8">8</a>]   Petke, R. and I. King, "Registration Procedures for URL Scheme
         Names", <a href="https://tools.ietf.org/html/bcp35">BCP 35</a>, <a href="rfc2717.html">RFC 2717</a>, November 1999.

   [<a id="ref-9" name="ref-9">9</a>]   Freed, N. and N. Borenstein, "Multipurpose Internet Mail
         Extensions (MIME) Part Two: Media Types", <a href="rfc2046.html">RFC 2046</a>, November
         1996.

   [<a id="ref-10" name="ref-10">10</a>]  Howes, T., Smith, M. and F. Dawson, "A MIME Content-Type for
         Directory Information", <a href="rfc2425.html">RFC 2425</a>, September 1998.

   [<a id="ref-11" name="ref-11">11</a>]  Bray, T., Paoli, J. and C. Sperberg-McQueen, "Extensible Markup
         Language (XML)" World Wide Web Consortium Recommendation REC-
         xml-19980210, February 1998.  <a href="http://www.w3.org/TR/1998/REC-xml-19980210">http://www.w3.org/TR/1998/REC-</a>
         <a href="http://www.w3.org/TR/1998/REC-xml-19980210">xml-19980210</a>.

   [<a id="ref-12" name="ref-12">12</a>]  Murata, M., St. Laurent, S. and D. Kohn, "XML Media Types", <a href="rfc3023.html">RFC</a>
         <a href="rfc3023.html">3023</a>, January 2001.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/12.%20%20Author%27s%20Address"></a><a class="selflink" href="#section-12" name="section-12">12</a>.  Author's Address</span>

   Keith Moore
   University of Tennessee
   Computer Science Department
   1122 Volunteer Blvd, Suite 203
   Knoxville TN, 37996-3450
   USA

   EMail: moore@cs.utk.edu




<span class="grey">Moore                    Best Current Practice                 [Page 13]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-14" id="page-14" name="page-14"> </a>
<span class="grey"><a href="rfc3205.html">RFC 3205</a>                     HTTP Layering                 February 2002</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/13.%20%20Full%20Copyright%20Statement"></a><a class="selflink" href="#section-13" name="section-13">13</a>.  Full Copyright Statement</span>

   Copyright (C) The Internet Society (2002).  All Rights Reserved.

   This document and translations of it may be copied and furnished to
   others, and derivative works that comment on or otherwise explain it
   or assist in its implementation may be prepared, copied, published
   and distributed, in whole or in part, without restriction of any
   kind, provided that the above copyright notice and this paragraph are
   included on all such copies and derivative works.  However, this
   document itself may not be modified in any way, such as by removing
   the copyright notice or references to the Internet Society or other
   Internet organizations, except as needed for the purpose of
   developing Internet standards in which case the procedures for
   copyrights defined in the Internet Standards process must be
   followed, or as required to translate it into languages other than
   English.

   The limited permissions granted above are perpetual and will not be
   revoked by the Internet Society or its successors or assigns.

   This document and the information contained herein is provided on an
   "AS IS" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING
   TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING
   BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION
   HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF
   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.

Acknowledgement

   Funding for the RFC Editor function is currently provided by the
   Internet Society.



















Moore                    Best Current Practice                 [Page 14]

</pre><br/>
    <span class="noprint"><small><small>Html markup produced by rfcmarkup 1.126, available from
      <a href="https://tools.ietf.org/tools/rfcmarkup/">https://tools.ietf.org/tools/rfcmarkup/</a>
    </small></small></span>
  </div>




</body><!-- Mirrored from tools.ietf.org/html/rfc3205 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 06 Mar 2018 23:18:47 GMT --></html>