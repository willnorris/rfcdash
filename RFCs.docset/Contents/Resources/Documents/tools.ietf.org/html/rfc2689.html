<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml"><!-- Mirrored from tools.ietf.org/html/rfc2689 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 06 Mar 2018 23:18:52 GMT --><!-- Added by HTTrack --><head><meta content="text/html;charset=utf-8" http-equiv="content-type"/><!-- /Added by HTTrack -->

    <meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
    <meta content="index,follow" name="robots"/>
    <meta content="rfcmarkup version 1.126" name="creator"/>
    <link href="http://purl.org/dc/elements/1.1/" rel="schema.DC"/>
<meta content="urn:ietf:rfc:2689" name="DC.Identifier"/>
<meta content="This document describes an architecture for providing integrated
services over low-bitrate links, such as modem lines, ISDN B-
channels, and sub-T1 links. It covers only the lower parts of the
Internet Multimedia Conferencing Architecture [1]; additional
components required for application services such as Internet
Telephony (e.g., a session initiation protocol) are outside the scope
of this document. The main components of the architecture are: a real-
time encapsulation format for asynchronous and synchronous low-
bitrate links, a header compression architecture optimized for real-
time flows, elements of negotiation protocols used between routers (or
between hosts and routers), and announcement protocols used by
applications to allow this negotiation to take place." name="DC.Description.Abstract"/>
<meta content="Carsten Bormann &lt;cabo@tzi.org&gt;" name="DC.Creator"/>
<meta content="September, 1999" name="DC.Date.Issued"/>
<meta content="Providing integrated services over low-bitrate links" name="DC.Title"/>

    <link href="https://tools.ietf.org/images/rfc.png" rel="icon" type="image/png"/>
    <link href="https://tools.ietf.org/images/rfc.png" rel="shortcut icon" type="image/png"/>
    <title>RFC 2689 - Providing integrated services over low-bitrate links</title>
    
    
    <style type="text/css">
	@media only screen 
	  and (min-width: 992px)
	  and (max-width: 1199px) {
	    body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 768px)
	  and (max-width: 991px) {
            body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 480px)
	  and (max-width: 767px) {
            body { font-size: 11pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (max-width: 479px) {
            body { font-size: 8pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-device-width : 375px) 
	  and (max-device-width : 667px) {
            body { font-size: 9.5pt; }
            div.content { width: 96ex; margin: 0 1px; }
        }
	@media only screen 
	  and (min-device-width: 1200px) {
            body { font-size: 10pt; margin: 0 4em; }
            div.content { width: 96ex; margin: 0; }
        }
        h1, h2, h3, h4, h5, h6, .h1, .h2, .h3, .h4, .h5, .h6 {
	    font-weight: bold;
            line-height: 0pt;
            display: inline;
            white-space: pre;
            font-family: monospace;
            font-size: 1em;
	    font-weight: bold;
        }
        pre {
            font-size: 1em;
            margin-top: 0px;
            margin-bottom: 0px;
        }
	.pre {
	    white-space: pre;
	    font-family: monospace;
	}
	.header{
	    font-weight: bold;
	}
        .newpage {
            page-break-before: always;
        }
        .invisible {
            text-decoration: none;
            color: white;
        }
        a.selflink {
          color: black;
          text-decoration: none;
        }
        @media print {
            body {
                font-family: monospace;
                font-size: 10.5pt;
            }
            h1, h2, h3, h4, h5, h6 {
                font-size: 1em;
            }
        
            a:link, a:visited {
                color: inherit;
                text-decoration: none;
            }
            .noprint {
                display: none;
            }
        }
	@media screen {
	    .grey, .grey a:link, .grey a:visited {
		color: #777;
	    }
            .docinfo {
                background-color: #EEE;
            }
            .top {
                border-top: 7px solid #EEE;
            }
            .bgwhite  { background-color: white; }
            .bgred    { background-color: #F44; }
            .bggrey   { background-color: #666; }
            .bgbrown  { background-color: #840; }            
            .bgorange { background-color: #FA0; }
            .bgyellow { background-color: #EE0; }
            .bgmagenta{ background-color: #F4F; }
            .bgblue   { background-color: #66F; }
            .bgcyan   { background-color: #4DD; }
            .bggreen  { background-color: #4F4; }

            .legend   { font-size: 90%; }
            .cplate   { font-size: 70%; border: solid grey 1px; }
	}
    </style>
    <!--[if IE]>
    <style>
    body {
       font-size: 13px;
       margin: 10px 10px;
    }
    </style>
    <![endif]-->

    <script type="text/javascript"><!--
    function addHeaderTags() {
	var spans = document.getElementsByTagName("span");
	for (var i=0; i < spans.length; i++) {
	    var elem = spans[i];
	    if (elem) {
		var level = elem.getAttribute("class");
                if (level == "h1" || level == "h2" || level == "h3" || level == "h4" || level == "h5" || level == "h6") {
                    elem.innerHTML = "<"+level+">"+elem.innerHTML+"</"+level+">";		
                }
	    }
	}
    }
    var legend_html = "Colour legend:<br />      <table>         <tr><td>Unknown:</td>                   <td><span class='cplate bgwhite'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft:</td>                     <td><span class='cplate bgred'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Informational:</td>             <td><span class='cplate bgorange'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Experimental:</td>              <td><span class='cplate bgyellow'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Best Common Practice:</td>      <td><span class='cplate bgmagenta'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Proposed Standard:</td>         <td><span class='cplate bgblue'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft Standard (old designation):</td> <td><span class='cplate bgcyan'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Internet Standard:</td>         <td><span class='cplate bggreen'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Historic:</td>                  <td><span class='cplate bggrey'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Obsolete:</td>                  <td><span class='cplate bgbrown'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>     </table>";
    function showElem(id) {
        var elem = document.getElementById(id);
        elem.innerHTML = eval(id+"_html");
        elem.style.visibility='visible';
    }
    function hideElem(id) {
        var elem = document.getElementById(id);
        elem.style.visibility='hidden';        
        elem.innerHTML = "";
    }
    // -->
    </script>
</head>
<body onload="addHeaderTags()">
  <div class="content">
   <div style="height: 13px;">
      <div class="pre noprint docinfo bgorange" onclick="showElem('legend');" onmouseout="hideElem('legend')" onmouseover="this.style.cursor='pointer';" style="height: 6px; position: absolute;" title="Click for colour legend.">                                                                        </div>
      <div class="docinfo noprint pre legend" id="legend" onmouseout="hideElem('legend');" onmouseover="showElem('legend');" style="position:absolute; top: 4px; left: 4ex; visibility:hidden; background-color: white; padding: 4px 9px 5px 7px; border: solid #345 1px; ">
      </div>
   </div>
<span class="pre noprint docinfo top">[<a href="index.html" title="Document search and retrieval page">Docs</a>] [<a href="https://tools.ietf.org/rfc/rfc2689.txt" title="Plaintext version of this document">txt</a>|<a href="https://tools.ietf.org/pdf/rfc2689" title="PDF version of this document">pdf</a>] [<a href="https://tools.ietf.org/html/draft-ietf-issll-isslow" title="draft-ietf-issll-isslow">draft-ietf-issl...</a>] [<a href="https://datatracker.ietf.org/doc/rfc2689" title="IESG Datatracker information for this document">Tracker</a>] [<a href="https://tools.ietf.org/rfcdiff?difftype=--hwdiff&amp;url2=rfc2689" title="Inline diff (wdiff)">Diff1</a>] [<a href="https://tools.ietf.org/rfcdiff?url2=rfc2689" title="Side-by-side diff">Diff2</a>]         </span><br/>
<span class="pre noprint docinfo">                                                                        </span><br/>
<span class="pre noprint docinfo">                                                           INFORMATIONAL</span><br/>
<span class="pre noprint docinfo">                                                                        </span><br/>
<pre>Network Working Group                                         C. Bormann
Request for Comments: 2689                       Universitaet Bremen TZI
Category: Informational                                   September 1999


          <span class="h1">Providing Integrated Services over Low-bitrate Links</span>

Status of this Memo

   This memo provides information for the Internet community.  It does
   not specify an Internet standard of any kind.  Distribution of this
   memo is unlimited.

Copyright Notice

   Copyright (C) The Internet Society (1999).  All Rights Reserved.

Abstract

   This document describes an architecture for providing integrated
   services over low-bitrate links, such as modem lines, ISDN B-
   channels, and sub-T1 links.  It covers only the lower parts of the
   Internet Multimedia Conferencing Architecture [<a href="#ref-1" title='"The Internet Multimedia Conferencing Architecture"'>1</a>]; additional
   components required for application services such as Internet
   Telephony (e.g., a session initiation protocol) are outside the scope
   of this document.  The main components of the architecture are: a
   real-time encapsulation format for asynchronous and synchronous low-
   bitrate links, a header compression architecture optimized for real-
   time flows, elements of negotiation protocols used between routers
   (or between hosts and routers), and announcement protocols used by
   applications to allow this negotiation to take place.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/1.%20%20Introduction"></a><a class="selflink" href="#section-1" name="section-1">1</a>.  Introduction</span>

   As an extension to the "best-effort" services the Internet is well-
   known for, additional types of services ("integrated services") that
   support the transport of real-time multimedia information are being
   developed for, and deployed in the Internet.  Important elements of
   this development are:

   -  parameters for forwarding mechanisms that are appropriate for
      real-time information [<a href="#ref-11" title='"Specification of the Controlled-Load Network Element Service"'>11</a>, <a href="#ref-12" title='"Specification of Guaranteed Quality of Service"'>12</a>],

   -  a setup protocol that allows establishing special forwarding
      treatment for real-time information flows (RSVP [<a href="#ref-4" title='"Resource ReSerVation Protocol (RSVP) -- Version 1 Functional Specification"'>4</a>]),

   -  a transport protocol for real-time information (RTP/RTCP [<a href="#ref-6" title='"RTP: A Transport Protocol for Real-Time Applications"'>6</a>]).




<span class="grey">Bormann                      Informational                      [Page 1]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-2" id="page-2" name="page-2"> </a>
<span class="grey"><a href="rfc2689.html">RFC 2689</a>       Integrated Services over Low-bitrate Links September 1999</span>


   In addition to these elements at the network and transport levels of
   the Internet Multimedia Conferencing Architecture [<a href="#ref-1" title='"The Internet Multimedia Conferencing Architecture"'>1</a>], further
   components are required to define application services such as
   Internet Telephony, e.g., protocols for session initiation and
   control.  These components are outside the scope of this document.

   Up to now, the newly developed services could not (or only very
   inefficiently) be used over forwarding paths that include low-bitrate
   links such as 14.4, 33.6, and 56 kbit/s modems, 56 and 64 kbit/s ISDN
   B-channels, or even sub-T1 links.  The encapsulation formats used on
   these links are not appropriate for the simultaneous transport of
   arbitrary data and real-time information that has to meet stringent
   delay requirements.  Transmission of a 1500 byte packet on a 28.8
   kbit/s modem link makes this link unavailable for the transmission of
   real-time information for about 400 ms.  This adds a worst-case delay
   that causes real-time applications to operate with round-trip delays
   on the order of at least a second -- unacceptable for real-time
   conversation.  In addition, the header overhead associated with the
   protocol stacks used is prohibitive on low-bitrate links, where
   compression down to a few dozen bytes per real-time information
   packet is often desirable.  E.g., the overhead of at least 44
   (4+20+8+12) bytes for HDLC/PPP, IP, UDP, and RTP completely
   overshadows typical audio payloads such as the 19.75 bytes needed for
   a G.723.1 ACELP audio frame -- a 14.4 kbit/s link is completely
   consumed by this header overhead alone at 40 real-time frames per
   second total (i.e., at 25 ms packetization delay for one stream or 50
   ms for two streams, with no space left for data, yet).  While the
   header overhead can be reduced by combining several real-time
   information frames into one packet, this increases the delay incurred
   while filling that packet and further detracts from the goal of
   real-time transfer of multi-media information over the Internet.

   This document describes an approach for addressing these problems.
   The main components of the architecture are:

   -  a real-time encapsulation format for asynchronous and synchronous
      low-bitrate links,

   -  a header compression architecture optimized for real-time flows,

   -  elements of negotiation protocols used between routers (or between
      hosts and routers), and

   -  announcement protocols used by applications to allow this
      negotiation to take place.






<span class="grey">Bormann                      Informational                      [Page 2]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-3" id="page-3" name="page-3"> </a>
<span class="grey"><a href="rfc2689.html">RFC 2689</a>       Integrated Services over Low-bitrate Links September 1999</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/2.%20%20Design%20Considerations"></a><a class="selflink" href="#section-2" name="section-2">2</a>.  Design Considerations</span>

   The main design goal for an architecture that addresses real-time
   multimedia flows over low-bitrate links is that of minimizing the
   end-to-end delay.  More specifically, the worst case delay (after
   removing possible outliers, which are equivalent to packet losses
   from an application point of view) is what determines the playout
   points selected by the applications and thus the delay actually
   perceived by the user.

   In addition, any such architecture should obviously undertake every
   attempt to maximize the bandwidth actually available to media data;
   overheads must be minimized.

   An important component of the integrated services architecture is the
   provision of reservations for real-time flows.  One of the problems
   that systems on low-bitrate links (routers or hosts) face when
   performing admission control for such reservations is that they must
   translate the bandwidth requested in the reservation to the one
   actually consumed on the link.  Methods such as data compression
   and/or header compression can reduce the requirements on the link,
   but admission control can only make use of the reduced requirements
   in its calculations if it has enough information about the data
   stream to know how effective the compression will be.  One goal of
   the architecture therefore is to provide the integrated services
   admission control with this information.  A beneficial side effect
   may be to allow the systems to perform better compression than would
   be possible without this information.  This may make it worthwhile to
   provide this information even when it is not intended to make a
   reservation for a real-time flow.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/3.%20%20The%20Need%20for%20a%20Concerted%20Approach"></a><a class="selflink" href="#section-3" name="section-3">3</a>.  The Need for a Concerted Approach</span>

   Many technical approaches come to mind for addressing these problems,
   in particular a new form of low-delay encapsulation to address delay
   and header compression methods to address overhead.  This section
   shows that these techniques should be combined to solve the problem.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.1.%20%20Real-Time%20Encapsulation"></a><a class="selflink" href="#section-3.1" name="section-3.1">3.1</a>.  Real-Time Encapsulation</span>

   The purpose of defining a real-time link-layer encapsulation protocol
   is to be able to introduce newly arrived real-time packets into the
   link-layer data stream without having to wait for the currently
   transmitted (possibly large) packet to end.  Obviously, a real-time
   encapsulation must be part of any complete solution as the problem of
   delays induced by large frames on the link can only be solved on this
   layer.




<span class="grey">Bormann                      Informational                      [Page 3]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-4" id="page-4" name="page-4"> </a>
<span class="grey"><a href="rfc2689.html">RFC 2689</a>       Integrated Services over Low-bitrate Links September 1999</span>


   To be able to switch to a real-time packet quickly in an interface
   driver, it is first necessary to identify packets that belong to
   real-time flows.  This can be done using a heuristic approach (e.g.,
   favor the transmission of highly periodic flows of small packets
   transported in IP/UDP, or use the IP precedence fields in a specific
   way defined within an organization).  Preferably, one also could make
   use of a protocol defined for identifying flows that require special
   treatment, i.e. RSVP.  Of the two service types defined for use with
   RSVP now, the guaranteed service will only be available in certain
   environments; for this and various other reasons, the service type
   chosen for many adaptive audio/video applications will most likely be
   the controlled-load service.  Controlled-load does not provide
   control parameters for target delay; thus it does not unambiguously
   identify those packet streams that would benefit most from being
   transported in a real-time encapsulation format.  This calls for a
   way to provide additional parameters in integrated services flow
   setup protocols to control the real-time encapsulation.

   Real-time encapsulation is not sufficient on its own, however: Even
   if the relevant flows can be appropriately identified for real-time
   treatment, most applications simply cannot operate properly on low-
   bitrate links with the header overhead implied by the combination of
   HDLC/PPP, IP, UDP, and RTP, i.e. they absolutely require header
   compression.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.2.%20%20Header%20Compression"></a><a class="selflink" href="#section-3.2" name="section-3.2">3.2</a>.  Header Compression</span>

   Header compression can be performed in a variety of elements and at a
   variety of levels in the protocol architecture.  As many vendors of
   Internet Telephony products for PCs ship applications, the approach
   that is most obvious to them is to reduce overhead by performing
   header compression at the application level, i.e. above transport
   protocols such as UDP (or actually by using a non-standard,
   efficiently coded header in the first place).

   Generally, header compression operates by installing state at both
   ends of a path that allows the receiving end to reconstruct
   information omitted at the sending end.  Many good techniques for
   header compression (<a href="rfc1144.html">RFC 1144</a>, [<a href="#ref-2" title='"IP Header Compression"'>2</a>]) operate on the assumption that the
   path will not reorder the frames generated.  This assumption does not
   hold for end-to-end compression; therefore additional overhead is
   required for resequencing state changes and for compressed packets
   making use of these state changes.

   Assume that a very good application level header compression solution
   for RTP flows could be able to save 11 out of the 12 bytes of an RTP
   header [<a href="#ref-3" title='"Framework for C/RTP: Compressed RTP Using Adaptive Differential Header Compression"'>3</a>].  Even this perfect solution only reduces the total header
   overhead by 1/4.  It would have to be deployed in all applications,



<span class="grey">Bormann                      Informational                      [Page 4]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-5" id="page-5" name="page-5"> </a>
<span class="grey"><a href="rfc2689.html">RFC 2689</a>       Integrated Services over Low-bitrate Links September 1999</span>


   even those that operate on systems that are attached to higher-
   bitrate links.

   Because of this limited effectiveness, the AVT group that is
   responsible for RTP within the IETF has decided to not further pursue
   application level header compression.

   For router and IP stack vendors, the obvious approach is to define
   header compression that can be negotiated between peer routers.

   Advanced header compression techniques now being defined in the IETF
   [<a href="#ref-2" title='"IP Header Compression"'>2</a>] certainly can relieve the link from significant parts of the
   IP/UDP overhead (i.e., most of 28 of the 44 bytes mentioned above).

   One of the design principles of the new IP header compression
   developed in conjunction with IPv6 is that it stops at layers the
   semantics of which cannot be inferred from information in lower layer
   (outer) headers.  Therefore, this header compression technique alone
   cannot compress the data that is contained within UDP packets.

   Any additional header compression technique runs into a problem: If
   it assumes specific application semantics (i.e., those of RTP and a
   payload data format) based on heuristics, it runs the risk of being
   triggered falsely and (e.g. in case of packet loss) reconstructing
   packets that are catastrophically incorrect for the application
   actually being used.  A header compression technique that can be
   operated based on heuristics but does not cause incorrect
   decompression even if the heuristics failed is described in [<a href="#ref-7" title='"Compressing IP/UDP/RTP Headers for Low-Speed Serial Links"'>7</a>]; a
   companion document describes the mapping of this technique to PPP
   [<a href="#ref-10" title='"IP Header Compression over PPP"'>10</a>].

   With all of these techniques, the total IP/UDP/RTP header overhead
   for an audio stream can be reduced to two bytes per packet.  This
   technology need only be deployed at bottleneck links; high-speed
   links can transfer the real-time streams without routers or switches
   expending CPU cycles to perform header compression.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/4.%20%20Principles%20of%20Real-Time%20Encapsulation%20for%20Low-Bitrate%20Links"></a><a class="selflink" href="#section-4" name="section-4">4</a>.  Principles of Real-Time Encapsulation for Low-Bitrate Links</span>

   The main design goal for a real-time encapsulation is to minimize the
   delay incurred by real-time packets that become available for sending
   while a long data packet is being sent.  To achieve this, the
   encapsulation must be able to either abort or suspend the transfer of
   the long data packet.  As an additional goal is to minimize the
   overhead required for the transmission of packets from periodic
   flows, this strongly argues for being able to suspend a packet, i.e.
   segment it into parts between which the real-time packets can be
   transferred.



<span class="grey">Bormann                      Informational                      [Page 5]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-6" id="page-6" name="page-6"> </a>
<span class="grey"><a href="rfc2689.html">RFC 2689</a>       Integrated Services over Low-bitrate Links September 1999</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.1.%20%20Using%20existing%20IP%20fragmentation"></a><a class="selflink" href="#section-4.1" name="section-4.1">4.1</a>.  Using existing IP fragmentation</span>

   Transmitting only part of a packet, to allow higher-priority traffic
   to intervene and then resuming its transmission later on, is a kind
   of fragmentation.  Fragmentation is an existing functionality of the
   IP layer: An IPv4 header already contains fields that allow a large
   IP datagram to be fragmented into small parts.  A sender's "real-time
   PPP" implementation might simply indicate a small MTU to its IP stack
   and thus cause all larger datagrams to be fragmented down to a size
   that allows the access delay goals to be met (this assumes that the
   IP stack is able to priority-tag fragments, or that the PPP
   implementation is able to correlate the fragments to the initial one
   that carries the information relevant for prioritizing, or that only
   initial fragments can be high-priority).  (Also, a PPP implementation
   can negotiate down the MTU of its peer, causing the peer to fragment
   to a small size, which might be considered a crude form of
   negotiating an access delay goal with the peer system -- if that
   system supports priority queueing at the fragment level.)

   Unfortunately, a full, 20 byte IP header is needed for each fragment
   (larger when IP options are used).  This limits the minimum size of
   fragments that can be used without too much overhead.  (Also, the
   size of non-final fragments must be a multiple of 8 bytes, further
   limiting the choice.)  With path MTU discovery, IP level
   fragmentation causes TCP implementations to use small MSSs -- this
   further increases the per-packet overhead to 40 bytes per fragment.

   In any case, fragmentation at the IP level persists on the path
   further down to the datagram receiver, increasing the transmission
   overheads and router load throughout the network.  With its high
   overhead and the adverse effect on the Internet, IP level
   fragmentation can only be a stop-gap mechanism when no other
   fragmentation protocol is available in the peer implementation.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.2.%20%20Link-Layer%20Mechanisms"></a><a class="selflink" href="#section-4.2" name="section-4.2">4.2</a>.  Link-Layer Mechanisms</span>

   Cell-oriented multiplexing techniques such as ATM that introduce
   regular points where cells from a different packet can be
   interpolated are too inefficient for low-bitrate links; also, they
   are not supported by chips used to support the link layer in low-
   bitrate routers and host interfaces.










<span class="grey">Bormann                      Informational                      [Page 6]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-7" id="page-7" name="page-7"> </a>
<span class="grey"><a href="rfc2689.html">RFC 2689</a>       Integrated Services over Low-bitrate Links September 1999</span>


   Instead, the real-time encapsulation should as far as possible make
   use of the capabilities of the chips that have been deployed.  On
   synchronous lines, these chips support HDLC framing; on asynchronous
   lines, an asynchronous variant of HDLC that usually is implemented in
   software is being used.  Both variants of HDLC provide a delimiting
   mechanism to indicate the end of a frame over the link.  The obvious
   solution to the segmentation problem is to combine this mechanism
   with an indication of whether the delimiter terminates or suspends
   the current packet.

   This indication could be in an octet appended to each frame
   information field; however, seven out of eight bits of the octet
   would be wasted.  Instead, the bit could be carried at the start of
   the next frame in conjunction with multiplexing information (PPP
   protocol identifier etc.) that will be required here anyway.  Since
   the real-time flows will in general be periodic, this multiplexing
   information could convey (part of) the compressed form of the header
   for the packet.  If packets from the real-time flow generally are of
   constant length (or have a defined maximum length that is often
   used), the continuation of the suspended packet could be immediately
   attached to it, without expending a further frame delimiter, i.e.,
   the interpolation of the real-time packet would then have zero
   overhead.  Since packets from low-delay real-time flows generally
   will not require the ability to be further suspended, the
   continuation bit could be reserved for the non-real-time packet
   stream.

   One real-time encapsulation format with these (and other) functions
   is described in ITU-T H.223 [<a href="#ref-13" title='"Multiplexing protocol for low bit rate multimedia communication"'>13</a>], the multiplex used by the H.324
   modem-based videophone standard [<a href="#ref-14" title='"Terminal for low bit rate multimedia communication"'>14</a>].  It was investigated whether
   compatibility could be achieved with this specification, which will
   be used in future videophone-enabled (H.324 capable) modems.
   However, since the multiplexing capabilities of H.223 are limited to
   15 schedules (definitions of sequences of packet types that can be
   identified in a multiplex header), for general Internet usage a
   superset or a more general encapsulation would have been required.
   Also, a PPP-style negotiation protocol was needed instead of using
   (and necessarily extending) ITU-T H.245 [<a href="#ref-15" title='"Control protocol for multimedia communication"'>15</a>] for setting the
   parameters of the multiplex.  In the PPP context, the interactions
   with the encapsulations for data compression and link layer
   encryption needed to be defined (including operation in the presence
   of padding).  But most important, H.223 requires synchronous HDLC
   chips that can be configured to send frames without an attached CRC,
   which is not possible with all chips deployed in commercially
   available routers; so complete compatibility was unachievable.






<span class="grey">Bormann                      Informational                      [Page 7]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-8" id="page-8" name="page-8"> </a>
<span class="grey"><a href="rfc2689.html">RFC 2689</a>       Integrated Services over Low-bitrate Links September 1999</span>


   Instead of adopting H.223, it was decided to pursue an approach that
   is oriented towards compatibility both with existing hardware and
   existing software (in particular PPP) implementations.  The next
   subsection groups these implementations according to their
   capabilities.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.3.%20%20Implementation%20models"></a><a class="selflink" href="#section-4.3" name="section-4.3">4.3</a>.  Implementation models</span>

   This section introduces a number of terms for types of
   implementations that are likely to emerge.  It is important to have
   these different implementation models in mind as there is no single
   approach that fits all models best.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/4.3.1.%20%20Sender%20types"></a><a class="selflink" href="#section-4.3.1" name="section-4.3.1">4.3.1</a>.  Sender types</span>

   There are two fundamental approaches to real-time transmission on
   low-bitrate links:

   Sender type 1
      The PPP real-time framing implementation is able to control the
      transmission of each byte being transmitted with some known,
      bounded delay (e.g., due to FIFOs).  For example, this is
      generally true of PC host implementations, which directly access
      serial interface chips byte by byte or by filling a very small
      FIFO.  For type 1 senders, a suspend/resume type approach will be
      typically used: When a long frame is to be sent, the attempt is to
      send it undivided; only if higher priority packets come up during
      the transmission will the lower-priority long frame be suspended
      and later resumed.  This approach allows the minimum variation in
      access delay for high-priority packets; also, fragmentation
      overhead is only incurred when actually needed.

   Sender type 2
      With type 2 senders, the interface between the PPP real-time
      framing implementation and the transmission hardware is not in
      terms of streams of bytes, but in terms of frames, e.g., in the
      form of multiple (prioritized) send queues directly supported by
      hardware.  This is often true of router systems for synchronous
      links, in particular those that have to support a large number of
      low-bitrate links.  As type 2 senders have no way to suspend a
      frame once it has been handed down for transmission, they
      typically will use a queues-of-fragments approach, where long
      packets are always split into units that are small enough to
      maintain the access delay goals for higher-priority traffic.
      There is a trade-off between the variation in access delay
      resulting from a large fragment size and the overhead that is
      incurred for every long packet by choosing a small fragment size.




<span class="grey">Bormann                      Informational                      [Page 8]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-9" id="page-9" name="page-9"> </a>
<span class="grey"><a href="rfc2689.html">RFC 2689</a>       Integrated Services over Low-bitrate Links September 1999</span>


<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/4.3.2.%20%20Receiver%20types"></a><a class="selflink" href="#section-4.3.2" name="section-4.3.2">4.3.2</a>.  Receiver types</span>

   Although the actual work of formulating transmission streams for
   real-time applications is performed at the sender, the ability of the
   receiver to immediately make use of the information received depends
   on its characteristics:

   Receiver type 1
      Type 1 receivers have full control over the stream of bytes
      received within PPP frames, i.e., bytes received are available
      immediately to the PPP real-time framing implementation (with some
      known, bounded delay e.g. due to FIFOs etc.).

   Receiver type 2
      With type 2 receivers, the PPP real-time framing implementation
      only gets hold of a frame when it has been received completely,
      i.e., the final flag has been processed (typically by some HDLC
      chip that directly fills a memory buffer).

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.4.%20%20Conclusion"></a><a class="selflink" href="#section-4.4" name="section-4.4">4.4</a>.  Conclusion</span>

   As a result of the diversity in capabilities of current
   implementations, there are now two specifications for real-time
   encapsulation: One, the multi-class extension to the PPP multi-link
   protocol, is providing the solution for the queues-of-fragments
   approach by extending the single-stream PPP multi-link protocol by
   multiple classes [<a href="#ref-8" title='"The Multi-Class Extension to Multi-Link PPP"'>8</a>].  The other encapsulation, PPP in a real-time
   oriented HDLC-like framing, builds on this specification end extends
   it by a way to dynamically delimit multiple fragments within one HDLC
   frame [<a href="#ref-9" title='"PPP in a Real-time Oriented HDLC-like Framing"'>9</a>], providing the solution for the suspend/resume type
   approach.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/5.%20%20Principles%20of%20Header%20Compression%20for%20Real-Time%20Flows"></a><a class="selflink" href="#section-5" name="section-5">5</a>.  Principles of Header Compression for Real-Time Flows</span>

   A good baseline for a discussion about header compression is in the
   new IP header compression specification that was designed in
   conjunction with the development of IPv6 [<a href="#ref-2" title='"IP Header Compression"'>2</a>].  The techniques used
   there can reduce the 28 bytes of IPv4/UDP header to about 6 bytes
   (depending on the number of concurrent streams); with the remaining 4
   bytes of HDLC/PPP overhead and 12 bytes for RTP the total header
   overhead can be about halved but still exceeds the size of a G.723.1
   ACELP frame.  Note that, in contrast to IP header compression, the
   environment discussed here assumes the existence of a full-duplex PPP
   link and thus can rely on negotiation where IP header compression
   requires repeated transmission of the same information.  (The use of
   the architecture of the present document with link layer multicasting
   has not yet been examined.)




<span class="grey">Bormann                      Informational                      [Page 9]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-10" id="page-10" name="page-10"> </a>
<span class="grey"><a href="rfc2689.html">RFC 2689</a>       Integrated Services over Low-bitrate Links September 1999</span>


   Additional design effort was required for RTP header compression.
   Applying the concepts of IP header compression, of the (at least) 12
   bytes in an RTP header, 7 bytes (timestamp, sequence, and marker bit)
   would qualify as RANDOM; DELTA encoding cannot generally be used
   without further information since the lower layer header does not
   unambiguously identify the semantics and there is no TCP checksum
   that can be relied on to detect incorrect decompression.  Only a more
   semantics-oriented approach can provide better compression (just as
   <a href="rfc1144.html">RFC 1144</a> can provide very good compression of TCP headers by making
   use of semantic knowledge of TCP and its checksumming method).

   For RTP packets, differential encoding of the sequence number and
   timestamps is an efficient approach for certain cases of payload data
   formats.  E.g., speech flows generally have sequence numbers and
   timestamp fields that increase by 1 and by the frame size in
   timestamp units, resp.; the CRTP (compressed RTP) specification makes
   use of this relationship by encoding these fields only when the
   second order difference is non-zero [<a href="#ref-7" title='"Compressing IP/UDP/RTP Headers for Low-Speed Serial Links"'>7</a>].

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/6.%20%20Announcement%20Protocols%20Used%20by%20Applications"></a><a class="selflink" href="#section-6" name="section-6">6</a>.  Announcement Protocols Used by Applications</span>

   As argued, the compressor can operate best if it can make use of
   information that clearly identifies real-time streams and provides
   information about the payload data format in use.

   If these systems are routers, this consent must be installed as
   router state; if these systems are hosts, it must be known to their
   networking kernels.  Sources of real-time information flows are
   already describing characteristics of these flows to their kernels
   and to the routers in the form of TSpecs in RSVP PATH messages [<a href="#ref-4" title='"Resource ReSerVation Protocol (RSVP) -- Version 1 Functional Specification"'>4</a>].
   Since these messages make use of the router alert option, they are
   seen by all routers on the path; path state about the packet stream
   is normally installed at each of these routers that implement RSVP.
   Additional RSVP objects could be defined that are included in PATH
   messages by those applications that desire good performance over low-
   bitrate links; these objects would be coded to be ignored by routers
   that are not interested in them (class number 11bbbbbb as defined in
   [<a href="#ref-4" title='"Resource ReSerVation Protocol (RSVP) -- Version 1 Functional Specification"'>4</a>], section 3.10).

   Note that the path state is available in the routers even when no
   reservation is made; this allows informed compression of best-effort
   traffic.  It is not quite clear, though, how path state could be torn
   down quickly when a source ceases to transmit.








<span class="grey">Bormann                      Informational                     [Page 10]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-11" id="page-11" name="page-11"> </a>
<span class="grey"><a href="rfc2689.html">RFC 2689</a>       Integrated Services over Low-bitrate Links September 1999</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/7.%20%20Elements%20of%20Hop-By-Hop%20Negotiation%20Protocols"></a><a class="selflink" href="#section-7" name="section-7">7</a>.  Elements of Hop-By-Hop Negotiation Protocols</span>

   The IP header compression specification attempts to account for
   simplex and multicast links by providing information about the
   compressed streams only in the forward direction.  E.g., a full
   IP/UDP header must be sent after F_MAX_TIME (currently 3 seconds),
   which is a negligible total overhead (e.g. one full header every 150
   G.723.1 packets), but must be considered carefully in scheduling the
   real-time transmissions.  Both simplex and multicast links are not
   prevailing in the low-bitrate environment (although multicast
   functionality may become more important with wireless systems); in
   this document, we therefore assume full-duplex capability.

   As compression techniques will improve, a negotiation between the two
   peers on the link would provide the best flexibility in
   implementation complexity and potential for extensibility.  The peer
   routers/hosts can decide which real-time packet streams are to be
   compressed, which header fields are not to be sent at all, which
   multiplexing information should be used on the link, and how the
   remaining header fields should be encoded.  PPP, a well-tried suite
   of negotiation protocols, is already used on most of the low-bitrate
   links and seems to provide the obvious approach.  Cooperation from
   PPP is also needed to negotiate the use of real-time encapsulations
   between systems that are not configured to automatically do so.
   Therefore, PPP options that can be negotiated at the link setup (LCP)
   phase are included in [<a href="#ref-8" title='"The Multi-Class Extension to Multi-Link PPP"'>8</a>], [<a href="#ref-9" title='"PPP in a Real-time Oriented HDLC-like Framing"'>9</a>], and [<a href="#ref-10" title='"IP Header Compression over PPP"'>10</a>].

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/8.%20%20Security%20Considerations"></a><a class="selflink" href="#section-8" name="section-8">8</a>.  Security Considerations</span>

   Header compression protocols that make use of assumptions about
   application protocols need to be carefully analyzed whether it is
   possible to subvert other applications by maliciously or
   inadvertently enabling their use.

   It is generally not possible to do significant hop-by-hop header
   compression on encrypted streams.  With certain security policies, it
   may be possible to run an encrypted tunnel to a network access server
   that does header compression on the decapsulated packets and sends
   them over an encrypted link encapsulation; see also the short mention
   of interactions between real-time encapsulation and encryption in
   <a href="#section-4">section 4</a> above.  If the security requirements permit, a special RTP
   payload data format that encrypts only the data may preferably be
   used.








<span class="grey">Bormann                      Informational                     [Page 11]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-12" id="page-12" name="page-12"> </a>
<span class="grey"><a href="rfc2689.html">RFC 2689</a>       Integrated Services over Low-bitrate Links September 1999</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/9.%20%20References"></a><a class="selflink" href="#section-9" name="section-9">9</a>.  References</span>


    [<a id="ref-1" name="ref-1">1</a>]  Handley, M., Crowcroft, J., Bormann, C. and J. Ott, "The
         Internet Multimedia Conferencing Architecture", Work in
         Progress.

    [<a id="ref-2" name="ref-2">2</a>]  Degermark, M., Nordgren, B. and S. Pink, "IP Header
         Compression", <a href="rfc2507.html">RFC 2507</a>, February 1999.

    [<a id="ref-3" name="ref-3">3</a>]  Scott Petrack, Ed Ellesson, "Framework for C/RTP: Compressed
         RTP Using Adaptive Differential Header Compression",
         contribution to the mailing list rem-conf@es.net, February
         1996.

    [<a id="ref-4" name="ref-4">4</a>]  Braden, R., Zhang, L., Berson, S., Herzog, S. and S. Jamin,
         "Resource ReSerVation Protocol (RSVP) -- Version 1 Functional
         Specification", <a href="rfc2205.html">RFC 2205</a>, September 1997.

    [<a id="ref-5" name="ref-5">5</a>]  Sklower, K., Lloyd, B., McGregor, G., Carr, D. and T.
         Coradetti, "The PPP Multilink Protocol (MP)", <a href="rfc1990.html">RFC 1990</a>, August
         1996.

    [<a id="ref-6" name="ref-6">6</a>]  Schulzrinne, H., Casner, S., Frederick, R. and V. Jacobson,
         "RTP: A Transport Protocol for Real-Time Applications", <a href="rfc1889.html">RFC</a>
         <a href="rfc1889.html">1889</a>, January 1996.

    [<a id="ref-7" name="ref-7">7</a>]  Casner, S. and V. Jacobson, "Compressing IP/UDP/RTP Headers for
         Low-Speed Serial Links", <a href="rfc2508.html">RFC 2508</a>, February 1999.

    [<a id="ref-8" name="ref-8">8</a>]  Bormann, C., "The Multi-Class Extension to Multi-Link PPP", <a href="rfc2686.html">RFC</a>
         <a href="rfc2686.html">2686</a>, September 1999.

    [<a id="ref-9" name="ref-9">9</a>]  Bormann, C., "PPP in a Real-time Oriented HDLC-like Framing",
         <a href="rfc2687.html">RFC 2687</a>, September 1999.

   [<a id="ref-10" name="ref-10">10</a>]  Engan, M., Casner, S. and C. Bormann, "IP Header Compression
         over PPP", <a href="rfc2509.html">RFC 2509</a>, February 1999.

   [<a id="ref-11" name="ref-11">11</a>]  Wroclawski, J.,   "Specification of the Controlled-Load Network
         Element Service", <a href="rfc2211.html">RFC 2211</a>, September 1997.

   [<a id="ref-12" name="ref-12">12</a>]  Shenker, S., Partridge, C. and R. Guerin.  "Specification of
         Guaranteed Quality of Service", <a href="rfc2212.html">RFC 2212</a>, September 1997.







<span class="grey">Bormann                      Informational                     [Page 12]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-13" id="page-13" name="page-13"> </a>
<span class="grey"><a href="rfc2689.html">RFC 2689</a>       Integrated Services over Low-bitrate Links September 1999</span>


   [<a id="ref-13" name="ref-13">13</a>]  ITU-T Recommendation H.223, "Multiplexing protocol for low bit
         rate multimedia communication", International Telecommunication
         Union, Telecommunication Standardization Sector (ITU-T), March
         1996.

   [<a id="ref-14" name="ref-14">14</a>]  ITU-T Recommendation H.324, "Terminal for low bit rate
         multimedia communication", International Telecommunication
         Union, Telecommunication Standardization Sector (ITU-T), March
         1996.

   [<a id="ref-15" name="ref-15">15</a>]  ITU-T Recommendation H.245, "Control protocol for multimedia
         communication", International Telecommunication Union,
         Telecommunication Standardization Sector (ITU-T), March 1996.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/10.%20%20Author%27s%20Address"></a><a class="selflink" href="#section-10" name="section-10">10</a>.  Author's Address</span>

   Carsten Bormann
   Universitaet Bremen FB3 TZI
   Postfach 330440
   D-28334 Bremen, GERMANY

   Phone: +49.421.218-7024
   Fax:   +49.421.218-7000
   EMail: cabo@tzi.org

Acknowledgements

   Much of the early discussion that led to this document was done with
   Scott Petrack and Cary Fitzgerald.  Steve Casner, Mikael Degermark,
   Steve Jackowski, Dave Oran, the other members of the ISSLL subgroup
   on low bitrate links (ISSLOW), and in particular the ISSLL WG co-
   chairs Eric Crawley and John Wroclawski have helped in making this
   architecture a reality.


















<span class="grey">Bormann                      Informational                     [Page 13]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-14" id="page-14" name="page-14"> </a>
<span class="grey"><a href="rfc2689.html">RFC 2689</a>       Integrated Services over Low-bitrate Links September 1999</span>


Full Copyright Statement

   Copyright (C) The Internet Society (1999).  All Rights Reserved.

   This document and translations of it may be copied and furnished to
   others, and derivative works that comment on or otherwise explain it
   or assist in its implementation may be prepared, copied, published
   and distributed, in whole or in part, without restriction of any
   kind, provided that the above copyright notice and this paragraph are
   included on all such copies and derivative works.  However, this
   document itself may not be modified in any way, such as by removing
   the copyright notice or references to the Internet Society or other
   Internet organizations, except as needed for the purpose of
   developing Internet standards in which case the procedures for
   copyrights defined in the Internet Standards process must be
   followed, or as required to translate it into languages other than
   English.

   The limited permissions granted above are perpetual and will not be
   revoked by the Internet Society or its successors or assigns.

   This document and the information contained herein is provided on an
   "AS IS" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING
   TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING
   BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION
   HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF
   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.

Acknowledgement

   Funding for the RFC Editor function is currently provided by the
   Internet Society.



















Bormann                      Informational                     [Page 14]

</pre><br/>
    <span class="noprint"><small><small>Html markup produced by rfcmarkup 1.126, available from
      <a href="https://tools.ietf.org/tools/rfcmarkup/">https://tools.ietf.org/tools/rfcmarkup/</a>
    </small></small></span>
  </div>




</body><!-- Mirrored from tools.ietf.org/html/rfc2689 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 06 Mar 2018 23:18:52 GMT --></html>