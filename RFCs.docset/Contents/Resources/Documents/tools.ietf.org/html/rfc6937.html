<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

<!-- Mirrored from tools.ietf.org/html/rfc6937 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 06 Mar 2018 23:18:25 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head profile="http://dublincore.org/documents/2008/08/04/dc-html/">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="robots" content="index,follow" />
    <meta name="creator" content="rfcmarkup version 1.126" />
    <link rel="schema.DC" href="http://purl.org/dc/elements/1.1/" />
<meta name="DC.Relation.Replaces" content="draft-mathis-tcpm-proportional-rate-reduction" />
<meta name="DC.Identifier" content="urn:ietf:rfc:6937" />
<meta name="DC.Date.Issued" content="May, 2013" />
<meta name="DC.Creator" content="Cheng, Yuchung" />
<meta name="DC.Creator" content="Dukkipati, Nandita" />
<meta name="DC.Creator" content="Mathis, Matt" />
<meta name="DC.Description.Abstract" content="This document describes an experimental Proportional Rate Reduction
(PRR) algorithm as an alternative to the widely deployed Fast Recovery
and Rate-Halving algorithms. These algorithms determine the amount of
data sent by TCP during loss recovery. PRR minimizes excess window
adjustments, and the actual window size at the end of recovery will be
as close as possible to the ssthresh, as determined by the congestion
control algorithm." />
<meta name="DC.Title" content="Proportional Rate Reduction for TCP" />

    <link rel="icon" href="https://tools.ietf.org/images/rfc.png" type="image/png" />
    <link rel="shortcut icon" href="https://tools.ietf.org/images/rfc.png" type="image/png" />
    <title>RFC 6937 - Proportional Rate Reduction for TCP</title>
    
    
    <style type="text/css">
	@media only screen 
	  and (min-width: 992px)
	  and (max-width: 1199px) {
	    body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 768px)
	  and (max-width: 991px) {
            body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 480px)
	  and (max-width: 767px) {
            body { font-size: 11pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (max-width: 479px) {
            body { font-size: 8pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-device-width : 375px) 
	  and (max-device-width : 667px) {
            body { font-size: 9.5pt; }
            div.content { width: 96ex; margin: 0 1px; }
        }
	@media only screen 
	  and (min-device-width: 1200px) {
            body { font-size: 10pt; margin: 0 4em; }
            div.content { width: 96ex; margin: 0; }
        }
        h1, h2, h3, h4, h5, h6, .h1, .h2, .h3, .h4, .h5, .h6 {
	    font-weight: bold;
            line-height: 0pt;
            display: inline;
            white-space: pre;
            font-family: monospace;
            font-size: 1em;
	    font-weight: bold;
        }
        pre {
            font-size: 1em;
            margin-top: 0px;
            margin-bottom: 0px;
        }
	.pre {
	    white-space: pre;
	    font-family: monospace;
	}
	.header{
	    font-weight: bold;
	}
        .newpage {
            page-break-before: always;
        }
        .invisible {
            text-decoration: none;
            color: white;
        }
        a.selflink {
          color: black;
          text-decoration: none;
        }
        @media print {
            body {
                font-family: monospace;
                font-size: 10.5pt;
            }
            h1, h2, h3, h4, h5, h6 {
                font-size: 1em;
            }
        
            a:link, a:visited {
                color: inherit;
                text-decoration: none;
            }
            .noprint {
                display: none;
            }
        }
	@media screen {
	    .grey, .grey a:link, .grey a:visited {
		color: #777;
	    }
            .docinfo {
                background-color: #EEE;
            }
            .top {
                border-top: 7px solid #EEE;
            }
            .bgwhite  { background-color: white; }
            .bgred    { background-color: #F44; }
            .bggrey   { background-color: #666; }
            .bgbrown  { background-color: #840; }            
            .bgorange { background-color: #FA0; }
            .bgyellow { background-color: #EE0; }
            .bgmagenta{ background-color: #F4F; }
            .bgblue   { background-color: #66F; }
            .bgcyan   { background-color: #4DD; }
            .bggreen  { background-color: #4F4; }

            .legend   { font-size: 90%; }
            .cplate   { font-size: 70%; border: solid grey 1px; }
	}
    </style>
    <!--[if IE]>
    <style>
    body {
       font-size: 13px;
       margin: 10px 10px;
    }
    </style>
    <![endif]-->

    <script type="text/javascript"><!--
    function addHeaderTags() {
	var spans = document.getElementsByTagName("span");
	for (var i=0; i < spans.length; i++) {
	    var elem = spans[i];
	    if (elem) {
		var level = elem.getAttribute("class");
                if (level == "h1" || level == "h2" || level == "h3" || level == "h4" || level == "h5" || level == "h6") {
                    elem.innerHTML = "<"+level+">"+elem.innerHTML+"</"+level+">";		
                }
	    }
	}
    }
    var legend_html = "Colour legend:<br />      <table>         <tr><td>Unknown:</td>                   <td><span class='cplate bgwhite'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft:</td>                     <td><span class='cplate bgred'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Informational:</td>             <td><span class='cplate bgorange'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Experimental:</td>              <td><span class='cplate bgyellow'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Best Common Practice:</td>      <td><span class='cplate bgmagenta'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Proposed Standard:</td>         <td><span class='cplate bgblue'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft Standard (old designation):</td> <td><span class='cplate bgcyan'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Internet Standard:</td>         <td><span class='cplate bggreen'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Historic:</td>                  <td><span class='cplate bggrey'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Obsolete:</td>                  <td><span class='cplate bgbrown'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>     </table>";
    function showElem(id) {
        var elem = document.getElementById(id);
        elem.innerHTML = eval(id+"_html");
        elem.style.visibility='visible';
    }
    function hideElem(id) {
        var elem = document.getElementById(id);
        elem.style.visibility='hidden';        
        elem.innerHTML = "";
    }
    // -->
    </script>
</head>
<body onload="addHeaderTags()">
  <div class="content">
   <div style="height: 13px;">
      <div onmouseover="this.style.cursor='pointer';"
         onclick="showElem('legend');"
         onmouseout="hideElem('legend')"
	 style="height: 6px; position: absolute;"
         class="pre noprint docinfo bgyellow"
         title="Click for colour legend." >                                                                        </div>
      <div id="legend"
           class="docinfo noprint pre legend"
           style="position:absolute; top: 4px; left: 4ex; visibility:hidden; background-color: white; padding: 4px 9px 5px 7px; border: solid #345 1px; "
           onmouseover="showElem('legend');"
           onmouseout="hideElem('legend');">
      </div>
   </div>
<span class="pre noprint docinfo top">[<a href="index.html" title="Document search and retrieval page">Docs</a>] [<a href="https://tools.ietf.org/rfc/rfc6937.txt" title="Plaintext version of this document">txt</a>|<a href="https://tools.ietf.org/pdf/rfc6937" title="PDF version of this document">pdf</a>] [<a href="https://tools.ietf.org/html/draft-ietf-tcpm-proportional-rate-reduction" title="draft-ietf-tcpm-proportional-rate-reduction">draft-ietf-tcpm...</a>] [<a href='https://datatracker.ietf.org/doc/rfc6937' title='IESG Datatracker information for this document'>Tracker</a>] [<a href="https://tools.ietf.org/rfcdiff?difftype=--hwdiff&amp;url2=rfc6937" title="Inline diff (wdiff)">Diff1</a>] [<a href="https://tools.ietf.org/rfcdiff?url2=rfc6937" title="Side-by-side diff">Diff2</a>]         </span><br />
<span class="pre noprint docinfo">                                                                        </span><br />
<span class="pre noprint docinfo">                                                            EXPERIMENTAL</span><br />
<span class="pre noprint docinfo">                                                                        </span><br />
<pre>
Internet Engineering Task Force (IETF)                         M. Mathis
Request for Comments: 6937                                  N. Dukkipati
Category: Experimental                                          Y. Cheng
ISSN: 2070-1721                                             Google, Inc.
                                                                May 2013


                  <span class="h1">Proportional Rate Reduction for TCP</span>

Abstract

   This document describes an experimental Proportional Rate Reduction
   (PRR) algorithm as an alternative to the widely deployed Fast
   Recovery and Rate-Halving algorithms.  These algorithms determine the
   amount of data sent by TCP during loss recovery.  PRR minimizes
   excess window adjustments, and the actual window size at the end of
   recovery will be as close as possible to the ssthresh, as determined
   by the congestion control algorithm.

Status of This Memo

   This document is not an Internet Standards Track specification; it is
   published for examination, experimental implementation, and
   evaluation.

   This document defines an Experimental Protocol for the Internet
   community.  This document is a product of the Internet Engineering
   Task Force (IETF).  It represents the consensus of the IETF
   community.  It has received public review and has been approved for
   publication by the Internet Engineering Steering Group (IESG).  Not
   all documents approved by the IESG are a candidate for any level of
   Internet Standard; see <a href="rfc5741.html#section-2">Section&nbsp;2 of RFC 5741</a>.

   Information about the current status of this document, any errata,
   and how to provide feedback on it may be obtained at
   <a href="http://www.rfc-editor.org/info/rfc6937">http://www.rfc-editor.org/info/rfc6937</a>.















<span class="grey">Mathis, et al.                Experimental                      [Page 1]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-2" id="page-2" href="#page-2" class="invisible"> </a>
<span class="grey"><a href="rfc6937.html">RFC 6937</a>               Proportional Rate Reduction              May 2013</span>


Copyright Notice

   Copyright (c) 2013 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to <a href="https://tools.ietf.org/html/bcp78">BCP 78</a> and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (<a href="http://trustee.ietf.org/license-info">http://trustee.ietf.org/license-info</a>) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.

Table of Contents

   <a href="#section-1">1</a>. Introduction ....................................................<a href="#page-2">2</a>
   <a href="#section-2">2</a>. Definitions .....................................................<a href="#page-5">5</a>
   <a href="#section-3">3</a>. Algorithms ......................................................<a href="#page-6">6</a>
      <a href="#section-3.1">3.1</a>. Examples ...................................................<a href="#page-6">6</a>
   <a href="#section-4">4</a>. Properties ......................................................<a href="#page-9">9</a>
   <a href="#section-5">5</a>. Measurements ...................................................<a href="#page-11">11</a>
   <a href="#section-6">6</a>. Conclusion and Recommendations .................................<a href="#page-12">12</a>
   <a href="#section-7">7</a>. Acknowledgements ...............................................<a href="#page-13">13</a>
   <a href="#section-8">8</a>. Security Considerations ........................................<a href="#page-13">13</a>
   <a href="#section-9">9</a>. References .....................................................<a href="#page-13">13</a>
      <a href="#section-9.1">9.1</a>. Normative References ......................................<a href="#page-13">13</a>
      <a href="#section-9.2">9.2</a>. Informative References ....................................<a href="#page-14">14</a>
   <a href="#appendix-A">Appendix A</a>. Strong Packet Conservation Bound ......................<a href="#page-15">15</a>

<span class="h2"><a class="selflink" name="section-1" href="#section-1">1</a>.  Introduction</span>

   This document describes an experimental algorithm, PRR, to improve
   the accuracy of the amount of data sent by TCP during loss recovery.

   Standard congestion control [<a href="rfc5681.html" title="&quot;TCP Congestion Control&quot;">RFC5681</a>] requires that TCP (and other
   protocols) reduce their congestion window (cwnd) in response to
   losses.  Fast Recovery, described in the same document, is the
   reference algorithm for making this adjustment.  Its stated goal is
   to recover TCP's self clock by relying on returning ACKs during
   recovery to clock more data into the network.  Fast Recovery
   typically adjusts the window by waiting for one half round-trip time
   (RTT) of ACKs to pass before sending any data.  It is fragile because
   it cannot compensate for the implicit window reduction caused by the
   losses themselves.





<span class="grey">Mathis, et al.                Experimental                      [Page 2]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-3" id="page-3" href="#page-3" class="invisible"> </a>
<span class="grey"><a href="rfc6937.html">RFC 6937</a>               Proportional Rate Reduction              May 2013</span>


   <a href="rfc6675.html">RFC 6675</a> [<a href="rfc6675.html" title="&quot;A Conservative Loss Recovery Algorithm Based on Selective Acknowledgment (SACK) for TCP&quot;">RFC6675</a>] makes Fast Recovery with Selective Acknowledgement
   (SACK) [<a href="rfc2018.html" title="&quot;TCP Selective Acknowledgment Options&quot;">RFC2018</a>] more accurate by computing "pipe", a sender side
   estimate of the number of bytes still outstanding in the network.
   With <a href="rfc6675.html">RFC 6675</a>, Fast Recovery is implemented by sending data as
   necessary on each ACK to prevent pipe from falling below slow-start
   threshold (ssthresh), the window size as determined by the congestion
   control algorithm.  This protects Fast Recovery from timeouts in many
   cases where there are heavy losses, although not if the entire second
   half of the window of data or ACKs are lost.  However, a single ACK
   carrying a SACK option that implies a large quantity of missing data
   can cause a step discontinuity in the pipe estimator, which can cause
   Fast Retransmit to send a burst of data.

   The Rate-Halving algorithm sends data on alternate ACKs during
   recovery, such that after 1 RTT the window has been halved.  Rate-
   Halving is implemented in Linux after only being informally published
   [<a href="#ref-RHweb" title="&quot;TCP Rate-Halving with Bounding Parameters&quot;">RHweb</a>], including an uncompleted document [<a href="#ref-RHID" title="&quot;The Rate-Halving Algorithm for TCP Congestion Control&quot;">RHID</a>].  Rate-Halving also
   does not adequately compensate for the implicit window reduction
   caused by the losses and assumes a net 50% window reduction, which
   was completely standard at the time it was written but not
   appropriate for modern congestion control algorithms, such as CUBIC
   [<a href="#ref-CUBIC" title="&quot;CUBIC: A new TCP-friendly high- speed TCP variant&quot;">CUBIC</a>], which reduce the window by less than 50%.  As a consequence,
   Rate-Halving often allows the window to fall further than necessary,
   reducing performance and increasing the risk of timeouts if there are
   additional losses.

   PRR avoids these excess window adjustments such that at the end of
   recovery the actual window size will be as close as possible to
   ssthresh, the window size as determined by the congestion control
   algorithm.  It is patterned after Rate-Halving, but using the
   fraction that is appropriate for the target window chosen by the
   congestion control algorithm.  During PRR, one of two additional
   Reduction Bound algorithms limits the total window reduction due to
   all mechanisms, including transient application stalls and the losses
   themselves.

   We describe two slightly different Reduction Bound algorithms:
   Conservative Reduction Bound (CRB), which is strictly packet
   conserving; and a Slow Start Reduction Bound (SSRB), which is more
   aggressive than CRB by, at most, 1 segment per ACK.  PRR-CRB meets
   the Strong Packet Conservation Bound described in <a href="#appendix-A">Appendix A</a>;
   however, in real networks it does not perform as well as the
   algorithms described in <a href="rfc6675.html">RFC 6675</a>, which prove to be more aggressive
   in a significant number of cases.  SSRB offers a compromise by
   allowing TCP to send 1 additional segment per ACK relative to CRB in
   some situations.  Although SSRB is less aggressive than <a href="rfc6675.html">RFC 6675</a>





<span class="grey">Mathis, et al.                Experimental                      [Page 3]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-4" id="page-4" href="#page-4" class="invisible"> </a>
<span class="grey"><a href="rfc6937.html">RFC 6937</a>               Proportional Rate Reduction              May 2013</span>


   (transmitting fewer segments or taking more time to transmit them),
   it outperforms it, due to the lower probability of additional losses
   during recovery.

   The Strong Packet Conservation Bound on which PRR and both Reduction
   Bounds are based is patterned after Van Jacobson's packet
   conservation principle: segments delivered to the receiver are used
   as the clock to trigger sending the same number of segments back into
   the network.  As much as possible, PRR and the Reduction Bound
   algorithms rely on this self clock process, and are only slightly
   affected by the accuracy of other estimators, such as pipe [<a href="rfc6675.html" title="&quot;A Conservative Loss Recovery Algorithm Based on Selective Acknowledgment (SACK) for TCP&quot;">RFC6675</a>]
   and cwnd.  This is what gives the algorithms their precision in the
   presence of events that cause uncertainty in other estimators.

   The original definition of the packet conservation principle
   [<a href="#ref-Jacobson88" title="&quot;Congestion Avoidance and Control&quot;">Jacobson88</a>]  treated packets that are presumed to be lost (e.g.,
   marked as candidates for retransmission) as having left the network.
   This idea is reflected in the pipe estimator defined in <a href="rfc6675.html">RFC 6675</a> and
   used here, but it is distinct from the Strong Packet Conservation
   Bound as described in <a href="#appendix-A">Appendix A</a>, which is defined solely on the
   basis of data arriving at the receiver.

   We evaluated these and other algorithms in a large scale measurement
   study presented in a companion paper [<a href="#ref-IMC11" title="&quot;Proportional Rate Reduction for TCP&quot;">IMC11</a>] and summarized in
   <a href="#section-5">Section 5</a>.  This measurement study was based on <a href="rfc3517.html">RFC 3517</a> [<a href="rfc3517.html" title="&quot;A Conservative Selective Acknowledgment (SACK)-based Loss Recovery Algorithm for TCP&quot;">RFC3517</a>],
   which has since been superseded by <a href="rfc6675.html">RFC 6675</a>.  Since there are slight
   differences between the two specifications, and we were meticulous
   about our implementation of <a href="rfc3517.html">RFC 3517</a>, we are not comfortable
   unconditionally asserting that our measurement results apply to <a href="rfc6675.html">RFC</a>
   <a href="rfc6675.html">6675</a>, although we believe this to be the case.  We have instead
   chosen to be pedantic about describing measurement results relative
   to <a href="rfc3517.html">RFC 3517</a>, on which they were actually based.  General discussions
   of algorithms and their properties have been updated to refer to <a href="rfc6675.html">RFC</a>
   <a href="rfc6675.html">6675</a>.

   We found that for authentic network traffic, PRR-SSRB outperforms
   both <a href="rfc3517.html">RFC 3517</a> and Linux Rate-Halving even though it is less
   aggressive than <a href="rfc3517.html">RFC 3517</a>.  We believe that these results apply to <a href="rfc6675.html">RFC</a>
   <a href="rfc6675.html">6675</a> as well.

   The algorithms are described as modifications to <a href="rfc5681.html">RFC 5681</a> [<a href="rfc5681.html" title="&quot;TCP Congestion Control&quot;">RFC5681</a>],
   "TCP Congestion Control", using concepts drawn from the pipe
   algorithm [<a href="rfc6675.html" title="&quot;A Conservative Loss Recovery Algorithm Based on Selective Acknowledgment (SACK) for TCP&quot;">RFC6675</a>].  They are most accurate and more easily
   implemented with SACK [<a href="rfc2018.html" title="&quot;TCP Selective Acknowledgment Options&quot;">RFC2018</a>], but do not require SACK.







<span class="grey">Mathis, et al.                Experimental                      [Page 4]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-5" id="page-5" href="#page-5" class="invisible"> </a>
<span class="grey"><a href="rfc6937.html">RFC 6937</a>               Proportional Rate Reduction              May 2013</span>


<span class="h2"><a class="selflink" name="section-2" href="#section-2">2</a>.  Definitions</span>

   The following terms, parameters, and state variables are used as they
   are defined in earlier documents:

   <a href="rfc793.html">RFC 793</a>: snd.una (send unacknowledged)

   <a href="rfc5681.html">RFC 5681</a>: duplicate ACK, FlightSize, Sender Maximum Segment Size
      (SMSS)

   <a href="rfc6675.html">RFC 6675</a>: covered (as in "covered sequence numbers")

   Voluntary window reductions: choosing not to send data in response to
   some ACKs, for the purpose of reducing the sending window size and
   data rate

   We define some additional variables:

   SACKd: The total number of bytes that the scoreboard indicates have
      been delivered to the receiver.  This can be computed by scanning
      the scoreboard and counting the total number of bytes covered by
      all SACK blocks.  If SACK is not in use, SACKd is not defined.

   DeliveredData: The total number of bytes that the current ACK
      indicates have been delivered to the receiver.  When not in
      recovery, DeliveredData is the change in snd.una.  With SACK,
      DeliveredData can be computed precisely as the change in snd.una,
      plus the (signed) change in SACKd.  In recovery without SACK,
      DeliveredData is estimated to be 1 SMSS on duplicate
      acknowledgements, and on a subsequent partial or full ACK,
      DeliveredData is estimated to be the change in snd.una, minus 1
      SMSS for each preceding duplicate ACK.

   Note that DeliveredData is robust; for TCP using SACK, DeliveredData
   can be precisely computed anywhere in the network just by inspecting
   the returning ACKs.  The consequence of missing ACKs is that later
   ACKs will show a larger DeliveredData.  Furthermore, for any TCP
   (with or without SACK), the sum of DeliveredData must agree with the
   forward progress over the same time interval.

   We introduce a local variable "sndcnt", which indicates exactly how
   many bytes should be sent in response to each ACK.  Note that the
   decision of which data to send (e.g., retransmit missing data or send
   more new data) is out of scope for this document.







<span class="grey">Mathis, et al.                Experimental                      [Page 5]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-6" id="page-6" href="#page-6" class="invisible"> </a>
<span class="grey"><a href="rfc6937.html">RFC 6937</a>               Proportional Rate Reduction              May 2013</span>


<span class="h2"><a class="selflink" name="section-3" href="#section-3">3</a>.  Algorithms</span>

   At the beginning of recovery, initialize PRR state.  This assumes a
   modern congestion control algorithm, CongCtrlAlg(), that might set
   ssthresh to something other than FlightSize/2:

      ssthresh = CongCtrlAlg()  // Target cwnd after recovery
      prr_delivered = 0         // Total bytes delivered during recovery
      prr_out = 0               // Total bytes sent during recovery
      RecoverFS = snd.nxt-snd.una // FlightSize at the start of recovery

   On every ACK during recovery compute:

      DeliveredData = change_in(snd.una) + change_in(SACKd)
      prr_delivered += DeliveredData
      pipe = (<a href="rfc6675.html">RFC 6675</a> pipe algorithm)
      if (pipe &gt; ssthresh) {
         // Proportional Rate Reduction
         sndcnt = CEIL(prr_delivered * ssthresh / RecoverFS) - prr_out
      } else {
         // Two versions of the Reduction Bound
         if (conservative) {    // PRR-CRB
           limit = prr_delivered - prr_out
         } else {               // PRR-SSRB
           limit = MAX(prr_delivered - prr_out, DeliveredData) + MSS
         }
         // Attempt to catch up, as permitted by limit
         sndcnt = MIN(ssthresh - pipe, limit)
      }

   On any data transmission or retransmission:

      prr_out += (data sent) // strictly less than or equal to sndcnt

<span class="h3"><a class="selflink" name="section-3.1" href="#section-3.1">3.1</a>.  Examples</span>

   We illustrate these algorithms by showing their different behaviors
   for two scenarios: TCP experiencing either a single loss or a burst
   of 15 consecutive losses.  In all cases we assume bulk data (no
   application pauses), standard Additive Increase Multiplicative
   Decrease (AIMD) congestion control, and cwnd = FlightSize = pipe = 20
   segments, so ssthresh will be set to 10 at the beginning of recovery.
   We also assume standard Fast Retransmit and Limited Transmit
   [<a href="rfc3042.html" title="&quot;Enhancing TCP's Loss Recovery Using Limited Transmit&quot;">RFC3042</a>], so TCP will send 2 new segments followed by 1 retransmit
   in response to the first 3 duplicate ACKs following the losses.






<span class="grey">Mathis, et al.                Experimental                      [Page 6]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-7" id="page-7" href="#page-7" class="invisible"> </a>
<span class="grey"><a href="rfc6937.html">RFC 6937</a>               Proportional Rate Reduction              May 2013</span>


   Each of the diagrams below shows the per ACK response to the first
   round trip for the various recovery algorithms when the zeroth
   segment is lost.  The top line indicates the transmitted segment
   number triggering the ACKs, with an X for the lost segment.  "cwnd"
   and "pipe" indicate the values of these algorithms after processing
   each returning ACK.  "Sent" indicates how much 'N'ew or
   'R'etransmitted data would be sent.  Note that the algorithms for
   deciding which data to send are out of scope of this document.

   When there is a single loss, PRR with either of the Reduction Bound
   algorithms has the same behavior.  We show "RB", a flag indicating
   which Reduction Bound subexpression ultimately determined the value
   of sndcnt.  When there are minimal losses, "limit" (both algorithms)
   will always be larger than ssthresh - pipe, so the sndcnt will be
   ssthresh - pipe, indicated by "s" in the "RB" row.

   <a href="rfc6675.html">RFC 6675</a>
   ack#   X  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19
   cwnd:    20 20 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11
   pipe:    19 19 18 18 17 16 15 14 13 12 11 10 10 10 10 10 10 10 10
   sent:     N  N  R                          N  N  N  N  N  N  N  N


   Rate-Halving (Linux)
   ack#   X  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19
   cwnd:    20 20 19 18 18 17 17 16 16 15 15 14 14 13 13 12 12 11 11
   pipe:    19 19 18 18 17 17 16 16 15 15 14 14 13 13 12 12 11 11 10
   sent:     N  N  R     N     N     N     N     N     N     N     N


   PRR
   ack#   X  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19
   pipe:    19 19 18 18 18 17 17 16 16 15 15 14 14 13 13 12 12 11 10
   sent:     N  N  R     N     N     N     N     N     N        N  N
   RB:                                                          s  s

       Cwnd is not shown because PRR does not use it.

   Key for RB
   s: sndcnt = ssthresh - pipe                 // from ssthresh
   b: sndcnt = prr_delivered - prr_out + SMSS  // from banked
   d: sndcnt = DeliveredData + SMSS            // from DeliveredData
   (Sometimes, more than one applies.)

   Note that all 3 algorithms send the same total amount of data.
   <a href="rfc6675.html">RFC 6675</a> experiences a "half window of silence", while the
   Rate-Halving and PRR spread the voluntary window reduction across an
   entire RTT.



<span class="grey">Mathis, et al.                Experimental                      [Page 7]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-8" id="page-8" href="#page-8" class="invisible"> </a>
<span class="grey"><a href="rfc6937.html">RFC 6937</a>               Proportional Rate Reduction              May 2013</span>


   Next, we consider the same initial conditions when the first 15
   packets (0-14) are lost.  During the remainder of the lossy RTT, only
   5 ACKs are returned to the sender.  We examine each of these
   algorithms in succession.

   <a href="rfc6675.html">RFC 6675</a>
   ack#   X  X  X  X  X  X  X  X  X  X  X  X  X  X  X 15 16 17 18 19
   cwnd:                                              20 20 11 11 11
   pipe:                                              19 19  4 10 10
   sent:                                               N  N 7R  R  R

   Rate-Halving (Linux)
   ack#   X  X  X  X  X  X  X  X  X  X  X  X  X  X  X 15 16 17 18 19
   cwnd:                                              20 20  5  5  5
   pipe:                                              19 19  4  4  4
   sent:                                               N  N  R  R  R

   PRR-CRB
   ack#   X  X  X  X  X  X  X  X  X  X  X  X  X  X  X 15 16 17 18 19
   pipe:                                              19 19  4  4  4
   sent:                                               N  N  R  R  R
   RB:                                                       b  b  b

   PRR-SSRB
   ack#   X  X  X  X  X  X  X  X  X  X  X  X  X  X  X 15 16 17 18 19
   pipe:                                              19 19  4  5  6
   sent:                                               N  N 2R 2R 2R
   RB:                                                      bd  d  d

   In this specific situation, <a href="rfc6675.html">RFC 6675</a> is more aggressive because once
   Fast Retransmit is triggered (on the ACK for segment 17), TCP
   immediately retransmits sufficient data to bring pipe up to cwnd.
   Our measurement data (see <a href="#section-5">Section 5</a>) indicates that <a href="rfc6675.html">RFC 6675</a>
   significantly outperforms Rate-Halving, PRR-CRB, and some other
   similarly conservative algorithms that we tested, showing that it is
   significantly common for the actual losses to exceed the window
   reduction determined by the congestion control algorithm.

   The Linux implementation of Rate-Halving includes an early version of
   the Conservative Reduction Bound [<a href="#ref-RHweb" title="&quot;TCP Rate-Halving with Bounding Parameters&quot;">RHweb</a>].  In this situation, the 5
   ACKs trigger exactly 1 transmission each (2 new data, 3 old data),
   and cwnd is set to 5.  At a window size of 5, it takes 3 round trips
   to retransmit all 15 lost segments.  Rate-Halving does not raise the
   window at all during recovery, so when recovery finally completes,
   TCP will slow start cwnd from 5 up to 10.  In this example, TCP
   operates at half of the window chosen by the congestion control for
   more than 3 RTTs, increasing the elapsed time and exposing it to
   timeouts in the event that there are additional losses.



<span class="grey">Mathis, et al.                Experimental                      [Page 8]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-9" id="page-9" href="#page-9" class="invisible"> </a>
<span class="grey"><a href="rfc6937.html">RFC 6937</a>               Proportional Rate Reduction              May 2013</span>


   PRR-CRB implements a Conservative Reduction Bound.  Since the total
   losses bring pipe below ssthresh, data is sent such that the total
   data transmitted, prr_out, follows the total data delivered to the
   receiver as reported by returning ACKs.  Transmission is controlled
   by the sending limit, which is set to prr_delivered - prr_out.  This
   is indicated by the RB:b tagging in the figure.  In this case,
   PRR-CRB is exposed to exactly the same problems as Rate-Halving; the
   excess window reduction causes it to take excessively long to recover
   the losses and exposes it to additional timeouts.

   PRR-SSRB increases the window by exactly 1 segment per ACK until pipe
   rises to ssthresh during recovery.  This is accomplished by setting
   limit to one greater than the data reported to have been delivered to
   the receiver on this ACK, implementing slow start during recovery,
   and indicated by RB:d tagging in the figure.  Although increasing the
   window during recovery seems to be ill advised, it is important to
   remember that this is actually less aggressive than permitted by <a href="rfc5681.html">RFC</a>
   <a href="rfc5681.html">5681</a>, which sends the same quantity of additional data as a single
   burst in response to the ACK that triggered Fast Retransmit.

   For less extreme events, where the total losses are smaller than the
   difference between FlightSize and ssthresh, PRR-CRB and PRR-SSRB have
   identical behaviors.

<span class="h2"><a class="selflink" name="section-4" href="#section-4">4</a>.  Properties</span>

   The following properties are common to both PRR-CRB and PRR-SSRB,
   except as noted:

   PRR maintains TCP's ACK clocking across most recovery events,
   including burst losses.  <a href="rfc6675.html">RFC 6675</a> can send large unclocked bursts
   following burst losses.

   Normally, PRR will spread voluntary window reductions out evenly
   across a full RTT.  This has the potential to generally reduce the
   burstiness of Internet traffic, and could be considered to be a type
   of soft pacing.  Hypothetically, any pacing increases the probability
   that different flows are interleaved, reducing the opportunity for
   ACK compression and other phenomena that increase traffic burstiness.
   However, these effects have not been quantified.

   If there are minimal losses, PRR will converge to exactly the target
   window chosen by the congestion control algorithm.  Note that as TCP
   approaches the end of recovery, prr_delivered will approach RecoverFS
   and sndcnt will be computed such that prr_out approaches ssthresh.






<span class="grey">Mathis, et al.                Experimental                      [Page 9]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-10" id="page-10" href="#page-10" class="invisible"> </a>
<span class="grey"><a href="rfc6937.html">RFC 6937</a>               Proportional Rate Reduction              May 2013</span>


   Implicit window reductions, due to multiple isolated losses during
   recovery, cause later voluntary reductions to be skipped.  For small
   numbers of losses, the window size ends at exactly the window chosen
   by the congestion control algorithm.

   For burst losses, earlier voluntary window reductions can be undone
   by sending extra segments in response to ACKs arriving later during
   recovery.  Note that as long as some voluntary window reductions are
   not undone, the final value for pipe will be the same as ssthresh,
   the target cwnd value chosen by the congestion control algorithm.

   PRR with either Reduction Bound improves the situation when there are
   application stalls, e.g., when the sending application does not queue
   data for transmission quickly enough or the receiver stops advancing
   rwnd (receiver window).  When there is an application stall early
   during recovery, prr_out will fall behind the sum of the
   transmissions permitted by sndcnt.  The missed opportunities to send
   due to stalls are treated like banked voluntary window reductions;
   specifically, they cause prr_delivered - prr_out to be significantly
   positive.  If the application catches up while TCP is still in
   recovery, TCP will send a partial window burst to catch up to exactly
   where it would have been had the application never stalled.  Although
   this burst might be viewed as being hard on the network, this is
   exactly what happens every time there is a partial RTT application
   stall while not in recovery.  We have made the partial RTT stall
   behavior uniform in all states.  Changing this behavior is out of
   scope for this document.

   PRR with Reduction Bound is less sensitive to errors in the pipe
   estimator.  While in recovery, pipe is intrinsically an estimator,
   using incomplete information to estimate if un-SACKed segments are
   actually lost or merely out of order in the network.  Under some
   conditions, pipe can have significant errors; for example, pipe is
   underestimated when a burst of reordered data is prematurely assumed
   to be lost and marked for retransmission.  If the transmissions are
   regulated directly by pipe as they are with <a href="rfc6675.html">RFC 6675</a>, a step
   discontinuity in the pipe estimator causes a burst of data, which
   cannot be retracted once the pipe estimator is corrected a few ACKs
   later.  For PRR, pipe merely determines which algorithm, PRR or the
   Reduction Bound, is used to compute sndcnt from DeliveredData.  While
   pipe is underestimated, the algorithms are different by at most 1
   segment per ACK.  Once pipe is updated, they converge to the same
   final window at the end of recovery.

   Under all conditions and sequences of events during recovery, PRR-CRB
   strictly bounds the data transmitted to be equal to or less than the
   amount of data delivered to the receiver.  We claim that this Strong
   Packet Conservation Bound is the most aggressive algorithm that does



<span class="grey">Mathis, et al.                Experimental                     [Page 10]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-11" id="page-11" href="#page-11" class="invisible"> </a>
<span class="grey"><a href="rfc6937.html">RFC 6937</a>               Proportional Rate Reduction              May 2013</span>


   not lead to additional forced losses in some environments.  It has
   the property that if there is a standing queue at a bottleneck with
   no cross traffic, the queue will maintain exactly constant length for
   the duration of the recovery, except for +1/-1 fluctuation due to
   differences in packet arrival and exit times.  See <a href="#appendix-A">Appendix A</a> for a
   detailed discussion of this property.

   Although the Strong Packet Conservation Bound is very appealing for a
   number of reasons, our measurements summarized in <a href="#section-5">Section 5</a>
   demonstrate that it is less aggressive and does not perform as well
   as <a href="rfc6675.html">RFC 6675</a>, which permits bursts of data when there are bursts of
   losses.  PRR-SSRB is a compromise that permits TCP to send 1 extra
   segment per ACK as compared to the Packet Conserving Bound.  From the
   perspective of a strict Packet Conserving Bound, PRR-SSRB does indeed
   open the window during recovery; however, it is significantly less
   aggressive than <a href="rfc6675.html">RFC 6675</a> in the presence of burst losses.

<span class="h2"><a class="selflink" name="section-5" href="#section-5">5</a>.  Measurements</span>

   In a companion IMC11 paper [<a href="#ref-IMC11" title="&quot;Proportional Rate Reduction for TCP&quot;">IMC11</a>], we describe some measurements
   comparing the various strategies for reducing the window during
   recovery.  The experiments were performed on servers carrying Google
   production traffic and are briefly summarized here.

   The various window reduction algorithms and extensive instrumentation
   were all implemented in Linux 2.6.  We used the uniform set of
   algorithms present in the base Linux implementation, including CUBIC
   [<a href="#ref-CUBIC" title="&quot;CUBIC: A new TCP-friendly high- speed TCP variant&quot;">CUBIC</a>], Limited Transmit [<a href="rfc3042.html" title="&quot;Enhancing TCP's Loss Recovery Using Limited Transmit&quot;">RFC3042</a>], threshold transmit (Section 3.1
   in [<a href="#ref-FACK" title="&quot;Forward Acknowledgment: Refining TCP Congestion Control&quot;">FACK</a>]) (this algorithm was not present in <a href="rfc3517.html">RFC 3517</a>, but a similar
   algorithm has been added to <a href="rfc6675.html">RFC 6675</a>), and lost retransmission
   detection algorithms.  We confirmed that the behaviors of Rate-
   Halving (the Linux default), <a href="rfc3517.html">RFC 3517</a>, and PRR were authentic to
   their respective specifications and that performance and features
   were comparable to the kernels in production use.  All of the
   different window reduction algorithms were all present in a common
   kernel and could be selected with a sysctl, such that we had an
   absolutely uniform baseline for comparing them.

   Our experiments included an additional algorithm, PRR with an
   unlimited bound (PRR-UB), which sends ssthresh-pipe bursts when pipe
   falls below ssthresh.  This behavior parallels <a href="rfc3517.html">RFC 3517</a>.

   An important detail of this configuration is that CUBIC only reduces
   the window by 30%, as opposed to the 50% reduction used by
   traditional congestion control algorithms.  This accentuates the
   tendency for <a href="rfc3517.html">RFC 3517</a> and PRR-UB to send a burst at the point when
   Fast Retransmit gets triggered because pipe is likely to already be
   below ssthresh.  Precisely this condition was observed for 32% of the



<span class="grey">Mathis, et al.                Experimental                     [Page 11]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-12" id="page-12" href="#page-12" class="invisible"> </a>
<span class="grey"><a href="rfc6937.html">RFC 6937</a>               Proportional Rate Reduction              May 2013</span>


   recovery events: pipe fell below ssthresh before Fast Retransmit was
   triggered, thus the various PRR algorithms started in the Reduction
   Bound phase, and <a href="rfc3517.html">RFC 3517</a> sent bursts of segments with the Fast
   Retransmit.

   In the companion paper, we observe that PRR-SSRB spends the least
   time in recovery of all the algorithms tested, largely because it
   experiences fewer timeouts once it is already in recovery.

   <a href="rfc3517.html">RFC 3517</a> experiences 29% more detected lost retransmissions and 2.6%
   more timeouts (presumably due to undetected lost retransmissions)
   than PRR-SSRB.  These results are representative of PRR-UB and other
   algorithms that send bursts when pipe falls below ssthresh.

   Rate-Halving experiences 5% more timeouts and significantly smaller
   final cwnd values at the end of recovery.  The smaller cwnd sometimes
   causes the recovery itself to take extra round trips.  These results
   are representative of PRR-CRB and other algorithms that implement
   strict packet conservation during recovery.

<span class="h2"><a class="selflink" name="section-6" href="#section-6">6</a>.  Conclusion and Recommendations</span>

   Although the Strong Packet Conservation Bound used in PRR-CRB is very
   appealing for a number of reasons, our measurements show that it is
   less aggressive and does not perform as well as <a href="rfc3517.html">RFC 3517</a> (and by
   implication <a href="rfc6675.html">RFC 6675</a>), which permits bursts of data when there are
   bursts of losses.  <a href="rfc3517.html">RFC 3517</a> and <a href="rfc6675.html">RFC 6675</a> are conservative in the
   original sense of Van Jacobson's packet conservation principle, which
   included the assumption that presumed lost segments have indeed left
   the network.  PRR-CRB makes no such assumption, following instead a
   Strong Packet Conservation Bound in which only packets that have
   actually arrived at the receiver are considered to have left the
   network.  PRR-SSRB is a compromise that permits TCP to send 1 extra
   segment per ACK relative to the Strong Packet Conservation Bound, to
   partially compensate for excess losses.

   From the perspective of the Strong Packet Conservation Bound,
   PRR-SSRB does indeed open the window during recovery; however, it is
   significantly less aggressive than <a href="rfc3517.html">RFC 3517</a> (and <a href="rfc6675.html">RFC 6675</a>) in the
   presence of burst losses.  Even so, it often outperforms <a href="rfc3517.html">RFC 3517</a>
   (and presumably <a href="rfc6675.html">RFC 6675</a>) because it avoids some of the self-
   inflicted losses caused by bursts.

   At this time, we see no reason not to test and deploy PRR-SSRB on a
   large scale.  Implementers worried about any potential impact of
   raising the window during recovery may want to optionally support
   PRR-CRB (which is actually simpler to implement) for comparison




<span class="grey">Mathis, et al.                Experimental                     [Page 12]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-13" id="page-13" href="#page-13" class="invisible"> </a>
<span class="grey"><a href="rfc6937.html">RFC 6937</a>               Proportional Rate Reduction              May 2013</span>


   studies.  Furthermore, there is one minor detail of PRR that can be
   improved by replacing pipe by total_pipe, as defined by Laminar TCP
   [<a href="#ref-Laminar" title="&quot;Laminar TCP and the case for refactoring TCP congestion control&quot;">Laminar</a>].

   One final comment about terminology: we expect that common usage will
   drop "Slow Start Reduction Bound" from the algorithm name.  This
   document needed to be pedantic about having distinct names for PRR
   and every variant of the Reduction Bound.  However, we do not
   anticipate any future exploration of the alternative Reduction
   Bounds.

<span class="h2"><a class="selflink" name="section-7" href="#section-7">7</a>.  Acknowledgements</span>

   This document is based in part on previous incomplete work by Matt
   Mathis, Jeff Semke, and Jamshid Mahdavi [<a href="#ref-RHID" title="&quot;The Rate-Halving Algorithm for TCP Congestion Control&quot;">RHID</a>] and influenced by
   several discussions with John Heffner.

   Monia Ghobadi and Sivasankar Radhakrishnan helped analyze the
   experiments.

   Ilpo Jarvinen reviewed the code.

   Mark Allman improved the document through his insightful review.

<span class="h2"><a class="selflink" name="section-8" href="#section-8">8</a>.  Security Considerations</span>

   PRR does not change the risk profile for TCP.

   Implementers that change PRR from counting bytes to segments have to
   be cautious about the effects of ACK splitting attacks [<a href="#ref-Savage99" title="&quot;TCP congestion control with a misbehaving receiver&quot;">Savage99</a>],
   where the receiver acknowledges partial segments for the purpose of
   confusing the sender's congestion accounting.

<span class="h2"><a class="selflink" name="section-9" href="#section-9">9</a>.  References</span>

<span class="h3"><a class="selflink" name="section-9.1" href="#section-9.1">9.1</a>.  Normative References</span>

   [<a name="ref-RFC0793" id="ref-RFC0793">RFC0793</a>]    Postel, J., "Transmission Control Protocol", STD 7,
                <a href="rfc793.html">RFC 793</a>, September 1981.

   [<a name="ref-RFC2018" id="ref-RFC2018">RFC2018</a>]    Mathis, M., Mahdavi, J., Floyd, S., and A. Romanow, "TCP
                Selective Acknowledgment Options", <a href="rfc2018.html">RFC 2018</a>, October
                1996.

   [<a name="ref-RFC5681" id="ref-RFC5681">RFC5681</a>]    Allman, M., Paxson, V., and E. Blanton, "TCP Congestion
                Control", <a href="rfc5681.html">RFC 5681</a>, September 2009.





<span class="grey">Mathis, et al.                Experimental                     [Page 13]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-14" id="page-14" href="#page-14" class="invisible"> </a>
<span class="grey"><a href="rfc6937.html">RFC 6937</a>               Proportional Rate Reduction              May 2013</span>


   [<a name="ref-RFC6675" id="ref-RFC6675">RFC6675</a>]    Blanton, E., Allman, M., Wang, L., Jarvinen, I., Kojo,
                M., and Y. Nishida, "A Conservative Loss Recovery
                Algorithm Based on Selective Acknowledgment (SACK) for
                TCP", <a href="rfc6675.html">RFC 6675</a>, August 2012.

<span class="h3"><a class="selflink" name="section-9.2" href="#section-9.2">9.2</a>.  Informative References</span>

   [<a name="ref-RFC3042" id="ref-RFC3042">RFC3042</a>]    Allman, M., Balakrishnan, H., and S. Floyd, "Enhancing
                TCP's Loss Recovery Using Limited Transmit", <a href="rfc3042.html">RFC 3042</a>,
                January 2001.

   [<a name="ref-RFC3517" id="ref-RFC3517">RFC3517</a>]    Blanton, E., Allman, M., Fall, K., and L. Wang, "A
                Conservative Selective Acknowledgment (SACK)-based Loss
                Recovery Algorithm for TCP", <a href="rfc3517.html">RFC 3517</a>, April 2003.

   [<a name="ref-IMC11" id="ref-IMC11">IMC11</a>]      Dukkipati, N., Mathis, M., Cheng, Y., and M. Ghobadi,
                "Proportional Rate Reduction for TCP", Proceedings of
                the 11th ACM SIGCOMM Conference on Internet Measurement
                2011, Berlin, Germany, November 2011.

   [<a name="ref-FACK" id="ref-FACK">FACK</a>]       Mathis, M. and J. Mahdavi, "Forward Acknowledgment:
                Refining TCP Congestion Control", ACM SIGCOMM SIGCOMM96,
                August 1996.

   [<a name="ref-RHID" id="ref-RHID">RHID</a>]       Mathis, M., Semke, J., and J. Mahdavi, "The Rate-Halving
                Algorithm for TCP Congestion Control", Work in Progress,
                August 1999.

   [<a name="ref-RHweb" id="ref-RHweb">RHweb</a>]      Mathis, M. and J. Mahdavi, "TCP Rate-Halving with
                Bounding Parameters", Web publication, December 1997,
                &lt;<a href="http://www.psc.edu/networking/papers/FACKnotes/current/">http://www.psc.edu/networking/papers/FACKnotes/current/</a>&gt;.

   [<a name="ref-CUBIC" id="ref-CUBIC">CUBIC</a>]      Rhee, I. and L. Xu, "CUBIC: A new TCP-friendly high-
                speed TCP variant", PFLDnet 2005, February 2005.

   [<a name="ref-Jacobson88" id="ref-Jacobson88">Jacobson88</a>] Jacobson, V., "Congestion Avoidance and Control",
                SIGCOMM Comput. Commun. Rev. 18(4), August 1988.

   [<a name="ref-Savage99" id="ref-Savage99">Savage99</a>]   Savage, S., Cardwell, N., Wetherall, D., and T.
                Anderson, "TCP congestion control with a misbehaving
                receiver", SIGCOMM Comput. Commun. Rev. 29(5), October
                1999.

   [<a name="ref-Laminar" id="ref-Laminar">Laminar</a>]    Mathis, M., "Laminar TCP and the case for refactoring
                TCP congestion control", Work in Progress, July 2012.






<span class="grey">Mathis, et al.                Experimental                     [Page 14]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-15" id="page-15" href="#page-15" class="invisible"> </a>
<span class="grey"><a href="rfc6937.html">RFC 6937</a>               Proportional Rate Reduction              May 2013</span>


<span class="h2"><a class="selflink" name="appendix-A" href="#appendix-A">Appendix A</a>.  Strong Packet Conservation Bound</span>

   PRR-CRB is based on a conservative, philosophically pure, and
   aesthetically appealing Strong Packet Conservation Bound, described
   here.  Although inspired by Van Jacobson's packet conservation
   principle [<a href="#ref-Jacobson88" title="&quot;Congestion Avoidance and Control&quot;">Jacobson88</a>], it differs in how it treats segments that are
   missing and presumed lost.  Under all conditions and sequences of
   events during recovery, PRR-CRB strictly bounds the data transmitted
   to be equal to or less than the amount of data delivered to the
   receiver.  Note that the effects of presumed losses are included in
   the pipe calculation, but do not affect the outcome of PRR-CRB, once
   pipe has fallen below ssthresh.

   We claim that this Strong Packet Conservation Bound is the most
   aggressive algorithm that does not lead to additional forced losses
   in some environments.  It has the property that if there is a
   standing queue at a bottleneck that is carrying no other traffic, the
   queue will maintain exactly constant length for the entire duration
   of the recovery, except for +1/-1 fluctuation due to differences in
   packet arrival and exit times.  Any less aggressive algorithm will
   result in a declining queue at the bottleneck.  Any more aggressive
   algorithm will result in an increasing queue or additional losses if
   it is a full drop tail queue.

   We demonstrate this property with a little thought experiment:

   Imagine a network path that has insignificant delays in both
   directions, except for the processing time and queue at a single
   bottleneck in the forward path.  By insignificant delay, we mean when
   a packet is "served" at the head of the bottleneck queue, the
   following events happen in much less than one bottleneck packet time:
   the packet arrives at the receiver; the receiver sends an ACK that
   arrives at the sender; the sender processes the ACK and sends some
   data; the data is queued at the bottleneck.

   If sndcnt is set to DeliveredData and nothing else is inhibiting
   sending data, then clearly the data arriving at the bottleneck queue
   will exactly replace the data that was served at the head of the
   queue, so the queue will have a constant length.  If queue is drop
   tail and full, then the queue will stay exactly full.  Losses or
   reordering on the ACK path only cause wider fluctuations in the queue
   size, but do not raise its peak size, independent of whether the data
   is in order or out of order (including loss recovery from an earlier
   RTT).  Any more aggressive algorithm that sends additional data will
   overflow the drop tail queue and cause loss.  Any less aggressive
   algorithm will under-fill the queue.  Therefore, setting sndcnt to
   DeliveredData is the most aggressive algorithm that does not cause
   forced losses in this simple network.  Relaxing the assumptions



<span class="grey">Mathis, et al.                Experimental                     [Page 15]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-16" id="page-16" href="#page-16" class="invisible"> </a>
<span class="grey"><a href="rfc6937.html">RFC 6937</a>               Proportional Rate Reduction              May 2013</span>


   (e.g., making delays more authentic and adding more flows, delayed
   ACKs, etc.) is likely to increase the fine grained fluctuations in
   queue size but does not change its basic behavior.

   Note that the congestion control algorithm implements a broader
   notion of optimal that includes appropriately sharing the network.
   Typical congestion control algorithms are likely to reduce the data
   sent relative to the Packet Conserving Bound implemented by PRR,
   bringing TCP's actual window down to ssthresh.

Authors' Addresses

   Matt Mathis
   Google, Inc.
   1600 Amphitheatre Parkway
   Mountain View, California  94043
   USA

   EMail: mattmathis@google.com


   Nandita Dukkipati
   Google, Inc.
   1600 Amphitheatre Parkway
   Mountain View, California  94043
   USA

   EMail: nanditad@google.com


   Yuchung Cheng
   Google, Inc.
   1600 Amphitheatre Parkway
   Mountain View, California  94043
   USA

   EMail: ycheng@google.com














Mathis, et al.                Experimental                     [Page 16]

</pre><br />
    <span class="noprint"><small><small>Html markup produced by rfcmarkup 1.126, available from
      <a href="https://tools.ietf.org/tools/rfcmarkup/">https://tools.ietf.org/tools/rfcmarkup/</a>
    </small></small></span>
  </div>
</body>

<!-- Mirrored from tools.ietf.org/html/rfc6937 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 06 Mar 2018 23:18:25 GMT -->
</html>
