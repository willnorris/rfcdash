<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml"><!-- Mirrored from tools.ietf.org/html/rfc6056 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 06 Mar 2018 23:18:32 GMT --><!-- Added by HTTrack --><head><meta content="text/html;charset=utf-8" http-equiv="content-type"/><!-- /Added by HTTrack -->

    <meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
    <meta content="index,follow" name="robots"/>
    <meta content="rfcmarkup version 1.126" name="creator"/>
    <link href="http://purl.org/dc/elements/1.1/" rel="schema.DC"/>
<meta content="draft-larsen-tsvwg-port-randomization" name="DC.Relation.Replaces"/>
<meta content="urn:ietf:rfc:6056" name="DC.Identifier"/>
<meta content="January, 2011" name="DC.Date.Issued"/>
<meta content="Larsen, Michael Vittrup" name="DC.Creator"/>
<meta content="Gont, Fernando" name="DC.Creator"/>
<meta content="Recently, awareness has been raised about a number of &quot;blind&quot; attacks
that can be performed against the Transmission Control Protocol (TCP)
and similar protocols. The consequences of these attacks range from
throughput-reduction to broken connections or data corruption. These
attacks rely on the attacker's ability to guess or know the five-
tuple (Protocol, Source Address, Destination Address, Source Port,
Destination Port) that identifies the transport protocol instance to
be attacked. This document describes a simple and efficient method for
random selection of the client port number, such that the possibility
of an attacker guessing the exact value is reduced. While this is not
a replacement for cryptographic methods, the described port number
randomization algorithms provide improved security/obfuscation with
very little effort and without any key management overhead. The
mechanisms described in this document are a local modification that
may be incrementally deployed, and that does not violate the
specifications of any of the transport protocols that may benefit from
it, such as TCP, UDP, SCTP, DCCP, and RTP." name="DC.Description.Abstract"/>
<meta content="Port Randomization" name="DC.Title"/>

    <link href="https://tools.ietf.org/images/rfc.png" rel="icon" type="image/png"/>
    <link href="https://tools.ietf.org/images/rfc.png" rel="shortcut icon" type="image/png"/>
    <title>RFC 6056 - Port Randomization</title>
    
    
    <style type="text/css">
	@media only screen 
	  and (min-width: 992px)
	  and (max-width: 1199px) {
	    body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 768px)
	  and (max-width: 991px) {
            body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 480px)
	  and (max-width: 767px) {
            body { font-size: 11pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (max-width: 479px) {
            body { font-size: 8pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-device-width : 375px) 
	  and (max-device-width : 667px) {
            body { font-size: 9.5pt; }
            div.content { width: 96ex; margin: 0 1px; }
        }
	@media only screen 
	  and (min-device-width: 1200px) {
            body { font-size: 10pt; margin: 0 4em; }
            div.content { width: 96ex; margin: 0; }
        }
        h1, h2, h3, h4, h5, h6, .h1, .h2, .h3, .h4, .h5, .h6 {
	    font-weight: bold;
            line-height: 0pt;
            display: inline;
            white-space: pre;
            font-family: monospace;
            font-size: 1em;
	    font-weight: bold;
        }
        pre {
            font-size: 1em;
            margin-top: 0px;
            margin-bottom: 0px;
        }
	.pre {
	    white-space: pre;
	    font-family: monospace;
	}
	.header{
	    font-weight: bold;
	}
        .newpage {
            page-break-before: always;
        }
        .invisible {
            text-decoration: none;
            color: white;
        }
        a.selflink {
          color: black;
          text-decoration: none;
        }
        @media print {
            body {
                font-family: monospace;
                font-size: 10.5pt;
            }
            h1, h2, h3, h4, h5, h6 {
                font-size: 1em;
            }
        
            a:link, a:visited {
                color: inherit;
                text-decoration: none;
            }
            .noprint {
                display: none;
            }
        }
	@media screen {
	    .grey, .grey a:link, .grey a:visited {
		color: #777;
	    }
            .docinfo {
                background-color: #EEE;
            }
            .top {
                border-top: 7px solid #EEE;
            }
            .bgwhite  { background-color: white; }
            .bgred    { background-color: #F44; }
            .bggrey   { background-color: #666; }
            .bgbrown  { background-color: #840; }            
            .bgorange { background-color: #FA0; }
            .bgyellow { background-color: #EE0; }
            .bgmagenta{ background-color: #F4F; }
            .bgblue   { background-color: #66F; }
            .bgcyan   { background-color: #4DD; }
            .bggreen  { background-color: #4F4; }

            .legend   { font-size: 90%; }
            .cplate   { font-size: 70%; border: solid grey 1px; }
	}
    </style>
    <!--[if IE]>
    <style>
    body {
       font-size: 13px;
       margin: 10px 10px;
    }
    </style>
    <![endif]-->

    <script type="text/javascript"><!--
    function addHeaderTags() {
	var spans = document.getElementsByTagName("span");
	for (var i=0; i < spans.length; i++) {
	    var elem = spans[i];
	    if (elem) {
		var level = elem.getAttribute("class");
                if (level == "h1" || level == "h2" || level == "h3" || level == "h4" || level == "h5" || level == "h6") {
                    elem.innerHTML = "<"+level+">"+elem.innerHTML+"</"+level+">";		
                }
	    }
	}
    }
    var legend_html = "Colour legend:<br />      <table>         <tr><td>Unknown:</td>                   <td><span class='cplate bgwhite'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft:</td>                     <td><span class='cplate bgred'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Informational:</td>             <td><span class='cplate bgorange'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Experimental:</td>              <td><span class='cplate bgyellow'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Best Common Practice:</td>      <td><span class='cplate bgmagenta'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Proposed Standard:</td>         <td><span class='cplate bgblue'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft Standard (old designation):</td> <td><span class='cplate bgcyan'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Internet Standard:</td>         <td><span class='cplate bggreen'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Historic:</td>                  <td><span class='cplate bggrey'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Obsolete:</td>                  <td><span class='cplate bgbrown'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>     </table>";
    function showElem(id) {
        var elem = document.getElementById(id);
        elem.innerHTML = eval(id+"_html");
        elem.style.visibility='visible';
    }
    function hideElem(id) {
        var elem = document.getElementById(id);
        elem.style.visibility='hidden';        
        elem.innerHTML = "";
    }
    // -->
    </script>
</head>
<body onload="addHeaderTags()">
  <div class="content">
   <div style="height: 13px;">
      <div class="pre noprint docinfo bgmagenta" onclick="showElem('legend');" onmouseout="hideElem('legend')" onmouseover="this.style.cursor='pointer';" style="height: 6px; position: absolute;" title="Click for colour legend.">                                                                        </div>
      <div class="docinfo noprint pre legend" id="legend" onmouseout="hideElem('legend');" onmouseover="showElem('legend');" style="position:absolute; top: 4px; left: 4ex; visibility:hidden; background-color: white; padding: 4px 9px 5px 7px; border: solid #345 1px; ">
      </div>
   </div>
<span class="pre noprint docinfo top">[<a href="index.html" title="Document search and retrieval page">Docs</a>] [<a href="https://tools.ietf.org/rfc/rfc6056.txt" title="Plaintext version of this document">txt</a>|<a href="https://tools.ietf.org/pdf/rfc6056" title="PDF version of this document">pdf</a>] [<a href="https://tools.ietf.org/html/draft-ietf-tsvwg-port-randomization" title="draft-ietf-tsvwg-port-randomization">draft-ietf-tsvw...</a>] [<a href="https://datatracker.ietf.org/doc/rfc6056" title="IESG Datatracker information for this document">Tracker</a>] [<a href="https://tools.ietf.org/rfcdiff?difftype=--hwdiff&amp;url2=rfc6056" title="Inline diff (wdiff)">Diff1</a>] [<a href="https://tools.ietf.org/rfcdiff?url2=rfc6056" title="Side-by-side diff">Diff2</a>] [<a href="https://www.rfc-editor.org/errata_search.php?rfc=6056">Errata</a>]</span><br/>
<span class="pre noprint docinfo">                                                                        </span><br/>
<span class="pre noprint docinfo">                                                   BEST CURRENT PRACTICE</span><br/>
<span class="pre noprint docinfo">                                                            <span style="color: #C00;">Errata Exist</span></span><br/>
<pre>Internet Engineering Task Force (IETF)                         M. Larsen
Request for Comments: 6056                                         Tieto
BCP: 156                                                         F. Gont
Category: Best Current Practice                                  UTN/FRH
ISSN: 2070-1721                                             January 2011


       <span class="h1">Recommendations for Transport-Protocol Port Randomization</span>

Abstract

   During the last few years, awareness has been raised about a number
   of "blind" attacks that can be performed against the Transmission
   Control Protocol (TCP) and similar protocols.  The consequences of
   these attacks range from throughput reduction to broken connections
   or data corruption.  These attacks rely on the attacker's ability to
   guess or know the five-tuple (Protocol, Source Address, Destination
   Address, Source Port, Destination Port) that identifies the transport
   protocol instance to be attacked.  This document describes a number
   of simple and efficient methods for the selection of the client port
   number, such that the possibility of an attacker guessing the exact
   value is reduced.  While this is not a replacement for cryptographic
   methods for protecting the transport-protocol instance, the
   aforementioned port selection algorithms provide improved security
   with very little effort and without any key management overhead.  The
   algorithms described in this document are local policies that may be
   incrementally deployed and that do not violate the specifications of
   any of the transport protocols that may benefit from them, such as
   TCP, UDP, UDP-lite, Stream Control Transmission Protocol (SCTP),
   Datagram Congestion Control Protocol (DCCP), and RTP (provided that
   the RTP application explicitly signals the RTP and RTCP port
   numbers).

Status of This Memo

   This memo documents an Internet Best Current Practice.

   This document is a product of the Internet Engineering Task Force
   (IETF).  It represents the consensus of the IETF community.  It has
   received public review and has been approved for publication by the
   Internet Engineering Steering Group (IESG).  Further information on
   BCPs is available in <a href="rfc5741.html#section-2">Section 2 of RFC 5741</a>.

   Information about the current status of this document, any errata,
   and how to provide feedback on it may be obtained at
   <a href="http://www.rfc-editor.org/info/rfc6056">http://www.rfc-editor.org/info/rfc6056</a>.





<span class="grey">Larsen &amp; Gont             Best Current Practice                 [Page 1]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-2" id="page-2" name="page-2"> </a>
<span class="grey"><a href="rfc6056.html">RFC 6056</a>           Port Randomization Recommendations       January 2011</span>


Copyright Notice

   Copyright (c) 2011 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to <a href="https://tools.ietf.org/html/bcp78">BCP 78</a> and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (<a href="http://trustee.ietf.org/license-info">http://trustee.ietf.org/license-info</a>) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.

   This document may contain material from IETF Documents or IETF
   Contributions published or made publicly available before November
   10, 2008.  The person(s) controlling the copyright in some of this
   material may not have granted the IETF Trust the right to allow
   modifications of such material outside the IETF Standards Process.
   Without obtaining an adequate license from the person(s) controlling
   the copyright in such materials, this document may not be modified
   outside the IETF Standards Process, and derivative works of it may
   not be created outside the IETF Standards Process, except to format
   it for publication as an RFC or to translate it into languages other
   than English.

























<span class="grey">Larsen &amp; Gont             Best Current Practice                 [Page 2]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-3" id="page-3" name="page-3"> </a>
<span class="grey"><a href="rfc6056.html">RFC 6056</a>           Port Randomization Recommendations       January 2011</span>


Table of Contents

   <a href="#section-1">1</a>.  Introduction . . . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-4">4</a>
   <a href="#section-2">2</a>.  Ephemeral Ports  . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-5">5</a>
     <a href="#section-2.1">2.1</a>.  Traditional Ephemeral Port Range . . . . . . . . . . . . .  <a href="#page-5">5</a>
     <a href="#section-2.2">2.2</a>.  Ephemeral Port Selection . . . . . . . . . . . . . . . . .  <a href="#page-6">6</a>
     <a href="#section-2.3">2.3</a>.  Collision of instance-ids  . . . . . . . . . . . . . . . .  <a href="#page-7">7</a>
   <a href="#section-3">3</a>.  Obfuscating the Ephemeral Port Selection . . . . . . . . . . .  <a href="#page-8">8</a>
     3.1.  Characteristics of a Good Algorithm for the
           Obfuscation of the Ephemeral Port Selection  . . . . . . .  <a href="#page-8">8</a>
     <a href="#section-3.2">3.2</a>.  Ephemeral Port Number Range  . . . . . . . . . . . . . . . <a href="#page-10">10</a>
     3.3.  Algorithms for the Obfuscation of the Ephemeral Port
           Selection  . . . . . . . . . . . . . . . . . . . . . . . . <a href="#page-11">11</a>
       <a href="#section-3.3.1">3.3.1</a>.  Algorithm 1: Simple Port Randomization Algorithm . . . <a href="#page-11">11</a>
       3.3.2.  Algorithm 2: Another Simple Port Randomization
               Algorithm  . . . . . . . . . . . . . . . . . . . . . . <a href="#page-13">13</a>
       3.3.3.  Algorithm 3: Simple Hash-Based Port Selection
               Algorithm  . . . . . . . . . . . . . . . . . . . . . . <a href="#page-14">14</a>
       <a href="#section-3.3.4">3.3.4</a>.  Algorithm 4: Double-Hash Port Selection Algorithm  . . <a href="#page-16">16</a>
       3.3.5.  Algorithm 5: Random-Increments Port Selection
               Algorithm  . . . . . . . . . . . . . . . . . . . . . . <a href="#page-18">18</a>
     3.4.  Secret-Key Considerations for Hash-Based Port
           Selection Algorithms . . . . . . . . . . . . . . . . . . . <a href="#page-19">19</a>
     <a href="#section-3.5">3.5</a>.  Choosing an Ephemeral Port Selection Algorithm . . . . . . <a href="#page-20">20</a>
   <a href="#section-4">4</a>.  Interaction with Network Address Port Translation (NAPT) . . . <a href="#page-22">22</a>
   <a href="#section-5">5</a>.  Security Considerations  . . . . . . . . . . . . . . . . . . . <a href="#page-23">23</a>
   <a href="#section-6">6</a>.  Acknowledgements . . . . . . . . . . . . . . . . . . . . . . . <a href="#page-24">24</a>
   <a href="#section-7">7</a>.  References . . . . . . . . . . . . . . . . . . . . . . . . . . <a href="#page-24">24</a>
     <a href="#section-7.1">7.1</a>.  Normative References . . . . . . . . . . . . . . . . . . . <a href="#page-24">24</a>
     <a href="#section-7.2">7.2</a>.  Informative References . . . . . . . . . . . . . . . . . . <a href="#page-25">25</a>
   <a href="#appendix-A">Appendix A</a>.  Survey of the Algorithms in Use by Some Popular
                Implementations . . . . . . . . . . . . . . . . . . . <a href="#page-28">28</a>
     <a href="#appendix-A.1">A.1</a>.  FreeBSD  . . . . . . . . . . . . . . . . . . . . . . . . . <a href="#page-28">28</a>
     <a href="#appendix-A.2">A.2</a>.  Linux  . . . . . . . . . . . . . . . . . . . . . . . . . . <a href="#page-28">28</a>
     <a href="#appendix-A.3">A.3</a>.  NetBSD . . . . . . . . . . . . . . . . . . . . . . . . . . <a href="#page-28">28</a>
     <a href="#appendix-A.4">A.4</a>.  OpenBSD  . . . . . . . . . . . . . . . . . . . . . . . . . <a href="#page-28">28</a>
     <a href="#appendix-A.5">A.5</a>.  OpenSolaris  . . . . . . . . . . . . . . . . . . . . . . . <a href="#page-28">28</a>














<span class="grey">Larsen &amp; Gont             Best Current Practice                 [Page 3]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-4" id="page-4" name="page-4"> </a>
<span class="grey"><a href="rfc6056.html">RFC 6056</a>           Port Randomization Recommendations       January 2011</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/1.%20%20Introduction"></a><a class="selflink" href="#section-1" name="section-1">1</a>.  Introduction</span>

   Recently, awareness has been raised about a number of "blind" attacks
   (i.e., attacks that can be performed without the need to sniff the
   packets that correspond to the transport protocol instance to be
   attacked) that can be performed against the Transmission Control
   Protocol (TCP) [<a href="https://tools.ietf.org/html/rfc0793" title='"Transmission Control Protocol"'>RFC0793</a>] and similar protocols.  The consequences of
   these attacks range from throughput reduction to broken connections
   or data corruption [<a href="rfc5927.html" title='"ICMP Attacks against TCP"'>RFC5927</a>] [<a href="rfc4953.html" title='"Defending TCP Against Spoofing Attacks"'>RFC4953</a>] [<a href="#ref-Watson" title='"Slipping in the Window: TCP Reset Attacks"'>Watson</a>].

   All these attacks rely on the attacker's ability to guess or know the
   five-tuple (Protocol, Source Address, Source port, Destination
   Address, Destination Port) that identifies the transport protocol
   instance to be attacked.

   Services are usually located at fixed, "well-known" ports [<a href="#ref-IANA" title='"IANA Port Numbers"'>IANA</a>] at
   the host supplying the service (the server).  Client applications
   connecting to any such service will contact the server by specifying
   the server IP address and service port number.  The IP address and
   port number of the client are normally left unspecified by the client
   application and thus are chosen automatically by the client
   networking stack.  Ports chosen automatically by the networking stack
   are known as ephemeral ports [<a href="#ref-Stevens" title='"Unix Network Programming, Volume 1: Networking APIs: Socket and XTI"'>Stevens</a>].

   While the server IP address, the well-known port, and the client IP
   address may be known by an attacker, the ephemeral port of the client
   is usually unknown and must be guessed.

   This document describes a number of algorithms for the selection of
   ephemeral port numbers, such that the possibility of an off-path
   attacker guessing the exact value is reduced.  They are not a
   replacement for cryptographic methods of protecting a transport-
   protocol instance such as IPsec [<a href="rfc4301.html" title='"Security Architecture for the Internet Protocol"'>RFC4301</a>], the TCP MD5 signature
   option [<a href="rfc2385.html" title='"Protection of BGP Sessions via the TCP MD5 Signature Option"'>RFC2385</a>], or the TCP Authentication Option [<a href="rfc5925.html" title='"The TCP Authentication Option"'>RFC5925</a>].  For
   example, they do not provide any mitigation in those scenarios in
   which the attacker is able to sniff the packets that correspond to
   the transport protocol instance to be attacked.  However, the
   proposed algorithms provide improved resistance to off-path attacks
   with very little effort and without any key management overhead.

   The mechanisms described in this document are local modifications
   that may be incrementally deployed, and that do not violate the
   specifications of any of the transport protocols that may benefit
   from them, such as TCP [<a href="https://tools.ietf.org/html/rfc0793" title='"Transmission Control Protocol"'>RFC0793</a>], UDP [<a href="https://tools.ietf.org/html/rfc0768" title='"User Datagram Protocol"'>RFC0768</a>], SCTP [<a href="rfc4960.html" title='"Stream Control Transmission Protocol"'>RFC4960</a>], DCCP
   [<a href="rfc4340.html" title='"Datagram Congestion Control Protocol (DCCP)"'>RFC4340</a>], UDP-lite [<a href="rfc3828.html" title='"The Lightweight User Datagram Protocol (UDP-Lite)"'>RFC3828</a>], and RTP [<a href="rfc3550.html" title='"RTP: A Transport Protocol for Real-Time Applications"'>RFC3550</a>] (provided the RTP
   application explicitly signals the RTP and RTCP port numbers with,
   e.g., [<a href="rfc3605.html" title='"Real Time Control Protocol (RTCP) attribute in Session Description Protocol (SDP)"'>RFC3605</a>]).




<span class="grey">Larsen &amp; Gont             Best Current Practice                 [Page 4]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-5" id="page-5" name="page-5"> </a>
<span class="grey"><a href="rfc6056.html">RFC 6056</a>           Port Randomization Recommendations       January 2011</span>


   Since these mechanisms are obfuscation techniques, focus has been on
   a reasonable compromise between the level of obfuscation and the ease
   of implementation.  Thus, the algorithms must be computationally
   efficient and not require substantial state.

   We note that while the technique of mitigating "blind" attacks by
   obfuscating the ephemeral port selection is well-known as "port
   randomization", the goal of the algorithms described in this document
   is to reduce the chances of an attacker guessing the ephemeral ports
   selected for new transport protocol instances, rather than to
   actually produce mathematically random sequences of ephemeral ports.

   Throughout this document, we will use the term "transport-protocol
   instance" as a general term to refer to an instantiation of a
   transport protocol (e.g., a "connection" in the case of connection-
   oriented transport protocols) and the term "instance-id" as a short-
   handle to refer to the group of values that identify a transport-
   protocol instance (e.g., in the case of TCP, the five-tuple
   {Protocol, IP Source Address, TCP Source Port, IP Destination
   Address, TCP Destination Port}).

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in <a href="rfc2119.html">RFC 2119</a> [<a href="rfc2119.html" title='"Key words for use in RFCs to Indicate Requirement Levels"'>RFC2119</a>].

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/2.%20%20Ephemeral%20Ports"></a><a class="selflink" href="#section-2" name="section-2">2</a>.  Ephemeral Ports</span>

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/2.1.%20%20Traditional%20Ephemeral%20Port%20Range"></a><a class="selflink" href="#section-2.1" name="section-2.1">2.1</a>.  Traditional Ephemeral Port Range</span>

   The Internet Assigned Numbers Authority (IANA) assigns the unique
   parameters and values used in protocols developed by the Internet
   Engineering Task Force (IETF), including well-known ports [<a href="#ref-IANA" title='"IANA Port Numbers"'>IANA</a>].
   IANA has reserved the following use of the 16-bit port range of TCP
   and UDP:

   o  The Well-Known Ports, 0 through 1023.

   o  The Registered Ports, 1024 through 49151

   o  The Dynamic and/or Private Ports, 49152 through 65535

   The dynamic port range defined by IANA consists of the 49152-65535
   range, and is meant for the selection of ephemeral ports.








<span class="grey">Larsen &amp; Gont             Best Current Practice                 [Page 5]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-6" id="page-6" name="page-6"> </a>
<span class="grey"><a href="rfc6056.html">RFC 6056</a>           Port Randomization Recommendations       January 2011</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/2.2.%20%20Ephemeral%20Port%20Selection"></a><a class="selflink" href="#section-2.2" name="section-2.2">2.2</a>.  Ephemeral Port Selection</span>

   As each communication instance is identified by the five-tuple
   {protocol, local IP address, local port, remote IP address, remote
   port}, the selection of ephemeral port numbers must result in a
   unique five-tuple.

   Selection of ephemeral ports such that they result in unique
   instance-ids (five-tuples) is handled by some implementations by
   having a per-protocol global "next_ephemeral" variable that is equal
   to the previously chosen ephemeral port + 1, i.e., the selection
   process is:

       /* Initialization at system boot time. Could be random */
       next_ephemeral = min_ephemeral;

       /* Ephemeral port selection function */
       count = max_ephemeral - min_ephemeral + 1;

       do {
           port = next_ephemeral;
           if (next_ephemeral == max_ephemeral) {
               next_ephemeral = min_ephemeral;
           } else {
               next_ephemeral++;
           }

           if (check_suitable_port(port))
               return port;

           count--;

       } while (count &gt; 0);

       return ERROR;

                    Traditional BSD Port Selection Algorithm

   Note:
      check_suitable_port() is a function that checks whether the
      resulting port number is acceptable as an ephemeral port.  That
      is, it checks whether the resulting port number is unique and may,
      in addition, check that the port number is not in use for a
      connection in the LISTEN or CLOSED states and that the port number
      is not in the list of port numbers that should not be allocated as
      ephemeral ports.  In BSD-derived systems, the
      check_suitable_port() would correspond to the in_pcblookup_local()
      function, where all the necessary checks would be performed.



<span class="grey">Larsen &amp; Gont             Best Current Practice                 [Page 6]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-7" id="page-7" name="page-7"> </a>
<span class="grey"><a href="rfc6056.html">RFC 6056</a>           Port Randomization Recommendations       January 2011</span>


   This algorithm works adequately provided that the number of
   transport-protocol instances (for each transport protocol) that have
   a lifetime longer than it takes to exhaust the total ephemeral port
   range is small, so that collisions of instance-ids are rare.

   However, this method has the drawback that the "next_ephemeral"
   variable and thus the ephemeral port range is shared between all
   transport-protocol instances, and the next ports chosen by the client
   are easy to predict.  If an attacker operates an "innocent" server to
   which the client connects, it is easy to obtain a reference point for
   the current value of the "next_ephemeral" variable.  Additionally, if
   an attacker could force a client to periodically establish, e.g., a
   new TCP connection to an attacker-controlled machine (or through an
   attacker-observable path), the attacker could subtract consecutive
   source port values to obtain the number of outgoing TCP connections
   established globally by the target host within that time period (up
   to wrap-around issues and instance-id collisions, of course).

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/2.3.%20%20Collision%20of%20instance-ids"></a><a class="selflink" href="#section-2.3" name="section-2.3">2.3</a>.  Collision of instance-ids</span>

   While it is possible for the ephemeral port selection algorithm to
   verify that the selected port number results in a instance-id that is
   not currently in use by that system, the resulting five-tuple may
   still be in use at a remote system.  For example, consider a scenario
   in which a client establishes a TCP connection with a remote web
   server, and the web server performs the active close on the
   connection.  While the state information for this connection will
   disappear at the client side (that is, the connection will be moved
   to the fictional CLOSED state), the instance-id will remain in the
   TIME-WAIT state at the web server for 2*MSL (Maximum Segment
   Lifetime).  If the same client tried to create a new incarnation of
   the previous connection (that is, a connection with the same
   instance-id as the one in the TIME_WAIT state at the server), an
   instance-id "collision" would occur.  The effect of these collisions
   range from connection-establishment failures to TIME-WAIT state
   assassination (with the potential of data corruption) [<a href="rfc1337.html" title='"TIME-WAIT Assassination Hazards in TCP"'>RFC1337</a>].  In
   scenarios in which a specific client establishes TCP connections with
   a specific service at a server, these problems become evident.
   Therefore, an ephemeral port selection algorithm should ideally
   minimize the rate of instance-id collisions.

   A simple approach to minimize the rate of these collisions would be
   to choose port numbers incrementally, so that a given port number
   would not be reused until the rest of the port numbers in the
   ephemeral port range have been used for a transport protocol
   instance.  However, if a single global variable were used to keep
   track of the last ephemeral port selected, ephemeral port numbers
   would be trivially predictable, thus making it easier for an off-path



<span class="grey">Larsen &amp; Gont             Best Current Practice                 [Page 7]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-8" id="page-8" name="page-8"> </a>
<span class="grey"><a href="rfc6056.html">RFC 6056</a>           Port Randomization Recommendations       January 2011</span>


   attacker to "guess" the instance-id in use by a target transport-
   protocol instance.  Sections <a href="#section-3.3.3">3.3.3</a> and <a href="#section-3.3.4">3.3.4</a> describe algorithms that
   select port numbers incrementally, while still making it difficult
   for an off-path attacker to predict the ephemeral ports used for
   future transport-protocol instances.

   A simple but inefficient approach to minimize the rate of collisions
   of instance-ids would be, e.g., in the case of TCP, for both
   endpoints of a TCP connection to keep state about recent connections
   (e.g., have both endpoints end up in the TIME-WAIT state).

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/3.%20%20Obfuscating%20the%20Ephemeral%20Port%20Selection"></a><a class="selflink" href="#section-3" name="section-3">3</a>.  Obfuscating the Ephemeral Port Selection</span>

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.1.%20%20Characteristics%20of%20a%20Good%20Algorithm%20for%20the%20Obfuscation%20of%20the"></a><a class="selflink" href="#section-3.1" name="section-3.1">3.1</a>.  Characteristics of a Good Algorithm for the Obfuscation of the</span>
<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/Ephemeral%20Port%20Selection"></a>      Ephemeral Port Selection</span>

   There are several factors to consider when designing an algorithm for
   selecting ephemeral ports, which include:

   o  Minimizing the predictability of the ephemeral port numbers used
      for future transport-protocol instances.

   o  Minimizing collisions of instance-ids.

   o  Avoiding conflict with applications that depend on the use of
      specific port numbers.

   Given the goal of improving the transport protocol's resistance to
   attack by obfuscation of the instance-id selection, it is key to
   minimize the predictability of the ephemeral ports that will be
   selected for new transport-protocol instances.  While the obvious
   approach to address this requirement would be to select the ephemeral
   ports by simply picking a random value within the chosen port number
   range, this straightforward policy may lead to collisions of
   instance-ids, which could lead to the interoperability problems
   (e.g., delays in the establishment of new connections, failures in
   connection establishment, or data corruption) discussed in
   <a href="#section-2.3">Section 2.3</a>.  As discussed in <a href="#section-1">Section 1</a>, it is worth noting that
   while the technique of mitigating "blind" attacks by obfuscating the
   ephemeral port selection is well-known as "port randomization", the
   goal of the algorithms described in this document is to reduce the
   chances that an attacker will guess the ephemeral ports selected for
   new transport-protocol instances, rather than to actually produce
   sequences of mathematically random ephemeral port numbers.







<span class="grey">Larsen &amp; Gont             Best Current Practice                 [Page 8]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-9" id="page-9" name="page-9"> </a>
<span class="grey"><a href="rfc6056.html">RFC 6056</a>           Port Randomization Recommendations       January 2011</span>


   It is also worth noting that, provided adequate algorithms are in
   use, the larger the range from which ephemeral ports are selected,
   the smaller the chances of an attacker are to guess the selected port
   number.

   In scenarios in which a specific client establishes transport-
   protocol instances with a specific service at a server, the problems
   described in <a href="#section-2.3">Section 2.3</a> become evident.  A good algorithm to
   minimize the collisions of instance-ids would consider the time a
   given five-tuple was last used, and would avoid reusing the last
   recently used five-tuples.  A simple approach to minimize the rate of
   collisions would be to choose port numbers incrementally, so that a
   given port number would not be reused until the rest of the port
   numbers in the ephemeral port range have been used for a transport-
   protocol instance.  However, if a single global variable were used to
   keep track of the last ephemeral port selected, ephemeral port
   numbers would be trivially predictable.

   It is important to note that a number of applications rely on binding
   specific port numbers that may be within the ephemeral port range.
   If such an application were run while the corresponding port number
   were in use, the application would fail.  Therefore, ephemeral port
   selection algorithms avoid using those port numbers.

   Port numbers that are currently in use by a TCP in the LISTEN state
   should not be allowed for use as ephemeral ports.  If this rule is
   not complied with, an attacker could potentially "steal" an incoming
   connection to a local server application in at least two different
   ways.  Firstly, an attacker could issue a connection request to the
   victim client at roughly the same time the client tries to connect to
   the victim server application [<a href="#ref-CPNI-TCP" title='"CPNI Technical Note 3/2009: Security Assessment of the Transmission Control Protocol (TCP)"'>CPNI-TCP</a>] [<a href="#ref-TCP-SEC" title='"Security Assessment of the Transmission Control Protocol (TCP)"'>TCP-SEC</a>].  If the SYN
   segment corresponding to the attacker's connection request and the
   SYN segment corresponding to the victim client "cross each other in
   the network", and provided the attacker is able to know or guess the
   ephemeral port used by the client, a TCP "simultaneous open" scenario
   would take place, and the incoming connection request sent by the
   client would be matched with the attacker's socket rather than with
   the victim server application's socket.  Secondly, an attacker could
   specify a more specific socket than the "victim" socket (e.g.,
   specify both the local IP address and the local TCP port), and thus
   incoming SYN segments matching the attacker's socket would be
   delivered to the attacker, rather than to the "victim" socket (see
   Section 10.1 of [<a href="#ref-CPNI-TCP" title='"CPNI Technical Note 3/2009: Security Assessment of the Transmission Control Protocol (TCP)"'>CPNI-TCP</a>]).

   It should be noted that most applications based on popular
   implementations of the TCP API (such as the Sockets API) perform
   "passive opens" in three steps.  Firstly, the application obtains a
   file descriptor to be used for inter-process communication (e.g., by



<span class="grey">Larsen &amp; Gont             Best Current Practice                 [Page 9]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-10" id="page-10" name="page-10"> </a>
<span class="grey"><a href="rfc6056.html">RFC 6056</a>           Port Randomization Recommendations       January 2011</span>


   issuing a socket() call).  Secondly, the application binds the file
   descriptor to a local TCP port number (e.g., by issuing a bind()
   call), thus creating a TCP in the fictional CLOSED state.  Thirdly,
   the aforementioned TCP is put in the LISTEN state (e.g., by issuing a
   listen() call).  As a result, with such an implementation of the TCP
   API, even if port numbers in use for TCPs in the LISTEN state were
   not allowed for use as ephemeral ports, there is a window of time
   between the second and the third steps in which an attacker could be
   allowed to select a port number that would be later used for
   listening to incoming connections.  Therefore, these implementations
   of the TCP API should enforce a stricter requirement for the
   allocation of port numbers: port numbers that are in use by a TCP in
   the LISTEN or CLOSED states should not be allowed for allocation as
   ephemeral ports [<a href="#ref-CPNI-TCP" title='"CPNI Technical Note 3/2009: Security Assessment of the Transmission Control Protocol (TCP)"'>CPNI-TCP</a>] [<a href="#ref-TCP-SEC" title='"Security Assessment of the Transmission Control Protocol (TCP)"'>TCP-SEC</a>].

   The aforementioned issue does not affect SCTP, since most SCTP
   implementations do not allow a socket to be bound to the same port
   number unless a specific socket option (SCTP_REUSE_PORT) is issued on
   the socket (i.e., this behavior needs to be explicitly allowed
   beforehand).  An example of a typical SCTP socket API can be found in
   [<a href="#ref-SCTP-SOCKET" title='"Sockets API Extensions for Stream Control Transmission Protocol (SCTP)"'>SCTP-SOCKET</a>].

   DCCP is not affected by the exploitation of "simultaneous opens" to
   "steal" incoming connections, as the server and the client state
   machines are different [<a href="rfc4340.html" title='"Datagram Congestion Control Protocol (DCCP)"'>RFC4340</a>].  However, it may be affected by the
   vector involving binding a more specific socket.  As a result, those
   tuples {local IP address, local port, Service Code} that are in use
   by a local socket should not be allowed for allocation as ephemeral
   ports.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.2.%20%20Ephemeral%20Port%20Number%20Range"></a><a class="selflink" href="#section-3.2" name="section-3.2">3.2</a>.  Ephemeral Port Number Range</span>

   As mentioned in <a href="#section-2.1">Section 2.1</a>, the dynamic ports consist of the range
   49152-65535.  However, ephemeral port selection algorithms should use
   the whole range 1024-65535.

   This range includes the IANA Registered Ports; thus, some of these
   port numbers may be needed for providing a particular service at the
   local host, which could result in the problems discussed in
   <a href="#section-3.1">Section 3.1</a>.  As a result, port numbers that may be needed for
   providing a particular service at the local host SHOULD NOT be
   included in the pool of port numbers available for ephemeral port
   randomization.  If the host does not provide a particular service,
   the port can be safely allocated to ordinary processes.

   A possible workaround for this potential problem would be to maintain
   a local list of the port numbers that should not be allocated as
   ephemeral ports.  Thus, before allocating a port number, the



<span class="grey">Larsen &amp; Gont             Best Current Practice                [Page 10]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-11" id="page-11" name="page-11"> </a>
<span class="grey"><a href="rfc6056.html">RFC 6056</a>           Port Randomization Recommendations       January 2011</span>


   ephemeral port selection function would check this list, avoiding the
   allocation of ports that may be needed for specific applications.
   Rather than naively excluding all the registered ports,
   administrators should identify services that may be offered by the
   local host and SHOULD exclude only the corresponding registered
   ports.

   Ephemeral port selection algorithms SHOULD use the largest possible
   port range, since this reduces the chances of an off-path attacker of
   guessing the selected port numbers.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.3.%20%20Algorithms%20for%20the%20Obfuscation%20of%20the%20Ephemeral%20Port%20Selection"></a><a class="selflink" href="#section-3.3" name="section-3.3">3.3</a>.  Algorithms for the Obfuscation of the Ephemeral Port Selection</span>

   Ephemeral port selection algorithms SHOULD obfuscate the selection of
   their ephemeral ports, since this helps to mitigate a number of
   attacks that depend on the attacker's ability to guess or know the
   five-tuple that identifies the transport-protocol instance to be
   attacked.

   The following subsections describe a number of algorithms that could
   be implemented in order to obfuscate the selection of ephemeral port
   numbers.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/3.3.1.%20%20Algorithm%201%3A%20Simple%20Port%20Randomization%20Algorithm"></a><a class="selflink" href="#section-3.3.1" name="section-3.3.1">3.3.1</a>.  Algorithm 1: Simple Port Randomization Algorithm</span>

   In order to address the security issues discussed in Sections <a href="#section-1">1</a> and
   2.2, a number of systems have implemented simple ephemeral port
   number randomization, as follows:























<span class="grey">Larsen &amp; Gont             Best Current Practice                [Page 11]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-12" id="page-12" name="page-12"> </a>
<span class="grey"><a href="rfc6056.html">RFC 6056</a>           Port Randomization Recommendations       January 2011</span>


       /* Ephemeral port selection function */
       num_ephemeral = max_ephemeral - min_ephemeral + 1;
       next_ephemeral = min_ephemeral + (random() % num_ephemeral);
       count = num_ephemeral;

       do {
           if(check_suitable_port(port))
                   return next_ephemeral;

           if (next_ephemeral == max_ephemeral) {
               next_ephemeral = min_ephemeral;
           } else {
               next_ephemeral++;
           }

           count--;
       } while (count &gt; 0);

       return ERROR;

                              Algorithm 1

   Note:
      random() is a function that returns a 32-bit pseudo-random
      unsigned integer number.  Note that the output needs to be
      unpredictable, and typical implementations of POSIX random()
      function do not necessarily meet this requirement.  See [<a href="rfc4086.html" title='"Randomness Requirements for Security"'>RFC4086</a>]
      for randomness requirements for security.

      All the variables (in this and all the algorithms discussed in
      this document) are unsigned integers.

   Since the initially chosen port may already be in use with IP
   addresses and server port that are identical to the ones being used
   for the socket for which the ephemeral port is to be selected, the
   resulting five-tuple might not be unique.  Therefore, multiple ports
   may have to be tried and verified against all existing transport-
   protocol instances before a port can be chosen.

   Web proxy servers, Network Address Port Translators (NAPTs)
   [<a href="rfc2663.html" title='"IP Network Address Translator (NAT) Terminology and Considerations"'>RFC2663</a>], and other middleboxes aggregate multiple peers into the
   same port space and thus increase the population of used ephemeral
   ports, and hence the chances of collisions of instance-ids.  However,
   [<a href="#ref-Allman" title='"Comments On Selecting Ephemeral Ports"'>Allman</a>] has shown that at least in the network scenarios used for
   measuring the collision properties of the algorithms described in
   this document, the collision rate resulting from the use of the
   aforementioned middleboxes is nevertheless very low.




<span class="grey">Larsen &amp; Gont             Best Current Practice                [Page 12]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-13" id="page-13" name="page-13"> </a>
<span class="grey"><a href="rfc6056.html">RFC 6056</a>           Port Randomization Recommendations       January 2011</span>


   Since this algorithm performs port selection without taking into
   account the port numbers previously chosen, it has the potential of
   reusing port numbers too quickly, thus possibly leading to collisions
   of instance-ids.  Even if a given instance-id is verified to be
   unique by the port selection algorithm, the instance-id might still
   be in use at the remote system.  In such a scenario, a connection
   request could possibly fail ([<a href="#ref-Silbersack" title='"Improving TCP/IP security through randomization without sacrificing interoperability"'>Silbersack</a>] describes this problem for
   the TCP case).

   However, this algorithm is biased towards the first available port
   after a sequence of unavailable port numbers.  If the local list of
   registered port numbers that should not be allocated as ephemeral
   ports (as described in <a href="#section-3.2">Section 3.2</a>) is significant, an attacker may
   actually have a significantly better chance of guessing a port
   number.

   This algorithm selects ephemeral port numbers randomly and thus
   reduces the chances that an attacker will guess the ephemeral port
   selected for a target transport-protocol instance.  Additionally, it
   prevents attackers from obtaining the number of outgoing transport-
   protocol instances (e.g., TCP connections) established by the client
   in some period of time.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/3.3.2.%20%20Algorithm%202%3A%20Another%20Simple%20Port%20Randomization%20Algorithm"></a><a class="selflink" href="#section-3.3.2" name="section-3.3.2">3.3.2</a>.  Algorithm 2: Another Simple Port Randomization Algorithm</span>

   The following pseudo-code illustrates another algorithm for selecting
   a random port number, in which in the event a local instance-id
   collision is detected, another port number is selected randomly:

       /* Ephemeral port selection function */
       num_ephemeral = max_ephemeral - min_ephemeral + 1;
       next_ephemeral = min_ephemeral + (random() % num_ephemeral);
       count = num_ephemeral;

       do {
           if(check_suitable_port(port))
                   return next_ephemeral;

           next_ephemeral = min_ephemeral + (random() % num_ephemeral);
           count--;
       } while (count &gt; 0);

       return ERROR;

                              Algorithm 2






<span class="grey">Larsen &amp; Gont             Best Current Practice                [Page 13]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-14" id="page-14" name="page-14"> </a>
<span class="grey"><a href="rfc6056.html">RFC 6056</a>           Port Randomization Recommendations       January 2011</span>


   When there are a large number of port numbers already in use for the
   same destination endpoint, this algorithm might be unable (with a
   very small remaining probability) to select an ephemeral port (i.e.,
   it would return "ERROR"), even if there are still a few port numbers
   available that would result in unique five-tuples.  However, the
   results in [<a href="#ref-Allman" title='"Comments On Selecting Ephemeral Ports"'>Allman</a>] have shown that in common scenarios, one port
   choice is enough, and in most cases where more than one choice is
   needed, two choices suffice.  Therefore, in those scenarios this
   would not be problem.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/3.3.3.%20%20Algorithm%203%3A%20Simple%20Hash-Based%20Port%20Selection%20Algorithm"></a><a class="selflink" href="#section-3.3.3" name="section-3.3.3">3.3.3</a>.  Algorithm 3: Simple Hash-Based Port Selection Algorithm</span>

   We would like to achieve the port-reuse properties of the traditional
   BSD port selection algorithm (described in <a href="#section-2.2">Section 2.2</a>), while at the
   same time achieve the unpredictability properties of Algorithm 1 and
   Algorithm 2.

   Ideally, we would like a "next_ephemeral" value for each set of
   (local IP address, remote IP addresses, remote port), so that the
   port-reuse frequency is the lowest possible.  Each of these
   "next_ephemeral" variables should be initialized with random values
   within the ephemeral port range and, together, these would thus
   separate the ephemeral port space of the transport-protocol instances
   on a "per-destination endpoint" basis (this "separation of the
   ephemeral port space" means that transport-protocol instances with
   different remote endpoints will not have different sequences of port
   numbers, i.e., will not be part of the same ephemeral port sequence
   as in the case of the traditional BSD ephemeral port selection
   algorithm).  Since we do not want to maintain in memory all these
   "next_ephemeral" values, we propose an offset function F() that can
   be computed from the local IP address, remote IP address, remote
   port, and a secret key.  F() will yield (practically) different
   values for each set of arguments, i.e.:


















<span class="grey">Larsen &amp; Gont             Best Current Practice                [Page 14]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-15" id="page-15" name="page-15"> </a>
<span class="grey"><a href="rfc6056.html">RFC 6056</a>           Port Randomization Recommendations       January 2011</span>


       /* Initialization at system boot time. Could be random. */
       next_ephemeral = 0;

       /* Ephemeral port selection function */
       num_ephemeral = max_ephemeral - min_ephemeral + 1;
       offset = F(local_IP, remote_IP, remote_port, secret_key);
       count = num_ephemeral;

       do {
           port = min_ephemeral +
                  (next_ephemeral + offset) % num_ephemeral;

           next_ephemeral++;

           if(check_suitable_port(port))
               return port;

           count--;

       } while (count &gt; 0);

       return ERROR;

                              Algorithm 3

   In other words, the function F() provides a "per-destination
   endpoint" fixed offset within the global ephemeral port range.  Both
   the "offset" and "next_ephemeral" variables may take any value within
   the storage type range since we are restricting the resulting port in
   a similar way as in Algorithm 1 (described in <a href="#section-3.3.1">Section 3.3.1</a>).  This
   allows us to simply increment the "next_ephemeral" variable and rely
   on the unsigned integer to wrap around.

   The function F() should be a cryptographic hash function like MD5
   [<a href="rfc1321.html" title='"The MD5 Message-Digest Algorithm"'>RFC1321</a>].  The function should use both IP addresses, the remote
   port, and a secret key value to compute the offset.  The remote IP
   address is the primary separator and must be included in the offset
   calculation.  The local IP address and remote port may in some cases
   be constant and thus not improve the ephemeral port space separation;
   however, they should also be included in the offset calculation.

   Cryptographic algorithms stronger than, e.g., MD5 should not be
   necessary, given that Algorithm 3 is simply a technique for the
   obfuscation of the selection of ephemeral ports.  The secret should
   be chosen to be as random as possible (see [<a href="rfc4086.html" title='"Randomness Requirements for Security"'>RFC4086</a>] for
   recommendations on choosing secrets).





<span class="grey">Larsen &amp; Gont             Best Current Practice                [Page 15]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-16" id="page-16" name="page-16"> </a>
<span class="grey"><a href="rfc6056.html">RFC 6056</a>           Port Randomization Recommendations       January 2011</span>


   Note that on multiuser systems, the function F() could include user-
   specific information, thereby providing protection not only on a
   host-to-host basis, but on a user to service basis.  In fact, any
   identifier of the remote entity could be used, depending on
   availability and the granularity requested.  With SCTP, both
   hostnames and alternative IP addresses may be included in the
   association negotiation, and either of these could be used in the
   offset function F().

   When multiple unique identifiers are available, any of these can be
   chosen as input to the offset function F() since they all uniquely
   identify the remote entity.  However, in cases like SCTP where the
   ephemeral port must be unique across all IP address permutations, we
   should ideally always use the same IP address to get a single
   starting offset for each association negotiation with a given remote
   entity to minimize the possibility of collisions.  A simple numerical
   sorting of the IP addresses and always using the numerically lowest
   could achieve this.  However, since most protocols will generally
   report the same IP addresses in the same order in each association
   setup, this sorting is most likely not necessary and the "first one"
   can simply be used.

   The ability of hostnames to uniquely define hosts can be discussed,
   and since SCTP always includes at least one IP address, we recommend
   using this as input to the offset function F() and ignoring hostname
   chunks when searching for ephemeral ports.

   It should be noted that, as this algorithm uses a global counter
   ("next_ephemeral") for selecting ephemeral ports, if an attacker
   could, e.g., force a client to periodically establish a new TCP
   connection to an attacker-controlled machine (or through an attacker-
   observable path), the attacker could subtract consecutive source port
   values to obtain the number of outgoing TCP connections established
   globally by the target host within that time period (up to wrap-
   around issues and five-tuple collisions, of course).

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/3.3.4.%20%20Algorithm%204%3A%20Double-Hash%20Port%20Selection%20Algorithm"></a><a class="selflink" href="#section-3.3.4" name="section-3.3.4">3.3.4</a>.  Algorithm 4: Double-Hash Port Selection Algorithm</span>

   A trade-off between maintaining a single global "next_ephemeral"
   variable and maintaining 2**N "next_ephemeral" variables (where N is
   the width of the result of F()) could be achieved as follows.  The
   system would keep an array of TABLE_LENGTH short integers, which
   would provide a separation of the increment of the "next_ephemeral"
   variable.  This improvement could be incorporated into Algorithm 3 as
   follows:






<span class="grey">Larsen &amp; Gont             Best Current Practice                [Page 16]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-17" id="page-17" name="page-17"> </a>
<span class="grey"><a href="rfc6056.html">RFC 6056</a>           Port Randomization Recommendations       January 2011</span>


     /* Initialization at system boot time */
     for(i = 0; i &lt; TABLE_LENGTH; i++)
         table[i] = random() % 65536;

     /* Ephemeral port selection function */
     num_ephemeral = max_ephemeral - min_ephemeral + 1;
     offset = F(local_IP, remote_IP, remote_port, secret_key1);
     index = G(local_IP, remote_IP, remote_port, secret_key2);
     count = num_ephemeral;

     do {
         port = min_ephemeral + (offset + table[index]) % num_ephemeral;
         table[index]++;

         if(check_suitable_port(port))
             return port;

        count--;

     } while (count &gt; 0);

     return ERROR;

                            Algorithm 4

   "table[]" could be initialized with mathematically random values, as
   indicated by the initialization code in pseudo-code above.  The
   function G() should be a cryptographic hash function like MD5
   [<a href="rfc1321.html" title='"The MD5 Message-Digest Algorithm"'>RFC1321</a>].  It should use both IP addresses, the remote port, and a
   secret key value to compute a value between 0 and (TABLE_LENGTH-1).
   Alternatively, G() could take an "offset" as input, and perform the
   exclusive-or (XOR) operation between all the bytes in "offset".

   The array "table[]" assures that successive transport-protocol
   instances with the same remote endpoint will use increasing ephemeral
   port numbers.  However, incrementation of the port numbers is
   separated into TABLE_LENGTH different spaces, and thus the port-reuse
   frequency will be (probabilistically) lower than that of Algorithm 3.
   That is, a new transport-protocol instance with some remote endpoint
   will not necessarily cause the "next_ephemeral" variable
   corresponding to other endpoints to be incremented.

   It is interesting to note that the size of "table[]" does not limit
   the number of different port sequences, but rather separates the
   *increments* into TABLE_LENGTH different spaces.  The port sequence
   will result from adding the corresponding entry of "table[]" to the
   variable "offset", which selects the actual port sequence (as in
   Algorithm 3).  [<a href="#ref-Allman" title='"Comments On Selecting Ephemeral Ports"'>Allman</a>] has found that a TABLE_LENGTH of 10 can



<span class="grey">Larsen &amp; Gont             Best Current Practice                [Page 17]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-18" id="page-18" name="page-18"> </a>
<span class="grey"><a href="rfc6056.html">RFC 6056</a>           Port Randomization Recommendations       January 2011</span>


   result in an improvement over Algorithm 3.  Further increasing the
   TABLE_LENGTH will increase the unpredictability of the resulting port
   number, and possibly further decrease the collision rate.

   An attacker can perform traffic analysis for any "increment space"
   into which the attacker has "visibility" -- namely, the attacker can
   force the client to establish a transport-protocol instance whose
   G(offset) identifies the target "increment space".  However, the
   attacker's ability to perform traffic analysis is very reduced when
   compared to the traditional BSD algorithm (described in <a href="#section-2.2">Section 2.2</a>)
   and Algorithm 3.  Additionally, an implementation can further limit
   the attacker's ability to perform traffic analysis by further
   separating the increment space (that is, using a larger value for
   TABLE_LENGTH).

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/3.3.5.%20%20Algorithm%205%3A%20Random-Increments%20Port%20Selection%20Algorithm"></a><a class="selflink" href="#section-3.3.5" name="section-3.3.5">3.3.5</a>.  Algorithm 5: Random-Increments Port Selection Algorithm</span>

   [<a id="ref-Allman" name="ref-Allman">Allman</a>] introduced another port selection algorithm, which offers a
   middle ground between the algorithms that select ephemeral ports
   independently at random (such as those described in Sections <a href="#section-3.3.1">3.3.1</a>
   and 3.3.2), and those that offer obfuscation with less randomization
   (such as those described in Sections <a href="#section-3.3.3">3.3.3</a> and <a href="#section-3.3.4">3.3.4</a>).

     /* Initialization code at system boot time. */
     next_ephemeral = random() % 65536;   /* Initialization value */
     N = 500;                             /* Determines the trade-off */

     /* Ephemeral port selection function */
     num_ephemeral = max_ephemeral - min_ephemeral + 1;

     count = num_ephemeral;

     do {
         next_ephemeral = next_ephemeral + (random() % N) + 1;
         port = min_ephemeral + (next_ephemeral % num_ephemeral);

         if(check_suitable_port(port))
                 return port;

          count--;
     } while (count &gt; 0);

     return ERROR;

                            Algorithm 5






<span class="grey">Larsen &amp; Gont             Best Current Practice                [Page 18]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-19" id="page-19" name="page-19"> </a>
<span class="grey"><a href="rfc6056.html">RFC 6056</a>           Port Randomization Recommendations       January 2011</span>


   This algorithm aims at producing a monotonically increasing sequence
   to prevent the collision of instance-ids, while avoiding the use of
   fixed increments, which would lead to trivially predictable
   sequences.  The value "N" allows for direct control of the trade-off
   between the level of unpredictability and the port-reuse frequency.
   The smaller the value of "N", the more similar this algorithm is to
   the traditional BSD port selection algorithm (described in
   <a href="#section-2.2">Section 2.2</a>).  The larger the value of "N", the more similar this
   algorithm is to the algorithm described in <a href="#section-3.3.1">Section 3.3.1</a> of this
   document.

   When the port numbers wrap, there is the risk of collisions of
   instance-ids.  Therefore, "N" should be selected according to the
   following criteria:

   o  It should maximize the wrapping time of the ephemeral port space.

   o  It should minimize collisions of instance-ids.

   o  It should maximize the unpredictability of selected port numbers.

   Clearly, these are competing goals, and the decision of which value
   of "N" to use is a trade-off.  Therefore, the value of "N" should be
   configurable so that system administrators can make the trade-off for
   themselves.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.4.%20%20Secret-Key%20Considerations%20for%20Hash-Based%20Port%20Selection%20Algorithms"></a><a class="selflink" href="#section-3.4" name="section-3.4">3.4</a>.  Secret-Key Considerations for Hash-Based Port Selection Algorithms</span>

   Every complex manipulation (like MD5) is no more secure than the
   input values, and in the case of ephemeral ports, the secret key.  If
   an attacker is aware of which cryptographic hash function is being
   used by the victim (which we should expect), and the attacker can
   obtain enough material (e.g., ephemeral ports chosen by the victim),
   the attacker may simply search the entire secret-key space to find
   matches.

   To protect against this, the secret key should be of a reasonable
   length.  Key lengths of 128 bits should be adequate.

   Another possible mechanism for protecting the secret key is to change
   it after some time.  If the host platform is capable of producing
   reasonably good random data, the secret key can be changed
   automatically.

   Changing the secret will cause abrupt shifts in the chosen ephemeral
   ports, and consequently collisions may occur.  That is, upon changing
   the secret, the "offset" value (see Sections <a href="#section-3.3.3">3.3.3</a> and <a href="#section-3.3.4">3.3.4</a>) used




<span class="grey">Larsen &amp; Gont             Best Current Practice                [Page 19]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-20" id="page-20" name="page-20"> </a>
<span class="grey"><a href="rfc6056.html">RFC 6056</a>           Port Randomization Recommendations       January 2011</span>


   for each destination endpoint will be different from that computed
   with the previous secret, thus leading to the selection of a port
   number recently used for connecting to the same endpoint.

   Thus, the change in secret key should be done with consideration and
   could be performed whenever one of the following events occur:

   o  The system is being bootstrapped.

   o  Some predefined/random time has expired.

   o  The secret key has been used sufficiently often that it should be
      regarded as insecure now.

   o  There are few active transport-protocol instances (i.e.,
      possibility of a collision is low).

   o  System load is low (i.e., the performance overhead of local
      collisions is tolerated).

   o  There is enough random data available to change the secret key
      (pseudo-random changes should not be done).

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.5.%20%20Choosing%20an%20Ephemeral%20Port%20Selection%20Algorithm"></a><a class="selflink" href="#section-3.5" name="section-3.5">3.5</a>.  Choosing an Ephemeral Port Selection Algorithm</span>

   [<a id="ref-Allman" name="ref-Allman">Allman</a>] is an empirical study of the properties of the algorithms
   described in this document, which has found that all the algorithms
   described in this document offer low collision rates -- at most 0.3%.
   That is, in those network scenarios assessed by [<a href="#ref-Allman" title='"Comments On Selecting Ephemeral Ports"'>Allman</a>], all of the
   algorithms described in this document perform well in terms of
   collisions of instance-ids.  However, these results may vary
   depending on the characteristics of network traffic and the specific
   network setup.

   The algorithm described in <a href="#section-2.2">Section 2.2</a> is the traditional ephemeral
   port selection algorithm implemented in BSD-derived systems.  It
   generates a global sequence of ephemeral port numbers, which makes it
   trivial for an attacker to predict the port number that will be used
   for a future transport protocol instance.  However, it is very simple
   and leads to a low port-reuse frequency.

   Algorithm 1 and Algorithm 2 have the advantage that they provide
   actual randomization of the ephemeral ports.  However, they may
   increase the chances of port number collisions, which could lead to
   the failure of a connection establishment attempt.  [<a href="#ref-Allman" title='"Comments On Selecting Ephemeral Ports"'>Allman</a>] found
   that these two algorithms show the largest collision rates (among all
   the algorithms described in this document).




<span class="grey">Larsen &amp; Gont             Best Current Practice                [Page 20]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-21" id="page-21" name="page-21"> </a>
<span class="grey"><a href="rfc6056.html">RFC 6056</a>           Port Randomization Recommendations       January 2011</span>


   Algorithm 3 provides complete separation in local and remote IP
   addresses and remote port space, and only limited separation in other
   dimensions (see <a href="#section-3.4">Section 3.4</a>).  However, implementations should
   consider the performance impact of computing the cryptographic hash
   used for the offset.

   Algorithm 4 improves Algorithm 3, usually leading to a lower port-
   reuse frequency, at the expense of more processor cycles used for
   computing G(), and additional kernel memory for storing the array
   "table[]".

   Algorithm 5 offers middle ground between the simple randomization
   algorithms (Algorithm 1 and Algorithm 2) and the hash-based
   algorithms (Algorithm 3 and Algorithm 4).  The upper limit on the
   random increments (the value "N" in the pseudo-code included in
   <a href="#section-3.3.5">Section 3.3.5</a>) controls the trade-off between randomization and port-
   reuse frequency.

   Finally, a special case that may preclude the utilization of
   Algorithm 3 and Algorithm 4 should be analyzed.  There exist some
   applications that contain the following code sequence:

       s = socket();
       bind(s, IP_address, port = *);

   In some BSD-derived systems, the call to bind() will result in the
   selection of an ephemeral port number.  However, as neither the
   remote IP address nor the remote port will be available to the
   ephemeral port selection function, the hash function F() used in
   Algorithm 3 and Algorithm 4 will not have all the required arguments,
   and thus the result of the hash function will be impossible to
   compute.  Transport protocols implementing Algorithm 3 or Algorithm 4
   should consider using Algorithm 2 when facing the scenario just
   described.

   An alternative to this behavior would be to implement "lazy binding"
   in response to the bind() call.  That is, selection of an ephemeral
   port would be delayed until, e.g., connect() or send() are called.
   Thus, at that point the ephemeral port is actually selected, all the
   necessary arguments for the hash function F() are available, and
   therefore Algorithm 3 and Algorithm 4 could still be used in this
   scenario.  This algorithm has been implemented by Linux [<a href="#ref-Linux">Linux</a>].









<span class="grey">Larsen &amp; Gont             Best Current Practice                [Page 21]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-22" id="page-22" name="page-22"> </a>
<span class="grey"><a href="rfc6056.html">RFC 6056</a>           Port Randomization Recommendations       January 2011</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/4.%20%20Interaction%20with%20Network%20Address%20Port%20Translation%20%28NAPT%29"></a><a class="selflink" href="#section-4" name="section-4">4</a>.  Interaction with Network Address Port Translation (NAPT)</span>

   Network Address Port Translation (NAPT) translates both the network
   address and transport-protocol port number, thus allowing the
   transport identifiers of a number of private hosts to be multiplexed
   into the transport identifiers of a single external address
   [<a href="rfc2663.html" title='"IP Network Address Translator (NAT) Terminology and Considerations"'>RFC2663</a>].

   In those scenarios in which a NAPT is present between the two
   endpoints of a transport-protocol instance, the obfuscation of the
   ephemeral port selection (from the point of view of the external
   network) will depend on the ephemeral port selection function at the
   NAPT.  Therefore, NAPTs should consider obfuscating the selection of
   ephemeral ports by means of any of the algorithms discussed in this
   document.

   A NAPT that does not implement port preservation [<a href="rfc4787.html" title='"Network Address Translation (NAT) Behavioral Requirements for Unicast UDP"'>RFC4787</a>] [<a href="rfc5382.html" title='"NAT Behavioral Requirements for TCP"'>RFC5382</a>]
   SHOULD obfuscate selection of the ephemeral port of a packet when it
   is changed during translation of that packet.

   A NAPT that does implement port preservation SHOULD obfuscate the
   ephemeral port of a packet only if the port must be changed as a
   result of the port being already in use for some other session.

   A NAPT that performs parity preservation and that must change the
   ephemeral port during translation of a packet SHOULD obfuscate the
   ephemeral ports.  The algorithms described in this document could be
   easily adapted such that the parity is preserved (i.e., force the
   lowest order bit of the resulting port number to 0 or 1 according to
   whether even or odd parity is desired).

   Some applications allocate contiguous ports and expect to see
   contiguous ports in use at their peers.  Clearly, this expectation
   might be difficult to accommodate at a NAPT, since some port numbers
   might already be in use by other sessions, and thus an alternative
   port might need to be selected, thus resulting in a non-contiguous
   port number sequence (see <a href="rfc4787.html#section-4.2.3">Section 4.2.3 of [RFC4787]</a>).  A NAPT that
   implements a simple port randomization algorithm (such as Algorithm
   1, Algorithm 2, or Algorithm 5) is likely to break this assumption,
   even if the endpoint selecting an ephemeral port does select
   ephemeral ports that are contiguous.  However, since a number of
   different ephemeral port selection algorithms have been implemented
   by deployed NAPTs, any application that relies on any specific
   ephemeral port selection algorithm at the NAPT is likely to suffer
   interoperability problems when a NAPT is present between the two
   endpoints of a transport-protocol instance.  Nevertheless, some of
   the algorithms described in this document (namely Algorithm 3 and
   Algorithm 4) select consecutive ephemeral ports such that they are



<span class="grey">Larsen &amp; Gont             Best Current Practice                [Page 22]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-23" id="page-23" name="page-23"> </a>
<span class="grey"><a href="rfc6056.html">RFC 6056</a>           Port Randomization Recommendations       January 2011</span>


   contiguous (except when one of the port numbers needed to produce a
   contiguous sequence is already in use by some other NAPT session).
   Therefore, a NAPT willing to produce sequences of contiguous port
   numbers should consider implementing Algorithm 3 or Algorithm 4 of
   this document.  <a href="#section-3.5">Section 3.5</a> provides further guidance in choosing a
   port selection algorithm.

   It should be noted that in some network scenarios, a NAPT may
   naturally obscure ephemeral port selections simply due to the vast
   range of services with which it establishes connections and to the
   overall rate of the traffic [<a href="#ref-Allman" title='"Comments On Selecting Ephemeral Ports"'>Allman</a>].

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/5.%20%20Security%20Considerations"></a><a class="selflink" href="#section-5" name="section-5">5</a>.  Security Considerations</span>

   Obfuscating the ephemeral port selection is no replacement for
   cryptographic mechanisms, such as IPsec [<a href="rfc4301.html" title='"Security Architecture for the Internet Protocol"'>RFC4301</a>], in terms of
   protecting transport-protocol instances against blind attacks.

   An eavesdropper that can monitor the packets that correspond to the
   transport-protocol instance to be attacked could learn the IP
   addresses and port numbers in use (and also sequence numbers, etc.)
   and easily perform an attack.  Obfuscation of the ephemeral port
   selection does not provide any additional protection against this
   kind of attack.  In such situations, proper authentication mechanisms
   such as those described in [<a href="rfc4301.html" title='"Security Architecture for the Internet Protocol"'>RFC4301</a>] should be used.

   This specification recommends including the whole range 1024-65535
   for the selection of ephemeral ports, and suggests that an
   implementation maintains a list of those port numbers that should not
   be made available for ephemeral port selection.  If the list of port
   numbers that are not available is significant, Algorithm 1 may be
   highly biased and generate predictable ports, as noted in
   <a href="#section-3.3.1">Section 3.3.1</a>.  In particular, if the list of IANA Registered Ports
   is accepted as the local list of port numbers that should not be made
   available, certain ports may result with 500 times the probability of
   other ports.  Systems that support numerous applications resulting in
   large lists of unavailable ports, or that use the IANA Registered
   Ports without modification, MUST NOT use Algorithm 1.

   If the local offset function F() (in Algorithm 3 and Algorithm 4)
   results in identical offsets for different inputs at greater
   frequency than would be expected by chance, the port-offset mechanism
   proposed in this document would have a reduced effect.

   If random numbers are used as the only source of the secret key, they
   should be chosen in accordance with the recommendations given in
   [<a href="rfc4086.html" title='"Randomness Requirements for Security"'>RFC4086</a>].




<span class="grey">Larsen &amp; Gont             Best Current Practice                [Page 23]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-24" id="page-24" name="page-24"> </a>
<span class="grey"><a href="rfc6056.html">RFC 6056</a>           Port Randomization Recommendations       January 2011</span>


   If an attacker uses dynamically assigned IP addresses, the current
   ephemeral port offset (Algorithm 3 and Algorithm 4) for a given five-
   tuple can be sampled and subsequently used to attack an innocent peer
   reusing this address.  However, this is only possible until a re-
   keying happens as described above.  Also, since ephemeral ports are
   only used on the client side (e.g., the one initiating the transport-
   protocol communication), both the attacker and the new peer need to
   act as servers in the scenario just described.  While servers using
   dynamic IP addresses exist, they are not very common, and with an
   appropriate re-keying mechanism the effect of this attack is limited.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/6.%20%20Acknowledgements"></a><a class="selflink" href="#section-6" name="section-6">6</a>.  Acknowledgements</span>

   The offset function used in Algorithm 3 and Algorithm 4 was inspired
   by the mechanism proposed by Steven Bellovin in [<a href="rfc1948.html" title='"Defending Against Sequence Number Attacks"'>RFC1948</a>] for
   defending against TCP sequence number attacks.

   The authors would like to thank (in alphabetical order) Mark Allman,
   Jari Arkko, Matthias Bethke, Stephane Bortzmeyer, Brian Carpenter,
   Vincent Deffontaines, Ralph Droms, Lars Eggert, Pasi Eronen, Gorry
   Fairhurst, Adrian Farrel, Guillermo Gont, David Harrington, Alfred
   Hoenes, Avshalom Houri, Charlie Kaufman, Amit Klein, Subramanian
   Moonesamy, Carlos Pignataro, Tim Polk, Kacheong Poon, Pasi Sarolahti,
   Robert Sparks, Randall Stewart, Joe Touch, Michael Tuexen, Magnus
   Westerlund, and Dan Wing for their valuable feedback on draft
   versions of this document.

   The authors would like to thank Alfred Hoenes for his admirable
   effort in improving the quality of this document.

   The authors would like to thank FreeBSD's Mike Silbersack for a very
   fruitful discussion about ephemeral port selection techniques.

   Fernando Gont's attendance to IETF meetings was supported by ISOC's
   "Fellowship to the IETF" program.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/7.%20%20References"></a><a class="selflink" href="#section-7" name="section-7">7</a>.  References</span>

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/7.1.%20%20Normative%20References"></a><a class="selflink" href="#section-7.1" name="section-7.1">7.1</a>.  Normative References</span>

   [<a id="ref-RFC0768" name="ref-RFC0768">RFC0768</a>]      Postel, J., "User Datagram Protocol", STD 6, <a href="rfc768.html">RFC 768</a>,
                  August 1980.

   [<a id="ref-RFC0793" name="ref-RFC0793">RFC0793</a>]      Postel, J., "Transmission Control Protocol", STD 7,
                  <a href="rfc793.html">RFC 793</a>, September 1981.

   [<a id="ref-RFC1321" name="ref-RFC1321">RFC1321</a>]      Rivest, R., "The MD5 Message-Digest Algorithm",
                  <a href="rfc1321.html">RFC 1321</a>, April 1992.



<span class="grey">Larsen &amp; Gont             Best Current Practice                [Page 24]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-25" id="page-25" name="page-25"> </a>
<span class="grey"><a href="rfc6056.html">RFC 6056</a>           Port Randomization Recommendations       January 2011</span>


   [<a id="ref-RFC2119" name="ref-RFC2119">RFC2119</a>]      Bradner, S., "Key words for use in RFCs to Indicate
                  Requirement Levels", <a href="https://tools.ietf.org/html/bcp14">BCP 14</a>, <a href="rfc2119.html">RFC 2119</a>, March 1997.

   [<a id="ref-RFC2385" name="ref-RFC2385">RFC2385</a>]      Heffernan, A., "Protection of BGP Sessions via the TCP
                  MD5 Signature Option", <a href="rfc2385.html">RFC 2385</a>, August 1998.

   [<a id="ref-RFC3550" name="ref-RFC3550">RFC3550</a>]      Schulzrinne, H., Casner, S., Frederick, R., and V.
                  Jacobson, "RTP: A Transport Protocol for Real-Time
                  Applications", STD 64, <a href="rfc3550.html">RFC 3550</a>, July 2003.

   [<a id="ref-RFC3605" name="ref-RFC3605">RFC3605</a>]      Huitema, C., "Real Time Control Protocol (RTCP)
                  attribute in Session Description Protocol (SDP)",
                  <a href="rfc3605.html">RFC 3605</a>, October 2003.

   [<a id="ref-RFC3828" name="ref-RFC3828">RFC3828</a>]      Larzon, L-A., Degermark, M., Pink, S., Jonsson, L-E.,
                  and G. Fairhurst, "The Lightweight User Datagram
                  Protocol (UDP-Lite)", <a href="rfc3828.html">RFC 3828</a>, July 2004.

   [<a id="ref-RFC4086" name="ref-RFC4086">RFC4086</a>]      Eastlake, D., Schiller, J., and S. Crocker,
                  "Randomness Requirements for Security", <a href="https://tools.ietf.org/html/bcp106">BCP 106</a>,
                  <a href="rfc4086.html">RFC 4086</a>, June 2005.

   [<a id="ref-RFC4301" name="ref-RFC4301">RFC4301</a>]      Kent, S. and K. Seo, "Security Architecture for the
                  Internet Protocol", <a href="rfc4301.html">RFC 4301</a>, December 2005.

   [<a id="ref-RFC4340" name="ref-RFC4340">RFC4340</a>]      Kohler, E., Handley, M., and S. Floyd, "Datagram
                  Congestion Control Protocol (DCCP)", <a href="rfc4340.html">RFC 4340</a>,
                  March 2006.

   [<a id="ref-RFC4787" name="ref-RFC4787">RFC4787</a>]      Audet, F. and C. Jennings, "Network Address
                  Translation (NAT) Behavioral Requirements for Unicast
                  UDP", <a href="https://tools.ietf.org/html/bcp127">BCP 127</a>, <a href="rfc4787.html">RFC 4787</a>, January 2007.

   [<a id="ref-RFC4960" name="ref-RFC4960">RFC4960</a>]      Stewart, R., "Stream Control Transmission Protocol",
                  <a href="rfc4960.html">RFC 4960</a>, September 2007.

   [<a id="ref-RFC5382" name="ref-RFC5382">RFC5382</a>]      Guha, S., Biswas, K., Ford, B., Sivakumar, S., and P.
                  Srisuresh, "NAT Behavioral Requirements for TCP",
                  <a href="https://tools.ietf.org/html/bcp142">BCP 142</a>, <a href="rfc5382.html">RFC 5382</a>, October 2008.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/7.2.%20%20Informative%20References"></a><a class="selflink" href="#section-7.2" name="section-7.2">7.2</a>.  Informative References</span>

   [<a id="ref-Allman" name="ref-Allman">Allman</a>]       Allman, M., "Comments On Selecting Ephemeral Ports",
                   ACM Computer Communication Review, 39(2), 2009.







<span class="grey">Larsen &amp; Gont             Best Current Practice                [Page 25]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-26" id="page-26" name="page-26"> </a>
<span class="grey"><a href="rfc6056.html">RFC 6056</a>           Port Randomization Recommendations       January 2011</span>


   [<a id="ref-CPNI-TCP" name="ref-CPNI-TCP">CPNI-TCP</a>]     Gont, F., "CPNI Technical Note 3/2009: Security
                  Assessment of the Transmission Control Protocol
                  (TCP)", 2009, &lt;<a href="http://www.cpni.gov.uk/Docs/tn-03-09-security-assessment-TCP.pdf">http://www.cpni.gov.uk/Docs/</a>
                  <a href="http://www.cpni.gov.uk/Docs/tn-03-09-security-assessment-TCP.pdf">tn-03-09-security-assessment-TCP.pdf</a>&gt;.

   [<a id="ref-FreeBSD" name="ref-FreeBSD">FreeBSD</a>]      The FreeBSD Project, &lt;<a href="http://www.freebsd.org/">http://www.freebsd.org</a>&gt;.

   [<a id="ref-IANA" name="ref-IANA">IANA</a>]         "IANA Port Numbers",
                  &lt;<a href="http://www.iana.org/assignments/port-numbers">http://www.iana.org/assignments/port-numbers</a>&gt;.

   [<a id="ref-Linux" name="ref-Linux">Linux</a>]        The Linux Project, &lt;<a href="http://www.kernel.org/">http://www.kernel.org</a>&gt;.

   [<a id="ref-NetBSD" name="ref-NetBSD">NetBSD</a>]       The NetBSD Project, &lt;<a href="http://www.netbsd.org/">http://www.netbsd.org</a>&gt;.

   [<a id="ref-OpenBSD" name="ref-OpenBSD">OpenBSD</a>]      The OpenBSD Project, &lt;<a href="http://www.openbsd.org/">http://www.openbsd.org</a>&gt;.

   [<a id="ref-OpenSolaris" name="ref-OpenSolaris">OpenSolaris</a>]  OpenSolaris, &lt;<a href="http://www.opensolaris.org/">http://www.opensolaris.org</a>&gt;.

   [<a id="ref-RFC1337" name="ref-RFC1337">RFC1337</a>]      Braden, B., "TIME-WAIT Assassination Hazards in TCP",
                  <a href="rfc1337.html">RFC 1337</a>, May 1992.

   [<a id="ref-RFC1948" name="ref-RFC1948">RFC1948</a>]      Bellovin, S., "Defending Against Sequence Number
                  Attacks", <a href="rfc1948.html">RFC 1948</a>, May 1996.

   [<a id="ref-RFC2663" name="ref-RFC2663">RFC2663</a>]      Srisuresh, P. and M. Holdrege, "IP Network Address
                  Translator (NAT) Terminology and Considerations",
                  <a href="rfc2663.html">RFC 2663</a>, August 1999.

   [<a id="ref-RFC4953" name="ref-RFC4953">RFC4953</a>]      Touch, J., "Defending TCP Against Spoofing Attacks",
                  <a href="rfc4953.html">RFC 4953</a>, July 2007.

   [<a id="ref-RFC5925" name="ref-RFC5925">RFC5925</a>]      Touch, J., Mankin, A., and R. Bonica, "The TCP
                  Authentication Option", <a href="rfc5925.html">RFC 5925</a>, June 2010.

   [<a id="ref-RFC5927" name="ref-RFC5927">RFC5927</a>]      Gont, F., "ICMP Attacks against TCP", <a href="rfc5927.html">RFC 5927</a>,
                  July 2010.

   [<a id="ref-SCTP-SOCKET" name="ref-SCTP-SOCKET">SCTP-SOCKET</a>]  Stewart, R., Poon, K., Tuexen, M., Lei, P., and V.
                  Yasevich, V., "Sockets API Extensions for Stream
                  Control Transmission Protocol (SCTP)", Work in
                  Progress, January 2011.

   [<a id="ref-Silbersack" name="ref-Silbersack">Silbersack</a>]   Silbersack, M., "Improving TCP/IP security through
                  randomization without sacrificing interoperability",
                  EuroBSDCon 2005 Conference.

   [<a id="ref-Stevens" name="ref-Stevens">Stevens</a>]      Stevens, W., "Unix Network Programming, Volume 1:
                  Networking APIs: Socket and XTI", Prentice Hall, 1998.



<span class="grey">Larsen &amp; Gont             Best Current Practice                [Page 26]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-27" id="page-27" name="page-27"> </a>
<span class="grey"><a href="rfc6056.html">RFC 6056</a>           Port Randomization Recommendations       January 2011</span>


   [<a id="ref-TCP-SEC" name="ref-TCP-SEC">TCP-SEC</a>]      Gont, F., "Security Assessment of the Transmission
                  Control Protocol (TCP)", Work in Progress,
                  February 2010.

   [<a id="ref-Watson" name="ref-Watson">Watson</a>]       Watson, P., "Slipping in the Window: TCP Reset
                  Attacks", CanSecWest 2004 Conference.













































<span class="grey">Larsen &amp; Gont             Best Current Practice                [Page 27]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-28" id="page-28" name="page-28"> </a>
<span class="grey"><a href="rfc6056.html">RFC 6056</a>           Port Randomization Recommendations       January 2011</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/Appendix%20A.%20%20Survey%20of%20the%20Algorithms%20in%20Use%20by%20Some%20Popular"></a><a class="selflink" href="#appendix-A" name="appendix-A">Appendix A</a>.  Survey of the Algorithms in Use by Some Popular</span>
             Implementations

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/A.1.%20%20FreeBSD"></a><a class="selflink" href="#appendix-A.1" name="appendix-A.1">A.1</a>.  FreeBSD</span>

   FreeBSD 8.0 implements Algorithm 1, and in response to this document
   now uses a "min_port" of 10000 and a "max_port" of 65535 [<a href="#ref-FreeBSD">FreeBSD</a>].

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/A.2.%20%20Linux"></a><a class="selflink" href="#appendix-A.2" name="appendix-A.2">A.2</a>.  Linux</span>

   Linux 2.6.15-53-386 implements Algorithm 3, with MD5 as the hash
   algorithm.  If the algorithm is faced with the corner-case scenario
   described in <a href="#section-3.5">Section 3.5</a>, Algorithm 1 is used instead [<a href="#ref-Linux">Linux</a>].

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/A.3.%20%20NetBSD"></a><a class="selflink" href="#appendix-A.3" name="appendix-A.3">A.3</a>.  NetBSD</span>

   NetBSD 5.0.1 does not obfuscate its ephemeral port numbers.  It
   selects ephemeral port numbers from the range 49152-65535, starting
   from port 65535, and decreasing the port number for each ephemeral
   port number selected [<a href="#ref-NetBSD">NetBSD</a>].

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/A.4.%20%20OpenBSD"></a><a class="selflink" href="#appendix-A.4" name="appendix-A.4">A.4</a>.  OpenBSD</span>

   OpenBSD 4.2 implements Algorithm 1, with a "min_port" of 1024 and a
   "max_port" of 49151.  [<a href="#ref-OpenBSD">OpenBSD</a>]

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/A.5.%20%20OpenSolaris"></a><a class="selflink" href="#appendix-A.5" name="appendix-A.5">A.5</a>.  OpenSolaris</span>

   OpenSolaris 2009.06 implements Algorithm 1, with a "min_port" of
   32768 and a "max_port" of 65535 [<a href="#ref-OpenSolaris">OpenSolaris</a>].





















<span class="grey">Larsen &amp; Gont             Best Current Practice                [Page 28]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-29" id="page-29" name="page-29"> </a>
<span class="grey"><a href="rfc6056.html">RFC 6056</a>           Port Randomization Recommendations       January 2011</span>


Authors' Addresses

   Michael Vittrup Larsen
   Tieto
   Skanderborgvej 232
   Aarhus  DK-8260
   Denmark

   Phone: +45 8938 5100
   EMail: michael.larsen@tieto.com


   Fernando Gont
   Universidad Tecnologica Nacional / Facultad Regional Haedo
   Evaristo Carriego 2644
   Haedo, Provincia de Buenos Aires  1706
   Argentina

   Phone: +54 11 4650 8472
   EMail: fernando@gont.com.ar































Larsen &amp; Gont             Best Current Practice                [Page 29]

</pre><br/>
    <span class="noprint"><small><small>Html markup produced by rfcmarkup 1.126, available from
      <a href="https://tools.ietf.org/tools/rfcmarkup/">https://tools.ietf.org/tools/rfcmarkup/</a>
    </small></small></span>
  </div>




</body><!-- Mirrored from tools.ietf.org/html/rfc6056 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 06 Mar 2018 23:18:32 GMT --></html>