<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml"><!-- Mirrored from tools.ietf.org/html/rfc6897 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 06 Mar 2018 23:18:26 GMT --><!-- Added by HTTrack --><head><meta content="text/html;charset=utf-8" http-equiv="content-type"/><!-- /Added by HTTrack -->

    <meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
    <meta content="index,follow" name="robots"/>
    <meta content="rfcmarkup version 1.126" name="creator"/>
    <link href="http://purl.org/dc/elements/1.1/" rel="schema.DC"/>
<meta content="draft-scharf-mptcp-api" name="DC.Relation.Replaces"/>
<meta content="urn:ietf:rfc:6897" name="DC.Identifier"/>
<meta content="March, 2013" name="DC.Date.Issued"/>
<meta content="Ford, Alan" name="DC.Creator"/>
<meta content="Scharf, Michael" name="DC.Creator"/>
<meta content="Multipath TCP (MPTCP) adds the capability of using multiple paths to a
regular TCP session. Even though it is designed to be totally backward
compatible to applications, the data transport differs compared to
regular TCP, and there are several additional degrees of freedom that
applications may wish to exploit. This document summarizes the impact
that MPTCP may have on applications, such as changes in performance.
Furthermore, it discusses compatibility issues of MPTCP in combination
with non-MPTCP-aware applications. Finally, the document describes a
basic application interface that is a simple extension of TCP's
interface for MPTCP-aware applications." name="DC.Description.Abstract"/>
<meta content="Multipath TCP (MPTCP) Application Interface Considerations" name="DC.Title"/>

    <link href="https://tools.ietf.org/images/rfc.png" rel="icon" type="image/png"/>
    <link href="https://tools.ietf.org/images/rfc.png" rel="shortcut icon" type="image/png"/>
    <title>RFC 6897 - Multipath TCP (MPTCP) Application Interface Considerations</title>
    
    
    <style type="text/css">
	@media only screen 
	  and (min-width: 992px)
	  and (max-width: 1199px) {
	    body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 768px)
	  and (max-width: 991px) {
            body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 480px)
	  and (max-width: 767px) {
            body { font-size: 11pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (max-width: 479px) {
            body { font-size: 8pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-device-width : 375px) 
	  and (max-device-width : 667px) {
            body { font-size: 9.5pt; }
            div.content { width: 96ex; margin: 0 1px; }
        }
	@media only screen 
	  and (min-device-width: 1200px) {
            body { font-size: 10pt; margin: 0 4em; }
            div.content { width: 96ex; margin: 0; }
        }
        h1, h2, h3, h4, h5, h6, .h1, .h2, .h3, .h4, .h5, .h6 {
	    font-weight: bold;
            line-height: 0pt;
            display: inline;
            white-space: pre;
            font-family: monospace;
            font-size: 1em;
	    font-weight: bold;
        }
        pre {
            font-size: 1em;
            margin-top: 0px;
            margin-bottom: 0px;
        }
	.pre {
	    white-space: pre;
	    font-family: monospace;
	}
	.header{
	    font-weight: bold;
	}
        .newpage {
            page-break-before: always;
        }
        .invisible {
            text-decoration: none;
            color: white;
        }
        a.selflink {
          color: black;
          text-decoration: none;
        }
        @media print {
            body {
                font-family: monospace;
                font-size: 10.5pt;
            }
            h1, h2, h3, h4, h5, h6 {
                font-size: 1em;
            }
        
            a:link, a:visited {
                color: inherit;
                text-decoration: none;
            }
            .noprint {
                display: none;
            }
        }
	@media screen {
	    .grey, .grey a:link, .grey a:visited {
		color: #777;
	    }
            .docinfo {
                background-color: #EEE;
            }
            .top {
                border-top: 7px solid #EEE;
            }
            .bgwhite  { background-color: white; }
            .bgred    { background-color: #F44; }
            .bggrey   { background-color: #666; }
            .bgbrown  { background-color: #840; }            
            .bgorange { background-color: #FA0; }
            .bgyellow { background-color: #EE0; }
            .bgmagenta{ background-color: #F4F; }
            .bgblue   { background-color: #66F; }
            .bgcyan   { background-color: #4DD; }
            .bggreen  { background-color: #4F4; }

            .legend   { font-size: 90%; }
            .cplate   { font-size: 70%; border: solid grey 1px; }
	}
    </style>
    <!--[if IE]>
    <style>
    body {
       font-size: 13px;
       margin: 10px 10px;
    }
    </style>
    <![endif]-->

    <script type="text/javascript"><!--
    function addHeaderTags() {
	var spans = document.getElementsByTagName("span");
	for (var i=0; i < spans.length; i++) {
	    var elem = spans[i];
	    if (elem) {
		var level = elem.getAttribute("class");
                if (level == "h1" || level == "h2" || level == "h3" || level == "h4" || level == "h5" || level == "h6") {
                    elem.innerHTML = "<"+level+">"+elem.innerHTML+"</"+level+">";		
                }
	    }
	}
    }
    var legend_html = "Colour legend:<br />      <table>         <tr><td>Unknown:</td>                   <td><span class='cplate bgwhite'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft:</td>                     <td><span class='cplate bgred'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Informational:</td>             <td><span class='cplate bgorange'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Experimental:</td>              <td><span class='cplate bgyellow'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Best Common Practice:</td>      <td><span class='cplate bgmagenta'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Proposed Standard:</td>         <td><span class='cplate bgblue'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft Standard (old designation):</td> <td><span class='cplate bgcyan'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Internet Standard:</td>         <td><span class='cplate bggreen'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Historic:</td>                  <td><span class='cplate bggrey'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Obsolete:</td>                  <td><span class='cplate bgbrown'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>     </table>";
    function showElem(id) {
        var elem = document.getElementById(id);
        elem.innerHTML = eval(id+"_html");
        elem.style.visibility='visible';
    }
    function hideElem(id) {
        var elem = document.getElementById(id);
        elem.style.visibility='hidden';        
        elem.innerHTML = "";
    }
    // -->
    </script>
</head>
<body onload="addHeaderTags()">
  <div class="content">
   <div style="height: 13px;">
      <div class="pre noprint docinfo bgorange" onclick="showElem('legend');" onmouseout="hideElem('legend')" onmouseover="this.style.cursor='pointer';" style="height: 6px; position: absolute;" title="Click for colour legend.">                                                                        </div>
      <div class="docinfo noprint pre legend" id="legend" onmouseout="hideElem('legend');" onmouseover="showElem('legend');" style="position:absolute; top: 4px; left: 4ex; visibility:hidden; background-color: white; padding: 4px 9px 5px 7px; border: solid #345 1px; ">
      </div>
   </div>
<span class="pre noprint docinfo top">[<a href="index.html" title="Document search and retrieval page">Docs</a>] [<a href="https://tools.ietf.org/rfc/rfc6897.txt" title="Plaintext version of this document">txt</a>|<a href="https://tools.ietf.org/pdf/rfc6897" title="PDF version of this document">pdf</a>] [<a href="https://tools.ietf.org/html/draft-ietf-mptcp-api" title="draft-ietf-mptcp-api">draft-ietf-mptc...</a>] [<a href="https://datatracker.ietf.org/doc/rfc6897" title="IESG Datatracker information for this document">Tracker</a>] [<a href="https://tools.ietf.org/rfcdiff?difftype=--hwdiff&amp;url2=rfc6897" title="Inline diff (wdiff)">Diff1</a>] [<a href="https://tools.ietf.org/rfcdiff?url2=rfc6897" title="Side-by-side diff">Diff2</a>]         </span><br/>
<span class="pre noprint docinfo">                                                                        </span><br/>
<span class="pre noprint docinfo">                                                           INFORMATIONAL</span><br/>
<span class="pre noprint docinfo">                                                                        </span><br/>
<pre>Internet Engineering Task Force (IETF)                         M. Scharf
Request for Comments: 6897                      Alcatel-Lucent Bell Labs
Category: Informational                                          A. Ford
ISSN: 2070-1721                                                    Cisco
                                                              March 2013


       <span class="h1">Multipath TCP (MPTCP) Application Interface Considerations</span>

Abstract

   Multipath TCP (MPTCP) adds the capability of using multiple paths to
   a regular TCP session.  Even though it is designed to be totally
   backward compatible to applications, the data transport differs
   compared to regular TCP, and there are several additional degrees of
   freedom that applications may wish to exploit.  This document
   summarizes the impact that MPTCP may have on applications, such as
   changes in performance.  Furthermore, it discusses compatibility
   issues of MPTCP in combination with non-MPTCP-aware applications.
   Finally, the document describes a basic application interface that is
   a simple extension of TCP's interface for MPTCP-aware applications.

Status of This Memo

   This document is not an Internet Standards Track specification; it is
   published for informational purposes.

   This document is a product of the Internet Engineering Task Force
   (IETF).  It represents the consensus of the IETF community.  It has
   received public review and has been approved for publication by the
   Internet Engineering Steering Group (IESG).  Not all documents
   approved by the IESG are a candidate for any level of Internet
   Standard; see <a href="rfc5741.html#section-2">Section 2 of RFC 5741</a>.

   Information about the current status of this document, any errata,
   and how to provide feedback on it may be obtained at
   <a href="http://www.rfc-editor.org/info/rfc6897">http://www.rfc-editor.org/info/rfc6897</a>.














<span class="grey">Scharf &amp; Ford                 Informational                     [Page 1]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-2" id="page-2" name="page-2"> </a>
<span class="grey"><a href="rfc6897.html">RFC 6897</a>                        MPTCP API                     March 2013</span>


Copyright Notice

   Copyright (c) 2013 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to <a href="https://tools.ietf.org/html/bcp78">BCP 78</a> and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (<a href="http://trustee.ietf.org/license-info">http://trustee.ietf.org/license-info</a>) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.

Table of Contents

   <a href="#section-1">1</a>. Introduction ....................................................<a href="#page-3">3</a>
   <a href="#section-2">2</a>. Terminology .....................................................<a href="#page-4">4</a>
   <a href="#section-3">3</a>. Comparison of MPTCP and Regular TCP .............................<a href="#page-5">5</a>
      <a href="#section-3.1">3.1</a>. Effect on Performance ......................................<a href="#page-5">5</a>
           <a href="#section-3.1.1">3.1.1</a>. Throughput ..........................................<a href="#page-5">5</a>
           <a href="#section-3.1.2">3.1.2</a>. Delay ...............................................<a href="#page-6">6</a>
           <a href="#section-3.1.3">3.1.3</a>. Resilience ..........................................<a href="#page-7">7</a>
      <a href="#section-3.2">3.2</a>. Potential Problems .........................................<a href="#page-8">8</a>
           <a href="#section-3.2.1">3.2.1</a>. Impact of Middleboxes ...............................<a href="#page-8">8</a>
           3.2.2. Dealing with Multiple Addresses inside
                  Applications ........................................<a href="#page-9">9</a>
           <a href="#section-3.2.3">3.2.3</a>. Security Implications ..............................<a href="#page-10">10</a>
   <a href="#section-4">4</a>. Operation of MPTCP with Legacy Applications ....................<a href="#page-10">10</a>
      <a href="#section-4.1">4.1</a>. Overview of the MPTCP Network Stack .......................<a href="#page-10">10</a>
      <a href="#section-4.2">4.2</a>. Address Issues ............................................<a href="#page-11">11</a>
           <a href="#section-4.2.1">4.2.1</a>. Specification of Addresses by Applications .........<a href="#page-11">11</a>
           <a href="#section-4.2.2">4.2.2</a>. Querying of Addresses by Applications ..............<a href="#page-12">12</a>
      <a href="#section-4.3">4.3</a>. MPTCP Connection Management ...............................<a href="#page-13">13</a>
           <a href="#section-4.3.1">4.3.1</a>. Reaction to Close Call by Application ..............<a href="#page-13">13</a>
           <a href="#section-4.3.2">4.3.2</a>. Other Connection Management Functions ..............<a href="#page-13">13</a>
      <a href="#section-4.4">4.4</a>. Socket Option Issues ......................................<a href="#page-13">13</a>
           <a href="#section-4.4.1">4.4.1</a>. General Guideline ..................................<a href="#page-13">13</a>
           <a href="#section-4.4.2">4.4.2</a>. Disabling of the Nagle Algorithm ...................<a href="#page-13">13</a>
           <a href="#section-4.4.3">4.4.3</a>. Buffer Sizing ......................................<a href="#page-14">14</a>
           <a href="#section-4.4.4">4.4.4</a>. Other Socket Options ...............................<a href="#page-14">14</a>
      <a href="#section-4.5">4.5</a>. Default Enabling of MPTCP .................................<a href="#page-14">14</a>
      <a href="#section-4.6">4.6</a>. Summary of Advice to Application Developers ...............<a href="#page-15">15</a>







<span class="grey">Scharf &amp; Ford                 Informational                     [Page 2]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-3" id="page-3" name="page-3"> </a>
<span class="grey"><a href="rfc6897.html">RFC 6897</a>                        MPTCP API                     March 2013</span>


   <a href="#section-5">5</a>. Basic API for MPTCP-Aware Applications .........................<a href="#page-15">15</a>
      <a href="#section-5.1">5.1</a>. Design Considerations .....................................<a href="#page-15">15</a>
      <a href="#section-5.2">5.2</a>. Requirements on the Basic MPTCP API .......................<a href="#page-16">16</a>
      <a href="#section-5.3">5.3</a>. Sockets Interface Extensions by the Basic MPTCP API .......<a href="#page-17">17</a>
           <a href="#section-5.3.1">5.3.1</a>. Overview ...........................................<a href="#page-17">17</a>
           <a href="#section-5.3.2">5.3.2</a>. Enabling and Disabling of MPTCP ....................<a href="#page-19">19</a>
           <a href="#section-5.3.3">5.3.3</a>. Binding MPTCP to Specified Addresses ...............<a href="#page-19">19</a>
           <a href="#section-5.3.4">5.3.4</a>. Querying the MPTCP Subflow Addresses ...............<a href="#page-20">20</a>
           <a href="#section-5.3.5">5.3.5</a>. Getting a Unique Connection Identifier .............<a href="#page-20">20</a>
   <a href="#section-6">6</a>. Other Compatibility Issues .....................................<a href="#page-21">21</a>
      <a href="#section-6.1">6.1</a>. Usage of TLS over MPTCP ...................................<a href="#page-21">21</a>
      <a href="#section-6.2">6.2</a>. Usage of the SCTP Sockets API .............................<a href="#page-21">21</a>
      <a href="#section-6.3">6.3</a>. Incompatibilities with Other Multihoming Solutions ........<a href="#page-21">21</a>
      <a href="#section-6.4">6.4</a>. Interactions with DNS .....................................<a href="#page-22">22</a>
   <a href="#section-7">7</a>. Security Considerations ........................................<a href="#page-22">22</a>
   <a href="#section-8">8</a>. Conclusion .....................................................<a href="#page-23">23</a>
   <a href="#section-9">9</a>. Acknowledgments ................................................<a href="#page-23">23</a>
   <a href="#section-10">10</a>. References ....................................................<a href="#page-24">24</a>
      <a href="#section-10.1">10.1</a>. Normative References .....................................<a href="#page-24">24</a>
      <a href="#section-10.2">10.2</a>. Informative References ...................................<a href="#page-24">24</a>
   <a href="#appendix-A">Appendix A</a>. Requirements on a Future Advanced MPTCP API ...........<a href="#page-26">26</a>
     <a href="#appendix-A.1">A.1</a>. Design Considerations ......................................<a href="#page-26">26</a>
     <a href="#appendix-A.2">A.2</a>. MPTCP Usage Scenarios and Application Requirements .........<a href="#page-27">27</a>
     <a href="#appendix-A.3">A.3</a>. Potential Requirements on an Advanced MPTCP API ............<a href="#page-29">29</a>
     <a href="#appendix-A.4">A.4</a>. Integration with the SCTP Sockets API ......................<a href="#page-30">30</a>

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/1.%20%20Introduction"></a><a class="selflink" href="#section-1" name="section-1">1</a>.  Introduction</span>

   Multipath TCP adds the capability of using multiple paths to a
   regular TCP session [<a href="#ref-1" title='"Transmission Control Protocol"'>1</a>].  The motivations for this extension include
   increasing throughput, overall resource utilization, and resilience
   to network failure, and these motivations are discussed, along with
   high-level design decisions, as part of the multipath TCP
   architecture [<a href="#ref-4" title='"Architectural Guidelines for Multipath TCP Development"'>4</a>].  MPTCP [<a href="#ref-5" title='"TCP Extensions for Multipath Operation with Multiple Addresses"'>5</a>] offers the same reliable, in-order,
   byte-stream transport as TCP and is designed to be backward
   compatible with both applications and the network layer.  It requires
   support inside the network stack of both endpoints.

   This document first presents the effects that MPTCP may have on
   applications, such as performance changes compared to regular TCP.
   Second, it defines the interoperation of MPTCP and applications that
   are unaware of the multipath transport.  MPTCP is designed to be
   usable without any application changes, but some compatibility issues
   have to be taken into account.  Third, this memo specifies a basic
   Application Programming Interface (API) for MPTCP-aware applications.
   The API presented here is an extension to the regular TCP API to





<span class="grey">Scharf &amp; Ford                 Informational                     [Page 3]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-4" id="page-4" name="page-4"> </a>
<span class="grey"><a href="rfc6897.html">RFC 6897</a>                        MPTCP API                     March 2013</span>


   allow an MPTCP-aware application the equivalent level of control and
   access to information of an MPTCP connection that would be possible
   with the standard TCP API on a regular TCP connection.

   The de facto standard API for TCP/IP applications is the "sockets"
   interface [<a href="#ref-8" title='"IEEE Standard for Information Technology -- Portable Operating System Interface (POSIX) Base Specifications, Issue 7"'>8</a>].  This document provides an abstract definition of
   MPTCP-specific extensions to this interface.  These are operations
   that can be used by an application to get or set additional MPTCP-
   specific information on a socket, in order to provide an equivalent
   level of information and control over MPTCP as exists for an
   application using regular TCP.  It is up to the applications, high-
   level programming languages, or libraries to decide whether to use
   these optional extensions.  For instance, an application may want to
   turn on or off the MPTCP mechanism for certain data transfers or
   limit its use to certain interfaces.  The abstract specification is
   in line with the Portable Operating System Interface (POSIX) standard
   [<a href="#ref-8" title='"IEEE Standard for Information Technology -- Portable Operating System Interface (POSIX) Base Specifications, Issue 7"'>8</a>] as much as possible.

   An advanced API for MPTCP is outside the scope of this document.
   Such an advanced API could offer a more fine-grained control over
   multipath transport functions and policies.  The appendix includes
   a brief, non-compulsory list of potential features of such an
   advanced API.

   There can be interactions or incompatibilities of MPTCP with other
   APIs or sockets interface extensions, which are discussed later in
   this document.  Some network stack implementations, especially on
   mobile devices, have centralized connection managers or other
   higher-level APIs to solve multi-interface issues, as surveyed in
   [<a href="#ref-15" title='"Current Practices for Multiple- Interface Hosts"'>15</a>].  Their interaction with MPTCP is outside the scope of this
   document.

   The target readers of this document are application developers whose
   software may benefit significantly from MPTCP.  This document also
   provides the necessary information for developers of MPTCP to
   implement the API in a TCP/IP network stack.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/2.%20%20Terminology"></a><a class="selflink" href="#section-2" name="section-2">2</a>.  Terminology</span>

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in [<a href="#ref-3" title='"Key words for use in RFCs to Indicate Requirement Levels"'>3</a>].

   This document uses the MPTCP terminology introduced in [<a href="#ref-5" title='"TCP Extensions for Multipath Operation with Multiple Addresses"'>5</a>].







<span class="grey">Scharf &amp; Ford                 Informational                     [Page 4]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-5" id="page-5" name="page-5"> </a>
<span class="grey"><a href="rfc6897.html">RFC 6897</a>                        MPTCP API                     March 2013</span>


   Concerning the API towards applications, the following terms are
   distinguished:

   o  Legacy API: The interface towards TCP that is currently used by
      applications.  This document explains the effect of MPTCP for such
      applications, as well as resulting issues.

   o  Basic API: A simple extension of TCP's interface for applications
      that are aware of MPTCP.  This document abstractly describes this
      interface, which provides access to multipath address information
      and a level of control equivalent to regular TCP.

   o  Advanced API: An API that offers more fine-grained control over
      the behavior of MPTCP.  Its specification is outside the scope of
      this document.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/3.%20%20Comparison%20of%20MPTCP%20and%20Regular%20TCP"></a><a class="selflink" href="#section-3" name="section-3">3</a>.  Comparison of MPTCP and Regular TCP</span>

   This section discusses the effect of MPTCP on performance as seen by
   an application, in comparison to what may be expected from the use of
   regular TCP.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.1.%20%20Effect%20on%20Performance"></a><a class="selflink" href="#section-3.1" name="section-3.1">3.1</a>.  Effect on Performance</span>

   One of the key goals of adding multipath capability to TCP is to
   improve the performance of a transport connection by load
   distribution over separate subflows across potentially disjoint
   paths.  Furthermore, it is an explicit goal of MPTCP that it provides
   a connection that performs at least as well as one using single-path
   TCP.  A corresponding congestion control algorithm is described in
   [<a href="#ref-7" title='"Coupled Congestion Control for Multipath Transport Protocols"'>7</a>].  The following sections summarize the performance effect of
   MPTCP as seen by an application.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/3.1.1.%20%20Throughput"></a><a class="selflink" href="#section-3.1.1" name="section-3.1.1">3.1.1</a>.  Throughput</span>

   The most obvious performance improvement that can be expected from
   the use of MPTCP is an increase in throughput, since MPTCP will pool
   more than one path (where available) between two endpoints.  This
   will usually provide as great or greater bandwidth for an
   application, even though exceptions may exist, e.g., due to
   differences in the congestion control dynamics.  For instance, if a
   new subflow is started, the short-term throughput can be smaller than
   the theoretical optimum.  If there are shared bottlenecks between the
   flows, then the congestion control algorithms will in most cases
   ensure that load is evenly spread amongst regular and multipath TCP
   sessions, so that no end user receives worse performance than if all
   were using single-path TCP.  There are some known corner cases in
   which an upgrade to MPTCP can affect other users [<a href="#ref-21" title='"Performance Issues with MPTCP"'>21</a>].



<span class="grey">Scharf &amp; Ford                 Informational                     [Page 5]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-6" id="page-6" name="page-6"> </a>
<span class="grey"><a href="rfc6897.html">RFC 6897</a>                        MPTCP API                     March 2013</span>


   This performance increase additionally means that an MPTCP session
   could achieve throughput that is greater than the capacity of a
   single interface on the device.  If any applications make assumptions
   about interfaces due to throughput, they must take this into account
   (although an MPTCP implementation must always respect an
   application's request for a particular interface).

   Furthermore, the flexibility of MPTCP to add and remove subflows as
   paths change availability could lead to a greater variation, and more
   frequent change, in connection bandwidth.  Applications that adapt to
   available bandwidth (such as video and audio streaming) may need to
   adjust some of their assumptions to most effectively take this into
   account.

   The transport of MPTCP signaling information results in a small
   overhead.  The use of MPTCP instead of a single TCP connection
   therefore results in a smaller goodput.  Also, if multiple subflows
   share a same bottleneck, this overhead slightly reduces the capacity
   that is available for data transport.  Yet, this potential reduction
   of throughput will be negligible in many usage scenarios, and the
   protocol contains optimizations in its design so that this overhead
   is minimal.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/3.1.2.%20%20Delay"></a><a class="selflink" href="#section-3.1.2" name="section-3.1.2">3.1.2</a>.  Delay</span>

   The benefits of MPTCP regarding throughput and resilience may come at
   some cost regarding data delivery delay and delay jitter.

   If the delays on the constituent subflows of an MPTCP connection
   differ, the jitter perceivable to an application may appear higher as
   the data are spread across the subflows.  Although MPTCP will ensure
   in-order delivery to the application, the data delivery could be more
   bursty than may be usual with single-path TCP, in particular on
   highly asymmetric paths.

   Applications with high real-time requirements might be affected by
   such a scenario.  One possible remedy is to disable MPTCP for such
   jitter-sensitive applications, either by using the basic API defined
   in this document, or by other means, such as system policies.

   However, the actual delay and jitter of data transport over MPTCP
   depend on the scheduling and congestion control algorithms used for
   sending data, as well as the heuristics to establish and shut down
   subflows.  A sender can implement strategies to minimize the delay
   jitter seen by applications, but this requires an accurate estimation
   of the path characteristics.  If the scheduling decisions are
   suboptimal or if assumptions about the path characteristics turn out
   to be wrong, delay jitter may be increased and affect delay-sensitive



<span class="grey">Scharf &amp; Ford                 Informational                     [Page 6]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-7" id="page-7" name="page-7"> </a>
<span class="grey"><a href="rfc6897.html">RFC 6897</a>                        MPTCP API                     March 2013</span>


   applications.  In general, for a delay-sensitive application, it
   would be desirable to select an appropriate congestion control
   algorithm for its traffic needs.

   Alternatively, MPTCP could be used in high-reliability, rather than
   high-throughput, modes of operation, such as by mirroring traffic on
   subflows, or by only using additional subflows for hot standby.
   These methods of traffic scheduling would not cause delay variation
   in the same way.  These additional modes, and the selection of
   alternative scheduling algorithms, would need to be indicated by an
   advanced API, the specification of which requires further analysis
   and is outside the scope of this document.

   If data transport on one subflow fails, the retransmissions inside
   MPTCP could affect the delivery delay to the application.  Yet,
   without MPTCP that data or the whole connection might have been lost,
   and other reliability mechanisms (e.g., application-level recovery)
   would likely have an even larger delay impact.

   In addition, applications that make round-trip time (RTT) estimates
   at the application level may have some issues.  Whilst the average
   delay calculated will be accurate, whether this is useful for an
   application will depend on what it requires this information for.  If
   a new application wishes to derive such information, it should
   consider how multiple subflows may affect its measurements and thus
   how it may wish to respond.  In such a case, an application may wish
   to express its scheduling preferences, as described later in this
   document.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/3.1.3.%20%20Resilience"></a><a class="selflink" href="#section-3.1.3" name="section-3.1.3">3.1.3</a>.  Resilience</span>

   Another performance improvement through the use of MPTCP is better
   resilience.  The use of multiple subflows simultaneously means that
   if one should fail, all traffic will move to the remaining
   subflow(s), and additionally any lost packets can be retransmitted on
   these subflows.

   As one special case, MPTCP can be used with only one active subflow
   at a given point in time.  In that case, resilience compared to
   single-path TCP is improved.  MPTCP also supports make-before-break
   and break-before-make handovers between subflows.  In both cases, the
   MPTCP connection can survive an unavailability or change of an IP
   address (e.g., due to shutdown of an interface or handover).  MPTCP
   closes or resets the MPTCP connection separately from the individual
   subflows, as described in [<a href="#ref-5" title='"TCP Extensions for Multipath Operation with Multiple Addresses"'>5</a>].

   Subflow failure may be caused by issues within the network, which an
   application would be unaware of, or interface failure on the node.



<span class="grey">Scharf &amp; Ford                 Informational                     [Page 7]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-8" id="page-8" name="page-8"> </a>
<span class="grey"><a href="rfc6897.html">RFC 6897</a>                        MPTCP API                     March 2013</span>


   An application may, under certain circumstances, be in a position to
   be aware of such failure (e.g., by radio signal strength, or simply
   an interface enabled flag), and so must not make assumptions of an
   MPTCP flow's stability based on this.  An MPTCP implementation must
   never override an application's request for a given interface,
   however, so the cases where this issue may be applicable are limited.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.2.%20%20Potential%20Problems"></a><a class="selflink" href="#section-3.2" name="section-3.2">3.2</a>.  Potential Problems</span>

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/3.2.1.%20%20Impact%20of%20Middleboxes"></a><a class="selflink" href="#section-3.2.1" name="section-3.2.1">3.2.1</a>.  Impact of Middleboxes</span>

   MPTCP has been designed to pass through the majority of middleboxes.
   Empirical evidence suggests that new TCP options can successfully be
   used on most paths in the Internet [<a href="#ref-22" title='"Is it Still Possible to Extend TCP?"'>22</a>].  Nevertheless, some
   middleboxes may still refuse to pass MPTCP messages due to the
   presence of TCP options, or they may strip TCP options.  If this is
   the case, MPTCP falls back to regular TCP.  Although this will not
   create a problem for the application (its communication will be set
   up either way), there may be additional (and indeed, user-
   perceivable) delay while the first handshake fails.  Therefore, an
   alternative approach could be to try both MPTCP and regular TCP
   connection attempts at the same time and respond to whichever replies
   first, in a fashion similar to the "Happy Eyeballs" mechanism for
   IPv6 [<a href="#ref-16" title='"Happy Eyeballs: Success with Dual-Stack Hosts"'>16</a>].  One could also apply a shorter timeout on the MPTCP
   attempt and thus reduce the setup delay if fallback to regular TCP is
   needed.

   An MPTCP implementation can learn the rate of MPTCP connection
   attempt successes or failures to particular hosts or networks, and on
   particular interfaces, and could therefore learn heuristics of when
   and when not to use MPTCP.  A detailed discussion of the various
   fallback mechanisms, for failures occurring at different points in
   the connection, is presented in [<a href="#ref-5" title='"TCP Extensions for Multipath Operation with Multiple Addresses"'>5</a>].  It must be emphasized that all
   such heuristics could also fail, and learning can be difficult in
   certain environments, e.g., if the host is mobile.

   There may also be middleboxes that transparently change the length of
   content.  If such middleboxes are present, MPTCP's reassembly of the
   byte stream in the receiver is difficult.  Still, MPTCP can detect
   such middleboxes and then fall back to regular TCP.  An overview of
   the impact of middleboxes is presented in [<a href="#ref-4" title='"Architectural Guidelines for Multipath TCP Development"'>4</a>], and MPTCP's mechanisms
   to work around these issues are presented and discussed in [<a href="#ref-5" title='"TCP Extensions for Multipath Operation with Multiple Addresses"'>5</a>].

   MPTCP can also have other unexpected implications.  For instance,
   intrusion detection systems could be triggered.  A full analysis of
   MPTCP's impact on such middleboxes is for further study after
   deployment experiments.




<span class="grey">Scharf &amp; Ford                 Informational                     [Page 8]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-9" id="page-9" name="page-9"> </a>
<span class="grey"><a href="rfc6897.html">RFC 6897</a>                        MPTCP API                     March 2013</span>


<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/3.2.2.%20%20Dealing%20with%20Multiple%20Addresses%20inside%20Applications"></a><a class="selflink" href="#section-3.2.2" name="section-3.2.2">3.2.2</a>.  Dealing with Multiple Addresses inside Applications</span>

   In regular TCP, there is a one-to-one mapping of the sockets
   interface to a flow through a network.  Since MPTCP can make use of
   multiple subflows, applications cannot implicitly rely on this
   one-to-one mapping any more.

   Whilst this doesn't matter for most applications, some applications
   may need to adapt to the presence of multiple addresses, because
   implicit assumptions are outdated.  In this section, selected
   examples for resulting issues are discussed.  The question of whether
   such implicit assumptions matter is an application-level decision,
   and this document only provides general guidance and a basic API to
   retrieve relevant information.

   A few applications require the transport to be along a single path;
   they can disable the use of MPTCP as described later in this
   document.  Examples include monitoring tools that want to measure the
   available bandwidth on a path, or routing protocols such as BGP that
   require the use of a specific link.

   Certain applications store the IP addresses of TCP connections, e.g.,
   by logging mechanisms.  Such logging mechanisms will continue to work
   with MPTCP, but two important aspects have to be mentioned: First, if
   the application is not aware of MPTCP, it will use the existing
   interface to the network stack.  This implies that an MPTCP-unaware
   application will track the IP addresses of the first subflow only.
   IP addresses used by follow-up subflows will be ignored.  Second, an
   MPTCP-aware application can use the basic API described in this
   document to monitor the IP addresses of all subflows, e.g., for
   logging mechanisms.  If an MPTCP connection uses several subflows,
   this will possibly imply that data structures have to be adapted and
   that the amount of data that has to be logged and stored per
   connection will increase.

   An MPTCP implementation may choose to maintain an MPTCP connection
   even if the IP address of the original subflow is no longer allocated
   to a host, depending on the policy concerning the first subflow
   (fate-sharing; see <a href="#section-4.2.2">Section 4.2.2</a>).  In this case, the IP address
   exposed to an MPTCP-unaware application can differ from the addresses
   actually being used by MPTCP.  It is even possible that the IP
   address gets assigned to another host during the lifetime of an MPTCP
   connection.  As further discussed below, this could be an issue if
   the IP addresses are exchanged by applications, e.g., inside the
   application protocol.  This issue can be addressed by enabling fate-
   sharing, at the cost of resilience, because the MPTCP connection then
   cannot close the initial subflow.




<span class="grey">Scharf &amp; Ford                 Informational                     [Page 9]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-10" id="page-10" name="page-10"> </a>
<span class="grey"><a href="rfc6897.html">RFC 6897</a>                        MPTCP API                     March 2013</span>


<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/3.2.3.%20%20Security%20Implications"></a><a class="selflink" href="#section-3.2.3" name="section-3.2.3">3.2.3</a>.  Security Implications</span>

   The support for multiple IP addresses within one MPTCP connection can
   result in additional security vulnerabilities, such as possibilities
   for attackers to hijack connections.  The protocol design of MPTCP
   minimizes this risk.  An attacker on one of the paths can cause harm,
   but this is hardly an additional security risk compared to single-
   path TCP, which is vulnerable to man-in-the-middle attacks as well.
   A detailed threat analysis of MPTCP is published in [<a href="#ref-6" title='"Threat Analysis for TCP Extensions for Multipath Operation with Multiple Addresses"'>6</a>].

   Impact on Transport Layer Security (TLS) is discussed in <a href="#section-6.1">Section 6.1</a>.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/4.%20%20Operation%20of%20MPTCP%20with%20Legacy%20Applications"></a><a class="selflink" href="#section-4" name="section-4">4</a>.  Operation of MPTCP with Legacy Applications</span>

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.1.%20%20Overview%20of%20the%20MPTCP%20Network%20Stack"></a><a class="selflink" href="#section-4.1" name="section-4.1">4.1</a>.  Overview of the MPTCP Network Stack</span>

   MPTCP is an extension of TCP, but it is designed to be backward
   compatible for legacy (MPTCP-unaware) applications.  TCP interacts
   with other parts of the network stack via different interfaces.  The
   de facto standard API between TCP and applications is the sockets
   interface.  The position of MPTCP in the protocol stack is
   illustrated in Figure 1.

                     +-------------------------------+
                     |           Application         |
                     +-------------------------------+
                            ^                  |
                  ~~~~~~~~~~|~Sockets Interface|~~~~~~~~~
                            |                  v
                     +-------------------------------+
                     |             MPTCP             |
                     + - - - - - - - + - - - - - - - +
                     | Subflow (TCP) | Subflow (TCP) |
                     +-------------------------------+
                     |       IP      |      IP       |
                     +-------------------------------+

                      Figure 1: MPTCP Protocol Stack

   In general, MPTCP can affect all interfaces that make assumptions
   about the coupling of a TCP connection to a single IP address and TCP
   port pair, to one socket endpoint, to one network interface, or to a
   given path through the network.








<span class="grey">Scharf &amp; Ford                 Informational                    [Page 10]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-11" id="page-11" name="page-11"> </a>
<span class="grey"><a href="rfc6897.html">RFC 6897</a>                        MPTCP API                     March 2013</span>


   This means that there are two classes of applications:

   o  Legacy applications: These applications are unaware of MPTCP and
      use the existing API towards TCP without any changes.  This is the
      default case.

   o  MPTCP-aware applications: These applications indicate support for
      an enhanced MPTCP interface.  This document specifies a minimum
      set of API extensions for such applications.

   In the following sections, it is discussed to what extent MPTCP
   affects legacy applications using the existing sockets API.  The
   existing sockets API implies that applications deal with data
   structures that store, amongst others, the IP addresses and TCP port
   numbers of a TCP connection.  A design objective of MPTCP is that
   legacy applications can continue to use the established sockets API
   without any changes.  However, in MPTCP there is a one-to-many
   mapping between the socket endpoint and the subflows.  This has
   several subtle implications for legacy applications using sockets API
   functions.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.2.%20%20Address%20Issues"></a><a class="selflink" href="#section-4.2" name="section-4.2">4.2</a>.  Address Issues</span>

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/4.2.1.%20%20Specification%20of%20Addresses%20by%20Applications"></a><a class="selflink" href="#section-4.2.1" name="section-4.2.1">4.2.1</a>.  Specification of Addresses by Applications</span>

   During binding, an application can either select a specific address
   or bind to INADDR_ANY.  Furthermore, on some systems other socket
   options (e.g., SO_BINDTODEVICE) can be used to bind to a specific
   interface.  If an application uses a specific address or binds to a
   specific interface, then MPTCP MUST respect this and not interfere in
   the application's choices.  The binding to a specific address or
   interface implies that the application is not aware of MPTCP and will
   disable the use of MPTCP on this connection.  An application that
   wishes to bind to a specific set of addresses with MPTCP must use
   multipath-aware calls to achieve this (as described in
   <a href="#section-5.3.3">Section 5.3.3</a>).

   If an application binds to INADDR_ANY, it is assumed that the
   application does not care which addresses are used locally.  In this
   case, a local policy MAY allow MPTCP to automatically set up multiple
   subflows on such a connection.

   The basic sockets API of MPTCP-aware applications allows the
   expression of further preferences in an MPTCP-compatible way (e.g.,
   binding to a subset of interfaces only).






<span class="grey">Scharf &amp; Ford                 Informational                    [Page 11]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-12" id="page-12" name="page-12"> </a>
<span class="grey"><a href="rfc6897.html">RFC 6897</a>                        MPTCP API                     March 2013</span>


<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/4.2.2.%20%20Querying%20of%20Addresses%20by%20Applications"></a><a class="selflink" href="#section-4.2.2" name="section-4.2.2">4.2.2</a>.  Querying of Addresses by Applications</span>

   Applications can use the getpeername() or getsockname() functions in
   order to retrieve the IP address of the peer or of the local socket.
   These functions can be used for various purposes, including security
   mechanisms, geo-location, or interface checks.  The sockets API was
   designed with an assumption that a socket is using just one address,
   and since this address is visible to the application, the application
   may assume that the information provided by the functions is the same
   during the lifetime of a connection.  However, in MPTCP, unlike in
   TCP, there is a one-to-many mapping of a connection to subflows, and
   subflows can be added and removed while the connection continues to
   exist.  Since the subflow addresses can change, MPTCP cannot expose
   addresses by getpeername() or getsockname() that are both valid and
   constant during the connection's lifetime.

   This problem is addressed as follows: If used by a legacy
   application, the MPTCP stack MUST always return the addresses and
   port numbers of the first subflow of an MPTCP connection, in all
   circumstances, even if that particular subflow is no longer in use.

   As the addresses may not be valid any more if the first subflow is
   closed, the MPTCP stack MAY close the whole MPTCP connection if the
   first subflow is closed (i.e., fate-sharing between the initial
   subflow and the MPTCP connection as a whole).  This fate-sharing
   avoids the reuse of the pair of IP addresses and ports while an MPTCP
   connection is still in progress, but at the cost of reducing the
   utility of MPTCP if IP addresses of the first subflow are not
   available any more (e.g., mobility events).  Whether to close the
   whole MPTCP connection by default SHOULD be controlled by a local
   policy.  Further experiments are needed to investigate its
   implications.

   The functions getpeername() and getsockname() SHOULD also always
   return the addresses of the first subflow if the socket is used by an
   MPTCP-aware application, in order to be consistent with MPTCP-unaware
   applications, and, e.g., also with the Stream Control Transmission
   Protocol (SCTP).  Instead of getpeername() or getsockname(),
   MPTCP-aware applications can use new API calls, described in
   <a href="#section-5.3">Section 5.3</a>, in order to retrieve the full list of address pairs for
   the subflows in use.










<span class="grey">Scharf &amp; Ford                 Informational                    [Page 12]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-13" id="page-13" name="page-13"> </a>
<span class="grey"><a href="rfc6897.html">RFC 6897</a>                        MPTCP API                     March 2013</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.3.%20%20MPTCP%20Connection%20Management"></a><a class="selflink" href="#section-4.3" name="section-4.3">4.3</a>.  MPTCP Connection Management</span>

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/4.3.1.%20%20Reaction%20to%20Close%20Call%20by%20Application"></a><a class="selflink" href="#section-4.3.1" name="section-4.3.1">4.3.1</a>.  Reaction to Close Call by Application</span>

   As described in [<a href="#ref-5" title='"TCP Extensions for Multipath Operation with Multiple Addresses"'>5</a>], MPTCP distinguishes between the closing of
   subflows (by TCP FIN) and closing the whole MPTCP connection
   (by Data FIN).

   When an application closes a socket, e.g., by calling the close()
   function, this indicates that the application has no more data to
   send, like for single-path TCP.  MPTCP will then close the MPTCP
   connection via Data FIN messages.  This is completely transparent for
   an application.

   In summary, the semantics of the close() interface for applications
   are not changed compared to TCP.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/4.3.2.%20%20Other%20Connection%20Management%20Functions"></a><a class="selflink" href="#section-4.3.2" name="section-4.3.2">4.3.2</a>.  Other Connection Management Functions</span>

   In general, an MPTCP connection is maintained separately from
   individual subflows.  MPTCP therefore has internal mechanisms to
   establish, close, or reset the MPTCP connection [<a href="#ref-5" title='"TCP Extensions for Multipath Operation with Multiple Addresses"'>5</a>].  These
   mechanisms provide equivalent functions like single-path TCP and can
   be mapped accordingly.  Therefore, these MPTCP internals do not
   affect the application interface.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.4.%20%20Socket%20Option%20Issues"></a><a class="selflink" href="#section-4.4" name="section-4.4">4.4</a>.  Socket Option Issues</span>

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/4.4.1.%20%20General%20Guideline"></a><a class="selflink" href="#section-4.4.1" name="section-4.4.1">4.4.1</a>.  General Guideline</span>

   The existing sockets API includes options that modify the behavior of
   sockets and their underlying communications protocols.  Various
   socket options exist on the socket, TCP, and IP level.  The value of
   an option can usually be set by the setsockopt() system function.
   The getsockopt() function gets information.  In general, the existing
   sockets interface functions cannot configure each MPTCP subflow
   individually.  In order to be backward compatible, existing APIs
   therefore SHOULD apply to all subflows within one connection, as far
   as possible.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/4.4.2.%20%20Disabling%20of%20the%20Nagle%20Algorithm"></a><a class="selflink" href="#section-4.4.2" name="section-4.4.2">4.4.2</a>.  Disabling of the Nagle Algorithm</span>

   One commonly used TCP socket option (TCP_NODELAY) disables the Nagle
   algorithm as described in [<a href="#ref-2" title='"Requirements for Internet Hosts - Communication Layers"'>2</a>].  This option is also specified in the
   POSIX standard [<a href="#ref-8" title='"IEEE Standard for Information Technology -- Portable Operating System Interface (POSIX) Base Specifications, Issue 7"'>8</a>].  Applications can use this option in combination
   with MPTCP in exactly the same way.  It then SHOULD disable the Nagle
   algorithm for the MPTCP connection, i.e., all subflows.




<span class="grey">Scharf &amp; Ford                 Informational                    [Page 13]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-14" id="page-14" name="page-14"> </a>
<span class="grey"><a href="rfc6897.html">RFC 6897</a>                        MPTCP API                     March 2013</span>


   In addition, the MPTCP protocol instance MAY use a different path
   scheduler algorithm if TCP_NODELAY is present.  For instance, it
   could use an algorithm that is optimized for latency-sensitive
   traffic (for instance, only transmitting on one path).  Specific
   algorithms are outside the scope of this document.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/4.4.3.%20%20Buffer%20Sizing"></a><a class="selflink" href="#section-4.4.3" name="section-4.4.3">4.4.3</a>.  Buffer Sizing</span>

   Applications can explicitly configure send and receive buffer sizes
   via the sockets API (SO_SNDBUF, SO_RCVBUF).  These socket options can
   also be used in combination with MPTCP and then affect the buffer
   size of the MPTCP connection.  However, when defining buffer sizes,
   application programmers should take into account that the transport
   over several subflows requires a certain amount of buffer for
   resequencing in the receiver.  MPTCP may also require more storage
   space in the sender, in particular, if retransmissions are sent over
   more than one path.  In addition, very small send buffers may prevent
   MPTCP from efficiently scheduling data over different subflows.
   Therefore, it does not make sense to use MPTCP in combination with
   small send or receive buffers.

   An MPTCP implementation MAY set a lower bound for send and receive
   buffers and treat a small buffer size request as an implicit request
   not to use MPTCP.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/4.4.4.%20%20Other%20Socket%20Options"></a><a class="selflink" href="#section-4.4.4" name="section-4.4.4">4.4.4</a>.  Other Socket Options</span>

   TCP features the ability to send "Urgent" data, but its use is not
   recommended in general, and specifically not with MPTCP [<a href="#ref-4" title='"Architectural Guidelines for Multipath TCP Development"'>4</a>].

   Some network stacks may provide additional implementation-specific
   socket options or interfaces that affect TCP's behavior.  In such
   cases, implementers must ensure that these options do not interfere
   with the MPTCP interface.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.5.%20%20Default%20Enabling%20of%20MPTCP"></a><a class="selflink" href="#section-4.5" name="section-4.5">4.5</a>.  Default Enabling of MPTCP</span>

   It is up to a local policy at the end system whether a network stack
   should automatically enable MPTCP for sockets even if there is no
   explicit sign of MPTCP awareness of the corresponding application.
   Such a choice may be under the control of the user through system
   preferences.

   The enabling of MPTCP, either by application or by system defaults,
   does not necessarily mean that MPTCP will always be used.  Both
   endpoints must support MPTCP, and there must be multiple addresses at
   at least one endpoint, for MPTCP to be used.  Even if those
   requirements are met, however, MPTCP may not be immediately used on a



<span class="grey">Scharf &amp; Ford                 Informational                    [Page 14]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-15" id="page-15" name="page-15"> </a>
<span class="grey"><a href="rfc6897.html">RFC 6897</a>                        MPTCP API                     March 2013</span>


   connection.  It may make sense for multiple paths to be brought into
   operation only after a given period of time, or if the connection is
   saturated.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.6.%20%20Summary%20of%20Advice%20to%20Application%20Developers"></a><a class="selflink" href="#section-4.6" name="section-4.6">4.6</a>.  Summary of Advice to Application Developers</span>

   o  Using the default MPTCP configuration: Like TCP, MPTCP is designed
      to be efficient and robust in the default configuration.
      Application developers should not explicitly configure TCP (or
      MPTCP) features unless this is really needed.

   o  Socket buffer dimensioning: Multipath transport requires larger
      buffers in the receiver for resequencing, as already explained.
      Applications should use reasonable buffer sizes (such as the
      operating system default values) in order to fully benefit from
      MPTCP.  A full discussion of buffer sizing issues is given in [<a href="#ref-5" title='"TCP Extensions for Multipath Operation with Multiple Addresses"'>5</a>].

   o  Facilitating stack-internal heuristics: The path management and
      data scheduling by MPTCP is realized by stack-internal algorithms
      that may implicitly try to self-optimize their behavior according
      to assumed application needs.  For instance, an MPTCP
      implementation may use heuristics to determine whether an
      application requires delay-sensitive or bulk data transport,
      using, for instance, port numbers, the TCP_NODELAY socket options,
      or the application's read/write patterns as input parameters.  An
      application developer can facilitate the operation of such
      heuristics by avoiding atypical interface use cases.  For
      instance, for long bulk data transfers, it does not make sense to
      enable the TCP_NODELAY socket option, nor is it reasonable to use
      many small socket send() calls each with small amounts of data
      only.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/5.%20%20Basic%20API%20for%20MPTCP-Aware%20Applications"></a><a class="selflink" href="#section-5" name="section-5">5</a>.  Basic API for MPTCP-Aware Applications</span>

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.1.%20%20Design%20Considerations"></a><a class="selflink" href="#section-5.1" name="section-5.1">5.1</a>.  Design Considerations</span>

   While applications can use MPTCP with the unmodified sockets API,
   multipath transport results in many degrees of freedom.  MPTCP
   manages the data transport over different subflows automatically.  By
   default, this is transparent to the application, but an application
   could use an additional API to interface with the MPTCP layer and to
   control important aspects of the MPTCP implementation's behavior.

   This document describes a basic MPTCP API.  The API contains a
   minimum set of functions that provide an equivalent level of control
   and information as exists for regular TCP.  It maintains backward
   compatibility with legacy applications.




<span class="grey">Scharf &amp; Ford                 Informational                    [Page 15]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-16" id="page-16" name="page-16"> </a>
<span class="grey"><a href="rfc6897.html">RFC 6897</a>                        MPTCP API                     March 2013</span>


   An advanced MPTCP API is outside the scope of this document.  The
   basic API does not allow a sender or a receiver to express
   preferences about the management of paths or the scheduling of data,
   even if this can have a significant performance impact and if an
   MPTCP implementation could benefit from additional guidance by
   applications.  A list of potential further API extensions is provided
   in the appendix.  The specification of such an advanced API is for
   further study and may partly be implementation-specific.

   MPTCP mainly affects the sending of data.  But a receiver may also
   have preferences about data transfer choices, and it may have
   performance requirements as well.  Yet, the configuration of such
   preferences is outside of the scope of the basic API.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.2.%20%20Requirements%20on%20the%20Basic%20MPTCP%20API"></a><a class="selflink" href="#section-5.2" name="section-5.2">5.2</a>.  Requirements on the Basic MPTCP API</span>

   Because of the importance of the sockets interface there are several
   fundamental design objectives for the basic interface between MPTCP
   and applications:

   o  Consistency with existing sockets APIs must be maintained as far
      as possible.  In order to support the large base of applications
      using the original API, a legacy application must be able to
      continue to use standard sockets interface functions when run on a
      system supporting MPTCP.  Also, MPTCP-aware applications should be
      able to access the socket without any major changes.

   o  Sockets API extensions must be minimized and independent of an
      implementation.

   o  The interface should handle both IPv4 and IPv6.

   The following is a list of the core requirements for the basic API:

   REQ1:  Turn on/off MPTCP: An application should be able to request to
          turn on or turn off the usage of MPTCP.  This means that an
          application should be able to explicitly request the use of
          MPTCP if this is possible.  Applications should also be able
          to request not to enable MPTCP and to use regular TCP
          transport instead.  This can be implicit in many cases, since
          MPTCP must be disabled by the use of binding to a specific
          address.  MPTCP may also be enabled if an application uses a
          dedicated multipath address family (such as AF_MULTIPATH
          [<a href="#ref-20" title='"Multi-address Interface in the Socket API"'>20</a>]).

   REQ2:  An application should be able to restrict MPTCP to binding to
          a given set of addresses.




<span class="grey">Scharf &amp; Ford                 Informational                    [Page 16]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-17" id="page-17" name="page-17"> </a>
<span class="grey"><a href="rfc6897.html">RFC 6897</a>                        MPTCP API                     March 2013</span>


   REQ3:  An application should be able to obtain information on the
          pairs of addresses used by the MPTCP subflows.

   REQ4:  An application should be able to extract a unique identifier
          for the connection (per endpoint).

   The first requirement is the most important one, since some
   applications could benefit a lot from MPTCP, but there are also cases
   in which it hardly makes sense.  The existing sockets API provides
   similar mechanisms to enable or disable advanced TCP features.  The
   second requirement corresponds to the binding of addresses with the
   bind() socket call, or, e.g., explicit device bindings with a
   SO_BINDTODEVICE option.  The third requirement ensures that there is
   an equivalent to getpeername() or getsockname() that is able to deal
   with more than one subflow.  Finally, it should be possible for the
   application to retrieve a unique connection identifier (local to the
   endpoint on which it is running) for the MPTCP connection.  This
   replaces the (address, port) pair for a connection identifier in
   single-path TCP, which is no longer static in MPTCP.

   An application can continue to use getpeername() or getsockname() in
   addition to the basic MPTCP API.  Both functions return the
   corresponding addresses of the first subflow, as already explained.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.3.%20%20Sockets%20Interface%20Extensions%20by%20the%20Basic%20MPTCP%20API"></a><a class="selflink" href="#section-5.3" name="section-5.3">5.3</a>.  Sockets Interface Extensions by the Basic MPTCP API</span>

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/5.3.1.%20%20Overview"></a><a class="selflink" href="#section-5.3.1" name="section-5.3.1">5.3.1</a>.  Overview</span>

   The abstract, basic MPTCP API consists of a set of new values that
   are associated with an MPTCP socket.  Such values may be used for
   changing properties of an MPTCP connection or retrieving information.
   These values could be accessed by new symbols on existing calls such
   as setsockopt() and getsockopt() or could be implemented as entirely
   new function calls.  This implementation decision is out of scope for
   this document.  The following list presents symbolic names for these
   MPTCP socket settings.

   o  TCP_MULTIPATH_ENABLE: Enable/disable MPTCP

   o  TCP_MULTIPATH_ADD: Bind MPTCP to a set of given local addresses,
      or add a set of new local addresses to an existing MPTCP
      connection

   o  TCP_MULTIPATH_REMOVE: Remove a local address from an MPTCP
      connection






<span class="grey">Scharf &amp; Ford                 Informational                    [Page 17]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-18" id="page-18" name="page-18"> </a>
<span class="grey"><a href="rfc6897.html">RFC 6897</a>                        MPTCP API                     March 2013</span>


   o  TCP_MULTIPATH_SUBFLOWS: Get the pairs of addresses currently used
      by the MPTCP subflows

   o  TCP_MULTIPATH_CONNID: Get the local connection identifier for this
      MPTCP connection

   Table 1 shows a list of the abstract socket operations for the basic
   configuration of MPTCP.  The first column gives the symbolic name of
   the operation.  The second and third columns indicate whether the
   operation provides values to be read ("Get") or takes values to
   configure ("Set").  The fourth column lists the type of data
   associated with this operation.  The data types are listed for
   information only.  In addition to IP addresses, an application MAY
   also indicate TCP port numbers, as further detailed below.

   +------------------------+-----+-----+------------------------------+
   | Name                   | Get | Set |           Data type          |
   +------------------------+-----+-----+------------------------------+
   | TCP_MULTIPATH_ENABLE   |  o  |  o  |           boolean            |
   | TCP_MULTIPATH_ADD      |     |  o  |      list of addresses       |
   |                        |     |     |         (and ports)          |
   | TCP_MULTIPATH_REMOVE   |     |  o  |      list of addresses       |
   |                        |     |     |         (and ports)          |
   | TCP_MULTIPATH_SUBFLOWS |  o  |     |  list of pairs of addresses  |
   |                        |     |     |         (and ports)          |
   | TCP_MULTIPATH_CONNID   |  o  |     |           integer            |
   +------------------------+-----+-----+------------------------------+

                     Table 1: MPTCP Socket Operations

   There are restrictions on when these new socket operations can be
   used:

   o  TCP_MULTIPATH_ENABLE: This value should only be set before the
      establishment of a TCP connection.  Its value should only be read
      after the establishment of a connection.

   o  TCP_MULTIPATH_ADD: This operation can be applied both before
      connection setup and during a connection.  If used before, it
      controls the local addresses that an MPTCP connection can use.  In
      the latter case, it allows MPTCP to use an additional local
      address, if there has been a restriction before connection setup.

   o  TCP_MULTIPATH_REMOVE: This operation can be applied both before
      connection setup and during a connection.  In both cases, it
      removes an address from the list of local addresses that may be
      used by subflows.




<span class="grey">Scharf &amp; Ford                 Informational                    [Page 18]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-19" id="page-19" name="page-19"> </a>
<span class="grey"><a href="rfc6897.html">RFC 6897</a>                        MPTCP API                     March 2013</span>


   o  TCP_MULTIPATH_SUBFLOWS: This value is read-only and can only be
      used after connection setup.

   o  TCP_MULTIPATH_CONNID: This value is read-only and should only be
      used after connection setup.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/5.3.2.%20%20Enabling%20and%20Disabling%20of%20MPTCP"></a><a class="selflink" href="#section-5.3.2" name="section-5.3.2">5.3.2</a>.  Enabling and Disabling of MPTCP</span>

   An application can explicitly indicate multipath capability by
   setting TCP_MULTIPATH_ENABLE to the value "true".  In this case, the
   MPTCP implementation SHOULD try to negotiate MPTCP for that
   connection.  Note that multipath transport will not necessarily be
   enabled, as it requires support at both end systems, no middleboxes
   on the path that would prevent any additional signaling, and at least
   one endpoint with multiple addresses.

   Building on the backward compatibility specified in <a href="#section-4.2.1">Section 4.2.1</a>, if
   an application enables MPTCP but binds to a specific address or
   interface, MPTCP MUST be enabled, but MPTCP MUST respect the
   application's choice and only use addresses that are explicitly
   provided by the application.  Note that it would be possible for an
   application to use the legacy bindings and then expand on them by
   using TCP_MULTIPATH_ADD.  Note also that it is possible for more than
   one local address to be initially available to MPTCP in this case, if
   an application has bound to a specific interface with multiple
   addresses.

   An application can disable MPTCP by setting TCP_MULTIPATH_ENABLE to a
   value of "false".  In that case, MPTCP MUST NOT be used on that
   connection.

   After connection establishment, an application can get the value of
   TCP_MULTIPATH_ENABLE.  A value of "false" then means lack of MPTCP
   support.  A value of "true" means that MPTCP is supported.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/5.3.3.%20%20Binding%20MPTCP%20to%20Specified%20Addresses"></a><a class="selflink" href="#section-5.3.3" name="section-5.3.3">5.3.3</a>.  Binding MPTCP to Specified Addresses</span>

   Before connection establishment, an application can use the
   TCP_MULTIPATH_ADD function to indicate a set of local IP addresses
   that MPTCP may bind to.  The parameter of the function is a list of
   addresses in a corresponding data structure.  By extension, this
   operation will also control the list of addresses that can be
   advertised to the peer via MPTCP signaling.

   If an application binds to a specific address or interface, it is not
   required to use the TCP_MULTIPATH_ADD operation for that address.  As
   explained in <a href="#section-5.3.2">Section 5.3.2</a>, MPTCP MUST only use the explicitly
   specified addresses in that case.



<span class="grey">Scharf &amp; Ford                 Informational                    [Page 19]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-20" id="page-20" name="page-20"> </a>
<span class="grey"><a href="rfc6897.html">RFC 6897</a>                        MPTCP API                     March 2013</span>


   An application MAY also indicate a TCP port number that, if
   specified, MPTCP MUST attempt to bind to.  The port number MAY be
   different than the one used by existing subflows.  If no port number
   is provided by the application, the port number is automatically
   selected by the MPTCP implementation, and it is RECOMMENDED that it
   is the same across all subflows.

   This operation can also be used to modify the address list in use
   during the lifetime of an MPTCP connection.  In this case, it is used
   to indicate a set of additional local addresses that the MPTCP
   connection can make use of and that can be signaled to the peer.  It
   should be noted that this signal is only a hint, and an MPTCP
   implementation MAY select only a subset of the addresses.

   The TCP_MULTIPATH_REMOVE operation can be used to remove a local
   address, or a set of local addresses, from an MPTCP connection.
   MPTCP MUST close any corresponding subflows (i.e., those using the
   local address that is no longer present) and signal the removal of
   the address to the peer.  If alternative paths are available using
   the supplied address list but MPTCP is not currently using them, an
   MPTCP implementation SHOULD establish alternative subflows before
   undertaking the address removal.

   It should be remembered that these operations SHOULD support both
   IPv4 and IPv6 addresses, potentially in the same call.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/5.3.4.%20%20Querying%20the%20MPTCP%20Subflow%20Addresses"></a><a class="selflink" href="#section-5.3.4" name="section-5.3.4">5.3.4</a>.  Querying the MPTCP Subflow Addresses</span>

   An application can get a list of the addresses used by the currently
   established subflows in an MPTCP connection by means of the read-only
   TCP_MULTIPATH_SUBFLOWS operation.

   The return value is a list of pairs of tuples of IP address and TCP
   port number.  In one pair, the first tuple refers to the local IP
   address and the local TCP port, and the second one to the remote IP
   address and remote TCP port used by the subflow.  The list MUST only
   include established subflows.  Both addresses in each pair MUST be
   either IPv4 or IPv6.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/5.3.5.%20%20Getting%20a%20Unique%20Connection%20Identifier"></a><a class="selflink" href="#section-5.3.5" name="section-5.3.5">5.3.5</a>.  Getting a Unique Connection Identifier</span>

   An application that wants a unique identifier for the connection,
   analogous to an (address, port) pair in regular TCP, can query the
   TCP_MULTIPATH_CONNID value to get a local connection identifier for
   the MPTCP connection.

   This SHOULD be an integer number and SHOULD be locally unique (e.g.,
   the MPTCP token).



<span class="grey">Scharf &amp; Ford                 Informational                    [Page 20]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-21" id="page-21" name="page-21"> </a>
<span class="grey"><a href="rfc6897.html">RFC 6897</a>                        MPTCP API                     March 2013</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/6.%20%20Other%20Compatibility%20Issues"></a><a class="selflink" href="#section-6" name="section-6">6</a>.  Other Compatibility Issues</span>

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/6.1.%20%20Usage%20of%20TLS%20over%20MPTCP"></a><a class="selflink" href="#section-6.1" name="section-6.1">6.1</a>.  Usage of TLS over MPTCP</span>

   Transport Layer Security (TLS) [<a href="#ref-17" title='"The Transport Layer Security (TLS) Protocol Version 1.2"'>17</a>] may be used over MPTCP's basic
   API.  When TLS compares any addresses used by MPTCP against names or
   addresses present in X.509 certificates [<a href="#ref-18" title='"Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile"'>18</a>] [<a href="#ref-19" title='"Representation and Verification of Domain-Based Application Service Identity within Internet Public Key Infrastructure Using X.509 (PKIX) Certificates in the Context of Transport Layer Security (TLS)"'>19</a>], it MUST only
   compare them with the address that MPTCP used to start the initial
   subflow as presented to TLS.  The addresses used for subsequent
   subflows need not to be compared against any TLS certificate
   information.  Finer-grained control would require an advanced API or
   proactive subflow management via the basic API.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/6.2.%20%20Usage%20of%20the%20SCTP%20Sockets%20API"></a><a class="selflink" href="#section-6.2" name="section-6.2">6.2</a>.  Usage of the SCTP Sockets API</span>

   For dealing with multihoming, several sockets API extensions have
   been defined for SCTP [<a href="#ref-13" title='"Sockets API Extensions for the Stream Control Transmission Protocol (SCTP)"'>13</a>].  As MPTCP realizes multipath transport
   from and to multihomed end systems, some of these interface function
   calls are actually applicable to MPTCP in a similar way.

   API developers may wish to integrate SCTP and MPTCP calls to provide
   a consistent interface to the application.  Yet, it must be
   emphasized that the transport service provided by MPTCP is different
   than that of SCTP, and this is why not all SCTP API functions can be
   mapped directly to MPTCP.  Furthermore, a network stack implementing
   MPTCP does not necessarily support SCTP and its specific sockets
   interface extensions.  This is why the basic API of MPTCP defines
   additional socket options only, which are a backward-compatible
   extension of TCP's application interface.  Integration with the SCTP
   API is outside the scope of the basic API.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/6.3.%20%20Incompatibilities%20with%20Other%20Multihoming%20Solutions"></a><a class="selflink" href="#section-6.3" name="section-6.3">6.3</a>.  Incompatibilities with Other Multihoming Solutions</span>

   The use of MPTCP can interact with various related sockets API
   extensions.  The use of a multihoming shim layer conflicts with
   multipath transport such as MPTCP or SCTP [<a href="#ref-11" title='"Sockets Application Program Interface (API) for Multihoming Shim"'>11</a>].  Care should be taken
   that the use of MPTCP not conflict with the overlapping features of
   other APIs:

   o  SHIM API [<a href="#ref-11" title='"Sockets Application Program Interface (API) for Multihoming Shim"'>11</a>]: This API specifies sockets API extensions for the
      multihoming shim layer.

   o  HIP API [<a href="#ref-12" title='"Basic Socket Interface Extensions for the Host Identity Protocol (HIP)"'>12</a>]: The Host Identity Protocol (HIP) also results in a
      new API.

   o  API for Mobile IPv6 [<a href="#ref-10" title='"Extension to Sockets API for Mobile IPv6"'>10</a>]: For Mobile IPv6, a significantly
      extended sockets API exists as well (in addition to API extensions
      for IPv6 [<a href="#ref-9" title='"Advanced Sockets Application Program Interface (API) for IPv6"'>9</a>]).



<span class="grey">Scharf &amp; Ford                 Informational                    [Page 21]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-22" id="page-22" name="page-22"> </a>
<span class="grey"><a href="rfc6897.html">RFC 6897</a>                        MPTCP API                     March 2013</span>


   In order to avoid any conflict, multiaddressed MPTCP SHOULD NOT be
   enabled if a network stack uses SHIM6, HIP, or Mobile IPv6.
   Furthermore, applications should not try to use both the MPTCP API
   and another multihoming or mobility layer API.

   It is possible, however, that some of the MPTCP functionality, such
   as congestion control, could be used in a SHIM6 or HIP environment.
   Such operation is for further study.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/6.4.%20%20Interactions%20with%20DNS"></a><a class="selflink" href="#section-6.4" name="section-6.4">6.4</a>.  Interactions with DNS</span>

   In multihomed or multiaddressed environments, there are various
   issues that are not specific to MPTCP but have to be considered as
   well.  These problems are summarized in [<a href="#ref-14" title='"Multiple Interfaces and Provisioning Domains Problem Statement"'>14</a>].

   Specifically, there can be interactions with DNS.  Whilst it is
   expected that an application will iterate over the list of addresses
   returned from a call such as getaddrinfo(), MPTCP itself MUST NOT
   make any assumptions about multiple A or AAAA records from the same
   DNS query referring to the same host, as it is possible that multiple
   addresses refer to multiple servers for load-balancing purposes.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/7.%20%20Security%20Considerations"></a><a class="selflink" href="#section-7" name="section-7">7</a>.  Security Considerations</span>

   This document first defines the behavior of the standard TCP/IP API
   for MPTCP-unaware applications.  In general, enabling MPTCP has some
   security implications for applications, which are introduced in
   <a href="#section-5.3.3">Section 5.3.3</a>, and these threats are further detailed in [<a href="#ref-6" title='"Threat Analysis for TCP Extensions for Multipath Operation with Multiple Addresses"'>6</a>].  The
   protocol specification of MPTCP [<a href="#ref-5" title='"TCP Extensions for Multipath Operation with Multiple Addresses"'>5</a>] defines several mechanisms to
   protect MPTCP against those attacks.

   The syntax and semantics of the API for MPTCP-unaware applications
   does not change.  However, assumptions that non-MPTCP-aware
   applications may make on the data retrieved by the backward-
   compatible API are discussed in <a href="#section-4.2.2">Section 4.2.2</a>.  System administrators
   may wish to disable MPTCP for certain applications that signal
   addresses, or make security decisions (e.g., opening firewall holes),
   based on responses to such queries.

   In addition, the basic MPTCP API for MPTCP-aware applications defines
   functions that provide an equivalent level of control and information
   as exists for regular TCP.  This document does not mandate a specific
   implementation of the basic MPTCP API.  The implementation should be
   designed not to affect memory management assumptions in existing
   code.  Implementors should take into account that data structures
   will be more complex than for standard TCP, e.g., when multiple





<span class="grey">Scharf &amp; Ford                 Informational                    [Page 22]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-23" id="page-23" name="page-23"> </a>
<span class="grey"><a href="rfc6897.html">RFC 6897</a>                        MPTCP API                     March 2013</span>


   subflow addresses have to be stored.  When dealing with such data
   structures, care is needed not to add security vulnerabilities to
   applications.

   New functions enable adding and removing local addresses from an
   MPTCP connection (TCP_MULTIPATH_ADD and TCP_MULTIPATH_REMOVE).  These
   functions don't add security threats if the MPTCP stack verifies that
   the addresses provided by the application are indeed available as
   source addresses for subflows.

   However, applications should use the TCP_MULTIPATH_ADD function with
   care, as new subflows might get established to those addresses.
   Furthermore, it could result in some form of information leakage
   since MPTCP might advertise those addresses to the other connection
   endpoint, which could learn IP addresses of interfaces that are not
   visible otherwise.

   Use of different addresses should not be assumed to lead to use of
   different paths, especially for security purposes.

   MPTCP-aware applications should also take care when querying and
   using information about the addresses used by subflows
   (TCP_MULTIPATH_SUBFLOWS).  As MPTCP can dynamically open and close
   subflows, a list of addresses queried once can get outdated during
   the lifetime of an MPTCP connection.  Then, the list may contain
   invalid entries, i.e., addresses that are not used any more or that
   might not even be assigned to that host any more.  Applications that
   want to ensure that MPTCP only uses a certain set of addresses should
   explicitly bind to those addresses.

   One specific example is the use TLS on top of MPTCP.  Corresponding
   guidance can be found in <a href="#section-6.1">Section 6.1</a>.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/8.%20%20Conclusion"></a><a class="selflink" href="#section-8" name="section-8">8</a>.  Conclusion</span>

   This document discusses MPTCP's implications and its performance
   impact on applications.  In addition, it specifies a basic MPTCP API.
   For legacy applications, it is ensured that the existing sockets API
   continues to work.  MPTCP-aware applications can use the basic MPTCP
   API that provides some control over the transport layer equivalent to
   regular TCP.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/9.%20%20Acknowledgments"></a><a class="selflink" href="#section-9" name="section-9">9</a>.  Acknowledgments</span>

   The authors sincerely thank the following people for their helpful
   comments and reviews of the document: Philip Eardley, Lavkesh
   Lahngir, John Leslie, Costin Raiciu, Michael Tuexen, and Javier
   Ubillos.



<span class="grey">Scharf &amp; Ford                 Informational                    [Page 23]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-24" id="page-24" name="page-24"> </a>
<span class="grey"><a href="rfc6897.html">RFC 6897</a>                        MPTCP API                     March 2013</span>


   Michael Scharf is supported by the German-Lab project
   (<a href="http://www.german-lab.de/">http://www.german-lab.de/</a>) funded by the German Federal Ministry of
   Education and Research (BMBF).  Alan Ford was previously supported by
   Roke Manor Research and by Trilogy (<a href="http://www.trilogy-project.org/">http://www.trilogy-project.org/</a>),
   a research project (ICT-216372) partially funded by the European
   Community under its Seventh Framework Program.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/10.%20%20References"></a><a class="selflink" href="#section-10" name="section-10">10</a>.  References</span>

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/10.1.%20%20Normative%20References"></a><a class="selflink" href="#section-10.1" name="section-10.1">10.1</a>.  Normative References</span>

   [<a id="ref-1" name="ref-1">1</a>]   Postel, J., "Transmission Control Protocol", STD 7, <a href="rfc793.html">RFC 793</a>,
         September 1981.

   [<a id="ref-2" name="ref-2">2</a>]   Braden, R., "Requirements for Internet Hosts - Communication
         Layers", STD 3, <a href="rfc1122.html">RFC 1122</a>, October 1989.

   [<a id="ref-3" name="ref-3">3</a>]   Bradner, S., "Key words for use in RFCs to Indicate Requirement
         Levels", <a href="https://tools.ietf.org/html/bcp14">BCP 14</a>, <a href="rfc2119.html">RFC 2119</a>, March 1997.

   [<a id="ref-4" name="ref-4">4</a>]   Ford, A., Raiciu, C., Handley, M., Barre, S., and J. Iyengar,
         "Architectural Guidelines for Multipath TCP Development",
         <a href="rfc6182.html">RFC 6182</a>, March 2011.

   [<a id="ref-5" name="ref-5">5</a>]   Ford, A., Raiciu, C., Handley, M., and O. Bonaventure, "TCP
         Extensions for Multipath Operation with Multiple Addresses",
         <a href="rfc6824.html">RFC 6824</a>, January 2013.

   [<a id="ref-6" name="ref-6">6</a>]   Bagnulo, M., "Threat Analysis for TCP Extensions for Multipath
         Operation with Multiple Addresses", <a href="rfc6181.html">RFC 6181</a>, March 2011.

   [<a id="ref-7" name="ref-7">7</a>]   Raiciu, C., Handley, M., and D. Wischik, "Coupled Congestion
         Control for Multipath Transport Protocols", <a href="rfc6356.html">RFC 6356</a>,
         October 2011.

   [<a id="ref-8" name="ref-8">8</a>]   "IEEE Standard for Information Technology -- Portable Operating
         System Interface (POSIX) Base Specifications, Issue 7", IEEE
         Std. 1003.1-2008, 2008.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/10.2.%20%20Informative%20References"></a><a class="selflink" href="#section-10.2" name="section-10.2">10.2</a>.  Informative References</span>

   [<a id="ref-9" name="ref-9">9</a>]   Stevens, W., Thomas, M., Nordmark, E., and T. Jinmei, "Advanced
         Sockets Application Program Interface (API) for IPv6",
         <a href="rfc3542.html">RFC 3542</a>, May 2003.

   [<a id="ref-10" name="ref-10">10</a>]  Chakrabarti, S. and E. Nordmark, "Extension to Sockets API for
         Mobile IPv6", <a href="rfc4584.html">RFC 4584</a>, July 2006.




<span class="grey">Scharf &amp; Ford                 Informational                    [Page 24]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-25" id="page-25" name="page-25"> </a>
<span class="grey"><a href="rfc6897.html">RFC 6897</a>                        MPTCP API                     March 2013</span>


   [<a id="ref-11" name="ref-11">11</a>]  Komu, M., Bagnulo, M., Slavov, K., and S. Sugimoto, "Sockets
         Application Program Interface (API) for Multihoming Shim",
         <a href="rfc6316.html">RFC 6316</a>, July 2011.

   [<a id="ref-12" name="ref-12">12</a>]  Komu, M. and T. Henderson, "Basic Socket Interface Extensions
         for the Host Identity Protocol (HIP)", <a href="rfc6317.html">RFC 6317</a>, July 2011.

   [<a id="ref-13" name="ref-13">13</a>]  Stewart, R., Tuexen, M., Poon, K., Lei, P., and V. Yasevich,
         "Sockets API Extensions for the Stream Control Transmission
         Protocol (SCTP)", <a href="rfc6458.html">RFC 6458</a>, December 2011.

   [<a id="ref-14" name="ref-14">14</a>]  Blanchet, M. and P. Seite, "Multiple Interfaces and
         Provisioning Domains Problem Statement", <a href="rfc6418.html">RFC 6418</a>,
         November 2011.

   [<a id="ref-15" name="ref-15">15</a>]  Wasserman, M. and P. Seite, "Current Practices for Multiple-
         Interface Hosts", <a href="rfc6419.html">RFC 6419</a>, November 2011.

   [<a id="ref-16" name="ref-16">16</a>]  Wing, D. and A. Yourtchenko, "Happy Eyeballs: Success with
         Dual-Stack Hosts", <a href="rfc6555.html">RFC 6555</a>, April 2012.

   [<a id="ref-17" name="ref-17">17</a>]  Dierks, T. and E. Rescorla, "The Transport Layer Security (TLS)
         Protocol Version 1.2", <a href="rfc5246.html">RFC 5246</a>, August 2008.

   [<a id="ref-18" name="ref-18">18</a>]  Cooper, D., Santesson, S., Farrell, S., Boeyen, S., Housley,
         R., and W. Polk, "Internet X.509 Public Key Infrastructure
         Certificate and Certificate Revocation List (CRL) Profile",
         <a href="rfc5280.html">RFC 5280</a>, May 2008.

   [<a id="ref-19" name="ref-19">19</a>]  Saint-Andre, P. and J. Hodges, "Representation and Verification
         of Domain-Based Application Service Identity within Internet
         Public Key Infrastructure Using X.509 (PKIX) Certificates in
         the Context of Transport Layer Security (TLS)", <a href="rfc6125.html">RFC 6125</a>,
         March 2011.

   [<a id="ref-20" name="ref-20">20</a>]  Sarolahti, P., <a href="https://www.google.com/search?sitesearch=tools.ietf.org%2Fhtml%2F&amp;q=inurl:draft-+%22Multi-address+Interface+in+the+Socket+API%22" style="text-decoration: none">"Multi-address Interface in the Socket API"</a>,
         Work in Progress, March 2010.

   [<a id="ref-21" name="ref-21">21</a>]  Khalili, R., Gast, N., Popovic, M., and J. Le Boudec,
         "Performance Issues with MPTCP", Work in Progress,
         February 2013.

   [<a id="ref-22" name="ref-22">22</a>]  Honda, M., Nishida, Y., Raiciu, C., Greenhalgh, A., Handley,
         M., and H. Tokuda, "Is it Still Possible to Extend TCP?", Proc.
         ACM Internet Measurement Conference (IMC), November 2011.






<span class="grey">Scharf &amp; Ford                 Informational                    [Page 25]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-26" id="page-26" name="page-26"> </a>
<span class="grey"><a href="rfc6897.html">RFC 6897</a>                        MPTCP API                     March 2013</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/Appendix%20A.%20%20Requirements%20on%20a%20Future%20Advanced%20MPTCP%20API"></a><a class="selflink" href="#appendix-A" name="appendix-A">Appendix A</a>.  Requirements on a Future Advanced MPTCP API</span>

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/A.1.%20%20Design%20Considerations"></a><a class="selflink" href="#appendix-A.1" name="appendix-A.1">A.1</a>.  Design Considerations</span>

   Multipath transport results in many degrees of freedom.  The basic
   MPTCP API only defines a minimum set of the API extensions for the
   interface between the MPTCP layer and applications, which does not
   offer much control of the MPTCP implementation's behavior.  A future,
   advanced API could address further features of MPTCP and provide more
   control.

   Applications that use TCP may have different requirements on the
   transport layer.  While developers have become used to the
   characteristics of regular TCP, new opportunities created by MPTCP
   could allow the service provided to be optimized further.  An
   advanced API could enable MPTCP-aware applications to specify
   preferences and control certain aspects of the behavior, in addition
   to the simple control provided by the basic interface.  An advanced
   API could also address aspects that are completely out of scope of
   the basic API, for example, the question of whether a receiving
   application could influence the sending policy.  A better integration
   with TLS could be another relevant objective (cf. <a href="#section-6.1">Section 6.1</a>) that
   requires further work.

   Furthermore, an advanced MPTCP API could be part of a new overall
   interface between the network stack and applications that addresses
   other issues as well, such as the split between identifiers and
   locators.  An API that does not use IP addresses (but instead uses,
   e.g., the connectbyname() function) would be useful for numerous
   purposes, independent of MPTCP.

   It has also been suggested that a separate address family called
   AF_MULTIPATH [<a href="#ref-20" title='"Multi-address Interface in the Socket API"'>20</a>] be used.  This separate address family could be
   used to exchange multiple addresses between an application and the
   standard sockets API, but it would be a more fundamental change
   compared to the basic API described in this document.

   This appendix documents a list of potential usage scenarios and
   requirements for the advanced API.  The specification and
   implementation of a corresponding API are outside the scope of this
   document.










<span class="grey">Scharf &amp; Ford                 Informational                    [Page 26]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-27" id="page-27" name="page-27"> </a>
<span class="grey"><a href="rfc6897.html">RFC 6897</a>                        MPTCP API                     March 2013</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/A.2.%20%20MPTCP%20Usage%20Scenarios%20and%20Application%20Requirements"></a><a class="selflink" href="#appendix-A.2" name="appendix-A.2">A.2</a>.  MPTCP Usage Scenarios and Application Requirements</span>

   There are different MPTCP usage scenarios.  An application that
   wishes to transmit bulk data will want MPTCP to provide a high-
   throughput service immediately, through creating and maximizing
   utilization of all available subflows.  This is the default MPTCP use
   case.

   But at the other extreme, there are applications that are highly
   interactive but require only a small amount of throughput, and these
   are optimally served by low latency and jitter stability.  In such a
   situation, it would be preferable for the traffic to use only the
   lowest-latency subflow (assuming it has sufficient capacity), maybe
   with one or two additional subflows for resilience and recovery
   purposes.  The key challenge for such a strategy is that the delay on
   a path may fluctuate significantly and that just always selecting the
   path with the smallest delay might result in instability.

   The choice between bulk data transport and latency-sensitive
   transport affects the scheduler in terms of whether traffic should
   be, by default, sent on one subflow or across several subflows.  Even
   if the total bandwidth required is less than that available on an
   individual path, it is desirable to spread this load to reduce stress
   on potential bottlenecks, and this is why this method should be the
   default for bulk data transport.  However, that may not be optimal
   for applications that require latency/jitter stability.

   In the case of the latter option, a further question arises: Should
   additional subflows be used whenever the primary subflow is
   overloaded, or only when the primary path fails (hot standby)?  In
   other words, is latency stability or bandwidth more important to the
   application?  This results in two different options: Firstly, there
   is the single path that can overflow into an additional subflow; and
   secondly, there is the single path with hot standby, whereby an
   application may want an alternative backup subflow in order to
   improve resilience.  In case data delivery on the first subflow
   fails, the data transport could immediately be continued on the
   second subflow, which is idle otherwise.

   Yet another complication is introduced with the potential that MPTCP
   introduces for changes in available bandwidth as the number of
   available subflows changes.  Such jitter in bandwidth may prove
   confusing for some applications, such as video or audio streaming,
   that dynamically adapt codecs based on available bandwidth.  Such
   applications may prefer MPTCP to attempt to provide a consistent
   bandwidth as far as is possible and avoid maximizing the use of all
   subflows.




<span class="grey">Scharf &amp; Ford                 Informational                    [Page 27]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-28" id="page-28" name="page-28"> </a>
<span class="grey"><a href="rfc6897.html">RFC 6897</a>                        MPTCP API                     March 2013</span>


   A further, mostly orthogonal question is whether data should be
   duplicated over the different subflows, in particular if there is
   spare capacity.  This could improve both the timeliness and
   reliability of data delivery.

   In summary, there are at least three possible performance objectives
   for multipath transport:

   1.  High bandwidth

   2.  Low latency and jitter stability

   3.  High reliability

   These are not necessarily disjoint, since there are also broadband
   interactive applications that require both high-speed bulk data
   traffic and a low latency and jitter.

   In an advanced API, applications could provide high-level guidance to
   the MPTCP implementation concerning these performance requirements,
   for instance, which requirement is considered to be the most
   important.  The MPTCP stack would then use internal mechanisms to
   fulfill this abstract indication of a desired service, as far as
   possible.  This would affect the assignment of data (including
   retransmissions) to existing subflows (e.g., 'use all in parallel',
   'use as overflow', 'hot standby', 'duplicate traffic') as well as the
   decisions regarding when to set up additional subflows to which
   addresses.  In both cases, different policies can exist, which can be
   expected to be implementation-specific.

   Therefore, an advanced API could provide a mechanism for how
   applications can specify their high-level requirements in an
   implementation-independent way.  One possibility would be to select
   one "application profile" out of a number of choices that
   characterize typical applications.  Yet, as applications today do not
   have to inform TCP about their communication requirements, it
   requires further studies as to whether such an approach would be
   realistic.

   Of course, independent of an advanced API, such functionality could
   also partly be achieved by MPTCP-internal heuristics that infer some
   application preferences, e.g., from existing socket options, such as
   TCP_NODELAY.  Whether this would be reliable, and indeed appropriate,
   is for further study.







<span class="grey">Scharf &amp; Ford                 Informational                    [Page 28]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-29" id="page-29" name="page-29"> </a>
<span class="grey"><a href="rfc6897.html">RFC 6897</a>                        MPTCP API                     March 2013</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/A.3.%20%20Potential%20Requirements%20on%20an%20Advanced%20MPTCP%20API"></a><a class="selflink" href="#appendix-A.3" name="appendix-A.3">A.3</a>.  Potential Requirements on an Advanced MPTCP API</span>

   The following is a list of potential requirements for an advanced
   MPTCP API beyond the features of the basic API.  It is included here
   for information only:

   REQ5:   An application should be able to establish MPTCP connections
           without using IP addresses as locators.

   REQ6:   An application should be able to obtain usage information and
           statistics about all subflows (e.g., ratio of traffic sent
           via this subflow).

   REQ7:   An application should be able to request a change in the
           number of subflows in use, thus triggering removal or
           addition of subflows.  An even finer control granularity
           would be a request for the establishment of a specific
           subflow to a provided destination or a request for the
           termination of a specified, existing subflow.

   REQ8:   An application should be able to inform the MPTCP
           implementation about its high-level performance requirements,
           e.g., in the form of a profile.

   REQ9:   An application should be able to indicate communication
           characteristics, e.g., the expected amount of data to be
           sent, the expected duration of the connection, or the
           expected rate at which data is provided.  Applications may in
           some cases be able to forecast such properties.  If so, such
           information could be an additional input parameter for
           heuristics inside the MPTCP implementation, which could be
           useful, for example, to decide when to set up additional
           subflows.

   REQ10:  An application should be able to control the automatic
           establishment/termination of subflows.  This would imply a
           selection among different heuristics of the path manager,
           e.g., 'try as soon as possible', 'wait until there is a bunch
           of data', etc.

   REQ11:  An application should be able to set preferred subflows or
           subflow usage policies.  This would result in a selection
           among different configurations of the multipath scheduler.
           For instance, an application might want to use certain
           subflows as backup only.






<span class="grey">Scharf &amp; Ford                 Informational                    [Page 29]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-30" id="page-30" name="page-30"> </a>
<span class="grey"><a href="rfc6897.html">RFC 6897</a>                        MPTCP API                     March 2013</span>


   REQ12:  An application should be able to control the level of
           redundancy by telling whether segments should be sent on more
           than one path in parallel.

   REQ13:  An application should be able to control the use of fate-
           sharing of the MPTCP connection and the initial subflow,
           e.g., to overwrite system policies.

   REQ14:  An application should be able to register for callbacks to be
           informed of changes to subflows on an MPTCP connection.  This
           "push" interface would allow the application to make timely
           logging and configuration changes, if required, and would
           avoid frequent polling of information.

   An advanced API fulfilling these requirements would allow application
   developers to more specifically configure MPTCP.  It could avoid
   suboptimal decisions of internal, implicit heuristics.  However, it
   is unclear whether all of these requirements would have a significant
   benefit to applications, since they are going above and beyond what
   the existing API to regular TCP provides.

   A subset of these functions might also be implemented system-wide or
   by other configuration mechanisms.  These implementation details are
   left for further study.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/A.4.%20%20Integration%20with%20the%20SCTP%20Sockets%20API"></a><a class="selflink" href="#appendix-A.4" name="appendix-A.4">A.4</a>.  Integration with the SCTP Sockets API</span>

   The advanced API may also integrate or use the SCTP sockets API.  The
   following functions that are defined for SCTP have functionality
   similar to the basic MPTCP API:

   o  sctp_bindx()

   o  sctp_connectx()

   o  sctp_getladdrs()

   o  sctp_getpaddrs()

   o  sctp_freeladdrs()

   o  sctp_freepaddrs()

   The syntax and semantics of these functions are described in [<a href="#ref-13" title='"Sockets API Extensions for the Stream Control Transmission Protocol (SCTP)"'>13</a>].

   A potential objective for the advanced API is to provide a consistent
   MPTCP and SCTP interface to the application.  This is left for
   further study.



<span class="grey">Scharf &amp; Ford                 Informational                    [Page 30]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-31" id="page-31" name="page-31"> </a>
<span class="grey"><a href="rfc6897.html">RFC 6897</a>                        MPTCP API                     March 2013</span>


Authors' Addresses

   Michael Scharf
   Alcatel-Lucent Bell Labs
   Lorenzstrasse 10
   70435 Stuttgart
   Germany

   EMail: michael.scharf@alcatel-lucent.com


   Alan Ford
   Cisco
   Ruscombe Business Park
   Ruscombe, Berkshire  RG10 9NN
   UK

   EMail: alanford@cisco.com

































Scharf &amp; Ford                 Informational                    [Page 31]

</pre><br/>
    <span class="noprint"><small><small>Html markup produced by rfcmarkup 1.126, available from
      <a href="https://tools.ietf.org/tools/rfcmarkup/">https://tools.ietf.org/tools/rfcmarkup/</a>
    </small></small></span>
  </div>




</body><!-- Mirrored from tools.ietf.org/html/rfc6897 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 06 Mar 2018 23:18:26 GMT --></html>