<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

<!-- Mirrored from tools.ietf.org/html/rfc5596 by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 28 Jul 2019 12:59:45 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head profile="http://dublincore.org/documents/2008/08/04/dc-html/">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="robots" content="index,follow" />
    <meta name="creator" content="rfcmarkup version 1.129c" />
    <link rel="schema.DC" href="http://purl.org/dc/elements/1.1/" />
<meta name="DC.Relation.Replaces" content="draft-fairhurst-dccp-behave-update" />
<meta name="DC.Identifier" content="urn:ietf:rfc:5596" />
<meta name="DC.Date.Issued" content="September, 2009" />
<meta name="DC.Creator" content="Godred Fairhurst &lt;gorry@erg.abdn.ac.uk&gt;" />
<meta name="DC.Description.Abstract" content="This document specifies an update to the Datagram Congestion Control
Protocol (DCCP), a connection-oriented and datagram-based transport
protocol. The update adds support for the DCCP-Listen packet. This
assists DCCP applications to communicate through middleboxes (e.g. a
DCCP server behind a firewall, or Network Address Port Translators),
where establishing necessary middlebox state requires peering
endpoints to initiate communication in a near-simultaneous manner." />
<meta name="DC.Title" content="Datagram Congestion Control Protocol (DCCP) Simultaneous-Open Technique to Facilitate NAT/Middlebox Traversal" />

    <link rel="icon" href="https://tools.ietf.org/images/rfc.png" type="image/png" />
    <link rel="shortcut icon" href="https://tools.ietf.org/images/rfc.png" type="image/png" />
    <title>RFC 5596 - Datagram Congestion Control Protocol (DCCP) Simultaneous-Open Technique to Facilitate NAT/Middlebox Traversal</title>
    
    
    <style type="text/css">
	@media only screen 
	  and (min-width: 992px)
	  and (max-width: 1199px) {
	    body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 768px)
	  and (max-width: 991px) {
            body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 480px)
	  and (max-width: 767px) {
            body { font-size: 11pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (max-width: 479px) {
            body { font-size: 8pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-device-width : 375px) 
	  and (max-device-width : 667px) {
            body { font-size: 9.5pt; }
            div.content { width: 96ex; margin: 0; }
        }
	@media only screen 
	  and (min-device-width: 1200px) {
            body { font-size: 10pt; margin: 0 4em; }
            div.content { width: 96ex; margin: 0; }
        }
        h1, h2, h3, h4, h5, h6, .h1, .h2, .h3, .h4, .h5, .h6 {
	    font-weight: bold;
            line-height: 0pt;
            display: inline;
            white-space: pre;
            font-family: monospace;
            font-size: 1em;
	    font-weight: bold;
        }
        pre {
            font-size: 1em;
            margin-top: 0px;
            margin-bottom: 0px;
        }
	.pre {
	    white-space: pre;
	    font-family: monospace;
	}
	.header{
	    font-weight: bold;
	}
        .newpage {
            page-break-before: always;
        }
        .invisible {
            text-decoration: none;
            color: white;
        }
        a.selflink {
          color: black;
          text-decoration: none;
        }
        @media print {
            body {
                font-family: monospace;
                font-size: 10.5pt;
            }
            h1, h2, h3, h4, h5, h6 {
                font-size: 1em;
            }
        
            a:link, a:visited {
                color: inherit;
                text-decoration: none;
            }
            .noprint {
                display: none;
            }
        }
	@media screen {
	    .grey, .grey a:link, .grey a:visited {
		color: #777;
	    }
            .docinfo {
                background-color: #EEE;
            }
            .top {
                border-top: 7px solid #EEE;
            }
            .bgwhite  { background-color: white; }
            .bgred    { background-color: #F44; }
            .bggrey   { background-color: #666; }
            .bgbrown  { background-color: #840; }            
            .bgorange { background-color: #FA0; }
            .bgyellow { background-color: #EE0; }
            .bgmagenta{ background-color: #F4F; }
            .bgblue   { background-color: #66F; }
            .bgcyan   { background-color: #4DD; }
            .bggreen  { background-color: #4F4; }

            .legend   { font-size: 90%; }
            .cplate   { font-size: 70%; border: solid grey 1px; }
	}
    </style>
    <!--[if IE]>
    <style>
    body {
       font-size: 13px;
       margin: 10px 10px;
    }
    </style>
    <![endif]-->

    <script type="text/javascript"><!--
    function addHeaderTags() {
	var spans = document.getElementsByTagName("span");
	for (var i=0; i < spans.length; i++) {
	    var elem = spans[i];
	    if (elem) {
		var level = elem.getAttribute("class");
                if (level == "h1" || level == "h2" || level == "h3" || level == "h4" || level == "h5" || level == "h6") {
                    elem.innerHTML = "<"+level+">"+elem.innerHTML+"</"+level+">";		
                }
	    }
	}
    }
    var legend_html = "Colour legend:<br />      <table>         <tr><td>Unknown:</td>                   <td><span class='cplate bgwhite'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft:</td>                     <td><span class='cplate bgred'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Informational:</td>             <td><span class='cplate bgorange'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Experimental:</td>              <td><span class='cplate bgyellow'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Best Common Practice:</td>      <td><span class='cplate bgmagenta'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Proposed Standard:</td>         <td><span class='cplate bgblue'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft Standard (old designation):</td> <td><span class='cplate bgcyan'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Internet Standard:</td>         <td><span class='cplate bggreen'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Historic:</td>                  <td><span class='cplate bggrey'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Obsolete:</td>                  <td><span class='cplate bgbrown'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>     </table>";
    function showElem(id) {
        var elem = document.getElementById(id);
        elem.innerHTML = eval(id+"_html");
        elem.style.visibility='visible';
    }
    function hideElem(id) {
        var elem = document.getElementById(id);
        elem.style.visibility='hidden';        
        elem.innerHTML = "";
    }
    // -->
    </script>
</head>
<body onload="addHeaderTags()">
  <div class="content">
   <div style="height: 13px;">
      <div onmouseover="this.style.cursor='pointer';"
         onclick="showElem('legend');"
         onmouseout="hideElem('legend')"
	 style="height: 6px; position: absolute;"
         class="pre noprint docinfo bgblue"
         title="Click for colour legend." >                                                                        </div>
      <div id="legend"
           class="docinfo noprint pre legend"
           style="position:absolute; top: 4px; left: 4ex; visibility:hidden; background-color: white; padding: 4px 9px 5px 7px; border: solid #345 1px; "
           onmouseover="showElem('legend');"
           onmouseout="hideElem('legend');">
      </div>
   </div>
<span class="pre noprint docinfo top">[<a href="index.html" title="Document search and retrieval page">Docs</a>] [<a href="https://tools.ietf.org/rfc/rfc5596.txt" title="Plaintext version of this document">txt</a>|<a href="https://tools.ietf.org/pdf/rfc5596" title="PDF version of this document">pdf</a>] [<a href="https://tools.ietf.org/html/draft-ietf-dccp-simul-open" title="draft-ietf-dccp-simul-open">draft-ietf-dccp...</a>] [<a href='https://datatracker.ietf.org/doc/rfc5596' title='IESG Datatracker information for this document'>Tracker</a>] [<a href="https://tools.ietf.org/rfcdiff?difftype=--hwdiff&amp;url2=rfc5596" title="Inline diff (wdiff)">Diff1</a>] [<a href="https://tools.ietf.org/rfcdiff?url2=rfc5596" title="Side-by-side diff">Diff2</a>]         </span><br />
<span class="pre noprint docinfo">                                                                        </span><br />
<span class="pre noprint docinfo">                                                       PROPOSED STANDARD</span><br />
<span class="pre noprint docinfo">                                                                        </span><br />
<pre>
Network Working Group                                       G. Fairhurst
Request for Comments: 5596                        University of Aberdeen
Updates: <a href="rfc4340.html">4340</a>                                             September 2009
Category: Standards Track


              <span class="h1">Datagram Congestion Control Protocol (DCCP)</span>
   <span class="h1">Simultaneous-Open Technique to Facilitate NAT/Middlebox Traversal</span>

Abstract

   This document specifies an update to the Datagram Congestion Control
   Protocol (DCCP), a connection-oriented and datagram-based transport
   protocol.  The update adds support for the DCCP-Listen packet.  This
   assists DCCP applications to communicate through middleboxes (e.g., a
   Network Address Port Translator or a DCCP server behind a firewall),
   where peering endpoints need to initiate communication in a near-
   simultaneous manner to establish necessary middlebox state.

Status of This Memo

   This document specifies an Internet standards track protocol for the
   Internet community, and requests discussion and suggestions for
   improvements.  Please refer to the current edition of the "Internet
   Official Protocol Standards" (STD 1) for the standardization state
   and status of this protocol.  Distribution of this memo is unlimited.

Copyright and License Notice

   Copyright (c) 2009 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to <a href="https://tools.ietf.org/html/bcp78">BCP 78</a> and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (<a href="http://trustee.ietf.org/license-info">http://trustee.ietf.org/license-info</a>) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the BSD License.

   This document may contain material from IETF Documents or IETF
   Contributions published or made publicly available before November
   10, 2008.  The person(s) controlling the copyright in some of this
   material may not have granted the IETF Trust the right to allow
   modifications of such material outside the IETF Standards Process.
   Without obtaining an adequate license from the person(s) controlling



<span class="grey">Fairhurst                   Standards Track                     [Page 1]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-2" id="page-2" href="#page-2" class="invisible"> </a>
<span class="grey"><a href="rfc5596.html">RFC 5596</a>            DCCP Simultaneous-Open Technique      September 2009</span>


   the copyright in such materials, this document may not be modified
   outside the IETF Standards Process, and derivative works of it may
   not be created outside the IETF Standards Process, except to format
   it for publication as an RFC or to translate it into languages other
   than English.

Table of Contents

   <a href="#section-1">1</a>.  Introduction . . . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-3">3</a>
     <a href="#section-1.1">1.1</a>.  Scope of This Document . . . . . . . . . . . . . . . . . .  <a href="#page-3">3</a>
     <a href="#section-1.2">1.2</a>.  DCCP NAT Traversal . . . . . . . . . . . . . . . . . . . .  <a href="#page-4">4</a>
     <a href="#section-1.3">1.3</a>.  Structure of This Document . . . . . . . . . . . . . . . .  <a href="#page-4">4</a>
   <a href="#section-2">2</a>.  Procedure for Near-Simultaneous-Open . . . . . . . . . . . . .  <a href="#page-5">5</a>
     <a href="#section-2.1">2.1</a>.  Conventions and Terminology  . . . . . . . . . . . . . . .  <a href="#page-5">5</a>
     <a href="#section-2.2">2.2</a>.  Protocol Method  . . . . . . . . . . . . . . . . . . . . .  <a href="#page-5">5</a>
       <a href="#section-2.2.1">2.2.1</a>.  DCCP-Listen Packet Format  . . . . . . . . . . . . . .  <a href="#page-6">6</a>
       <a href="#section-2.2.2">2.2.2</a>.  Protocol Method for DCCP Server Endpoints  . . . . . .  <a href="#page-7">7</a>
       <a href="#section-2.2.3">2.2.3</a>.  Protocol Method for DCCP Client Endpoints  . . . . . . <a href="#page-11">11</a>
       <a href="#section-2.2.4">2.2.4</a>.  Processing by Routers and Middleboxes  . . . . . . . . <a href="#page-11">11</a>
     <a href="#section-2.3">2.3</a>.  Examples of Use  . . . . . . . . . . . . . . . . . . . . . <a href="#page-12">12</a>
       <a href="#section-2.3.1">2.3.1</a>.  Repetition of DCCP-Listen  . . . . . . . . . . . . . . <a href="#page-13">13</a>
       <a href="#section-2.3.2">2.3.2</a>.  Optional Triggered Retransmission of DCCP-Request  . . <a href="#page-14">14</a>
     <a href="#section-2.4">2.4</a>.  Backwards Compatibility with <a href="rfc4340.html">RFC 4340</a>  . . . . . . . . . . <a href="#page-16">16</a>
   <a href="#section-3">3</a>.  Discussion of Design Decisions . . . . . . . . . . . . . . . . <a href="#page-16">16</a>
     <a href="#section-3.1">3.1</a>.  Rationale for a New Packet Type  . . . . . . . . . . . . . <a href="#page-17">17</a>
       <a href="#section-3.1.1">3.1.1</a>.  Use of Sequence Numbers  . . . . . . . . . . . . . . . <a href="#page-18">18</a>
     <a href="#section-3.2">3.2</a>.  Generation of Listen Packets . . . . . . . . . . . . . . . <a href="#page-18">18</a>
     <a href="#section-3.3">3.3</a>.  Repetition of DCCP-Listen Packets  . . . . . . . . . . . . <a href="#page-18">18</a>
   <a href="#section-4">4</a>.  Security Considerations  . . . . . . . . . . . . . . . . . . . <a href="#page-19">19</a>
   <a href="#section-5">5</a>.  IANA Considerations  . . . . . . . . . . . . . . . . . . . . . <a href="#page-20">20</a>
   <a href="#section-6">6</a>.  Acknowledgements . . . . . . . . . . . . . . . . . . . . . . . <a href="#page-20">20</a>
   <a href="#section-7">7</a>.  References . . . . . . . . . . . . . . . . . . . . . . . . . . <a href="#page-21">21</a>
     <a href="#section-7.1">7.1</a>.  Normative References . . . . . . . . . . . . . . . . . . . <a href="#page-21">21</a>
     <a href="#section-7.2">7.2</a>.  Informative References . . . . . . . . . . . . . . . . . . <a href="#page-21">21</a>
   <a href="#appendix-A">Appendix A</a>.  Discussion of Existing NAT Traversal Techniques . . . <a href="#page-23">23</a>
     <a href="#appendix-A.1">A.1</a>.  NAT Traversal Based on a Simultaneous-Request  . . . . . . <a href="#page-24">24</a>
     <a href="#appendix-A.2">A.2</a>.  Role Reversal  . . . . . . . . . . . . . . . . . . . . . . <a href="#page-25">25</a>














<span class="grey">Fairhurst                   Standards Track                     [Page 2]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-3" id="page-3" href="#page-3" class="invisible"> </a>
<span class="grey"><a href="rfc5596.html">RFC 5596</a>            DCCP Simultaneous-Open Technique      September 2009</span>


<span class="h2"><a class="selflink" name="section-1" href="#section-1">1</a>.  Introduction</span>

   The Datagram Congestion Control Protocol (DCCP) [<a href="rfc4340.html" title="&quot;Datagram Congestion Control Protocol (DCCP)&quot;">RFC4340</a>] is both
   datagram-based and connection-oriented.  According to <a href="rfc4340.html">RFC 4340</a>, DCCP
   servers establish connections by passively listening for incoming
   connection requests that are actively transmitted by DCCP clients.
   These asymmetric roles can cause problems when the server is 'inside'
   a middlebox, such as a Network Address Port Translation (NAPT), that
   only allows connection requests to be initiated from inside (e.g.,
   due to port overloading) [<a href="rfc5597.html" title="&quot;Network Address Translation (NAT) Behavioral Requirements for the Datagram Congestion Control Protocol&quot;">RFC5597</a>].  Host-based and network firewalls
   can also implement policies that lead to similar problems.  This
   behaviour is currently the default for many firewalls.

   UDP can support middlebox traversal using various techniques
   [<a href="rfc4787.html" title="&quot;Network Address Translation (NAT) Behavioral Requirements for Unicast UDP&quot;">RFC4787</a>] that leverage the connectionless nature of UDP and are
   therefore not suitable for DCCP.  TCP supports middlebox traversal
   through the use of its simultaneous-open procedure [<a href="rfc5382.html" title="&quot;NAT Behavioral Requirements for TCP&quot;">RFC5382</a>].  The
   concepts of the TCP solution are applicable to DCCP, but DCCP cannot
   simply reuse the same methods (see <a href="#appendix-A">Appendix A</a>).

   After discussing the problem space for DCCP, this document specifies
   an update to the DCCP state machine to offer native support that
   allows a DCCP client to establish a connection to a DCCP server that
   is inside one or more middleboxes.  This reduces dependence on
   external aids such as data relay servers [<a href="#ref-STUN" title="&quot;Traversal Using Relays around NAT (TURN): Relay Extensions to Session Traversal Utilities for NAT (STUN)&quot;">STUN</a>] by explicitly
   supporting a widely used principle known as 'hole punching'.

   The method requires only a minor change to the standard DCCP
   operational procedure.  The use of a dedicated DCCP packet type ties
   usage to a specific condition, ensuring the method is inter-operable
   with hosts that do not implement this update or that choose to
   disable it (see <a href="#section-4">Section 4</a>).

<span class="h3"><a class="selflink" name="section-1.1" href="#section-1.1">1.1</a>.  Scope of This Document</span>

   This method is useful in scenarios when a DCCP server is located
   inside the perimeter controlled by a middlebox.  It is relevant to
   both client/server and peer-to-peer applications, such as Voice over
   IP (VoIP), file sharing, or online gaming, and assists connections
   that utilise prior out-of-band signaling (e.g., via a well-known
   rendezvous server ([<a href="rfc3261.html" title="&quot;SIP: Session Initiation Protocol&quot;">RFC3261</a>], [<a href="#ref-H.323" title="&quot;Packet-based Multimedia Communications Systems&quot;">H.323</a>])) to notify both endpoints of
   the connection parameters ([<a href="rfc3235.html" title="&quot;Network Address Translator (NAT)-Friendly Application Design Guidelines&quot;">RFC3235</a>], [<a href="#ref-NAT-APP" title="&quot;Application Design Guidelines for Traversal through Network Address Translators&quot;">NAT-APP</a>]).









<span class="grey">Fairhurst                   Standards Track                     [Page 3]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-4" id="page-4" href="#page-4" class="invisible"> </a>
<span class="grey"><a href="rfc5596.html">RFC 5596</a>            DCCP Simultaneous-Open Technique      September 2009</span>


<span class="h3"><a class="selflink" name="section-1.2" href="#section-1.2">1.2</a>.  DCCP NAT Traversal</span>

   The behavioural requirements for NAT devices supporting DCCP are
   described in [<a href="rfc5597.html" title="&quot;Network Address Translation (NAT) Behavioral Requirements for the Datagram Congestion Control Protocol&quot;">RFC5597</a>].  A "traditional NAT" [<a href="rfc3022.html" title="&quot;Traditional IP Network Address Translator (Traditional NAT)&quot;">RFC3022</a>] that directly
   maps an IP address to a different IP address does not require the
   simultaneous-open technique described in this document.

   The method is required when the DCCP server is positioned behind one
   or more NAPT devices in the path (hierarchies of nested NAPT devices
   are possible).  This document refers to DCCP hosts located inside the
   perimeter controlled by one or more NAPT devices as having "private"
   addresses, and to DCCP hosts located in the global address realm as
   having "public" addresses.

   DCCP NAT traversal is considered for the following scenarios:

   1.  Private client connects to public server.

   2.  Public client connects to private server.

   3.  Private client connects to private server.

   A defining characteristic of traditional NAT devices [<a href="rfc3022.html" title="&quot;Traditional IP Network Address Translator (Traditional NAT)&quot;">RFC3022</a>] is
   that private hosts can connect to external hosts, but not vice versa.
   Hence, case (1) is possible using the protocol defined in [<a href="rfc4340.html" title="&quot;Datagram Congestion Control Protocol (DCCP)&quot;">RFC4340</a>].
   A pre-configured, static NAT address map would allow outside hosts to
   establish connections in cases (2) and (3).

   A DCCP implementation conforming to [<a href="rfc4340.html" title="&quot;Datagram Congestion Control Protocol (DCCP)&quot;">RFC4340</a>] and a NAT device
   conforming to [<a href="rfc5597.html" title="&quot;Network Address Translation (NAT) Behavioral Requirements for the Datagram Congestion Control Protocol&quot;">RFC5597</a>] would require a DCCP relay server to perform
   NAT traversal for cases (2) and (3).

   This document describes a method to support cases (2) and (3) without
   the aid of a DCCP relay server.  This method updates <a href="rfc4340.html">RFC 4340</a> and
   requires the DCCP server to discover the IP address and the DCCP port
   that correspond to the DCCP client.  Such signaling may be performed
   out-of-band (e.g., using the Session Description Protocol (SDP)
   [<a href="rfc4566.html" title="&quot;SDP: Session Description Protocol&quot;">RFC4566</a>]).

<span class="h3"><a class="selflink" name="section-1.3" href="#section-1.3">1.3</a>.  Structure of This Document</span>

   For background information on existing NAT traversal techniques,
   please consult <a href="#appendix-A">Appendix A</a>.

   The normative specification of the update is presented in <a href="#section-2">Section 2</a>.
   An informative discussion of underlying design decisions then follows
   in <a href="#section-3">Section 3</a>.  Security considerations are provided in <a href="#section-4">Section 4</a> and
   IANA considerations are provided in the concluding <a href="#section-5">Section 5</a>.



<span class="grey">Fairhurst                   Standards Track                     [Page 4]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-5" id="page-5" href="#page-5" class="invisible"> </a>
<span class="grey"><a href="rfc5596.html">RFC 5596</a>            DCCP Simultaneous-Open Technique      September 2009</span>


<span class="h2"><a class="selflink" name="section-2" href="#section-2">2</a>.  Procedure for Near-Simultaneous-Open</span>

   This section is normative and specifies the simultaneous-open
   technique for DCCP.  It updates the connection-establishment
   procedures of [<a href="rfc4340.html" title="&quot;Datagram Congestion Control Protocol (DCCP)&quot;">RFC4340</a>].

<span class="h3"><a class="selflink" name="section-2.1" href="#section-2.1">2.1</a>.  Conventions and Terminology</span>

   The document uses the terms and definitions provided in [<a href="rfc4340.html" title="&quot;Datagram Congestion Control Protocol (DCCP)&quot;">RFC4340</a>].
   Familiarity with this specification is assumed.  In particular, the
   following convention from <a href="rfc4340.html#section-3.2">Section&nbsp;3.2 of [RFC4340]</a> is used:

      Each DCCP connection runs between two hosts, which we often name
      DCCP A and DCCP B.  Each connection is actively initiated by one
      of the hosts, which we call the client; the other, initially
      passive host is called the server.

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in [<a href="rfc2119.html" title="&quot;Key words for use in RFCs to Indicate Requirement Levels&quot;">RFC2119</a>].

<span class="h3"><a class="selflink" name="section-2.2" href="#section-2.2">2.2</a>.  Protocol Method</span>

   The term "session" is used as defined in (<a href="rfc2663.html#section-2.3">[RFC2663], Section&nbsp;2.3</a>):
   DCCP sessions are uniquely identified by the 4-tuple of &lt;source IP-
   address, source port, target IP-address, target port&gt;.

   DCCP, in addition, introduces Service Codes, which can be used to
   identify different services available via the same port [<a href="rfc5595.html" title="&quot;The DCCP Service Code&quot;">RFC5595</a>].






















<span class="grey">Fairhurst                   Standards Track                     [Page 5]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-6" id="page-6" href="#page-6" class="invisible"> </a>
<span class="grey"><a href="rfc5596.html">RFC 5596</a>            DCCP Simultaneous-Open Technique      September 2009</span>


<span class="h4"><a class="selflink" name="section-2.2.1" href="#section-2.2.1">2.2.1</a>.  DCCP-Listen Packet Format</span>

   This document adds a new DCCP packet type, DCCP-Listen, whose format
   is shown below.

    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |          Source Port          |           Dest Port           |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  Data Offset  | CCVal | CsCov |           Checksum            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   | Res | Type  |X|   Reserved    |  Sequence Number High Bits    |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                    Sequence Number Low Bits                   |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                         Service Code                          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                 Figure 1: Format of a DCCP-Listen Packet

   o  The Source Port field indicates the port on which the DCCP server
      is listening for a connection from the IP address that appears as
      the destination IP address in the packet.

   o  The Destination Port field indicates the port selected by a DCCP
      client to identify the connection.  In this technique, this value
      must be communicated out-of-band to the server.

   o  The value of X MUST be set to 1.  A DCCP-Listen packet is sent
      before a connection is established; therefore, there is no way to
      negotiate use of short sequence numbers (<a href="rfc4340.html#section-5.1">[RFC4340], Section&nbsp;5.1</a>).

   o  The value of the Sequence Number field in a DCCP-Listen packet is
      not related to the DCCP sequence number used in normal DCCP
      messages (see <a href="#section-3">Section 3</a> for a description of the use of the DCCP
      sequence number).  Thus, for DCCP-Listen packets:

      *  A DCCP server SHOULD set the high and low bits of the Sequence
         Number field to 0.

      *  A DCCP client MUST ignore the value of the Sequence Number
         field.

      *  Middleboxes MUST NOT interpret sequence numbers in DCCP-Listen
         packets.





<span class="grey">Fairhurst                   Standards Track                     [Page 6]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-7" id="page-7" href="#page-7" class="invisible"> </a>
<span class="grey"><a href="rfc5596.html">RFC 5596</a>            DCCP Simultaneous-Open Technique      September 2009</span>


   o  The Service Code field contains the Service Code value for which
      the server is listening for a connection (<a href="rfc4340.html#section-8.1.2">Section&nbsp;8.1.2 of
      [RFC4340]</a> and [<a href="rfc5595.html" title="&quot;The DCCP Service Code&quot;">RFC5595</a>]).  This value MUST correspond to a Service
      Code that the server is actually offering for a connection
      identified by the same source IP address and the same source port
      as that of the DCCP-Listen packet.  Since the server may use
      multiple Service Codes, the specific value of the Service Code
      field needs to be communicated out-of-band, from client to server,
      prior to sending the DCCP-Listen packet, e.g., described using the
      Session Description Protocol (SDP) [<a href="rfc4566.html" title="&quot;SDP: Session Description Protocol&quot;">RFC4566</a>].

   o  At the time of writing, there are no known uses of header options
      (<a href="rfc4340.html#section-5.8">[RFC4340], Section&nbsp;5.8</a>) with a DCCP-Listen packet.  Clients MUST
      ignore all options in received DCCP-Listen packets.  Therefore,
      feature values cannot be negotiated using a DCCP-Listen packet.

   o  At the time of writing, there are no known uses of payload data
      with a DCCP-Listen packet.  Since DCCP-Listen packets are issued
      before an actual connection is established, endpoints MUST ignore
      any payload data encountered in DCCP-Listen packets.

   o  The following protocol fields are required to have specific
      values:

      *  Data Offset MUST have a value of five or more (i.e., at least
         20 bytes).

      *  CCVal MUST be zero (a connection has not been established).

      *  CsCov MUST be zero (use of the CsCov feature cannot be
         negotiated).

      *  Type has the value 10, assigned by IANA to denote a DCCP-Listen
         packet.

      *  X MUST be 1 (the generic header must be used).

   The remaining fields, including the "Res" and "Reserved" fields are
   specified by [<a href="rfc4340.html" title="&quot;Datagram Congestion Control Protocol (DCCP)&quot;">RFC4340</a>] and its successors.  The interpretation of
   these fields is not modified by this document.

<span class="h4"><a class="selflink" name="section-2.2.2" href="#section-2.2.2">2.2.2</a>.  Protocol Method for DCCP Server Endpoints</span>

   This document updates <a href="rfc4340.html#section-8.1">Section&nbsp;8.1 of [RFC4340]</a> for the case of a
   fully specified DCCP server endpoint.  The update modifies the way
   the server performs a passive-open.





<span class="grey">Fairhurst                   Standards Track                     [Page 7]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-8" id="page-8" href="#page-8" class="invisible"> </a>
<span class="grey"><a href="rfc5596.html">RFC 5596</a>            DCCP Simultaneous-Open Technique      September 2009</span>


   Prior to connection setup, it is common for a DCCP server endpoint to
   not be fully specified: before the connection is established, a
   server usually specifies only the destination port and Service Code.
   (Sometimes the destination address is also specified.)  This leaves
   the source address and source port unspecified.  The endpoint only
   becomes fully specified after performing the handshake for an
   incoming connection.  For such cases, this document does not update
   <a href="rfc4340.html#section-8.4">Section&nbsp;8.4 of [RFC4340]</a>, i.e., the server adheres to the existing
   state transitions in the left half of Figure 2 (CLOSED =&gt; LISTEN =&gt;
   RESPOND).

   A fully specified DCCP server endpoint permits exactly one client,
   identified by source IP-address:port, destination IP-address:port,
   plus a single Service Code, to set up the connection.  Such a server
   SHOULD perform the actions and state transitions shown in the right
   half of Figure 2 and specified below.

           unspecified remote   +--------+   fully specified remote
          +---------------------| CLOSED |---------------------+
          |                     +--------+   send DCCP-Listen  |
          |                                                    |
          v                                                    v
     +--------+                                  timeout  +---------+
     | LISTEN |                           +---+-----------| INVITED |
     +--------+                           |   |           +---------+
          |                               |   |  1st / 2nd  ^  |
          |                 more than 2   |   |  retransm.  |  | receive
          |               retransmissions |   +-------------+  | Request
          |                               |    resend Listen   v
          |                               |               +---------+
          |                               +--------------&gt;| LISTEN1 |
          |                                               +---------+
          |                                                    |
          |  receive Request   +---------+    receive Request* |
          +-------------------&gt;| RESPOND |&lt;--------------------+
             send Response     +---------+    send Response

   * Note: The case of a server that responds to a DCCP-Request in
   the INVITED state, transitions to the LISTEN1 state, and then
   immediately transitions to the RESPOND state does not require
   reception of an additional DCCP-Request packet.

        Figure 2: Updated State Transition Diagram for DCCP-Listen








<span class="grey">Fairhurst                   Standards Track                     [Page 8]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-9" id="page-9" href="#page-9" class="invisible"> </a>
<span class="grey"><a href="rfc5596.html">RFC 5596</a>            DCCP Simultaneous-Open Technique      September 2009</span>


   This diagram introduces two additional DCCP server states in addition
   to those listed in <a href="rfc4340.html#section-4.3">Section&nbsp;4.3 of [RFC4340]</a>:

   INVITED
      The INVITED state is associated with a specific DCCP connection
      and represents a fully specified server socket in the listening
      state that is generating DCCP-Listen packets towards the client.

   LISTEN1
      The LISTEN1 state is associated with a specific DCCP connection
      and represents a fully specified server socket in the passive
      listening state that will not generate further DCCP-Listen packets
      towards the client.

   A fully specified server endpoint performs a passive-open from the
   CLOSED state by inviting the remote client to connect.  This is
   performed by sending a single DCCP-Listen packet to the specified
   remote IP-address:port, using the format specified in <a href="#section-2.2.1">Section 2.2.1</a>.
   The figure below provides pseudocode describing the packet processing
   in the INVITED state.  This processing step follows Step 2 in <a href="rfc4340.html#section-8.5">Section</a>
   <a href="rfc4340.html#section-8.5">8.5 of [RFC4340]</a>).

   The INVITED state is, like LISTEN, a passive state, characterised by
   waiting in the absence of an established connection.  If the server
   endpoint in the INVITED state receives a DCCP-Request that matches
   the set of bound ports and addresses, it transitions to the LISTEN1
   state and then immediately transitions to the RESPOND state, where
   further processing resumes as specified in [<a href="rfc4340.html" title="&quot;Datagram Congestion Control Protocol (DCCP)&quot;">RFC4340</a>].

   The server SHOULD repeat sending a DCCP-Listen packet while in the
   INVITED state, at a 200-millisecond interval with up to at most 2
   repetitions (<a href="#section-3">Section 3</a> discusses this choice of time interval).  If
   the server is still in the INVITED state after a further period of
   200ms following transmission of the third DCCP-Listen packet, it
   SHOULD progress to the LISTEN1 state.

   Fully specified server endpoints SHOULD treat ICMP error messages
   received in response to a DCCP-Listen packet as "soft errors" that do
   not cause a state transition.  Reception of an ICMP error message as
   a result of sending a DCCP-Listen packet does not necessarily
   indicate a failure of the following connection request, and therefore
   should not result in a server state change.  This reaction to soft
   errors exploits the valuable feature of the Internet that, for many
   network failures, the network can be dynamically reconstructed
   without any disruption of the endpoints.

   Server endpoints SHOULD ignore any incoming DCCP-Listen packets.  A
   DCCP server in the LISTEN, INVITED, or LISTEN1 states MAY generate a



<span class="grey">Fairhurst                   Standards Track                     [Page 9]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-10" id="page-10" href="#page-10" class="invisible"> </a>
<span class="grey"><a href="rfc5596.html">RFC 5596</a>            DCCP Simultaneous-Open Technique      September 2009</span>


   DCCP-Reset packet (Code 7, "Connection Refused") in response to a
   received DCCP-Listen packet.  This DCCP-Reset packet is an indication
   that two servers are simultaneously awaiting connections on the same
   port.

   Further details on the design rationale are discussed in <a href="#section-3">Section 3</a>.

   The figure below provides pseudocode describing the packet processing
   in the INVITED state.  This processing step follows Step 2 in <a href="rfc4340.html#section-8.5">Section</a>
   <a href="rfc4340.html#section-8.5">8.5 of RFC 4340</a> [<a href="rfc4340.html" title="&quot;Datagram Congestion Control Protocol (DCCP)&quot;">RFC4340</a>].

    Step 2a: Process INVITED state
      If S.state == INVITED,
          /* State only entered for fully specified server endpoints */
          /* on entry S will have been set to a socket */
          If P.type == Request
             /* Exit INVITED state and continue to process the packet */
             S.state = LISTEN1
             Continue with S.state := LISTEN1
          Otherwise,
             If P.type == Listen
                /* The following line is optional */
                Generate Reset(Connection Refused)
                /* Otherwise, drop packet and return */
             Otherwise,
                Generate Reset(No Connection) unless P.type == Reset

    Step 2b: Process LISTEN1 state
      If S.state == LISTEN1,
          /* State only entered for fully specified server endpoints */
          /* Follows receipt of a Response packet */
          /* or sending third Listen packet (after timer expiry) */
          If P.type == Request,
             S.state = RESPOND
             Choose S.ISS (initial seqno) or set from Init Cookies
             Initialize S.GAR := S.ISS
             Set S.ISR, S.GSR, S.SWL, S.SWH from packet or Init Cookies
             Continue with S.state == RESPOND
             /* A Response packet will be generated in Step 11 */
          Otherwise,
             If P.type == Listen
                /* The following line is optional */
                Generate Reset(Connection Refused)
                /* Otherwise, drop packet and return */
             Otherwise,
                Generate Reset(No Connection) unless P.type == Reset

     Figure 3: Updated DCCP Pseudocode for INVITED and LISTEN1 States



<span class="grey">Fairhurst                   Standards Track                    [Page 10]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-11" id="page-11" href="#page-11" class="invisible"> </a>
<span class="grey"><a href="rfc5596.html">RFC 5596</a>            DCCP Simultaneous-Open Technique      September 2009</span>


<span class="h4"><a class="selflink" name="section-2.2.3" href="#section-2.2.3">2.2.3</a>.  Protocol Method for DCCP Client Endpoints</span>

   This document updates <a href="rfc4340.html#section-8.1.1">Section&nbsp;8.1.1 of [RFC4340]</a> by adding the
   following rule for the reception of DCCP-Listen packets by clients:

   Endpoints are required to ignore any header options or payload data
   encountered in DCCP-Listen packets (<a href="#section-2.2.1">Section 2.2.1</a>) and hence do not
   provide meaningful communication to a client.  A client in any state
   MUST silently discard any received DCCP-Listen packet, unless it
   implements the optional procedure defined in the following section.

<span class="h5"><a class="selflink" name="section-2.2.3.1" href="#section-2.2.3.1">2.2.3.1</a>.  Optional Generation of Triggered Requests</span>

   This section describes an optional optimisation at the client that
   can allow the client to avoid having to wait for a timeout following
   a dropped DCCP-Request.  The operation requires clients to respond to
   reception of DCCP-Listen packets when received in the REQUEST state.
   DCCP-Listen packets MUST be silently discarded in all other states.

   A client implementing this optimisation MAY immediately perform a
   retransmission of a DCCP-Request following the reception of the first
   DCCP-Listen packet.  The retransmission is performed in the same
   manner as a timeout in the REQUEST state [<a href="rfc4340.html" title="&quot;Datagram Congestion Control Protocol (DCCP)&quot;">RFC4340</a>].  A triggered
   retransmission SHOULD result in the client increasing the
   exponential-backoff timer interval.

   Note that a path delay greater than 200ms will result in multiple
   DCCP-Listen packets arriving at the client before a DCCP-Response is
   received.  Clients MUST therefore perform only one such
   retransmission for each DCCP connection.  This requires maintaining
   local state (e.g., one flag per connection).

   Implementors and users of this optional method need to be aware that
   host timing or path reordering can result in a server receiving two
   DCCP-Requests (i.e., the server sending one unnecessary packet).
   This would, in turn, trigger a client to send a second corresponding
   DCCP-Response (also unnecessary).  These additional packets are not
   expected to modify or delay the DCCP open procedure [<a href="rfc4340.html" title="&quot;Datagram Congestion Control Protocol (DCCP)&quot;">RFC4340</a>].

   <a href="#section-2.3.2">Section 2.3.2</a> provides examples of the use of triggered
   retransmission.

<span class="h4"><a class="selflink" name="section-2.2.4" href="#section-2.2.4">2.2.4</a>.  Processing by Routers and Middleboxes</span>

   DCCP-Listen packets do not require special treatment and should thus
   be forwarded end-to-end across Internet paths, by routers and
   middleboxes alike.




<span class="grey">Fairhurst                   Standards Track                    [Page 11]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-12" id="page-12" href="#page-12" class="invisible"> </a>
<span class="grey"><a href="rfc5596.html">RFC 5596</a>            DCCP Simultaneous-Open Technique      September 2009</span>


   Middleboxes may utilise the connection information (address, port,
   Service Code) to establish local forwarding state.  The DCCP-Listen
   packet carries the necessary information to uniquely identify a DCCP
   session in combination with the source and destination addresses
   (found in the enclosing IP header), including the DCCP Service Code
   value [<a href="rfc5595.html" title="&quot;The DCCP Service Code&quot;">RFC5595</a>].  The processing of the DCCP-Listen packet by NAT
   devices is specified in [<a href="rfc5597.html" title="&quot;Network Address Translation (NAT) Behavioral Requirements for the Datagram Congestion Control Protocol&quot;">RFC5597</a>].

<span class="h3"><a class="selflink" name="section-2.3" href="#section-2.3">2.3</a>.  Examples of Use</span>

   In the examples below, DCCP A is the client and DCCP B is the server.
   A middlebox device (NAT/Firewall), NA, is placed before DCCP A, and
   another middlebox, NB, is placed before DCCP B.  Both NA and NB use a
   policy that permits DCCP packets to traverse the device for outgoing
   links, but only permits incoming DCCP packets when a previous packet
   has been sent out for the same connection.

   In the figure below, DCCP A and DCCP B decide to communicate using an
   out-of-band mechanism (in this case, labelled SDP), whereupon the
   client and server are started.  DCCP B actively indicates its
   listening state by sending a DCCP-Listen message.  This fulfills the
   requirement of punching a hole in NB (also creating the binding to
   the external address and port).  This message is dropped by NA since
   no hole exists there yet.  DCCP A initiates a connection by entering
   the REQUEST state and sending a DCCP-Request.  (It is assumed that if
   NA were a NAT device, then this would also result in a binding that
   maps the pinhole to the external address and port.)  The DCCP-Request
   is received by DCCP B, via the binding at NB.  DCCP B transmits the
   DCCP-Response and connects through the bindings now in place at NA
   and NB.

    DCCP A                                        DCCP B
    ------               NA      NB               ------
    +-----------------+  +-+    +-+  +-----------------+
    |                 |  | |    | |  |                 | State = CLOSED
    | SDP --&gt;         |--+-+----+-+-&gt;|                 | State = INVITED
    |                 |  | |X---+-+--|&lt;-- DCCP-Listen  |
    |(State=REQUEST)  |  | |    | |  |                 |
    |DCCP-Request --&gt; |--+-+----+-+-&gt;|                 |
    |(State=PARTOPEN) | &lt;+-+----+-+--|&lt;-- DCCP-Response| State = RESPOND
    |DCCP-Ack --&gt;     |--+-+----+-+&gt; |                 |
    |                 |  | |    | |  |                 |
    |                 |  | |    | |  |                 |
    |DCCP-Data --&gt;    |--+-+----+-+-&gt;|                 | State = OPEN
    +-----------------+  +-+    +-+  +-----------------+

   Figure 4: Event Sequence When the Server Is Started Before the Client




<span class="grey">Fairhurst                   Standards Track                    [Page 12]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-13" id="page-13" href="#page-13" class="invisible"> </a>
<span class="grey"><a href="rfc5596.html">RFC 5596</a>            DCCP Simultaneous-Open Technique      September 2009</span>


<span class="h4"><a class="selflink" name="section-2.3.1" href="#section-2.3.1">2.3.1</a>.  Repetition of DCCP-Listen</span>

   This section examines the effect of not receiving the DCCP-Request.

   The figure below shows the sequence of packets where the DCCP server
   enters the INVITED state after reception of out-of-band signaling
   (e.g., SDP).  The key timer operations at the client and server are
   respectively shown on the left and right of the diagram.  It
   considers the case when the server does not receive a DCCP-Request
   within the first 600ms (often the request would be received within
   this interval).

   The repetition of DCCP-Listen packets may be implemented using a
   timer.  The timer is restarted with an interval of 200ms when sending
   each DCCP-Listen packet.  It is cancelled when the server leaves the
   INVITED state.  If the timer expires after the first and second
   transmission, it triggers a transmission of another DCCP-Listen
   packet.  If it expires after sending the third DCCP-Listen packet,
   the server leaves the INVITED state to enter the LISTEN1 state (where
   it passively waits for a DCCP-Request).































<span class="grey">Fairhurst                   Standards Track                    [Page 13]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-14" id="page-14" href="#page-14" class="invisible"> </a>
<span class="grey"><a href="rfc5596.html">RFC 5596</a>            DCCP Simultaneous-Open Technique      September 2009</span>


                DCCP A                           DCCP B
                ------  NA      NB               ------
                +----+  +-+    +-+  +-----------------+
                |    |  | |    | |  |                 | State = CLOSED
                | --&gt;|--+-+----+-+--|--&gt; SDP          |
                |    |  | |    | |  |                 | State = INVITED
                |    |  | |    | |  |                 |
                |    |  | |X---+-+--|&lt;-- DCCP-Listen  | Timer Starts
                |    |  | |    | |  |                 |      |
   DCCP-Request | --&gt;|---&gt;+--X | |  |   (dropped)     |      |
   Timer Starts |    |  | |    | |  |                 |      |
         |      |    |  | |    | |  |                 | 1st Timer Expiry
         |      |    |&lt;-+-+----+++--|&lt;-- DCCP-Listen  |
         |      |    |  | |    | |  |                 | Timer Starts
         |      |    |  | |    | |  |                 |       |
         |      |    |  | |    | |  |                 | 2nd Timer Expiry
         |      |    |  | |    | |  |                 |
         |      |    |&lt;-+-+----+-+--|&lt;-- DCCP-Listen  | Timer Starts
         |      |    |  | |    | |  |                 |       |
         |      |    |  | |    | |  |                 | 3rd Timer Expiry
         |      |    |  | |    | |  |                 |
         |      |    |  | |    | |  |                 | State = LISTEN1
         |      ~    ~  ~ ~    ~ ~  ~                 ~
         |      |    |  | |    | |  |                 |
   Timer Expiry | --&gt;|--+-+----+-+--|--&gt; DCCP-Request |
                |    |  | |    | |  |                 | State = RESPOND
                | &lt;--|--+-+----+-+--|&lt;-- DCCP-Response|
                +----+  +-+    +-+  +-----------------+

              Figure 5: Repetition of the DCCP-Listen Packet

<span class="h4"><a class="selflink" name="section-2.3.2" href="#section-2.3.2">2.3.2</a>.  Optional Triggered Retransmission of DCCP-Request</span>

   The following figure illustrates a triggered retransmission.  In this
   figure, the first DCCP-Listen is assumed to be lost in the network
   (e.g., does not open a pinhole at NB).  A later DCCP-Request is also
   not received (perhaps as a side effect of the first loss).  After
   200ms, the DCCP-Listen packet is retransmitted and correctly
   received.  This triggers the retransmission of the DCCP-Request,
   which, when received, results in a corresponding DCCP-Response.











<span class="grey">Fairhurst                   Standards Track                    [Page 14]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-15" id="page-15" href="#page-15" class="invisible"> </a>
<span class="grey"><a href="rfc5596.html">RFC 5596</a>            DCCP Simultaneous-Open Technique      September 2009</span>


   DCCP A                                         DCCP B
   ------               NA      NB               ------
   +-----------------+  +-+    +-+  +-----------------+
   |                 |  | |    | |  |                 | State = CLOSED
   |SDP              |--+-+----+-+-&gt;|                 | State = INVITED
   |(State= REQUEST) |  | |    | |  |                 |
   |                 |  | |    | |X-|&lt;-- DCCP-Listen  |
   |DCCP-Request --&gt; |--+-+---X| |  |                 |
   |                 | &lt;+-+----+-+--|&lt;-- DCCP-Listen  |(retransmit)
   |                 |  | |    | |  |                 |
   |DCCP-Request --&gt; |--+-+----+-+-&gt;|                 | State = RESPOND
   |  (Triggered)    |  | |    | |  |                 |
   |                 |&lt;-+-+----+-+--|&lt;-- DCCP-Response|
   |(State= PARTOPEN)|  | |    | |  |                 |
   |DCCP-Ack --&gt;     |--+-+----+-+-&gt;|                 | State = OPEN
   +-----------------+  +-+    +-+  +-----------------+

            Figure 6: Example Showing a Triggered DCCP-Request

   The figure below illustrates the sequence of packets exchanged when a
   DCCP-Listen and DCCP-Request are processed out of order.  Reception
   of the DCCP-Listen packet by the client triggers retransmission of
   the DCCP-Request.  The server responds to the first DCCP-Request and
   enters the RESPOND state.  The server subsequently responds to the
   second DCCP-Request with another DCCP-Response, which is ignored by
   the client (already in the PARTOPEN state).

























<span class="grey">Fairhurst                   Standards Track                    [Page 15]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-16" id="page-16" href="#page-16" class="invisible"> </a>
<span class="grey"><a href="rfc5596.html">RFC 5596</a>            DCCP Simultaneous-Open Technique      September 2009</span>


   DCCP A                                        DCCP B
   ------                NA     NB              ------
   +-----------------+  +-+    +-+  +-----------------+
   |                 |  | |    | |  |                 | State = CLOSED
   |SDP              |--+-+----+-+-&gt;|                 | State = INVITED
   |(State = REQUEST)|  | |    | |  |                 |
   |DCCP-Request --&gt; |--+-+-  -+-+--|&lt;-- DCCP-Listen  |
   |                 |  | | \/ | |  |                 |
   |                 |  | | /\ | |  |                 |
   |                 |&lt;-+-+-  -+-+-&gt;|                 |
   |DCCP-Request --&gt; |--+-+-  -+-+--|&lt;-- DCCP-Response| State = RESPOND
   |  (Triggered)    |  | | \/ | |  |                 |
   |                 |  | | /\ | |  |                 |
   |                 |&lt;-+-+-  -+-+-&gt;|                 |
   |(State= PARTOPEN)|  | |    | |  |                 |
   |DCCP-Ack     --&gt; |--+-+-  -+-+--|&lt;-- DCCP-Response|
   |  (Triggered)    |  | | \/ | |  |                 |
   |                 |  | | /\ | |  |                 |
   |  (Ignored)      |&lt;-+-+-  -+-+-&gt;|                 | State = OPEN
   |                 |  | |    | |  |                 |
   +-----------------+  +-+    +-+  +-----------------+

      Figure 7: Example Showing an Unnecessary Triggered DCCP-Request

<span class="h3"><a class="selflink" name="section-2.4" href="#section-2.4">2.4</a>.  Backwards Compatibility with <a href="rfc4340.html">RFC 4340</a></span>

   No changes are required if a DCCP client conforming to this document
   communicates with a DCCP server conforming to [<a href="rfc4340.html" title="&quot;Datagram Congestion Control Protocol (DCCP)&quot;">RFC4340</a>].

   If a client implements only [<a href="rfc4340.html" title="&quot;Datagram Congestion Control Protocol (DCCP)&quot;">RFC4340</a>], an incoming DCCP-Listen packet
   would be ignored due to step 1 in <a href="rfc4340.html#section-8.1">Section&nbsp;8.1 of [RFC4340]</a>, which at
   the same time also conforms to the behaviour specified by this
   document.

   This document further does not modify communication for any DCCP
   server that implements a passive-open without fully binding the
   addresses, ports, and Service Codes to be used.  The authors
   therefore do not expect practical deployment problems with existing,
   conformant DCCP implementations.

<span class="h2"><a class="selflink" name="section-3" href="#section-3">3</a>.  Discussion of Design Decisions</span>

   This is an informative section that reviews the rationale for the
   design of this method.







<span class="grey">Fairhurst                   Standards Track                    [Page 16]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-17" id="page-17" href="#page-17" class="invisible"> </a>
<span class="grey"><a href="rfc5596.html">RFC 5596</a>            DCCP Simultaneous-Open Technique      September 2009</span>


<span class="h3"><a class="selflink" name="section-3.1" href="#section-3.1">3.1</a>.  Rationale for a New Packet Type</span>

   The DCCP-Listen packet specified in <a href="#section-2.2.1">Section 2.2.1</a> has the same format
   as the DCCP-Request packet (<a href="rfc4340.html#section-5.1">[RFC4340], Section&nbsp;5.1</a>), the only
   difference is in the value of the Type field.  The usage, however,
   differs.  The DCCP-Listen packet serves as an advisory message, not
   as part of the actual connection setup: sequence numbers have no
   meaning, and no payload can be communicated.

   A DCCP-Request packet could, in theory, also have been used for the
   same purpose.  The following arguments were against this:

   The first problem was that of semantic overloading: the DCCP-Request
   defined in [<a href="rfc4340.html" title="&quot;Datagram Congestion Control Protocol (DCCP)&quot;">RFC4340</a>] serves a well-defined purpose, being the initial
   packet of the 3-way handshake.  Additional use in the manner of a
   DCCP-Listen packet would have required DCCP processors to have two
   different processing paths: one where a DCCP-Request was interpreted
   as part of the initial handshake, and another where the same packet
   was interpreted as an indication of an intention to accept a new
   connection.  This would complicate packet processing in hosts and, in
   particular, stateful middleboxes (which may have restricted
   computational resources).

   The second problem is that a client receiving a DCCP-Request from a
   server could generate a DCCP-Reset packet if it had not yet entered
   the REQUEST state (step 7 in <a href="rfc4340.html#section-8.5">Section&nbsp;8.5 of [RFC4340]</a>).  The method
   specified in this document lets client endpoints ignore DCCP-Listen
   packets.  Adding a similar rule for the DCCP-Request packet would
   have been cumbersome: clients would not have been able to distinguish
   between a DCCP-Request packet meant to indicate an intention to
   accept a new connection and a genuinely erratic connection
   initiation.

   The third problem is similar and refers to a client receiving the
   indication after having itself sent a (connection-initiation) DCCP-
   Request.  Step 7 in <a href="rfc4340.html#section-8.5">Section&nbsp;8.5 of [RFC4340]</a> requires the client to
   reply to a DCCP-Request from the server with a DCCP-Sync packet.
   Since sequence numbers are ignored for this type of message,
   additional and complex processing would become necessary: either to
   ask the client not to respond to a DCCP-Request when the request is
   used as an indication, or to ask middleboxes and servers to ignore
   DCCP-Sync packets generated in response to DCCP-Request packets that
   are used as indications.  Furthermore, since no initial sequence
   numbers have been negotiated at this stage, sending a DCCP-SyncAck
   would not be meaningful.

   The use of a separate packet type therefore allows simpler and
   clearer processing.



<span class="grey">Fairhurst                   Standards Track                    [Page 17]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-18" id="page-18" href="#page-18" class="invisible"> </a>
<span class="grey"><a href="rfc5596.html">RFC 5596</a>            DCCP Simultaneous-Open Technique      September 2009</span>


<span class="h4"><a class="selflink" name="section-3.1.1" href="#section-3.1.1">3.1.1</a>.  Use of Sequence Numbers</span>

   Although the DCCP-Listen Sequence Number fields are ignored, they
   have been retained in the DCCP-Listen packet header to reuse the
   generic header format from <a href="rfc4340.html#section-5.1">Section&nbsp;5.1 of [RFC4340]</a>.

   DCCP assigns a random initial value to the sequence number when a
   DCCP connection is established [<a href="rfc4340.html" title="&quot;Datagram Congestion Control Protocol (DCCP)&quot;">RFC4340</a>].  However, a sender is
   required to set this value to zero for a DCCP-Listen packet.  Both
   clients and middleboxes are also required to ignore this value.

   The rationale for ignoring the Sequence Number fields of DCCP-Listen
   packets is that, at the time the DCCP-Listen is exchanged, the
   endpoints have not yet entered connection setup: the DCCP-Listen
   packet is sent while the server is still in the passive-open
   (INVITED) state, i.e., it has not yet allocated state, other than
   binding to the client's IP-address:port and Service Code.

<span class="h3"><a class="selflink" name="section-3.2" href="#section-3.2">3.2</a>.  Generation of Listen Packets</span>

   A DCCP server should by default permit generation of DCCP-Listen
   packets.  Since DCCP-Listen packets solve a particular problem with
   NAT and/or firewall traversal, the generation of DCCP-Listen packets
   on passive sockets is tied to a condition (binding to a remote
   address and Service Code that are both known a priori) to ensure this
   does not interfere with the general case of "normal" DCCP connections
   (where client addresses are generally not known in advance).

   In the TCP world, the analogue is a transition from LISTEN to
   SYN_SENT by virtue of sending data: "A fully specified passive call
   can be made active by the subsequent execution of a SEND" (<a href="https://tools.ietf.org/html/rfc0793#section-3.8">[RFC0793],
   Section&nbsp;3.8</a>).  Unlike TCP, this update does not perform a role change
   from passive to active.  Like TCP, DCCP-Listen packets are only sent
   by a DCCP-server when the endpoint is fully specified (<a href="#section-2.2">Section 2.2</a>).

<span class="h3"><a class="selflink" name="section-3.3" href="#section-3.3">3.3</a>.  Repetition of DCCP-Listen Packets</span>

   Repetition is a necessary requirement to increase robustness and the
   chance of successful connection establishment when a DCCP-Listen
   packet is lost due to congestion, link loss, or some other reason.

   The decision to recommend a maximum number of 3 timeouts (2 repeated
   copies of the original DCCP-Listen packet) results from the following
   consideration: the repeated copies need to be spaced sufficiently far
   apart in time to avoid suffering from correlated loss.  The interval
   of 200ms was chosen to accommodate a wide range of wireless and wired
   network paths.




<span class="grey">Fairhurst                   Standards Track                    [Page 18]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-19" id="page-19" href="#page-19" class="invisible"> </a>
<span class="grey"><a href="rfc5596.html">RFC 5596</a>            DCCP Simultaneous-Open Technique      September 2009</span>


   Another constraint is given by the retransmission interval for the
   DCCP-Request (<a href="rfc4340.html#section-8.1.1">[RFC4340], Section&nbsp;8.1.1</a>).  To establish state,
   intermediate systems need to receive a (retransmitted) DCCP-Listen
   packet before the DCCP-Request times out (1 second).  With three
   timeouts, each spaced 200 milliseconds apart, the overall time is
   still below one second.  The sum of 600 milliseconds is sufficiently
   large to provide for longer one-way delays, as is the case, e.g., on
   some wireless links.

   The rationale behind transitioning to the LISTEN1 state after two
   repetitions is that other problems, independent of establishing
   middlebox state, may occur (such as delay or loss of the initial
   DCCP-Request).  Any late or retransmitted DCCP-Request packets will
   then still reach the server, allowing connection establishment to
   successfully complete.

<span class="h2"><a class="selflink" name="section-4" href="#section-4">4</a>.  Security Considerations</span>

   General security considerations for DCCP are described in [<a href="rfc4340.html" title="&quot;Datagram Congestion Control Protocol (DCCP)&quot;">RFC4340</a>].
   Security considerations for Service Codes are further described in
   [<a href="rfc5595.html" title="&quot;The DCCP Service Code&quot;">RFC5595</a>].

   The method specified in this document generates a DCCP-Listen packet
   addressed to a specific DCCP client.  This exposes the state of a
   DCCP server that is in a passive listening state (i.e., waiting to
   accept a connection from a known client).

   The exposed information is not encrypted and therefore could be seen
   on the network path to the DCCP client.  An attacker on this return
   path could observe a DCCP-Listen packet and then exploit this by
   spoofing a packet (e.g., DCCP-Request or DCCP-Reset) with the IP
   addresses, DCCP ports, and Service Code that correspond to the values
   to be used for the connection.  As in other on-path attacks, this
   could be used to inject data into a connection or to deny a
   connection request.  A similar on-path attack is also possible for
   any DCCP connection, once the session is initiated by the client
   (<a href="rfc4340.html#section-18">[RFC4340], Section&nbsp;18</a>).

   The DCCP-Listen packet is only sent in response to explicit, prior
   out-of-band signaling from a DCCP client to the DCCP server (e.g.,
   SDP [<a href="rfc4566.html" title="&quot;SDP: Session Description Protocol&quot;">RFC4566</a>] information communicated via the Session Initiation
   Protocol [<a href="rfc3261.html" title="&quot;SIP: Session Initiation Protocol&quot;">RFC3261</a>]) and will normally directly precede a DCCP-Request
   sent by the client (which carries the same information).

   This update does not significantly increase the complexity or
   vulnerability of a DCCP implementation that conforms to [<a href="rfc4340.html" title="&quot;Datagram Congestion Control Protocol (DCCP)&quot;">RFC4340</a>].  A
   DCCP server SHOULD therefore, by default, permit generation of DCCP-
   Listen packets.  A server that wishes to prevent disclosing this



<span class="grey">Fairhurst                   Standards Track                    [Page 19]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-20" id="page-20" href="#page-20" class="invisible"> </a>
<span class="grey"><a href="rfc5596.html">RFC 5596</a>            DCCP Simultaneous-Open Technique      September 2009</span>


   information MAY refrain from generating DCCP-Listen packets without
   impacting subsequent DCCP state transitions, but possibly inhibiting
   middlebox traversal.

   The DCCP base specification in <a href="rfc4340.html">RFC 4340</a> defines an Init Cookie
   option, which lets a DCCP server avoid having to hold any state until
   the three-way, connection-setup handshake has completed.  This
   specification enables an out-of-band mechanism that forces the server
   to hold state for a connection that has not yet been established.
   This is a change in the security profile of DCCP, although the impact
   is expected to be minimal and depends on the security features of the
   out-of-band mechanism (SIP SDP is one such mechanism that provides
   sufficient security features).

   The method creates a new way for a client to set up a DCCP connection
   to a server using out-of-band data, transported over a signaling
   connection.  If the signaling connection is not encrypted, an
   eavesdropper could see the client IP address and the port for the to-
   be-established DCCP connection, and generate a DCCP-Listen packet
   towards the client using its own server IP address and port.
   However, a client will only respond to a received DCCP-Listen packet
   if the server IP address and port match an existing DCCP connection
   that is in the REQUEST state (<a href="#section-2.3.2">Section 2.3.2</a>).  The method therefore
   cannot be used to redirect the connection to a different server IP
   address.

<span class="h2"><a class="selflink" name="section-5" href="#section-5">5</a>.  IANA Considerations</span>

   The IANA registered a new packet type, "DCCP-Listen", in the IANA
   DCCP Packet Types Registry.  The decimal value 10 has been assigned
   to this type.  This registry entry references this document.

<span class="h2"><a class="selflink" name="section-6" href="#section-6">6</a>.  Acknowledgements</span>

   This update was originally co-authored by Dr. Gerrit Renker,
   University of Aberdeen, and the present author acknowledges his
   insight in design of the protocol mechanism and in careful review of
   the early revisions of the document text.  Dan Wing assisted on
   issues relating to the use of NAT and NAPT.












<span class="grey">Fairhurst                   Standards Track                    [Page 20]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-21" id="page-21" href="#page-21" class="invisible"> </a>
<span class="grey"><a href="rfc5596.html">RFC 5596</a>            DCCP Simultaneous-Open Technique      September 2009</span>


<span class="h2"><a class="selflink" name="section-7" href="#section-7">7</a>.  References</span>

<span class="h3"><a class="selflink" name="section-7.1" href="#section-7.1">7.1</a>.  Normative References</span>

   [<a name="ref-RFC2119" id="ref-RFC2119">RFC2119</a>]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", <a href="https://tools.ietf.org/html/bcp14">BCP 14</a>, <a href="rfc2119.html">RFC 2119</a>, March 1997.

   [<a name="ref-RFC4340" id="ref-RFC4340">RFC4340</a>]  Kohler, E., Handley, M., and S. Floyd, "Datagram
              Congestion Control Protocol (DCCP)", <a href="rfc4340.html">RFC 4340</a>, March 2006.

   [<a name="ref-RFC5595" id="ref-RFC5595">RFC5595</a>]  Fairhurst, G., "The DCCP Service Code", <a href="rfc5595.html">RFC 5595</a>,
              September 2009.

<span class="h3"><a class="selflink" name="section-7.2" href="#section-7.2">7.2</a>.  Informative References</span>

   [<a name="ref-Epp05" id="ref-Epp05">Epp05</a>]    Eppinger, J-L., "TCP Connections for P2P Apps: A Software
              Approach to Solving the NAT Problem", Carnegie Mellon
              University/ISRI Technical Report CMU-ISRI-05-104,
              January 2005.

   [<a name="ref-FSK05" id="ref-FSK05">FSK05</a>]    Ford, B., Srisuresh, P., and D. Kegel, "Peer-to-Peer
              Communication Across Network Address Translators",
              Proceedings of USENIX-05, pages 179-192, 2005.

   [<a name="ref-GF05" id="ref-GF05">GF05</a>]     Guha, S. and P. Francis, "Characterization and Measurement
              of TCP Traversal through NATs and Firewalls", Proceedings
              of Internet Measurement Conference (IMC-05), pages 199-
              211, 2005.

   [<a name="ref-GTF04" id="ref-GTF04">GTF04</a>]    Guha, S., Takeda, Y., and P. Francis, "NUTSS: A SIP based
              approach to UDP and TCP connectivity", Proceedings of
              SIGCOMM-04 Workshops, Portland, OR, pages 43-48, 2004.

   [<a name="ref-H.323" id="ref-H.323">H.323</a>]    ITU-T, "Packet-based Multimedia Communications Systems",
              Recommendation H.323, July 2003.

   [<a name="ref-ICE" id="ref-ICE">ICE</a>]      Rosenberg, J., "TCP Candidates with Interactive
              Connectivity Establishment (ICE)", Work in Progress,
              July 2008.

   [<a name="ref-NAT-APP" id="ref-NAT-APP">NAT-APP</a>]  Ford, B., "Application Design Guidelines for Traversal
              through Network Address Translators", Work in Progress,
              March 2007.

   [<a name="ref-RFC0793" id="ref-RFC0793">RFC0793</a>]  Postel, J., "Transmission Control Protocol", STD 7,
              <a href="rfc793.html">RFC 793</a>, September 1981.





<span class="grey">Fairhurst                   Standards Track                    [Page 21]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-22" id="page-22" href="#page-22" class="invisible"> </a>
<span class="grey"><a href="rfc5596.html">RFC 5596</a>            DCCP Simultaneous-Open Technique      September 2009</span>


   [<a name="ref-RFC2663" id="ref-RFC2663">RFC2663</a>]  Srisuresh, P. and M. Holdrege, "IP Network Address
              Translator (NAT) Terminology and Considerations",
              <a href="rfc2663.html">RFC 2663</a>, August 1999.

   [<a name="ref-RFC3022" id="ref-RFC3022">RFC3022</a>]  Srisuresh, P. and K. Egevang, "Traditional IP Network
              Address Translator (Traditional NAT)", <a href="rfc3022.html">RFC 3022</a>,
              January 2001.

   [<a name="ref-RFC3235" id="ref-RFC3235">RFC3235</a>]  Senie, D., "Network Address Translator (NAT)-Friendly
              Application Design Guidelines", <a href="rfc3235.html">RFC 3235</a>, January 2002.

   [<a name="ref-RFC3261" id="ref-RFC3261">RFC3261</a>]  Rosenberg, J., Schulzrinne, H., Camarillo, G., Johnston,
              A., Peterson, J., Sparks, R., Handley, M., and E.
              Schooler, "SIP: Session Initiation Protocol", <a href="rfc3261.html">RFC 3261</a>,
              June 2002.

   [<a name="ref-RFC4566" id="ref-RFC4566">RFC4566</a>]  Handley, M., Jacobson, V., and C. Perkins, "SDP: Session
              Description Protocol", <a href="rfc4566.html">RFC 4566</a>, July 2006.

   [<a name="ref-RFC4787" id="ref-RFC4787">RFC4787</a>]  Audet, F. and C. Jennings, "Network Address Translation
              (NAT) Behavioral Requirements for Unicast UDP", <a href="https://tools.ietf.org/html/bcp127">BCP 127</a>,
              <a href="rfc4787.html">RFC 4787</a>, January 2007.

   [<a name="ref-RFC5382" id="ref-RFC5382">RFC5382</a>]  Guha, S., Biswas, K., Ford, B., Sivakumar, S., and P.
              Srisuresh, "NAT Behavioral Requirements for TCP", <a href="https://tools.ietf.org/html/bcp142">BCP 142</a>,
              <a href="rfc5382.html">RFC 5382</a>, October 2008.

   [<a name="ref-RFC5597" id="ref-RFC5597">RFC5597</a>]  Denis-Courmont, R., "Network Address Translation (NAT)
              Behavioral Requirements for the Datagram Congestion
              Control Protocol", <a href="https://tools.ietf.org/html/bcp150">BCP 150</a>, <a href="rfc5597.html">RFC 5597</a>, September 2009.

   [<a name="ref-STUN" id="ref-STUN">STUN</a>]     Rosenberg, J., Mahy, R., and P. Matthews, "Traversal Using
              Relays around NAT (TURN): Relay Extensions to Session
              Traversal Utilities for NAT (STUN)", Work in Progress,
              June 2009.
















<span class="grey">Fairhurst                   Standards Track                    [Page 22]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-23" id="page-23" href="#page-23" class="invisible"> </a>
<span class="grey"><a href="rfc5596.html">RFC 5596</a>            DCCP Simultaneous-Open Technique      September 2009</span>


<span class="h2"><a class="selflink" name="appendix-A" href="#appendix-A">Appendix A</a>.  Discussion of Existing NAT Traversal Techniques</span>

   This appendix provides a brief review of existing techniques to
   establish connectivity across NAT devices, with the aim of providing
   background information.  It first considers TCP NAT traversal based
   on simultaneous-open, and then discusses a second technique based on
   role reversal.  Further information can be found in [<a href="#ref-GTF04" title="&quot;NUTSS: A SIP based approach to UDP and TCP connectivity&quot;">GTF04</a>] and
   [<a href="#ref-GF05" title="&quot;Characterization and Measurement of TCP Traversal through NATs and Firewalls&quot;">GF05</a>].

   A central idea shared by these techniques is to make peer-to-peer
   sessions look like "outbound" sessions on each NAT device.  Often a
   rendezvous server, located in the public address realm, is used to
   enable clients to discover their NAT topology and the addresses of
   peers.

   The term 'hole punching' was coined in [<a href="#ref-FSK05" title="&quot;Peer-to-Peer Communication Across Network Address Translators&quot;">FSK05</a>] and refers to creating
   soft state in a traditional NAT device by initiating an outbound
   connection.  A well-behaved NAT can subsequently exploit this to
   allow a reverse connection back to the host in the private address
   realm.

   UDP and TCP hole punching use nearly the same technique [<a href="rfc4787.html" title="&quot;Network Address Translation (NAT) Behavioral Requirements for Unicast UDP&quot;">RFC4787</a>].
   The adaptation of the basic UDP hole punching principle to TCP NAT
   traversal [<a href="rfc5382.html" title="&quot;NAT Behavioral Requirements for TCP&quot;">RFC5382</a>] was introduced in Section 4 of [<a href="#ref-FSK05" title="&quot;Peer-to-Peer Communication Across Network Address Translators&quot;">FSK05</a>] and relies
   on the simultaneous-open feature of TCP [<a href="https://tools.ietf.org/html/rfc0793" title="&quot;Transmission Control Protocol&quot;">RFC0793</a>].  A further
   difference between UDP and TCP lies in the way the clients perform
   connectivity checks after obtaining suitable address pairs for
   connection establishment.  Whereas in UDP a single socket is
   sufficient, TCP clients require several sockets for the same address
   and port tuple:

   o  a passive socket to listen for connectivity tests from peers, and

   o  multiple active connections from the same address to test
      reachability of other peers.

   The SYN sent out by client A to its peer B creates soft state in A's
   NAT.  At the same time, B tries to connect to A:

   o  if the SYN from B has left B's NAT before the arrival of A's SYN,
      both endpoints perform simultaneous-open (4-way handshake of SYN/
      SYNACK);

   o  otherwise, A's SYN may not enter B's NAT, which leads to B
      performing a normal open (SYN_SENT =&gt; ESTABLISHED) and A
      performing a simultaneous-open (SYN_SENT =&gt; SYN_RCVD =&gt;
      ESTABLISHED).




<span class="grey">Fairhurst                   Standards Track                    [Page 23]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-24" id="page-24" href="#page-24" class="invisible"> </a>
<span class="grey"><a href="rfc5596.html">RFC 5596</a>            DCCP Simultaneous-Open Technique      September 2009</span>


   In the latter case, it is necessary that the NAT does not interfere
   with a RST segment (REQ-4 in [<a href="rfc5382.html" title="&quot;NAT Behavioral Requirements for TCP&quot;">RFC5382</a>]).  The simultaneous-open
   solution is convenient due to its simplicity, and is thus a preferred
   mode of operation in the TCP extension for Interactive Connectivity
   Establishment (ICE) ([<a href="#ref-ICE" title="&quot;TCP Candidates with Interactive Connectivity Establishment (ICE)&quot;">ICE</a>], Section 2).

<span class="h3"><a class="selflink" name="appendix-A.1" href="#appendix-A.1">A.1</a>.  NAT Traversal Based on a Simultaneous-Request</span>

   Among the various TCP NAT traversal approaches, the one using a TCP
   simultaneous-open suggests itself as a candidate for DCCP due to its
   simplicity ([<a href="#ref-GF05" title="&quot;Characterization and Measurement of TCP Traversal through NATs and Firewalls&quot;">GF05</a>], [<a href="#ref-NAT-APP" title="&quot;Application Design Guidelines for Traversal through Network Address Translators&quot;">NAT-APP</a>]).

   A characteristic of TCP simultaneous-open is that this erases the
   clear distinction between client and server: both sides enter through
   active (SYN_SENT) as well as passive (SYN_RCVD) states.  This
   characteristic conflicts with the DCCP design decision to provide a
   clear separation between client and server functions (<a href="rfc4340.html#section-4.6">[RFC4340],
   Section&nbsp;4.6</a>).

   In DCCP, several mechanisms implicitly rely on clearly defined
   client/server roles:

   o  Feature Negotiation: with few exceptions, almost all of DCCP's
      negotiable features use the "server-priority" reconciliation rule
      (<a href="rfc4340.html#section-6.3.1">[RFC4340], Section&nbsp;6.3.1</a>), whereby a peer exchanges its
      preference lists of feature values, and the server decides the
      outcome.

   o  Closing States: only a server may generate DCCP-CloseReq packets
      (asking the peer to hold timewait state), while a client is only
      permitted to send DCCP-Close or DCCP-Reset packets to terminate a
      connection (<a href="rfc4340.html#section-8.3">[RFC4340], Section&nbsp;8.3</a>).

   o  Service Codes [<a href="rfc5595.html" title="&quot;The DCCP Service Code&quot;">RFC5595</a>]: a server may be associated with multiple
      Service Codes, while a client must be associated with exactly one
      (<a href="rfc4340.html#section-8.1.2">[RFC4340], Section&nbsp;8.1.2</a>).

   o  Init Cookies: may only be used by a server and on DCCP-Response
      packets (<a href="rfc4340.html#section-8.1.4">[RFC4340], Section&nbsp;8.1.4</a>).

   The latter two points are not obstacles per se, but would have
   hindered the transition from a passive to an active socket.  In DCCP,
   a DCCP-Request is only generated by a client.  The assumption that
   "all DCCP hosts may be clients" was dismissed, since it would require
   undesirable changes to the state machine and would limit application
   programming.  As a consequence, the retro-fitting of a TCP-style
   simultaneous-open into DCCP to allow simultaneous exchange of DCCP-
   Connect packets was not recommended.



<span class="grey">Fairhurst                   Standards Track                    [Page 24]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-25" id="page-25" href="#page-25" class="invisible"> </a>
<span class="grey"><a href="rfc5596.html">RFC 5596</a>            DCCP Simultaneous-Open Technique      September 2009</span>


<span class="h3"><a class="selflink" name="appendix-A.2" href="#appendix-A.2">A.2</a>.  Role Reversal</span>

   Another simple TCP NAT traversal scheme uses role traversal ([<a href="#ref-Epp05" title="&quot;TCP Connections for P2P Apps: A Software Approach to Solving the NAT Problem&quot;">Epp05</a>],
   [<a href="#ref-GTF04" title="&quot;NUTSS: A SIP based approach to UDP and TCP connectivity&quot;">GTF04</a>]), where a peer first opens an active connection for the
   single purpose of punching a hole in the firewall, and then reverts
   to a listening socket, accepting connections that arrive via the new
   path.

   This solution would have had several disadvantages if used with DCCP.
   First, a DCCP server would be required to change its role to
   temporarily become a 'client'.  This would have required modification
   to the state machine -- in particular, the treatment of Service Codes
   and perhaps Init Cookies.  Further, the method would have needed to
   follow feature negotiation, since an endpoint's choice of initial
   options can rely on its role (i.e., an endpoint that knows it is the
   server can make a priori assumptions about the preference lists of
   features it is negotiating with the client, thereby enforcing a
   particular policy).  Finally, the server would have needed additional
   processing to ensure that the connection arriving at the listening
   socket matches the previously opened active connection.

   This approach was therefore not recommend for DCCP.

Author's Address

   Godred Fairhurst
   University of Aberdeen
   School of Engineering
   Fraser Noble Building
   Aberdeen  AB24 3UE
   Scotland

   EMail: gorry@erg.abdn.ac.uk
   URI:   <a href="http://www.erg.abdn.ac.uk/">http://www.erg.abdn.ac.uk</a>

















Fairhurst                   Standards Track                    [Page 25]

</pre><br />
    <span class="noprint"><small><small>Html markup produced by rfcmarkup 1.129c, available from
      <a href="https://tools.ietf.org/tools/rfcmarkup/">https://tools.ietf.org/tools/rfcmarkup/</a>
    </small></small></span>
  </div>
</body>

<!-- Mirrored from tools.ietf.org/html/rfc5596 by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 28 Jul 2019 12:59:45 GMT -->
</html>
