<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml"><!-- Mirrored from tools.ietf.org/html/rfc5011 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 06 Mar 2018 23:18:37 GMT --><!-- Added by HTTrack --><head><meta content="text/html;charset=utf-8" http-equiv="content-type"/><!-- /Added by HTTrack -->

    <meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
    <meta content="index,follow" name="robots"/>
    <meta content="rfcmarkup version 1.126" name="creator"/>
    <link href="http://purl.org/dc/elements/1.1/" rel="schema.DC"/>
<meta content="urn:ietf:rfc:5011" name="DC.Identifier"/>
<meta content='This document describes a means for automated, authenticated, and
authorized updating of DNSSEC "trust anchors". The method provides
protection against N-1 key compromises of N keys in the trust point
key set. Based on the trust established by the presence of a current
anchor, other anchors may be added at the same place in the hierarchy,
and, ultimately, supplant the existing anchor(s).  This mechanism will
require changes to resolver management behavior (but not resolver
resolution behavior), and the addition of a single flag bit to the
DNSKEY record. [STANDARDS-TRACK]' name="DC.Description.Abstract"/>
<meta content="M. StJohns" name="DC.Creator"/>
<meta content="September, 2007" name="DC.Date.Issued"/>
<meta content="Automated Updates of DNS Security (DNSSEC) Trust Anchors" name="DC.Title"/>

    <link href="https://tools.ietf.org/images/rfc.png" rel="icon" type="image/png"/>
    <link href="https://tools.ietf.org/images/rfc.png" rel="shortcut icon" type="image/png"/>
    <title>RFC 5011 - Automated Updates of DNS Security (DNSSEC) Trust Anchors</title>
    
    
    <style type="text/css">
	@media only screen 
	  and (min-width: 992px)
	  and (max-width: 1199px) {
	    body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 768px)
	  and (max-width: 991px) {
            body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 480px)
	  and (max-width: 767px) {
            body { font-size: 11pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (max-width: 479px) {
            body { font-size: 8pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-device-width : 375px) 
	  and (max-device-width : 667px) {
            body { font-size: 9.5pt; }
            div.content { width: 96ex; margin: 0 1px; }
        }
	@media only screen 
	  and (min-device-width: 1200px) {
            body { font-size: 10pt; margin: 0 4em; }
            div.content { width: 96ex; margin: 0; }
        }
        h1, h2, h3, h4, h5, h6, .h1, .h2, .h3, .h4, .h5, .h6 {
	    font-weight: bold;
            line-height: 0pt;
            display: inline;
            white-space: pre;
            font-family: monospace;
            font-size: 1em;
	    font-weight: bold;
        }
        pre {
            font-size: 1em;
            margin-top: 0px;
            margin-bottom: 0px;
        }
	.pre {
	    white-space: pre;
	    font-family: monospace;
	}
	.header{
	    font-weight: bold;
	}
        .newpage {
            page-break-before: always;
        }
        .invisible {
            text-decoration: none;
            color: white;
        }
        a.selflink {
          color: black;
          text-decoration: none;
        }
        @media print {
            body {
                font-family: monospace;
                font-size: 10.5pt;
            }
            h1, h2, h3, h4, h5, h6 {
                font-size: 1em;
            }
        
            a:link, a:visited {
                color: inherit;
                text-decoration: none;
            }
            .noprint {
                display: none;
            }
        }
	@media screen {
	    .grey, .grey a:link, .grey a:visited {
		color: #777;
	    }
            .docinfo {
                background-color: #EEE;
            }
            .top {
                border-top: 7px solid #EEE;
            }
            .bgwhite  { background-color: white; }
            .bgred    { background-color: #F44; }
            .bggrey   { background-color: #666; }
            .bgbrown  { background-color: #840; }            
            .bgorange { background-color: #FA0; }
            .bgyellow { background-color: #EE0; }
            .bgmagenta{ background-color: #F4F; }
            .bgblue   { background-color: #66F; }
            .bgcyan   { background-color: #4DD; }
            .bggreen  { background-color: #4F4; }

            .legend   { font-size: 90%; }
            .cplate   { font-size: 70%; border: solid grey 1px; }
	}
    </style>
    <!--[if IE]>
    <style>
    body {
       font-size: 13px;
       margin: 10px 10px;
    }
    </style>
    <![endif]-->

    <script type="text/javascript"><!--
    function addHeaderTags() {
	var spans = document.getElementsByTagName("span");
	for (var i=0; i < spans.length; i++) {
	    var elem = spans[i];
	    if (elem) {
		var level = elem.getAttribute("class");
                if (level == "h1" || level == "h2" || level == "h3" || level == "h4" || level == "h5" || level == "h6") {
                    elem.innerHTML = "<"+level+">"+elem.innerHTML+"</"+level+">";		
                }
	    }
	}
    }
    var legend_html = "Colour legend:<br />      <table>         <tr><td>Unknown:</td>                   <td><span class='cplate bgwhite'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft:</td>                     <td><span class='cplate bgred'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Informational:</td>             <td><span class='cplate bgorange'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Experimental:</td>              <td><span class='cplate bgyellow'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Best Common Practice:</td>      <td><span class='cplate bgmagenta'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Proposed Standard:</td>         <td><span class='cplate bgblue'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft Standard (old designation):</td> <td><span class='cplate bgcyan'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Internet Standard:</td>         <td><span class='cplate bggreen'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Historic:</td>                  <td><span class='cplate bggrey'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Obsolete:</td>                  <td><span class='cplate bgbrown'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>     </table>";
    function showElem(id) {
        var elem = document.getElementById(id);
        elem.innerHTML = eval(id+"_html");
        elem.style.visibility='visible';
    }
    function hideElem(id) {
        var elem = document.getElementById(id);
        elem.style.visibility='hidden';        
        elem.innerHTML = "";
    }
    // -->
    </script>
</head>
<body onload="addHeaderTags()">
  <div class="content">
   <div style="height: 13px;">
      <div class="pre noprint docinfo bggreen" onclick="showElem('legend');" onmouseout="hideElem('legend')" onmouseover="this.style.cursor='pointer';" style="height: 6px; position: absolute;" title="Click for colour legend.">                                                                        </div>
      <div class="docinfo noprint pre legend" id="legend" onmouseout="hideElem('legend');" onmouseover="showElem('legend');" style="position:absolute; top: 4px; left: 4ex; visibility:hidden; background-color: white; padding: 4px 9px 5px 7px; border: solid #345 1px; ">
      </div>
   </div>
<span class="pre noprint docinfo top">[<a href="index.html" title="Document search and retrieval page">Docs</a>] [<a href="https://tools.ietf.org/rfc/rfc5011.txt" title="Plaintext version of this document">txt</a>|<a href="https://tools.ietf.org/pdf/rfc5011" title="PDF version of this document">pdf</a>] [<a href="https://tools.ietf.org/html/draft-ietf-dnsext-trustupdate-timers" title="draft-ietf-dnsext-trustupdate-timers">draft-ietf-dnse...</a>] [<a href="https://datatracker.ietf.org/doc/rfc5011" title="IESG Datatracker information for this document">Tracker</a>] [<a href="https://tools.ietf.org/rfcdiff?difftype=--hwdiff&amp;url2=rfc5011" title="Inline diff (wdiff)">Diff1</a>] [<a href="https://tools.ietf.org/rfcdiff?url2=rfc5011" title="Side-by-side diff">Diff2</a>] [<a href="https://datatracker.ietf.org/ipr/search/?rfc=5011&amp;submit=rfc" title="IPR disclosures related to this document">IPR</a>]   </span><br/>
<span class="pre noprint docinfo">                                                                        </span><br/>
<span class="pre noprint docinfo">                                                       INTERNET STANDARD</span><br/>
<span class="pre noprint docinfo">                                                                        </span><br/>
<pre>Network Working Group                                         M. StJohns
Request for Comments: 5011                                   Independent
Category: Standards Track                                 September 2007


        <span class="h1">Automated Updates of DNS Security (DNSSEC) Trust Anchors</span>

Status of This Memo

   This document specifies an Internet standards track protocol for the
   Internet community, and requests discussion and suggestions for
   improvements.  Please refer to the current edition of the "Internet
   Official Protocol Standards" (STD 1) for the standardization state
   and status of this protocol.  Distribution of this memo is unlimited.

Abstract

   This document describes a means for automated, authenticated, and
   authorized updating of DNSSEC "trust anchors".  The method provides
   protection against N-1 key compromises of N keys in the trust point
   key set.  Based on the trust established by the presence of a current
   anchor, other anchors may be added at the same place in the
   hierarchy, and, ultimately, supplant the existing anchor(s).

   This mechanism will require changes to resolver management behavior
   (but not resolver resolution behavior), and the addition of a single
   flag bit to the DNSKEY record.
























<span class="grey">StJohns                     Standards Track                     [Page 1]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-2" id="page-2" name="page-2"> </a>
<span class="grey"><a href="rfc5011.html">RFC 5011</a>                  Trust Anchor Update             September 2007</span>


Table of Contents

   <a href="#section-1">1</a>. Introduction ....................................................<a href="#page-2">2</a>
      <a href="#section-1.1">1.1</a>. Compliance Nomenclature ....................................<a href="#page-3">3</a>
   <a href="#section-2">2</a>. Theory of Operation .............................................<a href="#page-3">3</a>
      <a href="#section-2.1">2.1</a>. Revocation .................................................<a href="#page-4">4</a>
      <a href="#section-2.2">2.2</a>. Add Hold-Down ..............................................<a href="#page-4">4</a>
      <a href="#section-2.3">2.3</a>. Active Refresh .............................................<a href="#page-5">5</a>
      <a href="#section-2.4">2.4</a>. Resolver Parameters ........................................<a href="#page-6">6</a>
           <a href="#section-2.4.1">2.4.1</a>. Add Hold-Down Time ..................................<a href="#page-6">6</a>
           <a href="#section-2.4.2">2.4.2</a>. Remove Hold-Down Time ...............................<a href="#page-6">6</a>
           <a href="#section-2.4.3">2.4.3</a>. Minimum Trust Anchors per Trust Point ...............<a href="#page-6">6</a>
   <a href="#section-3">3</a>. Changes to DNSKEY RDATA Wire Format .............................<a href="#page-6">6</a>
   <a href="#section-4">4</a>. State Table .....................................................<a href="#page-6">6</a>
      <a href="#section-4.1">4.1</a>. Events .....................................................<a href="#page-7">7</a>
      <a href="#section-4.2">4.2</a>. States .....................................................<a href="#page-7">7</a>
   <a href="#section-5">5</a>. Trust Point Deletion ............................................<a href="#page-8">8</a>
   <a href="#section-6">6</a>. Scenarios - Informative .........................................<a href="#page-9">9</a>
      <a href="#section-6.1">6.1</a>. Adding a Trust Anchor ......................................<a href="#page-9">9</a>
      <a href="#section-6.2">6.2</a>. Deleting a Trust Anchor ....................................<a href="#page-9">9</a>
      <a href="#section-6.3">6.3</a>. Key Roll-Over .............................................<a href="#page-10">10</a>
      <a href="#section-6.4">6.4</a>. Active Key Compromised ....................................<a href="#page-10">10</a>
      <a href="#section-6.5">6.5</a>. Stand-by Key Compromised ..................................<a href="#page-10">10</a>
      <a href="#section-6.6">6.6</a>. Trust Point Deletion ......................................<a href="#page-10">10</a>
   <a href="#section-7">7</a>. IANA Considerations ............................................<a href="#page-11">11</a>
   <a href="#section-8">8</a>. Security Considerations ........................................<a href="#page-11">11</a>
      <a href="#section-8.1">8.1</a>. Key Ownership vs. Acceptance Policy .......................<a href="#page-11">11</a>
      <a href="#section-8.2">8.2</a>. Multiple Key Compromise ...................................<a href="#page-12">12</a>
      <a href="#section-8.3">8.3</a>. Dynamic Updates ...........................................<a href="#page-12">12</a>
   <a href="#section-9">9</a>. Normative References ...........................................<a href="#page-12">12</a>
   <a href="#section-10">10</a>. Informative References ........................................<a href="#page-12">12</a>

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/1.%20%20Introduction"></a><a class="selflink" href="#section-1" name="section-1">1</a>.  Introduction</span>

   As part of the reality of fielding DNSSEC (Domain Name System
   Security Extensions) [<a href="rfc4033.html" title='"DNS Security Introduction and Requirements"'>RFC4033</a>] [<a href="rfc4034.html" title='"Resource Records for the DNS Security Extensions"'>RFC4034</a>] [<a href="rfc4035.html" title='"Protocol Modifications for the DNS Security Extensions"'>RFC4035</a>], the community has
   come to the realization that there will not be one signed name space,
   but rather islands of signed name spaces each originating from
   specific points (i.e., 'trust points') in the DNS tree.  Each of
   those islands will be identified by the trust point name, and
   validated by at least one associated public key.  For the purpose of
   this document, we'll call the association of that name and a
   particular key a 'trust anchor'.  A particular trust point can have
   more than one key designated as a trust anchor.

   For a DNSSEC-aware resolver to validate information in a DNSSEC
   protected branch of the hierarchy, it must have knowledge of a trust
   anchor applicable to that branch.  It may also have more than one



<span class="grey">StJohns                     Standards Track                     [Page 2]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-3" id="page-3" name="page-3"> </a>
<span class="grey"><a href="rfc5011.html">RFC 5011</a>                  Trust Anchor Update             September 2007</span>


   trust anchor for any given trust point.  Under current rules, a chain
   of trust for DNSSEC-protected data that chains its way back to ANY
   known trust anchor is considered 'secure'.

   Because of the probable balkanization of the DNSSEC tree due to
   signing voids at key locations, a resolver may need to know literally
   thousands of trust anchors to perform its duties (e.g., consider an
   unsigned ".COM").  Requiring the owner of the resolver to manually
   manage these many relationships is problematic.  It's even more
   problematic when considering the eventual requirement for key
   replacement/update for a given trust anchor.  The mechanism described
   herein won't help with the initial configuration of the trust anchors
   in the resolvers, but should make trust point key
   replacement/rollover more viable.

   As mentioned above, this document describes a mechanism whereby a
   resolver can update the trust anchors for a given trust point, mainly
   without human intervention at the resolver.  There are some corner
   cases discussed (e.g., multiple key compromise) that may require
   manual intervention, but they should be few and far between.  This
   document DOES NOT discuss the general problem of the initial
   configuration of trust anchors for the resolver.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/1.1.%20%20Compliance%20Nomenclature"></a><a class="selflink" href="#section-1.1" name="section-1.1">1.1</a>.  Compliance Nomenclature</span>

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in <a href="https://tools.ietf.org/html/bcp14">BCP 14</a>, [<a href="rfc2119.html" title='"Key words for use in RFCs to Indicate Requirement Levels"'>RFC2119</a>].

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/2.%20%20Theory%20of%20Operation"></a><a class="selflink" href="#section-2" name="section-2">2</a>.  Theory of Operation</span>

   The general concept of this mechanism is that existing trust anchors
   can be used to authenticate new trust anchors at the same point in
   the DNS hierarchy.  When a zone operator adds a new SEP key (i.e., a
   DNSKEY with the Secure Entry Point bit set) (see [<a href="rfc4034.html" title='"Resource Records for the DNS Security Extensions"'>RFC4034</a>], <a href="#section-2.1.1">Section</a>
   <a href="#section-2.1.1">2.1.1</a>) to a trust point DNSKEY RRSet, and when that RRSet is
   validated by an existing trust anchor, then the resolver can add the
   new key to its set of valid trust anchors for that trust point.

   There are some issues with this approach that need to be mitigated.
   For example, a compromise of one of the existing keys could allow an
   attacker to add their own 'valid' data.  This implies a need for a
   method to revoke an existing key regardless of whether or not that
   key is compromised.  As another example, assuming a single key
   compromise, we need to prevent an attacker from adding a new key and
   revoking all the other old keys.





<span class="grey">StJohns                     Standards Track                     [Page 3]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-4" id="page-4" name="page-4"> </a>
<span class="grey"><a href="rfc5011.html">RFC 5011</a>                  Trust Anchor Update             September 2007</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/2.1.%20%20Revocation"></a><a class="selflink" href="#section-2.1" name="section-2.1">2.1</a>.  Revocation</span>

   Assume two trust anchor keys A and B.  Assume that B has been
   compromised.  Without a specific revocation bit, B could invalidate A
   simply by sending out a signed trust point key set that didn't
   contain A.  To fix this, we add a mechanism that requires knowledge
   of the private key of a DNSKEY to revoke that DNSKEY.

   A key is considered revoked when the resolver sees the key in a
   self-signed RRSet and the key has the REVOKE bit (see <a href="#section-7">Section 7</a>
   below) set to '1'.  Once the resolver sees the REVOKE bit, it MUST
   NOT use this key as a trust anchor or for any other purpose except to
   validate the RRSIG it signed over the DNSKEY RRSet specifically for
   the purpose of validating the revocation.  Unlike the 'Add' operation
   below, revocation is immediate and permanent upon receipt of a valid
   revocation at the resolver.

   A self-signed RRSet is a DNSKEY RRSet that contains the specific
   DNSKEY and for which there is a corresponding validated RRSIG record.
   It's not a special DNSKEY RRSet, just a way of describing the
   validation requirements for that RRSet.

   N.B.: A DNSKEY with the REVOKE bit set has a different fingerprint
   than one without the bit set.  This affects the matching of a DNSKEY
   to DS records in the parent [<a href="rfc3755.html" title='"Legacy Resolver Compatibility for Delegation Signer (DS)"'>RFC3755</a>], or the fingerprint stored at a
   resolver used to configure a trust point.

   In the given example, the attacker could revoke B because it has
   knowledge of B's private key, but could not revoke A.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/2.2.%20%20Add%20Hold-Down"></a><a class="selflink" href="#section-2.2" name="section-2.2">2.2</a>.  Add Hold-Down</span>

   Assume two trust point keys A and B.  Assume that B has been
   compromised.  An attacker could generate and add a new trust anchor
   key C (by adding C to the DNSKEY RRSet and signing it with B), and
   then invalidate the compromised key.  This would result in both the
   attacker and owner being able to sign data in the zone and have it
   accepted as valid by resolvers.

   To mitigate but not completely solve this problem, we add a hold-down
   time to the addition of the trust anchor.  When the resolver sees a
   new SEP key in a validated trust point DNSKEY RRSet, the resolver
   starts an acceptance timer, and remembers all the keys that validated
   the RRSet.  If the resolver ever sees the DNSKEY RRSet without the
   new key but validly signed, it stops the acceptance process for that
   key and resets the acceptance timer.  If all of the keys that were





<span class="grey">StJohns                     Standards Track                     [Page 4]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-5" id="page-5" name="page-5"> </a>
<span class="grey"><a href="rfc5011.html">RFC 5011</a>                  Trust Anchor Update             September 2007</span>


   originally used to validate this key are revoked prior to the timer
   expiring, the resolver stops the acceptance process and resets the
   timer.

   Once the timer expires, the new key will be added as a trust anchor
   the next time the validated RRSet with the new key is seen at the
   resolver.  The resolver MUST NOT treat the new key as a trust anchor
   until the hold-down time expires AND it has retrieved and validated a
   DNSKEY RRSet after the hold-down time that contains the new key.

   N.B.: Once the resolver has accepted a key as a trust anchor, the key
   MUST be considered a valid trust anchor by that resolver until
   explicitly revoked as described above.

   In the given example, the zone owner can recover from a compromise by
   revoking B and adding a new key D and signing the DNSKEY RRSet with
   both A and B.

   The reason this does not completely solve the problem has to do with
   the distributed nature of DNS.  The resolver only knows what it sees.
   A determined attacker who holds one compromised key could keep a
   single resolver from realizing that the key had been compromised by
   intercepting 'real' data from the originating zone and substituting
   their own (e.g., using the example, signed only by B).  This is no
   worse than the current situation assuming a compromised key.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/2.3.%20%20Active%20Refresh"></a><a class="selflink" href="#section-2.3" name="section-2.3">2.3</a>.  Active Refresh</span>

   A resolver that has been configured for an automatic update of keys
   from a particular trust point MUST query that trust point (e.g., do a
   lookup for the DNSKEY RRSet and related RRSIG records) no less often
   than the lesser of 15 days, half the original TTL for the DNSKEY
   RRSet, or half the RRSIG expiration interval and no more often than
   once per hour.  The expiration interval is the amount of time from
   when the RRSIG was last retrieved until the expiration time in the
   RRSIG.  That is, queryInterval = MAX(1 hr, MIN (15 days, 1/2*OrigTTL,
   1/2*RRSigExpirationInterval))

   If the query fails, the resolver MUST repeat the query until
   satisfied no more often than once an hour and no less often than the
   lesser of 1 day, 10% of the original TTL, or 10% of the original
   expiration interval.  That is, retryTime = MAX (1 hour, MIN (1 day,
   .1 * origTTL, .1 * expireInterval)).








<span class="grey">StJohns                     Standards Track                     [Page 5]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-6" id="page-6" name="page-6"> </a>
<span class="grey"><a href="rfc5011.html">RFC 5011</a>                  Trust Anchor Update             September 2007</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/2.4.%20%20Resolver%20Parameters"></a><a class="selflink" href="#section-2.4" name="section-2.4">2.4</a>.  Resolver Parameters</span>

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/2.4.1.%20%20Add%20Hold-Down%20Time"></a><a class="selflink" href="#section-2.4.1" name="section-2.4.1">2.4.1</a>.  Add Hold-Down Time</span>

   The add hold-down time is 30 days or the expiration time of the
   original TTL of the first trust point DNSKEY RRSet that contained the
   new key, whichever is greater.  This ensures that at least two
   validated DNSKEY RRSets that contain the new key MUST be seen by the
   resolver prior to the key's acceptance.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/2.4.2.%20%20Remove%20Hold-Down%20Time"></a><a class="selflink" href="#section-2.4.2" name="section-2.4.2">2.4.2</a>.  Remove Hold-Down Time</span>

   The remove hold-down time is 30 days.  This parameter is solely a key
   management database bookeeping parameter.  Failure to remove
   information about the state of defunct keys from the database will
   not adversely impact the security of this protocol, but may end up
   with a database cluttered with obsolete key information.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/2.4.3.%20%20Minimum%20Trust%20Anchors%20per%20Trust%20Point"></a><a class="selflink" href="#section-2.4.3" name="section-2.4.3">2.4.3</a>.  Minimum Trust Anchors per Trust Point</span>

   A compliant resolver MUST be able to manage at least five SEP keys
   per trust point.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/3.%20%20Changes%20to%20DNSKEY%20RDATA%20Wire%20Format"></a><a class="selflink" href="#section-3" name="section-3">3</a>.  Changes to DNSKEY RDATA Wire Format</span>

   Bit 8 of the DNSKEY Flags field is designated as the 'REVOKE' flag.
   If this bit is set to '1', AND the resolver sees an RRSIG(DNSKEY)
   signed by the associated key, then the resolver MUST consider this
   key permanently invalid for all purposes except for validating the
   revocation.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/4.%20%20State%20Table"></a><a class="selflink" href="#section-4" name="section-4">4</a>.  State Table</span>

   The most important thing to understand is the resolver's view of any
   key at a trust point.  The following state table describes this view
   at various points in the key's lifetime.  The table is a normative
   part of this specification.  The initial state of the key is 'Start'.
   The resolver's view of the state of the key changes as various events
   occur.

   This is the state of a trust-point key as seen from the resolver.
   The column on the left indicates the current state.  The header at
   the top shows the next state.  The intersection of the two shows the
   event that will cause the state to transition from the current state
   to the next.






<span class="grey">StJohns                     Standards Track                     [Page 6]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-7" id="page-7" name="page-7"> </a>
<span class="grey"><a href="rfc5011.html">RFC 5011</a>                  Trust Anchor Update             September 2007</span>


                             NEXT STATE
           --------------------------------------------------
    FROM   |Start  |AddPend |Valid  |Missing|Revoked|Removed|
   ----------------------------------------------------------
   Start   |       |NewKey  |       |       |       |       |
   ----------------------------------------------------------
   AddPend |KeyRem |        |AddTime|       |       |       |
   ----------------------------------------------------------
   Valid   |       |        |       |KeyRem |Revbit |       |
   ----------------------------------------------------------
   Missing |       |        |KeyPres|       |Revbit |       |
   ----------------------------------------------------------
   Revoked |       |        |       |       |       |RemTime|
   ----------------------------------------------------------
   Removed |       |        |       |       |       |       |
   ----------------------------------------------------------

                           State Table

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.1.%20%20Events"></a><a class="selflink" href="#section-4.1" name="section-4.1">4.1</a>.  Events</span>

   NewKey   The resolver sees a valid DNSKEY RRSet with a new SEP key.
            That key will become a new trust anchor for the named trust
            point after it's been present in the RRSet for at least 'add
            time'.

   KeyPres  The key has returned to the valid DNSKEY RRSet.

   KeyRem   The resolver sees a valid DNSKEY RRSet that does not contain
            this key.

   AddTime  The key has been in every valid DNSKEY RRSet seen for at
            least the 'add time'.

   RemTime  A revoked key has been missing from the trust-point DNSKEY
            RRSet for sufficient time to be removed from the trust set.

   RevBit   The key has appeared in the trust anchor DNSKEY RRSet with
            its "REVOKED" bit set, and there is an RRSig over the DNSKEY
            RRSet signed by this key.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.2.%20%20States"></a><a class="selflink" href="#section-4.2" name="section-4.2">4.2</a>.  States</span>

   Start    The key doesn't yet exist as a trust anchor at the resolver.
            It may or may not exist at the zone server, but either
            hasn't yet been seen at the resolver or was seen but was
            absent from the last DNSKEY RRSet (e.g., KeyRem event).




<span class="grey">StJohns                     Standards Track                     [Page 7]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-8" id="page-8" name="page-8"> </a>
<span class="grey"><a href="rfc5011.html">RFC 5011</a>                  Trust Anchor Update             September 2007</span>


   AddPend  The key has been seen at the resolver, has its 'SEP' bit
            set, and has been included in a validated DNSKEY RRSet.
            There is a hold-down time for the key before it can be used
            as a trust anchor.

   Valid    The key has been seen at the resolver and has been included
            in all validated DNSKEY RRSets from the time it was first
            seen through the hold-down time.  It is now valid for
            verifying RRSets that arrive after the hold-down time.
            Clarification: The DNSKEY RRSet does not need to be
            continuously present at the resolver (e.g., its TTL might
            expire).  If the RRSet is seen and is validated (i.e.,
            verifies against an existing trust anchor), this key MUST be
            in the RRSet, otherwise a 'KeyRem' event is triggered.

   Missing  This is an abnormal state.  The key remains a valid trust-
            point key, but was not seen at the resolver in the last
            validated DNSKEY RRSet.  This is an abnormal state because
            the zone operator should be using the REVOKE bit prior to
            removal.

   Revoked  This is the state a key moves to once the resolver sees an
            RRSIG(DNSKEY) signed by this key where that DNSKEY RRSet
            contains this key with its REVOKE bit set to '1'.  Once in
            this state, this key MUST permanently be considered invalid
            as a trust anchor.

   Removed  After a fairly long hold-down time, information about this
            key may be purged from the resolver.  A key in the removed
            state MUST NOT be considered a valid trust anchor.  (Note:
            this state is more or less equivalent to the "Start" state,
            except that it's bad practice to re-introduce previously
            used keys -- think of this as the holding state for all the
            old keys for which the resolver no longer needs to track
            state.)

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/5.%20%20Trust%20Point%20Deletion"></a><a class="selflink" href="#section-5" name="section-5">5</a>.  Trust Point Deletion</span>

   A trust point that has all of its trust anchors revoked is considered
   deleted and is treated as if the trust point was never configured.
   If there are no superior configured trust points, data at and below
   the deleted trust point are considered insecure by the resolver.  If
   there ARE superior configured trust points, data at and below the
   deleted trust point are evaluated with respect to the superior trust
   point(s).

   Alternately, a trust point that is subordinate to another configured
   trust point MAY be deleted by a resolver after 180 days, where such a



<span class="grey">StJohns                     Standards Track                     [Page 8]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-9" id="page-9" name="page-9"> </a>
<span class="grey"><a href="rfc5011.html">RFC 5011</a>                  Trust Anchor Update             September 2007</span>


   subordinate trust point validly chains to a superior trust point.
   The decision to delete the subordinate trust anchor is a local
   configuration decision.  Once the subordinate trust point is deleted,
   validation of the subordinate zone is dependent on validating the
   chain of trust to the superior trust point.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/6.%20%20Scenarios%20-%20Informative"></a><a class="selflink" href="#section-6" name="section-6">6</a>.  Scenarios - Informative</span>

   The suggested model for operation is to have one active key and one
   stand-by key at each trust point.  The active key will be used to
   sign the DNSKEY RRSet.  The stand-by key will not normally sign this
   RRSet, but the resolver will accept it as a trust anchor if/when it
   sees the signature on the trust point DNSKEY RRSet.

   Since the stand-by key is not in active signing use, the associated
   private key may (and should) be provided with additional protections
   not normally available to a key that must be used frequently (e.g.,
   locked in a safe, split among many parties, etc).  Notionally, the
   stand-by key should be less subject to compromise than an active key,
   but that will be dependent on operational concerns not addressed
   here.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/6.1.%20%20Adding%20a%20Trust%20Anchor"></a><a class="selflink" href="#section-6.1" name="section-6.1">6.1</a>.  Adding a Trust Anchor</span>

   Assume an existing trust anchor key 'A'.

   1.  Generate a new key pair.

   2.  Create a DNSKEY record from the key pair and set the SEP and Zone
       Key bits.

   3.  Add the DNSKEY to the RRSet.

   4.  Sign the DNSKEY RRSet ONLY with the existing trust anchor key -
       'A'.

   5.  Wait for various resolvers' timers to go off and for them to
       retrieve the new DNSKEY RRSet and signatures.

   6.  The new trust anchor will be populated at the resolvers on the
       schedule described by the state table and update algorithm -- see
       Sections <a href="#section-2">2</a> and <a href="#section-4">4</a> above.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/6.2.%20%20Deleting%20a%20Trust%20Anchor"></a><a class="selflink" href="#section-6.2" name="section-6.2">6.2</a>.  Deleting a Trust Anchor</span>

   Assume existing trust anchors 'A' and 'B' and that you want to revoke
   and delete 'A'.




<span class="grey">StJohns                     Standards Track                     [Page 9]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-10" id="page-10" name="page-10"> </a>
<span class="grey"><a href="rfc5011.html">RFC 5011</a>                  Trust Anchor Update             September 2007</span>


   1.  Set the revocation bit on key 'A'.

   2.  Sign the DNSKEY RRSet with both 'A' and 'B'.  'A' is now revoked.
       The operator should include the revoked 'A' in the RRSet for at
       least the remove hold-down time, but then may remove it from the
       DNSKEY RRSet.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/6.3.%20%20Key%20Roll-Over"></a><a class="selflink" href="#section-6.3" name="section-6.3">6.3</a>.  Key Roll-Over</span>

   Assume existing keys A and B. 'A' is actively in use (i.e. has been
   signing the DNSKEY RRSet).  'B' was the stand-by key. (i.e. has been
   in the DNSKEY RRSet and is a valid trust anchor, but wasn't being
   used to sign the RRSet).

      1.  Generate a new key pair 'C'.
      2.  Add 'C' to the DNSKEY RRSet.
      3.  Set the revocation bit on key 'A'.
      4.  Sign the RRSet with 'A' and 'B'.

   'A' is now revoked, 'B' is now the active key, and 'C' will be the
   stand-by key once the hold-down expires.  The operator should include
   the revoked 'A' in the RRSet for at least the remove hold-down time,
   but may then remove it from the DNSKEY RRSet.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/6.4.%20%20Active%20Key%20Compromised"></a><a class="selflink" href="#section-6.4" name="section-6.4">6.4</a>.  Active Key Compromised</span>

   This is the same as the mechanism for Key Roll-Over (<a href="#section-6.3">Section 6.3</a>)
   above, assuming 'A' is the active key.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/6.5.%20%20Stand-by%20Key%20Compromised"></a><a class="selflink" href="#section-6.5" name="section-6.5">6.5</a>.  Stand-by Key Compromised</span>

   Using the same assumptions and naming conventions as Key Roll-Over
   (<a href="#section-6.3">Section 6.3</a>) above:

      1.  Generate a new key pair 'C'.
      2.  Add 'C' to the DNSKEY RRSet.
      3.  Set the revocation bit on key 'B'.
      4.  Sign the RRSet with 'A' and 'B'.

   'B' is now revoked, 'A' remains the active key, and 'C' will be the
   stand-by key once the hold-down expires.  'B' should continue to be
   included in the RRSet for the remove hold-down time.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/6.6.%20%20Trust%20Point%20Deletion"></a><a class="selflink" href="#section-6.6" name="section-6.6">6.6</a>.  Trust Point Deletion</span>

   To delete a trust point that is subordinate to another configured
   trust point (e.g., example.com to .com) requires some juggling of the
   data.  The specific process is:



<span class="grey">StJohns                     Standards Track                    [Page 10]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-11" id="page-11" name="page-11"> </a>
<span class="grey"><a href="rfc5011.html">RFC 5011</a>                  Trust Anchor Update             September 2007</span>


   1.  Generate a new DNSKEY and DS record and provide the DS record to
       the parent along with DS records for the old keys.

   2.  Once the parent has published the DSs, add the new DNSKEY to the
       RRSet and revoke ALL of the old keys at the same time, while
       signing the DNSKEY RRSet with all of the old and new keys.

   3.  After 30 days, stop publishing the old, revoked keys and remove
       any corresponding DS records in the parent.

   Revoking the old trust-point keys at the same time as adding new keys
   that chain to a superior trust prevents the resolver from adding the
   new keys as trust anchors.  Adding DS records for the old keys avoids
   a race condition where either the subordinate zone becomes unsecure
   (because the trust point was deleted) or becomes bogus (because it
   didn't chain to the superior zone).

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/7.%20%20IANA%20Considerations"></a><a class="selflink" href="#section-7" name="section-7">7</a>.  IANA Considerations</span>

   The IANA has assigned a bit in the DNSKEY flags field (see <a href="rfc4034.html#section-7">Section 7
   of [RFC4034]</a>) for the REVOKE bit (8).

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/8.%20%20Security%20Considerations"></a><a class="selflink" href="#section-8" name="section-8">8</a>.  Security Considerations</span>

   In addition to the following sections, see also Theory of Operation
   above (<a href="#section-2">Section 2</a>) and especially <a href="#section-2.2">Section 2.2</a> for related discussions.

   Security considerations for trust anchor rollover not specific to
   this protocol are discussed in [<a href="rfc4986.html" title='"Requirements Related to DNS Security (DNSSEC) Trust Anchor Rollover"'>RFC4986</a>].

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/8.1.%20%20Key%20Ownership%20vs.%20Acceptance%20Policy"></a><a class="selflink" href="#section-8.1" name="section-8.1">8.1</a>.  Key Ownership vs. Acceptance Policy</span>

   The reader should note that, while the zone owner is responsible for
   creating and distributing keys, it's wholly the decision of the
   resolver owner as to whether to accept such keys for the
   authentication of the zone information.  This implies the decision to
   update trust-anchor keys based on trusting a current trust-anchor key
   is also the resolver owner's decision.

   The resolver owner (and resolver implementers) MAY choose to permit
   or prevent key status updates based on this mechanism for specific
   trust points.  If they choose to prevent the automated updates, they
   will need to establish a mechanism for manual or other out-of-band
   updates, which are outside the scope of this document.







<span class="grey">StJohns                     Standards Track                    [Page 11]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-12" id="page-12" name="page-12"> </a>
<span class="grey"><a href="rfc5011.html">RFC 5011</a>                  Trust Anchor Update             September 2007</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/8.2.%20%20Multiple%20Key%20Compromise"></a><a class="selflink" href="#section-8.2" name="section-8.2">8.2</a>.  Multiple Key Compromise</span>

   This scheme permits recovery as long as at least one valid trust-
   anchor key remains uncompromised, e.g., if there are three keys, you
   can recover if two of them are compromised.  The zone owner should
   determine their own level of comfort with respect to the number of
   active, valid trust anchors in a zone and should be prepared to
   implement recovery procedures once they detect a compromise.  A
   manual or other out-of-band update of all resolvers will be required
   if all trust-anchor keys at a trust point are compromised.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/8.3.%20%20Dynamic%20Updates"></a><a class="selflink" href="#section-8.3" name="section-8.3">8.3</a>.  Dynamic Updates</span>

   Allowing a resolver to update its trust anchor set based on in-band
   key information is potentially less secure than a manual process.
   However, given the nature of the DNS, the number of resolvers that
   would require update if a trust anchor key were compromised, and the
   lack of a standard management framework for DNS, this approach is no
   worse than the existing situation.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/9.%20%20Normative%20References"></a><a class="selflink" href="#section-9" name="section-9">9</a>.  Normative References</span>

   [<a id="ref-RFC2119" name="ref-RFC2119">RFC2119</a>]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", <a href="https://tools.ietf.org/html/bcp14">BCP 14</a>, <a href="rfc2119.html">RFC 2119</a>, March 1997.

   [<a id="ref-RFC3755" name="ref-RFC3755">RFC3755</a>]  Weiler, S., "Legacy Resolver Compatibility for Delegation
              Signer (DS)", <a href="rfc3755.html">RFC 3755</a>, May 2004.

   [<a id="ref-RFC4033" name="ref-RFC4033">RFC4033</a>]  Arends, R., Austein, R., Larson, M., Massey, D., and S.
              Rose, "DNS Security Introduction and Requirements", <a href="rfc4033.html">RFC</a>
              <a href="rfc4033.html">4033</a>, March 2005.

   [<a id="ref-RFC4034" name="ref-RFC4034">RFC4034</a>]  Arends, R., Austein, R., Larson, M., Massey, D., and S.
              Rose, "Resource Records for the DNS Security Extensions",
              <a href="rfc4034.html">RFC 4034</a>, March 2005.

   [<a id="ref-RFC4035" name="ref-RFC4035">RFC4035</a>]  Arends, R., Austein, R., Larson, M., Massey, D., and S.
              Rose, "Protocol Modifications for the DNS Security
              Extensions", <a href="rfc4035.html">RFC 4035</a>, March 2005.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/10.%20%20Informative%20References"></a><a class="selflink" href="#section-10" name="section-10">10</a>.  Informative References</span>

   [<a id="ref-RFC4986" name="ref-RFC4986">RFC4986</a>]  Eland, H., Mundy, R., Crocker, S., and S. Krishnaswamy,
              "Requirements Related to DNS Security (DNSSEC) Trust
              Anchor Rollover", <a href="rfc4986.html">RFC 4986</a>, August 2007.






<span class="grey">StJohns                     Standards Track                    [Page 12]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-13" id="page-13" name="page-13"> </a>
<span class="grey"><a href="rfc5011.html">RFC 5011</a>                  Trust Anchor Update             September 2007</span>


Author's Address

   Michael StJohns
   Independent

   EMail: mstjohns@comcast.net













































<span class="grey">StJohns                     Standards Track                    [Page 13]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-14" id="page-14" name="page-14"> </a>
<span class="grey"><a href="rfc5011.html">RFC 5011</a>                  Trust Anchor Update             September 2007</span>


Full Copyright Statement

   Copyright (C) The IETF Trust (2007).

   This document is subject to the rights, licenses and restrictions
   contained in <a href="https://tools.ietf.org/html/bcp78">BCP 78</a>, and except as set forth therein, the authors
   retain all their rights.

   This document and the information contained herein are provided on an
   "AS IS" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS
   OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST AND
   THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS
   OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF
   THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED
   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.

Intellectual Property

   The IETF takes no position regarding the validity or scope of any
   Intellectual Property Rights or other rights that might be claimed to
   pertain to the implementation or use of the technology described in
   this document or the extent to which any license under such rights
   might or might not be available; nor does it represent that it has
   made any independent effort to identify any such rights.  Information
   on the procedures with respect to rights in RFC documents can be
   found in <a href="https://tools.ietf.org/html/bcp78">BCP 78</a> and <a href="https://tools.ietf.org/html/bcp79">BCP 79</a>.

   Copies of IPR disclosures made to the IETF Secretariat and any
   assurances of licenses to be made available, or the result of an
   attempt made to obtain a general license or permission for the use of
   such proprietary rights by implementers or users of this
   specification can be obtained from the IETF on-line IPR repository at
   <a href="http://www.ietf.org/ipr">http://www.ietf.org/ipr</a>.

   The IETF invites any interested party to bring to its attention any
   copyrights, patents or patent applications, or other proprietary
   rights that may cover technology that may be required to implement
   this standard.  Please address the information to the IETF at
   ietf-ipr@ietf.org.












StJohns                     Standards Track                    [Page 14]

</pre><br/>
    <span class="noprint"><small><small>Html markup produced by rfcmarkup 1.126, available from
      <a href="https://tools.ietf.org/tools/rfcmarkup/">https://tools.ietf.org/tools/rfcmarkup/</a>
    </small></small></span>
  </div>




</body><!-- Mirrored from tools.ietf.org/html/rfc5011 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 06 Mar 2018 23:18:37 GMT --></html>