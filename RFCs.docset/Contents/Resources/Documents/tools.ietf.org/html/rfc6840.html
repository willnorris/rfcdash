<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml"><!-- Mirrored from tools.ietf.org/html/rfc6840 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 06 Mar 2018 23:18:26 GMT --><!-- Added by HTTrack --><head><meta content="text/html;charset=utf-8" http-equiv="content-type"/><!-- /Added by HTTrack -->

    <meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
    <meta content="index,follow" name="robots"/>
    <meta content="rfcmarkup version 1.126" name="creator"/>
    <link href="http://purl.org/dc/elements/1.1/" rel="schema.DC"/>
<meta content="draft-weiler-dnsext-dnssec-bis-updates" name="DC.Relation.Replaces"/>
<meta content="urn:ietf:rfc:6840" name="DC.Identifier"/>
<meta content="February, 2013" name="DC.Date.Issued"/>
<meta content="Blacka, David" name="DC.Creator"/>
<meta content="Weiler, Samuel" name="DC.Creator"/>
<meta content="This document is a collection of technical clarifications to the DNS
Security (DNSSEC) document set. It is meant to serve as a resource to
implementors as well as a collection of DNSSEC errata that existed at
the time of writing.  This document updates the core DNSSEC documents
(RFC 4033, RFC 4034, and RFC 4035) as well as the NSEC3 specification
(RFC 5155). It also defines NSEC3 and SHA-2 (RFC 4509 and RFC 5702) as
core parts of the DNSSEC specification." name="DC.Description.Abstract"/>
<meta content="Clarifications and Implementation Notes for DNS Security (DNSSEC)" name="DC.Title"/>

    <link href="https://tools.ietf.org/images/rfc.png" rel="icon" type="image/png"/>
    <link href="https://tools.ietf.org/images/rfc.png" rel="shortcut icon" type="image/png"/>
    <title>RFC 6840 - Clarifications and Implementation Notes for DNS Security (DNSSEC)</title>
    
    
    <style type="text/css">
	@media only screen 
	  and (min-width: 992px)
	  and (max-width: 1199px) {
	    body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 768px)
	  and (max-width: 991px) {
            body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 480px)
	  and (max-width: 767px) {
            body { font-size: 11pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (max-width: 479px) {
            body { font-size: 8pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-device-width : 375px) 
	  and (max-device-width : 667px) {
            body { font-size: 9.5pt; }
            div.content { width: 96ex; margin: 0 1px; }
        }
	@media only screen 
	  and (min-device-width: 1200px) {
            body { font-size: 10pt; margin: 0 4em; }
            div.content { width: 96ex; margin: 0; }
        }
        h1, h2, h3, h4, h5, h6, .h1, .h2, .h3, .h4, .h5, .h6 {
	    font-weight: bold;
            line-height: 0pt;
            display: inline;
            white-space: pre;
            font-family: monospace;
            font-size: 1em;
	    font-weight: bold;
        }
        pre {
            font-size: 1em;
            margin-top: 0px;
            margin-bottom: 0px;
        }
	.pre {
	    white-space: pre;
	    font-family: monospace;
	}
	.header{
	    font-weight: bold;
	}
        .newpage {
            page-break-before: always;
        }
        .invisible {
            text-decoration: none;
            color: white;
        }
        a.selflink {
          color: black;
          text-decoration: none;
        }
        @media print {
            body {
                font-family: monospace;
                font-size: 10.5pt;
            }
            h1, h2, h3, h4, h5, h6 {
                font-size: 1em;
            }
        
            a:link, a:visited {
                color: inherit;
                text-decoration: none;
            }
            .noprint {
                display: none;
            }
        }
	@media screen {
	    .grey, .grey a:link, .grey a:visited {
		color: #777;
	    }
            .docinfo {
                background-color: #EEE;
            }
            .top {
                border-top: 7px solid #EEE;
            }
            .bgwhite  { background-color: white; }
            .bgred    { background-color: #F44; }
            .bggrey   { background-color: #666; }
            .bgbrown  { background-color: #840; }            
            .bgorange { background-color: #FA0; }
            .bgyellow { background-color: #EE0; }
            .bgmagenta{ background-color: #F4F; }
            .bgblue   { background-color: #66F; }
            .bgcyan   { background-color: #4DD; }
            .bggreen  { background-color: #4F4; }

            .legend   { font-size: 90%; }
            .cplate   { font-size: 70%; border: solid grey 1px; }
	}
    </style>
    <!--[if IE]>
    <style>
    body {
       font-size: 13px;
       margin: 10px 10px;
    }
    </style>
    <![endif]-->

    <script type="text/javascript"><!--
    function addHeaderTags() {
	var spans = document.getElementsByTagName("span");
	for (var i=0; i < spans.length; i++) {
	    var elem = spans[i];
	    if (elem) {
		var level = elem.getAttribute("class");
                if (level == "h1" || level == "h2" || level == "h3" || level == "h4" || level == "h5" || level == "h6") {
                    elem.innerHTML = "<"+level+">"+elem.innerHTML+"</"+level+">";		
                }
	    }
	}
    }
    var legend_html = "Colour legend:<br />      <table>         <tr><td>Unknown:</td>                   <td><span class='cplate bgwhite'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft:</td>                     <td><span class='cplate bgred'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Informational:</td>             <td><span class='cplate bgorange'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Experimental:</td>              <td><span class='cplate bgyellow'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Best Common Practice:</td>      <td><span class='cplate bgmagenta'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Proposed Standard:</td>         <td><span class='cplate bgblue'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft Standard (old designation):</td> <td><span class='cplate bgcyan'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Internet Standard:</td>         <td><span class='cplate bggreen'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Historic:</td>                  <td><span class='cplate bggrey'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Obsolete:</td>                  <td><span class='cplate bgbrown'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>     </table>";
    function showElem(id) {
        var elem = document.getElementById(id);
        elem.innerHTML = eval(id+"_html");
        elem.style.visibility='visible';
    }
    function hideElem(id) {
        var elem = document.getElementById(id);
        elem.style.visibility='hidden';        
        elem.innerHTML = "";
    }
    // -->
    </script>
</head>
<body onload="addHeaderTags()">
  <div class="content">
   <div style="height: 13px;">
      <div class="pre noprint docinfo bgblue" onclick="showElem('legend');" onmouseout="hideElem('legend')" onmouseover="this.style.cursor='pointer';" style="height: 6px; position: absolute;" title="Click for colour legend.">                                                                        </div>
      <div class="docinfo noprint pre legend" id="legend" onmouseout="hideElem('legend');" onmouseover="showElem('legend');" style="position:absolute; top: 4px; left: 4ex; visibility:hidden; background-color: white; padding: 4px 9px 5px 7px; border: solid #345 1px; ">
      </div>
   </div>
<span class="pre noprint docinfo top">[<a href="index.html" title="Document search and retrieval page">Docs</a>] [<a href="https://tools.ietf.org/rfc/rfc6840.txt" title="Plaintext version of this document">txt</a>|<a href="https://tools.ietf.org/pdf/rfc6840" title="PDF version of this document">pdf</a>] [<a href="https://tools.ietf.org/html/draft-ietf-dnsext-dnssec-bis-updates" title="draft-ietf-dnsext-dnssec-bis-updates">draft-ietf-dnse...</a>] [<a href="https://datatracker.ietf.org/doc/rfc6840" title="IESG Datatracker information for this document">Tracker</a>] [<a href="https://tools.ietf.org/rfcdiff?difftype=--hwdiff&amp;url2=rfc6840" title="Inline diff (wdiff)">Diff1</a>] [<a href="https://tools.ietf.org/rfcdiff?url2=rfc6840" title="Side-by-side diff">Diff2</a>] [<a href="https://www.rfc-editor.org/errata_search.php?rfc=6840">Errata</a>]</span><br/>
<span class="pre noprint docinfo">                                                                        </span><br/>
<span class="pre noprint docinfo">                                                       PROPOSED STANDARD</span><br/>
<span class="pre noprint docinfo">                                                            <span style="color: #C00;">Errata Exist</span></span><br/>
<pre>Internet Engineering Task Force (IETF)                    S. Weiler, Ed.
Request for Comments: 6840                                  SPARTA, Inc.
Updates: <a href="rfc4033.html">4033</a>, <a href="rfc4034.html">4034</a>, <a href="rfc4035.html">4035</a>, <a href="rfc5155.html">5155</a>                           D. Blacka, Ed.
Category: Standards Track                                 Verisign, Inc.
ISSN: 2070-1721                                            February 2013


   <span class="h1">Clarifications and Implementation Notes for DNS Security (DNSSEC)</span>

Abstract

   This document is a collection of technical clarifications to the DNS
   Security (DNSSEC) document set.  It is meant to serve as a resource
   to implementors as well as a collection of DNSSEC errata that existed
   at the time of writing.

   This document updates the core DNSSEC documents (<a href="rfc4033.html">RFC 4033</a>, <a href="rfc4034.html">RFC 4034</a>,
   and <a href="rfc4035.html">RFC 4035</a>) as well as the NSEC3 specification (<a href="rfc5155.html">RFC 5155</a>).  It also
   defines NSEC3 and SHA-2 (<a href="rfc4509.html">RFC 4509</a> and <a href="rfc5702.html">RFC 5702</a>) as core parts of the
   DNSSEC specification.

Status of This Memo

   This is an Internet Standards Track document.

   This document is a product of the Internet Engineering Task Force
   (IETF).  It represents the consensus of the IETF community.  It has
   received public review and has been approved for publication by the
   Internet Engineering Steering Group (IESG).  Further information on
   Internet Standards is available in <a href="rfc5741.html#section-2">Section 2 of RFC 5741</a>.

   Information about the current status of this document, any errata,
   and how to provide feedback on it may be obtained at
   <a href="http://www.rfc-editor.org/info/rfc6840">http://www.rfc-editor.org/info/rfc6840</a>.

















<span class="grey">Weiler &amp; Blacka              Standards Track                    [Page 1]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-2" id="page-2" name="page-2"> </a>
<span class="grey"><a href="rfc6840.html">RFC 6840</a>               DNSSEC Implementation Notes         February 2013</span>


Copyright Notice

   Copyright (c) 2013 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to <a href="https://tools.ietf.org/html/bcp78">BCP 78</a> and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (<a href="http://trustee.ietf.org/license-info">http://trustee.ietf.org/license-info</a>) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.

   This document may contain material from IETF Documents or IETF
   Contributions published or made publicly available before November
   10, 2008.  The person(s) controlling the copyright in some of this
   material may not have granted the IETF Trust the right to allow
   modifications of such material outside the IETF Standards Process.
   Without obtaining an adequate license from the person(s) controlling
   the copyright in such materials, this document may not be modified
   outside the IETF Standards Process, and derivative works of it may
   not be created outside the IETF Standards Process, except to format
   it for publication as an RFC or to translate it into languages other
   than English.

























<span class="grey">Weiler &amp; Blacka              Standards Track                    [Page 2]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-3" id="page-3" name="page-3"> </a>
<span class="grey"><a href="rfc6840.html">RFC 6840</a>               DNSSEC Implementation Notes         February 2013</span>


Table of Contents

   <a href="#section-1">1</a>. Introduction and Terminology ....................................<a href="#page-4">4</a>
      <a href="#section-1.1">1.1</a>. Structure of This Document .................................<a href="#page-4">4</a>
      <a href="#section-1.2">1.2</a>. Terminology ................................................<a href="#page-4">4</a>
   <a href="#section-2">2</a>. Important Additions to DNSSEC ...................................<a href="#page-4">4</a>
      <a href="#section-2.1">2.1</a>. NSEC3 Support ..............................................<a href="#page-4">4</a>
      <a href="#section-2.2">2.2</a>. SHA-2 Support ..............................................<a href="#page-5">5</a>
   <a href="#section-3">3</a>. Scaling Concerns ................................................<a href="#page-5">5</a>
      <a href="#section-3.1">3.1</a>. Implement a BAD Cache ......................................<a href="#page-5">5</a>
   <a href="#section-4">4</a>. Security Concerns ...............................................<a href="#page-5">5</a>
      <a href="#section-4.1">4.1</a>. Clarifications on Nonexistence Proofs ......................<a href="#page-5">5</a>
      <a href="#section-4.2">4.2</a>. Validating Responses to an ANY Query .......................<a href="#page-6">6</a>
      <a href="#section-4.3">4.3</a>. Check for CNAME ............................................<a href="#page-6">6</a>
      <a href="#section-4.4">4.4</a>. Insecure Delegation Proofs .................................<a href="#page-7">7</a>
   <a href="#section-5">5</a>. Interoperability Concerns .......................................<a href="#page-7">7</a>
      <a href="#section-5.1">5.1</a>. Errors in Canonical Form Type Code List ....................<a href="#page-7">7</a>
      <a href="#section-5.2">5.2</a>. Unknown DS Message Digest Algorithms .......................<a href="#page-7">7</a>
      <a href="#section-5.3">5.3</a>. Private Algorithms .........................................<a href="#page-8">8</a>
      <a href="#section-5.4">5.4</a>. Caution about Local Policy and Multiple RRSIGs .............<a href="#page-9">9</a>
      <a href="#section-5.5">5.5</a>. Key Tag Calculation ........................................<a href="#page-9">9</a>
      <a href="#section-5.6">5.6</a>. Setting the DO Bit on Replies ..............................<a href="#page-9">9</a>
      <a href="#section-5.7">5.7</a>. Setting the AD Bit on Queries .............................<a href="#page-10">10</a>
      <a href="#section-5.8">5.8</a>. Setting the AD Bit on Replies .............................<a href="#page-10">10</a>
      <a href="#section-5.9">5.9</a>. Always Set the CD Bit on Queries ..........................<a href="#page-10">10</a>
      <a href="#section-5.10">5.10</a>. Nested Trust Anchors .....................................<a href="#page-11">11</a>
      <a href="#section-5.11">5.11</a>. Mandatory Algorithm Rules ................................<a href="#page-11">11</a>
      <a href="#section-5.12">5.12</a>. Ignore Extra Signatures from Unknown Keys ................<a href="#page-12">12</a>
   <a href="#section-6">6</a>. Minor Corrections and Clarifications ...........................<a href="#page-12">12</a>
      <a href="#section-6.1">6.1</a>. Finding Zone Cuts .........................................<a href="#page-12">12</a>
      <a href="#section-6.2">6.2</a>. Clarifications on DNSKEY Usage ............................<a href="#page-12">12</a>
      <a href="#section-6.3">6.3</a>. Errors in Examples ........................................<a href="#page-13">13</a>
      <a href="#section-6.4">6.4</a>. Errors in <a href="rfc5155.html">RFC 5155</a> ........................................<a href="#page-13">13</a>
   <a href="#section-7">7</a>. Security Considerations ........................................<a href="#page-13">13</a>
   <a href="#section-8">8</a>. References .....................................................<a href="#page-14">14</a>
      <a href="#section-8.1">8.1</a>. Normative References ......................................<a href="#page-14">14</a>
      <a href="#section-8.2">8.2</a>. Informative References ....................................<a href="#page-15">15</a>
   <a href="#appendix-A">Appendix A</a>. Acknowledgments .......................................<a href="#page-16">16</a>
   <a href="#appendix-B">Appendix B</a>. Discussion of Setting the CD Bit ......................<a href="#page-16">16</a>
   <a href="#appendix-C">Appendix C</a>. Discussion of Trust Anchor Preference Options .........<a href="#page-19">19</a>
      <a href="#appendix-C.1">C.1</a>. Closest Encloser ..........................................<a href="#page-19">19</a>
      <a href="#appendix-C.2">C.2</a>. Accept Any Success ........................................<a href="#page-20">20</a>
      <a href="#appendix-C.3">C.3</a>. Preference Based on Source ................................<a href="#page-20">20</a>








<span class="grey">Weiler &amp; Blacka              Standards Track                    [Page 3]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-4" id="page-4" name="page-4"> </a>
<span class="grey"><a href="rfc6840.html">RFC 6840</a>               DNSSEC Implementation Notes         February 2013</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/1.%20%20Introduction%20and%20Terminology"></a><a class="selflink" href="#section-1" name="section-1">1</a>.  Introduction and Terminology</span>

   This document lists some additions, clarifications, and corrections
   to the core DNSSEC specification, as originally described in
   [<a href="rfc4033.html" title='"DNS Security Introduction and Requirements"'>RFC4033</a>], [<a href="rfc4034.html" title='"Resource Records for the DNS Security Extensions"'>RFC4034</a>], and [<a href="rfc4035.html" title=" however">RFC4035</a>], and later amended by [<a href="rfc5155.html" title='"DNS Security (DNSSEC) Hashed Authenticated Denial of Existence"'>RFC5155</a>].
   (See <a href="#section-2">Section 2</a> for more recent additions to that core document set.)

   It is intended to serve as a resource for implementors and as a
   repository of items existing at the time of writing that need to be
   addressed when advancing the DNSSEC documents along the Standards
   Track.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/1.1.%20%20Structure%20of%20This%20Document"></a><a class="selflink" href="#section-1.1" name="section-1.1">1.1</a>.  Structure of This Document</span>

   The clarifications and changes to DNSSEC are sorted according to
   their importance, starting with ones which could, if ignored, lead to
   security problems and progressing down to clarifications that are
   expected to have little operational impact.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/1.2.%20%20Terminology"></a><a class="selflink" href="#section-1.2" name="section-1.2">1.2</a>.  Terminology</span>

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
   "OPTIONAL" in this document are to be interpreted as described in
   [<a href="rfc2119.html" title='"Key words for use in RFCs to Indicate Requirement Levels"'>RFC2119</a>].

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/2.%20%20Important%20Additions%20to%20DNSSEC"></a><a class="selflink" href="#section-2" name="section-2">2</a>.  Important Additions to DNSSEC</span>

   This section lists some documents that are now considered core DNSSEC
   protocol documents in addition to those originally specified in
   <a href="rfc4033.html#section-10">Section 10 of [RFC4033]</a>.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/2.1.%20%20NSEC3%20Support"></a><a class="selflink" href="#section-2.1" name="section-2.1">2.1</a>.  NSEC3 Support</span>

   [<a id="ref-RFC5155" name="ref-RFC5155">RFC5155</a>] describes the use and behavior of the NSEC3 and NSEC3PARAM
   records for hashed denial of existence.  Validator implementations
   are strongly encouraged to include support for NSEC3 because a number
   of highly visible zones use it.  Validators that do not support
   validation of responses using NSEC3 will be hampered in validating
   large portions of the DNS space.

   [<a id="ref-RFC5155" name="ref-RFC5155">RFC5155</a>] is now considered part of the DNS Security Document Family
   as described by <a href="rfc4033.html#section-10">Section 10 of [RFC4033]</a>.








<span class="grey">Weiler &amp; Blacka              Standards Track                    [Page 4]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-5" id="page-5" name="page-5"> </a>
<span class="grey"><a href="rfc6840.html">RFC 6840</a>               DNSSEC Implementation Notes         February 2013</span>


   Note that the algorithm identifiers defined in [<a href="rfc5155.html" title='"DNS Security (DNSSEC) Hashed Authenticated Denial of Existence"'>RFC5155</a>] (DSA-NSEC3-
   SHA1 and RSASHA1-NSEC3-SHA1) and [<a href="rfc5702.html" title='"Use of SHA-2 Algorithms with RSA in DNSKEY and RRSIG Resource Records for DNSSEC"'>RFC5702</a>] (RSASHA256 and RSASHA512)
   signal that a zone might be using NSEC3, rather than NSEC.  The zone
   may be using either, and validators supporting these algorithms MUST
   support both NSEC3 and NSEC responses.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/2.2.%20%20SHA-2%20Support"></a><a class="selflink" href="#section-2.2" name="section-2.2">2.2</a>.  SHA-2 Support</span>

   [<a id="ref-RFC4509" name="ref-RFC4509">RFC4509</a>] describes the use of SHA-256 as a digest algorithm in
   Delegation Signer (DS) RRs.  [<a href="rfc5702.html" title='"Use of SHA-2 Algorithms with RSA in DNSKEY and RRSIG Resource Records for DNSSEC"'>RFC5702</a>] describes the use of the
   RSASHA256 and RSASHA512 algorithms in DNSKEY and RRSIG RRs.
   Validator implementations are strongly encouraged to include support
   for these algorithms for DS, DNSKEY, and RRSIG records.

   Both [<a href="rfc4509.html" title='"Use of SHA-256 in DNSSEC Delegation Signer (DS) Resource Records (RRs)"'>RFC4509</a>] and [<a href="rfc5702.html" title='"Use of SHA-2 Algorithms with RSA in DNSKEY and RRSIG Resource Records for DNSSEC"'>RFC5702</a>] are now considered part of the DNS
   Security Document Family as described by <a href="rfc4033.html#section-10">Section 10 of [RFC4033]</a>.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/3.%20%20Scaling%20Concerns"></a><a class="selflink" href="#section-3" name="section-3">3</a>.  Scaling Concerns</span>

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.1.%20%20Implement%20a%20BAD%20Cache"></a><a class="selflink" href="#section-3.1" name="section-3.1">3.1</a>.  Implement a BAD Cache</span>

   <a href="rfc4035.html#section-4.7">Section 4.7 of [RFC4035]</a> permits security-aware resolvers to
   implement a BAD cache.  That guidance has changed: security-aware
   resolvers SHOULD implement a BAD cache as described in [<a href="rfc4035.html" title=" however">RFC4035</a>].

   This change in guidance is based on operational experience with
   DNSSEC administrative errors leading to significant increases in DNS
   traffic, with an accompanying realization that such events are more
   likely and more damaging than originally supposed.  An example of one
   such event is documented in "Rolling Over DNSSEC Keys" [<a href="#ref-Huston" title='"Rolling Over DNSSEC Keys"'>Huston</a>].

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/4.%20%20Security%20Concerns"></a><a class="selflink" href="#section-4" name="section-4">4</a>.  Security Concerns</span>

   This section provides clarifications that, if overlooked, could lead
   to security issues.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.1.%20%20Clarifications%20on%20Nonexistence%20Proofs"></a><a class="selflink" href="#section-4.1" name="section-4.1">4.1</a>.  Clarifications on Nonexistence Proofs</span>

   <a href="rfc4035.html#section-5.4">Section 5.4 of [RFC4035]</a> under-specifies the algorithm for checking
   nonexistence proofs.  In particular, the algorithm as presented would
   allow a validator to interpret an NSEC or NSEC3 RR from an ancestor
   zone as proving the nonexistence of an RR in a child zone.

   An "ancestor delegation" NSEC RR (or NSEC3 RR) is one with:

   o  the NS bit set,

   o  the Start of Authority (SOA) bit clear, and



<span class="grey">Weiler &amp; Blacka              Standards Track                    [Page 5]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-6" id="page-6" name="page-6"> </a>
<span class="grey"><a href="rfc6840.html">RFC 6840</a>               DNSSEC Implementation Notes         February 2013</span>


   o  a signer field that is shorter than the owner name of the NSEC RR,
      or the original owner name for the NSEC3 RR.

   Ancestor delegation NSEC or NSEC3 RRs MUST NOT be used to assume
   nonexistence of any RRs below that zone cut, which include all RRs at
   that (original) owner name other than DS RRs, and all RRs below that
   owner name regardless of type.

   Similarly, the algorithm would also allow an NSEC RR at the same
   owner name as a DNAME RR, or an NSEC3 RR at the same original owner
   name as a DNAME, to prove the nonexistence of names beneath that
   DNAME.  An NSEC or NSEC3 RR with the DNAME bit set MUST NOT be used
   to assume the nonexistence of any subdomain of that NSEC/NSEC3 RR's
   (original) owner name.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.2.%20%20Validating%20Responses%20to%20an%20ANY%20Query"></a><a class="selflink" href="#section-4.2" name="section-4.2">4.2</a>.  Validating Responses to an ANY Query</span>

   [<a id="ref-RFC4035" name="ref-RFC4035">RFC4035</a>] does not address how to validate responses when QTYPE=*.
   As described in <a href="rfc1034.html#section-6.2.2">Section 6.2.2 of [RFC1034]</a>, a proper response to
   QTYPE=* may include a subset of the RRsets at a given name.  That is,
   it is not necessary to include all RRsets at the QNAME in the
   response.

   When validating a response to QTYPE=*, all received RRsets that match
   QNAME and QCLASS MUST be validated.  If any of those RRsets fail
   validation, the answer is considered Bogus.  If there are no RRsets
   matching QNAME and QCLASS, that fact MUST be validated according to
   the rules in <a href="rfc4035.html#section-5.4">Section 5.4 of [RFC4035]</a> (as clarified in this
   document).  To be clear, a validator must not expect to receive all
   records at the QNAME in response to QTYPE=*.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.3.%20%20Check%20for%20CNAME"></a><a class="selflink" href="#section-4.3" name="section-4.3">4.3</a>.  Check for CNAME</span>

   <a href="rfc4035.html#section-5">Section 5 of [RFC4035]</a> says nothing explicit about validating
   responses based on (or that should be based on) CNAMEs.  When
   validating a NOERROR/NODATA response, validators MUST check the CNAME
   bit in the matching NSEC or NSEC3 RR's type bitmap in addition to the
   bit for the query type.

   Without this check, an attacker could successfully transform a
   positive CNAME response into a NOERROR/NODATA response by (for
   example) simply stripping the CNAME RRset from the response.  A naive
   validator would then note that the QTYPE was not present in the
   matching NSEC/NSEC3 RR, but fail to notice that the CNAME bit was
   set; thus, the response should have been a positive CNAME response.






<span class="grey">Weiler &amp; Blacka              Standards Track                    [Page 6]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-7" id="page-7" name="page-7"> </a>
<span class="grey"><a href="rfc6840.html">RFC 6840</a>               DNSSEC Implementation Notes         February 2013</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.4.%20%20Insecure%20Delegation%20Proofs"></a><a class="selflink" href="#section-4.4" name="section-4.4">4.4</a>.  Insecure Delegation Proofs</span>

   <a href="rfc4035.html#section-5.2">Section 5.2 of [RFC4035]</a> specifies that a validator, when proving a
   delegation is not secure, needs to check for the absence of the DS
   and SOA bits in the NSEC (or NSEC3) type bitmap.  The validator also
   MUST check for the presence of the NS bit in the matching NSEC (or
   NSEC3) RR (proving that there is, indeed, a delegation), or
   alternately make sure that the delegation is covered by an NSEC3 RR
   with the Opt-Out flag set.

   Without this check, an attacker could reuse an NSEC or NSEC3 RR
   matching a non-delegation name to spoof an unsigned delegation at
   that name.  This would claim that an existing signed RRset (or set of
   signed RRsets) is below an unsigned delegation, thus not signed and
   vulnerable to further attack.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/5.%20%20Interoperability%20Concerns"></a><a class="selflink" href="#section-5" name="section-5">5</a>.  Interoperability Concerns</span>

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.1.%20%20Errors%20in%20Canonical%20Form%20Type%20Code%20List"></a><a class="selflink" href="#section-5.1" name="section-5.1">5.1</a>.  Errors in Canonical Form Type Code List</span>

   When canonicalizing DNS names (for both ordering and signing), DNS
   names in the RDATA section of NSEC resource records are not converted
   to lowercase.  DNS names in the RDATA section of RRSIG resource
   records are converted to lowercase.

   The guidance in the above paragraph differs from what has been
   published before but is consistent with current common practice.
   Item 3 of <a href="rfc4034.html#section-6.2">Section 6.2 of [RFC4034]</a> says that names in both of these
   RR types should be converted to lowercase.  The earlier [<a href="rfc3755.html" title='"Legacy Resolver Compatibility for Delegation Signer (DS)"'>RFC3755</a>]
   says that they should not.  Current practice follows neither document
   fully.

   <a href="rfc4034.html#section-6.2">Section 6.2 of [RFC4034]</a> also erroneously lists HINFO as a record
   that needs conversion to lowercase, and twice at that.  Since HINFO
   records contain no domain names, they are not subject to case
   conversion.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.2.%20%20Unknown%20DS%20Message%20Digest%20Algorithms"></a><a class="selflink" href="#section-5.2" name="section-5.2">5.2</a>.  Unknown DS Message Digest Algorithms</span>

   <a href="rfc4035.html#section-5.2">Section 5.2 of [RFC4035]</a> includes rules for how to handle delegations
   to zones that are signed with entirely unsupported public key
   algorithms, as indicated by the key algorithms shown in those zones'
   DS RRsets.  It does not explicitly address how to handle DS records
   that use unsupported message digest algorithms.  In brief, DS records
   using unknown or unsupported message digest algorithms MUST be
   treated the same way as DS records referring to DNSKEY RRs of unknown
   or unsupported public key algorithms.




<span class="grey">Weiler &amp; Blacka              Standards Track                    [Page 7]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-8" id="page-8" name="page-8"> </a>
<span class="grey"><a href="rfc6840.html">RFC 6840</a>               DNSSEC Implementation Notes         February 2013</span>


   The existing text says:

      If the validator does not support any of the algorithms listed in
      an authenticated DS RRset, then the resolver has no supported
      authentication path leading from the parent to the child.  The
      resolver should treat this case as it would the case of an
      authenticated NSEC RRset proving that no DS RRset exists, as
      described above.

   In other words, when determining the security status of a zone, a
   validator disregards any authenticated DS records that specify
   unknown or unsupported DNSKEY algorithms.  If none are left, the zone
   is treated as if it were unsigned.

   This document modifies the above text to additionally disregard
   authenticated DS records using unknown or unsupported message digest
   algorithms.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.3.%20%20Private%20Algorithms"></a><a class="selflink" href="#section-5.3" name="section-5.3">5.3</a>.  Private Algorithms</span>

   As discussed above, <a href="rfc4035.html#section-5.2">Section 5.2 of [RFC4035]</a> requires that validators
   make decisions about the security status of zones based on the public
   key algorithms shown in the DS records for those zones.  In the case
   of private algorithms, as described in <a href="rfc4034.html#appendix-A.1.1">Appendix A.1.1 of [RFC4034]</a>,
   the eight-bit algorithm field in the DS RR is not conclusive about
   what algorithm(s) is actually in use.

   If no private algorithms appear in the DS RRset, or if any supported
   algorithm appears in the DS RRset, no special processing is needed.
   Furthermore, if the validator implementation does not support any
   private algorithms, or only supports private algorithms using an
   algorithm number not present in the DS RRset, no special processing
   is needed.

   In the remaining cases, the security status of the zone depends on
   whether or not the resolver supports any of the private algorithms in
   use (provided that these DS records use supported message digest
   algorithms, as discussed in <a href="#section-5.2">Section 5.2</a> of this document).  In these
   cases, the resolver MUST retrieve the corresponding DNSKEY for each
   private algorithm DS record and examine the public key field to
   determine the algorithm in use.  The security-aware resolver MUST
   ensure that the hash of the DNSKEY RR's owner name and RDATA matches
   the digest in the DS RR as described in <a href="rfc4035.html#section-5.2">Section 5.2 of [RFC4035]</a>,
   authenticating the DNSKEY.  If all of the retrieved and authenticated
   DNSKEY RRs use unknown or unsupported private algorithms, then the
   zone is treated as if it were unsigned.





<span class="grey">Weiler &amp; Blacka              Standards Track                    [Page 8]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-9" id="page-9" name="page-9"> </a>
<span class="grey"><a href="rfc6840.html">RFC 6840</a>               DNSSEC Implementation Notes         February 2013</span>


   Note that if none of the private algorithm DS RRs can be securely
   matched to DNSKEY RRs and no other DS establishes that the zone is
   secure, the referral should be considered Bogus data as discussed in
   [<a href="rfc4035.html" title=" however">RFC4035</a>].

   This clarification facilitates the broader use of private algorithms,
   as suggested by [<a href="rfc4955.html" title='"DNS Security (DNSSEC) Experiments"'>RFC4955</a>].

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.4.%20%20Caution%20about%20Local%20Policy%20and%20Multiple%20RRSIGs"></a><a class="selflink" href="#section-5.4" name="section-5.4">5.4</a>.  Caution about Local Policy and Multiple RRSIGs</span>

   When multiple RRSIGs cover a given RRset, <a href="rfc4035.html#section-5.3.3">Section 5.3.3 of [RFC4035]</a>
   suggests that "the local resolver security policy determines whether
   the resolver also has to test these RRSIG RRs and how to resolve
   conflicts if these RRSIG RRs lead to differing results".

   This document specifies that a resolver SHOULD accept any valid RRSIG
   as sufficient, and only determine that an RRset is Bogus if all
   RRSIGs fail validation.

   If a resolver adopts a more restrictive policy, there's a danger that
   properly signed data might unnecessarily fail validation due to cache
   timing issues.  Furthermore, certain zone management techniques, like
   the Double Signature Zone Signing Key Rollover method described in
   <a href="rfc6781.html#section-4.2.1.2">Section 4.2.1.2 of [RFC6781]</a>, will not work reliably.  Such a
   resolver is also vulnerable to malicious insertion of gibberish
   signatures.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.5.%20%20Key%20Tag%20Calculation"></a><a class="selflink" href="#section-5.5" name="section-5.5">5.5</a>.  Key Tag Calculation</span>

   <a href="rfc4034.html#appendix-B.1">Appendix B.1 of [RFC4034]</a> incorrectly defines the Key Tag field
   calculation for algorithm 1.  It correctly says that the Key Tag is
   the most significant 16 of the least significant 24 bits of the
   public key modulus.  However, [<a href="rfc4034.html" title='"Resource Records for the DNS Security Extensions"'>RFC4034</a>] then goes on to incorrectly
   say that this is fourth-to-last and third-to-last octets of the
   public key modulus.  It is, in fact, the third-to-last and second-to-
   last octets.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.6.%20%20Setting%20the%20DO%20Bit%20on%20Replies"></a><a class="selflink" href="#section-5.6" name="section-5.6">5.6</a>.  Setting the DO Bit on Replies</span>

   As stated in <a href="rfc3225.html#section-3">Section 3 of [RFC3225]</a>, the DNSSEC OK (DO) bit of the
   query MUST be copied in the response.  However, in order to
   interoperate with implementations that ignore this rule on sending,
   resolvers MUST ignore the DO bit in responses.








<span class="grey">Weiler &amp; Blacka              Standards Track                    [Page 9]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-10" id="page-10" name="page-10"> </a>
<span class="grey"><a href="rfc6840.html">RFC 6840</a>               DNSSEC Implementation Notes         February 2013</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.7.%20%20Setting%20the%20AD%20Bit%20on%20Queries"></a><a class="selflink" href="#section-5.7" name="section-5.7">5.7</a>.  Setting the AD Bit on Queries</span>

   The semantics of the Authentic Data (AD) bit in the query were
   previously undefined.  <a href="rfc4035.html#section-4.6">Section 4.6 of [RFC4035]</a> instructed resolvers
   to always clear the AD bit when composing queries.

   This document defines setting the AD bit in a query as a signal
   indicating that the requester understands and is interested in the
   value of the AD bit in the response.  This allows a requester to
   indicate that it understands the AD bit without also requesting
   DNSSEC data via the DO bit.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.8.%20%20Setting%20the%20AD%20Bit%20on%20Replies"></a><a class="selflink" href="#section-5.8" name="section-5.8">5.8</a>.  Setting the AD Bit on Replies</span>

   <a href="rfc4035.html#section-3.2.3">Section 3.2.3 of [RFC4035]</a> describes under which conditions a
   validating resolver should set or clear the AD bit in a response.  In
   order to interoperate with legacy stub resolvers and middleboxes that
   neither understand nor ignore the AD bit, validating resolvers SHOULD
   only set the AD bit when a response both meets the conditions listed
   in <a href="rfc4035.html#section-3.2.3">Section 3.2.3 of [RFC4035]</a>, and the request contained either a set
   DO bit or a set AD bit.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.9.%20%20Always%20Set%20the%20CD%20Bit%20on%20Queries"></a><a class="selflink" href="#section-5.9" name="section-5.9">5.9</a>.  Always Set the CD Bit on Queries</span>

   When processing a request with the Checking Disabled (CD) bit set, a
   resolver SHOULD attempt to return all response data, even data that
   has failed DNSSEC validation.  <a href="rfc4035.html#section-3.2.2">Section 3.2.2 of [RFC4035]</a> requires a
   resolver processing a request with the CD bit set to set the CD bit
   on its upstream queries.

   This document further specifies that validating resolvers SHOULD set
   the CD bit on every upstream query.  This is regardless of whether
   the CD bit was set on the incoming query or whether it has a trust
   anchor at or above the QNAME.

   [<a id="ref-RFC4035" name="ref-RFC4035">RFC4035</a>] is ambiguous about what to do when a cached response was
   obtained with the CD bit unset, a case that only arises when the
   resolver chooses not to set the CD bit on all upstream queries, as
   specified above.  In the typical case, no new query is required, nor
   does the cache need to track the state of the CD bit used to make a
   given query.  The problem arises when the cached response is a server
   failure (RCODE 2), which may indicate that the requested data failed
   DNSSEC validation at an upstream validating resolver.  ([<a href="rfc2308.html" title='"Negative Caching of DNS Queries (DNS NCACHE)"'>RFC2308</a>]
   permits caching of server failures for up to five minutes.)  In these
   cases, a new query with the CD bit set is required.

   <a href="#appendix-B">Appendix B</a> discusses more of the logic behind the recommendation
   presented in this section.



<span class="grey">Weiler &amp; Blacka              Standards Track                   [Page 10]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-11" id="page-11" name="page-11"> </a>
<span class="grey"><a href="rfc6840.html">RFC 6840</a>               DNSSEC Implementation Notes         February 2013</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.10.%20%20Nested%20Trust%20Anchors"></a><a class="selflink" href="#section-5.10" name="section-5.10">5.10</a>.  Nested Trust Anchors</span>

   A DNSSEC validator may be configured such that, for a given response,
   more than one trust anchor could be used to validate the chain of
   trust to the response zone.  For example, imagine a validator
   configured with trust anchors for "example." and "zone.example."
   When the validator is asked to validate a response to
   "www.sub.zone.example.", either trust anchor could apply.

   When presented with this situation, DNSSEC validators have a choice
   of which trust anchor(s) to use.  Which to use is a matter of
   implementation choice.  <a href="#appendix-C">Appendix C</a> discusses several possible
   algorithms.

   It is possible and advisable to expose the choice of policy as a
   configuration option.  As a default, it is suggested that validators
   implement the "Accept Any Success" policy described in <a href="#appendix-C.2">Appendix C.2</a>
   while exposing other policies as configuration options.

   The "Accept Any Success" policy is to try all applicable trust
   anchors until one gives a validation result of Secure, in which case
   the final validation result is Secure.  If and only if all applicable
   trust anchors give a result of Insecure, the final validation result
   is Insecure.  If one or more trust anchors lead to a Bogus result and
   there is no Secure result, then the final validation result is Bogus.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.11.%20%20Mandatory%20Algorithm%20Rules"></a><a class="selflink" href="#section-5.11" name="section-5.11">5.11</a>.  Mandatory Algorithm Rules</span>

   The last paragraph of <a href="rfc4035.html#section-2.2">Section 2.2 of [RFC4035]</a> includes rules
   describing which algorithms must be used to sign a zone.  Since these
   rules have been confusing, they are restated using different language
   here:

      The DS RRset and DNSKEY RRset are used to signal which algorithms
      are used to sign a zone.  The presence of an algorithm in either a
      zone's DS or DNSKEY RRset signals that that algorithm is used to
      sign the entire zone.

      A signed zone MUST include a DNSKEY for each algorithm present in
      the zone's DS RRset and expected trust anchors for the zone.  The
      zone MUST also be signed with each algorithm (though not each key)
      present in the DNSKEY RRset.  It is possible to add algorithms at
      the DNSKEY that aren't in the DS record, but not vice versa.  If
      more than one key of the same algorithm is in the DNSKEY RRset, it
      is sufficient to sign each RRset with any subset of these DNSKEYs.
      It is acceptable to sign some RRsets with one subset of keys (or
      key) and other RRsets with a different subset, so long as at least




<span class="grey">Weiler &amp; Blacka              Standards Track                   [Page 11]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-12" id="page-12" name="page-12"> </a>
<span class="grey"><a href="rfc6840.html">RFC 6840</a>               DNSSEC Implementation Notes         February 2013</span>


      one DNSKEY of each algorithm is used to sign each RRset.
      Likewise, if there are DS records for multiple keys of the same
      algorithm, any subset of those may appear in the DNSKEY RRset.

   This requirement applies to servers, not validators.  Validators
   SHOULD accept any single valid path.  They SHOULD NOT insist that all
   algorithms signaled in the DS RRset work, and they MUST NOT insist
   that all algorithms signaled in the DNSKEY RRset work.  A validator
   MAY have a configuration option to perform a signature completeness
   test to support troubleshooting.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.12.%20%20Ignore%20Extra%20Signatures%20from%20Unknown%20Keys"></a><a class="selflink" href="#section-5.12" name="section-5.12">5.12</a>.  Ignore Extra Signatures from Unknown Keys</span>

   Validating resolvers MUST disregard RRSIGs in a zone that do not
   (currently) have a corresponding DNSKEY in the zone.  Similarly, a
   validating resolver MUST disregard RRSIGs with algorithm types that
   don't exist in the DNSKEY RRset.

   Good key rollover and algorithm rollover practices, as discussed in
   <a href="rfc6781.html">RFC 6781</a> and its successor documents and as suggested by the rules in
   the previous section, may require that such RRSIGs be present in a
   zone.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/6.%20%20Minor%20Corrections%20and%20Clarifications"></a><a class="selflink" href="#section-6" name="section-6">6</a>.  Minor Corrections and Clarifications</span>

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/6.1.%20%20Finding%20Zone%20Cuts"></a><a class="selflink" href="#section-6.1" name="section-6.1">6.1</a>.  Finding Zone Cuts</span>

   <a href="rfc4035.html#appendix-C.8">Appendix C.8 of [RFC4035]</a> discusses sending DS queries to the servers
   for a parent zone but does not state how to find those servers.
   Specific instructions can be found in <a href="rfc4035.html#section-4.2">Section 4.2 of [RFC4035]</a>.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/6.2.%20%20Clarifications%20on%20DNSKEY%20Usage"></a><a class="selflink" href="#section-6.2" name="section-6.2">6.2</a>.  Clarifications on DNSKEY Usage</span>

   It is possible to use different DNSKEYs to sign different subsets of
   a zone, constrained only by the rules in <a href="#section-5.11">Section 5.11</a>.  It is even
   possible to use a different DNSKEY for each RRset in a zone, subject
   only to practical limits on the size of the DNSKEY RRset and the
   above rules.  However, be aware that there is no way to tell
   resolvers what a particular DNSKEY is supposed to be used for -- any
   DNSKEY in the zone's signed DNSKEY RRset may be used to authenticate
   any RRset in the zone.  For example, if a weaker or less trusted
   DNSKEY is being used to authenticate NSEC RRsets or all dynamically
   updated records, that same DNSKEY can also be used to sign any other
   RRsets from the zone.

   Furthermore, note that the SEP bit setting has no effect on how a
   DNSKEY may be used -- the validation process is specifically
   prohibited from using that bit by <a href="rfc4034.html#section-2.1.2">Section 2.1.2 of [RFC4034]</a>.  It is



<span class="grey">Weiler &amp; Blacka              Standards Track                   [Page 12]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-13" id="page-13" name="page-13"> </a>
<span class="grey"><a href="rfc6840.html">RFC 6840</a>               DNSSEC Implementation Notes         February 2013</span>


   possible to use a DNSKEY without the SEP bit set as the sole secure
   entry point to the zone, yet use a DNSKEY with the SEP bit set to
   sign all RRsets in the zone (other than the DNSKEY RRset).  It is
   also possible to use a single DNSKEY, with or without the SEP bit
   set, to sign the entire zone, including the DNSKEY RRset itself.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/6.3.%20%20Errors%20in%20Examples"></a><a class="selflink" href="#section-6.3" name="section-6.3">6.3</a>.  Errors in Examples</span>

   The text in <a href="rfc4035.html#appendix-C.1">Appendix C.1 of [RFC4035]</a> refers to the examples in
   <a href="#appendix-B.1">Appendix B.1</a> as "x.w.example.com" while B.1 uses "x.w.example".  This
   is painfully obvious in the second paragraph where it states that the
   RRSIG labels field value of 3 indicates that the answer was not the
   result of wildcard expansion.  This is true for "x.w.example" but not
   for "x.w.example.com", which of course has a label count of 4
   (antithetically, a label count of 3 would imply the answer was the
   result of a wildcard expansion).

   The first paragraph of <a href="rfc4035.html#appendix-C.6">Appendix C.6 of [RFC4035]</a> also has a minor
   error: the reference to "a.z.w.w.example" should instead be
   "a.z.w.example", as in the previous line.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/6.4.%20%20Errors%20in%20RFC%205155"></a><a class="selflink" href="#section-6.4" name="section-6.4">6.4</a>.  Errors in <a href="rfc5155.html">RFC 5155</a></span>

   An NSEC3 record that matches an Empty Non-Terminal effectively has no
   type associated with it.  This NSEC3 record has an empty type bit
   map.  <a href="rfc5155.html#section-3.2.1">Section 3.2.1 of [RFC5155]</a> contains the statement:

      Blocks with no types present MUST NOT be included.

   However, the same section contains a regular expression:

      Type Bit Maps Field = ( Window Block # | Bitmap Length | Bitmap )+

   The plus sign in the regular expression indicates that there is one
   or more of the preceding element.  This means that there must be at
   least one window block.  If this window block has no types, it
   contradicts with the first statement.  Therefore, the correct text in
   <a href="rfc5155.html#section-3.2.1">Section 3.2.1 of [RFC5155]</a> should be:

      Type Bit Maps Field = ( Window Block # | Bitmap Length | Bitmap )*

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/7.%20%20Security%20Considerations"></a><a class="selflink" href="#section-7" name="section-7">7</a>.  Security Considerations</span>

   This document adds SHA-2 and NSEC3 support to the core DNSSEC
   protocol.  Security considerations for those features are discussed
   in the documents defining them.  Additionally, this document
   addresses some ambiguities and omissions in the core DNSSEC documents
   that, if not recognized and addressed in implementations, could lead



<span class="grey">Weiler &amp; Blacka              Standards Track                   [Page 13]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-14" id="page-14" name="page-14"> </a>
<span class="grey"><a href="rfc6840.html">RFC 6840</a>               DNSSEC Implementation Notes         February 2013</span>


   to security failures.  In particular, the validation algorithm
   clarifications in <a href="#section-4">Section 4</a> are critical for preserving the security
   properties DNSSEC offers.  Furthermore, failure to address some of
   the interoperability concerns in <a href="#section-5">Section 5</a> could limit the ability to
   later change or expand DNSSEC, including adding new algorithms.

   The recommendation in <a href="#section-5.9">Section 5.9</a> to always set the CD bit has
   security implications.  By setting the CD bit, a resolver will not
   benefit from more stringent validation rules or a more complete set
   of trust anchors at an upstream validator.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/8.%20%20References"></a><a class="selflink" href="#section-8" name="section-8">8</a>.  References</span>

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/8.1.%20%20Normative%20References"></a><a class="selflink" href="#section-8.1" name="section-8.1">8.1</a>.  Normative References</span>

   [<a id="ref-RFC1034" name="ref-RFC1034">RFC1034</a>]  Mockapetris, P., "Domain names - concepts and facilities",
              STD 13, <a href="rfc1034.html">RFC 1034</a>, November 1987.

   [<a id="ref-RFC2119" name="ref-RFC2119">RFC2119</a>]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", <a href="https://tools.ietf.org/html/bcp14">BCP 14</a>, <a href="rfc2119.html">RFC 2119</a>, March 1997.

   [<a id="ref-RFC3225" name="ref-RFC3225">RFC3225</a>]  Conrad, D., "Indicating Resolver Support of DNSSEC",
              <a href="rfc3225.html">RFC 3225</a>, December 2001.

   [<a id="ref-RFC4033" name="ref-RFC4033">RFC4033</a>]  Arends, R., Austein, R., Larson, M., Massey, D., and S.
              Rose, "DNS Security Introduction and Requirements",
              <a href="rfc4033.html">RFC 4033</a>, March 2005.

   [<a id="ref-RFC4034" name="ref-RFC4034">RFC4034</a>]  Arends, R., Austein, R., Larson, M., Massey, D., and S.
              Rose, "Resource Records for the DNS Security Extensions",
              <a href="rfc4034.html">RFC 4034</a>, March 2005.

   [<a id="ref-RFC4035" name="ref-RFC4035">RFC4035</a>]  Arends, R., Austein, R., Larson, M., Massey, D., and S.
              Rose, "Protocol Modifications for the DNS Security
              Extensions", <a href="rfc4035.html">RFC 4035</a>, March 2005.

   [<a id="ref-RFC4509" name="ref-RFC4509">RFC4509</a>]  Hardaker, W., "Use of SHA-256 in DNSSEC Delegation Signer
              (DS) Resource Records (RRs)", <a href="rfc4509.html">RFC 4509</a>, May 2006.

   [<a id="ref-RFC5155" name="ref-RFC5155">RFC5155</a>]  Laurie, B., Sisson, G., Arends, R., and D. Blacka, "DNS
              Security (DNSSEC) Hashed Authenticated Denial of
              Existence", <a href="rfc5155.html">RFC 5155</a>, March 2008.

   [<a id="ref-RFC5702" name="ref-RFC5702">RFC5702</a>]  Jansen, J., "Use of SHA-2 Algorithms with RSA in DNSKEY
              and RRSIG Resource Records for DNSSEC", <a href="rfc5702.html">RFC 5702</a>,
              October 2009.





<span class="grey">Weiler &amp; Blacka              Standards Track                   [Page 14]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-15" id="page-15" name="page-15"> </a>
<span class="grey"><a href="rfc6840.html">RFC 6840</a>               DNSSEC Implementation Notes         February 2013</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/8.2.%20%20Informative%20References"></a><a class="selflink" href="#section-8.2" name="section-8.2">8.2</a>.  Informative References</span>

   [<a id="ref-Huston" name="ref-Huston">Huston</a>]   Michaelson, G., Wallstrom, P., Arends, R., and G. Huston,
              "Rolling Over DNSSEC Keys", Internet Protocol
              Journal, Vol. 13, No.1, pp. 2-16, March 2010.

   [<a id="ref-RFC2308" name="ref-RFC2308">RFC2308</a>]  Andrews, M., "Negative Caching of DNS Queries (DNS
              NCACHE)", <a href="rfc2308.html">RFC 2308</a>, March 1998.

   [<a id="ref-RFC3755" name="ref-RFC3755">RFC3755</a>]  Weiler, S., "Legacy Resolver Compatibility for Delegation
              Signer (DS)", <a href="rfc3755.html">RFC 3755</a>, May 2004.

   [<a id="ref-RFC4955" name="ref-RFC4955">RFC4955</a>]  Blacka, D., "DNS Security (DNSSEC) Experiments", <a href="rfc4955.html">RFC 4955</a>,
              July 2007.

   [<a id="ref-RFC5011" name="ref-RFC5011">RFC5011</a>]  StJohns, M., "Automated Updates of DNS Security (DNSSEC)
              Trust Anchors", STD 74, <a href="rfc5011.html">RFC 5011</a>, September 2007.

   [<a id="ref-RFC5074" name="ref-RFC5074">RFC5074</a>]  Weiler, S., "DNSSEC Lookaside Validation (DLV)", <a href="rfc5074.html">RFC 5074</a>,
              November 2007.

   [<a id="ref-RFC6781" name="ref-RFC6781">RFC6781</a>]  Kolkman, O., Mekking, W., and R. Gieben, "DNSSEC
              Operational Practices, Version 2", <a href="rfc6781.html">RFC 6781</a>,
              December 2012.



























<span class="grey">Weiler &amp; Blacka              Standards Track                   [Page 15]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-16" id="page-16" name="page-16"> </a>
<span class="grey"><a href="rfc6840.html">RFC 6840</a>               DNSSEC Implementation Notes         February 2013</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/Appendix%20A.%20%20Acknowledgments"></a><a class="selflink" href="#appendix-A" name="appendix-A">Appendix A</a>.  Acknowledgments</span>

   The editors would like the thank Rob Austein for his previous work as
   an editor of this document.

   The editors are extremely grateful to those who, in addition to
   finding errors and omissions in the DNSSEC document set, have
   provided text suitable for inclusion in this document.

   The lack of specificity about handling private algorithms, as
   described in <a href="#section-5.3">Section 5.3</a>, and the lack of specificity in handling ANY
   queries, as described in <a href="#section-4.2">Section 4.2</a>, were discovered by David
   Blacka.

   The error in algorithm 1 key tag calculation, as described in
   <a href="#section-5.5">Section 5.5</a>, was found by Abhijit Hayatnagarkar.  Donald Eastlake
   contributed text for <a href="#section-5.5">Section 5.5</a>.

   The bug relating to delegation NSEC RR's in <a href="#section-4.1">Section 4.1</a> was found by
   Roy Badami.  Roy Arends found the related problem with DNAME.

   The errors in the [<a href="rfc4035.html" title=" however">RFC4035</a>] examples were found by Roy Arends, who
   also contributed text for <a href="#section-6.3">Section 6.3</a> of this document.

   Text on the mandatory algorithm rules was derived from suggestions by
   Matthijs Mekking and Ed Lewis.

   The CD bit logic was analyzed in depth by David Blacka, Olafur
   Gudmundsson, Mike St. Johns, and Andrew Sullivan.

   The editors would like to thank Alfred Hoenes, Ed Lewis, Danny Mayer,
   Olafur Gudmundsson, Suzanne Woolf, Rickard Bellgrim, Mike St. Johns,
   Mark Andrews, Wouter Wijngaards, Matthijs Mekking, Andrew Sullivan,
   Jeremy Reed, Paul Hoffman, Mohan Parthasarathy, Florian Weimer,
   Warren Kumari and Scott Rose for their contributions to this
   document.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/Appendix%20B.%20%20Discussion%20of%20Setting%20the%20CD%20Bit"></a><a class="selflink" href="#appendix-B" name="appendix-B">Appendix B</a>.  Discussion of Setting the CD Bit</span>

   [<a id="ref-RFC4035" name="ref-RFC4035">RFC4035</a>] may be read as relying on the implicit assumption that
   there is at most one validating system between the stub resolver and
   the authoritative server for a given zone.  It is entirely possible,
   however, for more than one validator to exist between a stub resolver
   and an authoritative server.  If these different validators have
   disjoint trust anchors configured, then it is possible that each
   would be able to validate some portion of the DNS tree, but neither





<span class="grey">Weiler &amp; Blacka              Standards Track                   [Page 16]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-17" id="page-17" name="page-17"> </a>
<span class="grey"><a href="rfc6840.html">RFC 6840</a>               DNSSEC Implementation Notes         February 2013</span>


   is able to validate all of it.  Accordingly, it might be argued that
   it is desirable not to set the CD bit on upstream queries, because
   that allows for maximal validation.

   In <a href="#section-5.9">Section 5.9</a> of this document, it is recommended to set the CD bit
   on an upstream query even when the incoming query arrives with CD=0.
   This is for two reasons: it encourages a more predictable validation
   experience as only one validator is always doing the validation, and
   it ensures that all DNSSEC data that exists may be available from the
   local cache should a query with CD=1 arrive.

   As a matter of policy, it is possible to set the CD bit differently
   than suggested in <a href="#section-5.9">Section 5.9</a>.  A different choice will, of course,
   not always yield the benefits listed above.  It is beyond the scope
   of this document to outline all of the considerations and counter
   considerations for all possible policies.  Nevertheless, it is
   possible to describe three approaches and their underlying philosophy
   of operation.  These are laid out in the tables below.

   The table that describes each model has five columns.  The first
   column indicates the value of the CD bit that the resolver receives
   (for instance, on the name server side in an iterative resolver, or
   as local policy or from the API in the case of a stub).  The second
   column indicates whether the query needs to be forwarded for
   resolution (F) or can be satisfied from a local cache (C).  The third
   column is a line number, so that it can be referred to later in the
   table.  The fourth column indicates any relevant conditions at the
   resolver, for example, whether the resolver has a covering trust
   anchor, and so on.  If there are no parameters here, the column is
   empty.  The fifth and final column indicates what action the resolver
   takes.

   The tables differentiate between "cached data" and "cached RCODE=2".
   This is a shorthand; the point is that one has to treat RCODE=2
   (server failure) as special, because it might indicate a validation
   failure somewhere upstream.  The distinction is really between
   "cached RCODE=2" and "cached everything else".

   The tables are probably easiest to think of in terms of describing
   what happens when a stub resolver sends a query to an intermediate
   resolver, but they are perfectly general and can be applied to any
   validating resolver.

   Model 1: "always set"

   This model is so named because the validating resolver sets the CD
   bit on queries it makes regardless of whether it has a covering trust
   anchor for the query.  The general philosophy represented by this



<span class="grey">Weiler &amp; Blacka              Standards Track                   [Page 17]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-18" id="page-18" name="page-18"> </a>
<span class="grey"><a href="rfc6840.html">RFC 6840</a>               DNSSEC Implementation Notes         February 2013</span>


   table is that only one resolver should be responsible for validation
   irrespective of the possibility that an upstream resolver may be
   present with trust anchors that cover different or additional QNAMEs.
   It is the model recommended in <a href="#section-5.9">Section 5.9</a> of this document.

    CD F/C    line      conditions            action
    ====================================================================
    1   F      A1                             Set CD=1 on upstream query
    0   F      A2                             Set CD=1 on upstream query
    1   C      A3                             Return the cache contents
                                               (data or RCODE=2)
    0   C      A4       no covering TA        Return cache contents
                                               (data or RCODE=2)
    0   C      A5       covering TA           Validate cached result and
                                               return it

   Model 2: "never set when receiving CD=0"

   This model is so named because it sets CD=0 on upstream queries for
   all received CD=0 queries, even if it has a covering trust anchor.
   The general philosophy represented by this table is that more than
   one resolver may take responsibility for validating a QNAME and that
   a validation failure for a QNAME by any resolver in the chain is a
   validation failure for the query.  Using this model is NOT
   RECOMMENDED.

    CD F/C    line       conditions           action
    ====================================================================
    1  F      N1                              Set CD=1 on upstream query
    0  F      N2                              Set CD=0 on upstream query
    1  C      N3         cached data          Return cached data
    1  C      N4         cached RCODE=2       Treat as line N1
    0  C      N5         no covering TA       Return cache contents
                                               (data or RCODE=2)
    0  C      N6         covering TA &amp;        Treat as line N2
                          cached data was
                          generated with CD=1
    0  C      N7         covering TA &amp;        Validate and return
                          cached data was
                          generated with CD=0


   Model 3: "sometimes set"

   This model is so named because it sets the CD bit on upstream queries
   triggered by received CD=0 queries, based on whether the validator
   has a trust anchor configured that covers the query.  If there is no
   covering trust anchor, the resolver clears the CD bit in the upstream



<span class="grey">Weiler &amp; Blacka              Standards Track                   [Page 18]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-19" id="page-19" name="page-19"> </a>
<span class="grey"><a href="rfc6840.html">RFC 6840</a>               DNSSEC Implementation Notes         February 2013</span>


   query.  If there is a covering trust anchor, the resolver sets CD=1
   and performs validation itself.  The general philosophy represented
   by this table is that a resolver should try and validate QNAMEs for
   which it has trust anchors and should not preclude validation by
   other resolvers for QNAMEs for which it does not have covering trust
   anchors.  Using this model is NOT RECOMMENDED.

    CD F/C    line       conditions         action
    ====================================================================
    1  F      S1                            Set CD=1 on upstream query
    0  F      S2         covering TA        Set CD=1 on upstream query
    0  F      S3         no covering TA     Set CD=0 on upstream query
    1  C      S4         cached data        Return cached data
    1  C      S5         cached RCODE=2     Treat as line S1
    0  C      S6         cached data was    Return cache contents
                          generated with
                          CD=0
    0  C      S7         cached data was    Validate &amp; return cache
                          generated with     contents
                          CD=1 &amp;
                          covering TA
    0  C      S8         cached RCODE=2     Return cache contents
    0  C      S9         cached data        Treat as line S3
                          was generated
                          with CD=1 &amp;
                          no covering
                          TA


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/Appendix%20C.%20%20Discussion%20of%20Trust%20Anchor%20Preference%20Options"></a><a class="selflink" href="#appendix-C" name="appendix-C">Appendix C</a>.  Discussion of Trust Anchor Preference Options</span>

   This section presents several different policies for validating
   resolvers to use when they have a choice of trust anchors available
   for validating a given answer.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/C.1.%20%20Closest%20Encloser"></a><a class="selflink" href="#appendix-C.1" name="appendix-C.1">C.1</a>.  Closest Encloser</span>

   One policy is to choose the trust anchor closest to the QNAME of the
   response.  For example, consider a validator configured with trust
   anchors for "example." and "zone.example."  When asked to validate a
   response for "www.sub.zone.example.", a validator using the "Closest
   Encloser" policy would choose the "zone.example." trust anchor.

   This policy has the advantage of allowing the operator to trivially
   override a parent zone's trust anchor with one that the operator can
   validate in a stronger way, perhaps because the resolver operator is





<span class="grey">Weiler &amp; Blacka              Standards Track                   [Page 19]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-20" id="page-20" name="page-20"> </a>
<span class="grey"><a href="rfc6840.html">RFC 6840</a>               DNSSEC Implementation Notes         February 2013</span>


   affiliated with the zone in question.  This policy also minimizes the
   number of public key operations needed, which is of benefit in
   resource-constrained environments.

   This policy has the disadvantage of giving the user some unexpected
   and unnecessary validation failures when sub-zone trust anchors are
   neglected.  As a concrete example, consider a validator that
   configured a trust anchor for "zone.example." in 2009 and one for
   "example." in 2011.  In 2012, "zone.example." rolls its Key Signing
   Key (KSK) and updates its DS records, but the validator operator
   doesn't update its trust anchor.  With the "Closest Encloser" policy,
   the validator gets validation failures.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/C.2.%20%20Accept%20Any%20Success"></a><a class="selflink" href="#appendix-C.2" name="appendix-C.2">C.2</a>.  Accept Any Success</span>

   Another policy is to try all applicable trust anchors until one gives
   a validation result of Secure, in which case the final validation
   result is Secure.  If and only if all applicable trust anchors give a
   result of Insecure, the final validation result is Insecure.  If one
   or more trust anchors lead to a Bogus result and there is no Secure
   result, then the final validation result is Bogus.

   This has the advantage of causing the fewest validation failures,
   which may deliver a better user experience.  If one trust anchor is
   out of date (as in our above example), the user may still be able to
   get a Secure validation result (and see DNS responses).

   This policy has the disadvantage of making the validator subject to
   the compromise of the weakest of these trust anchors, while making it
   relatively painless to keep old trust anchors configured in
   perpetuity.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/C.3.%20%20Preference%20Based%20on%20Source"></a><a class="selflink" href="#appendix-C.3" name="appendix-C.3">C.3</a>.  Preference Based on Source</span>

   When the trust anchors have come from different sources (e.g.,
   automated updates ([<a href="rfc5011.html" title='"Automated Updates of DNS Security (DNSSEC) Trust Anchors"'>RFC5011</a>]), one or more DNSSEC Lookaside
   Validation (DLV) registries ([<a href="rfc5074.html" title='"DNSSEC Lookaside Validation (DLV)"'>RFC5074</a>]), and manual configuration), a
   validator may wish to choose between them based on the perceived
   reliability of those sources.  The order of precedence might be
   exposed as a configuration option.

   For example, a validator might choose to prefer trust anchors found
   in a DLV registry over those manually configured on the theory that
   the manually configured ones will not be as aggressively maintained.







<span class="grey">Weiler &amp; Blacka              Standards Track                   [Page 20]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-21" id="page-21" name="page-21"> </a>
<span class="grey"><a href="rfc6840.html">RFC 6840</a>               DNSSEC Implementation Notes         February 2013</span>


   Conversely, a validator might choose to prefer manually configured
   trust anchors over those obtained from a DLV registry on the theory
   that the manually configured ones have been more carefully
   authenticated.

   Or the validator might do something more complex: prefer a sub-set of
   manually configured trust anchors (based on a configuration option),
   then trust anchors that have been updated using the mechanism in
   [<a href="rfc5011.html" title='"Automated Updates of DNS Security (DNSSEC) Trust Anchors"'>RFC5011</a>], then trust anchors from one DLV registry, then trust
   anchors from a different DLV registry, then the rest of the manually
   configured trust anchors.

Authors' Addresses

   Samuel Weiler (editor)
   SPARTA, Inc.
   7110 Samuel Morse Drive
   Columbia, MD  21046
   US

   EMail: weiler@tislabs.com


   David Blacka (editor)
   Verisign, Inc.
   12061 Bluemont Way
   Reston, VA  20190
   US

   EMail: davidb@verisign.com





















Weiler &amp; Blacka              Standards Track                   [Page 21]

</pre><br/>
    <span class="noprint"><small><small>Html markup produced by rfcmarkup 1.126, available from
      <a href="https://tools.ietf.org/tools/rfcmarkup/">https://tools.ietf.org/tools/rfcmarkup/</a>
    </small></small></span>
  </div>




</body><!-- Mirrored from tools.ietf.org/html/rfc6840 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 06 Mar 2018 23:18:26 GMT --></html>