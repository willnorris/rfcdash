<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml"><!-- Mirrored from tools.ietf.org/html/rfc114 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 06 Mar 2018 23:19:03 GMT --><!-- Added by HTTrack --><head><meta content="text/html;charset=utf-8" http-equiv="content-type"/><!-- /Added by HTTrack -->

    <meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
    <meta content="index,follow" name="robots"/>
    <meta content="rfcmarkup version 1.126" name="creator"/>
    <link href="http://purl.org/dc/elements/1.1/" rel="schema.DC"/>
<meta content="urn:ietf:rfc:114" name="DC.Identifier"/>
<meta content="A.K. Bhushan" name="DC.Creator"/>
<meta content="April, 1971" name="DC.Date.Issued"/>
<meta content="File Transfer Protocol" name="DC.Title"/>

    <link href="https://tools.ietf.org/images/rfc.png" rel="icon" type="image/png"/>
    <link href="https://tools.ietf.org/images/rfc.png" rel="shortcut icon" type="image/png"/>
    <title>RFC 114 - File Transfer Protocol</title>
    
    
    <style type="text/css">
	@media only screen 
	  and (min-width: 992px)
	  and (max-width: 1199px) {
	    body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 768px)
	  and (max-width: 991px) {
            body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 480px)
	  and (max-width: 767px) {
            body { font-size: 11pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (max-width: 479px) {
            body { font-size: 8pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-device-width : 375px) 
	  and (max-device-width : 667px) {
            body { font-size: 9.5pt; }
            div.content { width: 96ex; margin: 0 1px; }
        }
	@media only screen 
	  and (min-device-width: 1200px) {
            body { font-size: 10pt; margin: 0 4em; }
            div.content { width: 96ex; margin: 0; }
        }
        h1, h2, h3, h4, h5, h6, .h1, .h2, .h3, .h4, .h5, .h6 {
	    font-weight: bold;
            line-height: 0pt;
            display: inline;
            white-space: pre;
            font-family: monospace;
            font-size: 1em;
	    font-weight: bold;
        }
        pre {
            font-size: 1em;
            margin-top: 0px;
            margin-bottom: 0px;
        }
	.pre {
	    white-space: pre;
	    font-family: monospace;
	}
	.header{
	    font-weight: bold;
	}
        .newpage {
            page-break-before: always;
        }
        .invisible {
            text-decoration: none;
            color: white;
        }
        a.selflink {
          color: black;
          text-decoration: none;
        }
        @media print {
            body {
                font-family: monospace;
                font-size: 10.5pt;
            }
            h1, h2, h3, h4, h5, h6 {
                font-size: 1em;
            }
        
            a:link, a:visited {
                color: inherit;
                text-decoration: none;
            }
            .noprint {
                display: none;
            }
        }
	@media screen {
	    .grey, .grey a:link, .grey a:visited {
		color: #777;
	    }
            .docinfo {
                background-color: #EEE;
            }
            .top {
                border-top: 7px solid #EEE;
            }
            .bgwhite  { background-color: white; }
            .bgred    { background-color: #F44; }
            .bggrey   { background-color: #666; }
            .bgbrown  { background-color: #840; }            
            .bgorange { background-color: #FA0; }
            .bgyellow { background-color: #EE0; }
            .bgmagenta{ background-color: #F4F; }
            .bgblue   { background-color: #66F; }
            .bgcyan   { background-color: #4DD; }
            .bggreen  { background-color: #4F4; }

            .legend   { font-size: 90%; }
            .cplate   { font-size: 70%; border: solid grey 1px; }
	}
    </style>
    <!--[if IE]>
    <style>
    body {
       font-size: 13px;
       margin: 10px 10px;
    }
    </style>
    <![endif]-->

    <script type="text/javascript"><!--
    function addHeaderTags() {
	var spans = document.getElementsByTagName("span");
	for (var i=0; i < spans.length; i++) {
	    var elem = spans[i];
	    if (elem) {
		var level = elem.getAttribute("class");
                if (level == "h1" || level == "h2" || level == "h3" || level == "h4" || level == "h5" || level == "h6") {
                    elem.innerHTML = "<"+level+">"+elem.innerHTML+"</"+level+">";		
                }
	    }
	}
    }
    var legend_html = "Colour legend:<br />      <table>         <tr><td>Unknown:</td>                   <td><span class='cplate bgwhite'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft:</td>                     <td><span class='cplate bgred'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Informational:</td>             <td><span class='cplate bgorange'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Experimental:</td>              <td><span class='cplate bgyellow'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Best Common Practice:</td>      <td><span class='cplate bgmagenta'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Proposed Standard:</td>         <td><span class='cplate bgblue'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft Standard (old designation):</td> <td><span class='cplate bgcyan'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Internet Standard:</td>         <td><span class='cplate bggreen'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Historic:</td>                  <td><span class='cplate bggrey'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Obsolete:</td>                  <td><span class='cplate bgbrown'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>     </table>";
    function showElem(id) {
        var elem = document.getElementById(id);
        elem.innerHTML = eval(id+"_html");
        elem.style.visibility='visible';
    }
    function hideElem(id) {
        var elem = document.getElementById(id);
        elem.style.visibility='hidden';        
        elem.innerHTML = "";
    }
    // -->
    </script>
</head>
<body onload="addHeaderTags()">
  <div class="content">
   <div style="height: 13px;">
      <div class="pre noprint docinfo bgwhite" onclick="showElem('legend');" onmouseout="hideElem('legend')" onmouseover="this.style.cursor='pointer';" style="height: 6px; position: absolute;" title="Click for colour legend.">                                                                        </div>
      <div class="docinfo noprint pre legend" id="legend" onmouseout="hideElem('legend');" onmouseover="showElem('legend');" style="position:absolute; top: 4px; left: 4ex; visibility:hidden; background-color: white; padding: 4px 9px 5px 7px; border: solid #345 1px; ">
      </div>
   </div>
<span class="pre noprint docinfo top">[<a href="index.html" title="Document search and retrieval page">Docs</a>] [<a href="https://tools.ietf.org/rfc/rfc114.txt" title="Plaintext version of this document">txt</a>|<a href="https://tools.ietf.org/pdf/rfc114" title="PDF version of this document">pdf</a>] [<a href="https://datatracker.ietf.org/doc/rfc114" title="IESG Datatracker information for this document">Tracker</a>]                                              </span><br/>
<span class="pre noprint docinfo">                                                                        </span><br/>
<span class="pre noprint docinfo">Updated by: <a href="rfc133.html">133</a>, <a href="rfc141.html">141</a>, <a href="rfc171.html">171</a>, <a href="rfc172.html">172</a>                                      </span><br/>
<span class="pre noprint docinfo">                                                                        </span><br/>
<pre>Network Working Group                                         A. Bhushan
Request for Comments: 114                                MIT Project MAC
NIC: 5823                                                  16 April 1971


                        <span class="h1">A FILE TRANSFER PROTOCOL</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/I.%20Introduction"></a><a class="selflink" href="#appendix-I" name="appendix-I">I</a>. Introduction</span>

   Computer network usage may be divided into two broad categories --
   direct and indirect.  Direct usage implies that you, the network
   user, are "logged" into a remote host and use it as a local user.
   You interact with the remote system via a terminal (teletypewriter,
   graphics console) or a computer.  Differences in terminal
   characteristics are handled by host system programs, in accordance
   with standard protocols (such as TELNET (<a href="rfc97.html">RFC 97</a>) for teletypewriter
   communications, NETRJS (<a href="rfc88.html">RFC 88</a>) for remote job entry).  You, however,
   have to know the different conventions of remote systems, in order to
   use them.

   Indirect usage, by contrast, does not require that you explicitly log
   into a remote system or even know how to "use" the remote system.  An
   intermediate process makes most of the differences in commands and
   conventions invisible to you.  For example, you need only know a
   standard set of network file transfer commands for your local system
   in order to utilize remote file system.  This assumes the existence
   of a network file transfer process at each host cooperating via a
   common protocol.

   Indirect use is not limited to file transfers.  It may include
   execution of programs in remote hosts and the transfer of core
   images.  The extended file transfer protocol would facilitate the
   exchange of programs and data between computers, the use of storage
   and file handling capabilities of other computers (possibly including
   the trillion-bit store data computer), and have programs in remote
   hosts operate on your input and return an output.

   The protocol described herein has been developed for immediate
   implementation on two hosts at MIT, the GE645/Multics and the PDP-
   10/DM/CG-ITS (and possibly Harvard's PDP-10).  An interim version
   with limited capabilities is currently in the debugging stage. [<a href="#ref-1" title="limited to transfer of ASCII files">1</a>]
   Since our implementation involves two dissimilar systems (Multics is
   a "service" system, ITS is not) with different file systems (Multics
   provides elaborate access controls, ITS provides none), we feel that
   the file transfer mechanisms proposed are generalizable.  In
   addition, our specification reflects a consideration of other file
   systems on the network.  We conducted a survey [<a href="#ref-2">2</a>] of network host



<span class="grey">Bhushan                                                         [Page 1]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-2" id="page-2" name="page-2"> </a>
<span class="grey"><a href="rfc114.html">RFC 114</a>                 A FILE TRANSFER PROTOCOL           16 April 1971</span>


   systems to determine the requirements and capabilities.  This paper
   is a "first cut" at a protocol that will allow users at any host on
   the network to use the file system of every cooperating host.

II.  Discussion

   A few definitions are in order before the discussion of the protocol.
   A file is an ordered set consisting of computer instructions and/or
   data.  A file can be of arbitrary length [<a href="#ref-3">3</a>].  A named file is
   uniquely identified in a system by its file name and directory name.
   The directory name may be the name of a physical directory or it may
   be the name of a physical device.  An example of physical directory
   name is owner's project-programmer number and an example of physical
   device name is tape number.

   A file may or may not have access controls associated with it.  The
   access controls designate the users' access privileges.  In the
   absence of access controls, the files cannot be protected from
   accidental or unauthorized usage.

   A principal objective of the protocol is to promote the indirect use
   of computers on the network.  Therefore, the user or his program
   should have a simple and uniform interface to the file systems on the
   network and be shielded from the variations in file and storage
   systems of different host computers.  This is achieved by the
   existence of a standard protocol in each host.

   Criteria by which a user-level protocol may be judged were described
   by Mealy in <a href="rfc91.html">RFC 91</a>, as involving the notion of logical records,
   ability to access files without program modifications, and
   implementability.  I would add to these efficiency, extendibility,
   adaptability, and provision of error-recovery mechanisms.

   The attempt in this specification has been to enable the reliable
   transfer of network ASCII (7-bit ASCII in 8-bit field with leftmost
   bit zero) as well as "binary" data files with relative ease.  The use
   of other character codes, such as EBCDIC, and variously formatted
   data (decimal, octal, ASCII characters packed differently) is
   facilitated by inclusion of data type in descriptor headings.  An
   alternative mechanism for defining data is also available in the form
   of attributes in file headings.  The format control characters
   reserved for the syntax of this protocol have identical code
   representation in ASCII and EBCDIC.  (These character are SOH, STX,
   ETX, DC1, DC2, DC3, US, RS, GS, and FS.)







<span class="grey">Bhushan                                                         [Page 2]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-3" id="page-3" name="page-3"> </a>
<span class="grey"><a href="rfc114.html">RFC 114</a>                 A FILE TRANSFER PROTOCOL           16 April 1971</span>


   The notion of messages (the physical blocks of data communicated
   between NCP's) is suppressed herein and that of "logical" records and
   transactions is emphasized.  The data passed by the NCP is parsed
   into logical blocks by use of simple descriptors (code and count
   mechanisms) as described in Section III.  The alternative to count is
   fixed length blocks or standard end-of-file characters (scan data
   stream).  Both seem less desirable than count.

   The cooperating processes may be "daemon" processes which "listen" to
   agreed-upon sockets, and follow the initial connection protocol much
   in the same way as a "logger" does.  We recommend using a single
   full-duplex connection for the exchange of both data and control
   information [<a href="#ref-4" title="one for control information">4</a>], and using CLS to achieve synchronization when
   necessary (a CLS is not transmitted until a RFNM is received).

   The user may be identified by having the using process send at the
   start of the connection the user's name information (either passed on
   by user or known to the using system) [<a href="#ref-5" title=" as unique user identification numbers have not been implemented">5</a>].  This user name
   information (a sequence of standard ASCII characters), along with the
   host number (known to the NCP), positively identifies the user to the
   serving process.

   At present, more elaborate access control mechanisms, such as
   passwords, are not suggested.  The user, however, will have the
   security and protection provided by the serving system.  The serving
   host, if it has access controls, can prevent unprivileged access by
   users from other host sites.  It is up to the using host to prevent
   its own users from violating access rules.

   The files in a file system are identified by a pathname, similar to
   the labels described in <a href="rfc76.html">RFC 76</a> (Bouknight, Madden, and Grossman).
   The pathname contains the essential information regarding the storage
   and retrieval of data.

   In order to facilitate use, default options should be provided.  For
   example, the main file directory on disk would be the default on the
   PDP-10/ITS, and a pool directory would be the default on Multics.

   The file to be transferred may be a complete file or may consist of
   smaller records.  It may or may not have a heading.  A heading should
   contain ASCII or EBCDIC characters defining file attributes.  The
   file attributes could be some simple agreed-upon types or they could
   be described in a data reconfiguration or interpretation language
   similar to that described in <a href="rfc83.html">RFC 83</a> (Anderson, Haslern, and Heffner),
   or a combination.






<span class="grey">Bhushan                                                         [Page 3]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-4" id="page-4" name="page-4"> </a>
<span class="grey"><a href="rfc114.html">RFC 114</a>                 A FILE TRANSFER PROTOCOL           16 April 1971</span>


   The protocol does not restrict the nature of data in the file.  For
   example, a file could contain ASCII text, binary core image, graphics
   data or any other type of data.  The protocol includes an "execute"
   request for files that are programs.  This is intended to facilitate
   the execution of programs and subroutines in remote host computers
   [<a href="#ref-6">6</a>].

III.  SPECIFICATIONS

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/1.%20Transactions"></a><a class="selflink" href="#section-1" name="section-1">1</a>. Transactions</span>

   1A.   The protocol is transaction-oriented.  A transaction is defined
         to be an entity of information communicated between cooperating
         processes.

   1B.   Syntax

         A transaction has three fields, a 72-bit descriptor field and
         variable length (including zero) data and filler fields, as
         shown below.  The total length of a transaction is (72 + data +
         filler) bits.

   | &lt;code&gt;&lt;filler count&gt;&lt;NUL&gt;&lt;data count&gt;&lt;NUL&gt; |    &lt;data&gt;&lt;filler&gt;   |
   | |____||____________||___||__________||___| |    |____________|   |
   |   |         |         |        |       |   |          |          |
   | 24-bits   8-bits    8-bits  24-bits  8-bits|    variable length  |
   | &lt;-------descriptor field 72-bits---------&gt; |&lt;--data and filler--&gt;|
   |                                            |                     |

   1C.   Semantics

         The code field has three 8-bit bytes.  The first byte is
         interpreted as transaction type, the second byte as data type
         and the third byte as extension of data type.

         The filler count is a binary count of bits used as "filler"
         (i.e., not information) at the end of a transaction [<a href="#ref-7">7</a>].  As
         the length of the filler count field is 8-bits, the number of
         bits of filler shall not exceed 255 bits.

         The data count is a binary count of the number of data (i.e.,
         information) bits in the data field, not including filler bits.
         The number of data bits is limited to (2^24-1), as there are 24
         bits in the data count field.







<span class="grey">Bhushan                                                         [Page 4]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-5" id="page-5" name="page-5"> </a>
<span class="grey"><a href="rfc114.html">RFC 114</a>                 A FILE TRANSFER PROTOCOL           16 April 1971</span>


         The NUL bytes are inserted primarily as fillers in the
         descriptor field and allow the count information to appear at
         convenient word boundaries for different word length machines
         [<a href="#ref-8" title="24 and 30">8</a>].

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/2.%20%20Transaction%20Types"></a><a class="selflink" href="#section-2" name="section-2">2</a>.  Transaction Types</span>

   2A.   A transaction may be of the following four basic types:
         request, response, transfer and terminate.  Although large
         number of request and transfer types are defined,
         implementation of a subset is specifically permitted.  Host
         computers, on which a particular transaction type is not
         implemented, may refuse to accept that transaction by
         responding with an unsuccessful terminate.

         The following transaction type codes are tentatively defined:

         Transaction Type                       Transaction Type Code

                                             ASCII   Octal   Hexidecimal

         Request
                 Identify                        I       111     49
                 Retrieve                        R       122     52
                 Store                           S       123     53
                 Append                          A       101     41
                 Delete                          D       104     44
                 Rename                          N       116     4E
                 addname (Plus)                  P       120     50
                 deletename (Minus)              M       115     4D
                 Lookup                          L       114     4C
                 Open                            O       117     4F
                 Close                           C       103     43
                 Execute [<a href="#ref-9">9</a>]                     E       105     45

         Response
                 ready-to-receive (rr)           &lt;       074     3C
                 ready-to-send (rs)              &gt;       076     3E

         Transfer
                 complete_file                   *       052
                 heading                         #       043     23
                 part_of_file                    '       054     2C
                 last_part                       .       056     2E

         Terminate
                 successful (pos.)               +       053     2B
                 unsuccessful (neg.)             -       055     2D



<span class="grey">Bhushan                                                         [Page 5]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-6" id="page-6" name="page-6"> </a>
<span class="grey"><a href="rfc114.html">RFC 114</a>                 A FILE TRANSFER PROTOCOL           16 April 1971</span>


   2B.   Syntax

         In the following discussion US, RS, GS, FS, DC1, DC2, and DC3
         are the ASCII characters, unit separator (octal 037), record
         separator (octal 036), group separator (octal 035), file
         separator (octal 034), device control 1 (octal 021), device
         control 2 (octal 022), and device control 3 (octal 023),
         respectively.  These have an identical interpretation in
         EBCDIC.

   2B.1  Requests

         Identify, retrieve, store, append, delete, open, lookup and
         execute requests have the following data field:

                       &lt;path name&gt;

                Rename request has the data field:

                       &lt;path name&gt; GS &lt;name&gt;

                Addname and deletename requests have the data field:

                       &lt;path name&gt; GS &lt;filenames&gt;

         where pathname [<a href="#ref-10">10</a>], name and filenames have the following
         syntax (expressed in BNF, the metalanguage of the ALGOL 60
         report):

         &lt;pathname&gt; ::= &lt;device name&gt;|&lt;name&gt;|&lt;pathname&gt;US&lt;name&gt;
         &lt;device name&gt; ::= DC1&lt;name&gt;

         &lt;name&gt; ::= &lt;char&gt; | &lt;name&gt; &lt;char&gt;
         &lt;char&gt; ::= All 8-bit ASCII or EBCDIC characters except

                 US, RS, GS, FS, DC1, DC2, AND DC3.

         &lt;filenames&gt; ::= &lt;name&gt;|&lt;filenames&gt; RS &lt;name&gt;

         The data type for the request transaction shall be either A
         (octal 101 for ASCII, or E (octal 105) for EBCDIC [<a href="#ref-11" title="however">11</a>].

         Some examples of pathname are:

         DC1 MT08
         DC1 DSK 1.2 US Net&lt;3&gt; US J.Doe US Foo
         udd US proj. US h,n/x US user US file
         filename 1 filename 2



<span class="grey">Bhushan                                                         [Page 6]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-7" id="page-7" name="page-7"> </a>
<span class="grey"><a href="rfc114.html">RFC 114</a>                 A FILE TRANSFER PROTOCOL           16 April 1971</span>


   2B.2  Responses

         The response transactions shall normally have an empty data
         field.

   2B.3  Transfers

         The data types defined in <a href="#section-4">section 4</a> will govern the syntax of
         the data field in transfer transactions.  No other syntactical
         restrictions exist.

   2B.4  Terminates

         The successful terminate shall normally have an empty data
         field.  The unsuccessful terminate may have a data field
         defined by the data types A (octal 101) for ASCII, E (octal
         105) for EBCDIC, or S (octal 123) for status.

         A data type code of 'S' would imply byte oriented error return
         status codes in the data field.  The following error return
         status codes are defined tentatively:

         Error Code Meaning                        Error Code
                                             ASCII   Octal  Hexadecimal

         Undefined error                       U       125     55
         Transaction type error                T       124     54
         Syntax error                          S       123     53
         File search failed                    F       106     46
         Data type error                       D       104     44
         Access denied                         A       101     41
         Improper transaction sequence         I       111     49
         Time-out error                        O       117     4F
         Error condition by system             E       105     45

   2C.   Semantics

   2C.1  Requests

         Requests are always sent by using host.  In absence of a device
         name or complete pathname, default options should be provided
         for all types of requests.

         _Identify_ request identifies the user as indicated by
         &lt;pathname&gt; from serving to using host.

         _Retrieve_ request achieves the transfer of file specified in
         &lt;pathname&gt; from serving to using host.



<span class="grey">Bhushan                                                         [Page 7]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-8" id="page-8" name="page-8"> </a>
<span class="grey"><a href="rfc114.html">RFC 114</a>                 A FILE TRANSFER PROTOCOL           16 April 1971</span>


         _Store_  request achieves the transfer of file specified in
         &lt;pathname&gt; from using to serving host.

         _Append_ request causes data to be added to file specified in
         pathname.

         _Rename_ request causes name of file specified in &lt;pathname&gt; to
         be replaced by name specified in &lt;name&gt;.

         _Delete_ request causes file specified in &lt;pathname&gt; to be
         deleted.  If an extra level of protection for delete is desired
         (such as the query 'Do you wish to delete file x?'), it is to
         be a local implementation option.

         _Addname_ and _deletename_ requests cause names in &lt;filenames&gt;
         to be added or deleted to existing names of file specified in
         &lt;pathname&gt;.  These requests are useful in systems such as
         Multics which allow multiple names to be associated with a
         file.

         _Lookup_ request achieves the transfer of attributes (such as
         date last modified, access list, etc) of file specified in
         &lt;pathname&gt;, instead of the file itself.

         _Open_ request does not cause a data transfer, instead file
         specified in &lt;pathname&gt; is "opened" for retrieve (read) or
         store (write).  Subsequent requests are then treated as
         requests pertaining to the file that is opened till such a time
         that a close request is received.

         _Execute_ request achieves the execution of file specified in
         &lt;pathname&gt;, which must be an executable program.  Upon receipt
         of rr response, using host will transmit the necessary input
         data (parameters, arguments, etc).  Upon completion of
         execution serving host will send the results to using host and
         terminate [<a href="#ref-12">12</a>].

   2C.2  Response

         Responses are always sent by serving host.  The rr response
         indicates that serving host is ready to receive the file
         indicated in the preceding request.  The rs response indicates
         that the next transaction from serving host will be the
         transfer of file indicated in the preceding request.







<span class="grey">Bhushan                                                         [Page 8]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-9" id="page-9" name="page-9"> </a>
<span class="grey"><a href="rfc114.html">RFC 114</a>                 A FILE TRANSFER PROTOCOL           16 April 1971</span>


   2C.3  Transfers

         Transfers may be sent by either host.  Transfer transactions
         indicate the transfer of file indicated by a request.  Files
         can be transferred either as complete_file transactions or as
         part_of_file transactions followed by last_part transactions.
         The file may also have a heading transaction in the beginning.
         The syntax of a file, therefore, may be defined as:

         &lt;file&gt; ::= &lt;text&gt; | &lt;heading&gt; &lt;text&gt;
         &lt;text&gt; ::= &lt;complete_file&gt; | &lt;parts&gt; &lt;last_part&gt;
         &lt;parts&gt; ::= &lt;part_of_file&gt; | &lt;parts&gt; &lt;part_of_file&gt;

         Headings may be used to communicate the attributes of files.
         The form of headings is not formally specified but is discussed
         in Section IV as possible extension to this protocol.

   2C.4  Terminates

         The successful terminate is always sent by serving host.  It
         indicates to using host that serving host has been successful
         in serving the request and has gone to an initial state.  Using
         host will then inform user that his request is successfully
         served, and go to an initial state.

         The unsuccessful terminate may be sent by either host.  It
         indicates that sender of the terminate is unable to (or does
         not not wish to) go through with the request.  Both hosts will
         then go to their initial states.  The using host will inform
         the user that his request was aborted.  If any reasons for the
         unsuccessful terminate (either as text or as error return
         status codes) are received, these shall be communicated to the
         user.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/3.%20%20%20%20Transaction%20Sequence"></a><a class="selflink" href="#section-3" name="section-3">3</a>.    Transaction Sequence</span>

   3A.   The transaction sequence may be defined as an instance of file
         transfer, initiated by a request and ended by a terminate [<a href="#ref-13" title='"echoed"'>13</a>].
         The exact sequence in which transactions occur depends on the
         type of request.  A transaction sequence may be aborted anytime
         by either host, as explained in <a href="#section-3">Section 3</a>C.

   3B.   Examples

         The identify request doesn't require a response or terminate
         and constitutes a transaction sequence by itself.





<span class="grey">Bhushan                                                         [Page 9]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-10" id="page-10" name="page-10"> </a>
<span class="grey"><a href="rfc114.html">RFC 114</a>                 A FILE TRANSFER PROTOCOL           16 April 1971</span>


         Rename, delete, addname, deletename and open requests involve
         no data transfer but require terminates.  The user sends the
         request and the server sends a successful or an unsuccessful
         terminate depending on whether or not he is successful in
         complying with the request.

         Retrieve and Lookup requests involve data transfer from the
         server to the user.  The user sends the request, the server
         responds with a rs, and transfers the data specified by the
         request.  Upon completion of the data transfer, the server
         terminates the transaction sequence with a successful terminate
         if all goes well, or with an unsuccessful terminate is errors
         were detected.

         Store and Append requests involve data transfer from the user
         to server.  The user sends the request and the server responds
         with a rr.  The user then transfers the data.  Upon receiving
         the data, the server terminates the sequence.

         Execute request involves transfer of inputs from user to
         server, and transfer of outputs from server to user.  The user
         sends the request to which the server responds with rr.  The
         user then transfers the necessary inputs.  The server
         "executes" the program or subroutine and transfers the outputs
         to the user.  Upon completion of the output transfer, the
         server terminates the transaction sequence.

   3C.   Aborts

         Either host may abort the transaction sequence at any time by
         sending an unsuccessful terminate, or by closing the connection
         (NCP to transmit a CLS for the connection).  The CLS is a more
         drastic type of abort and shall be used when there is a
         catastrophic failure or when an abort is desired in the middle
         of a long file transfer.  The abort indicates to the receiving
         host that the other host wishes to terminate the transaction
         sequence and is now in the initial state.  When CLS is used to
         abort, the using host will reopen the connection.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/4.%20%20%20%20Data%20Types"></a><a class="selflink" href="#section-4" name="section-4">4</a>.    Data Types</span>

   4A.   The data type code together with the extension code defines the
         manner in which the data field is to be parsed and interpreted
         [<a href="#ref-14">14</a>].  Although a large number of data types are defined,
         specific implementations may handle only a limited subset of
         data types.  It is recommended that all host sites accept the





<span class="grey">Bhushan                                                        [Page 10]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-11" id="page-11" name="page-11"> </a>
<span class="grey"><a href="rfc114.html">RFC 114</a>                 A FILE TRANSFER PROTOCOL           16 April 1971</span>


         "network ASCII" and "binary" data types.  Host computers which
         do not "recognize" particular data types may abort the
         transaction sequence and return a data type error status code.

   4B.   The following data types are tentatively defined.  The code in
         the type and extension field is represented by its ASCII
         equivalent with 8th bit as zero.












































<span class="grey">Bhushan                                                        [Page 11]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-12" id="page-12" name="page-12"> </a>
<span class="grey"><a href="rfc114.html">RFC 114</a>                 A FILE TRANSFER PROTOCOL           16 April 1971</span>


        Data Type                                    Code
                                     Byte Size       Type     Extension
ASCII character, bit8=0 (network)       8             A          NUL

ASCII characters, bit8=1                8             A          1

ASCII characters, bit8=even parity      8             A          E

ASCII characters, bit8=odd parity       8             A          O

ASCII characters, 8th bit info.         8             A          8

ASCII characters, 7 bits                7             A          7

ASCII characters, in 9-bit field        9             A          9
ASCII formatted files (with SOH,
        STX, ETX, etc.)                 8             A          F
DEC-packed ASCII (5 7-bit char.,
        36th bit 1 or 0)                36            A          D
EBCDIC characters                       8             E         NUL
SIXBIT characters                       6             S         NUL
Binary data                             1             B         NUL
Binary bytes (size is binary ext.)      1-255         B        (any)
Decimal numbers, net ASCII              8             D          A
Decimal numbers, EBCDIC                 8             D          E
Decimal numbers, sixbit                 6             D          S
Decimal numbers, BCD (binary coded)     4             D          B
Octal numbers, net. ASCII               8             O          A
Octal numbers, EBCDIC                   8             O          E
Octal numbers, SIXBIT                   6             O          S
Hexadecimal numbers, net. ASCII         8             H          A
Hexadecimal numbers, EBCDIC             8             H          E
Hexadecimal numbers, SIXBIT             6             H          S
Unsigned integers, binary (ext.
        field is byte size)             1-225         U        (any)
Sign magnitude integers (field is
        binary size)                    1-255         I        (any)
2's complement integers (ext.
        field is byte size)             1-255         2        (any)
1's complement integers (ext.
        field is byte size)             1-255         1        (any)
Floating point (IBM360)                 32            F          I
Floating point (PDP-10)                 36            F          D
Status codes                            8             S         NUL







<span class="grey">Bhushan                                                        [Page 12]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-13" id="page-13" name="page-13"> </a>
<span class="grey"><a href="rfc114.html">RFC 114</a>                 A FILE TRANSFER PROTOCOL           16 April 1971</span>


   4C.   The data type information is intended to be interpretive.  If a
         host accepts a data type, it can interpret it to a form suited
         to its internal representation of characters or numbers [<a href="#ref-15" title=" five per word with 36th bit as don't care">15</a>].
         Specifically when no conversion is to be performed, the data
         type used will be binary.  The implicit or explicit byte size
         is useful as it facilitates storing of data.  For example, if a
         PDP-10 receives data types A, A1, AE, or A7, it can store the
         ASCII characters five to a word (DEC-packed ASCII).  If the
         datatype is A8 or A9, it would store the characters four to a
         word.  Sixbit characters would be stored six to a word.  If
         conversion routines are available on a system, the use of
         system program could convert the data from one form to another
         (such as EBCDIC to ASCII, IBM floating point to DEC floating
         point, Decimal ASCII to integers, etc.).

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/5.%20Initial%20Connection%2C%20CLS%2C%20and%20Identifying%20Users"></a><a class="selflink" href="#section-5" name="section-5">5</a>. Initial Connection, CLS, and Identifying Users</span>

   5A.   There will be a prearranged socket number [<a href="#ref-16">16</a>] for the
         cooperating process on the serving host.  The connection
         establishment will be in accordance with the initial connection
         protocol of <a href="rfc66.html">RFC 66</a> as modified by <a href="rfc80.html">RFC 80</a>.  The NCP dialog would
         be:

              user to server:    RTS&lt;us&gt;&lt;3&gt;&lt;p&gt;

         if accepted, server to user:    STR&lt;3&gt;&lt;us&gt;&lt;CLS&gt;&lt;3&gt;&lt;us&gt;
              server to user on link p:  &lt;ss&gt;
              server to user:    STR&lt;ss+1&gt;&lt;us&gt;RTS&lt;ss&gt;&lt;us+1&gt;&lt;q&gt;
              user to server:    STR&lt;us&gt;&lt;ss+1&gt;RTS&lt;us+1&gt;&lt;ss&gt;&lt;r&gt;

         This sets up a full-duplex connection between user and server
         processes, with server receiving through local socket ss from
         remote socket us+1 via link q, and sending to remote socket us
         through local socket ss+1 via link r.

   5B.   The connection will be broken by trading a CLS between the
         NCP'S for each of the two connections.  Normally the user will
         initiate the CLS.

         CLS may also be used by either the user or the server to abort
         a data transmission in the middle.  If a CLS is received in the
         middle of a transaction sequence, the whole transaction
         sequence will be aborted.  The using host will then reopen the
         connection.

   5C.   The first transaction from the user to server will be the
         identify transaction.  The users will be identified by the
         pathname in data field of the transaction which should be a



<span class="grey">Bhushan                                                        [Page 13]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-14" id="page-14" name="page-14"> </a>
<span class="grey"><a href="rfc114.html">RFC 114</a>                 A FILE TRANSFER PROTOCOL           16 April 1971</span>


         form acceptable to the server.  The server is at liberty to
         truncate pathnames for its own use.  Since the identify
         transaction does not require a response or terminate, the user
         can proceed directly with other requests.

IV.  Extensions to Protocol

   The protocol specified above has been designed to be extendable.  The
   obvious extensions would be in the area of transaction types (new
   types of requests), error return status words, and data types.  Some
   of the non-obvious extensions, that I can visualize are provisions of
   access control mechanisms, developing a uniform way of specifying
   file attributes in headings of files, increasing the scope of the
   execute command to include subroutine mediation, and the provision of
   transaction sequence identification numbers to facilitate handling of
   multiple requests over the same connection pair.

   Users of protected file systems should be able to have a reasonable
   degree of confidence in the ability of the serving process to
   identify remote users correctly.  In the absence of such confidence,
   some users would not be willing to give access to the serving process
   (especially write access).  Inclusion of access control mechanisms
   such as passwords, is likely to enhance the indirect use of network
   by users who are concerned about privacy and security.  A simple
   extension to the protocol would be to have the serving host sent a
   transaction type "password?" after it receives user name.  Upon
   receipt of "password?" the using host will transmit the password,
   which when successfully acknowledged, would indicate to the user that
   requests may proceed.

   There are a number of file attributes which properly belong in the
   heading of a file rather than the file itself or the data type in
   descriptors of transactions.  Such attributes include access control
   lists, date file was last modified, information about the nature of
   file, and description of its contents in a data description or data
   reconfiguration language.  Some uniformity in the way file attributes
   are specified would be useful.  Until then, the interpretation of the
   heading would be up to the user or the using process.  For example,
   the heading of files which are input to a data reconfiguration (form)
   machine may be the desired transformations expressed in the
   reconfiguration language.

   The "execute" command which achieves the execution of programs
   resident in remote hosts is a vital part of indirect use of remote
   hosts.  The present scope of the execute command, as outlined in the
   specifications, is somewhat limited.  It assumes that the user or





<span class="grey">Bhushan                                                        [Page 14]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-15" id="page-15" name="page-15"> </a>
<span class="grey"><a href="rfc114.html">RFC 114</a>                 A FILE TRANSFER PROTOCOL           16 April 1971</span>


   using process is aware of the manner in which the arguments and
   results should be exchanged.  One could broaden the scope of the
   execute command by introducing a program mediation protocol [<a href="#ref-17">17</a>].

   The present specification of the protocol does not allow the
   simultaneous transfer and processing of multiple requests over the
   same pair of connections.  If such a capability is desired, there is
   an easy way to implement it which only involves a minor change.  A
   transaction sequence identification number (TSid) could replace a NUL
   field in the descriptor of transactions.  The TSid would facilitate
   the coordination of transactions, related to a particular transaction
   sequence.  The 256 code combinations permitted by the TSid would be
   used in a round-robin manner (I can't see more than 256 outstanding
   requests between two user-processes in any practical implementation).
   An alternate way of simultaneous processing of requests is to open
   new pairs of connection.  I am not sure as to how useful simultaneous
   processing of requests is, and which of the two is a more reasonable
   approach.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/V.%20Conclusions"></a><a class="selflink" href="#appendix-V" name="appendix-V">V</a>. Conclusions</span>

   I tried to present a user-level protocol that will permit users and
   using programs to make indirect use of remote host computers.  The
   protocol facilitates not only file system operations but also program
   execution in remote hosts.  This is achieved by defining requests
   which are handled by cooperating processes.  The transaction sequence
   orientation provides greater assurance and would facilitate error
   control.  The notion of data types is introduced to facilitate the
   interpretation, reconfiguration and storage of simple and limited
   forms of data at individual host sites.  The protocol is readily
   extendible.

Endnotes

   [<a id="ref-1" name="ref-1">1</a>] The interim version of the protocol, limited to transfer of ASCII
   files, was developed by Chander Ramchandani and Howard Brodie of
   Project MAC.  The ideas of transactions, descriptors, error recovery,
   aborts, file headings and attributes, execution of programs, and use
   of data types, pathnames, and default mechanisms are new here.
   Howard Brodie and Neal Ryan have coded the interim protocol in the
   PDP-10 and the 645, respectively.

   [<a id="ref-2" name="ref-2">2</a>] The network system survey was conducted last fall by Howard
   Brodie of Project MAC, primarily by telephone.

   [<a id="ref-3" name="ref-3">3</a>] PDP-10 Reference Handbook, page 306.





<span class="grey">Bhushan                                                        [Page 15]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-16" id="page-16" name="page-16"> </a>
<span class="grey"><a href="rfc114.html">RFC 114</a>                 A FILE TRANSFER PROTOCOL           16 April 1971</span>


   [<a id="ref-4" name="ref-4">4</a>] We considered using two full-duplex links, one for control
   information, the other for data.  The use of a separate control link
   between the cooperating processes would simplify aborts, error
   recoveries and synchronization.  The synchronization function may
   alternatively be performed by closing the connection (in the middle
   of a transaction sequence) and reopening it with an abort message.
   (The use of INR and INS transmitted via the NCP control link has
   problems as mentioned by Kalin in <a href="rfc103.html">RFC 103</a>.)  We prefer the latter
   approach.

   [<a id="ref-5" name="ref-5">5</a>] Identifying users through use of socket numbers is not practical,
   as unique user identification numbers have not been implemented, and
   file systems identify users by name, not number.

   [<a id="ref-6" name="ref-6">6</a>] This subject is considered in detail by Bob Metcalfe in a
   forthcoming paper.

   [<a id="ref-7" name="ref-7">7</a>] Filler bits may be necessary as particular implementations of
   NCP's may not allow the free communication of bits.  Instead the
   NCP's may only accept bytes, as suggested in <a href="rfc102.html">RFC 102</a>.  The filler
   count is needed to determine the boundary between transactions.

   [<a id="ref-8" name="ref-8">8</a>] 72-bits in descriptor field are convenient as 72 is the least
   common multiple of 6, 8, 9, 18, 24 and 30, the commonly encountered
   byte sizes on the ARPA network host computers.

   [<a id="ref-9" name="ref-9">9</a>] The execute request is intended to facilitate the indirect
   execution of programs and subroutines.  However, this request in its
   present form may have only limited use.  A subroutine or program
   mediation protocol would be required for broader use of the execute
   feature.  Metcalfe considers this problem in a forthcoming paper.

   [<a id="ref-10" name="ref-10">10</a>] The pathname idea used in Multics is similar to that of labels
   in <a href="rfc76.html">RFC 76</a> by Bouknight, Madden and Grossman.

   [<a id="ref-11" name="ref-11">11</a>] We, however, urge the use of standard network ASCII.

   [<a id="ref-12" name="ref-12">12</a>] The exact manner in which the input and output are transmitted
   would depend on specific mediation conventions.  Names of input and
   output files may be transmitted instead of data itself.

   [<a id="ref-13" name="ref-13">13</a>] The transactions (including terminate) are not "echoed", as
   echoing does not solve any "hung" conditions.  Instead time-out
   mechanisms are recommended for avoiding hang-ups.

   [<a id="ref-14" name="ref-14">14</a>] The data type mechanism suggested here does not replace data
   reconfiguration service suggested by Harslem and Heafner in <a href="rfc83.html">RFC 83</a>
   and NIC5772.  In fact, it complements the reconfiguration.  For



<span class="grey">Bhushan                                                        [Page 16]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-17" id="page-17" name="page-17"> </a>
<span class="grey"><a href="rfc114.html">RFC 114</a>                 A FILE TRANSFER PROTOCOL           16 April 1971</span>


   example, data reconfiguration language can be expressed in EBCDIC,
   Network ASCII or any other code that form machine may "recognize".
   Subsequent data may be transmitted binary, and the form machine would
   reconfigure it to the required form.  I have included in data types,
   a large number suggested by Harslem and Heafner, as I do not wish to
   preclude interpretation, reconfiguration and storage of simple forms
   of data at individual host sites.

   [<a id="ref-15" name="ref-15">15</a>] The internal character representation in the hosts may be
   different even in ASCII.  For example PDP-10 stores 7-bit characters,
   five per word with 36th bit as don't care, while Multics stores them
   four per word, right-justified in 9-bit fields.

   [<a id="ref-16" name="ref-16">16</a>] It seems that socket 1 has been assigned to logger and socket 5
   to NETRJS.  Socket 3 seems a reasonable choice for the file transfer
   process.

   [<a id="ref-17" name="ref-17">17</a>] The term program mediation was suggested by Bob Metcalfe who is
   intending to write a paper on this subject.


         [ This RFC was put into machine readable form for entry ]
             [ into the online RFC archives by Ryan Kato 6/01]




























Bhushan                                                        [Page 17]

</pre><br/>
    <span class="noprint"><small><small>Html markup produced by rfcmarkup 1.126, available from
      <a href="https://tools.ietf.org/tools/rfcmarkup/">https://tools.ietf.org/tools/rfcmarkup/</a>
    </small></small></span>
  </div>




</body><!-- Mirrored from tools.ietf.org/html/rfc114 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 06 Mar 2018 23:19:03 GMT --></html>