<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml"><!-- Mirrored from tools.ietf.org/html/rfc642 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 14 Aug 2018 14:27:59 GMT --><!-- Added by HTTrack --><head><meta content="text/html;charset=utf-8" http-equiv="content-type"/><!-- /Added by HTTrack -->

    <meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
    <meta content="index,follow" name="robots"/>
    <meta content="rfcmarkup version 1.127" name="creator"/>
    <link href="http://purl.org/dc/elements/1.1/" rel="schema.DC"/>
<meta content="urn:ietf:rfc:642" name="DC.Identifier"/>
<meta content="J.D. Burchfiel" name="DC.Creator"/>
<meta content="July, 1974" name="DC.Date.Issued"/>
<meta content="Ready line philosophy and implementation" name="DC.Title"/>

    <link href="https://tools.ietf.org/images/rfc.png" rel="icon" type="image/png"/>
    <link href="https://tools.ietf.org/images/rfc.png" rel="shortcut icon" type="image/png"/>
    <title>RFC 642 - Ready line philosophy and implementation</title>
    
    
    <style type="text/css">
	@media only screen 
	  and (min-width: 992px)
	  and (max-width: 1199px) {
	    body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 768px)
	  and (max-width: 991px) {
            body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 480px)
	  and (max-width: 767px) {
            body { font-size: 11pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (max-width: 479px) {
            body { font-size: 8pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-device-width : 375px) 
	  and (max-device-width : 667px) {
            body { font-size: 9.5pt; }
            div.content { width: 96ex; margin: 0 1px; }
        }
	@media only screen 
	  and (min-device-width: 1200px) {
            body { font-size: 10pt; margin: 0 4em; }
            div.content { width: 96ex; margin: 0; }
        }
        h1, h2, h3, h4, h5, h6, .h1, .h2, .h3, .h4, .h5, .h6 {
	    font-weight: bold;
            line-height: 0pt;
            display: inline;
            white-space: pre;
            font-family: monospace;
            font-size: 1em;
	    font-weight: bold;
        }
        pre {
            font-size: 1em;
            margin-top: 0px;
            margin-bottom: 0px;
        }
	.pre {
	    white-space: pre;
	    font-family: monospace;
	}
	.header{
	    font-weight: bold;
	}
        .newpage {
            page-break-before: always;
        }
        .invisible {
            text-decoration: none;
            color: white;
        }
        a.selflink {
          color: black;
          text-decoration: none;
        }
        @media print {
            body {
                font-family: monospace;
                font-size: 10.5pt;
            }
            h1, h2, h3, h4, h5, h6 {
                font-size: 1em;
            }
        
            a:link, a:visited {
                color: inherit;
                text-decoration: none;
            }
            .noprint {
                display: none;
            }
        }
	@media screen {
	    .grey, .grey a:link, .grey a:visited {
		color: #777;
	    }
            .docinfo {
                background-color: #EEE;
            }
            .top {
                border-top: 7px solid #EEE;
            }
            .bgwhite  { background-color: white; }
            .bgred    { background-color: #F44; }
            .bggrey   { background-color: #666; }
            .bgbrown  { background-color: #840; }            
            .bgorange { background-color: #FA0; }
            .bgyellow { background-color: #EE0; }
            .bgmagenta{ background-color: #F4F; }
            .bgblue   { background-color: #66F; }
            .bgcyan   { background-color: #4DD; }
            .bggreen  { background-color: #4F4; }

            .legend   { font-size: 90%; }
            .cplate   { font-size: 70%; border: solid grey 1px; }
	}
    </style>
    <!--[if IE]>
    <style>
    body {
       font-size: 13px;
       margin: 10px 10px;
    }
    </style>
    <![endif]-->

    <script type="text/javascript"><!--
    function addHeaderTags() {
	var spans = document.getElementsByTagName("span");
	for (var i=0; i < spans.length; i++) {
	    var elem = spans[i];
	    if (elem) {
		var level = elem.getAttribute("class");
                if (level == "h1" || level == "h2" || level == "h3" || level == "h4" || level == "h5" || level == "h6") {
                    elem.innerHTML = "<"+level+">"+elem.innerHTML+"</"+level+">";		
                }
	    }
	}
    }
    var legend_html = "Colour legend:<br />      <table>         <tr><td>Unknown:</td>                   <td><span class='cplate bgwhite'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft:</td>                     <td><span class='cplate bgred'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Informational:</td>             <td><span class='cplate bgorange'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Experimental:</td>              <td><span class='cplate bgyellow'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Best Common Practice:</td>      <td><span class='cplate bgmagenta'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Proposed Standard:</td>         <td><span class='cplate bgblue'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft Standard (old designation):</td> <td><span class='cplate bgcyan'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Internet Standard:</td>         <td><span class='cplate bggreen'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Historic:</td>                  <td><span class='cplate bggrey'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Obsolete:</td>                  <td><span class='cplate bgbrown'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>     </table>";
    function showElem(id) {
        var elem = document.getElementById(id);
        elem.innerHTML = eval(id+"_html");
        elem.style.visibility='visible';
    }
    function hideElem(id) {
        var elem = document.getElementById(id);
        elem.style.visibility='hidden';        
        elem.innerHTML = "";
    }
    // -->
    </script>
</head>
<body onload="addHeaderTags()">
  <div class="content">
   <div style="height: 13px;">
      <div class="pre noprint docinfo bgwhite" onclick="showElem('legend');" onmouseout="hideElem('legend')" onmouseover="this.style.cursor='pointer';" style="height: 6px; position: absolute;" title="Click for colour legend.">                                                                        </div>
      <div class="docinfo noprint pre legend" id="legend" onmouseout="hideElem('legend');" onmouseover="showElem('legend');" style="position:absolute; top: 4px; left: 4ex; visibility:hidden; background-color: white; padding: 4px 9px 5px 7px; border: solid #345 1px; ">
      </div>
   </div>
<span class="pre noprint docinfo top">[<a href="index.html" title="Document search and retrieval page">Docs</a>] [<a href="https://tools.ietf.org/rfc/rfc642.txt" title="Plaintext version of this document">txt</a>|<a href="https://tools.ietf.org/pdf/rfc642" title="PDF version of this document">pdf</a>] [<a href="https://datatracker.ietf.org/doc/rfc642" title="IESG Datatracker information for this document">Tracker</a>]                                              </span><br/>
<span class="pre noprint docinfo">                                                                        </span><br/>
<span class="pre noprint docinfo">                                                                        </span><br/>
<span class="pre noprint docinfo">                                                                        </span><br/>
<pre>Network Working Group                                    Jerry Burchfiel
Request for Comments: 642                                            BBN
NIC: 30872                                                  July 5, 1974


                <span class="h1">Ready Line Philosophy and Implementation</span>

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/I.%20%20Introduction"></a><a class="selflink" href="#appendix-I" name="appendix-I">I</a>.  Introduction</span>

   BBN Report #1822, Specifications for the Interconnection of a Host
   and an IMP, gives a complete specification of the Host-IMP interface.
   However, the authors of this document bent over backward to avoid
   issuing arbitrary dictatorial directives to host interface
   implementors.  They succeeded admirably in this goal by describing
   the IMP implementation, and suggesting similar behavior on the part
   of the host.

   ARPA has appointed a PDP-11 local host interface standardization
   committee composed of myself, Dave Retz of SCRL, and Yuval Peduel of
   MIT Lincoln Labs.  During our review of various interfaces designed
   by the ARPA community, we have found total chaos, confusion and
   misunderstanding about the recommended host interface implementation.

   This note is an attempt to make explicit the recommendations which
   are implicit in Report #1822.  It provides a cookbook for interface
   implementors, including a set of recommended do's and don't's in the
   common problem areas.  This document has been reviewed and approved
   by the BBN IMP group.

II.  Ready-line Philosophy

   The following is an attempt to spell out in detail a consistent plan
   for operation of the IMP ready line and host ready line with the
   following objectives:

      1.  Reliably resynchronize and resume transmission after a
          temporary lapse of service and possible loss of state
          information by either system.

      2.  Make the programming of the host interface as simple as
          possible.  This will minimize bugs, and make it possible to
          create a small ROM network-bootstrap loader.

   First, consider the IMP ready line.  When it drops, the IMP has
   suffered a possible loss of state, so the message in transit from the
   IMP to the host (if any) is likely to be incomplete.  Similarly, the
   message in transit from the host to the IMP (if any) is likely to be
   incomplete.  Both the host and the IMP must recognize this explicitly



<span class="grey">Burchfiel                                                       [Page 1]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-2" id="page-2" name="page-2"> </a>
<span class="grey"><a href="rfc642.html">RFC 642</a>         Ready Line Philosophy and Implementation       July 1974</span>


   by sending a message intended to be thrown away* (which may he
   appended to the current message) and throw away the message currently
   being received.  (Both the host - IMP message and the IMP - host
   message).

   The simplest arrangement for the host's interface driver is a pair of
   processes, one sending messages and the other receiving messages.
   This drop of the IMP's ready line must be provided as an error status
   bit to each process.  However, the two processes will need to clear
   this condition independently: the simplest implementation is an Input
   Error flop and an Output Error flop.  Both flops are set by a drop of
   the IMP's ready line, and they are cleared independently under
   program control.

   When the IMP raises its ready line, each contact bounce will again
   set the Error flops in the host's interface.  To insure that messages
   are not flowing across the interface at this time, assertions of the
   signals "there's your IMP bit" and "ready for next host bit" have
   been delayed sufficiently in the IMP to guarantee that the IMP ready
   line has stabilized.

III.  Programming

   The interface driver processes can be described simply:

   INPUT:  Wait until an input buffer is available
           Wait until IMP ready
           Start input
           Wait until input is complete
           IF Input Error
           THEN clear Input Error  // Flush smashed message.  Input
                                   // buffer will be reused.
           ELSE queue message on input queue
           GOTO INPUT

   OUTPUT: Wait until a message is present on output queue
           Wait until IMP ready
           Start output
           Wait until output is complete
           IF Output Error
           THEN clear Output Error  // smashed message is flushed
           ELSE deque message from output queue  // Free up
                                                 // output buffer
           GOTO 0UTPUT

   ----------
   *The standard convention uses the host-IMP NOP message.




<span class="grey">Burchfiel                                                       [Page 2]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-3" id="page-3" name="page-3"> </a>
<span class="grey"><a href="rfc642.html">RFC 642</a>         Ready Line Philosophy and Implementation       July 1974</span>


   The only initialization required for system startup or restart is
   clearing the host READY flop, waiting 1/2 second, and setting the
   host READY flop.  Simply starting (or restarting) the above processes
   will properly resynchronize host-IMP communication.  As explained in
   RFC #636, the IMP ready line (and error flops) should only affect the
   two processes above: this resynchronization should be invisible to
   the NCP, and should have no effect on the connection data base.  The
   NCP will be resynchronized or reinitialized by the type 10 IMP-to-
   host message "interface was reset."

   Actually, it is possible to share a single Error flop between the
   input and output processes by implementing Input Error and Output
   Error as software flags.  A process testing for error must test both
   the Error flop and its own flag.  An interlock is required (e.g.  a
   mutual exclusion  semaphore) to guarantee that only one process at a
   time is testing and modifying the flags.  If the Error flop is set,
   the process must copy it into the other process' flag before clearing
   the flop and its own flag.

IV.  Host Ready Line Implementation

   When the host drops and raises its ready line, the IMP behaves in a
   fashion symmetric to that outlined above.  Of course, this drop
   indicates that the state of the host's interface driver, as well as
   the current incoming and outgoing messages, are likely to be lost.
   The appropriate action is triggered by setting the Error flop or
   flops in the host interface, and the processes specified above will
   correctly resynchronize message flow in both directions.  Of course,
   to guarantee that messages are not flowing across the interface while
   the host ready line is undergoing contact bounce, the host must delay
   transmission until its ready line has stabilized.  This may be done
   in two ways:

      Hardware: an integrating one-shot driven by the host ready line
           flop is ANDed with "there's your host bit" and "ready for
           next IMP bit" to guarantee that message transfer will not
           start until the ready flop has been on for 1/2 second.

      Software: the initialization program executes a 1/2 second wait
           after setting the host ready flop before permitting input or
           output to begin.










<span class="grey">Burchfiel                                                       [Page 3]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-4" id="page-4" name="page-4"> </a>
<span class="grey"><a href="rfc642.html">RFC 642</a>         Ready Line Philosophy and Implementation       July 1974</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/V.%20%20Summary"></a><a class="selflink" href="#appendix-V" name="appendix-V">V</a>.  Summary</span>

   This determines the specification READY line controls for the host's
   interface to the IMP:

      1.  It contains a program settable/clearable host READY flop which
          drives a relay closure to the IMP.

      2.  It detects the IMP's ready signal as a program-readable status
          condition.  (But not an interrupt condition)

      3.  It contains one or two ERROR flops set when either the host
          READY flop is off or the IMP ready signal is off.  The flop
          (flops) is a program-readable and program-clearable status
          condition.  (But not an interrupt condition).  These status
          flops must not be cleared by system initialization.

      4.  If hardware stabilization of the host's READY line is
          provided, it is a 1/2 second integrating one-shot driven by
          the host READY flop.  This signal is ANDed with "there's your
          host bit" and "ready for next IMP bit".











       [ This RFC was put into machine readable form for entry ]
       [ into the online RFC archives by Alex McKenzie with    ]
       [ support from GTE, formerly BBN Corp.           2/2000 ]
















Burchfiel                                                       [Page 4]

</pre><br/>
    <span class="noprint"><small><small>Html markup produced by rfcmarkup 1.127, available from
      <a href="https://tools.ietf.org/tools/rfcmarkup/">https://tools.ietf.org/tools/rfcmarkup/</a>
    </small></small></span>
  </div>




</body><!-- Mirrored from tools.ietf.org/html/rfc642 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 14 Aug 2018 14:27:59 GMT --></html>