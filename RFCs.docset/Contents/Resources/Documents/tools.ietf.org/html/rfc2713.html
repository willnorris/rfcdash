<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml"><!-- Mirrored from tools.ietf.org/html/rfc2713 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 06 Mar 2018 23:18:51 GMT --><!-- Added by HTTrack --><head><meta content="text/html;charset=utf-8" http-equiv="content-type"/><!-- /Added by HTTrack -->

    <meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
    <meta content="index,follow" name="robots"/>
    <meta content="rfcmarkup version 1.126" name="creator"/>
    <link href="http://purl.org/dc/elements/1.1/" rel="schema.DC"/>
<meta content="urn:ietf:rfc:2713" name="DC.Identifier"/>
<meta content="This document defines the schema for representing Java(tm) objects in
an LDAP directory. This memo provides information for the Internet
community." name="DC.Description.Abstract"/>
<meta content="Lee, Rosanna" name="DC.Creator"/>
<meta content="Seligman, Scott" name="DC.Creator"/>
<meta content="Ryan, Vincent" name="DC.Creator"/>
<meta content="October, 1999" name="DC.Date.Issued"/>
<meta content="Schema for Representing Java(tm) Objects in an LDAP Directory" name="DC.Title"/>

    <link href="https://tools.ietf.org/images/rfc.png" rel="icon" type="image/png"/>
    <link href="https://tools.ietf.org/images/rfc.png" rel="shortcut icon" type="image/png"/>
    <title>RFC 2713 - Schema for Representing Java(tm) Objects in an LDAP Directory</title>
    
    
    <style type="text/css">
	@media only screen 
	  and (min-width: 992px)
	  and (max-width: 1199px) {
	    body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 768px)
	  and (max-width: 991px) {
            body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 480px)
	  and (max-width: 767px) {
            body { font-size: 11pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (max-width: 479px) {
            body { font-size: 8pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-device-width : 375px) 
	  and (max-device-width : 667px) {
            body { font-size: 9.5pt; }
            div.content { width: 96ex; margin: 0 1px; }
        }
	@media only screen 
	  and (min-device-width: 1200px) {
            body { font-size: 10pt; margin: 0 4em; }
            div.content { width: 96ex; margin: 0; }
        }
        h1, h2, h3, h4, h5, h6, .h1, .h2, .h3, .h4, .h5, .h6 {
	    font-weight: bold;
            line-height: 0pt;
            display: inline;
            white-space: pre;
            font-family: monospace;
            font-size: 1em;
	    font-weight: bold;
        }
        pre {
            font-size: 1em;
            margin-top: 0px;
            margin-bottom: 0px;
        }
	.pre {
	    white-space: pre;
	    font-family: monospace;
	}
	.header{
	    font-weight: bold;
	}
        .newpage {
            page-break-before: always;
        }
        .invisible {
            text-decoration: none;
            color: white;
        }
        a.selflink {
          color: black;
          text-decoration: none;
        }
        @media print {
            body {
                font-family: monospace;
                font-size: 10.5pt;
            }
            h1, h2, h3, h4, h5, h6 {
                font-size: 1em;
            }
        
            a:link, a:visited {
                color: inherit;
                text-decoration: none;
            }
            .noprint {
                display: none;
            }
        }
	@media screen {
	    .grey, .grey a:link, .grey a:visited {
		color: #777;
	    }
            .docinfo {
                background-color: #EEE;
            }
            .top {
                border-top: 7px solid #EEE;
            }
            .bgwhite  { background-color: white; }
            .bgred    { background-color: #F44; }
            .bggrey   { background-color: #666; }
            .bgbrown  { background-color: #840; }            
            .bgorange { background-color: #FA0; }
            .bgyellow { background-color: #EE0; }
            .bgmagenta{ background-color: #F4F; }
            .bgblue   { background-color: #66F; }
            .bgcyan   { background-color: #4DD; }
            .bggreen  { background-color: #4F4; }

            .legend   { font-size: 90%; }
            .cplate   { font-size: 70%; border: solid grey 1px; }
	}
    </style>
    <!--[if IE]>
    <style>
    body {
       font-size: 13px;
       margin: 10px 10px;
    }
    </style>
    <![endif]-->

    <script type="text/javascript"><!--
    function addHeaderTags() {
	var spans = document.getElementsByTagName("span");
	for (var i=0; i < spans.length; i++) {
	    var elem = spans[i];
	    if (elem) {
		var level = elem.getAttribute("class");
                if (level == "h1" || level == "h2" || level == "h3" || level == "h4" || level == "h5" || level == "h6") {
                    elem.innerHTML = "<"+level+">"+elem.innerHTML+"</"+level+">";		
                }
	    }
	}
    }
    var legend_html = "Colour legend:<br />      <table>         <tr><td>Unknown:</td>                   <td><span class='cplate bgwhite'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft:</td>                     <td><span class='cplate bgred'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Informational:</td>             <td><span class='cplate bgorange'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Experimental:</td>              <td><span class='cplate bgyellow'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Best Common Practice:</td>      <td><span class='cplate bgmagenta'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Proposed Standard:</td>         <td><span class='cplate bgblue'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft Standard (old designation):</td> <td><span class='cplate bgcyan'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Internet Standard:</td>         <td><span class='cplate bggreen'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Historic:</td>                  <td><span class='cplate bggrey'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Obsolete:</td>                  <td><span class='cplate bgbrown'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>     </table>";
    function showElem(id) {
        var elem = document.getElementById(id);
        elem.innerHTML = eval(id+"_html");
        elem.style.visibility='visible';
    }
    function hideElem(id) {
        var elem = document.getElementById(id);
        elem.style.visibility='hidden';        
        elem.innerHTML = "";
    }
    // -->
    </script>
</head>
<body onload="addHeaderTags()">
  <div class="content">
   <div style="height: 13px;">
      <div class="pre noprint docinfo bgorange" onclick="showElem('legend');" onmouseout="hideElem('legend')" onmouseover="this.style.cursor='pointer';" style="height: 6px; position: absolute;" title="Click for colour legend.">                                                                        </div>
      <div class="docinfo noprint pre legend" id="legend" onmouseout="hideElem('legend');" onmouseover="showElem('legend');" style="position:absolute; top: 4px; left: 4ex; visibility:hidden; background-color: white; padding: 4px 9px 5px 7px; border: solid #345 1px; ">
      </div>
   </div>
<span class="pre noprint docinfo top">[<a href="index.html" title="Document search and retrieval page">Docs</a>] [<a href="https://tools.ietf.org/rfc/rfc2713.txt" title="Plaintext version of this document">txt</a>|<a href="https://tools.ietf.org/pdf/rfc2713" title="PDF version of this document">pdf</a>] [<a href="https://tools.ietf.org/html/draft-ryan-java-schema" title="draft-ryan-java-schema">draft-ryan-java...</a>] [<a href="https://datatracker.ietf.org/doc/rfc2713" title="IESG Datatracker information for this document">Tracker</a>] [<a href="https://tools.ietf.org/rfcdiff?difftype=--hwdiff&amp;url2=rfc2713" title="Inline diff (wdiff)">Diff1</a>] [<a href="https://tools.ietf.org/rfcdiff?url2=rfc2713" title="Side-by-side diff">Diff2</a>]         </span><br/>
<span class="pre noprint docinfo">                                                                        </span><br/>
<span class="pre noprint docinfo">                                                           INFORMATIONAL</span><br/>
<span class="pre noprint docinfo">                                                                        </span><br/>
<pre>Network Working Group                                            V. Ryan
Request for Comments: 2713                                   S. Seligman
Category: Informational                                           R. Lee
                                                  Sun Microsystems, Inc.
                                                            October 1999


     <span class="h1">Schema for Representing Java(tm) Objects in an LDAP Directory</span>

Status of this Memo

   This memo provides information for the Internet community.  It does
   not specify an Internet standard of any kind.  Distribution of this
   memo is unlimited.

Copyright Notice

   Copyright (C) The Internet Society (1999).  All Rights Reserved.

Abstract

   This document defines the schema for representing Java(tm) objects in
   an LDAP directory [<a href="#ref-LDAPv3" title='"Lightweight Directory Access Protocol (v3)"'>LDAPv3</a>].  It defines schema elements to represent
   a Java serialized object [<a href="#ref-Serial" title='"Object Serialization Specification,"'>Serial</a>], a Java marshalled object [<a href="#ref-RMI" title='"Remote Method Invocation,"'>RMI</a>], a
   Java remote object [<a href="#ref-RMI" title='"Remote Method Invocation,"'>RMI</a>], and a JNDI reference [<a href="#ref-JNDI" title='"The Java(tm) Naming and Directory Interface (tm) Specification,"'>JNDI</a>].

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/1.%20Introduction"></a><a class="selflink" href="#section-1" name="section-1">1</a>. Introduction</span>

   This document assumes that the reader has a general knowledge of the
   Java programming language [<a href="#ref-Java" title='"The Java(tm) Programming Language,"'>Java</a>].  For brevity we use the term "Java
   object" in place of "object in the Java programming language"
   throughout this text.

   Traditionally, LDAP directories have been used to store data. Users
   and programmers think of the directory as a hierarchy of directory
   entries, each containing a set of attributes.  You look up an entry
   from the directory and extract the attribute(s) of interest.  For
   example, you can look up a person's telephone number from the
   directory.  Alternatively, you can search the directory for entries
   with a particular set of attributes.  For example, you can search for
   all persons in the directory with the surname "Smith".

   For applications written in the Java programming language, a kind of
   data that is typically shared are Java objects themselves.  For such
   applications, it makes sense to be able to use the directory as a
   repository for Java objects.  The directory provides a centrally
   administered, and possibly replicated, service for use by Java
   applications distributed across the network.



<span class="grey">Ryan, et al.                 Informational                      [Page 1]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-2" id="page-2" name="page-2"> </a>
<span class="grey"><a href="rfc2713.html">RFC 2713</a>                Schema for Java Objects             October 1999</span>


   For example, an application server might use the directory for
   "registering" objects representing the services that it manages, so
   that a client can later search the directory to locate those services
   as it needs.

   The motivation for this document is to define a common way for
   applications to store and retrieve Java objects from the directory.
   Using this common schema, any Java application that needs to read or
   store Java objects in the directory can do so in an interoperable
   way.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/2%20Representation%20of%20Java%20Objects"></a><a class="selflink" href="#section-2" name="section-2">2</a> Representation of Java Objects</span>

   This document defines schema elements to represent three types of
   Java objects:  a Java serialized object, a Java marshalled object,
   and a JNDI reference. A Java remote object is stored as either a Java
   marshalled object or a JNDI reference.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/2.1%20Common%20Representations"></a><a class="selflink" href="#section-2.1" name="section-2.1">2.1</a> Common Representations</span>

   A Java object is stored in the LDAP directory by using the object
   class javaObject. This is the base class from which other Java object
   related classes derive: javaSerializedObject, javaMarshalledObject,
   and javaNamingReference.  javaObject is an abstract object class,
   which means that a javaObject cannot exist by itself in the
   directory; only auxiliary or structural subclasses of it can exist in
   the directory.

   The object class javaContainer represents a directory entry dedicated
   to storing a Java object. It is a structural object class.  In cases
   where a subclass of javaObject is mixed in with another structural
   object class, javaContainer is not required.

   The definitions for the object classes javaObject and javaContainer
   are presented in <a href="#section-4">Section 4</a>.

   The javaObject class has one mandatory attribute (javaClassName) and
   four optional attributes (javaClassNames, javaCodebase, javaDoc,
   description).  javaClassName is a single valued attribute that is
   used to store the fully qualified name of the object's Java class
   (for example, "java.lang.String").  This may be the object's most
   derived class's name, but does not have to be; that of a superclass
   or interface in some cases might be most appropriate.  This attribute
   is intended for storing the name of the object's "distinguished"
   class, that is, the class or interface with which the object should
   be identified.





<span class="grey">Ryan, et al.                 Informational                      [Page 2]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-3" id="page-3" name="page-3"> </a>
<span class="grey"><a href="rfc2713.html">RFC 2713</a>                Schema for Java Objects             October 1999</span>


   javaClassNames is a multivalued attribute that is used to store the
   fully qualified names of the object's Java classes and interfaces
   (for example, "java.lang.Byte"). Like all multivalued attributes, the
   javaClassNames attribute's values are unordered and so no one value
   is more "distinguished" than the others. This attribute is intended
   for storing an object's class and interface names and those of its
   ancestor classes and interfaces, although the list of values does not
   have to be complete.  If the javaClassNames attribute is present, it
   should include the value of javaClassName.

   For example, suppose an object is stored in the directory with a
   javaClassName attribute of "java.io.FilePermission", and a
   javaClassNames attribute of {"java.security.Permission",
   "java.io.FilePermission", "java.security.Guard",
   "java.io.Serializable"}. An application searching a directory for
   Java objects might use javaClassName to produce a summary of the
   names and types of Java objects in that directory.  Another
   application might use the javaClassNames attribute to find, for
   example, all java.security.Permission objects.

   javaCodebase is a multivalued attribute that is used to store the
   location(s) of the object's class definition.  javaDoc is used to
   store a pointer (URL) to the Java documentation for the class.
   description is used to store a textual description of a Java object
   and is defined in [<a href="#ref-v3Schema" title='"A Summary of the X.500(96) User Schema for use with LDAPv3"'>v3Schema</a>]. The definitions of these attributes are
   presented in <a href="#section-3">Section 3</a>.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/2.2%20Serialized%20Objects"></a><a class="selflink" href="#section-2.2" name="section-2.2">2.2</a> Serialized Objects</span>

   To "serialize" an object means to convert its state into a byte
   stream in such a way that the byte stream can be converted back into
   a copy of the object.  A Java object is "serializable" if its class
   or any of its superclasses implements either the java.io.Serializable
   interface or its subinterface java.io.Externalizable.
   "Deserialization" is the process of converting the serialized form of
   an object back into a copy of the object.  When an object is
   serialized, the entire tree of objects rooted at the object is also
   serialized. When it is deserialized, the tree is reconstructed. For
   example, suppose a serializable Book object contains (a serializable
   field of) an array of Page objects.  When a Book object is
   serialized, so is the array of Page objects.

   The Java platform specifies a default algorithm by which serializable
   objects are serialized. A Java class can also override this default
   serialization with its own algorithm.  [<a href="#ref-Serial" title='"Object Serialization Specification,"'>Serial</a>] describes object
   serialization in detail.





<span class="grey">Ryan, et al.                 Informational                      [Page 3]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-4" id="page-4" name="page-4"> </a>
<span class="grey"><a href="rfc2713.html">RFC 2713</a>                Schema for Java Objects             October 1999</span>


   When an object is serialized, information that identifies its class
   is recorded in the serialized stream. However, the class's definition
   ("class file") itself is not recorded. It is the responsibility of
   the system that is deserializing the object to determine the
   mechanism to use for locating and loading the associated class
   definitions. For example, the Java application might include in its
   classpath a JAR file containing the class definitions of the
   serialized object, or load the class definitions using information
   from the directory, as explained below.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/2.2.1%20Representation%20in%20the%20Directory"></a><a class="selflink" href="#section-2.2.1" name="section-2.2.1">2.2.1</a> Representation in the Directory</span>

   A serialized object is represented in the directory by the attributes
   javaClassName, javaClassNames, javaCodebase, and javaSerializedData,
   as defined in <a href="#section-3">Section 3</a>.  The mandatory attribute,
   javaSerializedData, contains the serialized form of the object.
   Although the serialized form already contains the class name, the
   mandatory javaClassName attribute also records the class name of the
   serialized object so that applications can determined class
   information without having to first deserialize the object.  The
   optional javaClassNames attribute is used to record additional class
   information about the serialized object.  The optional javaCodebase
   attribute is used to record the locations of the class definitions
   needed to deserialize the serialized object.

   A directory entry that contains a serialized object is represented by
   the object class javaSerializedObject, which is a subclass of
   javaObject.  javaSerializedObject is an auxiliary object class, which
   means that it needs to be mixed in with a structural object class.
   javaSerializedObject's definition is given in <a href="#section-4">Section 4</a>.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/2.3%20Marshalled%20Objects"></a><a class="selflink" href="#section-2.3" name="section-2.3">2.3</a> Marshalled Objects</span>

   To "marshal" an object means to record its state and codebase(s) in
   such a way that when the marshalled object is "unmarshalled," a copy
   of the original object is obtained, possibly by automatically loading
   the class definitions of the object.  You can marshal any object that
   is serializable or remote (that is, implements the java.rmi.Remote
   interface).  Marshalling is like serialization, except marshalling
   also records codebases. Marshalling is different from serialization
   in that marshalling treats remote objects specially. If an object is
   a java.rmi.Remote object, marshalling records the remote object's
   "stub" (see <a href="#section-2.5">Section 2.5</a>), instead of the remote object itself.  Like
   serialization, when an object is marshalled, the entire tree of
   objects rooted at the object is marshalled. When it is unmarshalled,
   the tree is reconstructed.





<span class="grey">Ryan, et al.                 Informational                      [Page 4]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-5" id="page-5" name="page-5"> </a>
<span class="grey"><a href="rfc2713.html">RFC 2713</a>                Schema for Java Objects             October 1999</span>


   A "marshalled" object is the represented by the
   java.rmi.MarshalledObject class. Here's an example of how to create
   MarshalledObjects for serializable and remote objects:

       java.io.Serializable sobj = ...;
       java.rmi.MarshalledObject mobj1 =
           new java.rmi.MarshalledObject(sobj);

       java.rmi.Remote robj = ...;
       java.rmi.MarshalledObject mobj2 =
           new java.rmi.MarshalledObject(robj);

   Then, to retrieve the original objects from the MarshalledObjects, do
   as follows:

       java.io.Serializable sobj = (java.io.Serializable) mobj1.get();
       java.io.Remote rstub = (java.io.Remote) mobj2.get();

   MarshalledObject is available only on the Java 2 Platform, Standard
   Edition, v1.2, and higher releases.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/2.3.1%20Representation%20in%20the%20Directory"></a><a class="selflink" href="#section-2.3.1" name="section-2.3.1">2.3.1</a> Representation in the Directory</span>

   A marshalled object is represented in the directory by the attributes
   javaClassName, javaClassNames, and javaSerializedData, as defined in
   <a href="#section-3">Section 3</a>.  The mandatory attribute, javaSerializedData, contains the
   serialized form of the marshalled object (that is, the serialized
   form of a MarshalledObject instance).  The mandatory javaClassName
   attribute records the distinguished class name of the object before
   it has been marshalled.  The optional javaClassNames attribute is
   used to record additional class information about the object before
   it has been marshalled.

   A directory entry that contains a marshalled object is represented by
   the object class javaMarshalledObject, which is a subclass of
   javaObject.  javaMarshalledObject is an auxiliary object class, which
   means that it needs to be mixed in with a structural object class.
   javaMarshalledObject's definition is given in <a href="#section-4">Section 4</a>.

   As evident in this description, a javaMarshalledObject differs from a
   javaSerializedObject only in the interpretation of the javaClassName
   and javaClassNames attributes.









<span class="grey">Ryan, et al.                 Informational                      [Page 5]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-6" id="page-6" name="page-6"> </a>
<span class="grey"><a href="rfc2713.html">RFC 2713</a>                Schema for Java Objects             October 1999</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/2.4%20JNDI%20References"></a><a class="selflink" href="#section-2.4" name="section-2.4">2.4</a> JNDI References</span>

   Java Naming and Directory Interface(tm) (JNDI) is a directory access
   API specified in the Java programming language [<a href="#ref-JNDI" title='"The Java(tm) Naming and Directory Interface (tm) Specification,"'>JNDI</a>].  It provides
   an object-oriented view of the directory, allowing Java objects to be
   added to and retrieved from the directory without requiring the
   client to manage data representation issues.

   JNDI defines the notion of a "reference" for use when an object
   cannot be stored in the directory directly, or when it is
   inappropriate or undesirable to do so.  An object with an associated
   reference is stored in the directory indirectly, by storing its
   reference instead.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/2.4.1%20Contents%20of%20a%20Reference"></a><a class="selflink" href="#section-2.4.1" name="section-2.4.1">2.4.1</a> Contents of a Reference</span>

   A JNDI reference is a Java object of class javax.naming.Reference.
   It consists of class information about the object being referenced
   and an ordered list of addresses.  An address is a Java object of
   class javax.naming.RefAddr.  Each address contains information on how
   to construct the object.

   A common use for JNDI references is to represent connections to a
   network service such as a database, directory, or file system.  Each
   address may then identify a "communications endpoint" for that
   service, containing information on how to contact the service.
   Multiple addresses may arise for various reasons, such as replication
   or the object offering interfaces over more than one communication
   mechanism.

   A reference also contains information to assist in the creation of an
   instance of the object to which the reference refers.  It contains
   the Java class name of that object, and the class name and location
   of the object factory to be used to create the object.  The
   procedures for creating an object given its reference and the reverse
   are described in [<a href="#ref-JNDI" title='"The Java(tm) Naming and Directory Interface (tm) Specification,"'>JNDI</a>].

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/2.4.2%20Representation%20in%20the%20Directory"></a><a class="selflink" href="#section-2.4.2" name="section-2.4.2">2.4.2</a> Representation in the Directory</span>

   A JNDI reference is stored in the directory by using the attributes
   javaClassName, javaClassNames, javaCodebase, javaReferenceAddress,
   and javaFactory, defined in <a href="#section-3">Section 3</a>.  These attributes store
   information corresponding to the contents of a reference described
   above.  javaReferenceAddress is a multivalued optional attribute for
   storing reference addresses.  javaFactory is the optional attribute
   for storing the object factory's fully qualified class name.  The
   mandatory javaClassName attribute is used to store the name of the
   distinguished class of the object.  The optional javaClassNames



<span class="grey">Ryan, et al.                 Informational                      [Page 6]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-7" id="page-7" name="page-7"> </a>
<span class="grey"><a href="rfc2713.html">RFC 2713</a>                Schema for Java Objects             October 1999</span>


   attribute is used to record additional class and interface names.
   The optional javaCodebase attribute is used to store the locations of
   the object factory's and the object's class definitions.

   A directory entry containing a JNDI reference is represented by the
   object class javaNamingReference, which is a subclass of javaObject.
   javaNamingReference is an auxiliary object class, which means that it
   needs to be mixed in with a structural object class.
   javaNamingReference's definition is given in <a href="#section-4">Section 4</a>.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/2.5%20Remote%20Objects"></a><a class="selflink" href="#section-2.5" name="section-2.5">2.5</a> Remote Objects</span>

   The Java Remote Method Invocation (RMI) system [<a href="#ref-RMI" title='"Remote Method Invocation,"'>RMI</a>] is a mechanism
   that enables an object on one Java virtual machine to invoke methods
   on an object in another Java virtual machine. Any object whose
   methods can be invoked in this way must implement the java.rmi.Remote
   interface.  When such an object is invoked, its arguments are
   marshalled and sent from the local virtual machine to the remote one,
   where the arguments are unmarshalled and used.  When the method
   terminates, the results are marshalled from the remote machine and
   sent to the caller's virtual machine.

   To make a remote object accessible to other virtual machines, a
   program typically registers it with the RMI registry.  The program
   supplies to the RMI registry the string name of the remote object and
   the remote object itself.  When a program wants to access a remote
   object, it supplies the object's string name to the RMI registry on
   the same machine as the remote object.  The RMI registry returns to
   the caller a reference (called "stub") to the remote object.  When
   the program receives the stub for the remote object, it can invoke
   methods on the remote object (through the stub).  A program can also
   obtain references to remote objects as a result of remote calls to
   other remote objects or from other naming services.  For example, the
   program can look up a reference to a remote object from an LDAP
   server that supports the schema defined in this document.

   The string name accepted by the RMI registry has the syntax
   "rmi://hostname:port/remoteObjectName", where "hostname" and "port"
   identify the machine and port on which the RMI registry is running,
   respectively, and "remoteObjectName" is the string name of the remote
   object.  "hostname", "port", and the prefix, "rmi:", are optional. If
   "hostname" is not specified, it defaults to the local host.  If
   "port" is not specified, it defaults to 1099.  If "remoteObjectName"
   is not specified, then the object being named is the RMI registry
   itself.  See [<a href="#ref-RMI" title='"Remote Method Invocation,"'>RMI</a>] for details.






<span class="grey">Ryan, et al.                 Informational                      [Page 7]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-8" id="page-8" name="page-8"> </a>
<span class="grey"><a href="rfc2713.html">RFC 2713</a>                Schema for Java Objects             October 1999</span>


   RMI can be supported using different protocols: the Java Remote
   Method Protocol (JRMP) and the Internet Inter-ORB Protocol (IIOP).
   The JRMP is a specialized protocol designed for RMI; the IIOP is the
   standard protocol for communication between CORBA objects [<a href="#ref-CORBA" title='"Common Object Request Broker Architecture Specification 2.0,"'>CORBA</a>].
   RMI over IIOP allows Java remote objects to communicate with CORBA
   objects which might be written in a non-Java programming language
   [<a href="#ref-RMI-IIOP" title='"RMI over IIOP"'>RMI-IIOP</a>].

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/2.5.1%20Representation%20in%20the%20Directory"></a><a class="selflink" href="#section-2.5.1" name="section-2.5.1">2.5.1</a> Representation in the Directory</span>

   Remote objects that use the IIOP are represented in the directory as
   CORBA object references [<a href="#ref-CORBA-LDAP" title='"Schema for Representing CORBA Object References in an LDAP Directory"'>CORBA-LDAP</a>].  Remote objects that use the
   JRMP are represented in the directory in one of two ways: as a
   marshalled object, or as a JNDI reference.

   A marshalled object records the codebases of the remote object's stub
   and any serializable or remote objects that it references, and
   replaces remote objects with their stubs.  To store a Remote object
   as a marshalled object (java.rmi.MarshalledObject), you first create
   a java.rmi.MarshalledObject instance for it.

       java.rmi.Remote robj = ...;
       java.rmi.MarshalledObject mobj =
           new java.rmi.MarshalledObject(robj);

   You can then store the MarshalledObject instance as a
   javaMarshalledObject.  The javaClassName attribute should contain the
   fully qualified name of the distinguished class of the remote object.
   The javaClassNames attribute should contain the names of the classes
   and interfaces of the remote object.  To read the remote object back
   from the directory, first deserialize the contents of the
   javaSerializedData to get a MarshalledObject (mobj), then retrieve it
   from the MarshalledObject as follows:

       java.rmi.Remote robj = (java.rmi.Remote)mobj.get();

   This returns the remote stub, which you can then use to invoke remote
   methods.

   MarshalledObject is available only on the Java 2 Platform, Standard
   Edition, v1.2 and higher releases. Therefore, a remote object stored
   as a MarshalledObject can only be read by clients using the the Java
   2 Platform, Standard Edition, v1.2 or higher releases.








<span class="grey">Ryan, et al.                 Informational                      [Page 8]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-9" id="page-9" name="page-9"> </a>
<span class="grey"><a href="rfc2713.html">RFC 2713</a>                Schema for Java Objects             October 1999</span>


   To store a remote object as a JNDI reference, you first create a
   javax.naming.Reference object instance for it using the remote
   object's string name as it has been, or will be, recorded with the
   RMI registry, with the additional restriction that the "rmi:" prefix
   must be present. Here's an example:

       javax.naming.Reference ref = new javax.naming.Reference(
         obj.getClass().getName(),
         new javax.naming.StringRefAddr("URL",
             "rmi://rserver/AppRemoteObjectX"));

   You then store the javax.naming.Reference instance as a
   javaNamingReference.  The advantage of using a JNDI reference is that
   this can be done without a reference to the remote object. In fact,
   the remote object does not have to exist at the time that this
   recording in the directory is made.  The remote object needs to exist
   and be bound with the RMI registry when the object is looked up from
   the directory.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/2.6%20%20Serialized%20Objects%20Vs.%20Marshalled%20Objects%20Vs.%20References"></a><a class="selflink" href="#section-2.6" name="section-2.6">2.6</a>  Serialized Objects Vs. Marshalled Objects Vs. References</span>

   The object classes defined in this document store different aspects
   of the Java objects.

   A javaSerializedObject or a serializable object stored as a
   javaMarshalledObject represents the object itself, while a
   javaNamingReference or a remote object stored as a
   javaMarshalledObject represents a "pointer" to the object.

   When storing a serializable object in the directory, you have a
   choice of storing it as a javaSerializedObject or a
   javaMarshalledObject.  The javaSerializedObject object class provides
   the basic way in which to store serializable objects. When you create
   an LDAP entry using the javaSerializableObject object class, you must
   explicitly set the javaCodebase attribute if you want readers of that
   entry to know where to load the class definitions of the object. When
   you create an LDAP entry using the javaMarshalledObject object class,
   you use the MarshalledObject class.  The MarshalledObject class uses
   the RMI infrastructure available on the Java platform to automate how
   codebase information is gathered and recorded, thus freeing you from
   having to set the javaCodebase attribute. On the other hand, the
   javaCodebase attribute is human-readable and can be updated easily by
   using text-based tools without having to change other parts of the
   entry.  This allows you, for instance, to move the class definitions
   to another location and then update the javaCodebase attribute to
   reflect the move without having to update the serialized object
   itself.




<span class="grey">Ryan, et al.                 Informational                      [Page 9]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-10" id="page-10" name="page-10"> </a>
<span class="grey"><a href="rfc2713.html">RFC 2713</a>                Schema for Java Objects             October 1999</span>


   A javaNamingReference provides a way of recording address information
   about an object which itself is not directly stored in the directory.
   A remote object stored as a javaMarshalledObject also records address
   information (the object's "stub") of an object which itself is not
   directory stored in the directory.  In other words, you can think of
   these as compact representations of the information required to
   access the object.

   A javaNamingReference typically consists of a small number of human-
   readable strings.  Standard text-based tools for directory
   administration may therefore be used to add, read, or modify
   reference entries -- if so desired -- quite easily.  Serialized and
   marshalled objects are not intended to be read or manipulated
   directly by humans.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/3%20Attribute%20Type%20Definitions"></a><a class="selflink" href="#section-3" name="section-3">3</a> Attribute Type Definitions</span>

   The following attribute types are defined in this document:

       javaClassName
       javaClassNames
       javaCodebase
       javaSerializedData
       javaFactory
       javaReferenceAddress
       javaDoc

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.1%20javaClassName"></a><a class="selflink" href="#section-3.1" name="section-3.1">3.1</a> javaClassName</span>

   This attribute stores the fully qualified name of the Java object's
   "distinguished" class or interface (for example, "java.lang.String").
   It is a single-valued attribute. This attribute's syntax is '
   Directory String' and its case is significant.

       ( 1.3.6.1.4.1.42.2.27.4.1.6
         NAME 'javaClassName'
         DESC 'Fully qualified name of distinguished Java class or
               interface'
         EQUALITY caseExactMatch
         SYNTAX 1.3.6.1.4.1.1466.115.121.1.15
         SINGLE-VALUE
       )









<span class="grey">Ryan, et al.                 Informational                     [Page 10]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-11" id="page-11" name="page-11"> </a>
<span class="grey"><a href="rfc2713.html">RFC 2713</a>                Schema for Java Objects             October 1999</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.2%20javaCodebase"></a><a class="selflink" href="#section-3.2" name="section-3.2">3.2</a> javaCodebase</span>

   This attribute stores the Java class definition's locations.  It
   specifies the locations from which to load the class definition for
   the class specified by the javaClassName attribute.  Each value of
   the attribute contains an ordered list of URLs, separated by spaces.
   For example, a value of "url1 url2 url3" means that the three
   (possibly interdependent) URLs (url1, url2, and url3) form the
   codebase for loading in the Java class definition.

   If the javaCodebase attribute contains more than one value, each
   value is an independent codebase. That is, there is no relationship
   between the URLs in one value and those in another; each value can be
   viewed as an alternate source for loading the Java class definition.
   See [<a href="#ref-Java" title='"The Java(tm) Programming Language,"'>Java</a>] for information regarding class loading.

   This attribute's syntax is 'IA5 String' and its case is significant.

       ( 1.3.6.1.4.1.42.2.27.4.1.7
         NAME 'javaCodebase'
         DESC 'URL(s) specifying the location of class definition'
         EQUALITY caseExactIA5Match
         SYNTAX 1.3.6.1.4.1.1466.115.121.1.26
       )

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.3%20javaClassNames"></a><a class="selflink" href="#section-3.3" name="section-3.3">3.3</a> javaClassNames</span>

   This attribute stores the Java object's fully qualified class or
   interface names (for example, "java.lang.String").  It is a
   multivalued attribute. When more than one value is present, each is
   the name of a class or interface, or ancestor class or interface, of
   this object.

   This attribute's syntax is 'Directory String' and its case is
   significant.

       ( 1.3.6.1.4.1.42.2.27.4.1.13
         NAME 'javaClassNames'
         DESC 'Fully qualified Java class or interface name'
         EQUALITY caseExactMatch
         SYNTAX 1.3.6.1.4.1.1466.115.121.1.15
       )









<span class="grey">Ryan, et al.                 Informational                     [Page 11]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-12" id="page-12" name="page-12"> </a>
<span class="grey"><a href="rfc2713.html">RFC 2713</a>                Schema for Java Objects             October 1999</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.4%20javaSerializedData"></a><a class="selflink" href="#section-3.4" name="section-3.4">3.4</a> javaSerializedData</span>

   This attribute stores the serialized form of a Java object.  The
   serialized form is described in [<a href="#ref-Serial" title='"Object Serialization Specification,"'>Serial</a>].

   This attribute's syntax is 'Octet String'.

       ( 1.3.6.1.4.1.42.2.27.4.1.8
         NAME 'javaSerializedData
         DESC 'Serialized form of a Java object'
         SYNTAX 1.3.6.1.4.1.1466.115.121.1.40
         SINGLE-VALUE
       )

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.5%20javaFactory"></a><a class="selflink" href="#section-3.5" name="section-3.5">3.5</a> javaFactory</span>

   This attribute stores the fully qualified class name of the object
   factory (for example, "com.wiz.jndi.WizObjectFactory") that can be
   used to create an instance of the object identified by the
   javaClassName attribute.

   This attribute's syntax is 'Directory String' and its case is
   significant.

       ( 1.3.6.1.4.1.42.2.27.4.1.10
         NAME 'javaFactory'
         DESC 'Fully qualified Java class name of a JNDI object factory'
         EQUALITY caseExactMatch
         SYNTAX 1.3.6.1.4.1.1466.115.121.1.15
         SINGLE-VALUE
       )

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.6%20javaReferenceAddress"></a><a class="selflink" href="#section-3.6" name="section-3.6">3.6</a> javaReferenceAddress</span>

   This attribute represents the sequence of addresses of a JNDI
   reference.  Each of its values represents one address, a Java object
   of type javax.naming.RefAddr.  Its value is a concatenation of the
   address type and address contents, preceded by a sequence number (the
   order of addresses in a JNDI reference is significant).  For example:

       #0#TypeA#ValA
       #1#TypeB#ValB
       #2#TypeC##rO0ABXNyABpq...

   In more detail, the value is encoded as follows:






<span class="grey">Ryan, et al.                 Informational                     [Page 12]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-13" id="page-13" name="page-13"> </a>
<span class="grey"><a href="rfc2713.html">RFC 2713</a>                Schema for Java Objects             October 1999</span>


   The delimiter is the first character of the value.  For readability
   the character '#' is recommended when it is not otherwise used
   anywhere in the value, but any character may be used subject to
   restrictions given below.

   The first delimiter is followed by the sequence number.  The sequence
   number of an address is its position in the JNDI reference, with the
   first address being numbered 0.  It is represented by its shortest
   string form, in decimal notation.

   The sequence number is followed by a delimiter, then by the address
   type, and then by another delimiter.  If the address is of Java class
   javax.naming.StringRefAddr, then this delimiter is followed by the
   value of the address contents (which is a string).  Otherwise, this
   delimiter is followed immediately by another delimiter, and then by
   the Base64 encoding of the serialized form of the entire address.

   The delimiter may be any character other than a digit or a character
   contained in the address type.  In addition, if the address contents
   is a string, the delimiter may not be the first character of that
   string.

   This attribute's syntax is 'Directory String' and its case is
   significant.  It can contain multiple values.

       ( 1.3.6.1.4.1.42.2.27.4.1.11
         NAME 'javaReferenceAddress'
         DESC 'Addresses associated with a JNDI Reference'
         EQUALITY caseExactMatch
         SYNTAX 1.3.6.1.4.1.1466.115.121.1.15
       )

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.7%20javaDoc"></a><a class="selflink" href="#section-3.7" name="section-3.7">3.7</a> javaDoc</span>

   This attribute stores a pointer to the Java documentation for the
   class.  It's value is a URL. For example, the following URL points to
   the specification of the java.lang.String class:
   <a href="http://java.sun.com/products/jdk/1.2/docs/api/java/lang/String.html">http://java.sun.com/products/jdk/1.2/docs/api/java/lang/String.html</a>

   This attribute's syntax is 'IA5 String' and its case is significant.

       ( 1.3.6.1.4.1.42.2.27.4.1.12
         NAME 'javaDoc'
         DESC 'The Java documentation for the class'
         EQUALITY caseExactIA5Match
         SYNTAX 1.3.6.1.4.1.1466.115.121.1.26
       )




<span class="grey">Ryan, et al.                 Informational                     [Page 13]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-14" id="page-14" name="page-14"> </a>
<span class="grey"><a href="rfc2713.html">RFC 2713</a>                Schema for Java Objects             October 1999</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/4%20Object%20Class%20Definitions"></a><a class="selflink" href="#section-4" name="section-4">4</a> Object Class Definitions</span>

   The following object classes are defined in this document:

       javaContainer
       javaObject
       javaSerializedObject
       javaMarshalledObject
       javaNamingReference

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.1%20javaContainer"></a><a class="selflink" href="#section-4.1" name="section-4.1">4.1</a> javaContainer</span>

   This structural object class represents a container for a Java
   object.

       ( 1.3.6.1.4.1.42.2.27.4.2.1
         NAME 'javaContainer'
         DESC 'Container for a Java object'
         SUP top
         STRUCTURAL
         MUST ( cn )
       )

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.2%20javaObject"></a><a class="selflink" href="#section-4.2" name="section-4.2">4.2</a> javaObject</span>

   This abstract object class represents a Java object.  A javaObject
   cannot exist in the directory; only auxiliary or structural
   subclasses of it can exist in the directory.

       ( 1.3.6.1.4.1.42.2.27.4.2.4
         NAME 'javaObject'
         DESC 'Java object representation'
         SUP top
         ABSTRACT
         MUST ( javaClassName )
         MAY ( javaClassNames $
               javaCodebase $
               javaDoc $
               description )
       )











<span class="grey">Ryan, et al.                 Informational                     [Page 14]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-15" id="page-15" name="page-15"> </a>
<span class="grey"><a href="rfc2713.html">RFC 2713</a>                Schema for Java Objects             October 1999</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.3%20javaSerializedObject"></a><a class="selflink" href="#section-4.3" name="section-4.3">4.3</a> javaSerializedObject</span>

   This auxiliary object class represents a Java serialized object.  It
   must be mixed in with a structural object class.

       ( 1.3.6.1.4.1.42.2.27.4.2.5
         NAME 'javaSerializedObject'
         DESC 'Java serialized object'
         SUP javaObject
         AUXILIARY
         MUST ( javaSerializedData )
       )

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.4%20javaMarshalledObject"></a><a class="selflink" href="#section-4.4" name="section-4.4">4.4</a> javaMarshalledObject</span>

   This auxiliary object class represents a Java marshalled object.  It
   must be mixed in with a structural object class.

       ( 1.3.6.1.4.1.42.2.27.4.2.8
         NAME 'javaMarshalledObject'
         DESC 'Java marshalled object'
         SUP javaObject
         AUXILIARY
         MUST ( javaSerializedData )
       )

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.5%20javaNamingReference"></a><a class="selflink" href="#section-4.5" name="section-4.5">4.5</a> javaNamingReference</span>

   This auxiliary object class represents a JNDI reference.  It must be
   mixed in with a structural object class.

       ( 1.3.6.1.4.1.42.2.27.4.2.7
         NAME 'javaNamingReference'
         DESC 'JNDI reference'
         SUP javaObject
         AUXILIARY
         MAY ( javaReferenceAddress $
               javaFactory )
       )












<span class="grey">Ryan, et al.                 Informational                     [Page 15]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-16" id="page-16" name="page-16"> </a>
<span class="grey"><a href="rfc2713.html">RFC 2713</a>                Schema for Java Objects             October 1999</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/5.%20Security%20Considerations"></a><a class="selflink" href="#section-5" name="section-5">5</a>. Security Considerations</span>

   Serializing an object and storing it into the directory enables (a
   copy of) the object to be examined and used outside the environment
   in which it was originally created.  The directory entry containing
   the serialized object could be read and modified within the
   constraints imposed by the access control mechanisms of the
   directory.  If an object contains sensitive information or
   information that could be misused outside of the context in which it
   was created, the object should not be stored in the directory.  For
   more details on security issues relating to serialization in general,
   see [<a href="#ref-Serial" title='"Object Serialization Specification,"'>Serial</a>].

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/6.%20Acknowledgements"></a><a class="selflink" href="#section-6" name="section-6">6</a>. Acknowledgements</span>

   We would like to thank Joseph Fialli, Peter Jones, Roger Riggs, Bob
   Scheifler, and Ann Wollrath of Sun Microsystems for their comments
   and suggestions.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/7.%20References"></a><a class="selflink" href="#section-7" name="section-7">7</a>. References</span>

   [<a id="ref-CORBA" name="ref-CORBA">CORBA</a>]      The Object Management Group, "Common Object Request
                Broker Architecture Specification 2.0,"
                <a href="http://www.omg.org/">http://www.omg.org</a>

   [<a id="ref-CORBA-LDAP" name="ref-CORBA-LDAP">CORBA-LDAP</a>] Ryan, V., Lee, R. and S. Seligman, "Schema for
                Representing CORBA Object References in an LDAP
                Directory", <a href="rfc2714.html">RFC 2714</a>, October 1999.

   [<a id="ref-Java" name="ref-Java">Java</a>]       Ken Arnold and James Gosling, "The Java(tm) Programming
                Language," Second Edition, ISBN 0-201-31006-6.

   [<a id="ref-JNDI" name="ref-JNDI">JNDI</a>]       Java Software, Sun Microsystems, Inc., "The Java(tm)
                Naming and Directory Interface (tm) Specification,"
                February 1998.  <a href="http://java.sun.com/products/jndi/">http://java.sun.com/products/jndi/</a>

   [<a id="ref-LDAPv3" name="ref-LDAPv3">LDAPv3</a>]     Wahl, M., Howes, T. and  S. Kille, "Lightweight
                Directory Access Protocol (v3)", <a href="rfc2251.html">RFC 2251</a>, December
                1997.

   [<a id="ref-RMI" name="ref-RMI">RMI</a>]        Java Software, Sun Microsystems, Inc., "Remote Method
                Invocation," November 1998.
                <a href="http://java.sun.com/products/jdk/1.2/docs/guide/rmi">http://java.sun.com/products/jdk/1.2/docs/guide/rmi</a>








<span class="grey">Ryan, et al.                 Informational                     [Page 16]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-17" id="page-17" name="page-17"> </a>
<span class="grey"><a href="rfc2713.html">RFC 2713</a>                Schema for Java Objects             October 1999</span>


   [<a id="ref-RMI-IIOP" name="ref-RMI-IIOP">RMI-IIOP</a>]   IBM and Java Software, Sun Microsystems, Inc., "RMI over
                IIOP", June 1999.
                <a href="http://java.sun.com/products/rmi-iiop/">http://java.sun.com/products/rmi-iiop/</a>

   [<a id="ref-Serial" name="ref-Serial">Serial</a>]     Java Software, Sun Microsystems, Inc., "Object
                Serialization Specification," November 1998.
                <a href="http://java.sun.com/products/jdk/1.2/docs/guide/serialization">http://java.sun.com/products/jdk/1.2/docs/guide/</a>
                <a href="http://java.sun.com/products/jdk/1.2/docs/guide/serialization">serialization</a>

   [<a id="ref-v3Schema" name="ref-v3Schema">v3Schema</a>]   Wahl, M., "A Summary of the X.500(96) User Schema for
                use with LDAPv3", <a href="rfc2256.html">RFC 2256</a>, December 1997.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/8.%20Authors%27%20Addresses"></a><a class="selflink" href="#section-8" name="section-8">8</a>. Authors' Addresses</span>

   Vincent Ryan
   Sun Microsystems, Inc.
   Mail Stop EDUB03
   901 San Antonio Road
   Palo Alto, CA 94303
   USA

   Phone: +353 1 819 9151
   EMail: vincent.ryan@ireland.sun.com


   Scott Seligman
   Sun Microsystems, Inc.
   Mail Stop UCUP02-209
   901 San Antonio Road
   Palo Alto, CA 94303
   USA

   Phone: +1 408 863 3222
   EMail: scott.seligman@eng.sun.com


   Rosanna Lee
   Sun Microsystems, Inc.
   Mail Stop UCUP02-206
   901 San Antonio Road
   Palo Alto, CA 94303
   USA

   Phone: +1 408 863 3221
   EMail: rosanna.lee@eng.sun.com






<span class="grey">Ryan, et al.                 Informational                     [Page 17]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-18" id="page-18" name="page-18"> </a>
<span class="grey"><a href="rfc2713.html">RFC 2713</a>                Schema for Java Objects             October 1999</span>


Appendix - LDAP Schema

  -- Attribute types --

  ( 1.3.6.1.4.1.42.2.27.4.1.6
    NAME 'javaClassName'
    DESC 'Fully qualified name of distinguished Java class or interface'
    EQUALITY caseExactMatch
    SYNTAX 1.3.6.1.4.1.1466.115.121.1.15
    SINGLE-VALUE
  )

  ( 1.3.6.1.4.1.42.2.27.4.1.7
    NAME 'javaCodebase'
    DESC 'URL(s) specifying the location of class definition'
    EQUALITY caseExactIA5Match
    SYNTAX 1.3.6.1.4.1.1466.115.121.1.26
  )

  ( 1.3.6.1.4.1.42.2.27.4.1.8
    NAME 'javaSerializedData'
    DESC 'Serialized form of a Java object'
    SYNTAX 1.3.6.1.4.1.1466.115.121.1.40
    SINGLE-VALUE
  )

  ( 1.3.6.1.4.1.42.2.27.4.1.10
    NAME 'javaFactory'
    DESC 'Fully qualified Java class name of a JNDI object factory'
    EQUALITY caseExactMatch
    SYNTAX 1.3.6.1.4.1.1466.115.121.1.15
    SINGLE-VALUE
  )

  ( 1.3.6.1.4.1.42.2.27.4.1.11
    NAME 'javaReferenceAddress'
    DESC 'Addresses associated with a JNDI Reference'
    EQUALITY caseExactMatch
    SYNTAX 1.3.6.1.4.1.1466.115.121.1.15
  )

  ( 1.3.6.1.4.1.42.2.27.4.1.12
    NAME 'javaDoc'
    DESC 'The Java documentation for the class'
    EQUALITY caseExactIA5Match
    SYNTAX 1.3.6.1.4.1.1466.115.121.1.26
  )




<span class="grey">Ryan, et al.                 Informational                     [Page 18]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-19" id="page-19" name="page-19"> </a>
<span class="grey"><a href="rfc2713.html">RFC 2713</a>                Schema for Java Objects             October 1999</span>


  ( 1.3.6.1.4.1.42.2.27.4.1.13
    NAME 'javaClassNames'
    DESC 'Fully qualified Java class or interface name'
    EQUALITY caseExactMatch
    SYNTAX 1.3.6.1.4.1.1466.115.121.1.15
  )

  -- from <a href="rfc2256.html">RFC-2256</a> --

  ( 2.5.4.13
    NAME 'description'
    EQUALITY caseIgnoreMatch
    SUBSTR caseIgnoreSubstringsMatch
    SYNTAX 1.3.6.1.4.1.1466.115.121.1.15{1024}
  )

  -- Object classes --

  ( 1.3.6.1.4.1.42.2.27.4.2.1
    NAME 'javaContainer'
    DESC 'Container for a Java object'
    SUP top
    STRUCTURAL
    MUST ( cn )
  )

  ( 1.3.6.1.4.1.42.2.27.4.2.4
    NAME 'javaObject'
    DESC 'Java object representation'
    SUP top
    ABSTRACT
    MUST ( javaClassName )
    MAY ( javaClassNames $ javaCodebase $ javaDoc $ description )
  )

  ( 1.3.6.1.4.1.42.2.27.4.2.5
    NAME 'javaSerializedObject'
    DESC 'Java serialized object'
    SUP javaObject
    AUXILIARY
    MUST ( javaSerializedData )
  )









<span class="grey">Ryan, et al.                 Informational                     [Page 19]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-20" id="page-20" name="page-20"> </a>
<span class="grey"><a href="rfc2713.html">RFC 2713</a>                Schema for Java Objects             October 1999</span>


  ( 1.3.6.1.4.1.42.2.27.4.2.7
    NAME 'javaNamingReference'
    DESC 'JNDI reference'
    SUP javaObject
    AUXILIARY
    MAY ( javaReferenceAddress $ javaFactory )
  )

  ( 1.3.6.1.4.1.42.2.27.4.2.8
    NAME 'javaMarshalledObject'
    DESC 'Java marshalled object'
    SUP javaObject
    AUXILIARY
    MUST ( javaSerializedData )
  )

  -- Matching rule from ISO X.520 --

  ( 2.5.13.5
    NAME 'caseExactMatch'
    SYNTAX 1.3.6.1.4.1.1466.115.121.1.15
  )





























<span class="grey">Ryan, et al.                 Informational                     [Page 20]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-21" id="page-21" name="page-21"> </a>
<span class="grey"><a href="rfc2713.html">RFC 2713</a>                Schema for Java Objects             October 1999</span>


Full Copyright Statement

   Copyright (C) The Internet Society (1999).  All Rights Reserved.

   This document and translations of it may be copied and furnished to
   others, and derivative works that comment on or otherwise explain it
   or assist in its implementation may be prepared, copied, published
   and distributed, in whole or in part, without restriction of any
   kind, provided that the above copyright notice and this paragraph are
   included on all such copies and derivative works.  However, this
   document itself may not be modified in any way, such as by removing
   the copyright notice or references to the Internet Society or other
   Internet organizations, except as needed for the purpose of
   developing Internet standards in which case the procedures for
   copyrights defined in the Internet Standards process must be
   followed, or as required to translate it into languages other than
   English.

   The limited permissions granted above are perpetual and will not be
   revoked by the Internet Society or its successors or assigns.

   This document and the information contained herein is provided on an
   "AS IS" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING
   TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING
   BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION
   HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF
   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.

Acknowledgement

   Funding for the RFC Editor function is currently provided by the
   Internet Society.



















Ryan, et al.                 Informational                     [Page 21]

</pre><br/>
    <span class="noprint"><small><small>Html markup produced by rfcmarkup 1.126, available from
      <a href="https://tools.ietf.org/tools/rfcmarkup/">https://tools.ietf.org/tools/rfcmarkup/</a>
    </small></small></span>
  </div>




</body><!-- Mirrored from tools.ietf.org/html/rfc2713 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 06 Mar 2018 23:18:51 GMT --></html>