<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml"><!-- Mirrored from tools.ietf.org/html/rfc103 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 06 Mar 2018 23:19:03 GMT --><!-- Added by HTTrack --><head><meta content="text/html;charset=utf-8" http-equiv="content-type"/><!-- /Added by HTTrack -->

    <meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
    <meta content="index,follow" name="robots"/>
    <meta content="rfcmarkup version 1.126" name="creator"/>
    <link href="http://purl.org/dc/elements/1.1/" rel="schema.DC"/>
<meta content="urn:ietf:rfc:103" name="DC.Identifier"/>
<meta content="R.B. Kalin" name="DC.Creator"/>
<meta content="February, 1971" name="DC.Date.Issued"/>
<meta content="Implementation of Interrupt Keys" name="DC.Title"/>

    <link href="https://tools.ietf.org/images/rfc.png" rel="icon" type="image/png"/>
    <link href="https://tools.ietf.org/images/rfc.png" rel="shortcut icon" type="image/png"/>
    <title>RFC 103 - Implementation of Interrupt Keys</title>
    
    
    <style type="text/css">
	@media only screen 
	  and (min-width: 992px)
	  and (max-width: 1199px) {
	    body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 768px)
	  and (max-width: 991px) {
            body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 480px)
	  and (max-width: 767px) {
            body { font-size: 11pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (max-width: 479px) {
            body { font-size: 8pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-device-width : 375px) 
	  and (max-device-width : 667px) {
            body { font-size: 9.5pt; }
            div.content { width: 96ex; margin: 0 1px; }
        }
	@media only screen 
	  and (min-device-width: 1200px) {
            body { font-size: 10pt; margin: 0 4em; }
            div.content { width: 96ex; margin: 0; }
        }
        h1, h2, h3, h4, h5, h6, .h1, .h2, .h3, .h4, .h5, .h6 {
	    font-weight: bold;
            line-height: 0pt;
            display: inline;
            white-space: pre;
            font-family: monospace;
            font-size: 1em;
	    font-weight: bold;
        }
        pre {
            font-size: 1em;
            margin-top: 0px;
            margin-bottom: 0px;
        }
	.pre {
	    white-space: pre;
	    font-family: monospace;
	}
	.header{
	    font-weight: bold;
	}
        .newpage {
            page-break-before: always;
        }
        .invisible {
            text-decoration: none;
            color: white;
        }
        a.selflink {
          color: black;
          text-decoration: none;
        }
        @media print {
            body {
                font-family: monospace;
                font-size: 10.5pt;
            }
            h1, h2, h3, h4, h5, h6 {
                font-size: 1em;
            }
        
            a:link, a:visited {
                color: inherit;
                text-decoration: none;
            }
            .noprint {
                display: none;
            }
        }
	@media screen {
	    .grey, .grey a:link, .grey a:visited {
		color: #777;
	    }
            .docinfo {
                background-color: #EEE;
            }
            .top {
                border-top: 7px solid #EEE;
            }
            .bgwhite  { background-color: white; }
            .bgred    { background-color: #F44; }
            .bggrey   { background-color: #666; }
            .bgbrown  { background-color: #840; }            
            .bgorange { background-color: #FA0; }
            .bgyellow { background-color: #EE0; }
            .bgmagenta{ background-color: #F4F; }
            .bgblue   { background-color: #66F; }
            .bgcyan   { background-color: #4DD; }
            .bggreen  { background-color: #4F4; }

            .legend   { font-size: 90%; }
            .cplate   { font-size: 70%; border: solid grey 1px; }
	}
    </style>
    <!--[if IE]>
    <style>
    body {
       font-size: 13px;
       margin: 10px 10px;
    }
    </style>
    <![endif]-->

    <script type="text/javascript"><!--
    function addHeaderTags() {
	var spans = document.getElementsByTagName("span");
	for (var i=0; i < spans.length; i++) {
	    var elem = spans[i];
	    if (elem) {
		var level = elem.getAttribute("class");
                if (level == "h1" || level == "h2" || level == "h3" || level == "h4" || level == "h5" || level == "h6") {
                    elem.innerHTML = "<"+level+">"+elem.innerHTML+"</"+level+">";		
                }
	    }
	}
    }
    var legend_html = "Colour legend:<br />      <table>         <tr><td>Unknown:</td>                   <td><span class='cplate bgwhite'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft:</td>                     <td><span class='cplate bgred'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Informational:</td>             <td><span class='cplate bgorange'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Experimental:</td>              <td><span class='cplate bgyellow'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Best Common Practice:</td>      <td><span class='cplate bgmagenta'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Proposed Standard:</td>         <td><span class='cplate bgblue'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft Standard (old designation):</td> <td><span class='cplate bgcyan'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Internet Standard:</td>         <td><span class='cplate bggreen'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Historic:</td>                  <td><span class='cplate bggrey'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Obsolete:</td>                  <td><span class='cplate bgbrown'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>     </table>";
    function showElem(id) {
        var elem = document.getElementById(id);
        elem.innerHTML = eval(id+"_html");
        elem.style.visibility='visible';
    }
    function hideElem(id) {
        var elem = document.getElementById(id);
        elem.style.visibility='hidden';        
        elem.innerHTML = "";
    }
    // -->
    </script>
</head>
<body onload="addHeaderTags()">
  <div class="content">
   <div style="height: 13px;">
      <div class="pre noprint docinfo bgwhite" onclick="showElem('legend');" onmouseout="hideElem('legend')" onmouseover="this.style.cursor='pointer';" style="height: 6px; position: absolute;" title="Click for colour legend.">                                                                        </div>
      <div class="docinfo noprint pre legend" id="legend" onmouseout="hideElem('legend');" onmouseover="showElem('legend');" style="position:absolute; top: 4px; left: 4ex; visibility:hidden; background-color: white; padding: 4px 9px 5px 7px; border: solid #345 1px; ">
      </div>
   </div>
<span class="pre noprint docinfo top">[<a href="index.html" title="Document search and retrieval page">Docs</a>] [<a href="https://tools.ietf.org/rfc/rfc103.txt" title="Plaintext version of this document">txt</a>|<a href="https://tools.ietf.org/pdf/rfc103" title="PDF version of this document">pdf</a>] [<a href="https://datatracker.ietf.org/doc/rfc103" title="IESG Datatracker information for this document">Tracker</a>]                                              </span><br/>
<span class="pre noprint docinfo">                                                                        </span><br/>
<span class="pre noprint docinfo">                                                                        </span><br/>
<span class="pre noprint docinfo">                                                                        </span><br/>
<pre>                                                NWG <a href="rfc103.html">RFC 103</a>
                                                NIC 5764


IMPLEMENTATION OF INTERRUPT KEYS


R B Kalin
MIT Lincoln Laboratory
<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/24%20Feb%201971"></a><a class="selflink" href="#section-24" name="section-24">24</a> Feb 1971</span>


    <span class="h1">The current protocol specifications contain a serious logical</span>
error in the implementation of the program interrupt function.  This
paper discusses the problem and offers a solution that is simple to
implement.

THE PROBLEM

    As found on most time-sharing systems the program interrupt key,
elsewhere known as the break key, or help request button, has two
functions.  It suspends temporarily the user process being run, and it
switches the keyboard input stream to a dormant supervisory process.
Unaccepted input typed prior to the interrupt request remains buffered
for the suspended user process.  Subsequent typing is sent to a
supervisory routine.

    The current NCP protocol implements only half this function.  It
pprovides, through use of INS and INR control messages, for the
suspension of a remote process, but it offers no mechanism for
notifying the remote host at what time the data stream should be
switched.  INR and INS messages are sent via the control link and
because messages on this link travel concurrently with those on the
user's keyboard input link, the receiving host can not rely on
relative arrival times as a source of synchronizing information.
Without such information the remote NCP can not know which input
characters are meant for the user process and which are meant for the
supervisory routine.

    A solution found on some systems to this problem is that of
mapping the interrupt signal into some code from the character set --
typically an ASCII control-C.  Unfortunately, this is not general
enough to be used within the ARPA network.  Some systems, eg. MULTICS,
make use of all available ASCII codes for other purposes, none are
available for such an assignment.  Even if such an assignment could be
made, there is the problem of getting the interrupt character to be
recognized by the remote host.  Buffers on that user link may be full
and the sending host may be unable to transmit the message containing



<span class="grey">Crocker                                                         [Page 1]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-2" id="page-2" name="page-2"> </a>
<span class="grey"><a href="rfc103.html">RFC 103</a>            Implementation of Interrupt Keys             February 1971</span>


the interrupt code.  If the remote user process loops without
accepting data, there is the possibility that its input buffers will
never become free and that the message will never get through.

    A partial answer is that of providing at the serving end a
teletype scanner process that is always hungry for input.  Because all
input messages are immediately consumed, buffers remain available and
interrupt codes can get through.  Unfortunately, this implies that at
times characters must be thrown away.  After being scanned there may
be no buffer space available for them.  While not critical during
console interactions -- users can type only when the program demands
input -- this defect prevents the scanner from being driven from a
text file.


A SOLUTION

    The following defines a solution to this problem for the case of
ASCII data streams.

1) Character messages should use eight bit fields for each character
code.

2) For all of the defined ASCII character codes the left most bit in
the eight bit field shall be zero.

3) An interrupt sync character ( arbitrarilly given the code octal 200
) should be placed in the data stream at the correct point in the
typing sequence.

4) All codes from octal 201 to octal 377 are officially to be ignored
by a receiving host.  Their use is reserved for additional control
information, should it become necessary.  Attempts to use them as
additional character codes will meet with resistance from PDP-10
systems that internally pack characters into seven bit fields.  Note
that this objection can not be made against the interrupt sync
character because it is filtered out by the system and never appears
in a user's input buffer.

5) Because of the possibility that there may be an insufficient
allocation to allow the user message containing the interrupt sync
character to be sent, the INR/INS mechanism currently defined must be
kept.  An INS control message should be sent at the time an interrupt
sync character is entered into a text stream. Upon its reception by
the foreign host, the attached process should be immediately suspended
and the associated input stream should be scanned.  If possible, all
input up to the interrupt sync character should be buffered for the
suspended process.  Once the sync character is found, the stream



<span class="grey">Crocker                                                         [Page 2]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-3" id="page-3" name="page-3"> </a>
<span class="grey"><a href="rfc103.html">RFC 103</a>            Implementation of Interrupt Keys             February 1971</span>


should be switched to the newly activated supervisory process.  If it
is not possible to buffer all of the user process's input, it can be
thrown away, and a error message returned to the user by the
supervisory process.  In either event it must be guaranteed that
outstanding input will be consumed and message buffers will be freed
so that pending character messages can be sent.

6) In the event that an interrupt sync character is received before
the matching INS, the user process should be suspended and the NCP
should wait for the INS before proceeding.

7) The function of the NCP is the above discussion can, of course, be
delegated a separate modulo, eg. a TELNET process.  If this is done,
the NCP can be transparent to message content.


COMMENTARY

    The proposed change to the second level protocol described herein
is not meant as a general solution, but rather as a specific patch to
the current NCP design with the intent of correcting a critical error.
Its more obvious deficiencies are...

1) It only works with seven bit code character streams.  No extensions
are allowed for EBCDIC, ASCII-8, or other large character sets.  No
provision is made for interrupting a process to which there is no
character stream, although the author knows of no case in which the
concept means more than closing the connection.

2) It requires the system to scan all data coming over an
interruptable connection.  Presumably this means that at the time the
connection is created, the receiving host must be told that this scan
is to be done.  Various techniques, both implicit and explicit, could
be used.

3) The technique is not immune to loss character boundaries within a
message nor can it tolerate INS control messages that do not have
matching sync characters, or vis versa.

4) It may not possible to get either the INS or the text message
containing the interrupt sync character to a remote host.  Possible
reasons include user console failure, local host failure, network
failure, blocked control link, insufficient allocation etc.  Under
such circumstances the remote process may loop indefinitely.


    The only comprehensive solution known to the interrupt
synchronization problem, those that avoid the above difficulties,



<span class="grey">Crocker                                                         [Page 3]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-4" id="page-4" name="page-4"> </a>
<span class="grey"><a href="rfc103.html">RFC 103</a>            Implementation of Interrupt Keys             February 1971</span>


require more than minor changes to the current NCP protocol.  Unless
simpler answers are suggested, their implementation must be postponed
until the next major design revision.

       [ This RFC was put into machine readable form for entry ]
         [ into the online RFC archives by Gert Doering 4/97 ]













































Crocker                                                         [Page 4]

</pre><br/>
    <span class="noprint"><small><small>Html markup produced by rfcmarkup 1.126, available from
      <a href="https://tools.ietf.org/tools/rfcmarkup/">https://tools.ietf.org/tools/rfcmarkup/</a>
    </small></small></span>
  </div>




</body><!-- Mirrored from tools.ietf.org/html/rfc103 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 06 Mar 2018 23:19:03 GMT --></html>