<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml"><!-- Mirrored from tools.ietf.org/html/rfc6507 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 06 Mar 2018 23:18:27 GMT --><!-- Added by HTTrack --><head><meta content="text/html;charset=utf-8" http-equiv="content-type"/><!-- /Added by HTTrack -->

    <meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
    <meta content="index,follow" name="robots"/>
    <meta content="rfcmarkup version 1.126" name="creator"/>
    <link href="http://purl.org/dc/elements/1.1/" rel="schema.DC"/>
<meta content="urn:ietf:rfc:6507" name="DC.Identifier"/>
<meta content="Many signature schemes currently in use rely on certificates for
authentication of identity. In Identity-based cryptography, this adds
unnecessary overhead and administration. The Elliptic Curve-based
Certificateless Signatures for Identity-based Encryption (ECCSI)
signature scheme described in this document is certificateless. This
scheme has the additional advantages of low bandwidth and low
computational requirements. This document is not an Internet Standards
Track specification; it is published for informational purposes." name="DC.Description.Abstract"/>
<meta content="Michael Groves &lt;Michael.Groves@cesg.gsi.gov.uk&gt;" name="DC.Creator"/>
<meta content="February, 2012" name="DC.Date.Issued"/>
<meta content="Elliptic Curve-Based Certificateless Signatures for Identity-Based Encryption (ECCSI)" name="DC.Title"/>

    <link href="https://tools.ietf.org/images/rfc.png" rel="icon" type="image/png"/>
    <link href="https://tools.ietf.org/images/rfc.png" rel="shortcut icon" type="image/png"/>
    <title>RFC 6507 - Elliptic Curve-Based Certificateless Signatures for Identity-Based Encryption (ECCSI)</title>
    
    
    <style type="text/css">
	@media only screen 
	  and (min-width: 992px)
	  and (max-width: 1199px) {
	    body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 768px)
	  and (max-width: 991px) {
            body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 480px)
	  and (max-width: 767px) {
            body { font-size: 11pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (max-width: 479px) {
            body { font-size: 8pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-device-width : 375px) 
	  and (max-device-width : 667px) {
            body { font-size: 9.5pt; }
            div.content { width: 96ex; margin: 0 1px; }
        }
	@media only screen 
	  and (min-device-width: 1200px) {
            body { font-size: 10pt; margin: 0 4em; }
            div.content { width: 96ex; margin: 0; }
        }
        h1, h2, h3, h4, h5, h6, .h1, .h2, .h3, .h4, .h5, .h6 {
	    font-weight: bold;
            line-height: 0pt;
            display: inline;
            white-space: pre;
            font-family: monospace;
            font-size: 1em;
	    font-weight: bold;
        }
        pre {
            font-size: 1em;
            margin-top: 0px;
            margin-bottom: 0px;
        }
	.pre {
	    white-space: pre;
	    font-family: monospace;
	}
	.header{
	    font-weight: bold;
	}
        .newpage {
            page-break-before: always;
        }
        .invisible {
            text-decoration: none;
            color: white;
        }
        a.selflink {
          color: black;
          text-decoration: none;
        }
        @media print {
            body {
                font-family: monospace;
                font-size: 10.5pt;
            }
            h1, h2, h3, h4, h5, h6 {
                font-size: 1em;
            }
        
            a:link, a:visited {
                color: inherit;
                text-decoration: none;
            }
            .noprint {
                display: none;
            }
        }
	@media screen {
	    .grey, .grey a:link, .grey a:visited {
		color: #777;
	    }
            .docinfo {
                background-color: #EEE;
            }
            .top {
                border-top: 7px solid #EEE;
            }
            .bgwhite  { background-color: white; }
            .bgred    { background-color: #F44; }
            .bggrey   { background-color: #666; }
            .bgbrown  { background-color: #840; }            
            .bgorange { background-color: #FA0; }
            .bgyellow { background-color: #EE0; }
            .bgmagenta{ background-color: #F4F; }
            .bgblue   { background-color: #66F; }
            .bgcyan   { background-color: #4DD; }
            .bggreen  { background-color: #4F4; }

            .legend   { font-size: 90%; }
            .cplate   { font-size: 70%; border: solid grey 1px; }
	}
    </style>
    <!--[if IE]>
    <style>
    body {
       font-size: 13px;
       margin: 10px 10px;
    }
    </style>
    <![endif]-->

    <script type="text/javascript"><!--
    function addHeaderTags() {
	var spans = document.getElementsByTagName("span");
	for (var i=0; i < spans.length; i++) {
	    var elem = spans[i];
	    if (elem) {
		var level = elem.getAttribute("class");
                if (level == "h1" || level == "h2" || level == "h3" || level == "h4" || level == "h5" || level == "h6") {
                    elem.innerHTML = "<"+level+">"+elem.innerHTML+"</"+level+">";		
                }
	    }
	}
    }
    var legend_html = "Colour legend:<br />      <table>         <tr><td>Unknown:</td>                   <td><span class='cplate bgwhite'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft:</td>                     <td><span class='cplate bgred'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Informational:</td>             <td><span class='cplate bgorange'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Experimental:</td>              <td><span class='cplate bgyellow'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Best Common Practice:</td>      <td><span class='cplate bgmagenta'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Proposed Standard:</td>         <td><span class='cplate bgblue'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft Standard (old designation):</td> <td><span class='cplate bgcyan'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Internet Standard:</td>         <td><span class='cplate bggreen'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Historic:</td>                  <td><span class='cplate bggrey'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Obsolete:</td>                  <td><span class='cplate bgbrown'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>     </table>";
    function showElem(id) {
        var elem = document.getElementById(id);
        elem.innerHTML = eval(id+"_html");
        elem.style.visibility='visible';
    }
    function hideElem(id) {
        var elem = document.getElementById(id);
        elem.style.visibility='hidden';        
        elem.innerHTML = "";
    }
    // -->
    </script>
</head>
<body onload="addHeaderTags()">
  <div class="content">
   <div style="height: 13px;">
      <div class="pre noprint docinfo bgorange" onclick="showElem('legend');" onmouseout="hideElem('legend')" onmouseover="this.style.cursor='pointer';" style="height: 6px; position: absolute;" title="Click for colour legend.">                                                                        </div>
      <div class="docinfo noprint pre legend" id="legend" onmouseout="hideElem('legend');" onmouseover="showElem('legend');" style="position:absolute; top: 4px; left: 4ex; visibility:hidden; background-color: white; padding: 4px 9px 5px 7px; border: solid #345 1px; ">
      </div>
   </div>
<span class="pre noprint docinfo top">[<a href="index.html" title="Document search and retrieval page">Docs</a>] [<a href="https://tools.ietf.org/rfc/rfc6507.txt" title="Plaintext version of this document">txt</a>|<a href="https://tools.ietf.org/pdf/rfc6507" title="PDF version of this document">pdf</a>] [<a href="https://tools.ietf.org/html/draft-groves-eccsi" title="draft-groves-eccsi">draft-groves-eccsi</a>] [<a href="https://datatracker.ietf.org/doc/rfc6507" title="IESG Datatracker information for this document">Tracker</a>] [<a href="https://tools.ietf.org/rfcdiff?difftype=--hwdiff&amp;url2=rfc6507" title="Inline diff (wdiff)">Diff1</a>] [<a href="https://tools.ietf.org/rfcdiff?url2=rfc6507" title="Side-by-side diff">Diff2</a>] [<a href="https://datatracker.ietf.org/ipr/search/?rfc=6507&amp;submit=rfc" title="IPR disclosures related to this document">IPR</a>]   </span><br/>
<span class="pre noprint docinfo">                                                                        </span><br/>
<span class="pre noprint docinfo">                                                           INFORMATIONAL</span><br/>
<span class="pre noprint docinfo">                                                                        </span><br/>
<pre>Internet Engineering Task Force (IETF)                         M. Groves
Request for Comments: 6507                                          CESG
Category: Informational                                    February 2012
ISSN: 2070-1721


            <span class="h1">Elliptic Curve-Based Certificateless Signatures</span>
                 <span class="h1">for Identity-Based Encryption (ECCSI)</span>

Abstract

   Many signature schemes currently in use rely on certificates for
   authentication of identity.  In Identity-based cryptography, this
   adds unnecessary overhead and administration.  The Elliptic Curve-
   based Certificateless Signatures for Identity-based Encryption
   (ECCSI) signature scheme described in this document is
   certificateless.  This scheme has the additional advantages of low
   bandwidth and low computational requirements.

Status of This Memo

   This document is not an Internet Standards Track specification; it is
   published for informational purposes.

   This document is a product of the Internet Engineering Task Force
   (IETF).  It has been approved for publication by the Internet
   Engineering Steering Group (IESG).  Not all documents approved by the
   IESG are a candidate for any level of Internet Standard; see <a href="rfc5741.html#section-2">Section</a>
   <a href="rfc5741.html#section-2">2 of RFC 5741</a>.

   Information about the current status of this document, any errata,
   and how to provide feedback on it may be obtained at
   <a href="http://www.rfc-editor.org/info/rfc6507">http://www.rfc-editor.org/info/rfc6507</a>.

Copyright Notice

   Copyright (c) 2012 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to <a href="https://tools.ietf.org/html/bcp78">BCP 78</a> and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (<a href="http://trustee.ietf.org/license-info">http://trustee.ietf.org/license-info</a>) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.



<span class="grey">Groves                        Informational                     [Page 1]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-2" id="page-2" name="page-2"> </a>
<span class="grey"><a href="rfc6507.html">RFC 6507</a>           ECCSI for Identity-Based Encryption     February 2012</span>


Table of Contents

   <a href="#section-1">1</a>. Introduction ....................................................<a href="#page-2">2</a>
      <a href="#section-1.1">1.1</a>. Requirements Terminology ...................................<a href="#page-3">3</a>
   <a href="#section-2">2</a>. Architecture ....................................................<a href="#page-3">3</a>
   <a href="#section-3">3</a>. Notation ........................................................<a href="#page-5">5</a>
      <a href="#section-3.1">3.1</a>. Arithmetic .................................................<a href="#page-5">5</a>
      <a href="#section-3.2">3.2</a>. Representations ............................................<a href="#page-6">6</a>
      <a href="#section-3.3">3.3</a>. Format of Material .........................................<a href="#page-6">6</a>
   <a href="#section-4">4</a>. Parameters ......................................................<a href="#page-7">7</a>
      <a href="#section-4.1">4.1</a>. Static Parameters ..........................................<a href="#page-7">7</a>
      <a href="#section-4.2">4.2</a>. Community Parameters .......................................<a href="#page-8">8</a>
   <a href="#section-5">5</a>. Algorithms ......................................................<a href="#page-8">8</a>
      <a href="#section-5.1">5.1</a>. User Key Material ..........................................<a href="#page-8">8</a>
           <a href="#section-5.1.1">5.1.1</a>. Algorithm for Constructing (SSK,PVT) Pair ...........<a href="#page-8">8</a>
           <a href="#section-5.1.2">5.1.2</a>. Algorithm for Validating a Received SSK .............<a href="#page-9">9</a>
      <a href="#section-5.2">5.2</a>. Signatures .................................................<a href="#page-9">9</a>
           <a href="#section-5.2.1">5.2.1</a>. Algorithm for Signing ...............................<a href="#page-9">9</a>
           <a href="#section-5.2.2">5.2.2</a>. Algorithm for Verifying ............................<a href="#page-10">10</a>
   <a href="#section-6">6</a>. Security Considerations ........................................<a href="#page-11">11</a>
   <a href="#section-7">7</a>. References .....................................................<a href="#page-13">13</a>
      <a href="#section-7.1">7.1</a>. Normative References ......................................<a href="#page-13">13</a>
      <a href="#section-7.2">7.2</a>. Informative References ....................................<a href="#page-13">13</a>
   <a href="#appendix-A">Appendix A</a>. Test Data..............................................<a href="#page-14">14</a>

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/1.%20%20Introduction"></a><a class="selflink" href="#section-1" name="section-1">1</a>.  Introduction</span>

   Digital signatures provide authentication services across a wide
   range of applications.  A chain of trust for such signatures is
   usually provided by certificates.  However, in low-bandwidth or other
   resource-constrained environments, the use of certificates might be
   undesirable.  This document describes an efficient scheme, ECCSI, for
   elliptic curve-based certificateless signatures, primarily intended
   for use with Identity-Based Encryption (IBE) schemes such as
   described in [<a href="rfc6508.html" title='"Sakai-Kasahara Key Encryption (SAKKE)"'>RFC6508</a>].  As certificates are not needed, the need to
   transmit or store them to authenticate each communication is
   obviated.  The algorithm has been developed by drawing on ideas set
   out by Arazi [<a href="#ref-BA" title='"Certification of DL/EC Keys"'>BA</a>] and is originally based upon the Elliptic Curve
   Digital Signature Algorithm [<a href="#ref-ECDSA" title='"Public Key Cryptography for the Financial Services Industry: The Elliptic Curve Digital Signature Algorithm (ECDSA)"'>ECDSA</a>], one of the most commonly used
   signature algorithms.

   The algorithm is for use in the following context:

      *  where there are two parties, a Signer and a Verifier;

      *  where short unambiguous Identifier strings are naturally
         associated to each of these parties;




<span class="grey">Groves                        Informational                     [Page 2]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-3" id="page-3" name="page-3"> </a>
<span class="grey"><a href="rfc6507.html">RFC 6507</a>           ECCSI for Identity-Based Encryption     February 2012</span>


      *  where a message is to be signed and then verified (e.g., for
         authenticating the initiating party during an Identity-based
         key establishment);

      *  where a common Key Management Service (KMS) provides a root of
         trust for both parties.

   The scheme does not rely on any web of trust between users.

   Authentication is provided in a single simplex transmission without
   per-session reference to any third party.  Thus, the scheme is
   particularly suitable in situations where the receiving party need
   not be active (or even enrolled) when the message to be authenticated
   is sent, or where the number of transmissions is to be minimized for
   efficiency.

   Instead of having a certificate, the Signer has an Identifier, to
   which his Secret Signing Key (SSK) (see <a href="#section-2">Section 2</a>) will have been
   cryptographically bound by means of a Public Validation Token (PVT)
   (see <a href="#section-2">Section 2</a>) by the KMS.  Unlike a traditional public key, this
   PVT requires no further explicit certification.

   The verification primitive within this scheme can be implemented
   using projective representation of elliptic curve points, without
   arithmetic field divisions, and without explicitly using the size of
   the underlying cryptographic group.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/1.1.%20%20Requirements%20Terminology"></a><a class="selflink" href="#section-1.1" name="section-1.1">1.1</a>.  Requirements Terminology</span>

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in [<a href="rfc2119.html" title='"Key words for use in RFCs to Indicate Requirement Levels"'>RFC2119</a>].

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/2.%20%20Architecture"></a><a class="selflink" href="#section-2" name="section-2">2</a>.  Architecture</span>

   A KMS provisions key material for a set of communicating devices (a
   "user community").  Each device within the user community MUST have
   an Identifier (ID), which can be formed by its peers.  These
   Identifiers MUST be unique to devices (or users), and MAY change over
   time.  As such, all applications of this signature scheme MUST define
   an unambiguous format for Identifiers.  We consider the situation
   where one device (the Signer) wishes to sign a message that it is
   sending to another (the Verifier).  Only the Signer's ID is used in
   the signature scheme.







<span class="grey">Groves                        Informational                     [Page 3]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-4" id="page-4" name="page-4"> </a>
<span class="grey"><a href="rfc6507.html">RFC 6507</a>           ECCSI for Identity-Based Encryption     February 2012</span>


   In advance, the KMS chooses its KMS Secret Authentication Key (KSAK),
   which is the root of trust for all other key material in the scheme.
   From this, the KMS derives the KMS Public Authentication Key (KPAK),
   which all devices will require in order to verify signatures.  This
   will be the root of trust for verification.

   Before verification of any signatures, members of the user community
   are supplied with the KPAK.  The supply of the KPAK MUST be
   authenticated by the KMS, and this authentication MUST be verified by
   each member of the user community.  Confidentiality protection MAY
   also be applied.

   In the description of the algorithms in this document, it is assumed
   that there is one KMS, one user community, and hence one KPAK.
   Applications MAY support multiple KPAKs, and some KPAKs could in fact
   be "private" to certain communities in certain circumstances.  The
   method for determining which KPAK to use (when more than one is
   available) is out of scope.

   The KMS generates and provisions key material for each device.  It
   MUST supply an SSK along with a PVT to all devices that are to send
   signed messages.  The mechanism by which these SSKs are provided MUST
   be secure, as the security of the authentication provided by ECCSI
   signatures is no stronger than the security of this supply channel.

   Before using the supplied key material (SSK, KPAK) to form
   signatures, the Sender MUST verify the key material (SSK) against the
   root of trust (KPAK) and against its own ID and its PVT, using the
   algorithm defined in <a href="#section-5.1.2">Section 5.1.2</a>.

   During the signing process, once the Signer has formed its message,
   it signs the message using its SSK.  It transmits the Signature
   (including the PVT), and MAY also transmit the message (in cases
   where the message is not known to the Verifier).  The Verifier MUST
   then use the message, Signature, and Sender ID in verification
   against the KPAK.

   This document specifies

      *  an algorithm for creating a KPAK from a KSAK, for a given
         elliptic curve;

      *  a format for transporting a KPAK;

      *  an algorithm for creating an SSK and a PVT from a Signer's ID,
         using the KSAK;





<span class="grey">Groves                        Informational                     [Page 4]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-5" id="page-5" name="page-5"> </a>
<span class="grey"><a href="rfc6507.html">RFC 6507</a>           ECCSI for Identity-Based Encryption     February 2012</span>


      *  an algorithm for verifying an SSK and a PVT against a Signer's
         ID and KPAK;

      *  an algorithm for creating a Signature from a message, using a
         Signer's ID with a matching SSK and PVT;

      *  a format for transporting a Signature;

      *  an algorithm for verifying a Signature for a message, using a
         Signer's ID with the matching KPAK.

   This document does not specify (but comments on)

      *  how to choose a valid and secure elliptic curve;

      *  which hash function to use;

      *  how to format a Signer's ID;

      *  how to format a message for signing;

      *  how to manage and install a KPAK;

      *  how to transport or install an SSK.

   As used in [<a href="rfc6509.html" title='"MIKEY-SAKKE: Sakai-Kasahara Key Encryption in Multimedia Internet KEYing (MIKEY)"'>RFC6509</a>], the elliptic curve and hash function are
   specified in <a href="rfc6509.html#section-2.1.1">Section 2.1.1 of [RFC6509]</a>, the format of Identifiers is
   specified in <a href="rfc6509.html#section-3.2">Section 3.2 of [RFC6509]</a>, and messages for signing are
   formatted as specified in [<a href="rfc3830.html" title='"MIKEY: Multimedia Internet KEYing"'>RFC3830</a>].

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/3.%20%20Notation"></a><a class="selflink" href="#section-3" name="section-3">3</a>.  Notation</span>

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.1.%20%20Arithmetic"></a><a class="selflink" href="#section-3.1" name="section-3.1">3.1</a>.  Arithmetic</span>

   ECCSI relies on elliptic curve arithmetic.  If P and Q are two
   elliptic curve points, their addition is denoted P + Q.  Moreover,
   the addition of P with itself k times is denoted [k]P.

   F_p denotes the finite field of p elements, where p is prime.  All
   elliptic curve points will be defined over F_p.

   The curve is defined by the equation y^2 = x^3 - 3*x + B modulo p,
   where B is an element of F_p.  Elliptic curve points, other than the
   group identity (0), are represented in the format P = (Px,Py), where
   Px and Py are the affine coordinates in F_p satisfying the above
   equation.  In particular, a point P = (Px,Py) is said to lie on an
   elliptic curve if Py^2 - Px^3 + 3*Px - B = 0 modulo p.  The identity
   point 0 will require no representation.



<span class="grey">Groves                        Informational                     [Page 5]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-6" id="page-6" name="page-6"> </a>
<span class="grey"><a href="rfc6507.html">RFC 6507</a>           ECCSI for Identity-Based Encryption     February 2012</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.2.%20%20Representations"></a><a class="selflink" href="#section-3.2" name="section-3.2">3.2</a>.  Representations</span>

   This section provides canonical representations of values that MUST
   be used to ensure interoperability of implementations.  The following
   representations MUST be used for input into hash functions and for
   transmission.  In this document, concatenation of octet strings s and
   t is denoted s || t.  The logarithm base 2 of a real number a is
   denoted lg(a).

   Integers           Integers MUST be represented as an octet string,
                      with bit length a multiple of 8.  To achieve this,
                      the integer is represented most significant bit
                      first, and padded with zero bits on the left until
                      an octet string of the necessary length is
                      obtained.  This is the octet string representation
                      described in <a href="rfc6090.html#section-6">Section 6 of [RFC6090]</a>.  There will
                      be no need to represent negative integers.  When
                      transmitted or hashed, such octet strings MUST
                      have length N = Ceiling(lg(p)/8).

   F_p elements       Elements of F_p MUST be represented as integers in
                      the range 0 to p-1 using the octet string
                      representation defined above.  For use in ECCSI,
                      such octet strings MUST have length N =
                      Ceiling(lg(p)/8).

   Points on E        Elliptic curve points MUST be represented in
                      uncompressed form ("affine coordinates") as
                      defined in <a href="rfc5480.html#section-2.2">Section 2.2 of [RFC5480]</a>.  For an
                      elliptic curve point (x,y) with x and y in F_p,
                      this representation is given by 0x04 || x' || y',
                      where x' is the N-octet string representing x and
                      y' is the N-octet string representing y.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.3.%20%20Format%20of%20Material"></a><a class="selflink" href="#section-3.3" name="section-3.3">3.3</a>.  Format of Material</span>

   This section describes the subfields of the different objects used
   within the protocol.

   Signature = r || s || PVT   where r and s are octet strings of length
                               N = Ceiling(lg(p)/8) representing
                               integers, and PVT is an octet string of
                               length 2N+1 representing an elliptic
                               curve point, yielding a total signature
                               length of 4N+1 octets.  (Note that r and






<span class="grey">Groves                        Informational                     [Page 6]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-7" id="page-7" name="page-7"> </a>
<span class="grey"><a href="rfc6507.html">RFC 6507</a>           ECCSI for Identity-Based Encryption     February 2012</span>


                               s represent integers rather than elements
                               of F_p, and therefore it is possible that
                               either or both of them could equal or
                               exceed p.)

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/4.%20%20Parameters"></a><a class="selflink" href="#section-4" name="section-4">4</a>.  Parameters</span>

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.1.%20%20Static%20Parameters"></a><a class="selflink" href="#section-4.1" name="section-4.1">4.1</a>.  Static Parameters</span>

   The following static parameters are fixed for each implementation.
   They are not intended to change frequently, and MUST be specified for
   each user community.  Note that these parameters MAY be shared across
   multiple KMSs.

      n                  A security parameter; the size in bits of the
                         prime p over which elliptic curve cryptography
                         is to be performed.

      N = Ceiling(n/8)   The number of octets used to represent fields r
                         and s in a Signature.  Also the number of
                         octets output by the hash function (see below).

      p                  A prime number of size n bits.  The finite
                         field with p elements is denoted F_p.

      E                  An elliptic curve defined over F_p, having a
                         subgroup of prime order q.

      B                  An element of F_p, where E is defined by the
                         formula y^2 = x^3 - 3*x + B modulo p.

      G                  A point on the elliptic curve E that generates
                         the subgroup of order q.

      q                  The prime q is defined to be the order of G in
                         E over F_p.

      Hash               A cryptographic hash function mapping arbitrary
                         strings to strings of N octets.  If a, b, c,
                         ... are strings, then hash( a || b || c || ...)
                         denotes the result obtained by hashing the
                         concatenation of these strings.

      Identifiers        The method for deriving user Identifiers.  The
                         format of Identifiers MUST be specified by each
                         implementation.  It MUST be possible for each
                         device to derive the Identifier for every
                         device with which it needs to communicate.  In



<span class="grey">Groves                        Informational                     [Page 7]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-8" id="page-8" name="page-8"> </a>
<span class="grey"><a href="rfc6507.html">RFC 6507</a>           ECCSI for Identity-Based Encryption     February 2012</span>


                         this document, ID will denote the correctly
                         formatted Identifier string of the Signer.
                         ECCSI makes use of the Signer Identifier only,
                         though an implementation MAY make use of other
                         Identifiers when constructing the message to be
                         signed.  Identifier formats MAY include a
                         timestamp to allow for automatic expiration of
                         key material.

   It is RECOMMENDED that p, E, and G are chosen to be standardized
   values.  In particular, it is RECOMMENDED that the curves and base
   points defined in [<a href="#ref-FIPS186-3" title='"Digital Signature Standard (DSS)"'>FIPS186-3</a>] be used.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.2.%20%20Community%20Parameters"></a><a class="selflink" href="#section-4.2" name="section-4.2">4.2</a>.  Community Parameters</span>

   The following community parameter MUST be supplied to devices each
   time the root of trust is changed.

      KPAK  The KMS Public Authentication Key (KPAK) is the root of
            trust for authentication.  It is derived from the KSAK in
            the KMS.  This value MUST be provisioned in a trusted
            fashion, such that each device that receives it has
            assurance that it is the genuine KPAK belonging to its KMS.
            Before use, each device MUST check that the supplied KPAK
            lies on the elliptic curve E.

   The KMS MUST fix the KPAK to be KPAK = [KSAK]G, where the KSAK MUST
   be chosen to be a random secret non-zero integer modulo q.  The value
   of the KSAK MUST be kept secret to the KMS.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/5.%20%20Algorithms"></a><a class="selflink" href="#section-5" name="section-5">5</a>.  Algorithms</span>

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.1.%20%20User%20Key%20Material"></a><a class="selflink" href="#section-5.1" name="section-5.1">5.1</a>.  User Key Material</span>

   To create signatures, each Signer requires a Secret Signing Key (SSK)
   and a Public Validation Token (PVT).  The SSK is an integer, and the
   PVT is an elliptic curve point.  The SSK MUST be kept secret (to the
   Signer and KMS), but the PVT need not be kept secret.  A different
   (SSK,PVT) pair will be needed for each Signer ID.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/5.1.1.%20%20Algorithm%20for%20Constructing%20%28SSK%2CPVT%29%20Pair"></a><a class="selflink" href="#section-5.1.1" name="section-5.1.1">5.1.1</a>.  Algorithm for Constructing (SSK,PVT) Pair</span>

   The KMS constructs a (SSK,PVT) pair from the Signer's ID, the KMS
   secret (KSAK), and the root of trust (KPAK).  To do this, the KMS
   MUST perform the following procedure:






<span class="grey">Groves                        Informational                     [Page 8]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-9" id="page-9" name="page-9"> </a>
<span class="grey"><a href="rfc6507.html">RFC 6507</a>           ECCSI for Identity-Based Encryption     February 2012</span>


      1) Choose v, a random (ephemeral) non-zero element of F_q;

      2) Compute PVT = [v]G (this MUST be represented canonically -- see
         <a href="#section-3.2">Section 3.2</a>);

      3) Compute a hash value HS = hash( G || KPAK || ID || PVT ),
         an N-octet integer;

      4) Compute SSK = ( KSAK + HS * v ) modulo q;

      5) If either the SSK or HS is zero modulo q, the KMS MUST erase
         the SSK and abort or restart the procedure with a fresh value
         of v;

      6) Output the (SSK,PVT) pair.  The KMS MUST then erase the value
         v.

   The method for transporting the SSK to the legitimate Signer device
   is out of scope for this document, but the SSK MUST be provisioned by
   the KMS using a method that protects its confidentiality.

   If necessary, the KMS MAY create multiple (SSK,PVT) pairs for the
   same Identifier.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/5.1.2.%20%20Algorithm%20for%20Validating%20a%20Received%20SSK"></a><a class="selflink" href="#section-5.1.2" name="section-5.1.2">5.1.2</a>.  Algorithm for Validating a Received SSK</span>

   Every SSK MUST be validated before being installed as a signing key.
   The Signer uses its ID and the KPAK to validate a received (SSK,PVT)
   pair.  To do this validation, the Signer MUST perform the following
   procedure, passing all checks:

      1) Validate that the PVT lies on the elliptic curve E;

      2) Compute HS = hash( G || KPAK || ID || PVT ), an N-octet
         integer.  The integer HS SHOULD be stored with the SSK for
         later use;

      3) Validate that KPAK = [SSK]G - [HS]PVT.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.2.%20%20Signatures"></a><a class="selflink" href="#section-5.2" name="section-5.2">5.2</a>.  Signatures</span>

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/5.2.1.%20%20Algorithm%20for%20Signing"></a><a class="selflink" href="#section-5.2.1" name="section-5.2.1">5.2.1</a>.  Algorithm for Signing</span>

   To sign a message (M), the Signer requires

      *  the KMS Public Authentication Key, KPAK;

      *  the Signer's own Identifier, ID;



<span class="grey">Groves                        Informational                     [Page 9]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-10" id="page-10" name="page-10"> </a>
<span class="grey"><a href="rfc6507.html">RFC 6507</a>           ECCSI for Identity-Based Encryption     February 2012</span>


      *  its Secret Signing Key, SSK;

      *  its Public Validation Token, PVT = (PVTx,PVTy).

   These values, with the exception of ID, MUST have been provided by
   the KMS.  The value of ID is derived by the Signer using the
   community-defined method for formatting Identifiers.

   The following procedure MUST be used by the Signer to compute the
   signature:

      1) Choose a random (ephemeral) non-zero value j in F_q;

      2) Compute J = [j]G (this MUST be represented canonically).
         Viewing J in affine coordinates J = (Jx,Jy), assign to r the
         N-octet integer representing Jx;

      3) Recall (or recompute) HS, and use it to compute a hash value
         HE = hash( HS || r || M );

      4) Verify that HE + r * SSK is non-zero modulo q; if this check
         fails, the Signer MUST abort or restart this procedure with a
         fresh value of j;

      5) Compute s' = ( (( HE + r * SSK )^-1) * j ) modulo q; the Signer
         MUST then erase the value j;

      6) If s' is too big to fit within an N-octet integer, then set the
         N-octet integer s = q - s'; otherwise, set the N-octet integer
         s = s' (note that since p is less than 2^n, by Hasse's theorem
         on elliptic curves, q &lt; 2^n + 2^(n/2 + 1) + 1.  Therefore, if
         s' &gt; 2^n, we have q - s' &lt; 2(n/2 + 1) + 1.  Thus, s is
         guaranteed to fit within an N-octet integer);

      7) Output the signature as Signature = ( r || s || PVT ).

   Note that step 6) is necessary because it is possible for q (and
   hence for elements of F_q) to be too big to fit within N octets.  The
   Signer MAY instead elect to set s to be the least integer of s' and
   q - s', represented in N octets.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/5.2.2.%20%20Algorithm%20for%20Verifying"></a><a class="selflink" href="#section-5.2.2" name="section-5.2.2">5.2.2</a>.  Algorithm for Verifying</span>

   The algorithm provided assumes that the Verifier computes points on
   elliptic curves using affine coordinates.  However, the Verifier MAY
   perform elliptic curve operations using any appropriate
   representation of points that achieves the equivalent operations.




<span class="grey">Groves                        Informational                    [Page 10]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-11" id="page-11" name="page-11"> </a>
<span class="grey"><a href="rfc6507.html">RFC 6507</a>           ECCSI for Identity-Based Encryption     February 2012</span>


   To verify a Signature ( r || s || PVT ) against a Signer's Identifier
   (ID), a message (M), and a pre-installed root of trust (KPAK), the
   Verifier MUST perform a procedure equivalent to the following:

      1) The Verifier MUST check that the PVT lies on the elliptic
         curve E;

      2) Compute HS = hash( G || KPAK || ID || PVT );

      3) Compute HE = hash( HS || r || M );

      4) Y = [HS]PVT + KPAK;

      5) Compute J = [s]( [HE]G + [r]Y );

      6) Viewing J in affine coordinates (Jx,Jy), the Verifier MUST
         check that Jx = r modulo p, and that Jx modulo p is non-zero,
         before accepting the Signature as valid.

   It is anticipated that the ID, message (M), and KPAK will be
   implicitly understood due to context, but any of these values MAY
   also be included in signaling.

   Note that the parameter q is not needed during verification.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/6.%20%20Security%20Considerations"></a><a class="selflink" href="#section-6" name="section-6">6</a>.  Security Considerations</span>

   The ECCSI cryptographic algorithm is based upon [<a href="#ref-ECDSA" title='"Public Key Cryptography for the Financial Services Industry: The Elliptic Curve Digital Signature Algorithm (ECDSA)"'>ECDSA</a>].  In fact,
   step 5) in the verification algorithm above is the same as the
   verification stage in ECDSA.  The only difference between ECDSA and
   ECCSI is that in ECCSI the 'public key', Y, is derived from the
   Signer ID by the Verifier (whereas in ECDSA the public key is fixed).
   It is therefore assumed that the security of ECCSI depends entirely
   on the secrecy of the secret keys.  In addition, to recover secret
   keys, one will need to perform computationally intensive
   cryptanalytic attacks.

   The KSAK provides the security for each device provisioned by the
   KMS.  It MUST NOT be revealed to any entity other than the KMS that
   holds it.  Each user's SSK authenticates the user as being associated
   with the ID to which the SSK is assigned by the KMS.  This key MUST
   NOT be revealed to any entity other than the KMS and the authorized
   user.

   The order of the base point G used in ECCSI MUST be a large prime q.
   If k bits of symmetric security are needed, Ceiling(lg(q)) MUST be at
   least 2*k.




<span class="grey">Groves                        Informational                    [Page 11]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-12" id="page-12" name="page-12"> </a>
<span class="grey"><a href="rfc6507.html">RFC 6507</a>           ECCSI for Identity-Based Encryption     February 2012</span>


   It is RECOMMENDED that the curves and base points defined in
   [<a href="#ref-FIPS186-3" title='"Digital Signature Standard (DSS)"'>FIPS186-3</a>] be used, since these curves are suitable for
   cryptographic use.  However, if other curves are used, the security
   of the curves MUST be assessed.

   In order to ensure that the SSK is only received by an authorized
   device, it MUST be provided through a secure channel.  The strength
   of the authentication offered by this signature scheme is no greater
   than the security provided by this delivery channel.

   Identifiers MUST be defined unambiguously by each application of
   ECCSI.  Note that it is not necessary to use a hash function to
   compose an Identifier string.  In this way, any weaknesses that might
   otherwise be caused by collisions in hash functions can be avoided
   without reliance on the structure of the Identifier format.
   Applications of ECCSI MAY include a time/date component in their
   Identifier format to ensure that Identifiers (and hence SSKs) are
   only valid for a fixed period of time.

   The use of the ephemeral value r in the hash HE significantly reduces
   the scope for offline attacks, improving the overall security, as
   compared to [<a href="#ref-ECDSA" title='"Public Key Cryptography for the Financial Services Industry: The Elliptic Curve Digital Signature Algorithm (ECDSA)"'>ECDSA</a>].  Furthermore, if Identifiers are specified to
   contain date-stamps, then all Identifiers, SSKs, signatures, and hash
   values will periodically become deprecated automatically, reducing
   the need for revocation and other additional management methods.

   The randomness of values stipulated to be selected at random, as
   described in this document, is essential to the security provided by
   ECCSI.  If the value of the KSAK can be predicted, then any
   signatures can be forged.  Similarly, if the value of v used by the
   KMS to create a user's SSK can be predicted, then the value of the
   KSAK could be recovered, which would allow signatures to be forged.
   If the value of j used by a user is predictable, then the value of
   his SSK could be recovered.  This would allow that user's signatures
   to be forged.  Guidance on the generation of random values for
   security can be found in [<a href="rfc4086.html" title='"Randomness Requirements for Security"'>RFC4086</a>].

   Note that in most instances, the value s in the Signature can be
   replaced by q - s.  Thus, the malleability of ECCSI signatures is
   similar to that in [<a href="#ref-ECDSA" title='"Public Key Cryptography for the Financial Services Industry: The Elliptic Curve Digital Signature Algorithm (ECDSA)"'>ECDSA</a>]; malleability is available but also very
   limited.










<span class="grey">Groves                        Informational                    [Page 12]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-13" id="page-13" name="page-13"> </a>
<span class="grey"><a href="rfc6507.html">RFC 6507</a>           ECCSI for Identity-Based Encryption     February 2012</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/7.%20%20References"></a><a class="selflink" href="#section-7" name="section-7">7</a>.  References</span>

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/7.1.%20%20Normative%20References"></a><a class="selflink" href="#section-7.1" name="section-7.1">7.1</a>.  Normative References</span>

   [<a id="ref-ECDSA" name="ref-ECDSA">ECDSA</a>]      X9.62-2005, "Public Key Cryptography for the Financial
                Services Industry: The Elliptic Curve Digital Signature
                Algorithm (ECDSA)", November 2005.

   [<a id="ref-FIPS186-3" name="ref-FIPS186-3">FIPS186-3</a>]  Federal Information Processing Standards Publication
                (FIPS PUB) 186-3, "Digital Signature Standard (DSS)",
                June 2009.

   [<a id="ref-RFC2119" name="ref-RFC2119">RFC2119</a>]    Bradner, S., "Key words for use in RFCs to Indicate
                Requirement Levels", <a href="https://tools.ietf.org/html/bcp14">BCP 14</a>, <a href="rfc2119.html">RFC 2119</a>, March 1997.

   [<a id="ref-RFC5480" name="ref-RFC5480">RFC5480</a>]    Turner, S., Brown, D., Yiu, K., Housley, R., and T.
                Polk, "Elliptic Curve Cryptography Subject Public Key
                Information", <a href="rfc5480.html">RFC 5480</a>, March 2009.

   [<a id="ref-RFC6090" name="ref-RFC6090">RFC6090</a>]    McGrew, D., Igoe, K., and M. Salter, "Fundamental
                Elliptic Curve Cryptography Algorithms", <a href="rfc6090.html">RFC 6090</a>,
                February 2011.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/7.2.%20%20Informative%20References"></a><a class="selflink" href="#section-7.2" name="section-7.2">7.2</a>.  Informative References</span>

   [<a id="ref-BA" name="ref-BA">BA</a>]         Arazi, Benjamin, "Certification of DL/EC Keys", paper
                submitted to P1363 meeting, August 1998,
                &lt;<a href="http://grouper.ieee.org/groups/1363/StudyGroup/contributions/arazi.doc">http://grouper.ieee.org/groups/1363/StudyGroup/</a>
                <a href="http://grouper.ieee.org/groups/1363/StudyGroup/contributions/arazi.doc">contributions/arazi.doc</a>&gt;.

   [<a id="ref-FIPS180-3" name="ref-FIPS180-3">FIPS180-3</a>]  Federal Information Processing Standards Publication
                (FIPS PUB) 180-3, "Secure Hash Standard (SHS)",
                October 2008.

   [<a id="ref-RFC3830" name="ref-RFC3830">RFC3830</a>]    Arkko, J., Carrara, E., Lindholm, F., Naslund, M., and
                K. Norrman, "MIKEY: Multimedia Internet KEYing",
                <a href="rfc3830.html">RFC 3830</a>, August 2004.

   [<a id="ref-RFC4086" name="ref-RFC4086">RFC4086</a>]    Eastlake 3rd, D., Schiller, J., and S. Crocker,
                "Randomness Requirements for Security", <a href="https://tools.ietf.org/html/bcp106">BCP 106</a>,
                <a href="rfc4086.html">RFC 4086</a>, June 2005.

   [<a id="ref-RFC6508" name="ref-RFC6508">RFC6508</a>]    Groves, M., "Sakai-Kasahara Key Encryption (SAKKE)",
                <a href="rfc6508.html">RFC 6508</a>, February 2012.

   [<a id="ref-RFC6509" name="ref-RFC6509">RFC6509</a>]    Groves, M., "MIKEY-SAKKE: Sakai-Kasahara Key Encryption
                in Multimedia Internet KEYing (MIKEY)", <a href="rfc6509.html">RFC 6509</a>,
                February 2012.



<span class="grey">Groves                        Informational                    [Page 13]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-14" id="page-14" name="page-14"> </a>
<span class="grey"><a href="rfc6507.html">RFC 6507</a>           ECCSI for Identity-Based Encryption     February 2012</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/Appendix%20A.%20%20Test%20Data"></a><a class="selflink" href="#appendix-A" name="appendix-A">Appendix A</a>.  Test Data</span>

   This appendix provides test data built from the NIST P-256 curve and
   base point.  SHA-256 (as defined in [<a href="#ref-FIPS180-3" title='"Secure Hash Standard (SHS)"'>FIPS180-3</a>]) is used as the hash
   function.  The keys and ephemerals -- KSAK, v, and j -- are arbitrary
   and for illustration only.

      // --------------------------------------------------------
      // Global parameters

      n       := 256;

      N       := 32;

      p       := 0x   FFFFFFFF 00000001 00000000 00000000
                      00000000 FFFFFFFF FFFFFFFF FFFFFFFF;

      Hash    := SHA-256;

      // --------------------------------------------------------
      // Community parameters

      B       := 0x   5AC635D8 AA3A93E7 B3EBBD55 769886BC
                      651D06B0 CC53B0F6 3BCE3C3E 27D2604B;

      q       := 0x   FFFFFFFF 00000000 FFFFFFFF FFFFFFFF
                      BCE6FAAD A7179E84 F3B9CAC2 FC632551;

      G       := 0x   04
                      6B17D1F2 E12C4247 F8BCE6E5 63A440F2
                      77037D81 2DEB33A0 F4A13945 D898C296
                      4FE342E2 FE1A7F9B 8EE7EB4A 7C0F9E16
                      2BCE3357 6B315ECE CBB64068 37BF51F5;

      KSAK    := 0x   12345;

      KPAK    := 0x   04
                      50D4670B DE75244F 28D2838A 0D25558A
                      7A72686D 4522D4C8 273FB644 2AEBFA93
                      DBDD3755 1AFD263B 5DFD617F 3960C65A
                      8C298850 FF99F203 66DCE7D4 367217F4;

      // --------------------------------------------------------
      // Signer ID

      ID      := "2011-02\0tel:+447700900123\0",
               = 0x   3230 31312D30 32007465 6C3A2B34
                      34373730 30393030 31323300;



<span class="grey">Groves                        Informational                    [Page 14]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-15" id="page-15" name="page-15"> </a>
<span class="grey"><a href="rfc6507.html">RFC 6507</a>           ECCSI for Identity-Based Encryption     February 2012</span>


      // --------------------------------------------------------
      // Creating SSK and PVT

      v       := 0x   23456;

      PVT     := 0x   04
                      758A1427 79BE89E8 29E71984 CB40EF75
                      8CC4AD77 5FC5B9A3 E1C8ED52 F6FA36D9
                      A79D2476 92F4EDA3 A6BDAB77 D6AA6474
                      A464AE49 34663C52 65BA7018 BA091F79;

      HS      := hash( 0x 04
                          6B17D1F2 E12C4247 F8BCE6E5 63A440F2
                          77037D81 2DEB33A0 F4A13945 D898C296
                          4FE342E2 FE1A7F9B 8EE7EB4A 7C0F9E16
                          2BCE3357 6B315ECE CBB64068 37BF51F5
                          04
                          50D4670B DE75244F 28D2838A 0D25558A
                          7A72686D 4522D4C8 273FB644 2AEBFA93
                          DBDD3755 1AFD263B 5DFD617F 3960C65A
                          8C298850 FF99F203 66DCE7D4 367217F4
                          32303131 2D303200 74656C3A 2B343437

                          37303039 30303132 3300
                          04
                          758A1427 79BE89E8 29E71984 CB40EF75
                          8CC4AD77 5FC5B9A3 E1C8ED52 F6FA36D9
                          A79D2476 92F4EDA3 A6BDAB77 D6AA6474
                          A464AE49 34663C52 65BA7018 BA091F79 ),

               = 0x       490F3FEB BC1C902F 6289723D 7F8CBF79
                          DB889308 49D19F38 F0295B5C 276C14D1;

      SSK     := 0x       23F374AE 1F4033F3 E9DBDDAA EF20F4CF
                          0B86BBD5 A138A5AE 9E7E006B 34489A0D;

      // --------------------------------------------------------
      // Creating a Signature

      M       := "message\0",
               = 0x   6D657373 61676500;

      j       := 0x   34567;








<span class="grey">Groves                        Informational                    [Page 15]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-16" id="page-16" name="page-16"> </a>
<span class="grey"><a href="rfc6507.html">RFC 6507</a>           ECCSI for Identity-Based Encryption     February 2012</span>


      J       := 0x   04
                      269D4C8F DEB66A74 E4EF8C0D 5DCC597D
                      DFE6029C 2AFFC493 6008CD2C C1045D81
                      6DDA6A13 10F4B067 BD5DABDA D741B7CE
                      F36457E1 96B1BFA9 7FD5F8FB B3926ADB;

      r       := 0x   269D4C8F DEB66A74 E4EF8C0D 5DCC597D
                      DFE6029C 2AFFC493 6008CD2C C1045D81;

      HE      := hash( 0x
                      490F3FEB BC1C902F 6289723D 7F8CBF79
                      DB889308 49D19F38 F0295B5C 276C14D1
                      269D4C8F DEB66A74 E4EF8C0D 5DCC597D
                      DFE6029C 2AFFC493 6008CD2C C1045D81
                      6D657373 61676500 ),

               = 0x   111F90EA E8271C96 DF9B3D67 26768D9E
                      E9B18145 D7EC152C FA9C23D1 C4F02285;

      s'      := 0x   E09B528D 0EF8D6DF 1AA3ECBF 80110CFC
                      EC9FC682 52CEBB67 9F413484 6940CCFD;

      s       := 0x   E09B528D 0EF8D6DF 1AA3ECBF 80110CFC
                      EC9FC682 52CEBB67 9F413484 6940CCFD;

      Sig     := 0x   269D4C8F DEB66A74 E4EF8C0D 5DCC597D
                      DFE6029C 2AFFC493 6008CD2C C1045D81
                      E09B528D 0EF8D6DF 1AA3ECBF 80110CFC
                      EC9FC682 52CEBB67 9F413484 6940CCFD
                      04

                      758A1427 79BE89E8 29E71984 CB40EF75
                      8CC4AD77 5FC5B9A3 E1C8ED52 F6FA36D9
                      A79D2476 92F4EDA3 A6BDAB77 D6AA6474
                      A464AE49 34663C52 65BA7018 BA091F79;

      // --------------------------------------------------------
      // Verifying a Signature

      Y       := 0x   04
                      833898D9 39C0013B B0502728 6F95CCE0
                      37C11BD2 5799423C 76E48362 A4959978
                      95D0473A 1CD6186E E9F0C104 B472499E
                      1A24D6CE 3D85173F 02EBBD94 5C25F604;







<span class="grey">Groves                        Informational                    [Page 16]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-17" id="page-17" name="page-17"> </a>
<span class="grey"><a href="rfc6507.html">RFC 6507</a>           ECCSI for Identity-Based Encryption     February 2012</span>


      J       := 0x   04
                      269D4C8F DEB66A74 E4EF8C0D 5DCC597D
                      DFE6029C 2AFFC493 6008CD2C C1045D81
                      6DDA6A13 10F4B067 BD5DABDA D741B7CE
                      F36457E1 96B1BFA9 7FD5F8FB B3926ADB;

      Jx      := 0x   269D4C8F DEB66A74 E4EF8C0D 5DCC597D
                      DFE6029C 2AFFC493 6008CD2C C1045D81;

      Jx = r  modulo p

      // --------------------------------------------------------

Author's Address

   Michael Groves
   CESG
   Hubble Road
   Cheltenham
   GL51 8HJ
   UK

   EMail: Michael.Groves@cesg.gsi.gov.uk




























Groves                        Informational                    [Page 17]

</pre><br/>
    <span class="noprint"><small><small>Html markup produced by rfcmarkup 1.126, available from
      <a href="https://tools.ietf.org/tools/rfcmarkup/">https://tools.ietf.org/tools/rfcmarkup/</a>
    </small></small></span>
  </div>




</body><!-- Mirrored from tools.ietf.org/html/rfc6507 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 06 Mar 2018 23:18:27 GMT --></html>