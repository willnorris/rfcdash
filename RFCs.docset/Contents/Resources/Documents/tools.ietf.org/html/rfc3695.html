<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml"><!-- Mirrored from tools.ietf.org/html/rfc3695 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 06 Mar 2018 23:18:46 GMT --><!-- Added by HTTrack --><head><meta content="text/html;charset=utf-8" http-equiv="content-type"/><!-- /Added by HTTrack -->

    <meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
    <meta content="index,follow" name="robots"/>
    <meta content="rfcmarkup version 1.126" name="creator"/>
    <link href="http://purl.org/dc/elements/1.1/" rel="schema.DC"/>
<meta content="urn:ietf:rfc:3695" name="DC.Identifier"/>
<meta content="This document introduces some Forward Error Correction (FEC) schemes
that supplement the FEC schemes described in RFC 3452. The primary
benefits of these additional FEC schemes are that they are designed
for reliable bulk delivery of large objects using a more compact FEC
Payload ID, and they can be used to sequentially deliver blocks of an
object of indeterminate length. Thus, they more flexibly support
different delivery models with less packet header overhead. This
document also describes the Fully-Specified FEC scheme corresponding
to FEC Encoding ID 0. This Fully-Specified FEC scheme requires no FEC
coding and is introduced primarily to allow simple interoperability
testing between different implementations of protocol instantiations
that use the FEC building block. This memo defines an Experimental
Protocol for the Internet community." name="DC.Description.Abstract"/>
<meta content="Vicisano, Lorenzo" name="DC.Creator"/>
<meta content="Luby, Michael" name="DC.Creator"/>
<meta content="February, 2004" name="DC.Date.Issued"/>
<meta content="Compact Forward Error Correction (FEC) Schemes" name="DC.Title"/>

    <link href="https://tools.ietf.org/images/rfc.png" rel="icon" type="image/png"/>
    <link href="https://tools.ietf.org/images/rfc.png" rel="shortcut icon" type="image/png"/>
    <title>RFC 3695 - Compact Forward Error Correction (FEC) Schemes</title>
    
    
    <style type="text/css">
	@media only screen 
	  and (min-width: 992px)
	  and (max-width: 1199px) {
	    body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 768px)
	  and (max-width: 991px) {
            body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 480px)
	  and (max-width: 767px) {
            body { font-size: 11pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (max-width: 479px) {
            body { font-size: 8pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-device-width : 375px) 
	  and (max-device-width : 667px) {
            body { font-size: 9.5pt; }
            div.content { width: 96ex; margin: 0 1px; }
        }
	@media only screen 
	  and (min-device-width: 1200px) {
            body { font-size: 10pt; margin: 0 4em; }
            div.content { width: 96ex; margin: 0; }
        }
        h1, h2, h3, h4, h5, h6, .h1, .h2, .h3, .h4, .h5, .h6 {
	    font-weight: bold;
            line-height: 0pt;
            display: inline;
            white-space: pre;
            font-family: monospace;
            font-size: 1em;
	    font-weight: bold;
        }
        pre {
            font-size: 1em;
            margin-top: 0px;
            margin-bottom: 0px;
        }
	.pre {
	    white-space: pre;
	    font-family: monospace;
	}
	.header{
	    font-weight: bold;
	}
        .newpage {
            page-break-before: always;
        }
        .invisible {
            text-decoration: none;
            color: white;
        }
        a.selflink {
          color: black;
          text-decoration: none;
        }
        @media print {
            body {
                font-family: monospace;
                font-size: 10.5pt;
            }
            h1, h2, h3, h4, h5, h6 {
                font-size: 1em;
            }
        
            a:link, a:visited {
                color: inherit;
                text-decoration: none;
            }
            .noprint {
                display: none;
            }
        }
	@media screen {
	    .grey, .grey a:link, .grey a:visited {
		color: #777;
	    }
            .docinfo {
                background-color: #EEE;
            }
            .top {
                border-top: 7px solid #EEE;
            }
            .bgwhite  { background-color: white; }
            .bgred    { background-color: #F44; }
            .bggrey   { background-color: #666; }
            .bgbrown  { background-color: #840; }            
            .bgorange { background-color: #FA0; }
            .bgyellow { background-color: #EE0; }
            .bgmagenta{ background-color: #F4F; }
            .bgblue   { background-color: #66F; }
            .bgcyan   { background-color: #4DD; }
            .bggreen  { background-color: #4F4; }

            .legend   { font-size: 90%; }
            .cplate   { font-size: 70%; border: solid grey 1px; }
	}
    </style>
    <!--[if IE]>
    <style>
    body {
       font-size: 13px;
       margin: 10px 10px;
    }
    </style>
    <![endif]-->

    <script type="text/javascript"><!--
    function addHeaderTags() {
	var spans = document.getElementsByTagName("span");
	for (var i=0; i < spans.length; i++) {
	    var elem = spans[i];
	    if (elem) {
		var level = elem.getAttribute("class");
                if (level == "h1" || level == "h2" || level == "h3" || level == "h4" || level == "h5" || level == "h6") {
                    elem.innerHTML = "<"+level+">"+elem.innerHTML+"</"+level+">";		
                }
	    }
	}
    }
    var legend_html = "Colour legend:<br />      <table>         <tr><td>Unknown:</td>                   <td><span class='cplate bgwhite'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft:</td>                     <td><span class='cplate bgred'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Informational:</td>             <td><span class='cplate bgorange'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Experimental:</td>              <td><span class='cplate bgyellow'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Best Common Practice:</td>      <td><span class='cplate bgmagenta'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Proposed Standard:</td>         <td><span class='cplate bgblue'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft Standard (old designation):</td> <td><span class='cplate bgcyan'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Internet Standard:</td>         <td><span class='cplate bggreen'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Historic:</td>                  <td><span class='cplate bggrey'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Obsolete:</td>                  <td><span class='cplate bgbrown'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>     </table>";
    function showElem(id) {
        var elem = document.getElementById(id);
        elem.innerHTML = eval(id+"_html");
        elem.style.visibility='visible';
    }
    function hideElem(id) {
        var elem = document.getElementById(id);
        elem.style.visibility='hidden';        
        elem.innerHTML = "";
    }
    // -->
    </script>
</head>
<body onload="addHeaderTags()">
  <div class="content">
   <div style="height: 13px;">
      <div class="pre noprint docinfo bgbrown" onclick="showElem('legend');" onmouseout="hideElem('legend')" onmouseover="this.style.cursor='pointer';" style="height: 6px; position: absolute;" title="Click for colour legend.">                                                                        </div>
      <div class="docinfo noprint pre legend" id="legend" onmouseout="hideElem('legend');" onmouseover="showElem('legend');" style="position:absolute; top: 4px; left: 4ex; visibility:hidden; background-color: white; padding: 4px 9px 5px 7px; border: solid #345 1px; ">
      </div>
   </div>
<span class="pre noprint docinfo top">[<a href="index.html" title="Document search and retrieval page">Docs</a>] [<a href="https://tools.ietf.org/rfc/rfc3695.txt" title="Plaintext version of this document">txt</a>|<a href="https://tools.ietf.org/pdf/rfc3695" title="PDF version of this document">pdf</a>] [<a href="https://tools.ietf.org/html/draft-ietf-rmt-bb-fec-supp-compact" title="draft-ietf-rmt-bb-fec-supp-compact">draft-ietf-rmt-...</a>] [<a href="https://datatracker.ietf.org/doc/rfc3695" title="IESG Datatracker information for this document">Tracker</a>] [<a href="https://tools.ietf.org/rfcdiff?difftype=--hwdiff&amp;url2=rfc3695" title="Inline diff (wdiff)">Diff1</a>] [<a href="https://tools.ietf.org/rfcdiff?url2=rfc3695" title="Side-by-side diff">Diff2</a>]         </span><br/>
<span class="pre noprint docinfo">                                                                        </span><br/>
<span class="pre noprint docinfo">Obsoleted by: <a href="rfc5445.html">5445</a>                                          EXPERIMENTAL</span><br/>
<span class="pre noprint docinfo">                                                                        </span><br/>
<pre>Network Working Group                                            M. Luby
Request for Comments: 3695                              Digital Fountain
Category: Experimental                                       L. Vicisano
                                                                   Cisco
                                                           February 2004


             <span class="h1">Compact Forward Error Correction (FEC) Schemes</span>

Status of this Memo

   This memo defines an Experimental Protocol for the Internet
   community.  It does not specify an Internet standard of any kind.
   Discussion and suggestions for improvement are requested.
   Distribution of this memo is unlimited.

Copyright Notice

   Copyright (C) The Internet Society (2004).  All Rights Reserved.

Abstract

   This document introduces some Forward Error Correction (FEC) schemes
   that supplement the FEC schemes described in <a href="rfc3452.html">RFC 3452</a>.  The primary
   benefits of these additional FEC schemes are that they are designed
   for reliable bulk delivery of large objects using a more compact FEC
   Payload ID, and they can be used to sequentially deliver blocks of an
   object of indeterminate length.  Thus, they more flexibly support
   different delivery models with less packet header overhead.

   This document also describes the Fully-Specified FEC scheme
   corresponding to FEC Encoding ID 0.  This Fully-Specified FEC scheme
   requires no FEC coding and is introduced primarily to allow simple
   interoperability testing between different implementations of
   protocol instantiations that use the FEC building block.

Table of Contents

   <a href="#section-1">1</a>.  Introduction . . . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-2">2</a>
   <a href="#section-2">2</a>.  Packet Header Fields . . . . . . . . . . . . . . . . . . . . .  <a href="#page-3">3</a>
       <a href="#section-2.1">2.1</a>.  FEC Payload ID for FEC Encoding IDs 0 and 130. . . . . .  <a href="#page-4">4</a>
       <a href="#section-2.2">2.2</a>.  Compact No-Code FEC scheme . . . . . . . . . . . . . . .  <a href="#page-5">5</a>
       <a href="#section-2.3">2.3</a>.  Compact FEC scheme . . . . . . . . . . . . . . . . . . .  <a href="#page-5">5</a>
   <a href="#section-3">3</a>.  Compact No-Code FEC scheme . . . . . . . . . . . . . . . . . .  <a href="#page-6">6</a>
       <a href="#section-3.1">3.1</a>.  Source Block Logistics . . . . . . . . . . . . . . . . .  <a href="#page-7">7</a>
       <a href="#section-3.2">3.2</a>.  Sending and Receiving a Source Block . . . . . . . . . .  <a href="#page-8">8</a>
   <a href="#section-4">4</a>.  Usage Examples . . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-9">9</a>
       <a href="#section-4.1">4.1</a>.  Reliable Bulk Data Delivery. . . . . . . . . . . . . . .  <a href="#page-9">9</a>



<span class="grey">Luby &amp; Vicisano               Experimental                      [Page 1]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-2" id="page-2" name="page-2"> </a>
<span class="grey"><a href="rfc3695.html">RFC 3695</a>                      FEC Schemes                  February 2004</span>


       <a href="#section-4.2">4.2</a>.  Block-Stream Delivery. . . . . . . . . . . . . . . . . . <a href="#page-10">10</a>
   <a href="#section-5">5</a>.  Security Considerations. . . . . . . . . . . . . . . . . . . . <a href="#page-10">10</a>
   <a href="#section-6">6</a>.  IANA Considerations. . . . . . . . . . . . . . . . . . . . . . <a href="#page-10">10</a>
   <a href="#section-7">7</a>.  References . . . . . . . . . . . . . . . . . . . . . . . . . . <a href="#page-11">11</a>
       <a href="#section-7.1">7.1</a>.  Normative References . . . . . . . . . . . . . . . . . . <a href="#page-11">11</a>
       <a href="#section-7.2">7.2</a>.  Informative References . . . . . . . . . . . . . . . . . <a href="#page-12">12</a>
   <a href="#section-8">8</a>.  Authors' Addresses . . . . . . . . . . . . . . . . . . . . . . <a href="#page-12">12</a>
   <a href="#section-9">9</a>.  Full Copyright Statement . . . . . . . . . . . . . . . . . . . <a href="#page-13">13</a>

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/1.%20%20Introduction"></a><a class="selflink" href="#section-1" name="section-1">1</a>.  Introduction</span>

   This document describes two new Forward Error Correction (FEC)
   schemes corresponding to FEC Encoding IDs 0 and 130 which supplement
   the FEC schemes corresponding to FEC Encoding IDs 128 and 129
   described in the FEC Building Block [<a href="#ref-4" title='"Forward Error Correction (FEC) Building Block"'>4</a>].

   The new FEC schemes are particularly applicable when an object is
   partitioned into equal-length source blocks.  In this case, the
   source block length common to all source blocks can be communicated
   out-of-band, thus saving the additional overhead of carrying the
   source block length within the FEC Payload ID of each packet.  The
   new FEC schemes are similar to the FEC schemes with FEC Encoding ID
   128 defined in <a href="rfc3452.html">RFC 3452</a> [<a href="#ref-4" title='"Forward Error Correction (FEC) Building Block"'>4</a>], except that the FEC Payload ID is half
   as long.  This is the reason that these new FEC schemes are called
   Compact FEC schemes.

   The primary focus of FEC Encoding IDs 128 and 129 is to reliably
   deliver bulk objects of known length.  The FEC schemes described in
   this document are designed to be used for both reliable delivery of
   bulk objects of known length, and for the delivery of a stream of
   source blocks for an object of indeterminate length.  Within the
   block-stream delivery model, reliability guarantees can range from
   acknowledged reliable delivery of each block to unacknowledged
   enhanced-reliability delivery of time-sensitive blocks, depending on
   the properties of the protocol instantiation in which the FEC scheme
   is used.  Acknowledged reliable block-stream delivery is similar in
   spirit to the byte-stream delivery that TCP offers, except that the
   unit of delivery is a block of data instead of a byte of data.  In
   the spirit of a building block (see <a href="rfc3048.html">RFC 3048</a> [<a href="#ref-6" title='"Reliable Multicast Transport Building Blocks for One-to-Many Bulk-Data Transfer"'>6</a>]), the FEC schemes
   described in this document can be used to provide reliability for
   other service models as well.

   The two new FEC Encoding IDs 0 and 130 are described in <a href="#section-2">Section 2</a>,
   and this supplements <a href="#section-5">Section 5</a> of the FEC building block [<a href="#ref-4" title='"Forward Error Correction (FEC) Building Block"'>4</a>].
   <a href="#section-3">Section 3</a> of this document describes the Fully-Specified FEC scheme
   corresponding to the FEC Encoding ID 0.  This Fully-Specified FEC





<span class="grey">Luby &amp; Vicisano               Experimental                      [Page 2]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-3" id="page-3" name="page-3"> </a>
<span class="grey"><a href="rfc3695.html">RFC 3695</a>                      FEC Schemes                  February 2004</span>


   scheme requires no FEC coding and is specified primarily to allow
   simple interoperability testing between different implementations of
   protocol instantiations that use the FEC building block.

   This document inherits the context, language, declarations and
   restrictions of the FEC building block [<a href="#ref-4" title='"Forward Error Correction (FEC) Building Block"'>4</a>].  This document also uses
   the terminology of the companion document [<a href="#ref-7" title='"The Use of Forward Error Correction (FEC) in Reliable Multicast"'>7</a>] which describes the use
   of FEC codes within the context of reliable IP multicast transport
   and provides an introduction to some commonly used FEC codes.

   Building blocks are defined in <a href="rfc3048.html">RFC 3048</a> [<a href="#ref-6" title='"Reliable Multicast Transport Building Blocks for One-to-Many Bulk-Data Transfer"'>6</a>].  This document is a
   product of the IETF RMT WG and follows the general guidelines
   provided in <a href="rfc3269.html">RFC 3269</a> [<a href="#ref-3" title='"Author Guidelines for Reliable Multicast Transport (RMT) Building Blocks and Protocol Instantiation Documents"'>3</a>].

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in <a href="rfc2119.html">RFC 2119</a> [<a href="#ref-2" title='"Key words for use in RFCs to Indicate Requirement Levels"'>2</a>].

Statement of Intent

   This memo contains part of the definitions necessary to fully specify
   a Reliable Multicast Transport (RMT) protocol in accordance with <a href="rfc2357.html">RFC</a>
   <a href="rfc2357.html">2357</a> [<a href="#ref-5" title='"IETF Criteria for Evaluating Reliable Multicast Transport and Application Protocols"'>5</a>].  As per <a href="rfc2357.html">RFC 2357</a>, the use of any reliable multicast
   protocol in the Internet requires an adequate congestion control
   scheme.

   While waiting for such a scheme to be available, or for an existing
   scheme to be proven adequate, the RMT working group publishes this
   Request for Comments in the "Experimental" category.

   It is the intent of RMT to re-submit this specification as an IETF
   Proposed Standard as soon as the above condition is met.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/2.%20%20Packet%20Header%20Fields"></a><a class="selflink" href="#section-2" name="section-2">2</a>.  Packet Header Fields</span>

   This section specifies FEC Encoding IDs 0 and 130 and the associated
   FEC Payload ID formats and the specific information in the
   corresponding FEC Object Transmission Information.  The FEC scheme
   associated with FEC Encoding ID 0 is Fully-Specified whereas the FEC
   schemes associated with FEC Encoding ID 130 are Under-Specified.

   FEC Encoding IDs 0 and 130 have the same FEC Payload ID format, which
   is described in the following subsection.  The FEC Object
   Transmission Information for FEC Encoding IDs 0 and 130 is different,
   and is described in the subsequent two subsections.






<span class="grey">Luby &amp; Vicisano               Experimental                      [Page 3]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-4" id="page-4" name="page-4"> </a>
<span class="grey"><a href="rfc3695.html">RFC 3695</a>                      FEC Schemes                  February 2004</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/2.1.%20%20FEC%20Payload%20ID%20for%20FEC%20Encoding%20IDs%200%20and%20130"></a><a class="selflink" href="#section-2.1" name="section-2.1">2.1</a>.  FEC Payload ID for FEC Encoding IDs 0 and 130</span>

   The FEC Payload ID for FEC Encoding IDs 0 and 130 is composed of a
   Source Block Number and an Encoding Symbol ID structured as follows:

     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |     Source Block Number       |      Encoding Symbol ID       |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

   The 16-bit Source Block Number is used to identify from which source
   block of the object the encoding symbol in the payload of the packet
   is generated.  There are two possible modes: In the unique SBN mode
   each source block within the object has a unique Source Block Number
   associated with it, and in the non-unique SBN mode the same Source
   Block Number may be used for more than one source block within the
   object.  Which mode is being used for an object is outside the scope
   of this document and MUST be communicated, either explicitly or
   implicitly, out-of-band to receivers.

   If the unique SBN mode is used then successive Source Block Numbers
   are associated with consecutive source blocks of the object starting
   with Source Block Number 0 for the first source block of the object.
   In this case, there are at most 2^16 source blocks in the object.

   If the non-unique SBN mode is used then the mapping from source
   blocks to Source Block Numbers MUST be communicated out-of-band to
   receivers, and how this is done is outside the scope of this
   document.  This mapping could be implicit, for example determined by
   the transmission order of the source blocks.   In non-unique SBN
   mode, packets for two different source blocks mapped to the same
   Source Block Number SHOULD NOT be sent within an interval of time
   that is shorter than the transport time of a source block.  The
   transport time of a source block includes the amount of time the
   source block is processed at the transport layer by the sender, the
   network transit time for packets, and the amount of time the source
   block is processed at the transport layer by a receiver.  This allows
   the receiver to clearly decide which packets belong to which source
   block.

   The 16-bit Encoding Symbol ID identifies which specific encoding
   symbol generated from the source block is carried in the packet
   payload.  The exact details of the correspondence between Encoding
   Symbol IDs and the encoding symbols in the packet payload for FEC
   Encoding ID 0 are specified in <a href="#section-3">Section 3</a>.  The exact details of the
   correspondence between Encoding Symbol IDs and the encoding symbol(s)
   in the packet payload for FEC Encoding ID 130 are dependent on the



<span class="grey">Luby &amp; Vicisano               Experimental                      [Page 4]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-5" id="page-5" name="page-5"> </a>
<span class="grey"><a href="rfc3695.html">RFC 3695</a>                      FEC Schemes                  February 2004</span>


   particular encoding algorithm used as identified by the FEC Encoding
   ID and by the FEC Instance ID.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/2.2.%20%20Compact%20No-Code%20FEC%20scheme"></a><a class="selflink" href="#section-2.2" name="section-2.2">2.2</a>.  Compact No-Code FEC scheme</span>

   This subsection reserves FEC Encoding ID 0 for the Compact No-Code
   FEC scheme described in this subsection and in <a href="#section-3">Section 3</a>.  This is a
   Fully-Specified FEC scheme that is primarily intended to be used for
   simple interoperability testing between different implementations of
   protocol instantiations that use the FEC building block.  The value
   of this FEC scheme is that no FEC encoding or decoding is required to
   implement it and therefore it is easy to test interoperability
   between protocols that may use different proprietary FEC schemes in
   production in their first implementations.

   The FEC Payload ID format for FEC Encoding ID 0 is described in
   Sub<a href="#section-2.1">section 2.1</a>.  The FEC Object Transmission Information has the
   following specific information:

   o The FEC Encoding ID 0.

   o For each source block of the object, the length in bytes of the
     encoding symbol carried in the packet payload.  This length MUST be
     the same for all packets sent for the same source block, but MAY be
     different for different source blocks in the same object.

   o For each source block of the object, the length of the source block
     in bytes.  Typically, each source block for the object has the same
     length and thus only one length common to all source blocks need be
     communicated, but this is not a requirement.  For convenience, the
     source block length MAY be a multiple of the length of the encoding
     symbol carried in one packet payload.

   How this out-of-band information is communicated is outside the scope
   of this document.

   Other information, such as the object length and the number of source
   blocks of the object for an object of known length may be needed by a
   receiver to support some delivery models, i.e., reliable bulk data
   delivery.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/2.3.%20%20Compact%20FEC%20scheme"></a><a class="selflink" href="#section-2.3" name="section-2.3">2.3</a>.  Compact FEC scheme</span>

   This subsection reserves FEC Encoding ID 130 for the Compact FEC
   scheme that is described in this subsection.  This is an
   Under-Specified FEC scheme.  This FEC scheme is similar in spirit to
   the Compact No-Code FEC scheme, except that a non-trivial FEC
   encoding (that is Under-Specified) may be used to generate encoding



<span class="grey">Luby &amp; Vicisano               Experimental                      [Page 5]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-6" id="page-6" name="page-6"> </a>
<span class="grey"><a href="rfc3695.html">RFC 3695</a>                      FEC Schemes                  February 2004</span>


   symbol(s) placed in the payload of each packet and a corresponding
   FEC decoder may be used to produce the source block from received
   packets.

   The FEC Payload ID format for FEC Encoding ID 0 is described in
   Sub<a href="#section-2.1">section 2.1</a>.  The FEC Object Transmission Information has the
   following specific information:

   o The FEC Encoding ID 130.

   o The FEC Instance ID associated with the FEC Encoding ID 130 to be
     used.

   o For each source block of the object, the aggregate length of the
     encoding symbol(s) carried in one packet payload.  This length MUST
     be the same for all packets sent for the same source block, but MAY
     be different for different source blocks in the same object.

   o For each source block of the object, the length of the source block
     in bytes.  Typically, each source block for the object has the same
     length and thus only one length common to all source blocks need to
     be communicated, but this is not a requirement.  For convenience,
     the source block length MAY be a multiple of the aggregate length
     of the encoding symbol(s) carried in one packet payload.

   How this out-of-band information is communicated is outside the scope
   of this document.

   Other information, such as the object length and the number of source
   blocks of the object for an object of known length may be needed by a
   receiver to support some delivery models, i.e., reliable bulk data
   delivery.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/3.%20%20Compact%20No-Code%20FEC%20scheme"></a><a class="selflink" href="#section-3" name="section-3">3</a>.  Compact No-Code FEC scheme</span>

   In this section we describe a Fully-Specified FEC scheme
   corresponding to FEC Encoding ID 0.  The primary purpose for
   introducing these FEC schemes is to allow simple interoperability
   testing between different implementations of the same protocol
   instantiation that uses the FEC building block.

   The Compact No-Code FEC scheme does not require FEC encoding or
   decoding.  Instead, each encoding symbol consists of consecutive
   bytes of a source block of the object.  The FEC Payload ID consists
   of two fields, the 16-bit Source Block Number and the 16-bit Encoding
   Symbol ID, as described in Sub<a href="#section-2.1">section 2.1</a>.  The relative lengths of
   these fields were chosen for their similarity with the corresponding
   fields of the FEC Payload ID associated with FEC Encoding ID 130, and



<span class="grey">Luby &amp; Vicisano               Experimental                      [Page 6]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-7" id="page-7" name="page-7"> </a>
<span class="grey"><a href="rfc3695.html">RFC 3695</a>                      FEC Schemes                  February 2004</span>


   because of this testing interoperability of the FEC scheme associated
   with FEC Encoding ID 0 provides a first basic step to testing
   interoperability of an FEC scheme associated with FEC Encoding ID
   130.

   Sub<a href="#section-2.1">section 2.1</a>. describes mapping between source blocks of an object
   and Source Block Numbers.  The next two subsections describe the
   details of how the Compact No-Code FEC scheme operates for each
   source block of an object.  These subsections are not meant to
   suggest a particular implementation, but just to illustrate the
   general algorithm through the description of a simple, non-optimized
   implementation.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.1.%20%20Source%20Block%20Logistics"></a><a class="selflink" href="#section-3.1" name="section-3.1">3.1</a>.  Source Block Logistics</span>

   Let X &gt; 0 be the length of a source block in bytes.  The value of X
   is part of the FEC Object Transmission Information, and how this
   information is communicated to a receiver is outside the scope of
   this document.

   Let L &gt; 0 be the length of the encoding symbol contained in the
   payload of each packet.  There are several possible ways the length
   of the encoding symbol L can be communicated to the receiver, and how
   this is done is outside the scope of this document.  As an example, a
   sender could fix the packet payload length to be L in order to place
   the encoding symbol of length L into the packet, and then a receiver
   could infer the value of L from the length of the received packet
   payload.  It is REQUIRED that L be the same for all packets sent for
   the same source block but MAY be different for different source
   blocks within the same object.

   For a given source block X bytes in length with Source Block Number
   I, let N = X/L rounded up to the nearest integer.  The encoding
   symbol carried in the payload of a packet consists of a consecutive
   portion of the source block.  The source block is logically
   partitioned into N encoding symbols, each L bytes in length, and the
   corresponding Encoding Symbol IDs range from 0 through N-1 starting
   at the beginning of the source block and proceeding to the end.
   Thus, the encoding symbol with Encoding Symbol ID Y consists of bytes
   L*Y through L*(Y+1)-1 of the source block, where the bytes of the
   source block are numbered from 0 through X-1.  If X/L is not integral
   then the last encoding symbol with Encoding Symbol ID = N-1 consists
   of bytes L*(N-1) through the last byte X-1 of the source block, and
   the remaining L*N - X bytes of the encoding symbol can by padded out
   with zeroes.






<span class="grey">Luby &amp; Vicisano               Experimental                      [Page 7]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-8" id="page-8" name="page-8"> </a>
<span class="grey"><a href="rfc3695.html">RFC 3695</a>                      FEC Schemes                  February 2004</span>


   As an example, suppose that the source block length X = 20,400 and
   encoding symbol length L = 1,000.  The encoding symbol with Encoding
   Symbol ID = 10 contains bytes 10,000 through 10,999 of the source
   block, and the encoding symbol with Encoding Symbol ID = 20 contains
   bytes 20,000 through the last byte 20,399 of the source block and the
   remaining 600 bytes of the encoding symbol can be padded with zeroes.

   There are no restrictions beyond the rules stated above on how a
   sender generates encoding symbols to send from a source block.
   However, it is recommended that an implementor of refer to the
   companion document [<a href="#ref-7" title='"The Use of Forward Error Correction (FEC) in Reliable Multicast"'>7</a>] for general advice.

   In the next subsection a procedure is recommended for sending and
   receiving source blocks.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.2.%20%20Sending%20and%20Receiving%20a%20Source%20Block"></a><a class="selflink" href="#section-3.2" name="section-3.2">3.2</a>.  Sending and Receiving a Source Block</span>

   The following carousel procedure is RECOMMENDED for a sender to
   generate packets containing FEC Payload IDs and corresponding
   encoding symbols for a source block with Source Block Number I.  Set
   the length in bytes of an encoding symbol to a fixed value L which is
   reasonable for a packet payload (e.g., ensure that the total packet
   size does not exceed the MTU) and that is smaller than the source
   block length X, e.g., L = 1,000 for X &gt;= 1,000.  Initialize Y to a
   value randomly chosen in the interval [0..N-1].  Repeat the following
   for each packet of the source block to be sent.

   o If Y &lt; N-1 then generate the encoding symbol consisting of the L
     bytes of the source block numbered L*Y through L*(Y+1)-1.

   o If Y = N-1 then generate the encoding symbol consisting of the last
     X - L*(N-1) bytes of the source block numbered L*(N-1) through X-1
     followed by L*N - X padding bytes of zeroes.

   o Set the Source Block Length to X, set the Source Block Number = I,
     set the Encoding Symbol ID = Y, place the FEC Payload ID and the
     encoding symbol into the packet to send.

   o In preparation for the generation of the next packet: if Y &lt; N-1
     then increment Y by one else if Y = N-1 then reset Y to zero.

   The following procedure is RECOMMENDED for a receiver to recover the
   source block based on receiving packets for the source block from a
   sender that is using the carousel procedure describe above.  The
   receiver can determine from which source block a received packet was
   generated by the Source Block Number carried in the FEC Payload ID.
   Upon receipt of the first FEC Payload ID for a source block, the
   receiver uses the source block length received out-of-band as part of



<span class="grey">Luby &amp; Vicisano               Experimental                      [Page 8]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-9" id="page-9" name="page-9"> </a>
<span class="grey"><a href="rfc3695.html">RFC 3695</a>                      FEC Schemes                  February 2004</span>


   the FEC Object Transmission Information to determine the length X in
   bytes of the source block, and allocates space for the X bytes that
   the source block requires.  The receiver also computes the length L
   of the encoding symbol in the payload of the packet by substracting
   the packet header length from the total length of the received packet
   (and the receiver checks that this length is the same in each
   subsequent received packet from the same source block).  After
   calculating N = X/L rounded up to the nearest integer, the receiver
   allocates a boolean array RECEIVED[0..N-1] with all N entries
   initialized to false to track received encoding symbols.  The
   receiver keeps receiving packets for the source block as long as
   there is at least one entry in RECEIVED still set to false or until
   the application decides to give up on this source block and move on
   to other source blocks.  For each received packet for the source
   block (including the first packet) the steps to be taken to help
   recover the source block are as follows.  Let Y be the value of the
   Encoding Symbol ID within FEC Payload ID of the packet.  If Y &lt; N-1
   then the receiver copies the L bytes of the encoding symbol into
   bytes numbered L*Y through L*(Y+1)-1 of the space reserved for the
   source block.  If Y = N-1 then the receiver copies the first
   X - L*(N-1) bytes of the encoding symbol into bytes numbered L*(N-1)
   through X-1 of the space reserved for the source block.  In either
   case, the receiver sets RECEIVED[Y] = true.  At each point in time,
   the receiver has successfully recovered bytes L*Y through L*(Y+1)-1
   of the source block for all Y in the interval [0..N-1] for which
   RECEIVED[Y] is true.  If all N entries of RECEIVED are true then the
   receiver has recovered the entire source block.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/4.%20%20Usage%20Examples"></a><a class="selflink" href="#section-4" name="section-4">4</a>.  Usage Examples</span>

   The following subsections outline some usage examples for FEC
   Encoding IDs 0 and 130.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.1.%20%20Reliable%20Bulk%20Data%20Delivery"></a><a class="selflink" href="#section-4.1" name="section-4.1">4.1</a>.  Reliable Bulk Data Delivery</span>

   One possible delivery model that can be supported using any FEC
   scheme described in this document is reliable bulk data delivery.  In
   this model, one or more potentially large objects are delivered
   reliably to potentially multiple receivers using multicast.  For this
   delivery model the unique SBN mode is often used.  Using this mode
   the maximum length of an object that can be delivered is at most the
   number of possible source blocks times the maximum length of a source
   block.  If the aggregate length of encoding symbols carried in a
   packet payload is L bytes then the maximum length of a source block
   is the number of distinct Encoding Symbol IDs times L, or 2^16 * L
   for FEC Encoding IDs 0 and 130.  If for example L = 1 KB then the
   length of a source block can be up to around 65 MB.   However, in
   practice the length of the source block is usually shorter than the



<span class="grey">Luby &amp; Vicisano               Experimental                      [Page 9]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-10" id="page-10" name="page-10"> </a>
<span class="grey"><a href="rfc3695.html">RFC 3695</a>                      FEC Schemes                  February 2004</span>


   number of distinct Encoding Symbol IDs times L, and thus generally
   the length of a source block is a fraction of 65 MB.  Since the
   number of distinct Source Block Numbers is 2^16, for this example an
   object can be more than a terabyte.

   The non-unique SBN mode of delivery can also be effectively used for
   reliably delivering large object.  In this case, the length of the
   object delivered could be arbitrarily large, depending on the
   out-of-band mapping between source blocks and Source Block Numbers.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.2.%20%20Block-Stream%20Delivery"></a><a class="selflink" href="#section-4.2" name="section-4.2">4.2</a>.  Block-Stream Delivery</span>

   Another possible delivery model that can be supported using FEC
   Encoding ID 0 or 130 is block-stream delivery of an object.  In this
   model, the source blocks of a potentially indeterminate length object
   are to be reliably delivered in sequence to one or multiple
   receivers.  Thus, the object could be partitioned into source blocks
   on-the-fly at the sender as the data arrives, and all packets
   generated for one source block are sent before any packets are sent
   for the subsequent source block.  In this example, all source blocks
   could be of the same length and this length could be communicated
   out-of-band to a receiver before the receiver joins the session.  For
   this delivery model it is not required that the Source Block Numbers
   for all source blocks are unique.  However, a suggested usage is to
   use all 2^16 Source Block Numbers for consecutive source blocks of
   the object, and thus the time between reuse of a Source Block Number
   is the time it takes to send the packets for 2^16 source blocks.

   This delivery model can be used to reliably deliver an object to one
   or multiple receivers, using either an ACK or NACK based
   acknowledgement based scheme for each source block.  As another
   example the sender could send a fixed number of packets for each
   source block without any acknowledgements from receivers, for example
   in a live streaming without feedback application.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/5.%20%20Security%20Considerations"></a><a class="selflink" href="#section-5" name="section-5">5</a>.  Security Considerations</span>

   The security considerations for this document are the same as they
   are for <a href="rfc3452.html">RFC 3452</a> [<a href="#ref-4" title='"Forward Error Correction (FEC) Building Block"'>4</a>].

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/6.%20%20IANA%20Considerations"></a><a class="selflink" href="#section-6" name="section-6">6</a>.  IANA Considerations</span>

   Values of FEC Encoding IDs and FEC Instance IDs are subject to IANA
   registration.  For general guidelines on IANA considerations as they
   apply to this document, see <a href="rfc3452.html">RFC 3452</a> [<a href="#ref-4" title='"Forward Error Correction (FEC) Building Block"'>4</a>].  This document assigns the
   Fully-Specified FEC Encoding ID 0 under the ietf:rmt:fec:encoding
   name-space to "Compact No-Code".  The FEC Payload ID format and
   corresponding FEC Object Transmission Information associated with FEC



<span class="grey">Luby &amp; Vicisano               Experimental                     [Page 10]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-11" id="page-11" name="page-11"> </a>
<span class="grey"><a href="rfc3695.html">RFC 3695</a>                      FEC Schemes                  February 2004</span>


   Encoding ID 0 is described in Subsections <a href="#section-2.1">2.1</a> and <a href="#section-2.2">2.2</a>, and the
   corresponding FEC scheme is described in <a href="#section-3">Section 3</a>.

   This document assigns the Under-Specified FEC Encoding ID 130 under
   the ietf:rmt:fec:encoding name-space to "Compact FEC".  The FEC
   Payload ID format and corresponding FEC Object Transmission
   Information associated with FEC Encoding ID 130 are described in
   Subsections <a href="#section-2.1">2.1</a> and <a href="#section-2.3">2.3</a>.

   As FEC Encoding ID 130 is Under-Specified, a new "FEC Instance ID"
   sub-name-space must be established, in accordance to <a href="rfc3452.html">RFC 3452</a>. Hence
   this document also establishes a new "FEC Instance ID" registry named

   ietf:rmt:fec:encoding:instance:130

   and scoped by

   ietf:rmt:fec:encoding = 130 (Compact FEC)

   As per <a href="rfc3452.html">RFC 3452</a>, the values that can be assigned within
   ietf:rmt:fec:encoding:instance:130 are non-negative numeric indices.
   Assignment requests are granted on a "First Come First Served" basis.
   <a href="rfc3452.html">RFC 3452</a> specifies additional criteria that MUST be met for the
   assignment within the generic ietf:rmt:fec:encoding:instance name-
   space.  These criteria also apply to
   ietf:rmt:fec:encoding:instance:130.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/7.%20%20References"></a><a class="selflink" href="#section-7" name="section-7">7</a>.  References</span>

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/7.1.%20%20Normative%20References"></a><a class="selflink" href="#section-7.1" name="section-7.1">7.1</a>.  Normative References</span>

   [<a id="ref-1" name="ref-1">1</a>] Bradner, S., "The Internet Standards Process -- Revision 3", <a href="https://tools.ietf.org/html/bcp9">BCP</a>
       <a href="https://tools.ietf.org/html/bcp9">9</a>, <a href="rfc2026.html">RFC 2026</a>, October 1996.

   [<a id="ref-2" name="ref-2">2</a>] Bradner, S., "Key words for use in RFCs to Indicate Requirement
       Levels", <a href="https://tools.ietf.org/html/bcp14">BCP 14</a>, <a href="rfc2119.html">RFC 2119</a>, March 1997.

   [<a id="ref-3" name="ref-3">3</a>] Kermode, R. and L. Vicisano, "Author Guidelines for Reliable
       Multicast Transport (RMT) Building Blocks and Protocol
       Instantiation Documents", <a href="rfc3269.html">RFC 3269</a>, April 2002.

   [<a id="ref-4" name="ref-4">4</a>] Luby, M., Vicisano, L., Gemmell, J., Rizzo, L., Handley, M. and
       J. Crowcroft, "Forward Error Correction (FEC) Building Block",
       <a href="rfc3452.html">RFC 3452</a>, December 2002.







<span class="grey">Luby &amp; Vicisano               Experimental                     [Page 11]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-12" id="page-12" name="page-12"> </a>
<span class="grey"><a href="rfc3695.html">RFC 3695</a>                      FEC Schemes                  February 2004</span>


   [<a id="ref-5" name="ref-5">5</a>] Mankin, A., Romanow, A., Bradner, S. and V. Paxson, "IETF
       Criteria for Evaluating Reliable Multicast Transport and
       Application Protocols", <a href="rfc2357.html">RFC 2357</a>, June 1998.

   [<a id="ref-6" name="ref-6">6</a>] Whetten, B., Vicisano, L., Kermode, R., Handley, M., Floyd, S.
       and M. Luby, "Reliable Multicast Transport Building Blocks for
       One-to-Many Bulk-Data Transfer", <a href="rfc3048.html">RFC 3048</a>, January 2001.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/7.2.%20%20Informative%20References"></a><a class="selflink" href="#section-7.2" name="section-7.2">7.2</a>.  Informative References</span>

   [<a id="ref-7" name="ref-7">7</a>] Luby, M., Vicisano, L., Gemmell, J., Rizzo, L., Handley, M. and
       J. Crowcroft, "The Use of Forward Error Correction (FEC) in
       Reliable Multicast", <a href="rfc3453.html">RFC 3453</a>, December 2002.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/8.%20%20Authors%27%20Addresses"></a><a class="selflink" href="#section-8" name="section-8">8</a>.  Authors' Addresses</span>

   Michael Luby
   Digital Fountain, Inc.
   39141 Civic Center Drive
   Suite 300
   Fremont, CA  94538

   EMail: luby@digitalfountain.com


   Lorenzo Vicisano
   cisco Systems, Inc.
   170 West Tasman Dr.,
   San Jose, CA, USA, 95134

   EMail: lorenzo@cisco.com




















<span class="grey">Luby &amp; Vicisano               Experimental                     [Page 12]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-13" id="page-13" name="page-13"> </a>
<span class="grey"><a href="rfc3695.html">RFC 3695</a>                      FEC Schemes                  February 2004</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/9.%20%20Full%20Copyright%20Statement"></a><a class="selflink" href="#section-9" name="section-9">9</a>.  Full Copyright Statement</span>

   Copyright (C) The Internet Society (2004).  This document is subject
   to the rights, licenses and restrictions contained in <a href="https://tools.ietf.org/html/bcp78">BCP 78</a> and
   except as set forth therein, the authors retain all their rights.

   This document and the information contained herein are provided on an
   "AS IS" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS
   OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET
   ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED,
   INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE
   INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED
   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.

Intellectual Property

   The IETF takes no position regarding the validity or scope of any
   Intellectual Property Rights or other rights that might be claimed to
   pertain to the implementation or use of the technology described in
   this document or the extent to which any license under such rights
   might or might not be available; nor does it represent that it has
   made any independent effort to identify any such rights.  Information
   on the procedures with respect to rights in RFC documents can be
   found in <a href="https://tools.ietf.org/html/bcp78">BCP 78</a> and <a href="https://tools.ietf.org/html/bcp79">BCP 79</a>.

   Copies of IPR disclosures made to the IETF Secretariat and any
   assurances of licenses to be made available, or the result of an
   attempt made to obtain a general license or permission for the use of
   such proprietary rights by implementers or users of this
   specification can be obtained from the IETF on-line IPR repository at
   <a href="http://www.ietf.org/ipr">http://www.ietf.org/ipr</a>.

   The IETF invites any interested party to bring to its attention any
   copyrights, patents or patent applications, or other proprietary
   rights that may cover technology that may be required to implement
   this standard.  Please address the information to the IETF at ietf-
   ipr@ietf.org.

Acknowledgement

   Funding for the RFC Editor function is currently provided by the
   Internet Society.









Luby &amp; Vicisano               Experimental                     [Page 13]

</pre><br/>
    <span class="noprint"><small><small>Html markup produced by rfcmarkup 1.126, available from
      <a href="https://tools.ietf.org/tools/rfcmarkup/">https://tools.ietf.org/tools/rfcmarkup/</a>
    </small></small></span>
  </div>




</body><!-- Mirrored from tools.ietf.org/html/rfc3695 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 06 Mar 2018 23:18:46 GMT --></html>