<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml"><!-- Mirrored from tools.ietf.org/html/rfc6518 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 06 Mar 2018 23:18:29 GMT --><!-- Added by HTTrack --><head><meta content="text/html;charset=utf-8" http-equiv="content-type"/><!-- /Added by HTTrack -->

    <meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
    <meta content="index,follow" name="robots"/>
    <meta content="rfcmarkup version 1.126" name="creator"/>
    <link href="http://purl.org/dc/elements/1.1/" rel="schema.DC"/>
<meta content="urn:ietf:rfc:6518" name="DC.Identifier"/>
<meta content="This document is one of a series concerned with defining a roadmap of
protocol specification work for the use of modern cryptographic
mechanisms and algorithms for message authentication in routing
protocols. In particular, it defines the framework for a key
management protocol that may be used to create and manage session keys
for message authentication and integrity. This document is not an
Internet Standards Track specification; it is published for
informational purposes." name="DC.Description.Abstract"/>
<meta content="&lt;&gt;, Gregory Lebovitz" name="DC.Creator"/>
<meta content="&lt;&gt;, Manav Bhatia" name="DC.Creator"/>
<meta content="February, 2012" name="DC.Date.Issued"/>
<meta content="Keying and Authentication for Routing Protocols (KARP) Design Guidelines" name="DC.Title"/>

    <link href="https://tools.ietf.org/images/rfc.png" rel="icon" type="image/png"/>
    <link href="https://tools.ietf.org/images/rfc.png" rel="shortcut icon" type="image/png"/>
    <title>RFC 6518 - Keying and Authentication for Routing Protocols (KARP) Design Guidelines</title>
    
    
    <style type="text/css">
	@media only screen 
	  and (min-width: 992px)
	  and (max-width: 1199px) {
	    body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 768px)
	  and (max-width: 991px) {
            body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 480px)
	  and (max-width: 767px) {
            body { font-size: 11pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (max-width: 479px) {
            body { font-size: 8pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-device-width : 375px) 
	  and (max-device-width : 667px) {
            body { font-size: 9.5pt; }
            div.content { width: 96ex; margin: 0 1px; }
        }
	@media only screen 
	  and (min-device-width: 1200px) {
            body { font-size: 10pt; margin: 0 4em; }
            div.content { width: 96ex; margin: 0; }
        }
        h1, h2, h3, h4, h5, h6, .h1, .h2, .h3, .h4, .h5, .h6 {
	    font-weight: bold;
            line-height: 0pt;
            display: inline;
            white-space: pre;
            font-family: monospace;
            font-size: 1em;
	    font-weight: bold;
        }
        pre {
            font-size: 1em;
            margin-top: 0px;
            margin-bottom: 0px;
        }
	.pre {
	    white-space: pre;
	    font-family: monospace;
	}
	.header{
	    font-weight: bold;
	}
        .newpage {
            page-break-before: always;
        }
        .invisible {
            text-decoration: none;
            color: white;
        }
        a.selflink {
          color: black;
          text-decoration: none;
        }
        @media print {
            body {
                font-family: monospace;
                font-size: 10.5pt;
            }
            h1, h2, h3, h4, h5, h6 {
                font-size: 1em;
            }
        
            a:link, a:visited {
                color: inherit;
                text-decoration: none;
            }
            .noprint {
                display: none;
            }
        }
	@media screen {
	    .grey, .grey a:link, .grey a:visited {
		color: #777;
	    }
            .docinfo {
                background-color: #EEE;
            }
            .top {
                border-top: 7px solid #EEE;
            }
            .bgwhite  { background-color: white; }
            .bgred    { background-color: #F44; }
            .bggrey   { background-color: #666; }
            .bgbrown  { background-color: #840; }            
            .bgorange { background-color: #FA0; }
            .bgyellow { background-color: #EE0; }
            .bgmagenta{ background-color: #F4F; }
            .bgblue   { background-color: #66F; }
            .bgcyan   { background-color: #4DD; }
            .bggreen  { background-color: #4F4; }

            .legend   { font-size: 90%; }
            .cplate   { font-size: 70%; border: solid grey 1px; }
	}
    </style>
    <!--[if IE]>
    <style>
    body {
       font-size: 13px;
       margin: 10px 10px;
    }
    </style>
    <![endif]-->

    <script type="text/javascript"><!--
    function addHeaderTags() {
	var spans = document.getElementsByTagName("span");
	for (var i=0; i < spans.length; i++) {
	    var elem = spans[i];
	    if (elem) {
		var level = elem.getAttribute("class");
                if (level == "h1" || level == "h2" || level == "h3" || level == "h4" || level == "h5" || level == "h6") {
                    elem.innerHTML = "<"+level+">"+elem.innerHTML+"</"+level+">";		
                }
	    }
	}
    }
    var legend_html = "Colour legend:<br />      <table>         <tr><td>Unknown:</td>                   <td><span class='cplate bgwhite'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft:</td>                     <td><span class='cplate bgred'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Informational:</td>             <td><span class='cplate bgorange'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Experimental:</td>              <td><span class='cplate bgyellow'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Best Common Practice:</td>      <td><span class='cplate bgmagenta'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Proposed Standard:</td>         <td><span class='cplate bgblue'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft Standard (old designation):</td> <td><span class='cplate bgcyan'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Internet Standard:</td>         <td><span class='cplate bggreen'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Historic:</td>                  <td><span class='cplate bggrey'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Obsolete:</td>                  <td><span class='cplate bgbrown'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>     </table>";
    function showElem(id) {
        var elem = document.getElementById(id);
        elem.innerHTML = eval(id+"_html");
        elem.style.visibility='visible';
    }
    function hideElem(id) {
        var elem = document.getElementById(id);
        elem.style.visibility='hidden';        
        elem.innerHTML = "";
    }
    // -->
    </script>
</head>
<body onload="addHeaderTags()">
  <div class="content">
   <div style="height: 13px;">
      <div class="pre noprint docinfo bgorange" onclick="showElem('legend');" onmouseout="hideElem('legend')" onmouseover="this.style.cursor='pointer';" style="height: 6px; position: absolute;" title="Click for colour legend.">                                                                        </div>
      <div class="docinfo noprint pre legend" id="legend" onmouseout="hideElem('legend');" onmouseover="showElem('legend');" style="position:absolute; top: 4px; left: 4ex; visibility:hidden; background-color: white; padding: 4px 9px 5px 7px; border: solid #345 1px; ">
      </div>
   </div>
<span class="pre noprint docinfo top">[<a href="index.html" title="Document search and retrieval page">Docs</a>] [<a href="https://tools.ietf.org/rfc/rfc6518.txt" title="Plaintext version of this document">txt</a>|<a href="https://tools.ietf.org/pdf/rfc6518" title="PDF version of this document">pdf</a>] [<a href="https://tools.ietf.org/html/draft-ietf-karp-design-guide" title="draft-ietf-karp-design-guide">draft-ietf-karp...</a>] [<a href="https://datatracker.ietf.org/doc/rfc6518" title="IESG Datatracker information for this document">Tracker</a>] [<a href="https://tools.ietf.org/rfcdiff?difftype=--hwdiff&amp;url2=rfc6518" title="Inline diff (wdiff)">Diff1</a>] [<a href="https://tools.ietf.org/rfcdiff?url2=rfc6518" title="Side-by-side diff">Diff2</a>]         </span><br/>
<span class="pre noprint docinfo">                                                                        </span><br/>
<span class="pre noprint docinfo">                                                           INFORMATIONAL</span><br/>
<span class="pre noprint docinfo">                                                                        </span><br/>
<pre>Internet Engineering Task Force (IETF)                       G. Lebovitz
Request for Comments: 6518                                     M. Bhatia
Category: Informational                                   Alcatel-Lucent
ISSN: 2070-1721                                            February 2012

         <span class="h1">Keying and Authentication for Routing Protocols (KARP)</span>
                           <span class="h1">Design Guidelines</span>

Abstract

   This document is one of a series concerned with defining a roadmap of
   protocol specification work for the use of modern cryptographic
   mechanisms and algorithms for message authentication in routing
   protocols.  In particular, it defines the framework for a key
   management protocol that may be used to create and manage session
   keys for message authentication and integrity.

Status of This Memo

   This document is not an Internet Standards Track specification; it is
   published for informational purposes.

   This document is a product of the Internet Engineering Task Force
   (IETF).  It represents the consensus of the IETF community.  It has
   received public review and has been approved for publication by the
   Internet Engineering Steering Group (IESG).  Not all documents
   approved by the IESG are a candidate for any level of Internet
   Standard; see <a href="rfc5741.html#section-2">Section 2 of RFC 5741</a>.

   Information about the current status of this document, any errata,
   and how to provide feedback on it may be obtained at
   <a href="http://www.rfc-editor.org/info/rfc6518">http://www.rfc-editor.org/info/rfc6518</a>.



















<span class="grey">Lebovitz &amp; Bhatia             Informational                     [Page 1]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-2" id="page-2" name="page-2"> </a>
<span class="grey"><a href="rfc6518.html">RFC 6518</a>                 KARP Design Guidelines            February 2012</span>


Copyright Notice

   Copyright (c) 2012 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to <a href="https://tools.ietf.org/html/bcp78">BCP 78</a> and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (<a href="http://trustee.ietf.org/license-info">http://trustee.ietf.org/license-info</a>) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.

Table of Contents

   <a href="#section-1">1</a>. Introduction ....................................................<a href="#page-3">3</a>
      <a href="#section-1.1">1.1</a>. Conventions Used in This Document ..........................<a href="#page-4">4</a>
   <a href="#section-2">2</a>. Categorizing Routing Protocols ..................................<a href="#page-5">5</a>
      <a href="#section-2.1">2.1</a>. Category: Message Transaction Type .........................<a href="#page-5">5</a>
      <a href="#section-2.2">2.2</a>. Category: Peer versus Group Keying .........................<a href="#page-6">6</a>
   <a href="#section-3">3</a>. Consider the Future Existence of a Key Management Protocol ......<a href="#page-6">6</a>
      <a href="#section-3.1">3.1</a>. Consider Asymmetric Keys ...................................<a href="#page-7">7</a>
      <a href="#section-3.2">3.2</a>. Cryptographic Keys Life Cycle ..............................<a href="#page-8">8</a>
   <a href="#section-4">4</a>. Roadmap .........................................................<a href="#page-9">9</a>
      <a href="#section-4.1">4.1</a>. Work Phases on Any Particular Protocol .....................<a href="#page-9">9</a>
      <a href="#section-4.2">4.2</a>. Work Items per Routing Protocol ...........................<a href="#page-11">11</a>
   <a href="#section-5">5</a>. Routing Protocols in Categories ................................<a href="#page-13">13</a>
   <a href="#section-6">6</a>. Supporting Incremental Deployment ..............................<a href="#page-16">16</a>
   <a href="#section-7">7</a>. Denial-of-Service Attacks ......................................<a href="#page-17">17</a>
   <a href="#section-8">8</a>. Gap Analysis ...................................................<a href="#page-18">18</a>
   <a href="#section-9">9</a>. Security Considerations ........................................<a href="#page-20">20</a>
      <a href="#section-9.1">9.1</a>. Use Strong Keys ...........................................<a href="#page-21">21</a>
      <a href="#section-9.2">9.2</a>. Internal versus External Operation ........................<a href="#page-22">22</a>
      <a href="#section-9.3">9.3</a>. Unique versus Shared Keys .................................<a href="#page-22">22</a>
      <a href="#section-9.4">9.4</a>. Key Exchange Mechanism ....................................<a href="#page-24">24</a>
   <a href="#section-10">10</a>. Acknowledgments ...............................................<a href="#page-26">26</a>
   <a href="#section-11">11</a>. References ....................................................<a href="#page-26">26</a>
       <a href="#section-11.1">11.1</a>. Normative References ....................................<a href="#page-26">26</a>
       <a href="#section-11.2">11.2</a>. Informative References ..................................<a href="#page-26">26</a>










<span class="grey">Lebovitz &amp; Bhatia             Informational                     [Page 2]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-3" id="page-3" name="page-3"> </a>
<span class="grey"><a href="rfc6518.html">RFC 6518</a>                 KARP Design Guidelines            February 2012</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/1.%20%20Introduction"></a><a class="selflink" href="#section-1" name="section-1">1</a>.  Introduction</span>

   In March 2006, the Internet Architecture Board (IAB) held a workshop
   on the topic of "Unwanted Internet Traffic".  The report from that
   workshop is documented in <a href="rfc4948.html">RFC 4948</a> [<a href="rfc4948.html" title='"Report from the IAB workshop on Unwanted Traffic March 9-10, 2006"'>RFC4948</a>].  <a href="#section-8.1">Section 8.1</a> of that
   document states that "A simple risk analysis would suggest that an
   ideal attack target of minimal cost but maximal disruption is the
   core routing infrastructure".  <a href="#section-8.2">Section 8.2</a> calls for "[t]ightening
   the security of the core routing infrastructure".  Four main steps
   were identified for that tightening:

   o  Increase the security mechanisms and practices for operating
      routers.

   o  Clean up the Internet Routing Registry [<a href="#ref-IRR" title='"Internet Routing Registry Routing Assets Database"'>IRR</a>] repository, and
      securing both the database and the access, so that it can be used
      for routing verifications.

   o  Create specifications for cryptographic validation of routing
      message content.

   o  Secure the routing protocols' packets on the wire.

   The first bullet is being addressed in the OPSEC working group.  The
   second bullet should be addressed through liaisons with those running
   the IRR's globally.  The third bullet is being addressed in the SIDR
   working group.

   This document addresses the last bullet, securing the packets on the
   wire of the routing protocol exchanges.  Thus, it is concerned with
   guidelines for describing issues and techniques for protecting the
   messages between directly communicating peers.  This may overlap
   with, but is strongly distinct from, protection designed to ensure
   that routing information is properly authorized relative to sources
   of this information.  Such authorizations are provided by other
   mechanisms and are outside the scope of this document and the work
   that relies on it.

   This document uses the terminology "on the wire" to talk about the
   information used by routing systems.  This term is widely used in
   RFCs, but is used in several different ways.  In this document, it is
   used to refer both to information exchanged between routing protocol
   instances and to underlying protocols that may also need to be
   protected in specific circumstances.  Other documents that will
   analyze individual protocols will need to indicate how they use the
   term "on the wire".





<span class="grey">Lebovitz &amp; Bhatia             Informational                     [Page 3]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-4" id="page-4" name="page-4"> </a>
<span class="grey"><a href="rfc6518.html">RFC 6518</a>                 KARP Design Guidelines            February 2012</span>


   The term "routing transport" is used to refer to the layer that
   exchanges the routing protocols.  This can be TCP, UDP, or even
   direct link-level messaging in the case of some routing protocols.
   The term is used here to allow a referent for discussing both common
   and disparate issues that affect or interact with this dimension of
   the routing systems.  The term is used here to refer generally to the
   set of mechanisms and exchanges underneath the routing protocol,
   whatever that is in specific cases.

   Keying and Authentication for Routing Protocols (KARP) will focus on
   an abstraction for keying information that describes the interface
   between routing protocols, operators, and automated key management.
   Conceptually, when routing protocols send or receive messages, they
   will look up the key to use in this abstract key table.
   Conceptually, there will be an interface for a routing protocol to
   make requests of automated key management when it is being used; when
   keys become available, they will be made available in the key table.
   There is no requirement that this abstraction be used for
   implementation; the abstraction serves the needs of standardization
   and management.  Specifically, as part of the KARP work plan:

   1) KARP will design the key table abstraction, the interface between
      key management protocols and routing protocols, and possibly
      security protocols at other layers.

   2) For each routing protocol, KARP will define the mapping between
      how the protocol represents key material and the protocol-
      independent key table abstraction.  When routing protocols share a
      common mechanism for authentication, such as the TCP
      Authentication Option, the same mapping is likely to be reused
      between protocols.  An implementation may be able to move much of
      the keying logic into code related to this shared authentication
      primitive rather than code specific to routing protocols.

   3) When designing automated key management for both symmetric keys
      and group keys, we will only use the abstractions designed in
      point 1 above to communicate between automated key management and
      routing protocols.

   Readers must refer to [<a href="#ref-THTS-REQS" title="&quot;The Threat Analysis and Requirements for Cryptographic Authentication of Routing Protocols' Transports&quot;">THTS-REQS</a>] for a clear definition of the
   scope, goals, non-goals, and the audience for the design work being
   undertaken in the KARP WG.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/1.1.%20%20Conventions%20Used%20in%20This%20Document"></a><a class="selflink" href="#section-1.1" name="section-1.1">1.1</a>.  Conventions Used in This Document</span>

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in <a href="rfc2119.html">RFC 2119</a> [<a href="rfc2119.html" title='"Key words for use in RFCs to Indicate Requirement Levels"'>RFC2119</a>].



<span class="grey">Lebovitz &amp; Bhatia             Informational                     [Page 4]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-5" id="page-5" name="page-5"> </a>
<span class="grey"><a href="rfc6518.html">RFC 6518</a>                 KARP Design Guidelines            February 2012</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/2.%20%20Categorizing%20Routing%20Protocols"></a><a class="selflink" href="#section-2" name="section-2">2</a>.  Categorizing Routing Protocols</span>

   This document places the routing protocols into two categories
   according to their requirements for authentication.  We hope these
   categories will allow design teams to focus on security mechanisms
   for a given category.  Further, we hope that each protocol in the
   group will be able to reuse the authentication mechanism.  It is also
   hoped that, down the road, we can create one Key Management Protocol
   (KMP) per category (if not for several categories), so that the work
   can be easily leveraged for use in the various routing protocol
   groupings.  KMPs are useful for allowing simple, automated updates of
   the traffic keys used in a base protocol.  KMPs replace the need for
   humans, or operational support systems (OSS) routines, to
   periodically replace keys on running systems.  It also removes the
   need for a chain of manual keys to be chosen or configured on such
   systems.  When configured properly, a KMP will enforce the key
   freshness policy among peers by keeping track of the key's lifetime
   and negotiating a new key at the defined interval.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/2.1.%20%20Category%3A%20Message%20Transaction%20Type"></a><a class="selflink" href="#section-2.1" name="section-2.1">2.1</a>.  Category: Message Transaction Type</span>

   The first category defines three types of messaging transactions used
   on the wire by the base routing protocol.  They are as follows:

      One-to-One

         One peer router directly and intentionally delivers a route
         update specifically to one other peer router.  Examples are BGP
         [<a href="rfc4271.html" title='"A Border Gateway Protocol 4 (BGP-4)"'>RFC4271</a>]; LDP [<a href="rfc5036.html" title='"LDP Specification"'>RFC5036</a>]; BFD [<a href="rfc5880.html" title='"Bidirectional Forwarding Detection (BFD)"'>RFC5880</a>]; and RSVP-TE [<a href="rfc3209.html" title='"RSVP-TE: Extensions to RSVP for LSP Tunnels"'>RFC3209</a>],
         [<a href="rfc3473.html" title='"Generalized Multi-Protocol Label Switching (GMPLS) Signaling Resource ReserVation Protocol-Traffic Engineering (RSVP-TE) Extensions"'>RFC3473</a>], [<a href="rfc4726.html" title='"A Framework for Inter-Domain Multiprotocol Label Switching Traffic Engineering"'>RFC4726</a>], and [<a href="rfc5151.html" title='"Inter-Domain MPLS and GMPLS Traffic Engineering -- Resource Reservation Protocol-Traffic Engineering (RSVP-TE) Extensions"'>RFC5151</a>].  Point-to-point modes of
         both IS-IS [<a href="rfc1195.html" title='"Use of OSI IS-IS for routing in TCP/IP and dual environments"'>RFC1195</a>] and OSPF [<a href="rfc2328.html" title='"OSPF Version 2"'>RFC2328</a>], when sent over both
         traditional point-to-point links and when using multi-access
         layers, may both also fall into this category.

      One-to-Many

         A router peers with multiple other routers on a single network
         segment -- i.e., on link local -- such that it creates and
         sends one route update message that is intended for multiple
         peers.  Examples would be OSPF and IS-IS in their broadcast,
         non-point-to-point mode and Routing Information Protocol (RIP)
         [<a href="rfc2453.html" title='"RIP Version 2"'>RFC2453</a>].

      Multicast

         Multicast protocols have unique security properties because
         they are inherently group-based protocols; thus, they have
         group keying requirements at the routing level where link-local



<span class="grey">Lebovitz &amp; Bhatia             Informational                     [Page 5]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-6" id="page-6" name="page-6"> </a>
<span class="grey"><a href="rfc6518.html">RFC 6518</a>                 KARP Design Guidelines            February 2012</span>


         routing messages are multicasted.  Also, at least in the case
         of Protocol Independent Multicast - Sparse Mode (PIM-SM)
         [<a href="rfc4601.html" title='"Protocol Independent Multicast - Sparse Mode (PIM-SM): Protocol Specification (Revised)"'>RFC4601</a>], some messages are sent unicast to a given peer(s),
         as is the case with router-close-to-sender and the "Rendezvous
         Point".  Some work for application-layer message security has
         been done in the Multicast Security (MSEC) working group and
         may be helpful to review, but it is not directly applicable.

   These categories affect both the routing protocol view of the
   communication and the actual message transfer.  As a result, some
   message transaction types for a few routing protocols may be
   mixtures, for example, using broadcast where multicast might be
   expected or using unicast to deliver what looks to the routing
   protocol like broadcast or multicast.

   Protocol security analysis documents produced in the KARP working
   group need to pay attention both to the semantics of the
   communication and the techniques that are used for the message
   exchanges.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/2.2.%20%20Category%3A%20Peer%20versus%20Group%20Keying"></a><a class="selflink" href="#section-2.2" name="section-2.2">2.2</a>.  Category: Peer versus Group Keying</span>

   The second category is the keying mechanism that will be used to
   distribute the session keys to the routing transports.  They are as
   follows:

   Peer Keying

      One router sends the keying messages only to one other router,
      such that a one-to-one, uniquely keyed security association (SA)
      is established between the two routers (e.g., BGP, BFD and LDP).

   Group Keying

      One router creates and distributes a single keying message to
      multiple peers.  In this case, a group SA will be established and
      used among multiple peers simultaneously.  Group keying exists for
      protocols like OSPF [<a href="rfc2328.html" title='"OSPF Version 2"'>RFC2328</a>] and for multicast protocols like
      PIM-SM [<a href="rfc4601.html" title='"Protocol Independent Multicast - Sparse Mode (PIM-SM): Protocol Specification (Revised)"'>RFC4601</a>].

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/3.%20%20Consider%20the%20Future%20Existence%20of%20a%20Key%20Management%20Protocol"></a><a class="selflink" href="#section-3" name="section-3">3</a>.  Consider the Future Existence of a Key Management Protocol</span>

   When it comes time for the KARP WG to design a reusable model for a
   Key Management Protocol (KMP), [<a href="rfc4107.html" title='"Guidelines for Cryptographic Key Management"'>RFC4107</a>] should be consulted.







<span class="grey">Lebovitz &amp; Bhatia             Informational                     [Page 6]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-7" id="page-7" name="page-7"> </a>
<span class="grey"><a href="rfc6518.html">RFC 6518</a>                 KARP Design Guidelines            February 2012</span>


   When conducting the design work on a manually keyed version of a
   routing protocol's authentication mechanism, consideration must be
   made for the eventual use of a KMP.  In particular, design teams must
   consider what parameters would need to be handed to the routing
   protocols by a KMP.

   Examples of parameters that might need to be passed are as follows: a
   security association identifier (e.g., IPsec Security Parameter Index
   (SPI) or the TCP Authentication Option's (TCP-AO's) KeyID), a key
   lifetime (which may be represented in either bytes or seconds), the
   cryptographic algorithms being used, the keys themselves, and the
   directionality of the keys (i.e., receiving versus the sending keys).

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.1.%20%20Consider%20Asymmetric%20Keys"></a><a class="selflink" href="#section-3.1" name="section-3.1">3.1</a>.  Consider Asymmetric Keys</span>

   The use of asymmetric keys can be a very powerful way to authenticate
   machine peers as used in routing protocol peer exchanges.  If
   generated on the machine, and never moved off the machine, these keys
   will not need to be changed if an administrator leaves the
   organization.  Since the keys are random, they are far less
   susceptible to off-line dictionary and guessing attacks.

   An easy and simple way to use asymmetric keys is to start by having
   the router generate a public/private key pair.  At the time of this
   writing, the recommended key size for algorithms based on integer
   factorization cryptography like RSA is 1024 bits and 2048 bits for
   extremely valuable keys like the root key pair used by a
   certification authority.  It is believed that a 1024-bit RSA key is
   equivalent in strength to 80-bit symmetric keys and 2048-bit RSA keys
   to 112-bit symmetric keys [<a href="rfc3766.html" title='"Determining Strengths For Public Keys Used For Exchanging Symmetric Keys"'>RFC3766</a>].  Elliptic Curve Cryptography
   (ECC) [<a href="rfc4492.html" title='"Elliptic Curve Cryptography (ECC) Cipher Suites for Transport Layer Security (TLS)"'>RFC4492</a>] appears to be secure with shorter keys than those
   needed by other asymmetric key algorithms.  National Institute of
   Standards and Technology (NIST) guidelines [<a href="#ref-NIST-800-57" title='"Recommendation for Key Management Part 1: General (Revised)"'>NIST-800-57</a>] state that
   ECC keys should be twice the length of equivalent strength symmetric
   key algorithms.  Thus, a 224-bit ECC key would roughly have the same
   strength as a 112-bit symmetric key.

   Many routers have the ability to be remotely managed using Secure
   Shell (SSH) Protocol [<a href="rfc4252.html" title='"The Secure Shell (SSH) Authentication Protocol"'>RFC4252</a>] and [<a href="rfc4253.html" title='"The Secure Shell (SSH) Transport Layer Protocol"'>RFC4253</a>].  As such, routers will
   also have the ability to generate and store an asymmetric key pair,
   because this is the common authentication method employed by SSH when
   an administrator connects to a router for management sessions.









<span class="grey">Lebovitz &amp; Bhatia             Informational                     [Page 7]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-8" id="page-8" name="page-8"> </a>
<span class="grey"><a href="rfc6518.html">RFC 6518</a>                 KARP Design Guidelines            February 2012</span>


   Once an asymmetric key pair is generated, the KMP generating security
   association parameters and keys for routing protocol may use the
   machine's asymmetric keys for the authentication mechanism.  The form
   of the identity proof could be raw keys, the more easily
   administrable self-signed certificate format, or a PKI-issued
   [<a href="rfc5280.html" title='"Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile"'>RFC5280</a>] certificate credential.

   Regardless of which credential is standardized, the authentication
   mechanism can be as simple as a strong hash over a string of human-
   readable and transferable form of ASCII characters.  More complex,
   but also more secure, the identity proof could be verified through
   the use of a PKI system's revocation checking mechanism, (e.g.,
   Certificate Revocation List (CRL) or Online Certificate Status
   Protocol (OCSP) responder).  If the SHA-1 fingerprint is used, the
   solution could be as simple as loading a set of neighbor routers'
   peer ID strings into a table and listing the associated fingerprint
   string for each ID string.  In most organizations or peering points,
   this list will not be longer than a thousand or so routers, and often
   the list will be much shorter.  In other words, the entire list for a
   given organization's router ID and hash could be held in a router's
   configuration file, uploaded, downloaded, and moved about at will.
   Additionally, it doesn't matter who sees or gains access to these
   fingerprints, because they can be distributed publicly as it needn't
   be kept secret.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.2.%20%20Cryptographic%20Keys%20Life%20Cycle"></a><a class="selflink" href="#section-3.2" name="section-3.2">3.2</a>.  Cryptographic Keys Life Cycle</span>

   Cryptographic keys should have a limited lifetime and may need to be
   changed when an operator who had access to them leaves.  Using a key
   chain, a set of keys derived from the same keying material and used
   one after the other, also does not help as one still has to change
   all the keys in the key chain when an operator having access to all
   those keys leaves the company.  Additionally, key chains will not
   help if the routing transport subsystem does not support rolling over
   to the new keys without bouncing the routing sessions and
   adjacencies.  So the first step is to fix the routing stack so that
   routing protocols can change keys without breaking or bouncing the
   adjacencies.

   An often cited reason for limiting the lifetime of a key is to
   minimize the damage from a compromised key.  It could be argued that
   it is likely a user will not discover an attacker has compromised the
   key if the attacker remains "passive"; thus, relatively frequent key
   changes will limit any potential damage from compromised keys.







<span class="grey">Lebovitz &amp; Bhatia             Informational                     [Page 8]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-9" id="page-9" name="page-9"> </a>
<span class="grey"><a href="rfc6518.html">RFC 6518</a>                 KARP Design Guidelines            February 2012</span>


   Another threat against the long-lived key is that one of the systems
   storing the key, or one of the users entrusted with the key, will be
   subverted.  So, while there may not be cryptographic motivations of
   changing the keys, there could be system security motivations for
   rolling the key.

   Although manual key distribution methods are subject to human error
   and frailty, more frequent manual key changes might actually increase
   the risk of exposure, as it is during the time that the keys are
   being changed that they are likely to be disclosed.  In these cases,
   especially when very strong cryptography is employed, it may be more
   prudent to have fewer, well-controlled manual key distributions
   rather than more frequent, poorly controlled manual key
   distributions.  In general, where strong cryptography is employed,
   physical, procedural, and logical access protection considerations
   often have more impact on the key life than do algorithm and key size
   factors.

   For incremental deployments, we could start by associating life times
   with the send and the receive keys in the key chain for the long-
   lived keys.  This is an incremental approach that we could use until
   the cryptographic keying material for individual sessions is derived
   from the keying material stored in a database of long-lived
   cryptographic keys as described in [<a href="#ref-CRPT-TAB" title='"Database of Long-Lived Symmetric Cryptographic Keys"'>CRPT-TAB</a>].  A key derivation
   function (KDF) and its inputs are also specified in the database of
   long-lived cryptographic keys; session-specific values based on the
   routing protocol are input to the KDF.  Protocol-specific key
   identifiers may be assigned to the cryptographic keying material for
   individual sessions if needed.

   The long-lived cryptographic keys used by the routing protocols can
   either be inserted manually in a database or make use of an automated
   key management protocol to do this.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/4.%20%20Roadmap"></a><a class="selflink" href="#section-4" name="section-4">4</a>.  Roadmap</span>

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.1.%20%20Work%20Phases%20on%20Any%20Particular%20Protocol"></a><a class="selflink" href="#section-4.1" name="section-4.1">4.1</a>.  Work Phases on Any Particular Protocol</span>

   It is believed that improving security for any routing protocol will
   be a two-phase process.  The first phase would be to modify routing
   protocols to support modern cryptography algorithms and key agility.
   The second phase would be to design and move to an automated key
   management mechanism.  This is like a crawl, walk, and run process.
   In order for operators to accept these phases, we believe that the
   key management protocol should be clearly separated from the routing
   transport.  This would mean that the routing transport subsystem is
   oblivious to how the keys are derived, exchanged, and downloaded as
   long as there is something that it can use.  It is like having a



<span class="grey">Lebovitz &amp; Bhatia             Informational                     [Page 9]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-10" id="page-10" name="page-10"> </a>
<span class="grey"><a href="rfc6518.html">RFC 6518</a>                 KARP Design Guidelines            February 2012</span>


   routing-protocol-configuration switch that requests the security
   module for the "KARP security parameters" so that it can refer to
   some module written, maintained, and operated by security experts and
   insert those parameters in the routing exchange.

   The desired end state for the KARP work contains several items.
   First, the people desiring to deploy securely authenticated and
   integrity validated packets between routing peers have the tools
   specified, implemented, and shipped in order to deploy.  These tools
   should be fairly simple to implement and not more complex than the
   security mechanisms to which the operators are already accustomed.
   (Examples of security mechanisms to which router operators are
   accustomed include: the use of asymmetric keys for authentication in
   SSH for router configuration, the use of pre-shared keys (PSKs) in
   TCP MD5 for BGP protection, the use of self-signed certificates for
   HTTP Secure (HTTPS) access to device Web-based user interfaces, the
   use of strongly constructed passwords and/or identity tokens for user
   identification when logging into routers and management systems.)
   While the tools that we intend to specify may not be able to stop a
   deployment from using "foobar" as an input key for every device
   across their entire routing domain, we intend to make a solid, modern
   security system that is not too much more difficult than that.  In
   other words, simplicity and deployability are keys to success.  The
   routing protocols will specify modern cryptographic algorithms and
   security mechanisms.  Routing peers will be able to employ unique,
   pair-wise keys per peering instance, with reasonable key lifetimes,
   and updating those keys on a regular basis will be operationally
   easy, causing no service interruption.

   Achieving the above described end state using manual keys may be
   pragmatic only in very small deployments.  However, manual keying in
   larger deployments will be too burdensome for operators.  Thus, the
   second goal is to support key life cycle management with a KMP.  We
   expect that both manual and automated key management will coexist in
   the real world.

   In accordance with the desired end state just described, we define
   two main work phases for each routing protocol:

   1.  Enhance the routing protocol's current authentication
       mechanism(s).  This work involves enhancing a routing protocol's
       current security mechanisms in order to achieve a consistent,
       modern level of security functionality within its existing key
       management framework.  It is understood and accepted that the
       existing key management frameworks are largely based on manual
       keys.  Since many operators have already built operational
       support systems (OSS) around these manual key implementations,
       there is some automation available for an operator to leverage in



<span class="grey">Lebovitz &amp; Bhatia             Informational                    [Page 10]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-11" id="page-11" name="page-11"> </a>
<span class="grey"><a href="rfc6518.html">RFC 6518</a>                 KARP Design Guidelines            February 2012</span>


       that way, if the underlying mechanisms are themselves secure.  In
       this phase, we explicitly exclude embedding or creating a KMP.
       Refer to [<a href="#ref-THTS-REQS" title="&quot;The Threat Analysis and Requirements for Cryptographic Authentication of Routing Protocols' Transports&quot;">THTS-REQS</a>] for the list of the requirements for Phase 1
       work.

   2.  Develop an automated key management framework.  The second phase
       will focus on the development of an automated keying framework to
       facilitate unique pair-wise (group-wise, where applicable) keys
       per peering instance.  This involves the use of a KMP.  The use
       of automatic key management mechanisms offers a number of
       benefits over manual keying.  Most important, it provides fresh
       traffic keying material for each session, thus helping to prevent
       inter-connection replay attacks.  In an inter-connection replay
       attack, protocol packets from the earlier protocol session are
       replayed affecting the current execution of the protocol.  A KMP
       is also helpful because it negotiates unique, pair-wise, random
       keys, without administrator involvement.  It negotiates several
       SA parameters like algorithms, modes, and parameters required for
       the secure connection, thus providing interoperability between
       endpoints with disparate capabilities and configurations.  In
       addition it could also include negotiating the key lifetimes.
       The KMP can thus keep track of those lifetimes using counters and
       can negotiate new keys and parameters before they expire, again,
       without administrator interaction.  Additionally, in the event of
       a breach, changing the KMP key will immediately cause a rekey to
       occur for the traffic key, and those new traffic keys will be
       installed and used in the current connection.  In summary, a KMP
       provides a protected channel between the peers through which they
       can negotiate and pass important data required to exchange proof
       of identities, derive traffic keys, determine rekeying,
       synchronize their keying state, signal various keying events,
       notify with error messages, etc.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.2.%20%20Work%20Items%20per%20Routing%20Protocol"></a><a class="selflink" href="#section-4.2" name="section-4.2">4.2</a>.  Work Items per Routing Protocol</span>

   Each routing protocol will have a team (the Routing_Protocol-KARP
   team, e.g., the OSPF-KARP team) working on incrementally improving
   the security of a routing protocol.  These teams will have the
   following main work items:

   PHASE 1:

      Characterize the Routing Protocol

         Assess the routing protocol to see what authentication and
         integrity mechanisms it has today.  Does it need significant
         improvement to its existing mechanisms or not?  This will




<span class="grey">Lebovitz &amp; Bhatia             Informational                    [Page 11]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-12" id="page-12" name="page-12"> </a>
<span class="grey"><a href="rfc6518.html">RFC 6518</a>                 KARP Design Guidelines            February 2012</span>


         include determining if modern, strong security algorithms and
         parameters are present and if the protocol supports key agility
         without bouncing adjacencies.

      Define Optimal State

         List the requirements for the routing protocol's session key
         usage and format to contain modern, strong security algorithms
         and mechanisms, per the Requirements document [<a href="#ref-THTS-REQS" title="&quot;The Threat Analysis and Requirements for Cryptographic Authentication of Routing Protocols' Transports&quot;">THTS-REQS</a>].  The
         goal here is to determine what is needed for the routing
         protocol to be used securely with at least manual key
         management.

      Gap Analysis

         Enumerate the requirements for this protocol to move from its
         current security state, the first bullet, to its optimal state,
         as listed just above.

      Transition and Deployment Considerations

         Document the operational transition plan for moving from the
         old to the new security mechanism.  Will adjacencies need to
         bounce?  What new elements/servers/services in the
         infrastructure will be required?  What is an example work flow
         that an operator will take?  The best possible case is if the
         adjacency does not break, but this may not always be possible.

      Define, Assign, Design

         Create a deliverables list of the design and specification
         work, with milestones.  Define owners.  Release one or more
         documents.

   PHASE 2:

      KMP Analysis

         Review requirements for KMPs.  Identify any nuances for this
         particular routing protocol's needs and its use cases for a
         KMP.  List the requirements that this routing protocol has for
         being able to be used in conjunction with a KMP.  Define the
         optimal state and check how easily it can be decoupled from the
         KMP.







<span class="grey">Lebovitz &amp; Bhatia             Informational                    [Page 12]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-13" id="page-13" name="page-13"> </a>
<span class="grey"><a href="rfc6518.html">RFC 6518</a>                 KARP Design Guidelines            February 2012</span>


      Gap Analysis

         Enumerate the requirements for this protocol to move from its
         current security state to its optimal state, with respect to
         the key management.

      Define, Assign, Design

         Create a deliverables list of the design and specification
         work, with milestones.  Define owners.  Generate the design and
         document work for a KMP to be able to generate the routing
         protocol's session keys for the packets on the wire.  These
         will be the arguments passed in the API to the KMP in order to
         bootstrap the session keys for the routing protocol.

         There will also be a team formed to work on the base framework
         mechanisms for each of the main categories.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/5.%20%20Routing%20Protocols%20in%20Categories"></a><a class="selflink" href="#section-5" name="section-5">5</a>.  Routing Protocols in Categories</span>

   This section groups the routing protocols into categories according
   to attributes set forth in the Categories' Section (<a href="#section-2">Section 2</a>).  Each
   group will have a design team tasked with improving the security of
   the routing protocol mechanisms and defining the KMP requirements for
   their group, then rolling both into a roadmap document upon which
   they will execute.

   BGP, LDP, PCEP, and MSDP

      These routing protocols fall into the category of the one-to-one
      peering messages and will use peer keying protocols.  Border
      Gateway Protocol (BGP) [<a href="rfc4271.html" title='"A Border Gateway Protocol 4 (BGP-4)"'>RFC4271</a>], Path Computation Element
      Communication Protocol (PCEP) [<a href="rfc5440.html" title='"Path Computation Element (PCE) Communication Protocol (PCEP)"'>RFC5440</a>], and Multicast Source
      Discovery Protocol (MSDP) [<a href="rfc3618.html" title='"Multicast Source Discovery Protocol (MSDP)"'>RFC3618</a>] messages are transmitted over
      TCP, while Label Distribution Protocol (LDP) [<a href="rfc5036.html" title='"LDP Specification"'>RFC5036</a>] uses both
      UDP and TCP.  A team will work on one mechanism to cover these TCP
      unicast protocols.  Much of the work on the routing protocol
      update for its existing authentication mechanism has already
      occurred in the TCPM working group, on the TCP-AO [<a href="rfc5925.html" title='"The TCP Authentication Option"'>RFC5925</a>]
      document, as well as its cryptography-helper document, TCP-AO-
      CRYPTO [<a href="rfc5926.html" title='"Cryptographic Algorithms for the TCP Authentication Option (TCP- AO)"'>RFC5926</a>].  However, TCP-AO cannot be used for discovery
      exchanges carried in LDP as those are carried over UDP.  A
      separate team might want to look at LDP.  Another exception is the
      mode where LDP is used directly on the LAN.  The work for this may
      go into the group keying category (along with OSPF) as mentioned
      below.





<span class="grey">Lebovitz &amp; Bhatia             Informational                    [Page 13]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-14" id="page-14" name="page-14"> </a>
<span class="grey"><a href="rfc6518.html">RFC 6518</a>                 KARP Design Guidelines            February 2012</span>


   OSPF, IS-IS, and RIP

      The routing protocols that fall into the category group keying
      (with one-to-many peering) includes OSPF [<a href="rfc2328.html" title='"OSPF Version 2"'>RFC2328</a>], IS-IS
      [<a href="rfc1195.html" title='"Use of OSI IS-IS for routing in TCP/IP and dual environments"'>RFC1195</a>] and RIP [<a href="rfc2453.html" title='"RIP Version 2"'>RFC2453</a>].  Not surprisingly, all these routing
      protocols have two other things in common.  First, they are run on
      a combination of the OSI datalink Layer 2, and the OSI network
      Layer 3.  By this we mean that they have a component of how the
      routing protocol works, which is specified in Layer 2 as well as
      in Layer 3.  Second, they are all internal gateway protocols
      (IGPs).  The keying mechanisms will be much more complicated to
      define for these than for a one-to-one messaging protocol.

   BFD

      Because it is less of a routing protocol, per se, and more of a
      peer liveness detection mechanism, Bidirectional Forwarding
      Detection (BFD) [<a href="rfc5880.html" title='"Bidirectional Forwarding Detection (BFD)"'>RFC5880</a>] will have its own team.  BFD is also
      different from the other protocols covered here as it works on
      millisecond timers and would need separate considerations to
      mitigate the potential for Denial-of-Service (DoS) attacks.  It
      also raises interesting issues [<a href="rfc6039.html" title='"Issues with Existing Cryptographic Protection Methods for Routing Protocols"'>RFC6039</a>] with respect to the
      sequence number scheme that is generally deployed to protect
      against replay attacks as this space can roll over quite
      frequently because of the rate at which BFD packets are generated.

   RSVP and RSVP-TE

      The Resource reSerVation Protocol (RSVP) [<a href="rfc2205.html" title='"Resource ReSerVation Protocol (RSVP) -- Version 1 Functional Specification"'>RFC2205</a>] allows hop-by-
      hop authentication of RSVP neighbors, as specified in [<a href="rfc2747.html" title='"RSVP Cryptographic Authentication"'>RFC2747</a>].
      In this mode, an integrity object is attached to each RSVP message
      to transmit a keyed message digest.  This message digest allows
      the recipient to verify the identity of the RSVP node that sent
      the message and to validate the integrity of the message.  Through
      the inclusion of a sequence number in the scope of the digest, the
      digest also offers replay protection.

      [<a id="ref-RFC2747" name="ref-RFC2747">RFC2747</a>] does not dictate how the key for the integrity operation
      is derived.  Currently, most implementations of RSVP use a
      statically configured key, on a per-interface or per-neighbor
      basis.

      RSVP relies on a per-peer authentication mechanism where each hop
      authenticates its neighbor using a shared key or a certificate.

      Trust in this model is transitive.  Each RSVP node trusts,
      explicitly, only its RSVP next-hop peers through the message
      digest contained in the INTEGRITY object [<a href="rfc2747.html" title='"RSVP Cryptographic Authentication"'>RFC2747</a>].  The next-hop



<span class="grey">Lebovitz &amp; Bhatia             Informational                    [Page 14]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-15" id="page-15" name="page-15"> </a>
<span class="grey"><a href="rfc6518.html">RFC 6518</a>                 KARP Design Guidelines            February 2012</span>


      RSVP speaker, in turn, trusts its own peers, and so on.  See also
      the document "RSVP Security Properties" [<a href="rfc4230.html" title='"RSVP Security Properties"'>RFC4230</a>] for more
      background.

      The keys used for protecting the RSVP messages can be group keys
      (for example, distributed via the Group Domain of Interpretation
      (GDOI) [<a href="rfc6407.html" title='"The Group Domain of Interpretation"'>RFC6407</a>], as discussed in [<a href="#ref-GDOI-MAC" title='"GDOI Generic Message Authentication Code Policy"'>GDOI-MAC</a>]).

      The trust an RSVP node has with another RSVP node has an explicit
      and implicit component.  Explicitly, the node trusts the other
      node to maintain the integrity (and, optionally, the
      confidentiality) of RSVP messages depending on whether
      authentication or encryption (or both) are used.  This means that
      the message has not been altered or its contents seen by another,
      non-trusted node.  Implicitly, each node trusts the other node to
      maintain the level of protection specified within that security
      domain.  Note that in any group key management scheme, like GDOI,
      each node trusts all the other members of the group with regard to
      data origin authentication.

      RSVP-TE [<a href="rfc3209.html" title='"RSVP-TE: Extensions to RSVP for LSP Tunnels"'>RFC3209</a>], [<a href="rfc3473.html" title='"Generalized Multi-Protocol Label Switching (GMPLS) Signaling Resource ReserVation Protocol-Traffic Engineering (RSVP-TE) Extensions"'>RFC3473</a>], [<a href="rfc4726.html" title='"A Framework for Inter-Domain Multiprotocol Label Switching Traffic Engineering"'>RFC4726</a>], and [<a href="rfc5151.html" title='"Inter-Domain MPLS and GMPLS Traffic Engineering -- Resource Reservation Protocol-Traffic Engineering (RSVP-TE) Extensions"'>RFC5151</a>] is an
      extension of the RSVP protocol for traffic engineering.  It
      supports the reservation of resources across an IP network and is
      used for establishing MPLS label switch paths (LSPs), taking into
      consideration network constraint parameters such as available
      bandwidth and explicit hops.  RSVP-TE signaling is used to
      establish both intra- and inter-domain TE LSPs.

      When signaling an inter-domain RSVP-TE LSP, operators may make use
      of the security features already defined for RSVP-TE [<a href="rfc3209.html" title='"RSVP-TE: Extensions to RSVP for LSP Tunnels"'>RFC3209</a>].
      This may require some coordination between domains to share keys
      ([<a href="rfc2747.html" title='"RSVP Cryptographic Authentication"'>RFC2747</a>][RFC3097]), and care is required to ensure that the keys
      are changed sufficiently frequently.  Note that this may involve
      additional synchronization, should the domain border nodes be
      protected with Fast Reroute, since the merge point (MP) and point
      of local repair (PLR) should also share the key.

      For inter-domain signaling for MPLS-TE, the administrators of
      neighboring domains must satisfy themselves as to the existence of
      a suitable trust relationship between the domains.  In the absence
      of such a relationship, the administrators should decide not to
      deploy inter-domain signaling and should disable RSVP-TE on any
      inter-domain interfaces.

      KARP will currently be working only on RSVP-TE, as the native RSVP
      lies outside the scope of the WG charter.





<span class="grey">Lebovitz &amp; Bhatia             Informational                    [Page 15]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-16" id="page-16" name="page-16"> </a>
<span class="grey"><a href="rfc6518.html">RFC 6518</a>                 KARP Design Guidelines            February 2012</span>


   PIM-SM and PIM-DM

      Finally, the multicast protocols Protocol Independent Multicast -
      Sparse Mode (PIM-SM) [<a href="rfc4601.html" title='"Protocol Independent Multicast - Sparse Mode (PIM-SM): Protocol Specification (Revised)"'>RFC4601</a>] and Protocol Independent Multicast
      - Dense Mode (PIM-DM) [<a href="rfc3973.html" title='"Protocol Independent Multicast - Dense Mode (PIM-DM): Protocol Specification (Revised)"'>RFC3973</a>] will be grouped together.  PIM-SM
      multicasts routing information (Hello, Join/Prune, Assert) on a
      link-local basis, using a defined multicast address.  In addition,
      it specifies unicast communication for exchange of information
      (Register, Register-Stop) between the router closest to a group
      sender and the "Rendezvous Point".  The Rendezvous Point is
      typically not "on-link" for a particular router.  While much work
      has been done on multicast security for application-layer groups,
      little has been done to address the problem of managing hundreds
      or thousands of small one-to-many groups with link-local scope.
      Such an authentication mechanism should be considered along with
      the router-to-Rendezvous Point authentication mechanism.  The most
      important issue is ensuring that only the "authorized neighbors"
      get the keys for source/group (S,G), so that rogue routers cannot
      participate in the exchanges.  Another issue is that some of the
      communication may occur intra-domain, e.g., the link-local
      messages in an enterprise, while others for the same (*,G) may
      occur inter-domain, e.g., the router-to-Rendezvous Point messages
      may be from one enterprise's router to another.

      One possible solution proposes a region-wide "master" key server
      (possibly replicated), and one "local" key server per speaking
      router.  There is no issue with propagating the messages outside
      the link, because link-local messages, by definition, are not
      forwarded.  This solution is offered only as an example of how
      work may progress; further discussion should occur in this work
      team.  Specification of a link-local protection mechanism for PIM-
      SM is defined in [<a href="rfc4601.html" title='"Protocol Independent Multicast - Sparse Mode (PIM-SM): Protocol Specification (Revised)"'>RFC4601</a>], and this mechanism has been updated in
      PIM-SM-LINKLOCAL [<a href="rfc5796.html" title='"Authentication and Confidentiality in Protocol Independent Multicast Sparse Mode (PIM-SM) Link-Local Messages"'>RFC5796</a>].  However, the KMP part is completely
      unspecified and will require work outside the expertise of the PIM
      working group to accomplish, another example of why this roadmap
      is being created.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/6.%20%20Supporting%20Incremental%20Deployment"></a><a class="selflink" href="#section-6" name="section-6">6</a>.  Supporting Incremental Deployment</span>

   It is imperative that the new authentication and security mechanisms
   defined support incremental deployment, as it is not feasible to
   deploy a new routing protocol authentication mechanism throughout the
   network instantaneously.  One of the goals of the KARP WG is to add
   incremental security to existing mechanisms rather than replacing
   them.  Delivering better deployable solutions to which vendors and
   operators can migrate is more important than getting a perfect
   security solution.  It may also not be possible to deploy such a
   mechanism to all routers in a large Autonomous System (AS) at one



<span class="grey">Lebovitz &amp; Bhatia             Informational                    [Page 16]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-17" id="page-17" name="page-17"> </a>
<span class="grey"><a href="rfc6518.html">RFC 6518</a>                 KARP Design Guidelines            February 2012</span>


   time.  This means that the designers must work on this aspect of the
   authentication mechanism for the routing protocol on which they are
   working.  The mechanisms must provide backward compatibility in the
   message formatting, transmission, and processing of routing
   information carried through a mixed security environment.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/7.%20%20Denial-of-Service%20Attacks"></a><a class="selflink" href="#section-7" name="section-7">7</a>.  Denial-of-Service Attacks</span>

   DoS attacks must be kept in mind when designing KARP solutions.
   [<a href="#ref-THTS-REQS" title="&quot;The Threat Analysis and Requirements for Cryptographic Authentication of Routing Protocols' Transports&quot;">THTS-REQS</a>] describes DoS attacks that are in scope for the KARP
   work.  Protocol designers should ensure that the new cryptographic
   validation mechanisms must not provide an attacker with an
   opportunity for DoS attacks.  Cryptographic validation, while
   typically cheaper than signing, is still an incremental cost.  If an
   attacker can force a system to validate many packets multiple times,
   then this could be a potential DoS attack vector.  On the other hand,
   if the authentication procedure is itself quite CPU intensive, then
   overwhelming the CPU with multiple bogus packets can bring down the
   system.  In this case, the authentication procedure itself aids the
   DoS attack.

   There are some known techniques to reduce the cryptographic
   computation load.  Packets can include non-cryptographic consistency
   checks.  For example, [<a href="rfc5082.html" title='"The Generalized TTL Security Mechanism (GTSM)"'>RFC5082</a>] provides a mechanism that uses the IP
   header to limit the attackers that can inject packets that will be
   subject to cryptographic validation.  In the design, Phase 2, once an
   automated key management protocol is developed, it may be possible to
   determine the peer IP addresses that are valid participants.  Only
   the packets from the verified sources could be subject to
   cryptographic validation.

   Protocol designers must ensure that a device never needs to check
   incoming protocol packets using multiple keys, as this can overwhelm
   the CPU, leading to a DoS attack.  KARP solutions should indicate the
   checks that are appropriate prior to performing cryptographic
   validation.  KARP solutions should indicate where information about
   valid neighbors can be used to limit the scope of the attacks.

   Particular care needs to be paid to the design of automated key
   management schemes.  It is often desirable to force a party
   attempting to authenticate to do work and to maintain state until
   that work is done.  That is, the initiator of the authentication
   should maintain the cost of any state required by the authentication
   for as long as possible.  This also helps when an attacker sends an
   overwhelming load of keying protocol initiations from bogus sources.






<span class="grey">Lebovitz &amp; Bhatia             Informational                    [Page 17]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-18" id="page-18" name="page-18"> </a>
<span class="grey"><a href="rfc6518.html">RFC 6518</a>                 KARP Design Guidelines            February 2012</span>


   Another important class of attack is denial of service against the
   routing protocol where an attacker can manipulate either the routing
   protocol or the cryptographic authentication mechanism to disrupt
   routing adjacencies.

   Without KARP solutions, many routing protocols are subject to
   disruption simply by injecting an invalid packet or a packet for the
   wrong state.  Even with cryptographic validation, replay attacks are
   often a vector where a previously valid packet can be injected to
   create a denial of service.   KARP solutions should prevent all cases
   where packet replays or other packet injections by an outsider can
   disrupt routing sessions.

   Some residual denial-of-service risk is always likely.  If an
   attacker can generate a large enough number of packets, the routing
   protocol can get disrupted.  Even if the routing protocol is not
   disrupted, the loss rate on a link may rise to a point where claiming
   that traffic can successfully be routed across the link will be
   inaccurate.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/8.%20%20Gap%20Analysis"></a><a class="selflink" href="#section-8" name="section-8">8</a>.  Gap Analysis</span>

   The [<a href="#ref-THTS-REQS" title="&quot;The Threat Analysis and Requirements for Cryptographic Authentication of Routing Protocols' Transports&quot;">THTS-REQS</a>] document lists the generic requirements for the
   security mechanisms that must exist for the various routing protocols
   that come under the purview of KARP.  There will be different design
   teams working for each of the categories of routing protocols
   defined.

   To start, design teams must review the "Threats and Requirements for
   Authentication of routing protocols" document [<a href="#ref-THTS-REQS" title="&quot;The Threat Analysis and Requirements for Cryptographic Authentication of Routing Protocols' Transports&quot;">THTS-REQS</a>].  This
   document contains detailed descriptions of the threat analysis for
   routing protocol authentication and integrity in general.  Note that
   it does not contain all the authentication-related threats for any
   one routing protocol, or category of routing protocols.  The design
   team must conduct a protocol-specific threat analysis to determine if
   threats beyond those in the [<a href="#ref-THTS-REQS" title="&quot;The Threat Analysis and Requirements for Cryptographic Authentication of Routing Protocols' Transports&quot;">THTS-REQS</a>] document arise in the context
   of the protocol (group) and to describe those threats.

   The [<a href="#ref-THTS-REQS" title="&quot;The Threat Analysis and Requirements for Cryptographic Authentication of Routing Protocols' Transports&quot;">THTS-REQS</a>] document also contains many security requirements.
   Each routing protocol design team must walk through each section of
   the requirements and determine one by one how its protocol either
   does or does not relate to each requirement.

   Examples include modern, strong, cryptographic algorithms, with at
   least one such algorithm listed as a MUST, algorithm agility, secure
   use of simple PSKs, intra-connection replay protection, inter-
   connection replay protection, etc.




<span class="grey">Lebovitz &amp; Bhatia             Informational                    [Page 18]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-19" id="page-19" name="page-19"> </a>
<span class="grey"><a href="rfc6518.html">RFC 6518</a>                 KARP Design Guidelines            February 2012</span>


   When doing the gap analysis, we must first identify the elements of
   each routing protocol that we wish to protect.  In case of protocols
   riding on top of IP, we might want to protect the IP header and the
   protocol headers, while for those that work on top of TCP, it will be
   the TCP header and the protocol payload.  There is patently value in
   protecting the IP header and the TCP header if the routing protocols
   rely on these headers for some information (for example, identifying
   the neighbor that originated the packet).

   Then, there will be a set of cryptography requirements that we might
   want to look at.  For example, there must be at least one set of
   cryptographic algorithms (MD5, SHA, etc.) or constructions (Hashed
   MAC (HMAC), etc.) whose use is supported by all implementations and
   can be safely assumed to be supported by any implementation of the
   authentication option.  The design teams should look for the protocol
   on which they are working.  If such algorithms or constructions are
   not available, then some should be defined to support
   interoperability by having a single default.

   Design teams must ensure that the default cryptographic algorithms
   and constructions supported by the routing protocols are accepted by
   the community.  This means that the protocols must not rely on non-
   standard or ad hoc hash functions, keyed-hash constructions,
   signature schemes, or other functions, and they must use published
   and standard schemes.

   Care should also be taken to ensure that the routing protocol
   authentication scheme has algorithm agility (i.e., it is capable of
   supporting algorithms other than its defaults).  Ideally, the
   authentication mechanism should not be affected by packet loss and
   reordering.

   Design teams should ensure that their protocol's authentication
   mechanism is able to accommodate rekeying.  This is essential since
   it is well known that keys must periodically be changed.  Also, what
   the designers must ensure is that this rekeying event should not
   affect the functioning of the routing protocol.  For example, OSPF
   rekeying requires coordination among the adjacent routers, while IS-
   IS requires coordination among routers in the entire domain.

   If new authentication and security mechanisms are needed, then the
   design teams must design in such a manner that the routing protocol
   authentication mechanism remains oblivious to how the keying material
   is derived.  This decouples the authentication mechanism from the key
   management system that is employed.






<span class="grey">Lebovitz &amp; Bhatia             Informational                    [Page 19]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-20" id="page-20" name="page-20"> </a>
<span class="grey"><a href="rfc6518.html">RFC 6518</a>                 KARP Design Guidelines            February 2012</span>


   Design teams should also note that many routing protocols require
   prioritized treatment of certain protocol packets and authentication
   mechanisms should honor this.

   Not all routing protocol authentication mechanisms provide support
   for replay attacks, and the design teams should identify such
   authentication mechanisms and work on them so that this can get
   fixed.  The design teams must look at the protocols that they are
   working on and see if packets captured from the previous/stale
   sessions can be replayed.

   What might also influence the design is the rate at which the
   protocol packets are originated.  In case of protocols like BFD,
   where packets are originated at millisecond intervals, there are some
   special considerations that must be kept in mind when defining the
   new authentication and security mechanisms.

   The designers should also consider whether the current authentication
   mechanisms impose considerable processing overhead on a router that's
   doing authentication.  Most currently deployed routers do not have
   hardware accelerators for cryptographic processing and these
   operations can impose a significant processing burden under some
   circumstances.  The proposed solutions should be evaluated carefully
   with regard to the processing burden that they will impose, since
   deployment may be impeded if network operators perceive that a
   solution will impose a processing burden which either entails
   substantial capital expenses or threatens to destabilize the routers.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/9.%20%20Security%20Considerations"></a><a class="selflink" href="#section-9" name="section-9">9</a>.  Security Considerations</span>

   As mentioned in the Introduction, <a href="rfc4948.html">RFC 4948</a> [<a href="rfc4948.html" title='"Report from the IAB workshop on Unwanted Traffic March 9-10, 2006"'>RFC4948</a>] identifies
   additional steps needed to achieve the overall goal of improving the
   security of the core routing infrastructure.  Those include
   validation of route origin announcements, path validation, cleaning
   up the IRR databases for accuracy, and operational security practices
   that prevent routers from becoming compromised devices.  The KARP
   work is but one step needed to improve core routing infrastructure.

   The security of cryptographic-based systems depends on both the
   strength of the cryptographic algorithms chosen and the strength of
   the keys used with those algorithms.  The security also depends on
   the engineering of the protocol used by the system to ensure that
   there are no non-cryptographic ways to bypass the security of the
   overall system.







<span class="grey">Lebovitz &amp; Bhatia             Informational                    [Page 20]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-21" id="page-21" name="page-21"> </a>
<span class="grey"><a href="rfc6518.html">RFC 6518</a>                 KARP Design Guidelines            February 2012</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/9.1.%20%20Use%20Strong%20Keys"></a><a class="selflink" href="#section-9.1" name="section-9.1">9.1</a>.  Use Strong Keys</span>

   Care should be taken to ensure that the selected key is
   unpredictable, avoiding any keys known to be weak for the algorithm
   in use.  [<a href="rfc4086.html" title='"Randomness Requirements for Security"'>RFC4086</a>] contains helpful information on both key
   generation techniques and cryptographic randomness.

   Care should also be taken when choosing the length of the key.
   [<a href="rfc3766.html" title='"Determining Strengths For Public Keys Used For Exchanging Symmetric Keys"'>RFC3766</a>] provides some additional information on asymmetric and
   symmetric key sizes and how they relate to system requirements for
   attack resistance.

   In addition to using a key of appropriate length and randomness,
   deployers of KARP should use different keys between different routing
   peers whenever operationally possible.  This is especially true when
   the routing protocol takes a static traffic key as opposed to a
   traffic key derived on a per-connection basis using a KDF.  The
   burden for doing so is understandably much higher than using the same
   static traffic key across all peering routers.  Depending upon the
   specific KMP, it can be argued that generally using a KMP network-
   wide increases peer-wise security.  Consider an attacker that learns
   or guesses the traffic key used by two peer routers: if the traffic
   key is only used between those two routers, then the attacker has
   only compromised that one connection not the entire network.

   However whenever using manual keys, it is best to design a system
   where a given pre-shared key (PSK) will be used in a KDF mixed with
   connection-specific material, in order to generate session unique --
   and therefore peer-wise -- traffic keys.  Doing so has the following
   advantages: the traffic keys used in the per-message authentication
   mechanism are peer-wise unique, it provides inter-connection replay
   protection, and if the per-message authentication mechanism covers
   some connection counter, intra-connection replay protection.

   Note that certain key derivation functions (e.g., KDF_AES_128_CMAC)
   as used in TCP-AO [<a href="rfc5926.html" title='"Cryptographic Algorithms for the TCP Authentication Option (TCP- AO)"'>RFC5926</a>], the pseudorandom function (PRF) used in
   the KDF may require a key of a certain fixed size as an input.

   For example, AES_128_CMAC requires a 128-bit (16-byte) key as the
   seed.  However, for the convenience of the administrators, a
   specification may not want to require the entry of a PSK be of
   exactly 16 bytes.  Instead, a specification may call for a key prep
   routine that could handle a variable-length PSK, one that might be
   less or more than 16 bytes (see <a href="rfc4615.html#section-3">[RFC4615], Section 3</a>, as an example).
   That key prep routine would derive a key of exactly the required
   length, thus, be suitable as a seed to the PRF.  This does NOT mean
   that administrators are safe to use weak keys.  Administrators are
   encouraged to follow [<a href="rfc4086.html" title='"Randomness Requirements for Security"'>RFC4086</a>] [<a href="#ref-NIST-800-118" title='"Guide to Enterprise Password Management (Draft)"'>NIST-800-118</a>].  We simply attempted



<span class="grey">Lebovitz &amp; Bhatia             Informational                    [Page 21]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-22" id="page-22" name="page-22"> </a>
<span class="grey"><a href="rfc6518.html">RFC 6518</a>                 KARP Design Guidelines            February 2012</span>


   to "put a fence around stupidity", as much as possible as it's hard
   to imagine administrators putting in a password that is, say 16 bytes
   in length.

   A better option, from a security perspective, is to use some
   representation of a device-specific asymmetric key pair as the
   identity proof, as described in section "Unique versus Shared Keys"
   section.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/9.2.%20%20Internal%20versus%20External%20Operation"></a><a class="selflink" href="#section-9.2" name="section-9.2">9.2</a>.  Internal versus External Operation</span>

   Design teams must consider whether the protocol is an internal
   routing protocol or an external one, i.e., does it primarily run
   between peers within a single domain of control or between two
   different domains of control?  Some protocols may be used in both
   cases, internally and externally, and as such, various modes of
   authentication operation may be required for the same protocol.
   While it is preferred that all routing exchanges run with the best
   security mechanisms enabled in all deployment contexts, this
   exhortation is greater for those protocols running on inter-domain
   point-to-point links.  It is greatest for those on shared access link
   layers with several different domains interchanging together, because
   the volume of attackers are greater from the outside.  Note however,
   that the consequences of internal attacks maybe no less severe -- in
   fact, they may be quite a bit more severe -- than an external attack.
   An example of this internal versus external consideration is BGP,
   which has both EBGP and IBGP modes.  Another example is a multicast
   protocol where the neighbors are sometimes within a domain of control
   and sometimes at an inter-domain exchange point.  In the case of PIM-
   SM running on an internal multi-access link, it would be acceptable
   to give up some security to get some convenience by using a group key
   among the peers on the link.  On the other hand, in the case of PIM-
   SM running over a multi-access link at a public exchange point,
   operators may favor security over convenience by using unique pair-
   wise keys for every peer.  Designers must consider both modes of
   operation and ensure the authentication mechanisms fit both.

   Operators are encouraged to run cryptographic authentication on all
   their adjacencies, but to work from the outside in, i.e., External
   BGP (EBGP) links are a higher priority than the Internal BGP (IBGP)
   links because they are externally facing, and, as a result, more
   likely to be targeted in an attack.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/9.3.%20%20Unique%20versus%20Shared%20Keys"></a><a class="selflink" href="#section-9.3" name="section-9.3">9.3</a>.  Unique versus Shared Keys</span>

   This section discusses security considerations regarding when it is
   appropriate to use the same authentication key inputs for multiple
   peers and when it is not.  This is largely a debate of convenience



<span class="grey">Lebovitz &amp; Bhatia             Informational                    [Page 22]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-23" id="page-23" name="page-23"> </a>
<span class="grey"><a href="rfc6518.html">RFC 6518</a>                 KARP Design Guidelines            February 2012</span>


   versus security.  It is often the case that the best secured
   mechanism is also the least convenient mechanism.  For example, an
   air gap between a host and the network absolutely prevents remote
   attacks on the host, but having to copy and carry files using the
   "sneaker net" is quite inconvenient and does not scale.

   Operators have erred on the side of convenience when it comes to
   securing routing protocols with cryptographic authentication.  Many
   do not use it at all.  Some use it only on external links, but not on
   internal links.  Those that do use it often use the same key for all
   peers in a network.  It is common to see the same key in use for
   years, e.g., the key was entered when authentication mechanisms were
   originally configured or when the routing gear was deployed.

   One goal for designers is to create authentication and integrity
   mechanisms that are easy for operators to deploy and manage, and
   still use unique keys between peers (or small groups on multi-access
   links) and for different sessions among the same peers.  Operators
   have the impression that they NEED one key shared across the network,
   when, in fact, they do not.  What they need is the relative
   convenience they experience from deploying cryptographic
   authentication with one key (or a few keys) compared to the
   inconvenience they would experience if they deployed the same
   authentication mechanism using unique pair-wise keys.  An example is
   BGP route reflectors.  Here, operators often use the same
   authentication key between each client and the route reflector.  The
   roadmaps defined from this guidance document should allow for unique
   keys to be used between each client and the peer, without sacrificing
   much convenience.  Designers should strive to deliver peer-wise
   unique keying mechanisms with similar ease-of-deployment properties
   as today's one-key method.

   Operators must understand the consequences of using the same key
   across many peers.  One argument against using the same key is that
   if the same key that is used in multiple devices, then a compromise
   of any one of the devices will expose the key.  Also, since the same
   key is supported on many devices, this is known by many people, which
   affects its distribution to all of the devices.

   Consider also the attack consequence size, the amount of routing
   adjacencies that can be negatively affected once a breach has
   occurred, i.e., once the keys have been acquired by the attacker.

   Again, if a shared key is used across the internal domain, then the
   consequence size is the whole network.  Ideally, unique key pairs
   would be used for each adjacency.





<span class="grey">Lebovitz &amp; Bhatia             Informational                    [Page 23]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-24" id="page-24" name="page-24"> </a>
<span class="grey"><a href="rfc6518.html">RFC 6518</a>                 KARP Design Guidelines            February 2012</span>


   In some cases, use of shared keys is needed because of the problem
   space.  For example, a multicast packet is sent once but then
   consumed by several routing neighbors.  If unique keys were used per
   neighbor, the benefit of multicast would be erased because the sender
   would have to create a different announcement packet for each
   receiver.  Though this may be desired and acceptable in some small
   number of use cases, it is not the norm.  Shared (i.e., group) keys
   are an acceptable solution here, and much work has been done already
   in this area (by the MSEC working group).

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/9.4.%20%20Key%20Exchange%20Mechanism"></a><a class="selflink" href="#section-9.4" name="section-9.4">9.4</a>.  Key Exchange Mechanism</span>

   This section discusses the security and use case considerations for
   key exchange for routing protocols.  Two options exist: an out-of-
   band mechanism or a KMP.  An out-of-band mechanism involves operators
   configuring keys in the device through a configuration tool or
   management method (e.g., Simple Network Management Protocol (SNMP),
   Network Configuration Protocol (NETCONF)).  A KMP is an automated
   protocol that exchanges keys without operator intervention.  KMPs can
   occur either in-band to the routing protocol or out-of-band to the
   routing protocol (i.e., a different protocol).

   An example of an out-of-band configuration mechanism could be an
   administrator who makes a remote management connection (e.g., using
   SSH) to a router and manually enters the keying information, e.g.,
   the algorithm, the key(s), the key lifetimes, etc.  Another example
   could be an OSS system that inputs the same information by using a
   script over an SSH connection or by pushing configuration through
   some other management connection, standard (NETCONF-based) or
   proprietary.

   The drawbacks of an out-of-band configuration mechanism include lack
   of scalability, complexity, and speed of changing if a security
   breach is suspected.  For example, if an employee who had access to
   keys was terminated, or if a machine holding those keys was believed
   to be compromised, then the system would be considered insecure and
   vulnerable until new keys were generated and distributed.  Those keys
   then need to be placed into the OSS system, and the OSS system then
   needs to push the new keys -- often during a very limited change
   window -- into the relevant devices.  If there are multiple
   organizations involved in these connections, because the protected
   connections are inter-domain, this process is very complicated.

   The principle benefit of out-of-band configuration mechanism is that
   once the new keys/parameters are set in OSS system, they can be
   pushed automatically to all devices within the OSS's domain.





<span class="grey">Lebovitz &amp; Bhatia             Informational                    [Page 24]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-25" id="page-25" name="page-25"> </a>
<span class="grey"><a href="rfc6518.html">RFC 6518</a>                 KARP Design Guidelines            February 2012</span>


   Operators have mechanisms in place for this already for managing
   other router configuration data.  In small environments with few
   routers, a manual system is not difficult to employ.

   We further define a peer-to-peer KMP as using cryptographically
   protected identity verification, session key negotiation, and
   security association parameter negotiation between the two routing
   peers.  The KMP among peers may also include the negotiation of
   parameters, like cryptographic algorithms, cryptographic inputs
   (e.g., initialization vectors), key lifetimes, etc.

   There are several benefits of a peer-to-peer KMP versus centrally
   managed and distributing keys.  It results in key(s) that are
   privately generated, and it need not be recorded permanently
   anywhere.  Since the traffic keys used in a particular connection are
   not a fixed part of a device configuration, no security sensitive
   data exists anywhere else in the operator's systems that can be
   stolen, e.g., in the case of a terminated or turned employee.  If a
   server or other data store is stolen or compromised, the thieves gain
   limited or no access to current traffic keys.  They may gain access
   to key derivation material, like a PSK, but may not be able to access
   the current traffic keys in use.  In this example, these PSKs can be
   updated in the device configurations (either manually or through an
   OSS) without bouncing or impacting the existing session at all.  In
   the case of using raw asymmetric keys or certificates, instead of
   PSKs, the data theft (from the data store) would likely not result in
   any compromise, as the key pairs would have been generated on the
   routers and never leave those routers.  In such a case, no changes
   are needed on the routers; the connections will continue to be
   secure, uncompromised.  Additionally, with a KMP, regular rekey
   operations occur without any operator involvement or oversight.  This
   keeps keys fresh.

   There are a few drawbacks to using a KMP.  First, a KMP requires more
   cryptographic processing for the router at the beginning of a
   connection.  This will add some minor start-up time to connection
   establishment versus a purely manual key management approach.  Once a
   connection with traffic keys has been established via a KMP, the
   performance is the same in the KMP and the out-of-band configuration
   case.  KMPs also add another layer of protocol and configuration
   complexity, which can fail or be misconfigured.  This was more of an
   issue when these KMPs were first deployed, but less so as these
   implementations and operational experience with them have matured.

   One of the goals for KARP is to develop a KMP; an out-of-band
   configuration protocol for key exchange is out of scope.





<span class="grey">Lebovitz &amp; Bhatia             Informational                    [Page 25]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-26" id="page-26" name="page-26"> </a>
<span class="grey"><a href="rfc6518.html">RFC 6518</a>                 KARP Design Guidelines            February 2012</span>


   Within this constraint, there are two approaches for a KMP:

   The first is to use a KMP that runs independent of the routing and
   the signaling protocols.  It would run on its own port and use its
   own transport (to avoid interfering with the routing protocol that it
   is serving).  When a routing protocol needs a key, it would contact
   the local instance of this key management protocol and request a key.
   The KMP generates a key that is delivered to the routing protocol for
   it to use for authenticating and integrity verification of the
   routing protocol packets.  This KMP could either be an existing key
   management protocol such as ISAKMP/IKE, GKMP, etc., extended for the
   routing protocols, or it could be a new KMP, designed for the routing
   protocol context.

   The second approach is to define an in-band KMP extension for
   existing routing protocols putting the key management mechanisms
   inside the protocol itself.  In this case, the key management
   messages would be carried within the routing protocol packets,
   resulting in very tight coupling between the routing protocols and
   the key management protocol.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/10.%20%20Acknowledgments"></a><a class="selflink" href="#section-10" name="section-10">10</a>.  Acknowledgments</span>

   Much of the text for this document came originally from "Roadmap for
   Cryptographic Authentication of Routing Protocol Packets on the
   Wire", authored by Gregory M. Lebovitz.

   We would like to thank Sam Hartman, Eric Rescorla, Russ White, Sean
   Turner, Stephen Kent, Stephen Farrell, Adrian Farrel, Russ Housley,
   Michael Barnes, and Vishwas Manral for their comments on the
   document.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/11.%20%20References"></a><a class="selflink" href="#section-11" name="section-11">11</a>.  References</span>

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/11.1.%20%20Normative%20References"></a><a class="selflink" href="#section-11.1" name="section-11.1">11.1</a>.  Normative References</span>

   [<a id="ref-RFC2119" name="ref-RFC2119">RFC2119</a>]      Bradner, S., "Key words for use in RFCs to Indicate
                  Requirement Levels", <a href="https://tools.ietf.org/html/bcp14">BCP 14</a>, <a href="rfc2119.html">RFC 2119</a>, March 1997.

   [<a id="ref-RFC4948" name="ref-RFC4948">RFC4948</a>]      Andersson, L., Davies, E., and L. Zhang, "Report from
                  the IAB workshop on Unwanted Traffic March 9-10,
                  2006", <a href="rfc4948.html">RFC 4948</a>, August 2007.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/11.2.%20%20Informative%20References"></a><a class="selflink" href="#section-11.2" name="section-11.2">11.2</a>.  Informative References</span>

   [<a id="ref-RFC1195" name="ref-RFC1195">RFC1195</a>]      Callon, R., "Use of OSI IS-IS for routing in TCP/IP
                  and dual environments", <a href="rfc1195.html">RFC 1195</a>, December 1990.




<span class="grey">Lebovitz &amp; Bhatia             Informational                    [Page 26]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-27" id="page-27" name="page-27"> </a>
<span class="grey"><a href="rfc6518.html">RFC 6518</a>                 KARP Design Guidelines            February 2012</span>


   [<a id="ref-RFC2205" name="ref-RFC2205">RFC2205</a>]      Braden, R., Ed., Zhang, L., Berson, S., Herzog, S.,
                  and S. Jamin, "Resource ReSerVation Protocol (RSVP) --
                  Version 1 Functional Specification", <a href="rfc2205.html">RFC 2205</a>,
                  September 1997.

   [<a id="ref-RFC2328" name="ref-RFC2328">RFC2328</a>]      Moy, J., "OSPF Version 2", STD 54, <a href="rfc2328.html">RFC 2328</a>, April
                  1998.

   [<a id="ref-RFC2453" name="ref-RFC2453">RFC2453</a>]      Malkin, G., "RIP Version 2", STD 56, <a href="rfc2453.html">RFC 2453</a>,
                  November 1998.

   [<a id="ref-RFC2747" name="ref-RFC2747">RFC2747</a>]      Baker, F., Lindell, B., and M. Talwar, "RSVP
                  Cryptographic Authentication", <a href="rfc2747.html">RFC 2747</a>, January 2000.

   [<a id="ref-RFC3097" name="ref-RFC3097">RFC3097</a>]      Braden, R. and L. Zhang, "RSVP Cryptographic
                  Authentication -- Updated Message Type Value", <a href="rfc3097.html">RFC</a>
                  <a href="rfc3097.html">3097</a>, April 2001.

   [<a id="ref-RFC3209" name="ref-RFC3209">RFC3209</a>]      Awduche, D., Berger, L., Gan, D., Li, T., Srinivasan,
                  V., and G. Swallow, "RSVP-TE: Extensions to RSVP for
                  LSP Tunnels", <a href="rfc3209.html">RFC 3209</a>, December 2001.

   [<a id="ref-RFC3473" name="ref-RFC3473">RFC3473</a>]      Berger, L., Ed., "Generalized Multi-Protocol Label
                  Switching (GMPLS) Signaling Resource ReserVation
                  Protocol-Traffic Engineering (RSVP-TE) Extensions",
                  <a href="rfc3473.html">RFC 3473</a>, January 2003.

   [<a id="ref-RFC3618" name="ref-RFC3618">RFC3618</a>]      Fenner, B., Ed., and D. Meyer, Ed., "Multicast Source
                  Discovery Protocol (MSDP)", <a href="rfc3618.html">RFC 3618</a>, October 2003.

   [<a id="ref-RFC3766" name="ref-RFC3766">RFC3766</a>]      Orman, H. and P. Hoffman, "Determining Strengths For
                  Public Keys Used For Exchanging Symmetric Keys", <a href="https://tools.ietf.org/html/bcp86">BCP</a>
                  <a href="https://tools.ietf.org/html/bcp86">86</a>, <a href="rfc3766.html">RFC 3766</a>, April 2004.

   [<a id="ref-RFC3973" name="ref-RFC3973">RFC3973</a>]      Adams, A., Nicholas, J., and W. Siadak, "Protocol
                  Independent Multicast - Dense Mode (PIM-DM): Protocol
                  Specification (Revised)", <a href="rfc3973.html">RFC 3973</a>, January 2005.

   [<a id="ref-RFC4086" name="ref-RFC4086">RFC4086</a>]      Eastlake 3rd, D., Schiller, J., and S. Crocker,
                  "Randomness Requirements for Security", <a href="https://tools.ietf.org/html/bcp106">BCP 106</a>, <a href="rfc4086.html">RFC</a>
                  <a href="rfc4086.html">4086</a>, June 2005.

   [<a id="ref-RFC4107" name="ref-RFC4107">RFC4107</a>]      Bellovin, S. and R. Housley, "Guidelines for
                  Cryptographic Key Management", <a href="https://tools.ietf.org/html/bcp107">BCP 107</a>, <a href="rfc4107.html">RFC 4107</a>, June
                  2005.

   [<a id="ref-RFC4230" name="ref-RFC4230">RFC4230</a>]      Tschofenig, H. and R. Graveman, "RSVP Security
                  Properties", <a href="rfc4230.html">RFC 4230</a>, December 2005.



<span class="grey">Lebovitz &amp; Bhatia             Informational                    [Page 27]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-28" id="page-28" name="page-28"> </a>
<span class="grey"><a href="rfc6518.html">RFC 6518</a>                 KARP Design Guidelines            February 2012</span>


   [<a id="ref-RFC4252" name="ref-RFC4252">RFC4252</a>]      Ylonen, T. and C. Lonvick, Ed., "The Secure Shell
                  (SSH) Authentication Protocol", <a href="rfc4252.html">RFC 4252</a>, January
                  2006.

   [<a id="ref-RFC4253" name="ref-RFC4253">RFC4253</a>]      Ylonen, T. and C. Lonvick, Ed., "The Secure Shell
                  (SSH) Transport Layer Protocol", <a href="rfc4253.html">RFC 4253</a>, January
                  2006.

   [<a id="ref-RFC4271" name="ref-RFC4271">RFC4271</a>]      Rekhter, Y., Ed., Li, T., Ed., and S. Hares, Ed., "A
                  Border Gateway Protocol 4 (BGP-4)", <a href="rfc4271.html">RFC 4271</a>, January
                  2006.

   [<a id="ref-RFC4492" name="ref-RFC4492">RFC4492</a>]      Blake-Wilson, S., Bolyard, N., Gupta, V., Hawk, C.,
                  and B. Moeller, "Elliptic Curve Cryptography (ECC)
                  Cipher Suites for Transport Layer Security (TLS)", <a href="rfc4492.html">RFC</a>
                  <a href="rfc4492.html">4492</a>, May 2006.

   [<a id="ref-RFC4601" name="ref-RFC4601">RFC4601</a>]      Fenner, B., Handley, M., Holbrook, H., and I.
                  Kouvelas, "Protocol Independent Multicast - Sparse
                  Mode (PIM-SM): Protocol Specification (Revised)", <a href="rfc4601.html">RFC</a>
                  <a href="rfc4601.html">4601</a>, August 2006.

   [<a id="ref-RFC4615" name="ref-RFC4615">RFC4615</a>]      Song, J., Poovendran, R., Lee, J., and T. Iwata, "The
                  Advanced Encryption Standard-Cipher-based Message
                  Authentication Code-Pseudo-Random Function-128 (-
                  AES-CMAC-PRF-128) Algorithm for the Internet Key
                  Exchange Protocol (IKE)", <a href="rfc4615.html">RFC 4615</a>, August 2006.

   [<a id="ref-RFC4726" name="ref-RFC4726">RFC4726</a>]      Farrel, A., Vasseur, J.-P., and A. Ayyangar, "A
                  Framework for  Inter-Domain Multiprotocol Label
                  Switching Traffic Engineering", <a href="rfc4726.html">RFC 4726</a>, November
                  2006.

   [<a id="ref-RFC5036" name="ref-RFC5036">RFC5036</a>]      Andersson, L., Ed., Minei, I., Ed., and B. Thomas,
                  Ed., "LDP Specification", <a href="rfc5036.html">RFC 5036</a>, October 2007.

   [<a id="ref-RFC5082" name="ref-RFC5082">RFC5082</a>]      Gill, V., Heasley, J., Meyer, D., Savola, P., Ed., and
                  C. Pignataro, "The Generalized TTL Security Mechanism
                  (GTSM)", <a href="rfc5082.html">RFC 5082</a>, October 2007.

   [<a id="ref-RFC5151" name="ref-RFC5151">RFC5151</a>]      Farrel, A., Ed., Ayyangar, A., and JP. Vasseur,
                  "Inter-Domain MPLS and GMPLS Traffic Engineering --
                  Resource Reservation Protocol-Traffic Engineering
                  (RSVP-TE) Extensions", <a href="rfc5151.html">RFC 5151</a>, February 2008.







<span class="grey">Lebovitz &amp; Bhatia             Informational                    [Page 28]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-29" id="page-29" name="page-29"> </a>
<span class="grey"><a href="rfc6518.html">RFC 6518</a>                 KARP Design Guidelines            February 2012</span>


   [<a id="ref-RFC5280" name="ref-RFC5280">RFC5280</a>]      Cooper, D., Santesson, S., Farrell, S., Boeyen, S.,
                  Housley, R., and W. Polk, "Internet X.509 Public Key
                  Infrastructure Certificate and Certificate Revocation
                  List (CRL) Profile", <a href="rfc5280.html">RFC 5280</a>, May 2008.

   [<a id="ref-RFC5440" name="ref-RFC5440">RFC5440</a>]      Vasseur, JP., Ed., and JL. Le Roux, Ed., "Path
                  Computation Element (PCE) Communication Protocol
                  (PCEP)", <a href="rfc5440.html">RFC 5440</a>, March 2009.

   [<a id="ref-RFC5796" name="ref-RFC5796">RFC5796</a>]      Atwood, W., Islam, S., and M. Siami, "Authentication
                  and Confidentiality in Protocol Independent Multicast
                  Sparse Mode (PIM-SM) Link-Local Messages", <a href="rfc5796.html">RFC 5796</a>,
                  March 2010.

   [<a id="ref-RFC5880" name="ref-RFC5880">RFC5880</a>]      Katz, D. and D. Ward, "Bidirectional Forwarding
                  Detection (BFD)", <a href="rfc5880.html">RFC 5880</a>, June 2010.

   [<a id="ref-RFC5925" name="ref-RFC5925">RFC5925</a>]      Touch, J., Mankin, A., and R. Bonica, "The TCP
                  Authentication Option", <a href="rfc5925.html">RFC 5925</a>, June 2010.

   [<a id="ref-RFC5926" name="ref-RFC5926">RFC5926</a>]      Lebovitz, G. and E. Rescorla, "Cryptographic
                  Algorithms for the TCP Authentication Option (TCP-
                  AO)", <a href="rfc5926.html">RFC 5926</a>, June 2010.

   [<a id="ref-RFC6039" name="ref-RFC6039">RFC6039</a>]      Manral, V., Bhatia, M., Jaeggli, J., and R. White,
                  "Issues with Existing Cryptographic Protection Methods
                  for Routing Protocols", <a href="rfc6039.html">RFC 6039</a>, October 2010.

   [<a id="ref-RFC6407" name="ref-RFC6407">RFC6407</a>]      Weis, B., Rowles, S., and T. Hardjono, "The Group
                  Domain of Interpretation", <a href="rfc6407.html">RFC 6407</a>, October 2011.

   [<a id="ref-THTS-REQS" name="ref-THTS-REQS">THTS-REQS</a>]    Lebovitz, G., "The Threat Analysis and Requirements
                  for Cryptographic Authentication of Routing Protocols'
                  Transports", Work in Progress, June 2011.

   [<a id="ref-CRPT-TAB" name="ref-CRPT-TAB">CRPT-TAB</a>]     Housley, R. and Polk, T., "Database of Long-Lived
                  Symmetric Cryptographic Keys", Work in Progress,
                  October 2011

   [<a id="ref-GDOI-MAC" name="ref-GDOI-MAC">GDOI-MAC</a>]     Weis, B. and S. Rowles, "GDOI Generic Message
                  Authentication Code Policy", Work in Progress,
                  September 2011.

   [<a id="ref-IRR" name="ref-IRR">IRR</a>]          Merit Network Inc , "Internet Routing Registry Routing
                  Assets Database", 2006, <a href="http://www.irr.net/">http://www.irr.net/</a>.






<span class="grey">Lebovitz &amp; Bhatia             Informational                    [Page 29]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-30" id="page-30" name="page-30"> </a>
<span class="grey"><a href="rfc6518.html">RFC 6518</a>                 KARP Design Guidelines            February 2012</span>


   [<a id="ref-NIST-800-57" name="ref-NIST-800-57">NIST-800-57</a>]  US National Institute of Standards &amp; Technology,
                  "Recommendation for Key Management Part 1: General
                  (Revised)", March 2007

   [<a id="ref-NIST-800-118" name="ref-NIST-800-118">NIST-800-118</a>] US National Institute of Standards &amp; Technology,
                  "Guide to Enterprise Password Management (Draft)",
                  April 2009

Authors' Addresses

   Gregory M. Lebovitz
   Aptos, California
   USA 95003

   EMail: gregory.ietf@gmail.com


   Manav Bhatia
   Alcatel-Lucent
   Bangalore
   India

   EMail: manav.bhatia@alcatel-lucent.com




























Lebovitz &amp; Bhatia             Informational                    [Page 30]

</pre><br/>
    <span class="noprint"><small><small>Html markup produced by rfcmarkup 1.126, available from
      <a href="https://tools.ietf.org/tools/rfcmarkup/">https://tools.ietf.org/tools/rfcmarkup/</a>
    </small></small></span>
  </div>




</body><!-- Mirrored from tools.ietf.org/html/rfc6518 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 06 Mar 2018 23:18:29 GMT --></html>