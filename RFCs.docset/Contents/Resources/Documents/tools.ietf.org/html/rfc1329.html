<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml"><!-- Mirrored from tools.ietf.org/html/rfc1329 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 06 Mar 2018 23:18:58 GMT --><!-- Added by HTTrack --><head><meta content="text/html;charset=utf-8" http-equiv="content-type"/><!-- /Added by HTTrack -->

    <meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
    <meta content="index,follow" name="robots"/>
    <meta content="rfcmarkup version 1.126" name="creator"/>
    <link href="http://purl.org/dc/elements/1.1/" rel="schema.DC"/>
<meta content="urn:ietf:rfc:1329" name="DC.Identifier"/>
<meta content="In this document an idea is submitted how IP and ARP can be used on
inhomogeneous FDDI networks (FDDI networks with single MAC and dual
MAC stations) by introducing a new protocol layer in the protocol
suite of the dual MAC stations. This memo provides information for the
Internet community. It does not specify an Internet standard." name="DC.Description.Abstract"/>
<meta content="P. Kuehn" name="DC.Creator"/>
<meta content="May, 1992" name="DC.Date.Issued"/>
<meta content="Thoughts on Address Resolution for Dual MAC FDDI Networks" name="DC.Title"/>

    <link href="https://tools.ietf.org/images/rfc.png" rel="icon" type="image/png"/>
    <link href="https://tools.ietf.org/images/rfc.png" rel="shortcut icon" type="image/png"/>
    <title>RFC 1329 - Thoughts on Address Resolution for Dual MAC FDDI Networks</title>
    
    
    <style type="text/css">
	@media only screen 
	  and (min-width: 992px)
	  and (max-width: 1199px) {
	    body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 768px)
	  and (max-width: 991px) {
            body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 480px)
	  and (max-width: 767px) {
            body { font-size: 11pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (max-width: 479px) {
            body { font-size: 8pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-device-width : 375px) 
	  and (max-device-width : 667px) {
            body { font-size: 9.5pt; }
            div.content { width: 96ex; margin: 0 1px; }
        }
	@media only screen 
	  and (min-device-width: 1200px) {
            body { font-size: 10pt; margin: 0 4em; }
            div.content { width: 96ex; margin: 0; }
        }
        h1, h2, h3, h4, h5, h6, .h1, .h2, .h3, .h4, .h5, .h6 {
	    font-weight: bold;
            line-height: 0pt;
            display: inline;
            white-space: pre;
            font-family: monospace;
            font-size: 1em;
	    font-weight: bold;
        }
        pre {
            font-size: 1em;
            margin-top: 0px;
            margin-bottom: 0px;
        }
	.pre {
	    white-space: pre;
	    font-family: monospace;
	}
	.header{
	    font-weight: bold;
	}
        .newpage {
            page-break-before: always;
        }
        .invisible {
            text-decoration: none;
            color: white;
        }
        a.selflink {
          color: black;
          text-decoration: none;
        }
        @media print {
            body {
                font-family: monospace;
                font-size: 10.5pt;
            }
            h1, h2, h3, h4, h5, h6 {
                font-size: 1em;
            }
        
            a:link, a:visited {
                color: inherit;
                text-decoration: none;
            }
            .noprint {
                display: none;
            }
        }
	@media screen {
	    .grey, .grey a:link, .grey a:visited {
		color: #777;
	    }
            .docinfo {
                background-color: #EEE;
            }
            .top {
                border-top: 7px solid #EEE;
            }
            .bgwhite  { background-color: white; }
            .bgred    { background-color: #F44; }
            .bggrey   { background-color: #666; }
            .bgbrown  { background-color: #840; }            
            .bgorange { background-color: #FA0; }
            .bgyellow { background-color: #EE0; }
            .bgmagenta{ background-color: #F4F; }
            .bgblue   { background-color: #66F; }
            .bgcyan   { background-color: #4DD; }
            .bggreen  { background-color: #4F4; }

            .legend   { font-size: 90%; }
            .cplate   { font-size: 70%; border: solid grey 1px; }
	}
    </style>
    <!--[if IE]>
    <style>
    body {
       font-size: 13px;
       margin: 10px 10px;
    }
    </style>
    <![endif]-->

    <script type="text/javascript"><!--
    function addHeaderTags() {
	var spans = document.getElementsByTagName("span");
	for (var i=0; i < spans.length; i++) {
	    var elem = spans[i];
	    if (elem) {
		var level = elem.getAttribute("class");
                if (level == "h1" || level == "h2" || level == "h3" || level == "h4" || level == "h5" || level == "h6") {
                    elem.innerHTML = "<"+level+">"+elem.innerHTML+"</"+level+">";		
                }
	    }
	}
    }
    var legend_html = "Colour legend:<br />      <table>         <tr><td>Unknown:</td>                   <td><span class='cplate bgwhite'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft:</td>                     <td><span class='cplate bgred'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Informational:</td>             <td><span class='cplate bgorange'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Experimental:</td>              <td><span class='cplate bgyellow'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Best Common Practice:</td>      <td><span class='cplate bgmagenta'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Proposed Standard:</td>         <td><span class='cplate bgblue'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft Standard (old designation):</td> <td><span class='cplate bgcyan'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Internet Standard:</td>         <td><span class='cplate bggreen'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Historic:</td>                  <td><span class='cplate bggrey'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Obsolete:</td>                  <td><span class='cplate bgbrown'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>     </table>";
    function showElem(id) {
        var elem = document.getElementById(id);
        elem.innerHTML = eval(id+"_html");
        elem.style.visibility='visible';
    }
    function hideElem(id) {
        var elem = document.getElementById(id);
        elem.style.visibility='hidden';        
        elem.innerHTML = "";
    }
    // -->
    </script>
</head>
<body onload="addHeaderTags()">
  <div class="content">
   <div style="height: 13px;">
      <div class="pre noprint docinfo bgorange" onclick="showElem('legend');" onmouseout="hideElem('legend')" onmouseover="this.style.cursor='pointer';" style="height: 6px; position: absolute;" title="Click for colour legend.">                                                                        </div>
      <div class="docinfo noprint pre legend" id="legend" onmouseout="hideElem('legend');" onmouseover="showElem('legend');" style="position:absolute; top: 4px; left: 4ex; visibility:hidden; background-color: white; padding: 4px 9px 5px 7px; border: solid #345 1px; ">
      </div>
   </div>
<span class="pre noprint docinfo top">[<a href="index.html" title="Document search and retrieval page">Docs</a>] [<a href="https://tools.ietf.org/rfc/rfc1329.txt" title="Plaintext version of this document">txt</a>|<a href="https://tools.ietf.org/pdf/rfc1329" title="PDF version of this document">pdf</a>] [<a href="https://datatracker.ietf.org/doc/rfc1329" title="IESG Datatracker information for this document">Tracker</a>]                                              </span><br/>
<span class="pre noprint docinfo">                                                                        </span><br/>
<span class="pre noprint docinfo">Updated by: <a href="rfc5494.html">5494</a>                                           INFORMATIONAL</span><br/>
<span class="pre noprint docinfo">                                                                        </span><br/>
<pre>Network Working Group                                           P. Kuehn
Request for Comments: 1329                                      May 1992


       <span class="h1">Thoughts on Address Resolution for Dual MAC FDDI Networks</span>

Status of this Memo

   This memo provides information for the Internet community.  It does
   not specify an Internet standard.  Distribution of this memo is
   unlimited.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/1.%20Abstract"></a><a class="selflink" href="#section-1" name="section-1">1</a>. Abstract</span>

   In this document an idea is submitted how IP and ARP can be used on
   inhomogeneous FDDI networks (FDDI networks with single MAC and dual
   MAC stations) by introducing a new protocol layer in the protocol
   suite of the dual MAC stations.  Thus two dual MAC stations are able
   to do a load splitting across the two rings and use the double
   bandwidth of 200 Mbits/s as single MAC stations.  The new layer is an
   extension of layer 3.  For the user, the higher layer protocols, IP
   and ARP the property "dual MAC" is transparent.  No modification is
   required in the protocol suite of single MAC stations and transparent
   bridges.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/2.%20Acknowledgements"></a><a class="selflink" href="#section-2" name="section-2">2</a>. Acknowledgements</span>

   This paper is a result of a diploma thesis prepared at the Technical
   University of Munich, Lehrstuhl fuer Kommunikationsnetze, in co-
   operation with the Siemens Nixdorf AG.  The author would like to
   thank Jrg Eberspher and Bernhard Edmaier from the university, Andreas
   Thimmel and Jens Horstmeier from the SNI AG at Augsburg for the
   helpful comments and discussions.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/3.%20Conventions"></a><a class="selflink" href="#section-3" name="section-3">3</a>. Conventions</span>

   Primary MAC, P-MAC           MAC, placed on the primary ring
   Secondary MAC, S-MAC         MAC, placed on the secondary ring
   Inhomogeneous ring           configuration of a dual FDDI ring with
                                single MAC and dual MAC stations

   DMARP                        Dual MAC Address Resolution Protocol

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/4.%20Assumptions"></a><a class="selflink" href="#section-4" name="section-4">4</a>. Assumptions</span>

   When a dual FDDI ring wraps, both MACs in a dual MAC station are
   assumed to remain connected to the ring.  ANSI is just investigating
   whether the Configuration Management in the Station Management of a



<span class="grey">Kuehn                                                           [Page 1]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-2" id="page-2" name="page-2"> </a>
<span class="grey"><a href="rfc1329.html">RFC 1329</a>     Address Resolution for Dual MAC FDDI Networks      May 1992</span>


   FDDI station can be modified to allow this.  According to the FDDI
   SMT standard [<a href="#ref-1" title='"FDDI Station Management (SMT)"'>1</a>], different addresses are required for all MACs on
   the primary and the secondary ring.

   In this paper, the MAC in a single MAC station is assumed to reside
   on the primary ring.  The application of single MAC stations which
   have their MAC attached to the secondary ring is not precluded, but
   therefor additional connectivity between the two rings is required.
   These configurations are beyond the scope of this document.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/5.%20The%20Application%20of%20Transparent%20Bridges"></a><a class="selflink" href="#section-5" name="section-5">5</a>. The Application of Transparent Bridges</span>

   Transparent bridges can provide links to other 802 LANs or further
   inhomogeneous FDDI rings.  The connection between two inhomogeneous
   FDDI rings can be realized by one or two transparent bridges. When
   two transparent bridges are used, one transparent bridge links the
   primary rings, the other the secondary rings.  If two secondary rings
   are connected by a transparent bridge, a path of transparent bridges
   must exist between the two primary rings.  No transparent bridges are
   allowed between the primary and the secondary ring.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/6.%20Protocol%20Layers%20in%20Single%20MAC%20Stations"></a><a class="selflink" href="#section-6" name="section-6">6</a>. Protocol Layers in Single MAC Stations</span>

   The new protocol layer, named load sharing layer, is drafted to be
   introduced only in dual MAC stations.  In single MAC stations, IP and
   ARP are working on top of the Subnetwork Access Protocol (SNAP) 04]
   and the Logical Link Control protocol (802.2 LLC) [<a href="#ref-3" title='"Information processing systems- Local area networks- Part 2: Logical link control"'>3</a>].  LLC type 1 is
   used because connectionless services are investigated only.























<span class="grey">Kuehn                                                           [Page 2]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-3" id="page-3" name="page-3"> </a>
<span class="grey"><a href="rfc1329.html">RFC 1329</a>     Address Resolution for Dual MAC FDDI Networks      May 1992</span>


      +--------------------------+
      |   IP                     |
      +--------------------------+
      +--------------------------+
      |   ARP                    |
      +--------------------------+
       |             |
       | ARP frames  | IP frames
       |             |
      +--------------------------+
      |   SNAP                   |
      +--------------------------+
      +--------------------------+
      |   LLC                    |
      +--------------------------+
      +--------------------------++-------+
      |   FDDI-MAC               || F     |
      +--------------------------+| D  S  |
      +--------------------------+| D  M  |
      |   FDDI PHY and PMD       || I  T  |
      +--------------------------++-------+

   For the ARP layer, the following model is assumed:
   +-------------------------------------------------------X-----------+
   |  - ARP entity -                                       |           |
   |                                                       | IP frames |
   | +----------------+   +----------------+ read          |           |
   | | Cache          |   |                | entries +-------------+   |
   | | Administration |-&gt;-|  Address Cache |------&gt;--| Address     |   |
   | +----------------+   |                |         | Conversion  |   |
   |     |                +----------------+         | Unit        |   |
   |     | ARP frames                                +-------------+   |
   |     |                                               / |           |
   |     | ___________ &lt;- ARP requests _________________/  | IP frames |
   |     |/                                                |           |
   +-----X-------------------------------------------------X-----------+

   The Address Conversion Unit handles the actual conversion of IP
   addresses to hardware addresses.  For this purpose, it uses the
   information in the ARP cache.  The cache administration communicates
   with other ARP entities by ARP and creates, deletes and renews the
   entries in the cache.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/7.%20Protocol%20Layers%20in%20Dual%20MAC%20Stations"></a><a class="selflink" href="#section-7" name="section-7">7</a>. Protocol Layers in Dual MAC Stations</span>

   The load sharing layer provides the same interface to ARP as SNAP
   does.  To exchange information about addresses and reachability, the
   load sharing entities in dual MAC stations communicate with the Dual



<span class="grey">Kuehn                                                           [Page 3]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-4" id="page-4" name="page-4"> </a>
<span class="grey"><a href="rfc1329.html">RFC 1329</a>     Address Resolution for Dual MAC FDDI Networks      May 1992</span>


   MAC Address Resolution Protocol (DMARP).  For the transmission of
   DMARP frames the SNAP SAP of LLC is used, as for IP and ARP, too.
   The Organizationally Unique Identifier (OUI) in the SNAP header is
   set to zero (24 bit), the EtherType field (16 bit) contains a new
   number indicating DMARP, which is not defined yet.

   +---------------------------------------------------------+
   |                         IP                              |
   +---------------------------------------------------------+
   +---------------------------------------------------------+
   |                         ARP                             |
   +---------------------------------------------------------+
             | ARP frames                 | IP frames
   +---------------------------------------------------------+
   |                 Load Sharing Layer                      |
   +---------------------------------------------------------+
    |        |        |          |        |        |
    | ARP    | DMARP  | IP       | ARP    | DMARP  | IP
    | frames | frames | frames   | frames | frames | frames
    |        |        |          |        |        |
   +-------------------------+  +----------------------------+
   |   SNAP 1                |  |    SNAP 2                  |
   +-------------------------+  +----------------------------+
   +-------------------------+  +----------------------------+
   |   LLC 1                 |  |    LLC 2                   |
   +-------------------------+  +----------------------------+
   +-------------------------+  +----------------------------++-------+
   |   Primary MAC           |  |    Secondary MAC           || F     |
   +-------------------------+  +----------------------------+| D  S  |
   +---------------------------------------------------------+| D  M  |
   |                  FDDI PHY and PMD                       || I  T  |
   +---------------------------------------------------------++-------+

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/8.%20Running%20Inhomogeneous%20FDDI%20Rings"></a><a class="selflink" href="#section-8" name="section-8">8</a>. Running Inhomogeneous FDDI Rings</span>

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/8.1.%20Exchange%20of%20Primary%20MAC%20Addresses%20between%20Stations"></a><a class="selflink" href="#section-8.1" name="section-8.1">8.1</a>. Exchange of Primary MAC Addresses between Stations</span>

   IP and higher layer protocols only use the network independent IP
   addresses.  The ARP entity takes upon the conversion of an IP address
   to the appropriate hardware address.  To make the property dual MAC"
   transparent, ARP may only know the addresses of MACs on the primary
   ring. Therefore, the load sharing entity always delivers ARP frames
   to SNAP 1 for transmission.  By this way, communication with ARP is
   done over the primary ring in normal state.  A secondary MAC can
   receive an ARP frame when the dual ring is wrapped and the
   destination hardware address is a multicast or broadcast address.
   These frames will be discarded because they were received twice.




<span class="grey">Kuehn                                                           [Page 4]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-5" id="page-5" name="page-5"> </a>
<span class="grey"><a href="rfc1329.html">RFC 1329</a>     Address Resolution for Dual MAC FDDI Networks      May 1992</span>


   By this way, the associations of IP addresses to primary MAC
   addresses for the single MAC and dual MAC stations are stored in the
   ARP cache.  The ARP cache contains no secondary MAC addresses.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/8.2.%20Exchange%20of%20Secondary%20MAC%20Addresses%20between%20Dual%20MAC%20Stations"></a><a class="selflink" href="#section-8.2" name="section-8.2">8.2</a>. Exchange of Secondary MAC Addresses between Dual MAC Stations</span>

   The load sharing layer needs to know the secondary MAC addresses of
   the other dual MAC stations.  The DMARP is used to get these
   addresses.  Whenever the load sharing entity delivers an ARP frame to
   SNAP 1, a DMARP reply frame will be sent on the secondary ring,
   containing the stations primary and secondary MAC address. The
   destination hardware address in this DMARP frame is the broadcast MAC
   address, the EtherType field in the SNAP header identifies DMARP.
   The IP destination address is copied from the ARP frame.  If the ARP
   frame that was transmitted parallel to the DMARP reply was a request,
   an ARP reply frame will be sent back to the sending station by the
   ARP entity in the receiving station. When the load sharing layer in
   the receiving station delivers this ARP reply frame to SNAP 1, it
   sends a DMARP reply frame on the secondary ring.

   By this way, DMARP exchanges the additionally required secondary MAC
   addresses between the dual MAC stations.  This is done parallel to
   the exchange of the ARP frames.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/8.3.%20Communication%20of%20Dual%20MAC%20Stations%20on%20Different%20Dual%20FDDI%20Rings"></a><a class="selflink" href="#section-8.3" name="section-8.3">8.3</a>. Communication of Dual MAC Stations on Different Dual FDDI Rings</span>

   If two inhomogeneous dual FDDI rings are connected by one transparent
   bridge, dual MAC stations placed on different dual FDDI rings cannot
   perform a load sharing.  If both dual FDDI rings remain in normal
   state, no DMARP reply frames get from one secondary ring to the other
   secondary ring.  A dual MAC station realizes another dual MAC station
   placed on the other dual ring as a single MAC station, because it
   only receives ARP frames from it.  If one of the dual rings is
   wrapped, a DMARP reply frame can get on the primary ring of the other
   dual ring.  A target station on the unwrapped ring receives this
   DMARP frame by the primary MAC and the load sharing entity stores the
   contained addresses in an entry in the address cache.  This entry is
   marked with a control bit, named the OR-bit Other ring bit").  No
   load sharing will be done with a station related to an entry with the
   OR-bit set.

   If both dual FDDI rings are wrapped, the MACs of all stations reside
   on one ring.  Now, dual MAC stations placed on different dual rings
   can communicate with DMARP.  If a DMARP reply frame is received by
   the primary MAC and no entry exists for the sending station, a new
   entry with OR-Bit set will be created.  Otherwise, the OR-bit will be
   set in the existing entry.  If a DMARP reply frame is received by the
   secondary MAC and an entry with OR-bit set already exists for the



<span class="grey">Kuehn                                                           [Page 5]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-6" id="page-6" name="page-6"> </a>
<span class="grey"><a href="rfc1329.html">RFC 1329</a>     Address Resolution for Dual MAC FDDI Networks      May 1992</span>


   sending station, the bit will not be reset.

   This mechanism provides that no load sharing will be done between
   Dual MAC stations on different dual rings if the dual rings are
   linked with one transparent bridge.  An additional DMARP error frame
   is used to provide against errors when a DMARP reply frame gets lost
   on the ring.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/8.4.%20Timeout%20of%20Entries%20Marked%20with%20OR-Bit%20Set"></a><a class="selflink" href="#section-8.4" name="section-8.4">8.4</a>. Timeout of Entries Marked with OR-Bit Set</span>

   If a FDDI ring is wrapped, the DMARP reply frames are received by the
   primary and secondary MACs of the target dual MAC stations.  In that
   case, the entries for dual MAC stations on the same dual ring are
   also marked with the OR-bit, although the load sharing is possible
   between these stations.

   When an OR-bit in an entry is set for the first time, a timer entity
   is started. If the timer entity runs out, a DMARP request frame is
   sent over SNAP 2 to the secondary MAC of the associated target)
   station.  Then the entry will be discarded.

   If the request cannot be received by the target station because the
   network configuration has changed, there is no entry in the address
   cache for this station any more and no load sharing is computed.  If
   the target station receives the DMARP request frame, it sends back a
   DMARP reply frame.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/8.5.%20Problems%20with%20the%20Application%20of%20Large%20FDDI%20Networks"></a><a class="selflink" href="#section-8.5" name="section-8.5">8.5</a>. Problems with the Application of Large FDDI Networks</span>

   With an increasing number of dual FDDI rings, each one linked
   together by two transparent bridges, the probability increases, that
   one of these inhomogeneous dual FDDI rings is wrapped in the moment
   when two dual MAC stations exchange ARP frames and DMARP replies.

   If two dual MAC stations are communicating for the first time, the
   probability decreases that a load sharing is really computed after
   the exchange of DMARP replies, although this would be possible
   according to the network configuration.  It relies upon the fact,
   that DMARP replies get to the primary ring over the wrapped dual ring
   and only entries marked with the OR-bit set are created. To solve
   this problem further expedients are invented:

   At first, entries in the address cache can be marked read-only by the
   setting of the R-bit.  In dual MAC stations, entries can be written
   manually for other dual MAC stations that are frequently talked to or
   that have a special importance.  The control bits of these entries
   cannot be changed by DMARP.




<span class="grey">Kuehn                                                           [Page 6]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-7" id="page-7" name="page-7"> </a>
<span class="grey"><a href="rfc1329.html">RFC 1329</a>     Address Resolution for Dual MAC FDDI Networks      May 1992</span>


   Next, additional control bits are introduced.  One of these bits is
   the Hold-bit (H-bit). When two dual MAC stations exchange ARP frames
   and DMARP replies to create entries in their address caches, one
   station starts sending a DMARP reply, first.  According to the
   network state, it sends an additional DMARP error frame, a moment
   later.  Within a maximum period of time (see "Configuring the Timer
   Parameters"), all frames arrive at the neighbour station and are
   received by the primary and/or secondary MAC.  If the OR-bit was not
   set for an entry within this period of time, it is clear, that no
   further DMARP frames will be received, which result in setting the
   OR-bit.  For such an entry the H-bit is set.  As the reception of
   reply and error frames is not sufficient for setting the OR-bit when
   the H-bit is set, the load sharing is assumed to be sure.  The
   correctness of the H-bit will be verified in relatively long time
   periods by queries (query and hold frames) at the station associated.

   For two communicating stations there exists a possibility to get
   information from a third station.  Always, when the OR-bit is set for
   an entry in a dual MAC station, a search frame is transmitted by the
   secondary MAC, containing the own primary MAC address and the primary
   MAC address of the counter station.  If a third station can compute a
   sure load sharing with both stations (the H-bit is set for the
   associated entries), the stations can perform a load sharing between
   them, too.  The third station informs these stations by sending found
   frames to them.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/8.6.%20Multicast%20and%20Broadcast%20Addresses%20in%20IP%20Frames"></a><a class="selflink" href="#section-8.6" name="section-8.6">8.6</a>. Multicast and Broadcast Addresses in IP Frames</span>

   If the destination hardware address of an IP frame is a multicast or
   broadcast hardware address, the frame is always delivered to SNAP 1
   and sent on the primary ring, because one of the addressed stations
   could be a single MAC station.  IP frames which are delivered to the
   load sharing entity by SNAP 2 are discarded by the load sharing
   entity.  Thus, the duplication of these frames can be prevented.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/9.%20Internal%20Structure"></a><a class="selflink" href="#section-9" name="section-9">9</a>. Internal Structure</span>

   One load Sharing entity exists in the load sharing layer.  This load
   sharing entity consists of the address cache, the cache
   administration and the multiplexer.











<span class="grey">Kuehn                                                           [Page 7]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-8" id="page-8" name="page-8"> </a>
<span class="grey"><a href="rfc1329.html">RFC 1329</a>     Address Resolution for Dual MAC FDDI Networks      May 1992</span>


   to ARP                                                     to ARP
   +----X----------------------------------------------------X--------+
   |    |                                                   | IP      |
   |    | ARP frames                            read        | frames  |
   |    |                                       entries     |         |
   | +----------------------------+   +---------+       +----------+  |
   | | Cache Administration       |-&gt;-| Address |----&gt;--|  Multi-  |  |
   | +----------------------------|-&gt;-| Cache   |       |  plexer  |  |
   |  |        |        |        |    +---------+       |          |  |
   |  |        |        |        |                      +----------+  |
   |  | ARP    | DMARP  | ARP    | DMARP                |        |    |
   |  | frames | frames | frames | frames            IP |     IP |    |
   |  |        |        |        |               frames | frames |    |
   |  |        |        |        |                      |        |    |
   +--X--------X--------X--------X-----------------------X--------X---+
   to SNAP 1         to SNAP 2                    to SNAP 1   to SNAP 2

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/9.1.%20The%20Address%20Cache"></a><a class="selflink" href="#section-9.1" name="section-9.1">9.1</a>. The Address Cache</span>

   In the address cache, the associations of primary MAC addresses to
   secondary MAC addresses are stored for other dual MAC stations on the
   network.  There are no entries for single MAC stations.

   Because the OR- and the LS-bit (see table) always have inverted
   values, one of the bits is redundant.  Afterwards the examination of
   an entry state gets easier by the introduction of both bits, they are
   defined together.  The ARP is able to support other protocol address
   formats than the IP format.  To support this ARP property by DMARP,
   the protocol type number as used in the ARP frames is stored in every
   entry of the address cache.  So, a dual MAC station is able to
   communicate with another station with DMARP, even if the other
   station does not use IP.  The numbers used in DMARP frames and the
   address cache for the protocol type and the address length are taken
   over from ARP.

   name               length     comment
   --------------------------------------------------------------------

   P-MAC address      48 bit     Address of the primary MAC
                                 in an other dual MAC station

   S-MAC address      48 bit     Address of the secondary MAC
                                 in that station

   LS-bit             1 bit      A load sharing can be performed
                                 with that station
                                 ("Load sharing bit")




<span class="grey">Kuehn                                                           [Page 8]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-9" id="page-9" name="page-9"> </a>
<span class="grey"><a href="rfc1329.html">RFC 1329</a>     Address Resolution for Dual MAC FDDI Networks      May 1992</span>


   OR-bit             1 bit      No load sharing may be done
                                 with that station
                                 ("Other ring bit")

   H-bit              1 bit      The load sharing with that
                                 station is trusty.
                                 ("Hold bit")

   Q-bit              1 bit      A query frame was sent to that
                                 station, no hold frame was
                                 received yet ("Query bit")

   R-bit              1 bit      This entry cannot be changed by
                                 DMARP ("Read-only bit")

   V-bit              1 bit      The entry is valid
                                 ("Valid bit")

   subscript          32 bit     Unique number, identifying this
                                 entry

   protocol type      16 bit     Number of the protocol type
                                 that was last used in that
                                 station

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/9.2.%20The%20Multiplexer"></a><a class="selflink" href="#section-9.2" name="section-9.2">9.2</a>. The Multiplexer</span>

   The multiplexer deals with multiplexing the IP frames upon the two
   FDDI rings.  Broadcast and multicast frames are always sent on the
   primary ring.  Otherwise, the contents of the address cache and a load
   sharing criteria are used to decide on which of the rings an IP frame
   has to be transmitted.  If there is no entry for the primary MAC
   address of the destination station in the cache, the IP frame is
   transmitted on the primary ring.  If there is an entry for the
   destination station and the LS-bit is set, a load sharing can be done
   with this station.  Later on a load sharing criteria, which is beyond
   the scope of this document, decides, which one of the rings is used
   for transmission.  An example for a load sharing criteria is the
   length of the transmit queues in the MACs.  The multiplexer requires an
   abstract function only, which returns the appropriate ring for the
   transmission of an actual IP frame.

   Additionally, the multiplexer filters the received IP frames:
   multicast or broadcast frames received from the secondary MAC are
   discarded.






<span class="grey">Kuehn                                                           [Page 9]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-10" id="page-10" name="page-10"> </a>
<span class="grey"><a href="rfc1329.html">RFC 1329</a>     Address Resolution for Dual MAC FDDI Networks      May 1992</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/9.3.%20The%20Cache%20Administration"></a><a class="selflink" href="#section-9.3" name="section-9.3">9.3</a>. The Cache Administration</span>

   The cache administration creates and deletes the entries in the
   address cache.  For this purpose, it communicates with other load
   sharing entities in other dual MAC stations with the DMARP.  The
   cache administration handles the delivery of ARP frames to the ARP
   and the SNAP entity in the station, respectively.

   The cache administration needs three timers for the communication with
   the DMARP, which have to be supported by the system environment.  Each
   of these timers must support a timer entity for each entry in the
   address cache, whereby a single one is running at a time.

   Supported timer services:

      TIMER_request(time, name, subscript)
      TIMER_response(name, subscript)
      TIMER_cancel(name, subscript):

   A timer entity is started by the service TIMER_request and cancelled
   by the TIMER_cancel service request. The TIMER_response service
   indicates that a timer entity has run out.  The parameter name is the
   name of a timer: OR-Entry-Timer, Hold-Timer, or Query-Timer.  Each
   entry in the address cache is uniquely identified by a number
   subscript).  This number is also the number of an associated timer
   entity.  How to dispose these numbers is a question of
   implementation.  The parameter time determines the time period when
   the timer runs out.  This parameter has the value OR-set-timeout for
   the OR-Entry-Timer, Hold-time for the Hold-Timer and Query-time for
   the Query-Timer.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/9.4.%20Configuring%20the%20Timer%20Parameters"></a><a class="selflink" href="#section-9.4" name="section-9.4">9.4</a>. Configuring the Timer Parameters</span>

   The OR-set-timeout parameter for the OR-Entry-Timer

      The period of time, determined by this parameter, should be
      essentially longer than the maximum time for a frame to travel
      around the entire network.  The expression entire network means
      the network which is constituted by the subnetworks linked
      together with transparent bridges.  When entries with OR-bit set
      are created continuously for a dual MAC station by the timeout
      mechanism, this parameter determines the periods of time between
      the consecutive requests that are sent to this station.  If the
      state of the dual FDDI ring changes and an entry with LS-bit set
      could be created, this parameter additionally determines the
      maximum time until the new entry is created.  (If an entry could
      not be created by transmission of search frames.)  Therefore, the
      OR-set-timeout parameter should be set to some 10 seconds.



<span class="grey">Kuehn                                                          [Page 10]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-11" id="page-11" name="page-11"> </a>
<span class="grey"><a href="rfc1329.html">RFC 1329</a>     Address Resolution for Dual MAC FDDI Networks      May 1992</span>


   The Hold-time parameter for the Hold-Timer

      The period of time, determined by this parameter, should as well
      be essentially longer than the maximum time for a frame to travel
      around the entire network.  When two stations communicate for the
      first time, they exchange ARP frames and DMARP replies.  The
      Hold-time parameter determines the period of time until the load
      sharing is assumed to be accomplished after the setting of the
      LS-bit.  In this period of time, the frames mentioned above must
      have reached its destination.  If an entry would be marked with
      the H-bit incorrectly, the time until it gets corrected will be
      relatively long (Query time).  Proposed dimension: several
      minutes.

   The Query-time parameter for the Query-Timer

      When an entry is marked with LS- and H-bit it is assumed, that
      load sharing can be performed with the associated station.  To
      allow the correction of a wrong value of the H-bit, the
      correctness of the H-bit is tested in periods of time, determined
      by the parameter Query-time.  It is tested whether a frame is
      received, which was sent by the secondary MAC to the secondary MAC
      address of the target station.  (The target station acknowledges
      the reception of the query frame by a hold frame.)  To limit the
      traffic caused by the query and hold frames, the parameter Query-
      time should be set to several minutes.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/9.5.%20Format%20of%20DMARP%20Frames"></a><a class="selflink" href="#section-9.5" name="section-9.5">9.5</a>. Format of DMARP Frames</span>

   fieldname            length            comment
   --------------------------------------------------------------------

   hardware type        16 bit            1 = "ethernet"

   protocol type        16 bit            2048D = "Internet
                                          Protocol"

   length of hardware   8 bit             Value in octets,
   addresses                              6 for 48 bit MAC addresses

   length of protocol   8 bit             Value in octets,
   addresses                              4 for Internet addresses

   operation            16 bit            1: "reply"
                                          2: "request"
                                          3: "error"
                                          4: "search"
                                          5: "found"



<span class="grey">Kuehn                                                          [Page 11]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-12" id="page-12" name="page-12"> </a>
<span class="grey"><a href="rfc1329.html">RFC 1329</a>     Address Resolution for Dual MAC FDDI Networks      May 1992</span>


                                          6: "query"
                                          7: "hold"

   1. hardware address  ... octets

   2. hardware address  ... octets

   protocol address     ... octets
   sender

   protocol address     ... octets
   receiver

   --------------------------------------------------------------------

   The value for the field "protocol type" is the same as in ARP frames.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/9.6.%20Contents%20of%20DMARP%20Frames"></a><a class="selflink" href="#section-9.6" name="section-9.6">9.6</a>. Contents of DMARP Frames</span>

   In the following tables of DMARP frames, the fields containing the
   length and type of protocol and hardware addresses are omitted.

   Format:

   +-------------------------------------------------------------+
   | Operation | 1. hardware | 2. hardware | protocol | protocol |
   |           | address     |    address  | address  | address  |
   |           |             |             | sender   | receiver |
   +-------------------------------------------------------------+

   Operation = 1 (reply), 2 (request), 3 (error):
   +-----------------------------------------------------------------+
   | Operation | P-MAC address | S-MAC address | protocol | protocol |
   |           | sender        | sender        | address  | address  |
   |           |               |               | sender   | receiver |
   +-----------------------------------------------------------------+

   +-------------------------------------------------------------------+
   | Operation=4 | P-MAC        | P-MAC address | protocol | broadcast |
   | (search)    | address      | counter-      | address  | protocol  |
   |             | sender       | station       | sender   | address   |
   +-------------------------------------------------------------------+

   +-------------------------------------------------------------------+
   | Operation=5 | P-MAC        | S-MAC address | protocol | broadcast |
   | (found)     | address      | counter-      | address  | protocol  |
   |             | sender       | station       | sender   | address   |
   +-------------------------------------------------------------------+



<span class="grey">Kuehn                                                          [Page 12]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-13" id="page-13" name="page-13"> </a>
<span class="grey"><a href="rfc1329.html">RFC 1329</a>     Address Resolution for Dual MAC FDDI Networks      May 1992</span>


   +-------------------------------------------------------------------+
   | Operation=6 | S-MAC        | P-MAC address | protocol | broadcast |
   | (query)     | address      | counter-      | address  | protocol  |
   |             | sender       | station       | sender   | address   |
   +-------------------------------------------------------------------+

   +-------------------------------------------------------------------+
   | Operation=7 | P-MAC address | S-MAC address | protocol | protocol |
   | (hold)      | sender        | sender        | address  | address  |
   |             |               |               | sender   | receiver |
   +-------------------------------------------------------------------+

   Apart from the error frames all frames are sent on the secondary
   ring.  The reply, error and search frames are addressed to the
   broadcast hardware address.  The request, found, query and hold
   frames are addressed to an individual secondary MAC address.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/10.%20Formal%20Description"></a><a class="selflink" href="#section-10" name="section-10">10</a>. Formal Description</span>

   The following description is written in ESTELLE.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/10.1.%20Global%20Constants%2C%20Variables%20and%20Types"></a><a class="selflink" href="#section-10.1" name="section-10.1">10.1</a>. Global Constants, Variables and Types</span>

default individual queue;

timescale ...;

type

 PDU_type        = ... ; (* format of a Protocol Data Unit:
                             String of variable length               *)
 HW_addr_type    = ... ; (* format of a 48 bit MAC address           *)
 PR_addr_type    = ... ; (* General: format of a protocol address
                            in an ARP or DMARP frame                 *)
 IP_addr_type    = ... ; (* General: format of an IP address         *)
 QoS_type        = ... ; (* General: format of a Quality-of-
                             -Service statement                      *)
 timer_name_type = ... ; (* Type for the name of a system timer      *)

 flag = (reset,set);

var

(*
  The values of these variables are set in the initialization part or
  by external management functions.
*)




<span class="grey">Kuehn                                                          [Page 13]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-14" id="page-14" name="page-14"> </a>
<span class="grey"><a href="rfc1329.html">RFC 1329</a>     Address Resolution for Dual MAC FDDI Networks      May 1992</span>


My_P_MAC_addr      : HW_addr_type; (* Address of the MAC, placed on
                                      the primary ring               *)
My_S_MAC_addr      : HW_addr_type; (* Address of the MAC, placed on
                                      the secondary ring             *)
My_IP_address      : IP_addr_type; (* IP address of this station     *)
Broadcast_HW_addr  : HW_addr_type; (* Broadcast MAC address (48 bit) *)
Broadcast_IP_addr  : IP_addr_type; (* Broadcast IP address           *)
dmarp_QoS          : QoS_type;     (* Quality_of_Service-statement
                                      for DMARP frames               *)

ethernet         : integer; (* Type statement in DMARP frames        *)
ip               : integer; (* Number for IP as protocol type        *)
fddi_addr_length : integer; (* Length of a MAC address in octetts    *)
ip_addr_length   : integer; (* Length of a IP address in octetts     *)

OR_set_timeout   : integer; (* Parameter for the OR-Entry-Timer      *)
Query_time       : integer; (* Parameter for the Hold-Timer          *)
Hold_time        : integer; (* Parameter for the Query-Timer         *)

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/10.2.%20Channels"></a><a class="selflink" href="#section-10.2" name="section-10.2">10.2</a>. Channels</span>

   channel SAPchn(User,Provider);
   by User :
    UNITDATA_request
    (
      Source_addr  : HW_addr_type;
      Dest_addr    : HW_addr_type;
      QoS          : QoS_type;
      PDU          : PDU_type;
    )
   by Provider :
    UNITDATA_indication
    (
      Source_addr  : HW_addr_type;
      Dest_addr    : HW_addr_type;
      QoS          : QoS_type;
      PDU          : PDU_type;
    )

   channel System_Access_Point_chn(User,Provider);
   by User:
    TIMER_request(Time       : integer;
                  Timer_id   : timer_name_type;
                  subscript  : integer);

    TIMER_cancel(Timer_id    : timer_name_type;
                 subscript   : integer);




<span class="grey">Kuehn                                                          [Page 14]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-15" id="page-15" name="page-15"> </a>
<span class="grey"><a href="rfc1329.html">RFC 1329</a>     Address Resolution for Dual MAC FDDI Networks      May 1992</span>


   by Provider:
    TIMER_response(Timer_id  : timer_name_type;
                   subscript : integer);


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/10.3.%20The%20Module%20Header%20and%20Interaction%20Points"></a><a class="selflink" href="#section-10.3" name="section-10.3">10.3</a>. The Module Header and Interaction Points</span>

   module LS_module systemprocess;
    ip LS_ARPSAP     : SAPchn(Provider);
       LS_IPSAP      : SAPchn(Provider);
       SNAP1_ARPSAP  : SAPchn(User);
       SNAP1_LSSAP   : SAPchn(User);
       SNAP1_IPSAP   : SAPchn(User);
       SNAP2_ARPSAP  : SAPchn(User);
       SNAP2_LSSAP   : SAPchn(User);
       SNAP2_IPSAP   : SAPchn(User);
       LS_System_Access_Point : System_Access_Point_chn(User);
   end;

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/10.4.%20The%20Modulebody%20of%20the%20Load%20Sharing%20Entity"></a><a class="selflink" href="#section-10.4" name="section-10.4">10.4</a>. The Modulebody of the Load Sharing Entity</span>

   body LS_body for LS_module;

   module multiplexer_module process;
    ip LS_IPSAP    : SAPchn(Provider);
       SNAP1_IPSAP : SAPchn(User);
       SNAP2_IPSAP : SAPchn(User);
   end;

   module cache_administration_module process;
    ip LS_ARPSAP    : SAPchn(Provider);
       SNAP1_ARPSAP : SAPchn(User);
       SNAP1_LSSAP  : SAPchn(User);
       SNAP2_ARPSAP : SAPchn(User);
       SNAP2_LSSAP  : SAPchn(User);
       LS_System_Access_Point : System_Access_Point_chn(User);
   end;

   body cache_administration_body for cache_administration_module;
     (* defined later *)
   end;

   body multiplexer_body for multiplexer_module;
     (* defined later *)
   end;

   modvar
    cache_administration : cache_administration_module;



<span class="grey">Kuehn                                                          [Page 15]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-16" id="page-16" name="page-16"> </a>
<span class="grey"><a href="rfc1329.html">RFC 1329</a>     Address Resolution for Dual MAC FDDI Networks      May 1992</span>


    multiplexer          : multiplexer_module;

   initialize
   begin
    ethernet         := 1;
    ip               := 2048;
    fddi_addr_length := 6;
    ip_addr_length   := 4;
    init cache_administration      with cache_administration_body;
    init multiplexer               with multiplexer_body;
    attach LS_IPSAP                to multiplexer.LS_IPSAP;
    attach SNAP1_IPSAP             to multiplexer.SNAP1_IPSAP;
    attach SNAP2_IPSAP             to multiplexer.SNAP2_IPSAP;
    attach LS_ARPSAP               to cache_administration.LS_ARPSAP;
    attach SNAP1_ARPSAP            to cache_administration.SNAP1_ARPSAP;
    attach SNAP1_LSSAP             to cache_administration.SNAP1_LSSAP;
    attach SNAP2_ARPSAP            to cache_administration.SNAP2_ARPSAP;
    attach SNAP2_LSSAP             to cache_administration.SNAP2_LSSAP;
    attach LS_System_Access_Point  to cache_administration.
                                       LS_System_Access_Point;
   end; end;

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/10.5.%20The%20Modulebody%20for%20the%20Multiplexer"></a><a class="selflink" href="#section-10.5" name="section-10.5">10.5</a>. The Modulebody for the Multiplexer</span>

body multiplexer_body for multiplexer_module;

type
  Type_of_addr_type = (individual, multi, broad);
  ring_type         = (primary, secondary);

var
  act_S_MAC_addr : HW_addr_type;

function determ_addrtype(HW_addr: HW_addr_type): Type_of_addr_type;
primitive;
(*
  Returns the type of a hardware address.
  (Individual, multicast or broadcast address)
*)

function get_cacheentry(prtype: integer; P_MAC_addr: HW_addr_type;
 var S_MAC_addr : HW_addr_type): boolean;
primitive;
(*
 Returns the associated secondary MAC address for a given primary MAC
 address and protocol type. If an entry exists, the value TRUE is
 returned.
*)



<span class="grey">Kuehn                                                          [Page 16]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-17" id="page-17" name="page-17"> </a>
<span class="grey"><a href="rfc1329.html">RFC 1329</a>     Address Resolution for Dual MAC FDDI Networks      May 1992</span>


function ls_criteria : ring_type;
(*
 Returns the ring on which the actual frame should be transmitted.
*)
primitive;

trans

when LS_IPSAP.UNITDATA_request(Source_addr,Dest_addr,QoS,PDU) begin
 if determ_addrtype(Dest_addr) &lt;&gt; individual then
 output SNAP1_IPSAP.UNITDATA_request(Source_addr,Dest_addr,QoS,PDU);
 else begin
  if get_cacheentry(ip,Dest_addr,act_S_MAC_addr) and
   (ls_criteria=secondary) then
  output SNAP2_IPSAP.UNITDATA_request(My_S_MAC_addr,
   act_S_MAC_addr,QoS,PDU);
  else
  output SNAP1_IPSAP.UNITDATA_request(Source_addr,Dest_addr,QoS,PDU);
 end;
end;

when SNAP1_IPSAP.UNITDATA_indication(Source_addr,Dest_addr,QoS,PDU)
begin
 output LS_IPSAP.UNITDATA_indication(Source_addr,Dest_addr,QoS,PDU);
end;

when SNAP2_IPSAP.UNITDATA_indication(Source_addr,Dest_addr,QoS,PDU)
begin
 if determ_addrtype(Dest_addr) = individual then begin
  Dest_addr := My_P_MAC_addr;
  output LS_IPSAP.UNITDATA_indication(Source_addr,Dest_addr,QoS,PDU);
 end;
end;

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/10.6.%20The%20Modulebody%20for%20the%20Cache%20Administration"></a><a class="selflink" href="#section-10.6" name="section-10.6">10.6</a>. The Modulebody for the Cache Administration</span>

body cache_administration_body for cache_administration_module;

type
 arp_pdu_type = record
  hwtype        : integer;
  prtype        : integer;
  HW_length     : integer;
  PR_length     : integer;
  operation     : (request,reply);
  HW_sender     : HW_addr_type;
  PR_sender     : PR_addr_type;
  HW_receiver   : HW_addr_type;



<span class="grey">Kuehn                                                          [Page 17]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-18" id="page-18" name="page-18"> </a>
<span class="grey"><a href="rfc1329.html">RFC 1329</a>     Address Resolution for Dual MAC FDDI Networks      May 1992</span>


  PR_receiver   : PR_addr_type;
 end;

 dmarp_operation_type = (request,reply,error,search,found,query,hold);

 dmarp_pdu_type = record
  hwtype        : integer;
  prtype        : integer;
  HW_length     : integer;
  PR_length     : integer;
  operation     : dmarpoperation_type;
  HW_1          : HW_addr_type;
  HW_2          : HW_addr_type;
  PR_sender     : PR_addr_type;
  PR_receiver   : PR_addr_type;
 end;

var
 arp_pdu        : arp_pdu_type;
 dmarp_pdu      : dmarp_pdu_type;
 send_pdu       : dmarp_pdu_type;
 act_P_MAC_addr : HW_addr_type;

function my_pr_address(prtype : integer ; praddr : PR_addr_type):
boolean;
(*
 Returns TRUE, if praddr is my station address, the protocol type is
 prtype. (2048d for the Internet protocol)
*)
primitive;

function get_my_pr_addr(prtype : integer) : PR_addr_type;
(*
 Returns my station address, the protocol has the number prtype.
*)

function extract_arp_pdu(PDU : PDU_type) : arp_pdu_type;
(*
 Returns the data contained in an ARP PDU as a record.
*)
primitive;

function extract_dmarp_pdu(PDU : PDU_type) : dmarp_pdu_type;
(*
 Returns the data contained in an DMARP PDU as a record.
*)
primitive;




<span class="grey">Kuehn                                                          [Page 18]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-19" id="page-19" name="page-19"> </a>
<span class="grey"><a href="rfc1329.html">RFC 1329</a>     Address Resolution for Dual MAC FDDI Networks      May 1992</span>


function assemble_dmarp_pdu(dmarp_pdu : dmarp_pdu_type): PDU;
(*
 Returns a DMARP PDU from the data in the record.
*)
primitive;

procedure create_entry(prtype: integer; P_MAC_addr: HW_addr_type;
 S_MAC_addr: HW_addr_type; LS_Bit: flag; OR_Bit: flag;
 H_Bit: flag; Q_Bit: flag; R_Bit: flag; V_Bit: flag);
(*
 Creates a new entry in the address cache, if no entry with the given
 primary MAC address or R-bit set to one exists. The protocol type has
 the number prtype. The control bits are set as given in the parameters,
 the LS-bit is set last.
*)
primitive;

function search_entry(prtype : integer; P_MAC_addr : HW_addr_type):
boolean;
(*
 Returns TRUE if an entry with the primary MAC address P_MAC_addr and
 the given protocol type was found in the address cache.
*)
primitive;

procedure update_entry(prtype: integer; P_MAC_addr: HW_addr_type;
 S_MAC_addr: HW_addr_type);
(*
 Searches an entry with the given primary MAC address P_MAC_address and
 updates the secondary MAC address in the entry if the R-bit is set to
 zero.
*)
primitive;

procedure reset_LS_bit(prtype: integer; P_MAC_addr : HW_addr_type);
(*
 Searches an entry with the given primary MAC address P_MAC_address and
 resets the LS-bit if the R-bit is reset.
*)
primitive;

procedure set_Q_bit(prtype: integer; P_MAC_addr : HW_addr_type);
(*
 Searches an entry with the given primary MAC address P_MAC_address and
 sets the Q-bit if the R-bit is reset.
*)
primitive;




<span class="grey">Kuehn                                                          [Page 19]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-20" id="page-20" name="page-20"> </a>
<span class="grey"><a href="rfc1329.html">RFC 1329</a>     Address Resolution for Dual MAC FDDI Networks      May 1992</span>


function H_bit_set(prtype: integer; P_MAC_addr : HW_addr_type):
boolean;
(*
 Returns TRUE if an entry exists with H-bit set to one and the given
 P-MAC address.
*)
primitive;

function OR_bit_set(prtype: integer; P_MAC_addr : HW_addr_type):
boolean;
(*
 Returns TRUE if an entry exists with OR-bit set to one and the given
 P-MAC address.
*)
primitive;

function LS_bit_set(prtype: integer; P_MAC_addr : HW_addr_type):
boolean;
(*
 Returns TRUE if an entry exists with LS-bit set to one and the given
 P-MAC address.
*)
primitive;

function Q_bit_set(prtype: integer; P_MAC_addr : HW_addr_type):
boolean;
(*
 Returns TRUE if an entry exists with Q-bit set to one and the given
 P-MAC address.
*)
primitive;

function get_subscript(prtype: integer; P_MAC_addr : HW_addr_type):
integer;
(*
 Returns the subscipt number of an entry with the given primary MAC
 address.
*)
primitive;

function get_broadcast_addr(prtype : integer): PR_addr_type;
(*
 Returns the broadcast protocol address for the given protocol type.
*)

function get_P_MAC_addr(subscript : integer) : HW_addr_type;
(*
 Returns the primary MAC address of the entry with the given subscript



<span class="grey">Kuehn                                                          [Page 20]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-21" id="page-21" name="page-21"> </a>
<span class="grey"><a href="rfc1329.html">RFC 1329</a>     Address Resolution for Dual MAC FDDI Networks      May 1992</span>


 number.
*)
primitive;

function get_S_MAC_addr(prtype: integer; P_MAC_addr: HW_addr_type):
 HW_addr_type;
(*
 Returns the secondary MAC address of the station with the given primary
 MAC address.
*)
primitive;

procedure delete_entry(subscript : integer);
(*
 Deletes the entry with the given subscript number if the R-bit is
 reset.
*)
primitive;

function get_pr_type(subscript : integer) : integer;
(*
 Returns the protocol type for the entry with the given subscript
 number.
*)
primitive;

function get_pr_length(prtype : integer) : integer;
(*
 Returns the length of a protocol address.
*)
primitive;


trans

when LS_ARPSAP.UNITDATA_request(Source_addr,Dest_addr,QoS,PDU)
begin
 arp_pdu := extract_arp_pdu(PDU);
 output SNAP1_ARPSAP.UNITDATA_request(Source_addr,Dest_addr,QoS,PDU);
 dmarp_pdu.hwtype               := ethernet;
 dmarp_pdu.prtype               := arp_pdu.prtype;
 dmarp_pdu.HW_length            := fddi_addr_length;
 dmarp_pdu.PR_length            := arp_pdu.PR_length;
 dmarp_pdu.operation            := reply;
 dmarp_pdu.HW_1                 := My_P_MAC_addr;
 dmarp_pdu.HW_2                 := My_S_MAC_addr;
 dmarp_pdu.PR_sender            := arp_pdu.PR_sender;
 dmarp_pdu.PR_receiver          := arp_pdu.PR_receiver;



<span class="grey">Kuehn                                                          [Page 21]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-22" id="page-22" name="page-22"> </a>
<span class="grey"><a href="rfc1329.html">RFC 1329</a>     Address Resolution for Dual MAC FDDI Networks      May 1992</span>


 PDU := assemble_dmarp_pdu(dmarp_pdu);
 output SNAP2_LSSAP.UNITDATA_request(My_S_MAC_addr,Broadcast_HW_addr,
  dmarp_QoS,PDU);
end;


when SNAP1_ARPSAP.UNITDATA_indication(Source_addr,Dest_addr,QoS,PDU)
begin
 output LS_ARPSAP.UNITDATA_indication(Source_addr,Dest_addr,QoS,PDU);
end;

when SNAP2_ARPSAP.UNITDATA_indication(Source_addr,Dest_addr,QoS,PDU)
begin end;

when SNAP1_LSSAP.UNITDATA_indication(Source_addr,Dest_addr,QoS,PDU)
begin
 dmarp_pdu := extract_dmarp_pdu(PDU);
 if ((dmarp_pdu.operation = error) or (dmarp_pdu.operation = reply))
 then begin
  if my_pr_address(dmarp_pdu.prtype,dmarp_pdu.PR_receiver) then begin
   if not H_bit_set(dmarp_pdu.prtype,dmarp_pdu.HW_1) then begin
    if not OR_bit_set(dmarp_pdu.prtype,dmarp_pdu.HW_1) then begin
     if LS_bit_set(dmarp_pdu.prtype,dmarp_pdu.HW_1) then begin
      output LS_System_Access_point.TIMER_cancel(
       "Hold_Timer",get_subscript(dmarp_pdu.prtype,dmarp_pdu.HW_1));
      create_entry(dmarp_pdu.prtype,dmarp_pdu.HW_1,dmarp_pdu.HW_2,
       reset,set,reset,reset,reset,set);
     end;
     output LS_System_Access_point.TIMER_request(
      OR_set_timeout,"OR_Entry_Timer",
      get_subscript(dmarp_pdu.prtype,dmarp_pdu.HW_1));
     send_pdu.hwtype    := ethernet;
     send_pdu.prtype    := dmarp_pdu.prtype;
     send_pdu.HW_length := fddi_addr_length;
     send_pdu.PR_length := dmarp_pdu.PR_length;
     send_pdu.operation := search;
     send_pdu.HW_1      := My_P_MAC_addr;
     send_pdu.HW_2      := dmarp_pdu.HW_1;
     send_pdu.PR_sender := get_my_pr_addr(dmarp_pdu.prtype);
     send_pdu.PR_receiver := get_broadcast_addr(dmarp_pdu.prtype);
     PDU := assemble_dmarp_pdu(dmarp_pdu);
     output SNAP2_LSSAP.UNITDATA_request(
      My_S_MAC_addr,Broadcast_HW_addr,dmarp_QoS,PDU);
    end else begin
     if dmarp_pdu.operation=error then
     update_entry(dmarp_pdu.prtype,dmarp_pdu.HW_1,dmarp_pdu.HW_2);
    end;
   end else begin



<span class="grey">Kuehn                                                          [Page 22]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-23" id="page-23" name="page-23"> </a>
<span class="grey"><a href="rfc1329.html">RFC 1329</a>     Address Resolution for Dual MAC FDDI Networks      May 1992</span>


    if dmarp_pdu.operation = error then
    update_entry(dmarp_pdu.prtype,dmarp_pdu.HW_1,dmarp_pdu.HW_2);
   end;
  end else begin
   if my_pr_address(dmarp_pdu.prtype,dmarp_pdu.PR_sender) and
    (dmarp_pdu.operation = reply) then begin
    dmarp_pdu.operation := error;
    PDU := assemble_dmarp_pdu(dmarp_pdu);
    output SNAP1_LSSAP.UNITDATA_request(
     My_P_MAC_addr,Broadcast_HW_addr,dmarp_QoS,PDU);
   end else begin
    if dmarp_pdu.operation=error and
     search_entry(dmarp_pdu.prtype,dmarp_pdu.HW_1) then
    update_entry(dmarp_pdu.prtype,dmarp_pdu.HW_1,dmarp_pdu.HW_2);
end; end; end; end;


when SNAP2_LSSAP.UNITDATA_indication(Source_addr,Dest_addr,QoS,PDU)
begin
 dmarp_pdu := extract_dmarp_pdu(PDU);
 if (dmarp_pdu.operation = found) and
  my_pr_address(dmarp_pdu.prtype,dmarp_pdu.PR_receiver) then begin
  if not H_bit_set(dmarp_pdu.prtype,dmarp_pdu.HW_1) then begin
   if OR_bit_set(dmarp_pdu.prtype,dmarp_pdu.HW_1) then begin
    output LS_System_Access_Point.
     TIMER_cancel("OR_Entry_Timer",
     get_subscript(dmarp_pdu.prtype,dmarp_pdu.HW_1));
   end;
   if LS_bit_set(dmarp_pdu.prtype,dmarp_pdu.HW_1) then begin
    output LS_System_Access_Point.
     TIMER_cancel("Hold_Timer",
     get_subscript(dmarp_pdu.prtype,dmarp_pdu.HW_1));
   end;
   create_entry(dmarp_pdu.prtype,dmarp_pdu.HW_1,dmarp_pdu.HW_2,
    set,reset,set,reset,reset,set);
   output LS_System_Access_Point.TIMER_request(Query_time,"Query_Timer",
    get_subscript(dmarp_pdu.prtype,dmarp_pdu.HW_1));
  end;
 end else begin
  if (dmarp_pdu.operation = reply) or
   (dmarp_pdu.operation = request) then begin
   if search_entry(dmarp_pdu.prtype,dmarp_pdu.HW_1) then
    update_entry(dmarp_pdu.prtype,dmarp_pdu.HW_1,dmarp_pdu.HW_2);
  end;
  if (dmarp_pdu.operation=request) and
   my_pr_address(dmarp_pdu.prtype,dmarp_pdu.PR_receiver) then begin
   send_pdu.hwtype      := dmarp_pdu.hwtype;
   send_pdu.prtype      := dmarp_pdu.prtype;



<span class="grey">Kuehn                                                          [Page 23]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-24" id="page-24" name="page-24"> </a>
<span class="grey"><a href="rfc1329.html">RFC 1329</a>     Address Resolution for Dual MAC FDDI Networks      May 1992</span>


   send_pdu.HW_length   := fddi_addr_length;
   send_pdu.PR_length   := dmarp_pdu.PR_length;
   send_pdu.operation   := reply;
   send_pdu.HW_1        := My_P_MAC_addr;
   send_pdu.HW_2        := My_S_MAC_addr;
   send_pdu.PR_sender   := get_my_pr_addr(dmarp_pdu.prtype);
   send_pdu.PR_receiver := dmarp_pdu.PR_sender;
   PDU := assemble_dmarp_pdu(dmarp_pdu);
   output SNAP2_LSSAP.UNITDATA_request(
    My_S_MAC_addr,Broadcast_HW_addr,dmarp_QoS,PDU);
  end else begin
   if my_pr_address(dmarp_pdu.prtype,dmarp_pdu.pr_receiver) then begin
    case dmarp_pdu.operation of
     reply: begin
      if not ( OR_bit_set(dmarp_pdu.prtype,dmarp_pdu.HW_1) or
       LS_bit_set(dmarp_pdu.prtype,dmarp_pdu.HW_1) )then begin
       create_entry(dmarp_pdu.prtype,dmarp_pdu.HW_1,dmarp_pdu.HW_2,
        set,reset,reset,reset,reset,set);
       output LS_System_Access_Point.TIMER_request(Hold_time,
        "Hold_Timer",get_subscript(dmarp_pdu.prtype,dmarp_pdu.HW_1));
      end;
     end;

     error: begin
      if not ( OR_bit_set(dmarp_pdu.prtype,dmarp_pdu.HW_1) or
       H_bit_set(dmarp_pdu.prtype,dmarp_pdu.HW_1) ) then begin
       if LS_bit_set(dmarp_pdu.prtype,dmarp_pdu.HW_1) then
       output LS_System_access_point.TIMER_cancel(
        "Hold_Timer",get_subscript(dmarp_pdu.prtype,dmarp_pdu.HW_1));
       create_entry(dmarp_pdu.prtype,dmarp_pdu.HW_1,dmarp_pdu.HW_2,
        reset,set,reset,reset,reset,set);
       output LS_System_access_point.TIMER_request(
        OR_set_timeout,"OR_Entry_Timer",
        get_subscript(dmarp_pdu.prtype,dmarp_pdu.HW_1));
       send_pdu.hwtype          := ethernet;
       send_pdu.prtype          := dmarp_pdu.prtype;
       send_pdu.HW_length       := fddi_addr_length;
       send_pdu.PR_length       := dmarp_pdu.PR_length;
       send_pdu.operation       := search;
       send_pdu.HW_1            := My_P_MAC_addr;
       send_pdu.HW_2            := dmarp_pdu.HW_1;
       send_pdu.PR_sender       := get_my_pr_addr(dmarp_pdu.prtype);
       send_pdu.PR_receiver     := get_broadcast_addr(dmarp_pdu.prtype);
       PDU := assemble_dmarp_pdu(dmarp_pdu);
       output SNAP2_LSSAP.UNITDATA_request(
        My_S_MAC_addr,Broadcast_HW_addr,dmarp_QoS,PDU);
      end;
     end;



<span class="grey">Kuehn                                                          [Page 24]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-25" id="page-25" name="page-25"> </a>
<span class="grey"><a href="rfc1329.html">RFC 1329</a>     Address Resolution for Dual MAC FDDI Networks      May 1992</span>


     search: begin
      if not (dmarp_pdu.HW_1=My_P_MAC_addr or
       dmarp_pdu.HW_2=My_P_MAC_addr) then begin
       if H_bit_set(dmarp_pdu.prtype,dmarp_pdu.HW_1) and
        H_bit_set(dmarp_pdu.prtype,dmarp_pdu.HW_2) then begin
        send_pdu.hwtype      := ethernet;
        send_pdu.prtype      := dmarp_pdu.prtype;
        send_pdu.HW_length   := fddi_addr_length;
        send_pdu.PR_length   := dmarp_pdu.PR_length;
        send_pdu.operation   := found;
        send_pdu.HW_1        := dmarp_pdu.HW_2;
        send_pdu.HW_2        := get_S_MAC_addr(dmarp_pdu.prtype,
                                 dmarp_pdu.HW_2);
        send_pdu.PR_sender   := get_my_pr_addr(dmarp_pdu.prtype);
        send_pdu.PR_receiver := get_broadcast_addr(dmarp_pdu.prtype);
        PDU := assemble_dmarp_pdu(send_pdu);
        output SNAP2_LSSAP.UNITDATA_request(My_S_MAC_addr,
         get_S_MAC_addr(dmarp_pdu.prtype,dmarp_pdu.HW_1),dmarp_QoS,PDU);
        send_pdu.HW_1 := dmarp_pdu.HW_1;
        send_pdu.HW_2 := get_S_MAC_addr(dmarp_pdu.prtype,
         dmarp_pdu.HW_1);
        PDU := assemble_dmarp_pdu(send_pdu);
        output SNAP2_LSSAP.UNITDATA_request(My_S_MAC_addr,
         get_S_MAC_addr(dmarp_pdu.prtype,dmarp_pdu.HW_2),dmarp_QoS,PDU);
       end;
      end;
     end;


     Query: begin
      if dmarp_pdu.HW_2 = My_P_MAC_addr then begin
       send_pdu.hwtype          := ethernet;
       send_pdu.prtype          := dmarp_pdu.prtype;
       send_pdu.HW_length       := dmarp_pdu.HW_length;
       send_pdu.PR_length       := dmarp_pdu.PR_length;
       send_pdu.operation       := hold;
       send_pdu.HW_1            := My_P_MAC_addr;
       send_pdu.HW_2            := My_S_MAC_addr;
       send_pdu.PR_sender       := get_my_pr_addr(dmarp_pdu.prtype);
       send_pdu.PR_receiver     := dmarp_pdu.PR_sender;
       PDU := assemble_dmarp_pdu(send_pdu);
       output SNAP2_LSSAP.UNITDATA_request(
        My_S_MAC_addr,dmarp_pdu.HW_1,dmarp_QoS,PDU);
      end;
     end;
     Hold: begin
      if H_bit_set(dmarp_pdu.prtype,dmarp_pdu.HW_1) then
      reset_Q_bit(dmarp_pdu.prtype,dmarp_pdu.HW_1);



<span class="grey">Kuehn                                                          [Page 25]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-26" id="page-26" name="page-26"> </a>
<span class="grey"><a href="rfc1329.html">RFC 1329</a>     Address Resolution for Dual MAC FDDI Networks      May 1992</span>


     end;
    end;
   end;
  end;
 end;
end;


when LS_System_Access_Point.TIMER_response(Timer_name,subscript) begin
case Timer_name of
 "OR_Entry_Timer": begin
  act_P_MAC_addr := get_P_MAC_addr(subscript);
  if OR_bit_set(get_pr_type(subscript),act_P_MAC_addr) then begin
   send_pdu.hwtype      := ethernet;
   send_pdu.prtype      := get_pr_type(subscript);
   send_pdu.HW_length   := fddi_addr_length;
   send_pdu.PR_length   := get_pr_length(send_pdu.prtype);
   send_pdu.operation   := request;
   send_pdu.HW_1        := My_P_MAC_addr;
   send_pdu.HW_2        := My_S_MAC_addr;
   send_pdu.PR_sender   := get_my_pr_addr(send_pdu.prtype);
   send_pdu.PR_receiver := get_broadcast_addr(send_pdu.prtype);
   PDU := assemble_dmarp_pdu(send_pdu);
   output SNAP2_LSSAP.UNITDATA_request(
    My_S_MAC_addr,get_S_MAC_addr(send_pdu.prtype,act_P_MAC_addr),
    dmarp_QoS,PDU);
   delete_entry(subscript);
  end;
 end;
 "Hold_Timer": begin
  act_P_MAC_addr := get_P_MAC_addr(subscript);
  if (not H_bit_set(get_pr_type(subscript),act_P_MAC_addr)) and
   LS_bit_set(get_pr_type(subscript),act_P_MAC_addr) then begin
   set_H_bit(get_pr_type(subscript),act_P_MAC_addr);
   output LS_System_Access_point.TIMER_request(
    Query_time,"Query_Timer",subscript);
  end;
 end;
 "Query_Timer": begin
  act_P_MAC_addr       := get_P_MAC_addr(subscript);
  send_pdu.hwtype      := ethernet;
  send_pdu.prtype      := get_pr_type(subscript);
  send_pdu.HW_length   := fddi_addr_length;
  send_pdu.PR_length   := get_pr_length(send_pdu.prtype);
  send_pdu.PR_sender   := get_my_pr_addr(send_pdu.prtype);
  send_pdu.PR_receiver := get_broadcast_addr(send_pdu.prtype);
  if Q_bit_set(get_pr_type(subscript),act_P_MAC_addr) then begin
   send_pdu.HW_1      := My_P_MAC_addr;



<span class="grey">Kuehn                                                          [Page 26]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-27" id="page-27" name="page-27"> </a>
<span class="grey"><a href="rfc1329.html">RFC 1329</a>     Address Resolution for Dual MAC FDDI Networks      May 1992</span>


   send_pdu.HW_2      := My_S_MAC_addr;
   send_pdu.operation := request;
   PDU := assemble_dmarp_pdu(send_pdu);
   output SNAP2_LSSAP.UNITDATA_request(
    My_S_MAC_addr,get_S_MAC_addr(send_pdu.prtype,act_P_MAC_addr),
    dmarp_QoS,PDU);
   delete_entry(subscript);
  end else begin
   send_pdu.HW_1      := My_S_MAC_addr;
   send_pdu.HW_2      := get_P_MAC_addr(subscript);
   send_pdu.operation := query;
   PDU := assemble_dmarp_pdu(send_pdu);
   output SNAP2_LSSAP.UNITDATA_request(
    My_S_MAC_addr,get_S_MAC_addr(send_pdu.prtype,send_pdu.HW_2),
    dmarp_QoS,PDU);
   set_Q_bit(send_pdu.prtype,send_pdu.HW_2);
end; end; end; end; end; (* body *)

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/11.%20Summary"></a><a class="selflink" href="#section-11" name="section-11">11</a>. Summary</span>

   The introduction of the load sharing layer in the protocol layering
   of the dual MAC stations allows the application of IP and ARP on
   inhomogeneous FDDI rings. The protocol suite of single MAC stations
   needs no modification.

   By the load sharing layer, the property "dual MAC" is transparent for
   ARP, IP and the higher layer protocols.

   In dual MAC stations, any load sharing criteria may be implemented in
   the multiplexer of the load sharing entity.  The conversion of
   addresses, the exchange of address and reachability information
   between dual MAC stations and the proper transmission of multicast
   and broadcast frames is taken upon by the load sharing entity.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/12.%20References"></a><a class="selflink" href="#section-12" name="section-12">12</a>. References</span>

    [<a id="ref-1" name="ref-1">1</a>] ANSI, "FDDI Station Management (SMT)", ANSI
        X3T9/90-X3T9.5/84-49 Rev 6.2, May 1990.

    [<a id="ref-2" name="ref-2">2</a>] ANSI, "FDDI Media Access Control (MAC-2)",
        X3T9/90-X3T9.5/88-139 Rev 3.2, June 1990.

    [<a id="ref-3" name="ref-3">3</a>] ISO, "Information processing systems- Local area networks-
        Part 2: Logical link control", ISO 8802-2:1989, August 1989.

    [<a id="ref-4" name="ref-4">4</a>] IEEE, "Draft Standard P802.1A Overview and Architecture",
        P802.1A/D9-89/74, September 1989.




<span class="grey">Kuehn                                                          [Page 27]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-28" id="page-28" name="page-28"> </a>
<span class="grey"><a href="rfc1329.html">RFC 1329</a>     Address Resolution for Dual MAC FDDI Networks      May 1992</span>


    [<a id="ref-5" name="ref-5">5</a>] Plummer, C., "An Ethernet Address Resolution Protocol --or--
        Converting Network Protocol Addresses to 48.bit Ethernet
        Address for Transmission on Ethernet Hardware", <a href="rfc826.html">RFC 826</a>, MIT,
        November 1982.

    [<a id="ref-6" name="ref-6">6</a>] Reynolds, J., and Postel, J., "Assigned Numbers", <a href="rfc1060.html">RFC 1060</a>,
        USC/Information Sciences Institute, March 1990.

    [<a id="ref-7" name="ref-7">7</a>] Postel, J., "Internet Protocol", <a href="rfc791.html">RFC 791</a>, USC/Information
        Sciences Institute, September 1981.

    [<a id="ref-8" name="ref-8">8</a>] Katz, D., "A Proposed Standard for the Transmission of IP
        Datagrams over FDDI Networks", <a href="rfc1188.html">RFC 1188</a>, Merit/NSFNET,
        October 1990.

    [<a id="ref-9" name="ref-9">9</a>] Internet Engineering Task Force, Braden, R., Editor,
        "Requirements for Internet Hosts -- Communication Layers",
        <a href="rfc1122.html">RFC 1122</a>, IETF, October 1989.

   [<a id="ref-10" name="ref-10">10</a>] Katz, D., "The Use of Connectionless Network Layer Protocols
        over FDDI Networks", Merit/NSFNET, 1990.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/13.%20%20Security%20Considerations"></a><a class="selflink" href="#section-13" name="section-13">13</a>.  Security Considerations</span>

   Security issues are not discussed in this memo.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/14.%20Author%27s%20Address"></a><a class="selflink" href="#section-14" name="section-14">14</a>. Author's Address</span>

   Peter Kuehn
   Raiffeisenstrasse 9b
   8933 Untermeitingen
   Germany

   Phone: .. 82 32 / 7 46 02
   EMail: thimmela@sniabg.wa.sni.de
















Kuehn                                                          [Page 28]

</pre><br/>
    <span class="noprint"><small><small>Html markup produced by rfcmarkup 1.126, available from
      <a href="https://tools.ietf.org/tools/rfcmarkup/">https://tools.ietf.org/tools/rfcmarkup/</a>
    </small></small></span>
  </div>




</body><!-- Mirrored from tools.ietf.org/html/rfc1329 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 06 Mar 2018 23:18:58 GMT --></html>