<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml"><!-- Mirrored from tools.ietf.org/html/rfc203 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 06 Mar 2018 23:19:03 GMT --><!-- Added by HTTrack --><head><meta content="text/html;charset=utf-8" http-equiv="content-type"/><!-- /Added by HTTrack -->

    <meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
    <meta content="index,follow" name="robots"/>
    <meta content="rfcmarkup version 1.126" name="creator"/>
    <link href="http://purl.org/dc/elements/1.1/" rel="schema.DC"/>
<meta content="urn:ietf:rfc:203" name="DC.Identifier"/>
<meta content="R.B. Kalin" name="DC.Creator"/>
<meta content="August, 1971" name="DC.Date.Issued"/>
<meta content="Achieving reliable communication" name="DC.Title"/>

    <link href="https://tools.ietf.org/images/rfc.png" rel="icon" type="image/png"/>
    <link href="https://tools.ietf.org/images/rfc.png" rel="shortcut icon" type="image/png"/>
    <title>RFC 203 - Achieving reliable communication</title>
    
    
    <style type="text/css">
	@media only screen 
	  and (min-width: 992px)
	  and (max-width: 1199px) {
	    body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 768px)
	  and (max-width: 991px) {
            body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 480px)
	  and (max-width: 767px) {
            body { font-size: 11pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (max-width: 479px) {
            body { font-size: 8pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-device-width : 375px) 
	  and (max-device-width : 667px) {
            body { font-size: 9.5pt; }
            div.content { width: 96ex; margin: 0 1px; }
        }
	@media only screen 
	  and (min-device-width: 1200px) {
            body { font-size: 10pt; margin: 0 4em; }
            div.content { width: 96ex; margin: 0; }
        }
        h1, h2, h3, h4, h5, h6, .h1, .h2, .h3, .h4, .h5, .h6 {
	    font-weight: bold;
            line-height: 0pt;
            display: inline;
            white-space: pre;
            font-family: monospace;
            font-size: 1em;
	    font-weight: bold;
        }
        pre {
            font-size: 1em;
            margin-top: 0px;
            margin-bottom: 0px;
        }
	.pre {
	    white-space: pre;
	    font-family: monospace;
	}
	.header{
	    font-weight: bold;
	}
        .newpage {
            page-break-before: always;
        }
        .invisible {
            text-decoration: none;
            color: white;
        }
        a.selflink {
          color: black;
          text-decoration: none;
        }
        @media print {
            body {
                font-family: monospace;
                font-size: 10.5pt;
            }
            h1, h2, h3, h4, h5, h6 {
                font-size: 1em;
            }
        
            a:link, a:visited {
                color: inherit;
                text-decoration: none;
            }
            .noprint {
                display: none;
            }
        }
	@media screen {
	    .grey, .grey a:link, .grey a:visited {
		color: #777;
	    }
            .docinfo {
                background-color: #EEE;
            }
            .top {
                border-top: 7px solid #EEE;
            }
            .bgwhite  { background-color: white; }
            .bgred    { background-color: #F44; }
            .bggrey   { background-color: #666; }
            .bgbrown  { background-color: #840; }            
            .bgorange { background-color: #FA0; }
            .bgyellow { background-color: #EE0; }
            .bgmagenta{ background-color: #F4F; }
            .bgblue   { background-color: #66F; }
            .bgcyan   { background-color: #4DD; }
            .bggreen  { background-color: #4F4; }

            .legend   { font-size: 90%; }
            .cplate   { font-size: 70%; border: solid grey 1px; }
	}
    </style>
    <!--[if IE]>
    <style>
    body {
       font-size: 13px;
       margin: 10px 10px;
    }
    </style>
    <![endif]-->

    <script type="text/javascript"><!--
    function addHeaderTags() {
	var spans = document.getElementsByTagName("span");
	for (var i=0; i < spans.length; i++) {
	    var elem = spans[i];
	    if (elem) {
		var level = elem.getAttribute("class");
                if (level == "h1" || level == "h2" || level == "h3" || level == "h4" || level == "h5" || level == "h6") {
                    elem.innerHTML = "<"+level+">"+elem.innerHTML+"</"+level+">";		
                }
	    }
	}
    }
    var legend_html = "Colour legend:<br />      <table>         <tr><td>Unknown:</td>                   <td><span class='cplate bgwhite'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft:</td>                     <td><span class='cplate bgred'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Informational:</td>             <td><span class='cplate bgorange'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Experimental:</td>              <td><span class='cplate bgyellow'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Best Common Practice:</td>      <td><span class='cplate bgmagenta'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Proposed Standard:</td>         <td><span class='cplate bgblue'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft Standard (old designation):</td> <td><span class='cplate bgcyan'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Internet Standard:</td>         <td><span class='cplate bggreen'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Historic:</td>                  <td><span class='cplate bggrey'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Obsolete:</td>                  <td><span class='cplate bgbrown'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>     </table>";
    function showElem(id) {
        var elem = document.getElementById(id);
        elem.innerHTML = eval(id+"_html");
        elem.style.visibility='visible';
    }
    function hideElem(id) {
        var elem = document.getElementById(id);
        elem.style.visibility='hidden';        
        elem.innerHTML = "";
    }
    // -->
    </script>
</head>
<body onload="addHeaderTags()">
  <div class="content">
   <div style="height: 13px;">
      <div class="pre noprint docinfo bgwhite" onclick="showElem('legend');" onmouseout="hideElem('legend')" onmouseover="this.style.cursor='pointer';" style="height: 6px; position: absolute;" title="Click for colour legend.">                                                                        </div>
      <div class="docinfo noprint pre legend" id="legend" onmouseout="hideElem('legend');" onmouseover="showElem('legend');" style="position:absolute; top: 4px; left: 4ex; visibility:hidden; background-color: white; padding: 4px 9px 5px 7px; border: solid #345 1px; ">
      </div>
   </div>
<span class="pre noprint docinfo top">[<a href="index.html" title="Document search and retrieval page">Docs</a>] [<a href="https://tools.ietf.org/rfc/rfc203.txt" title="Plaintext version of this document">txt</a>|<a href="https://tools.ietf.org/pdf/rfc203" title="PDF version of this document">pdf</a>] [<a href="https://datatracker.ietf.org/doc/rfc203" title="IESG Datatracker information for this document">Tracker</a>]                                              </span><br/>
<span class="pre noprint docinfo">                                                                        </span><br/>
<span class="pre noprint docinfo">                                                                        </span><br/>
<span class="pre noprint docinfo">                                                                        </span><br/>
<pre>Network Working Group                                           R. Kalin
Request for Comments: 203                                MIT Lincoln Lab
NIC: 7168                                                 10 August 1971


                    <span class="h1">Achieving Reliable Communication</span>

   'This material has not been reviewed for public release and is
   intended only for use with the ARPA network.  It should not be quoted
   or cited in any publication not related to the ARPA network.'

ABSTRACT

   A non-standard protocol, suitable for either second or third level
   use, is proposed with the intent of providing error resistant and
   highly reliable communication channels.  Errors introduced by message
   garbling, message loss, and message pickup are considered.  Measures
   for increasing throughput are also discussed.

AIMS AND LIMITATIONS

   It is not our intent to propose the design of a perfect communication
   channel, rather it is our contention that in the real world there can
   be no perfect channels and that no amount of protocol can insure the
   error free transfer of information.  Our goal is to explicate the
   various types of errors that are possible and to provide for each
   techniques of detection and recovery that, at a cost, can be made
   arbitrarily good.  In this way the mean time between undetected
   errors can be made as large as necessary.

ERROR TYPES AND DETECTION

   Over a message switching facility, such as the ARPA network, all
   transmission errors can be divided into two classes -- those that
   result in the loss of an expected message, and those that result in
   the picking up of an unexpected message.  A single bit inversion can
   cause errors of both types.  Error detection can therefore be divided
   into two components -- one which attempts to determine if the message
   just received is appropriate at that time, and another which attempts
   to determine if a message has been lost.

   The detection of garbled input messages has been adequately covered
   by classical coding ( elsewhere, mistakenly termed 'communication' )
   theory.   Internal message consistency can be determined through the
   use parity bits, checksum fields, or any of the various coding
   techniques available for adding some measure of redundancy.  With
   relative simplicity, the likelyhood of an undetected error of this
   type can be made small enough so as to become inconsequential.



<span class="grey">Kalin                                                           [Page 1]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-2" id="page-2" name="page-2"> </a>
<span class="grey"><a href="rfc203.html">RFC 203</a>             ACHIEVING RELIABLE COMMUNICATION      10 August 1971</span>


   Because it is adequately covered elsewhere, no further discussion
   shall be given here.

   The detection of a message's external consistency, whether or not it
   can possibly follow the message that arrived just before it, can also
   be straight forward.  Sequence numbers, if used, can be easily
   checked.  A modulo N sequence field will allow detection of up to N-1
   successive message losses.  If several concurrent links are in use
   then sequencing can be maintained for each link.  Multi-link single
   sequence schemes are more complicated and, although used between IMPs
   for transmission of message packets, they shall be ignored here.

   The detection by a receiving host of a lost message can not be
   determined directly, but rather must be inferred from other
   observations.  Any automatic correction scheme must be prepared to
   handle the possibility of faulty inference.  Message loss would
   normally be inferred upon the arrival of a message that should follow
   the one expected.  It might also be inferred by the fact that the
   message expected is long overdue.

ERROR CORRECTION

   If a BCH or other error correcting code is used for transmission,
   errors detected in a message's internal consistency can sometimes be
   corrected by the receiving host.  In the event that this is not
   possible, the content of the message is of little use because it can
   not be relied upon.  The only reasonable solution is that of
   discarding the message and relying upon the recovery procedures
   implemented for lost messages.

   Errors of external consistency can also be treated in the same way.
   The message can be thrown away and the techniques for recovering lost
   messages relied upon.  Over a critical channel, a slightly fancier
   technique can at times save some retransmissions.  If message N is
   expected, but message N+1 arrives, there is no need to throw away
   message N+1 and then recover two messages, it could be saved, and
   only message N retransmitted.

   On noisy channels the technique of saving out of sequence messages
   can be used to some advantage, especially if recovering from a lost
   message requires several messages of overhead.  On the ARPA network,
   the measured error rate is so low that its advantages are outweighed
   by the increase in resident coding.

RECOVERING LOST MESSAGES

   The simplest technique I know of for recovering lost can be defined
   by the following rules:



<span class="grey">Kalin                                                           [Page 2]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-3" id="page-3" name="page-3"> </a>
<span class="grey"><a href="rfc203.html">RFC 203</a>             ACHIEVING RELIABLE COMMUNICATION      10 August 1971</span>


   1) All undiscarded messages have reply messages.
   2) Messages with coding errors that can not be corrected are
      discarded.
   3) The receiver can determine if a message is in sequence.
   4) Messages received that are out of sequence are discarded.
   5) If no reply message is received in N time units since the last
      transmission, the last message sent is retransmitted ( space need
      not be isochronic ).
   6) A new message is not sent until the reply for the last one has
      been received.

   The above protocol, if run, is highly effective for continuous
   communication.  Since by rule 6) only one message can be in transit
   at a time, the necessary sequencing information can be contained in a
   single bit.  Unmodified, it is not suitable for finite communication,
   since rules 1) and 5) guarantee that there will be no 'last message'.
   The protocol also does not make very effective use of a pipelined
   channel, since there is only one message being sent at a time.

   Channel throughput can be increased by several techniques, the first
   of which would be to disassemble the data stream into several ( eg.
   four or eight ) streams, transmit each using the above protocol, and
   then reassemble the streams at the far end.  Another technique is to
   modify rules 5) and 6).

   5a)   If no reply has been received to message M in N time units
         since the last transmission, then messages M, M+1,... are
         retransmitted.

   6a)   There must be no more than L outstanding unreplied messages.

   With L equal to one, this protocol degenerates into the first
   protocol.  Increasing L increases throughput until the gain is
   outweighed by the time spent in error recovery.  The larger L, the
   costlier error recovery.  The value of N should be adjusted so that
   the reply time for a message is usually less than N plus the time to
   send L-1 messages.  Increasing N too much will have the effect of
   lowering the response time to errors.  Decreasing N increases the
   probability initiating unnecessary retransmissions.

A CRITICAL RACE

   The above protocols leave unresolved the the particulars of starting
   and stopping a finite transmission.  In opening a communication
   channel, what is the sequence number of the first message sent?  What
   will be the first sequence number of the first message sent?  What





<span class="grey">Kalin                                                           [Page 3]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-4" id="page-4" name="page-4"> </a>
<span class="grey"><a href="rfc203.html">RFC 203</a>             ACHIEVING RELIABLE COMMUNICATION      10 August 1971</span>


   will be the first sequence number of the first reply received?  At
   the end of transmission, how does one signal the 'last message'?  The
   following two rules are introduced:

   7) If the same message has been received K times ( eg. 50 ), then it
      should be accepted as being 'in sequence'.  The expected
      sequencing should be adjusted accordingly.  K identical reply
      messages are then sent.

   8) If no reply has been received in J seconds, then the
      retransmission of the last unreplied message should cease.

   With these additional rules a finite transmission is started by
   repeatedly transmitting the first message until K identical reply
   messages are received.  Sequencing is adjusted accordingly and then
   subsequent messages can be sent.  A conversation is broken by
   quitting transmission after the reply to the last message you care
   about has been received.  Eventually the other end will stop
   resending the reply.  To avoid ambiguity, the variable J should be
   less than N times K.  Problems will arise if the network crashes for
   J seconds, for there is a race condition over whether or not the lack
   of a reply is the result of a channel failure or the end of a
   conversation.


         [ This RFC was put into machine readable form for entry ]
             [ into the online RFC archives by Ryan Kato 6/01]
























Kalin                                                           [Page 4]

</pre><br/>
    <span class="noprint"><small><small>Html markup produced by rfcmarkup 1.126, available from
      <a href="https://tools.ietf.org/tools/rfcmarkup/">https://tools.ietf.org/tools/rfcmarkup/</a>
    </small></small></span>
  </div>




</body><!-- Mirrored from tools.ietf.org/html/rfc203 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 06 Mar 2018 23:19:03 GMT --></html>