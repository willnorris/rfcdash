<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml"><!-- Mirrored from tools.ietf.org/html/rfc8085 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 06 Mar 2018 23:18:18 GMT --><!-- Added by HTTrack --><head><meta content="text/html;charset=utf-8" http-equiv="content-type"/><!-- /Added by HTTrack -->

    <meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
    <meta content="index,follow" name="robots"/>
    <meta content="rfcmarkup version 1.126" name="creator"/>
    <link href="http://purl.org/dc/elements/1.1/" rel="schema.DC"/>
<meta content="rfc5405" name="DC.Relation.Replaces"/>
<meta content="urn:ietf:rfc:8085" name="DC.Identifier"/>
<meta content="March, 2017" name="DC.Date.Issued"/>
<meta content="Shepherd, Greg" name="DC.Creator"/>
<meta content="Fairhurst, Gorry" name="DC.Creator"/>
<meta content="Eggert, Lars" name="DC.Creator"/>
<meta content="The User Datagram Protocol (UDP) provides a minimal message-passing
transport that has no inherent congestion control mechanisms. This
document provides guidelines on the use of UDP for the designers of
applications, tunnels, and other protocols that use UDP. Congestion
control guidelines are a primary focus, but the document also provides
guidance on other topics, including message sizes, reliability,
checksums, middlebox traversal, the use of Explicit Congestion
Notification (ECN), Differentiated Services Code Points (DSCPs), and
ports.  Because congestion control is critical to the stable operation
of the Internet, applications and other protocols that choose to use
UDP as an Internet transport must employ mechanisms to prevent
congestion collapse and to establish some degree of fairness with
concurrent traffic. They may also need to implement additional
mechanisms, depending on how they use UDP.  Some guidance is also
applicable to the design of other protocols (e.g., protocols layered
directly on IP or via IP-based tunnels), especially when these
protocols do not themselves provide congestion control.  This document
obsoletes RFC 5405 and adds guidelines for multicast UDP usage." name="DC.Description.Abstract"/>
<meta content="UDP Usage Guidelines" name="DC.Title"/>

    <link href="https://tools.ietf.org/images/rfc.png" rel="icon" type="image/png"/>
    <link href="https://tools.ietf.org/images/rfc.png" rel="shortcut icon" type="image/png"/>
    <title>RFC 8085 - UDP Usage Guidelines</title>
    
    
    <style type="text/css">
	@media only screen 
	  and (min-width: 992px)
	  and (max-width: 1199px) {
	    body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 768px)
	  and (max-width: 991px) {
            body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 480px)
	  and (max-width: 767px) {
            body { font-size: 11pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (max-width: 479px) {
            body { font-size: 8pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-device-width : 375px) 
	  and (max-device-width : 667px) {
            body { font-size: 9.5pt; }
            div.content { width: 96ex; margin: 0 1px; }
        }
	@media only screen 
	  and (min-device-width: 1200px) {
            body { font-size: 10pt; margin: 0 4em; }
            div.content { width: 96ex; margin: 0; }
        }
        h1, h2, h3, h4, h5, h6, .h1, .h2, .h3, .h4, .h5, .h6 {
	    font-weight: bold;
            line-height: 0pt;
            display: inline;
            white-space: pre;
            font-family: monospace;
            font-size: 1em;
	    font-weight: bold;
        }
        pre {
            font-size: 1em;
            margin-top: 0px;
            margin-bottom: 0px;
        }
	.pre {
	    white-space: pre;
	    font-family: monospace;
	}
	.header{
	    font-weight: bold;
	}
        .newpage {
            page-break-before: always;
        }
        .invisible {
            text-decoration: none;
            color: white;
        }
        a.selflink {
          color: black;
          text-decoration: none;
        }
        @media print {
            body {
                font-family: monospace;
                font-size: 10.5pt;
            }
            h1, h2, h3, h4, h5, h6 {
                font-size: 1em;
            }
        
            a:link, a:visited {
                color: inherit;
                text-decoration: none;
            }
            .noprint {
                display: none;
            }
        }
	@media screen {
	    .grey, .grey a:link, .grey a:visited {
		color: #777;
	    }
            .docinfo {
                background-color: #EEE;
            }
            .top {
                border-top: 7px solid #EEE;
            }
            .bgwhite  { background-color: white; }
            .bgred    { background-color: #F44; }
            .bggrey   { background-color: #666; }
            .bgbrown  { background-color: #840; }            
            .bgorange { background-color: #FA0; }
            .bgyellow { background-color: #EE0; }
            .bgmagenta{ background-color: #F4F; }
            .bgblue   { background-color: #66F; }
            .bgcyan   { background-color: #4DD; }
            .bggreen  { background-color: #4F4; }

            .legend   { font-size: 90%; }
            .cplate   { font-size: 70%; border: solid grey 1px; }
	}
    </style>
    <!--[if IE]>
    <style>
    body {
       font-size: 13px;
       margin: 10px 10px;
    }
    </style>
    <![endif]-->

    <script type="text/javascript"><!--
    function addHeaderTags() {
	var spans = document.getElementsByTagName("span");
	for (var i=0; i < spans.length; i++) {
	    var elem = spans[i];
	    if (elem) {
		var level = elem.getAttribute("class");
                if (level == "h1" || level == "h2" || level == "h3" || level == "h4" || level == "h5" || level == "h6") {
                    elem.innerHTML = "<"+level+">"+elem.innerHTML+"</"+level+">";		
                }
	    }
	}
    }
    var legend_html = "Colour legend:<br />      <table>         <tr><td>Unknown:</td>                   <td><span class='cplate bgwhite'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft:</td>                     <td><span class='cplate bgred'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Informational:</td>             <td><span class='cplate bgorange'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Experimental:</td>              <td><span class='cplate bgyellow'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Best Common Practice:</td>      <td><span class='cplate bgmagenta'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Proposed Standard:</td>         <td><span class='cplate bgblue'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft Standard (old designation):</td> <td><span class='cplate bgcyan'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Internet Standard:</td>         <td><span class='cplate bggreen'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Historic:</td>                  <td><span class='cplate bggrey'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Obsolete:</td>                  <td><span class='cplate bgbrown'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>     </table>";
    function showElem(id) {
        var elem = document.getElementById(id);
        elem.innerHTML = eval(id+"_html");
        elem.style.visibility='visible';
    }
    function hideElem(id) {
        var elem = document.getElementById(id);
        elem.style.visibility='hidden';        
        elem.innerHTML = "";
    }
    // -->
    </script>
</head>
<body onload="addHeaderTags()">
  <div class="content">
   <div style="height: 13px;">
      <div class="pre noprint docinfo bgmagenta" onclick="showElem('legend');" onmouseout="hideElem('legend')" onmouseover="this.style.cursor='pointer';" style="height: 6px; position: absolute;" title="Click for colour legend.">                                                                        </div>
      <div class="docinfo noprint pre legend" id="legend" onmouseout="hideElem('legend');" onmouseover="showElem('legend');" style="position:absolute; top: 4px; left: 4ex; visibility:hidden; background-color: white; padding: 4px 9px 5px 7px; border: solid #345 1px; ">
      </div>
   </div>
<span class="pre noprint docinfo top">[<a href="index.html" title="Document search and retrieval page">Docs</a>] [<a href="https://tools.ietf.org/rfc/rfc8085.txt" title="Plaintext version of this document">txt</a>|<a href="https://tools.ietf.org/pdf/rfc8085" title="PDF version of this document">pdf</a>] [<a href="https://tools.ietf.org/html/draft-ietf-tsvwg-rfc5405bis" title="draft-ietf-tsvwg-rfc5405bis">draft-ietf-tsvw...</a>] [<a href="https://datatracker.ietf.org/doc/rfc8085" title="IESG Datatracker information for this document">Tracker</a>] [<a href="https://tools.ietf.org/rfcdiff?difftype=--hwdiff&amp;url2=rfc8085" title="Inline diff (wdiff)">Diff1</a>] [<a href="https://tools.ietf.org/rfcdiff?url2=rfc8085" title="Side-by-side diff">Diff2</a>]         </span><br/>
<span class="pre noprint docinfo">                                                                        </span><br/>
<span class="pre noprint docinfo">                                                   BEST CURRENT PRACTICE</span><br/>
<span class="pre noprint docinfo">                                                                        </span><br/>
<pre>Internet Engineering Task Force (IETF)                         L. Eggert
Request for Comments: 8085                                        NetApp
BCP: 145                                                    G. Fairhurst
Obsoletes: <a href="rfc5405.html">5405</a>                                   University of Aberdeen
Category: Best Current Practice                              G. Shepherd
ISSN: 2070-1721                                            Cisco Systems
                                                              March 2017


                          <span class="h1">UDP Usage Guidelines</span>

Abstract

   The User Datagram Protocol (UDP) provides a minimal message-passing
   transport that has no inherent congestion control mechanisms.  This
   document provides guidelines on the use of UDP for the designers of
   applications, tunnels, and other protocols that use UDP.  Congestion
   control guidelines are a primary focus, but the document also
   provides guidance on other topics, including message sizes,
   reliability, checksums, middlebox traversal, the use of Explicit
   Congestion Notification (ECN), Differentiated Services Code Points
   (DSCPs), and ports.

   Because congestion control is critical to the stable operation of the
   Internet, applications and other protocols that choose to use UDP as
   an Internet transport must employ mechanisms to prevent congestion
   collapse and to establish some degree of fairness with concurrent
   traffic.  They may also need to implement additional mechanisms,
   depending on how they use UDP.

   Some guidance is also applicable to the design of other protocols
   (e.g., protocols layered directly on IP or via IP-based tunnels),
   especially when these protocols do not themselves provide congestion
   control.

   This document obsoletes <a href="rfc5405.html">RFC 5405</a> and adds guidelines for multicast
   UDP usage.














<span class="grey">Eggert, et al.            Best Current Practice                 [Page 1]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-2" id="page-2" name="page-2"> </a>
<span class="grey"><a href="rfc8085.html">RFC 8085</a>                  UDP Usage Guidelines                March 2017</span>


Status of This Memo

   This memo documents an Internet Best Current Practice.

   This document is a product of the Internet Engineering Task Force
   (IETF).  It represents the consensus of the IETF community.  It has
   received public review and has been approved for publication by the
   Internet Engineering Steering Group (IESG).  Further information on
   BCPs is available in <a href="rfc7841.html#section-2">Section 2 of RFC 7841</a>.

   Information about the current status of this document, any errata,
   and how to provide feedback on it may be obtained at
   <a href="http://www.rfc-editor.org/info/rfc8085">http://www.rfc-editor.org/info/rfc8085</a>.

Copyright Notice

   Copyright (c) 2017 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to <a href="https://tools.ietf.org/html/bcp78">BCP 78</a> and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (<a href="http://trustee.ietf.org/license-info">http://trustee.ietf.org/license-info</a>) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.























<span class="grey">Eggert, et al.            Best Current Practice                 [Page 2]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-3" id="page-3" name="page-3"> </a>
<span class="grey"><a href="rfc8085.html">RFC 8085</a>                  UDP Usage Guidelines                March 2017</span>


Table of Contents

   <a href="#section-1">1</a>. Introduction ....................................................<a href="#page-3">3</a>
   <a href="#section-2">2</a>. Terminology .....................................................<a href="#page-5">5</a>
   <a href="#section-3">3</a>. UDP Usage Guidelines ............................................<a href="#page-5">5</a>
      <a href="#section-3.1">3.1</a>. Congestion Control Guidelines ..............................<a href="#page-6">6</a>
      <a href="#section-3.2">3.2</a>. Message Size Guidelines ...................................<a href="#page-19">19</a>
      <a href="#section-3.3">3.3</a>. Reliability Guidelines ....................................<a href="#page-21">21</a>
      <a href="#section-3.4">3.4</a>. Checksum Guidelines .......................................<a href="#page-22">22</a>
      <a href="#section-3.5">3.5</a>. Middlebox Traversal Guidelines ............................<a href="#page-25">25</a>
      <a href="#section-3.6">3.6</a>. Limited Applicability and Controlled Environments .........<a href="#page-27">27</a>
   <a href="#section-4">4</a>. Multicast UDP Usage Guidelines .................................<a href="#page-28">28</a>
      <a href="#section-4.1">4.1</a>. Multicast Congestion Control Guidelines ...................<a href="#page-30">30</a>
      <a href="#section-4.2">4.2</a>. Message Size Guidelines for Multicast .....................<a href="#page-32">32</a>
   <a href="#section-5">5</a>. Programming Guidelines .........................................<a href="#page-32">32</a>
      <a href="#section-5.1">5.1</a>. Using UDP Ports ...........................................<a href="#page-34">34</a>
      <a href="#section-5.2">5.2</a>. ICMP Guidelines ...........................................<a href="#page-37">37</a>
   <a href="#section-6">6</a>. Security Considerations ........................................<a href="#page-38">38</a>
   <a href="#section-7">7</a>. Summary ........................................................<a href="#page-40">40</a>
   <a href="#section-8">8</a>. References .....................................................<a href="#page-42">42</a>
      <a href="#section-8.1">8.1</a>. Normative References ......................................<a href="#page-42">42</a>
      <a href="#section-8.2">8.2</a>. Informative References ....................................<a href="#page-43">43</a>
   <a href="#appendix-A">Appendix A</a>. .......................................................<a href="#page-53">53</a>
   Acknowledgments ...................................................<a href="#page-55">55</a>
   Authors' Addresses ................................................<a href="#page-55">55</a>

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/1.%20%20Introduction"></a><a class="selflink" href="#section-1" name="section-1">1</a>.  Introduction</span>

   The User Datagram Protocol (UDP) [<a href="rfc768.html" title='"User Datagram Protocol"'>RFC768</a>] provides a minimal,
   unreliable, best-effort, message-passing transport to applications
   and other protocols (such as tunnels) that wish to operate over IP.
   Both are simply called "applications" in the remainder of this
   document.

   Compared to other transport protocols, UDP and its UDP-Lite variant
   [<a href="rfc3828.html" title='"The Lightweight User Datagram Protocol (UDP-Lite)"'>RFC3828</a>] are unique in that they do not establish end-to-end
   connections between communicating end systems.  UDP communication
   consequently does not incur connection establishment and teardown
   overheads, and there is minimal associated end-system state.  Because
   of these characteristics, UDP can offer a very efficient
   communication transport to some applications.

   A second unique characteristic of UDP is that it provides no inherent
   congestion control mechanisms.  On many platforms, applications can
   send UDP datagrams at the line rate of the platform's link interface,
   which is often much greater than the available end-to-end path
   capacity, and doing so contributes to congestion along the path.
   [<a href="rfc2914.html" title='"Congestion Control Principles"'>RFC2914</a>] describes the best current practice for congestion control



<span class="grey">Eggert, et al.            Best Current Practice                 [Page 3]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-4" id="page-4" name="page-4"> </a>
<span class="grey"><a href="rfc8085.html">RFC 8085</a>                  UDP Usage Guidelines                March 2017</span>


   in the Internet.  It identifies two major reasons why congestion
   control mechanisms are critical for the stable operation of the
   Internet:

   1.  The prevention of congestion collapse, i.e., a state where an
       increase in network load results in a decrease in useful work
       done by the network.

   2.  The establishment of a degree of fairness, i.e., allowing
       multiple flows to share the capacity of a path reasonably
       equitably.

   Because UDP itself provides no congestion control mechanisms, it is
   up to the applications that use UDP for Internet communication to
   employ suitable mechanisms to prevent congestion collapse and
   establish a degree of fairness.  [<a href="rfc2309.html" title='"Recommendations on Queue Management and Congestion Avoidance in the Internet"'>RFC2309</a>] discusses the dangers of
   congestion-unresponsive flows and states that "all UDP-based
   streaming applications should incorporate effective congestion
   avoidance mechanisms."  [<a href="rfc7567.html" title='"IETF Recommendations Regarding Active Queue Management"'>RFC7567</a>] reaffirms this statement.  This is
   an important requirement, even for applications that do not use UDP
   for streaming.  In addition, congestion-controlled transmission is of
   benefit to an application itself, because it can reduce self-induced
   packet loss, minimize retransmissions, and hence reduce delays.
   Congestion control is essential even at relatively slow transmission
   rates.  For example, an application that generates five 1500-byte UDP
   datagrams in one second can already exceed the capacity of a 56 Kb/s
   path.  For applications that can operate at higher, potentially
   unbounded data rates, congestion control becomes vital to prevent
   congestion collapse and establish some degree of fairness.  <a href="#section-3">Section 3</a>
   describes a number of simple guidelines for the designers of such
   applications.

   A UDP datagram is carried in a single IP packet and is hence limited
   to a maximum payload of 65,507 bytes for IPv4 and 65,527 bytes for
   IPv6.  The transmission of large IP packets usually requires IP
   fragmentation.  Fragmentation decreases communication reliability and
   efficiency and should be avoided.  IPv6 allows the option of
   transmitting large packets ("jumbograms") without fragmentation when
   all link layers along the path support this [<a href="rfc2675.html" title='"IPv6 Jumbograms"'>RFC2675</a>].  Some of the
   guidelines in <a href="#section-3">Section 3</a> describe how applications should determine
   appropriate message sizes.  Other sections of this document provide
   guidance on reliability, checksums, middlebox traversal and use of
   multicast.

   This document provides guidelines and recommendations.  Although most
   UDP applications are expected to follow these guidelines, there do
   exist valid reasons why a specific application may decide not to
   follow a given guideline.  In such cases, it is RECOMMENDED that



<span class="grey">Eggert, et al.            Best Current Practice                 [Page 4]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-5" id="page-5" name="page-5"> </a>
<span class="grey"><a href="rfc8085.html">RFC 8085</a>                  UDP Usage Guidelines                March 2017</span>


   application designers cite the respective section(s) of this document
   in the technical specification of their application or protocol and
   explain their rationale for their design choice.

   [<a id="ref-RFC5405" name="ref-RFC5405">RFC5405</a>] was scoped to provide guidelines for unicast applications
   only, whereas this document also provides guidelines for UDP flows
   that use IP anycast, multicast, broadcast, and applications that use
   UDP tunnels to support IP flows.

   Finally, although this document specifically refers to usage of UDP,
   the spirit of some of its guidelines also applies to other message-
   passing applications and protocols (specifically on the topics of
   congestion control, message sizes, and reliability).  Examples
   include signaling, tunnel or control applications that choose to run
   directly over IP by registering their own IP protocol number with
   IANA.  This document is expected to provide useful background reading
   to the designers of such applications and protocols.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/2.%20%20Terminology"></a><a class="selflink" href="#section-2" name="section-2">2</a>.  Terminology</span>

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
   "OPTIONAL" in this document are to be interpreted as described in
   [<a href="rfc2119.html" title='"Key words for use in RFCs to Indicate Requirement Levels"'>RFC2119</a>].

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/3.%20%20UDP%20Usage%20Guidelines"></a><a class="selflink" href="#section-3" name="section-3">3</a>.  UDP Usage Guidelines</span>

   Internet paths can have widely varying characteristics, including
   transmission delays, available bandwidths, congestion levels,
   reordering probabilities, supported message sizes, or loss rates.
   Furthermore, the same Internet path can have very different
   conditions over time.  Consequently, applications that may be used on
   the Internet MUST NOT make assumptions about specific path
   characteristics.  They MUST instead use mechanisms that let them
   operate safely under very different path conditions.  Typically, this
   requires conservatively probing the current conditions of the
   Internet path they communicate over to establish a transmission
   behavior that it can sustain and that is reasonably fair to other
   traffic sharing the path.

   These mechanisms are difficult to implement correctly.  For most
   applications, the use of one of the existing IETF transport protocols
   is the simplest method of acquiring the required mechanisms.  Doing
   so also avoids issues that protocols using a new IP protocol number
   face when being deployed over the Internet, where middleboxes that
   only support TCP and UDP are sometimes present.  Consequently, the
   RECOMMENDED alternative to the UDP usage described in the remainder
   of this section is the use of an IETF transport protocol such as TCP



<span class="grey">Eggert, et al.            Best Current Practice                 [Page 5]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-6" id="page-6" name="page-6"> </a>
<span class="grey"><a href="rfc8085.html">RFC 8085</a>                  UDP Usage Guidelines                March 2017</span>


   [<a href="rfc793.html" title='"Transmission Control Protocol"'>RFC793</a>], Stream Control Transmission Protocol (SCTP) [<a href="rfc4960.html" title='"Stream Control Transmission Protocol"'>RFC4960</a>], and
   SCTP Partial Reliability Extension (SCTP-PR) [<a href="rfc3758.html" title='"Stream Control Transmission Protocol (SCTP) Partial Reliability Extension"'>RFC3758</a>], or Datagram
   Congestion Control Protocol (DCCP) [<a href="rfc4340.html" title='"Datagram Congestion Control Protocol (DCCP)"'>RFC4340</a>] with its different
   congestion control types [<a href="rfc4341.html" title='"Profile for Datagram Congestion Control Protocol (DCCP) Congestion Control ID 2: TCP-like Congestion Control"'>RFC4341</a>][RFC4342][<a href="rfc5622.html" title='"Profile for Datagram Congestion Control Protocol (DCCP) Congestion ID 4: TCP-Friendly Rate Control for Small Packets (TFRC-SP)"'>RFC5622</a>], or transport
   protocols specified by the IETF in the future.  (UDP-encapsulated
   SCTP [<a href="rfc6951.html" title='"UDP Encapsulation of Stream Control Transmission Protocol (SCTP) Packets for End-Host to End-Host Communication"'>RFC6951</a>] and DCCP [<a href="rfc6773.html" title='"DCCP-UDP: A Datagram Congestion Control Protocol UDP Encapsulation for NAT Traversal"'>RFC6773</a>] can offer support for traversing
   firewalls and other middleboxes where the native protocols are not
   supported.)

   If used correctly, these more fully featured transport protocols are
   not as "heavyweight" as often claimed.  For example, the TCP
   algorithms have been continuously improved over decades, and they
   have reached a level of efficiency and correctness that custom
   application-layer mechanisms will struggle to easily duplicate.  In
   addition, many TCP implementations allow connections to be tuned by
   an application to its purposes.  For example, TCP's "Nagle" algorithm
   [<a href="rfc1122.html" title='"Requirements for Internet Hosts - Communication Layers"'>RFC1122</a>] can be disabled, improving communication latency at the
   expense of more frequent -- but still congestion controlled -- packet
   transmissions.  Another example is the TCP SYN cookie mechanism
   [<a href="rfc4987.html" title='"TCP SYN Flooding Attacks and Common Mitigations"'>RFC4987</a>], which is available on many platforms.  TCP with SYN
   cookies does not require a server to maintain per-connection state
   until the connection is established.  TCP also requires the end that
   closes a connection to maintain the TIME-WAIT state that prevents
   delayed segments from one connection instance from interfering with a
   later one.  Applications that are aware of and designed for this
   behavior can shift maintenance of the TIME-WAIT state to conserve
   resources by controlling which end closes a TCP connection [<a href="#ref-FABER" title='"The TIME-WAIT State in TCP and Its Effect on Busy Servers"'>FABER</a>].
   Finally, TCP's built-in capacity-probing and awareness of the maximum
   transmission unit supported by the path (PMTU) results in efficient
   data transmission that quickly compensates for the initial connection
   setup delay, in the case of transfers that exchange more than a few
   segments.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.1.%20%20Congestion%20Control%20Guidelines"></a><a class="selflink" href="#section-3.1" name="section-3.1">3.1</a>.  Congestion Control Guidelines</span>

   If an application or protocol chooses not to use a congestion-
   controlled transport protocol, it SHOULD control the rate at which it
   sends UDP datagrams to a destination host, in order to fulfill the
   requirements of [<a href="rfc2914.html" title='"Congestion Control Principles"'>RFC2914</a>].  It is important to stress that an
   application SHOULD perform congestion control over all UDP traffic it
   sends to a destination, independently from how it generates this
   traffic.  For example, an application that forks multiple worker
   processes or otherwise uses multiple sockets to generate UDP
   datagrams SHOULD perform congestion control over the aggregate
   traffic.






<span class="grey">Eggert, et al.            Best Current Practice                 [Page 6]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-7" id="page-7" name="page-7"> </a>
<span class="grey"><a href="rfc8085.html">RFC 8085</a>                  UDP Usage Guidelines                March 2017</span>


   Several approaches to perform congestion control are discussed in the
   remainder of this section.  This section describes generic topics
   with an intended emphasis on unicast and anycast [<a href="rfc1546.html" title='"Host Anycasting Service"'>RFC1546</a>] usage.
   Not all approaches discussed below are appropriate for all UDP-
   transmitting applications.  <a href="#section-3.1.2">Section 3.1.2</a> discusses congestion
   control options for applications that perform bulk transfers over
   UDP.  Such applications can employ schemes that sample the path over
   several subsequent round-trips during which data is exchanged to
   determine a sending rate that the path at its current load can
   support.  Other applications only exchange a few UDP datagrams with a
   destination.  <a href="#section-3.1.3">Section 3.1.3</a> discusses congestion control options for
   such "low data-volume" applications.  Because they typically do not
   transmit enough data to iteratively sample the path to determine a
   safe sending rate, they need to employ different kinds of congestion
   control mechanisms.  <a href="#section-3.1.11">Section 3.1.11</a> discusses congestion control
   considerations when UDP is used as a tunneling protocol.  <a href="#section-4">Section 4</a>
   provides additional recommendations for broadcast and multicast
   usage.

   It is important to note that congestion control should not be viewed
   as an add-on to a finished application.  Many of the mechanisms
   discussed in the guidelines below require application support to
   operate correctly.  Application designers need to consider congestion
   control throughout the design of their application, similar to how
   they consider security aspects throughout the design process.

   In the past, the IETF has also investigated integrated congestion
   control mechanisms that act on the traffic aggregate between two
   hosts, i.e., a framework such as the Congestion Manager [<a href="rfc3124.html" title='"The Congestion Manager"'>RFC3124</a>],
   where active sessions may share current congestion information in a
   way that is independent of the transport protocol.  Such mechanisms
   have currently failed to see deployment, but would otherwise simplify
   the design of congestion control mechanisms for UDP sessions, so that
   they fulfill the requirements in [<a href="rfc2914.html" title='"Congestion Control Principles"'>RFC2914</a>].

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/3.1.1.%20%20Protocol%20Timer%20Guidelines"></a><a class="selflink" href="#section-3.1.1" name="section-3.1.1">3.1.1</a>.  Protocol Timer Guidelines</span>

   Understanding the latency between communicating endpoints is usually
   a crucial part of effective congestion control implementations for
   protocols and applications.  Latency estimation can be used in a
   number of protocol functions, such as calculating a congestion-
   controlled transmission rate, triggering retransmission, and
   detecting packet loss.  Additional protocol functions, for example,
   determining an interval for probing a path, determining an interval
   between keep-alive messages, determining an interval for measuring
   the quality of experience, or determining if a remote endpoint has





<span class="grey">Eggert, et al.            Best Current Practice                 [Page 7]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-8" id="page-8" name="page-8"> </a>
<span class="grey"><a href="rfc8085.html">RFC 8085</a>                  UDP Usage Guidelines                March 2017</span>


   responded to a request to perform an action, typically operate over
   longer timescales than congestion control and therefore are not
   covered in this section.

   The general recommendation in this document is that applications
   SHOULD leverage existing congestion control techniques and the
   latency estimators specified therein (see next subsection).  The
   following guidelines are provided for applications that need to
   design their own latency estimation mechanisms.

   The guidelines are framed in terms of "latency" and not "round-trip
   time" because some situations require characterizing only the
   network-based latency (e.g., TCP-Friendly Rate Control (TFRC)
   [<a href="rfc5348.html" title='"TCP Friendly Rate Control (TFRC): Protocol Specification"'>RFC5348</a>]), while other cases necessitate inclusion of the time
   required by the remote endpoint to provide feedback (e.g., developing
   an understanding of when to retransmit a message).

   The latency between endpoints is generally a dynamic property.
   Therefore, estimates SHOULD represent some sort of averaging of
   multiple recent measurement samples to account for variance.
   Leveraging an Exponentially Weighted Moving Average (EWMA) has proven
   useful for this purpose (e.g., in TCP [<a href="rfc6298.html" title="&quot;Computing TCP's Retransmission Timer&quot;">RFC6298</a>] and TFRC [<a href="rfc5348.html" title='"TCP Friendly Rate Control (TFRC): Protocol Specification"'>RFC5348</a>]).

   Independent latency estimates SHOULD be maintained for each
   destination with which an endpoint communicates.

   Latency samples MUST NOT be derived from ambiguous transactions.  The
   canonical example is in a protocol that retransmits data, but
   subsequently cannot determine which copy is being acknowledged.  This
   ambiguity makes correct computation of the latency problematic.  See
   the discussion of Karn's algorithm in [<a href="rfc6298.html" title="&quot;Computing TCP's Retransmission Timer&quot;">RFC6298</a>].  This requirement
   ensures a sender establishes a sound estimate of the latency without
   relying on misleading measurements.

   When a latency estimate is used to arm a timer that provides loss
   detection -- with or without retransmission -- expiry of the timer
   MUST be interpreted as an indication of congestion in the network,
   causing the sending rate to be adapted to a safe conservative rate
   (e.g., TCP collapses the congestion window to one segment [<a href="rfc5681.html" title='"TCP Congestion Control"'>RFC5681</a>]).

   Some applications require an initial latency estimate before the
   latency between endpoints can be empirically sampled.  For instance,
   when arming a retransmission timer, an initial value is needed to
   protect the messages sent before the endpoints sample the latency.
   This initial latency estimate SHOULD generally be as conservative
   (large) as possible for the given application.  For instance, in the
   absence of any knowledge about the latency of a path, TCP requires
   the initial Retransmission Timeout (RTO) to be set to no less than 1



<span class="grey">Eggert, et al.            Best Current Practice                 [Page 8]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-9" id="page-9" name="page-9"> </a>
<span class="grey"><a href="rfc8085.html">RFC 8085</a>                  UDP Usage Guidelines                March 2017</span>


   second [<a href="rfc6298.html" title="&quot;Computing TCP's Retransmission Timer&quot;">RFC6298</a>].  UDP applications SHOULD similarly use an initial
   latency estimate of 1 second.  Values shorter than 1 second can be
   problematic (see the data analysis in the appendix of [<a href="rfc6298.html" title="&quot;Computing TCP's Retransmission Timer&quot;">RFC6298</a>]).

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/3.1.2.%20%20Bulk-Transfer%20Applications"></a><a class="selflink" href="#section-3.1.2" name="section-3.1.2">3.1.2</a>.  Bulk-Transfer Applications</span>

   Applications that perform bulk transmission of data to a peer over
   UDP, i.e., applications that exchange more than a few UDP datagrams
   per RTT, SHOULD implement TFRC [<a href="rfc5348.html" title='"TCP Friendly Rate Control (TFRC): Protocol Specification"'>RFC5348</a>], window-based TCP-like
   congestion control, or otherwise ensure that the application complies
   with the congestion control principles.

   TFRC has been designed to provide both congestion control and
   fairness in a way that is compatible with the IETF's other transport
   protocols.  If an application implements TFRC, it need not follow the
   remaining guidelines in <a href="#section-3.1.2">Section 3.1.2</a>, because TFRC already addresses
   them, but it SHOULD still follow the remaining guidelines in the
   subsequent subsections of <a href="#section-3">Section 3</a>.

   Bulk-transfer applications that choose not to implement TFRC or TCP-
   like windowing SHOULD implement a congestion control scheme that
   results in bandwidth (capacity) use that competes fairly with TCP
   within an order of magnitude.

   <a href="rfc3551.html#section-2">Section 2 of [RFC3551]</a> suggests that applications SHOULD monitor the
   packet-loss rate to ensure that it is within acceptable parameters.
   Packet loss is considered acceptable if a TCP flow across the same
   network path under the same network conditions would achieve an
   average throughput, measured on a reasonable timescale, that is not
   less than that of the UDP flow.  The comparison to TCP cannot be
   specified exactly, but is intended as an "order-of-magnitude"
   comparison in timescale and throughput.  The recommendations for
   managing timers specified in <a href="#section-3.1.1">Section 3.1.1</a> also apply.

   Finally, some bulk-transfer applications may choose not to implement
   any congestion control mechanism and instead rely on transmitting
   across reserved path capacity (see <a href="#section-3.1.9">Section 3.1.9</a>).  This might be an
   acceptable choice for a subset of restricted networking environments,
   but is by no means a safe practice for operation over the wider
   Internet.  When the UDP traffic of such applications leaks out into
   unprovisioned Internet paths, it can significantly degrade the
   performance of other traffic sharing the path and even result in
   congestion collapse.  Applications that support an uncontrolled or
   unadaptive transmission behavior SHOULD NOT do so by default and
   SHOULD instead require users to explicitly enable this mode of
   operation, and they SHOULD verify that sufficient path capacity has
   been reserved for them.




<span class="grey">Eggert, et al.            Best Current Practice                 [Page 9]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-10" id="page-10" name="page-10"> </a>
<span class="grey"><a href="rfc8085.html">RFC 8085</a>                  UDP Usage Guidelines                March 2017</span>


<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/3.1.3.%20%20Low%20Data-Volume%20Applications"></a><a class="selflink" href="#section-3.1.3" name="section-3.1.3">3.1.3</a>.  Low Data-Volume Applications</span>

   When applications that at any time exchange only a few UDP datagrams
   with a destination implement TFRC or one of the other congestion
   control schemes in <a href="#section-3.1.2">Section 3.1.2</a>, the network sees little benefit,
   because those mechanisms perform congestion control in a way that is
   only effective for longer transmissions.

   Applications that at any time exchange only a few UDP datagrams with
   a destination SHOULD still control their transmission behavior by not
   sending on average more than one UDP datagram per RTT to a
   destination.  Similar to the recommendation in [<a href="rfc1536.html" title='"Common DNS Implementation Errors and Suggested Fixes"'>RFC1536</a>], an
   application SHOULD maintain an estimate of the RTT for any
   destination with which it communicates using the methods specified in
   <a href="#section-3.1.1">Section 3.1.1</a>.

   Some applications cannot maintain a reliable RTT estimate for a
   destination.  These applications do not need to or are unable to use
   protocol timers to measure the RTT (<a href="#section-3.1.1">Section 3.1.1</a>).  Two cases can be
   identified:

   1.  The first case is that of applications that exchange too few UDP
       datagrams with a peer to establish a statistically accurate RTT
       estimate but that can monitor the reliability of transmission
       (<a href="#section-3.3">Section 3.3</a>).  Such applications MAY use a predetermined
       transmission interval that is exponentially backed off when
       packets are deemed lost.  TCP specifies an initial value of 1
       second [<a href="rfc6298.html" title="&quot;Computing TCP's Retransmission Timer&quot;">RFC6298</a>], which is also RECOMMENDED as an initial value
       for UDP applications.  Some low data-volume applications, e.g.,
       SIP [<a href="rfc3261.html" title='"SIP: Session Initiation Protocol"'>RFC3261</a>] and General Internet Signaling Transport (GIST)
       [<a href="rfc5971.html" title='"GIST: General Internet Signalling Transport"'>RFC5971</a>] use an interval of 500 ms, and shorter values are
       likely problematic in many cases.  As in the previous case, note
       that the initial timeout is not the maximum possible timeout, see
       <a href="#section-3.1.1">Section 3.1.1</a>.

   2.  A second case of applications cannot maintain an RTT estimate for
       a destination, because the destination does not send return
       traffic.  Such applications SHOULD NOT send more than one UDP
       datagram every 3 seconds and SHOULD use an even less aggressive
       rate when possible.  Shorter values are likely problematic in
       many cases.  Note that the sending rate in this case must be more
       conservative than in the previous cases, because the lack of
       return traffic prevents the detection of packet loss, i.e.,
       congestion, and the application therefore cannot perform
       exponential back off to reduce load.






<span class="grey">Eggert, et al.            Best Current Practice                [Page 10]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-11" id="page-11" name="page-11"> </a>
<span class="grey"><a href="rfc8085.html">RFC 8085</a>                  UDP Usage Guidelines                March 2017</span>


<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/3.1.4.%20%20Applications%20Supporting%20Bidirectional%20Communications"></a><a class="selflink" href="#section-3.1.4" name="section-3.1.4">3.1.4</a>.  Applications Supporting Bidirectional Communications</span>

   Applications that communicate bidirectionally SHOULD employ
   congestion control for both directions of the communication.  For
   example, for a client-server, request-response-style application,
   clients SHOULD congestion-control their request transmission to a
   server, and the server SHOULD congestion-control its responses to the
   clients.  Congestion in the forward and reverse directions is
   uncorrelated, and an application SHOULD either independently detect
   and respond to congestion along both directions or limit new and
   retransmitted requests based on acknowledged responses across the
   entire round-trip path.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/3.1.5.%20%20Implications%20of%20RTT%20and%20Loss%20Measurements%20on%20Congestion%20Control"></a><a class="selflink" href="#section-3.1.5" name="section-3.1.5">3.1.5</a>.  Implications of RTT and Loss Measurements on Congestion Control</span>

   Transports such as TCP, SCTP, and DCCP provide timely detection of
   congestion that results in an immediate reduction of their maximum
   sending rate when congestion is experienced.  This reaction is
   typically completed 1-2 RTTs after loss/congestion is encountered.
   Applications using UDP SHOULD implement a congestion control scheme
   that provides a prompt reaction to signals indicating congestion
   (e.g., by reducing the rate within the next RTT following a
   congestion signal).

   The operation of a UDP congestion control algorithm can be very
   different from the way TCP operates.  This includes congestion
   controls that respond on timescales that fit applications that cannot
   usefully work within the "change rate every RTT" model of TCP.
   Applications that experience a low or varying RTT are particularly
   vulnerable to sampling errors (e.g., due to measurement noise or
   timer accuracy).  This suggests the need to average loss/congestion
   and RTT measurements over a longer interval; however, this also can
   contribute additional delay in detecting congestion.  Some
   applications may not react by reducing their sending rate immediately
   for various reasons, including the following: RTT and loss
   measurements are only made periodically (e.g., using RTCP),
   additional time is required to filter information, or the application
   is only able to change its sending rate at predetermined interval
   (e.g., some video codecs).

   When designing a congestion control algorithm, the designer therefore
   needs to consider the total time taken to reduce the load following a
   lack of feedback or a congestion event.  An application where the
   most recent RTT measurement is smaller than the actual RTT or the
   measured loss rate is smaller than the current rate, can result in
   over estimating the available capacity.  Such over-estimation can





<span class="grey">Eggert, et al.            Best Current Practice                [Page 11]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-12" id="page-12" name="page-12"> </a>
<span class="grey"><a href="rfc8085.html">RFC 8085</a>                  UDP Usage Guidelines                March 2017</span>


   result in a sending rate that creates congestion to the application
   or other flows sharing the path capacity, and can contribute to
   congestion collapse -- both of these need to be avoided.

   A congestion control designed for UDP SHOULD respond as quickly as
   possible when it experiences congestion, and it SHOULD take into
   account both the loss rate and the response time when choosing a new
   rate.  The implemented congestion control scheme SHOULD result in
   bandwidth (capacity) use that is comparable to that of TCP within an
   order of magnitude, so that it does not starve other flows sharing a
   common bottleneck.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/3.1.6.%20%20Burst%20Mitigation%20and%20Pacing"></a><a class="selflink" href="#section-3.1.6" name="section-3.1.6">3.1.6</a>.  Burst Mitigation and Pacing</span>

   UDP applications SHOULD provide mechanisms to regulate the bursts of
   transmission that the application may send to the network.  Many TCP
   and SCTP implementations provide mechanisms that prevent a sender
   from generating long bursts at line-rate, since these are known to
   induce early loss to applications sharing a common network
   bottleneck.  The use of pacing with TCP [<a href="#ref-ALLMAN" title='"Notes on burst mitigation for transport protocols"'>ALLMAN</a>] has also been shown
   to improve the coexistence of TCP flows with other flows.  The need
   to avoid excessive transmission bursts is also noted in
   specifications for applications (e.g., [<a href="rfc7143.html" title='"Internet Small Computer System Interface (iSCSI) Protocol (Consolidated)"'>RFC7143</a>]).

   Even low data-volume UDP flows may benefit from packet pacing, e.g.,
   an application that sends three copies of a packet to improve
   robustness to loss is RECOMMENDED to pace out those three packets
   over several RTTs, to reduce the probability that all three packets
   will be lost due to the same congestion event (or other event, such
   as burst corruption).

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/3.1.7.%20%20Explicit%20Congestion%20Notification"></a><a class="selflink" href="#section-3.1.7" name="section-3.1.7">3.1.7</a>.  Explicit Congestion Notification</span>

   Internet applications can use Explicit Congestion Notification (ECN)
   [<a href="rfc3168.html" title='"The Addition of Explicit Congestion Notification (ECN) to IP"'>RFC3168</a>] to gain benefits for the services they support [<a href="rfc8087.html" title='"The Benefits of Using Explicit Congestion Notification (ECN)"'>RFC8087</a>].

   Internet transports, such as TCP, provide a set of mechanisms that
   are needed to utilize ECN.  ECN operates by setting an ECN-capable
   codepoint (ECT(0) or ECT(1)) in the IP header of packets that are
   sent.  This indicates to ECN-capable network devices (routers and
   other devices) that they may mark (set the congestion experienced,
   Congestion Experience (CE) codepoint) rather than drop the IP packet
   as a signal of incipient congestion.

   UDP applications can also benefit from enabling ECN, providing that
   the API supports ECN and that they implement the required protocol
   mechanisms to support ECN.




<span class="grey">Eggert, et al.            Best Current Practice                [Page 12]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-13" id="page-13" name="page-13"> </a>
<span class="grey"><a href="rfc8085.html">RFC 8085</a>                  UDP Usage Guidelines                March 2017</span>


   The set of mechanisms required for an application to use ECN over UDP
   are:

   o  A sender MUST provide a method to determine (e.g., negotiate) that
      the corresponding application is able to provide ECN feedback
      using a compatible ECN method.

   o  A receiver that enables the use of ECN for a UDP port MUST check
      the ECN field at the receiver for each UDP datagram that it
      receives on this port.

   o  The receiving application needs to provide feedback of congestion
      information to the sending application.  This MUST report the
      presence of datagrams received with a CE-mark by providing a
      mechanism to feed this congestion information back to the sending
      application.  The feedback MAY also report the presence of ECT(1)
      and ECT(0)/Not-ECT packets [<a href="rfc7560.html" title='"Problem Statement and Requirements for Increased Accuracy in Explicit Congestion Notification (ECN) Feedback"'>RFC7560</a>].  ([<a href="rfc3168.html" title='"The Addition of Explicit Congestion Notification (ECN) to IP"'>RFC3168</a>] and [<a href="rfc7560.html" title='"Problem Statement and Requirements for Increased Accuracy in Explicit Congestion Notification (ECN) Feedback"'>RFC7560</a>]
      specify methods for TCP.)

   o  An application sending ECN-capable datagrams MUST provide an
      appropriate congestion reaction when it receives feedback
      indicating that congestion has been experienced.  This ought to
      result in reduction of the sending rate by the UDP congestion
      control method (see <a href="#section-3.1">Section 3.1</a>) that is not less than the
      reaction of TCP under equivalent conditions.

   o  A sender SHOULD detect network paths that do not support the ECN
      field correctly.  When detected, they need to either
      conservatively react to congestion or even fall back to not using
      ECN [<a href="rfc8087.html" title='"The Benefits of Using Explicit Congestion Notification (ECN)"'>RFC8087</a>].  This method needs to be robust to changes within
      the network path that may occur over the lifetime of a session.

   o  A sender is encouraged to provide a mechanism to detect and react
      appropriately to misbehaving receivers that fail to report
      CE-marked packets [<a href="rfc8087.html" title='"The Benefits of Using Explicit Congestion Notification (ECN)"'>RFC8087</a>].

   [<a id="ref-RFC6679" name="ref-RFC6679">RFC6679</a>] provides guidance and an example of this support, by
   describing a method to allow ECN to be used for UDP-based
   applications using the Real-Time Protocol (RTP).  Applications that
   cannot provide this set of mechanisms, but wish to gain the benefits
   of using ECN, are encouraged to use a transport protocol that already
   supports ECN (such as TCP).

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/3.1.8.%20%20Differentiated%20Services%20Model"></a><a class="selflink" href="#section-3.1.8" name="section-3.1.8">3.1.8</a>.  Differentiated Services Model</span>

   An application using UDP can use the differentiated services
   (DiffServ) Quality of Service (QoS) framework.  To enable
   differentiated services processing, a UDP sender sets the



<span class="grey">Eggert, et al.            Best Current Practice                [Page 13]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-14" id="page-14" name="page-14"> </a>
<span class="grey"><a href="rfc8085.html">RFC 8085</a>                  UDP Usage Guidelines                March 2017</span>


   Differentiated Services Code Point (DSCP) field [<a href="rfc2475.html" title='"An Architecture for Differentiated Services"'>RFC2475</a>] in packets
   sent to the network.  Normally, a UDP source/destination port pair
   will set a single DSCP value for all packets belonging to a flow, but
   multiple DSCPs can be used as described later in this section.  A
   DSCP may be chosen from a small set of fixed values (the class
   selector code points), or from a set of recommended values defined in
   the Per Hop Behavior (PHB) specifications, or from values that have
   purely local meanings to a specific network that supports DiffServ.
   In general, packets may be forwarded across multiple networks between
   source and destination.

   In setting a non-default DSCP value, an application must be aware
   that DSCP markings may be changed or removed between the traffic
   source and destination.  This has implications on the design of
   applications that use DSCPs.  Specifically, applications SHOULD be
   designed not to rely on implementation of a specific network
   treatment; they need instead to implement congestion control methods
   to determine if their current sending rate is inducing congestion in
   the network.

   [<a id="ref-RFC7657" name="ref-RFC7657">RFC7657</a>] describes the implications of using DSCPs and provides
   recommendations on using multiple DSCPs within a single network five-
   tuple (source and destination addresses, source and destination
   ports, and the transport protocol used, in this case, UDP or
   UDP-Lite), and particularly the expected impact on transport protocol
   interactions, with congestion control or reliability functionality
   (e.g., retransmission, reordering).  Use of multiple DSCPs can result
   in reordering by increasing the set of network forwarding resources
   used by a sender.  It can also increase exposure to resource
   depletion or failure.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/3.1.9.%20%20QoS%2C%20Pre-Provisioned%2C%20or%20Reserved%20Capacity"></a><a class="selflink" href="#section-3.1.9" name="section-3.1.9">3.1.9</a>.  QoS, Pre-Provisioned, or Reserved Capacity</span>

   The IETF usually specifies protocols for use within the Best Effort
   General Internet.  Sometimes it is relevant to specify protocols with
   a different applicability.  An application using UDP can use the
   integrated services QoS framework.  This framework is usually made
   available within controlled environments (e.g., within a single
   administrative domain or bilaterally agreed connection between
   domains).  Applications intended for the Internet SHOULD NOT assume
   that QoS mechanisms are supported by the networks they use, and
   therefore need to provide congestion control, error recovery, etc.,
   in case the actual network path does not provide provisioned service.

   Some UDP applications are only expected to be deployed over network
   paths that use pre-provisioned capacity or capacity reserved using
   dynamic provisioning, e.g., through the Resource Reservation Protocol
   (RSVP).  Multicast applications are also used with pre-provisioned



<span class="grey">Eggert, et al.            Best Current Practice                [Page 14]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-15" id="page-15" name="page-15"> </a>
<span class="grey"><a href="rfc8085.html">RFC 8085</a>                  UDP Usage Guidelines                March 2017</span>


   capacity (e.g., IPTV deployments within access networks).  These
   applications MAY choose not to implement any congestion control
   mechanism and instead rely on transmitting only on paths where the
   capacity is provisioned and reserved for this use.  This might be an
   acceptable choice for a subset of restricted networking environments,
   but is by no means a safe practice for operation over the wider
   Internet.  Applications that choose this option SHOULD carefully and
   in detail describe the provisioning and management procedures that
   result in the desired containment.

   Applications that support an uncontrolled or unadaptive transmission
   behavior SHOULD NOT do so by default and SHOULD instead require users
   to explicitly enable this mode of operation.

   Applications designed for use within a controlled environment (see
   <a href="#section-3.6">Section 3.6</a>) may be able to exploit network management functions to
   detect whether they are causing congestion, and react accordingly.
   If the traffic of such applications leaks out into unprovisioned
   Internet paths, it can significantly degrade the performance of other
   traffic sharing the path and even result in congestion collapse.
   Protocols designed for such networks SHOULD provide mechanisms at the
   network edge to prevent leakage of traffic into unprovisioned
   Internet paths (e.g., [<a href="rfc7510.html" title='"Encapsulating MPLS in UDP"'>RFC7510</a>]).  To protect other applications
   sharing the same path, applications SHOULD also deploy an appropriate
   circuit breaker, as described in <a href="#section-3.1.10">Section 3.1.10</a>.

   An IETF specification targeting a controlled environment is expected
   to provide an applicability statement that restricts the application
   to the controlled environment (see <a href="#section-3.6">Section 3.6</a>).

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/3.1.10.%20%20Circuit%20Breaker%20Mechanisms"></a><a class="selflink" href="#section-3.1.10" name="section-3.1.10">3.1.10</a>.  Circuit Breaker Mechanisms</span>

   A transport circuit breaker is an automatic mechanism that is used to
   estimate the congestion caused by a flow, and to terminate (or
   significantly reduce the rate of) the flow when excessive congestion
   is detected [<a href="rfc8084.html" title='"Network Transport Circuit Breakers"'>RFC8084</a>].  This is a safety measure to prevent
   congestion collapse (starvation of resources available to other
   flows), essential for an Internet that is heterogeneous and for
   traffic that is hard to predict in advance.

   A circuit breaker is intended as a protection mechanism of last
   resort.  Under normal circumstances, a circuit breaker should not be
   triggered; it is designed to protect things when there is severe
   overload.  The goal is usually to limit the maximum transmission rate
   that reflects the available capacity of a network path.  Circuit
   breakers can operate on individual UDP flows or traffic aggregates,
   e.g., traffic sent using a network tunnel.




<span class="grey">Eggert, et al.            Best Current Practice                [Page 15]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-16" id="page-16" name="page-16"> </a>
<span class="grey"><a href="rfc8085.html">RFC 8085</a>                  UDP Usage Guidelines                March 2017</span>


   [<a id="ref-RFC8084" name="ref-RFC8084">RFC8084</a>] provides guidance and examples on the use of circuit
   breakers.  The use of a circuit breaker in RTP is specified in
   [<a href="rfc8083.html" title='"Multimedia Congestion Control: Circuit Breakers for Unicast RTP Sessions"'>RFC8083</a>].

   Applications used in the general Internet SHOULD implement a
   transport circuit breaker if they do not implement congestion control
   or operate a low data-volume service (see <a href="#section-3.6">Section 3.6</a>).  All
   applications MAY implement a transport circuit breaker [<a href="rfc8084.html" title='"Network Transport Circuit Breakers"'>RFC8084</a>] and
   are encouraged to consider implementing at least a slow-acting
   transport circuit breaker to provide a protection of last resort for
   their network traffic.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/3.1.11.%20%20UDP%20Tunnels"></a><a class="selflink" href="#section-3.1.11" name="section-3.1.11">3.1.11</a>.  UDP Tunnels</span>

   One increasingly popular use of UDP is as a tunneling protocol
   [<a href="#ref-INT-TUNNELS">INT-TUNNELS</a>], where a tunnel endpoint encapsulates the packets of
   another protocol inside UDP datagrams and transmits them to another
   tunnel endpoint, which decapsulates the UDP datagrams and forwards
   the original packets contained in the payload.  One example of such a
   protocol is Teredo [<a href="rfc4380.html" title='"Teredo: Tunneling IPv6 over UDP through Network Address Translations (NATs)"'>RFC4380</a>].  Tunnels establish virtual links that
   appear to directly connect locations that are distant in the physical
   Internet topology and can be used to create virtual (private)
   networks.  Using UDP as a tunneling protocol is attractive when the
   payload protocol is not supported by middleboxes that may exist along
   the path, because many middleboxes support transmission using UDP.

   Well-implemented tunnels are generally invisible to the endpoints
   that happen to transmit over a path that includes tunneled links.  On
   the other hand, to the routers along the path of a UDP tunnel, i.e.,
   the routers between the two tunnel endpoints, the traffic that a UDP
   tunnel generates is a regular UDP flow, and the encapsulator and
   decapsulator appear as regular UDP-sending and UDP-receiving
   applications.  Because other flows can share the path with one or
   more UDP tunnels, congestion control needs to be considered.

   Two factors determine whether a UDP tunnel needs to employ specific
   congestion control mechanisms: first, whether the payload traffic is
   IP-based; and second, whether the tunneling scheme generates UDP
   traffic at a volume that corresponds to the volume of payload traffic
   carried within the tunnel.

   IP-based unicast traffic is generally assumed to be congestion
   controlled, i.e., it is assumed that the transport protocols
   generating IP-based unicast traffic at the sender already employ
   mechanisms that are sufficient to address congestion on the path.
   Consequently, a tunnel carrying IP-based unicast traffic should





<span class="grey">Eggert, et al.            Best Current Practice                [Page 16]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-17" id="page-17" name="page-17"> </a>
<span class="grey"><a href="rfc8085.html">RFC 8085</a>                  UDP Usage Guidelines                March 2017</span>


   already interact appropriately with other traffic sharing the path,
   and specific congestion control mechanisms for the tunnel are not
   necessary.

   However, if the IP traffic in the tunnel is known not to be
   congestion controlled, additional measures are RECOMMENDED to limit
   the impact of the tunneled traffic on other traffic sharing the path.
   For the specific case of a tunnel that carries IP multicast traffic,
   see <a href="#section-4.1">Section 4.1</a>.

   The following guidelines define these possible cases in more detail:

   1.  A tunnel generates UDP traffic at a volume that corresponds to
       the volume of payload traffic, and the payload traffic is IP
       based and congestion controlled.

       This is arguably the most common case for Internet tunnels.  In
       this case, the UDP tunnel SHOULD NOT employ its own congestion
       control mechanism, because congestion losses of tunneled traffic
       will already trigger an appropriate congestion response at the
       original senders of the tunneled traffic.  A circuit breaker
       mechanism may provide benefit by controlling the envelope of the
       aggregated traffic.

       Note that this guideline is built on the assumption that most
       IP-based communication is congestion controlled.  If a UDP tunnel
       is used for IP-based traffic that is known to not be congestion
       controlled, the next set of guidelines applies.

   2.  A tunnel generates UDP traffic at a volume that corresponds to
       the volume of payload traffic, and the payload traffic is not
       known to be IP based, or is known to be IP based but not
       congestion controlled.

       This can be the case, for example, when some link-layer protocols
       are encapsulated within UDP (but not all link-layer protocols;
       some are congestion controlled).  Because it is not known that
       congestion losses of tunneled non-IP traffic will trigger an
       appropriate congestion response at the senders, the UDP tunnel
       SHOULD employ an appropriate congestion control mechanism or
       circuit breaker mechanism designed for the traffic it carries.
       Because tunnels are usually bulk-transfer applications as far as
       the intermediate routers are concerned, the guidelines in
       <a href="#section-3.1.2">Section 3.1.2</a> apply.

   3.  A tunnel generates UDP traffic at a volume that does not
       correspond to the volume of payload traffic, independent of
       whether the payload traffic is IP based or congestion controlled.



<span class="grey">Eggert, et al.            Best Current Practice                [Page 17]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-18" id="page-18" name="page-18"> </a>
<span class="grey"><a href="rfc8085.html">RFC 8085</a>                  UDP Usage Guidelines                March 2017</span>


       Examples of this class include UDP tunnels that send at a
       constant rate, increase their transmission rates under loss, for
       example, due to increasing redundancy when Forward Error
       Correction is used, or are otherwise unconstrained in their
       transmission behavior.  These specialized uses of UDP for
       tunneling go beyond the scope of the general guidelines given in
       this document.  The implementer of such specialized tunnels
       SHOULD carefully consider congestion control in the design of
       their tunneling mechanism and SHOULD consider use of a circuit
       breaker mechanism.

   The type of encapsulated payload might be identified by a UDP port;
   identified by an Ethernet Type or IP protocol number.  A tunnel
   SHOULD provide mechanisms to restrict the types of flows that may be
   carried by the tunnel.  For instance, a UDP tunnel designed to carry
   IP needs to filter out non-IP traffic at the ingress.  This is
   particularly important when a generic tunnel encapsulation is used
   (e.g., one that encapsulates using an EtherType value).  Such tunnels
   SHOULD provide a mechanism to restrict the types of traffic that are
   allowed to be encapsulated for a given deployment (see
   [<a href="#ref-INT-TUNNELS">INT-TUNNELS</a>]).

   Designing a tunneling mechanism requires significantly more expertise
   than needed for many other UDP applications, because tunnels are
   usually intended to be transparent to the endpoints transmitting over
   them, so they need to correctly emulate the behavior of an IP link
   [<a href="#ref-INT-TUNNELS">INT-TUNNELS</a>], for example:

   o  Requirements for tunnels that carry or encapsulate using ECN code
      points [<a href="rfc6040.html" title='"Tunnelling of Explicit Congestion Notification"'>RFC6040</a>].

   o  Usage of the IP DSCP field by tunnel endpoints [<a href="rfc2983.html" title='"Differentiated Services and Tunnels"'>RFC2983</a>].

   o  Encapsulation considerations in the design of tunnels [<a href="#ref-ENCAP" title='"Encapsulation Considerations"'>ENCAP</a>].

   o  Usage of ICMP messages [<a href="#ref-INT-TUNNELS">INT-TUNNELS</a>].

   o  Handling of fragmentation and packet size for tunnels
      [<a href="#ref-INT-TUNNELS">INT-TUNNELS</a>].

   o  Source port usage for tunnels designed to support equal cost
      multipath (ECMP) routing (see <a href="#section-5.1.1">Section 5.1.1</a>).

   o  Guidance on the need to protect headers [<a href="#ref-INT-TUNNELS">INT-TUNNELS</a>] and the use
      of checksums for IPv6 tunnels (see <a href="#section-3.4.1">Section 3.4.1</a>).

   o  Support for operations and maintenance [<a href="#ref-INT-TUNNELS">INT-TUNNELS</a>].




<span class="grey">Eggert, et al.            Best Current Practice                [Page 18]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-19" id="page-19" name="page-19"> </a>
<span class="grey"><a href="rfc8085.html">RFC 8085</a>                  UDP Usage Guidelines                March 2017</span>


   At the same time, the tunneled traffic is application traffic like
   any other from the perspective of the networks the tunnel transmits
   over.  This document only touches upon the congestion control
   considerations for implementing UDP tunnels; a discussion of other
   required tunneling behavior is out of scope.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.2.%20%20Message%20Size%20Guidelines"></a><a class="selflink" href="#section-3.2" name="section-3.2">3.2</a>.  Message Size Guidelines</span>

   IP fragmentation lowers the efficiency and reliability of Internet
   communication.  The loss of a single fragment results in the loss of
   an entire fragmented packet, because even if all other fragments are
   received correctly, the original packet cannot be reassembled and
   delivered.  This fundamental issue with fragmentation exists for both
   IPv4 and IPv6.

   In addition, some network address translators (NATs) and firewalls
   drop IP fragments.  The network address translation performed by a
   NAT only operates on complete IP packets, and some firewall policies
   also require inspection of complete IP packets.  Even with these
   being the case, some NATs and firewalls simply do not implement the
   necessary reassembly functionality; instead, they choose to drop all
   fragments.  Finally, [<a href="rfc4963.html" title='"IPv4 Reassembly Errors at High Data Rates"'>RFC4963</a>] documents other issues specific to
   IPv4 fragmentation.

   Due to these issues, an application SHOULD NOT send UDP datagrams
   that result in IP packets that exceed the Maximum Transmission Unit
   (MTU) along the path to the destination.  Consequently, an
   application SHOULD either use the path MTU information provided by
   the IP layer or implement Path MTU Discovery (PMTUD) itself [<a href="rfc1191.html" title='"Path MTU discovery"'>RFC1191</a>]
   [<a href="rfc1981.html" title='"Path MTU Discovery for IP version 6"'>RFC1981</a>] [<a href="rfc4821.html" title='"Packetization Layer Path MTU Discovery"'>RFC4821</a>] to determine whether the path to a destination
   will support its desired message size without fragmentation.

   However, the ICMP messages that enable path MTU discovery are being
   increasingly filtered by middleboxes (including Firewalls) [<a href="rfc4890.html" title='"Recommendations for Filtering ICMPv6 Messages in Firewalls"'>RFC4890</a>].
   When the path includes a tunnel, some devices acting as a tunnel
   ingress discard ICMP messages that originate from network devices
   over which the tunnel passes, preventing these from reaching the UDP
   endpoint.

   Packetization Layer Path MTU Discovery (PLPMTUD) [<a href="rfc4821.html" title='"Packetization Layer Path MTU Discovery"'>RFC4821</a>] does not
   rely upon network support for ICMP messages and is therefore
   considered more robust than standard PMTUD.  It is not susceptible to
   "black holing" of ICMP messages.  To operate, PLPMTUD requires
   changes to the way the transport is used: both to transmit probe
   packets and to account for the loss or success of these probes.  This
   not only updates the PMTU algorithm, it also impacts loss recovery,
   congestion control, etc.  These updated mechanisms can be implemented




<span class="grey">Eggert, et al.            Best Current Practice                [Page 19]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-20" id="page-20" name="page-20"> </a>
<span class="grey"><a href="rfc8085.html">RFC 8085</a>                  UDP Usage Guidelines                March 2017</span>


   within a connection-oriented transport (e.g., TCP, SCTP, DCCP), but
   they are not a part of UDP; this type of feedback is not typically
   present for unidirectional applications.

   Therefore, PLPMTUD places additional design requirements on a UDP
   application that wishes to use this method.  This is especially true
   for UDP tunnels, because the overhead of sending probe packets needs
   to be accounted for and may require adding a congestion control
   mechanism to the tunnel (see <a href="#section-3.1.11">Section 3.1.11</a>) as well as complicating
   the data path at a tunnel decapsulator.

   Applications that do not follow the recommendation to do PMTU/PLPMTUD
   discovery SHOULD still avoid sending UDP datagrams that would result
   in IP packets that exceed the path MTU.  Because the actual path MTU
   is unknown, such applications SHOULD fall back to sending messages
   that are shorter than the default effective MTU for sending (EMTU_S
   in [<a href="rfc1122.html" title='"Requirements for Internet Hosts - Communication Layers"'>RFC1122</a>]).  For IPv4, EMTU_S is the smaller of 576 bytes and the
   first-hop MTU [<a href="rfc1122.html" title='"Requirements for Internet Hosts - Communication Layers"'>RFC1122</a>].  For IPv6, EMTU_S is 1280 bytes [<a href="rfc2460.html" title='"Internet Protocol, Version 6 (IPv6) Specification"'>RFC2460</a>].
   The effective PMTU for a directly connected destination (with no
   routers on the path) is the configured interface MTU, which could be
   less than the maximum link payload size.  Transmission of minimum-
   sized UDP datagrams is inefficient over paths that support a larger
   PMTU, which is a second reason to implement PMTU discovery.

   To determine an appropriate UDP payload size, applications MUST
   subtract the size of the IP header (which includes any IPv4 optional
   headers or IPv6 extension headers) as well as the length of the UDP
   header (8 bytes) from the PMTU size.  This size, known as the Maximum
   Segment Size (MSS), can be obtained from the TCP/IP stack [<a href="rfc1122.html" title='"Requirements for Internet Hosts - Communication Layers"'>RFC1122</a>].

   Applications that do not send messages that exceed the effective PMTU
   of IPv4 or IPv6 need not implement any of the above mechanisms.  Note
   that the presence of tunnels can cause an additional reduction of the
   effective PMTU [<a href="#ref-INT-TUNNELS">INT-TUNNELS</a>], so implementing PMTU discovery may be
   beneficial.

   Applications that fragment an application-layer message into multiple
   UDP datagrams SHOULD perform this fragmentation so that each datagram
   can be received independently, and be independently retransmitted in
   the case where an application implements its own reliability
   mechanisms.










<span class="grey">Eggert, et al.            Best Current Practice                [Page 20]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-21" id="page-21" name="page-21"> </a>
<span class="grey"><a href="rfc8085.html">RFC 8085</a>                  UDP Usage Guidelines                March 2017</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.3.%20%20Reliability%20Guidelines"></a><a class="selflink" href="#section-3.3" name="section-3.3">3.3</a>.  Reliability Guidelines</span>

   Application designers are generally aware that UDP does not provide
   any reliability, e.g., it does not retransmit any lost packets.
   Often, this is a main reason to consider UDP as a transport protocol.
   Applications that do require reliable message delivery MUST implement
   an appropriate mechanism themselves.

   UDP also does not protect against datagram duplication, i.e., an
   application may receive multiple copies of the same UDP datagram,
   with some duplicates arriving potentially much later than the first.
   Application designers SHOULD handle such datagram duplication
   gracefully, and they may consequently need to implement mechanisms to
   detect duplicates.  Even if UDP datagram reception triggers only
   idempotent operations, applications may want to suppress duplicate
   datagrams to reduce load.

   Applications that require ordered delivery MUST reestablish datagram
   ordering themselves.  The Internet can significantly delay some
   packets with respect to others, e.g., due to routing transients,
   intermittent connectivity, or mobility.  This can cause reordering,
   where UDP datagrams arrive at the receiver in an order different from
   the transmission order.

   Applications that use multiple transport ports need to be robust to
   reordering between sessions.  Load-balancing techniques within the
   network, such as Equal Cost Multipath (ECMP) forwarding can also
   result in a lack of ordering between different transport sessions,
   even between the same two network endpoints.

   It is important to note that the time by which packets are reordered
   or after which duplicates can still arrive can be very large.  Even
   more importantly, there is no well-defined upper boundary here.
   [<a href="rfc793.html" title='"Transmission Control Protocol"'>RFC793</a>] defines the maximum delay a TCP segment should experience --
   the Maximum Segment Lifetime (MSL) -- as 2 minutes.  No other RFC
   defines an MSL for other transport protocols or IP itself.  The MSL
   value defined for TCP is conservative enough that it SHOULD be used
   by other protocols, including UDP.  Therefore, applications SHOULD be
   robust to the reception of delayed or duplicate packets that are
   received within this 2-minute interval.

   Retransmission of lost packets or messages is a common reliability
   mechanism.  Such retransmissions can increase network load in
   response to congestion, worsening that congestion.  Any application
   that uses retransmission is responsible for congestion control of its
   retransmissions (as well as the application's original traffic);
   hence, it is subject to the Congestion Control guidelines in




<span class="grey">Eggert, et al.            Best Current Practice                [Page 21]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-22" id="page-22" name="page-22"> </a>
<span class="grey"><a href="rfc8085.html">RFC 8085</a>                  UDP Usage Guidelines                March 2017</span>


   <a href="#section-3.1">Section 3.1</a>.  Guidance on the appropriate measurement of RTT in
   <a href="#section-3.1.1">Section 3.1.1</a> also applies for timers used for retransmission packet-
   loss detection.

   Instead of implementing these relatively complex reliability
   mechanisms by itself, an application that requires reliable and
   ordered message delivery SHOULD whenever possible choose an IETF
   standard transport protocol that provides these features.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.4.%20%20Checksum%20Guidelines"></a><a class="selflink" href="#section-3.4" name="section-3.4">3.4</a>.  Checksum Guidelines</span>

   The UDP header includes an optional, 16-bit one's complement checksum
   that provides an integrity check.  These checks are not strong from a
   coding or cryptographic perspective and are not designed to detect
   physical-layer errors or malicious modification of the datagram
   [<a href="rfc3819.html" title='"Advice for Internet Subnetwork Designers"'>RFC3819</a>].  Application developers SHOULD implement additional checks
   where data integrity is important, e.g., through a Cyclic Redundancy
   Check (CRC) or keyed or non-keyed cryptographic hash included with
   the data to verify the integrity of an entire object/file sent over
   the UDP service.

   The UDP checksum provides a statistical guarantee that the payload
   was not corrupted in transit.  It also allows the receiver to verify
   that it was the intended destination of the packet, because it covers
   the IP addresses, port numbers, and protocol number, and it verifies
   that the packet is not truncated or padded, because it covers the
   size field.  Therefore, it protects an application against receiving
   corrupted payload data in place of, or in addition to, the data that
   was sent.  More description of the set of checks performed using the
   checksum field is provided in <a href="rfc6396.html#section-3.1">Section 3.1 of [RFC6396]</a>.

   Applications SHOULD enable UDP checksums [<a href="rfc1122.html" title='"Requirements for Internet Hosts - Communication Layers"'>RFC1122</a>].  For IPv4,
   [<a href="rfc768.html" title='"User Datagram Protocol"'>RFC768</a>] permits an option to disable their use, by setting a zero
   checksum value.  An application is permitted to optionally discard
   UDP datagrams with a zero checksum [<a href="rfc1122.html" title='"Requirements for Internet Hosts - Communication Layers"'>RFC1122</a>].

   When UDP is used over IPv6, the UDP checksum is relied upon to
   protect both the IPv6 and UDP headers from corruption (because IPv6
   lacks a checksum) and MUST be used as specified in [<a href="rfc2460.html" title='"Internet Protocol, Version 6 (IPv6) Specification"'>RFC2460</a>].  Under
   specific conditions, a UDP application is allowed to use a zero UDP
   zero-checksum mode with a tunnel protocol (see <a href="#section-3.4.1">Section 3.4.1</a>).

   Applications that choose to disable UDP checksums MUST NOT make
   assumptions regarding the correctness of received data and MUST
   behave correctly when a UDP datagram is received that was originally
   sent to a different destination or is otherwise corrupted.





<span class="grey">Eggert, et al.            Best Current Practice                [Page 22]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-23" id="page-23" name="page-23"> </a>
<span class="grey"><a href="rfc8085.html">RFC 8085</a>                  UDP Usage Guidelines                March 2017</span>


<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/3.4.1.%20%20IPv6%20Zero%20UDP%20Checksum"></a><a class="selflink" href="#section-3.4.1" name="section-3.4.1">3.4.1</a>.  IPv6 Zero UDP Checksum</span>

   [<a id="ref-RFC6935" name="ref-RFC6935">RFC6935</a>] defines a method that enables use of a zero UDP zero-
   checksum mode with a tunnel protocol, providing that the method
   satisfies the requirements in [<a href="rfc6936.html" title='"Applicability Statement for the Use of IPv6 UDP Datagrams with Zero Checksums"'>RFC6936</a>].  The application MUST
   implement mechanisms and/or usage restrictions when enabling this
   mode.  This includes defining the scope for usage and measures to
   prevent leakage of traffic to other UDP applications (see <a href="#appendix-A">Appendix A</a>
   and <a href="#section-3.6">Section 3.6</a>).  These additional design requirements for using a
   zero IPv6 UDP checksum are not present for IPv4, since the IPv4
   header validates information that is not protected in an IPv6 packet.
   Key requirements are:

   o  Use of the UDP checksum with IPv6 MUST be the default
      configuration for all implementations [<a href="rfc6935.html" title='"IPv6 and UDP Checksums for Tunneled Packets"'>RFC6935</a>].  The receiving
      endpoint MUST only allow the use of UDP zero-checksum mode for
      IPv6 on a UDP destination port that is specifically enabled.

   o  An application that supports a checksum different than that in
      [<a href="rfc2460.html" title='"Internet Protocol, Version 6 (IPv6) Specification"'>RFC2460</a>] MUST comply with all implementation requirements
      specified in <a href="rfc6936.html#section-4">Section 4 of [RFC6936]</a> and with the usage
      requirements specified in <a href="rfc6936.html#section-5">Section 5 of [RFC6936]</a>.

   o  A UDP application MUST check that the source and destination IPv6
      addresses are valid for any packets with a UDP zero-checksum and
      MUST discard any packet for which this check fails.  To protect
      from misdelivery, new encapsulation designs SHOULD include an
      integrity check at the transport layer that includes at least the
      IPv6 header, the UDP header and the shim header for the
      encapsulation, if any [<a href="rfc6936.html" title='"Applicability Statement for the Use of IPv6 UDP Datagrams with Zero Checksums"'>RFC6936</a>].

   o  One way to help satisfy the requirements of [<a href="rfc6936.html" title='"Applicability Statement for the Use of IPv6 UDP Datagrams with Zero Checksums"'>RFC6936</a>] may be to
      limit the usage of such tunnels, e.g., to constrain traffic to an
      operator network, as discussed in <a href="#section-3.6">Section 3.6</a>.  The encapsulation
      defined for MPLS in UDP [<a href="rfc7510.html" title='"Encapsulating MPLS in UDP"'>RFC7510</a>] chooses this approach.

   As in IPv4, IPv6 applications that choose to disable UDP checksums
   MUST NOT make assumptions regarding the correctness of received data
   and MUST behave correctly when a UDP datagram is received that was
   originally sent to a different destination or is otherwise corrupted.

   IPv6 datagrams with a zero UDP checksum will not be passed by any
   middlebox that validates the checksum based on [<a href="rfc2460.html" title='"Internet Protocol, Version 6 (IPv6) Specification"'>RFC2460</a>] or that
   updates the UDP checksum field, such as NATs or firewalls.  Changing
   this behavior would require such middleboxes to be updated to
   correctly handle datagrams with zero UDP checksums.  To ensure end-
   to-end robustness, applications that may be deployed in the general
   Internet MUST provide a mechanism to safely fall back to using a



<span class="grey">Eggert, et al.            Best Current Practice                [Page 23]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-24" id="page-24" name="page-24"> </a>
<span class="grey"><a href="rfc8085.html">RFC 8085</a>                  UDP Usage Guidelines                March 2017</span>


   checksum when a path change occurs that redirects a zero UDP checksum
   flow over a path that includes a middlebox that discards IPv6
   datagrams with a zero UDP checksum.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/3.4.2.%20%20UDP-Lite"></a><a class="selflink" href="#section-3.4.2" name="section-3.4.2">3.4.2</a>.  UDP-Lite</span>

   A special class of applications can derive benefit from having
   partially damaged payloads delivered, rather than discarded, when
   using paths that include error-prone links.  Such applications can
   tolerate payload corruption and MAY choose to use the Lightweight
   User Datagram Protocol (UDP-Lite) [<a href="rfc3828.html" title='"The Lightweight User Datagram Protocol (UDP-Lite)"'>RFC3828</a>] variant of UDP instead of
   basic UDP.  Applications that choose to use UDP-Lite instead of UDP
   should still follow the congestion control and other guidelines
   described for use with UDP in <a href="#section-3">Section 3</a>.

   UDP-Lite changes the semantics of the UDP "payload length" field to
   that of a "checksum coverage length" field.  Otherwise, UDP-Lite is
   semantically identical to UDP.  The interface of UDP-Lite differs
   from that of UDP by the addition of a single (socket) option that
   communicates the checksum coverage length: at the sender, this
   specifies the intended checksum coverage, with the remaining
   unprotected part of the payload called the "error-insensitive part".
   By default, the UDP-Lite checksum coverage extends across the entire
   datagram.  If required, an application may dynamically modify this
   length value, e.g., to offer greater protection to some messages.
   UDP-Lite always verifies that a packet was delivered to the intended
   destination, i.e., always verifies the header fields.  Errors in the
   insensitive part will not cause a UDP datagram to be discarded by the
   destination.  Therefore, applications using UDP-Lite MUST NOT make
   assumptions regarding the correctness of the data received in the
   insensitive part of the UDP-Lite payload.

   A UDP-Lite sender SHOULD select the minimum checksum coverage to
   include all sensitive payload information.  For example, applications
   that use the Real-Time Protocol (RTP) [<a href="rfc3550.html" title='"RTP: A Transport Protocol for Real-Time Applications"'>RFC3550</a>] will likely want to
   protect the RTP header against corruption.  Applications, where
   appropriate, MUST also introduce their own appropriate validity
   checks for protocol information carried in the insensitive part of
   the UDP-Lite payload (e.g., internal CRCs).

   A UDP-Lite receiver MUST set a minimum coverage threshold for
   incoming packets that is not smaller than the smallest coverage used
   by the sender [<a href="rfc3828.html" title='"The Lightweight User Datagram Protocol (UDP-Lite)"'>RFC3828</a>].  The receiver SHOULD select a threshold that
   is sufficiently large to block packets with an inappropriately short
   coverage field.  This may be a fixed value, or it may be negotiated
   by an application.  UDP-Lite does not provide mechanisms to negotiate
   the checksum coverage between the sender and receiver.  Therefore,
   this needs to be performed by the application.



<span class="grey">Eggert, et al.            Best Current Practice                [Page 24]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-25" id="page-25" name="page-25"> </a>
<span class="grey"><a href="rfc8085.html">RFC 8085</a>                  UDP Usage Guidelines                March 2017</span>


   Applications can still experience packet loss when using UDP-Lite.
   The enhancements offered by UDP-Lite rely upon a link being able to
   intercept the UDP-Lite header to correctly identify the partial
   coverage required.  When tunnels and/or encryption are used, this can
   result in UDP-Lite datagrams being treated the same as UDP datagrams,
   i.e., result in packet loss.  Use of IP fragmentation can also
   prevent special treatment for UDP-Lite datagrams, and this is another
   reason why applications SHOULD avoid IP fragmentation (<a href="#section-3.2">Section 3.2</a>).

   UDP-Lite is supported in some endpoint protocol stacks.  Current
   support for middlebox traversal using UDP-Lite is poor, because UDP-
   Lite uses a different IPv4 protocol number or IPv6 "next header"
   value than that used for UDP; therefore, few middleboxes are
   currently able to interpret UDP-Lite and take appropriate actions
   when forwarding the packet.  This makes UDP-Lite less suited for
   applications needing general Internet support, until such time as
   UDP-Lite has achieved better support in middleboxes.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.5.%20%20Middlebox%20Traversal%20Guidelines"></a><a class="selflink" href="#section-3.5" name="section-3.5">3.5</a>.  Middlebox Traversal Guidelines</span>

   NATs and firewalls are examples of intermediary devices
   ("middleboxes") that can exist along an end-to-end path.  A middlebox
   typically performs a function that requires it to maintain per-flow
   state.  For connection-oriented protocols, such as TCP, middleboxes
   snoop and parse the connection-management information, and create and
   destroy per-flow state accordingly.  For a connectionless protocol
   such as UDP, this approach is not possible.  Consequently,
   middleboxes can create per-flow state when they see a packet that --
   according to some local criteria -- indicates a new flow, and destroy
   the state after some time during which no packets belonging to the
   same flow have arrived.

   Depending on the specific function that the middlebox performs, this
   behavior can introduce a time-dependency that restricts the kinds of
   UDP traffic exchanges that will be successful across the middlebox.
   For example, NATs and firewalls typically define the partial path on
   one side of them to be interior to the domain they serve, whereas the
   partial path on their other side is defined to be exterior to that
   domain.  Per-flow state is typically created when the first packet
   crosses from the interior to the exterior, and while the state is
   present, NATs and firewalls will forward return traffic.  Return
   traffic that arrives after the per-flow state has timed out is
   dropped, as is other traffic that arrives from the exterior.








<span class="grey">Eggert, et al.            Best Current Practice                [Page 25]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-26" id="page-26" name="page-26"> </a>
<span class="grey"><a href="rfc8085.html">RFC 8085</a>                  UDP Usage Guidelines                March 2017</span>


   Many applications that use UDP for communication operate across
   middleboxes without needing to employ additional mechanisms.  One
   example is the Domain Name System (DNS), which has a strict request-
   response communication pattern that typically completes within
   seconds.

   Other applications may experience communication failures when
   middleboxes destroy the per-flow state associated with an application
   session during periods when the application does not exchange any UDP
   traffic.  Applications SHOULD be able to gracefully handle such
   communication failures and implement mechanisms to re-establish
   application-layer sessions and state.

   For some applications, such as media transmissions, this
   re-synchronization is highly undesirable, because it can cause user-
   perceivable playback artifacts.  Such specialized applications MAY
   send periodic keep-alive messages to attempt to refresh middlebox
   state (e.g., [<a href="rfc7675.html" title='"Session Traversal Utilities for NAT (STUN) Usage for Consent Freshness"'>RFC7675</a>]).  It is important to note that keep-alive
   messages are not recommended for general use -- they are unnecessary
   for many applications and can consume significant amounts of system
   and network resources.

   An application that needs to employ keep-alive messages to deliver
   useful service over UDP in the presence of middleboxes SHOULD NOT
   transmit them more frequently than once every 15 seconds and SHOULD
   use longer intervals when possible.  No common timeout has been
   specified for per-flow UDP state for arbitrary middleboxes.  NATs
   require a state timeout of 2 minutes or longer [<a href="rfc4787.html" title='"Network Address Translation (NAT) Behavioral Requirements for Unicast UDP"'>RFC4787</a>].  However,
   empirical evidence suggests that a significant fraction of currently
   deployed middleboxes unfortunately use shorter timeouts.  The timeout
   of 15 seconds originates with the Interactive Connectivity
   Establishment (ICE) protocol [<a href="rfc5245.html" title='"Interactive Connectivity Establishment (ICE): A Protocol for Network Address Translator (NAT) Traversal for Offer/Answer Protocols"'>RFC5245</a>].  When an application is
   deployed in a controlled environment, the deployer SHOULD investigate
   whether the target environment allows applications to use longer
   intervals, or whether it offers mechanisms to explicitly control
   middlebox state timeout durations, for example, using the Port
   Control Protocol (PCP) [<a href="rfc6887.html" title='"Port Control Protocol (PCP)"'>RFC6887</a>], Middlebox Communications (MIDCOM)
   [<a href="rfc3303.html" title='"Middlebox communication architecture and framework"'>RFC3303</a>], Next Steps in Signaling (NSIS) [<a href="rfc5973.html" title='"NAT/Firewall NSIS Signaling Layer Protocol (NSLP)"'>RFC5973</a>], or Universal
   Plug and Play (UPnP) [<a href="#ref-UPnP" title='"Internet Gateway Device (IGD) Standardized Device Control Protocol V 1.0"'>UPnP</a>].  It is RECOMMENDED that applications
   apply slight random variations ("jitter") to the timing of keep-alive
   transmissions, to reduce the potential for persistent synchronization
   between keep-alive transmissions from different hosts [<a href="rfc7675.html" title='"Session Traversal Utilities for NAT (STUN) Usage for Consent Freshness"'>RFC7675</a>].









<span class="grey">Eggert, et al.            Best Current Practice                [Page 26]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-27" id="page-27" name="page-27"> </a>
<span class="grey"><a href="rfc8085.html">RFC 8085</a>                  UDP Usage Guidelines                March 2017</span>


   Sending keep-alive messages is not a substitute for implementing a
   mechanism to recover from broken sessions.  Like all UDP datagrams,
   keep-alive messages can be delayed or dropped, causing middlebox
   state to time out.  In addition, the congestion control guidelines in
   <a href="#section-3.1">Section 3.1</a> cover all UDP transmissions by an application, including
   the transmission of middlebox keep-alive messages.  Congestion
   control may thus lead to delays or temporary suspension of keep-alive
   transmission.

   Keep-alive messages are NOT RECOMMENDED for general use.  They are
   unnecessary for many applications and may consume significant
   resources.  For example, on battery-powered devices, if an
   application needs to maintain connectivity for long periods with
   little traffic, the frequency at which keep-alive messages are sent
   can become the determining factor that governs power consumption,
   depending on the underlying network technology.

   Because many middleboxes are designed to require keep-alive messages
   for TCP connections at a frequency that is much lower than that
   needed for UDP, this difference alone can often be sufficient to
   prefer TCP over UDP for these deployments.  On the other hand, there
   is anecdotal evidence that suggests that direct communication through
   middleboxes, e.g., by using ICE [<a href="rfc5245.html" title='"Interactive Connectivity Establishment (ICE): A Protocol for Network Address Translator (NAT) Traversal for Offer/Answer Protocols"'>RFC5245</a>], does succeed less often
   with TCP than with UDP.  The trade-offs between different transport
   protocols -- especially when it comes to middlebox traversal --
   deserve careful analysis.

   UDP applications that could be deployed in the Internet need to be
   designed understanding that there are many variants of middlebox
   behavior, and although UDP is connectionless, middleboxes often
   maintain state for each UDP flow.  Using multiple UDP flows can
   consume available state space and also can lead to changes in the way
   the middlebox handles subsequent packets (either to protect its
   internal resources, or to prevent perceived misuse).  The probability
   of path failure can increase when applications use multiple UDP flows
   in parallel (see <a href="#section-5.1.2">Section 5.1.2</a> for recommendations on usage of
   multiple ports).

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.6.%20%20Limited%20Applicability%20and%20Controlled%20Environments"></a><a class="selflink" href="#section-3.6" name="section-3.6">3.6</a>.  Limited Applicability and Controlled Environments</span>

   Two different types of applicability have been identified for the
   specification of IETF applications that utilize UDP:

   General Internet.  By default, IETF specifications target deployment
      on the general Internet.  Experience has shown that successful
      protocols developed in one specific context or for a particular
      application tend to become used in a wider range of contexts.  For
      example, a protocol with an initial deployment within a local area



<span class="grey">Eggert, et al.            Best Current Practice                [Page 27]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-28" id="page-28" name="page-28"> </a>
<span class="grey"><a href="rfc8085.html">RFC 8085</a>                  UDP Usage Guidelines                March 2017</span>


      network may subsequently be used over a virtual network that
      traverses the Internet, or in the Internet in general.
      Applications designed for general Internet use may experience a
      range of network device behaviors and, in particular, should
      consider whether applications need to operate over paths that may
      include middleboxes.

   Controlled Environment.  A protocol/encapsulation/tunnel could be
      designed to be used only within a controlled environment.  For
      example, an application designed for use by a network operator
      might only be deployed within the network of that single network
      operator or on networks of an adjacent set of cooperating network
      operators.  The application traffic may then be managed to avoid
      congestion, rather than relying on built-in mechanisms, which are
      required when operating over the general Internet.  Applications
      that target a limited applicability use case may be able to take
      advantage of specific hardware (e.g., carrier-grade equipment) or
      underlying protocol features of the subnetwork over which they are
      used.

   Specifications addressing a limited applicability use case or a
   controlled environment SHOULD identify how, in their restricted
   deployment, a level of safety is provided that is equivalent to that
   of a protocol designed for operation over the general Internet (e.g.,
   a design based on extensive experience with deployments of particular
   methods that provide features that cannot be expected in general
   Internet equipment and the robustness of the design of MPLS to
   corruption of headers both helped justify use of an alternate UDP
   integrity check [<a href="rfc7510.html" title='"Encapsulating MPLS in UDP"'>RFC7510</a>]).

   An IETF specification targeting a controlled environment is expected
   to provide an applicability statement that restricts the application
   traffic to the controlled environment, and it would be expected to
   describe how methods can be provided to discourage or prevent escape
   of corrupted packets from the environment (for example, <a href="rfc7510.html#section-5">Section 5 of
   [RFC7510]</a>).

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/4.%20%20Multicast%20UDP%20Usage%20Guidelines"></a><a class="selflink" href="#section-4" name="section-4">4</a>.  Multicast UDP Usage Guidelines</span>

   This section complements <a href="#section-3">Section 3</a> by providing additional guidelines
   that are applicable to multicast and broadcast usage of UDP.

   Multicast and broadcast transmission [<a href="rfc1112.html" title='"Host extensions for IP multicasting"'>RFC1112</a>] usually employ the UDP
   transport protocol, although they may be used with other transport
   protocols (e.g., UDP-Lite).






<span class="grey">Eggert, et al.            Best Current Practice                [Page 28]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-29" id="page-29" name="page-29"> </a>
<span class="grey"><a href="rfc8085.html">RFC 8085</a>                  UDP Usage Guidelines                March 2017</span>


   There are currently two models of multicast delivery: the Any-Source
   Multicast (ASM) model as defined in [<a href="rfc1112.html" title='"Host extensions for IP multicasting"'>RFC1112</a>] and the Source-Specific
   Multicast (SSM) model as defined in [<a href="rfc4607.html" title='"Source-Specific Multicast for IP"'>RFC4607</a>].  ASM group members
   will receive all data sent to the group by any source, while SSM
   constrains the distribution tree to only one single source.

   Specialized classes of applications also use UDP for IP multicast or
   broadcast [<a href="rfc919.html" title='"Broadcasting Internet Datagrams"'>RFC919</a>].  The design of such specialized applications
   requires expertise that goes beyond simple, unicast-specific
   guidelines, since these senders may transmit to potentially very many
   receivers across potentially very heterogeneous paths at the same
   time, which significantly complicates congestion control, flow
   control, and reliability mechanisms.

   This section provides guidance on multicast and broadcast UDP usage.
   Use of broadcast by an application is normally constrained by routers
   to the local subnetwork.  However, use of tunneling techniques and
   proxies can and does result in some broadcast traffic traversing
   Internet paths.  These guidelines therefore also apply to broadcast
   traffic.

   The IETF has defined a reliable multicast framework [<a href="rfc3048.html" title='"Reliable Multicast Transport Building Blocks for One-to-Many Bulk-Data Transfer"'>RFC3048</a>] and
   several building blocks to aid the designers of multicast
   applications, such as [<a href="rfc3738.html" title='"Wave and Equation Based Rate Control (WEBRC) Building Block"'>RFC3738</a>] or [<a href="rfc4654.html" title='"TCP-Friendly Multicast Congestion Control (TFMCC): Protocol Specification"'>RFC4654</a>].

   Senders to anycast destinations must be aware that successive
   messages sent to the same anycast IP address may be delivered to
   different anycast nodes, i.e., arrive at different locations in the
   topology.

   Most UDP tunnels that carry IP multicast traffic use a tunnel
   encapsulation with a unicast destination address, such as Automatic
   Multicast Tunneling [<a href="rfc7450.html" title='"Automatic Multicast Tunneling"'>RFC7450</a>].  These MUST follow the same
   requirements as a tunnel carrying unicast data (see <a href="#section-3.1.11">Section 3.1.11</a>).
   There are deployment cases and solutions where the outer header of a
   UDP tunnel contains a multicast destination address, such as
   [<a href="rfc6513.html" title='"Multicast in MPLS/ BGP IP VPNs"'>RFC6513</a>].  These cases are primarily deployed in controlled
   environments over reserved capacity, often operating within a single
   administrative domain, or between two domains over a bilaterally
   agreed upon path with reserved capacity, and so congestion control is
   OPTIONAL, but circuit breaker techniques are still RECOMMENDED in
   order to restore some degree of service should the offered load
   exceed the reserved capacity (e.g., due to misconfiguration).








<span class="grey">Eggert, et al.            Best Current Practice                [Page 29]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-30" id="page-30" name="page-30"> </a>
<span class="grey"><a href="rfc8085.html">RFC 8085</a>                  UDP Usage Guidelines                March 2017</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.1.%20%20Multicast%20Congestion%20Control%20Guidelines"></a><a class="selflink" href="#section-4.1" name="section-4.1">4.1</a>.  Multicast Congestion Control Guidelines</span>

   Unicast congestion-controlled transport mechanisms are often not
   applicable to multicast distribution services, or simply do not scale
   to large multicast trees, since they require bidirectional
   communication and adapt the sending rate to accommodate the network
   conditions to a single receiver.  In contrast, multicast distribution
   trees may fan out to massive numbers of receivers, which limits the
   scalability of an in-band return channel to control the sending rate,
   and the one-to-many nature of multicast distribution trees prevents
   adapting the rate to the requirements of an individual receiver.  For
   this reason, generating TCP-compatible aggregate flow rates for
   Internet multicast data, either native or tunneled, is the
   responsibility of the application implementing the congestion
   control.

   Applications using multicast SHOULD provide appropriate congestion
   control.  Multicast congestion control needs to be designed using
   mechanisms that are robust to the potential heterogeneity of both the
   multicast distribution tree and the receivers belonging to a group.
   Heterogeneity may manifest itself in some receivers experiencing more
   loss that others, higher delay, and/or less ability to respond to
   network conditions.  Congestion control is particularly important for
   any multicast session where all or part of the multicast distribution
   tree spans an access network (e.g., a home gateway).  Two styles of
   congestion control have been defined in the RFC Series:

   o  Feedback-based congestion control, in which the sender receives
      multicast or unicast UDP messages from the receivers allowing it
      to assess the level of congestion and then adjust the sender
      rate(s) (e.g., [<a href="rfc5740.html" title='"NACK-Oriented Reliable Multicast (NORM) Transport Protocol"'>RFC5740</a>],[<a href="rfc4654.html" title='"TCP-Friendly Multicast Congestion Control (TFMCC): Protocol Specification"'>RFC4654</a>]).  Multicast methods may
      operate on longer timescales than for unicast (e.g., due to the
      higher group RTT of a heterogeneous group).  A control method
      could decide not to reduce the rate of the entire multicast group
      in response to a control message received from a single receiver
      (e.g., a sender could set a minimum rate and decide to request a
      congested receiver to leave the multicast group and could also
      decide to distribute content to these congested receivers at a
      lower rate using unicast congestion control).

   o  Receiver-driven congestion control, which does not require a
      receiver to send explicit UDP control messages for congestion
      control (e.g., [<a href="rfc3738.html" title='"Wave and Equation Based Rate Control (WEBRC) Building Block"'>RFC3738</a>], [<a href="rfc5775.html" title='"Asynchronous Layered Coding (ALC) Protocol Instantiation"'>RFC5775</a>]).  Instead, the sender
      distributes the data across multiple IP multicast groups (e.g.,
      using a set of {S,G} channels).  Each receiver determines its own
      level of congestion and controls its reception rate using only
      multicast join/leave messages sent in the network control plane.
      This method scales to arbitrary large groups of receivers.



<span class="grey">Eggert, et al.            Best Current Practice                [Page 30]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-31" id="page-31" name="page-31"> </a>
<span class="grey"><a href="rfc8085.html">RFC 8085</a>                  UDP Usage Guidelines                March 2017</span>


   Any multicast-enabled receiver may attempt to join and receive
   traffic from any group.  This may imply the need for rate limits on
   individual receivers or the aggregate multicast service.  Note, at
   the transport layer, there is no way to prevent a join message
   propagating to the next-hop router.

   Some classes of multicast applications support applications that can
   monitor the user-level quality of the transfer at the receiver.
   Applications that can detect a significant reduction in user quality
   SHOULD regard this as a congestion signal (e.g., to leave a group
   using layered multicast encoding); if not, they SHOULD use this
   signal to provide a circuit breaker to terminate the flow by leaving
   the multicast group.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/4.1.1.%20%20Bulk-Transfer%20Multicast%20Applications"></a><a class="selflink" href="#section-4.1.1" name="section-4.1.1">4.1.1</a>.  Bulk-Transfer Multicast Applications</span>

   Applications that perform bulk transmission of data over a multicast
   distribution tree, i.e., applications that exchange more than a few
   UDP datagrams per RTT, SHOULD implement a method for congestion
   control.  The currently RECOMMENDED IETF methods are as follows:
   Asynchronous Layered Coding (ALC) [<a href="rfc5775.html" title='"Asynchronous Layered Coding (ALC) Protocol Instantiation"'>RFC5775</a>], TCP-Friendly Multicast
   Congestion Control (TFMCC) [<a href="rfc4654.html" title='"TCP-Friendly Multicast Congestion Control (TFMCC): Protocol Specification"'>RFC4654</a>], Wave and Equation Based Rate
   Control (WEBRC) [<a href="rfc3738.html" title='"Wave and Equation Based Rate Control (WEBRC) Building Block"'>RFC3738</a>], NACK-Oriented Reliable Multicast (NORM)
   transport protocol [<a href="rfc5740.html" title='"NACK-Oriented Reliable Multicast (NORM) Transport Protocol"'>RFC5740</a>], File Delivery over Unidirectional
   Transport (FLUTE) [<a href="rfc6726.html" title='"FLUTE - File Delivery over Unidirectional Transport"'>RFC6726</a>], Real Time Protocol/Control Protocol
   (RTP/RTCP) [<a href="rfc3550.html" title='"RTP: A Transport Protocol for Real-Time Applications"'>RFC3550</a>].

   An application can alternatively implement another congestion control
   scheme following the guidelines of [<a href="rfc2887.html" title='"The Reliable Multicast Design Space for Bulk Data Transfer"'>RFC2887</a>] and utilizing the
   framework of [<a href="rfc3048.html" title='"Reliable Multicast Transport Building Blocks for One-to-Many Bulk-Data Transfer"'>RFC3048</a>].  Bulk-transfer applications that choose not
   to implement [<a href="rfc4654.html" title='"TCP-Friendly Multicast Congestion Control (TFMCC): Protocol Specification"'>RFC4654</a>], [<a href="rfc5775.html" title='"Asynchronous Layered Coding (ALC) Protocol Instantiation"'>RFC5775</a>], [<a href="rfc3738.html" title='"Wave and Equation Based Rate Control (WEBRC) Building Block"'>RFC3738</a>], [<a href="rfc5740.html" title='"NACK-Oriented Reliable Multicast (NORM) Transport Protocol"'>RFC5740</a>], [<a href="rfc6726.html" title='"FLUTE - File Delivery over Unidirectional Transport"'>RFC6726</a>],
   or [<a href="rfc3550.html" title='"RTP: A Transport Protocol for Real-Time Applications"'>RFC3550</a>] SHOULD implement a congestion control scheme that
   results in bandwidth use that competes fairly with TCP within an
   order of magnitude.

   <a href="rfc3551.html#section-2">Section 2 of [RFC3551]</a> states that multimedia applications SHOULD
   monitor the packet-loss rate to ensure that it is within acceptable
   parameters.  Packet loss is considered acceptable if a TCP flow
   across the same network path under the same network conditions would
   achieve an average throughput, measured on a reasonable timescale,
   that is not less than that of the UDP flow.  The comparison to TCP
   cannot be specified exactly, but is intended as an "order-of-
   magnitude" comparison in timescale and throughput.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/4.1.2.%20%20Low%20Data-Volume%20Multicast%20Applications"></a><a class="selflink" href="#section-4.1.2" name="section-4.1.2">4.1.2</a>.  Low Data-Volume Multicast Applications</span>

   All the recommendations in <a href="#section-3.1.3">Section 3.1.3</a> are also applicable to low
   data-volume multicast applications.



<span class="grey">Eggert, et al.            Best Current Practice                [Page 31]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-32" id="page-32" name="page-32"> </a>
<span class="grey"><a href="rfc8085.html">RFC 8085</a>                  UDP Usage Guidelines                March 2017</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.2.%20%20Message%20Size%20Guidelines%20for%20Multicast"></a><a class="selflink" href="#section-4.2" name="section-4.2">4.2</a>.  Message Size Guidelines for Multicast</span>

   A multicast application SHOULD NOT send UDP datagrams that result in
   IP packets that exceed the effective MTU as described in <a href="rfc6807.html#section-3">Section 3 of
   [RFC6807]</a>.  Consequently, an application SHOULD either use the
   effective MTU information provided by the "Population Count
   Extensions to Protocol Independent Multicast (PIM)" [<a href="rfc6807.html" title='"Population Count Extensions to Protocol Independent Multicast (PIM)"'>RFC6807</a>] or
   implement path MTU discovery itself (see <a href="#section-3.2">Section 3.2</a>) to determine
   whether the path to each destination will support its desired message
   size without fragmentation.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/5.%20%20Programming%20Guidelines"></a><a class="selflink" href="#section-5" name="section-5">5</a>.  Programming Guidelines</span>

   The de facto standard application programming interface (API) for
   TCP/IP applications is the "sockets" interface [<a href="#ref-POSIX" title='"Standard for Information Technology - Portable Operating System Interface (POSIX)"'>POSIX</a>].  Some
   platforms also offer applications the ability to directly assemble
   and transmit IP packets through "raw sockets" or similar facilities.
   This is a second, more cumbersome method of using UDP.  The
   guidelines in this document cover all such methods through which an
   application may use UDP.  Because the sockets API is by far the most
   common method, the remainder of this section discusses it in more
   detail.

   Although the sockets API was developed for UNIX in the early 1980s, a
   wide variety of non-UNIX operating systems also implement it.  The
   sockets API supports both IPv4 and IPv6 [<a href="rfc3493.html" title='"Basic Socket Interface Extensions for IPv6"'>RFC3493</a>].  The UDP sockets
   API differs from that for TCP in several key ways.  Because
   application programmers are typically more familiar with the TCP
   sockets API, this section discusses these differences.  [<a href="#ref-STEVENS" title='"UNIX Network Programming, The sockets Networking API"'>STEVENS</a>]
   provides usage examples of the UDP sockets API.

   UDP datagrams may be directly sent and received, without any
   connection setup.  Using the sockets API, applications can receive
   packets from more than one IP source address on a single UDP socket.
   Some servers use this to exchange data with more than one remote host
   through a single UDP socket at the same time.  Many applications need
   to ensure that they receive packets from a particular source address;
   these applications MUST implement corresponding checks at the
   application layer or explicitly request that the operating system
   filter the received packets.

   Many operating systems also allow a UDP socket to be connected, i.e.,
   to bind a UDP socket to a specific pair of addresses and ports.  This
   is similar to the corresponding TCP sockets API functionality.
   However, for UDP, this is only a local operation that serves to
   simplify the local send/receive functions and to filter the traffic
   for the specified addresses and ports.  Binding a UDP socket does not
   establish a connection -- UDP does not notify the remote end when a



<span class="grey">Eggert, et al.            Best Current Practice                [Page 32]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-33" id="page-33" name="page-33"> </a>
<span class="grey"><a href="rfc8085.html">RFC 8085</a>                  UDP Usage Guidelines                March 2017</span>


   local UDP socket is bound.  Binding a socket also allows configuring
   options that affect the UDP or IP layers, for example, use of the UDP
   checksum or the IP Timestamp option.  On some stacks, a bound socket
   also allows an application to be notified when ICMP error messages
   are received for its transmissions [<a href="rfc1122.html" title='"Requirements for Internet Hosts - Communication Layers"'>RFC1122</a>].

   If a client/server application executes on a host with more than one
   IP interface, the application SHOULD send any UDP responses with an
   IP source address that matches the IP destination address of the UDP
   datagram that carried the request (see <a href="rfc1122.html#section-4.1.3.5">[RFC1122], Section 4.1.3.5</a>).
   Many middleboxes expect this transmission behavior and drop replies
   that are sent from a different IP address, as explained in
   <a href="#section-3.5">Section 3.5</a>.

   A UDP receiver can receive a valid UDP datagram with a zero-length
   payload.  Note that this is different from a return value of zero
   from a read() socket call, which for TCP indicates the end of the
   connection.

   UDP provides no flow-control, i.e., the sender at any given time does
   not know whether the receiver is able to handle incoming
   transmissions.  This is another reason why UDP-based applications
   need to be robust in the presence of packet loss.  This loss can also
   occur within the sending host, when an application sends data faster
   than the line rate of the outbound network interface.  It can also
   occur at the destination, where receive calls fail to return all the
   data that was sent when the application issues them too infrequently
   (i.e., such that the receive buffer overflows).  Robust flow control
   mechanisms are difficult to implement, which is why applications that
   need this functionality SHOULD consider using a full-featured
   transport protocol such as TCP.

   When an application closes a TCP, SCTP, or DCCP socket, the transport
   protocol on the receiving host is required to maintain TIME-WAIT
   state.  This prevents delayed packets from the closed connection
   instance from being mistakenly associated with a later connection
   instance that happens to reuse the same IP address and port pairs.
   The UDP protocol does not implement such a mechanism.  Therefore,
   UDP-based applications need to be robust to reordering and delay.
   One application may close a socket or terminate, followed in time by
   another application receiving on the same port.  This later
   application may then receive packets intended for the first
   application that were delayed in the network.








<span class="grey">Eggert, et al.            Best Current Practice                [Page 33]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-34" id="page-34" name="page-34"> </a>
<span class="grey"><a href="rfc8085.html">RFC 8085</a>                  UDP Usage Guidelines                March 2017</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.1.%20%20Using%20UDP%20Ports"></a><a class="selflink" href="#section-5.1" name="section-5.1">5.1</a>.  Using UDP Ports</span>

   The rules and procedures for the management of the "Service Name and
   Transport Protocol Port Number Registry" are specified in [<a href="rfc6335.html" title='"Internet Assigned Numbers Authority (IANA) Procedures for the Management of the Service Name and Transport Protocol Port Number Registry"'>RFC6335</a>].
   Recommendations for use of UDP ports are provided in [<a href="rfc7605.html" title='"Recommendations on Using Assigned Transport Port Numbers"'>RFC7605</a>].

   A UDP sender SHOULD NOT use a source port value of zero.  A source
   port number that cannot be easily determined from the address or
   payload type provides protection at the receiver from data injection
   attacks by off-path devices.  A UDP receiver SHOULD NOT bind to port
   zero.

   Applications SHOULD implement receiver port and address checks at the
   application layer or explicitly request that the operating system
   filter the received packets to prevent receiving packets with an
   arbitrary port.  This measure is designed to provide additional
   protection from data injection attacks from an off-path source (where
   the port values may not be known).

   Applications SHOULD provide a check that protects from off-path data
   injection, avoiding an application receiving packets that were
   created by an unauthorized third party.  TCP stacks commonly use a
   randomized source port to provide this protection [<a href="rfc6056.html" title='"Recommendations for Transport- Protocol Port Randomization"'>RFC6056</a>]; UDP
   applications should follow the same technique.  Middleboxes and end
   systems often make assumptions about the system ports or user ports;
   hence, it is recommended to use randomized ports in the Dynamic and/
   or Private Port range.  Setting a "randomized" source port also
   provides greater assurance that reported ICMP errors originate from
   network systems on the path used by a particular flow.  Some UDP
   applications choose to use a predetermined value for the source port
   (including some multicast applications), these applications need to
   therefore employ a different technique.  Protection from off-path
   data attacks can also be provided by randomizing the initial value of
   another protocol field within the datagram payload, and checking the
   validity of this field at the receiver (e.g., RTP has random initial
   sequence number and random media timestamp offsets [<a href="rfc3550.html" title='"RTP: A Transport Protocol for Real-Time Applications"'>RFC3550</a>]).

   When using multicast, IP routers perform a reverse-path forwarding
   (RPF) check for each multicast packet.  This provides protection from
   off-path data injection, restricting opportunities to forge a
   packet's source address.  When a receiver joins a multicast group and
   filters based on the source address the filter verifies the sender's
   IP address.  This is always the case when using an SSM {S,G} channel.








<span class="grey">Eggert, et al.            Best Current Practice                [Page 34]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-35" id="page-35" name="page-35"> </a>
<span class="grey"><a href="rfc8085.html">RFC 8085</a>                  UDP Usage Guidelines                March 2017</span>


<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/5.1.1.%20%20Usage%20of%20UDP%20for%20Source%20Port%20Entropy%20and%20the%20IPv6%20Flow%20Label"></a><a class="selflink" href="#section-5.1.1" name="section-5.1.1">5.1.1</a>.  Usage of UDP for Source Port Entropy and the IPv6 Flow Label</span>

   Some applications use the UDP datagram header as a source of entropy
   for network devices that implement ECMP [<a href="rfc6438.html" title='"Using the IPv6 Flow Label for Equal Cost Multipath Routing and Link Aggregation in Tunnels"'>RFC6438</a>].  A UDP tunnel
   application targeting this usage encapsulates an inner packet using
   UDP, where the UDP source port value forms a part of the entropy that
   can be used to balance forwarding of network traffic by the devices
   that use ECMP.  A sending tunnel endpoint selects a source port value
   in the UDP datagram header that is computed from the inner flow
   information (e.g., the encapsulated packet headers).  To provide
   sufficient entropy, the sending tunnel endpoint maps the encapsulated
   traffic to one of a range of UDP source values.  The value SHOULD be
   within the ephemeral port range, i.e., 49152 to 65535, where the high
   order two bits of the port are set to one.  The available source port
   entropy of 14 bits (using the ephemeral port range) plus the outer IP
   addresses seems sufficient for entropy for most ECMP applications
   [<a href="#ref-ENCAP" title='"Encapsulation Considerations"'>ENCAP</a>].

   To avoid reordering within an IP flow, the same UDP source port value
   SHOULD be used for all packets assigned to an encapsulated flow
   (e.g., using a hash of the relevant headers).  The entropy mapping
   for a flow MAY change over the lifetime of the encapsulated flow
   [<a href="#ref-ENCAP" title='"Encapsulation Considerations"'>ENCAP</a>].  For instance, this could be changed as a Denial of Service
   (DOS) mitigation, or as a means to effect routing through the ECMP
   network.  However, the source port selected for a flow SHOULD NOT
   change more than once in every thirty seconds (e.g., as in
   [<a href="rfc8086.html" title='"GRE- in-UDP Encapsulation"'>RFC8086</a>]).

   The use of the source port field for entropy has several side effects
   that need to be considered, including:

   o  It can increase the probability of misdelivery of corrupted
      packets, which increases the need for checksum computation or an
      equivalent mechanism to protect other UDP applications from
      misdelivery errors <a href="#section-3.4">Section 3.4</a>.

   o  It is expected to reduce the probability of successful middlebox
      traversal <a href="#section-3.5">Section 3.5</a>.  This use of the source port field will
      often not be suitable for applications targeting deployment in the
      general Internet.

   o  It can prevent the field being usable to protect from off-path
      attacks (described in <a href="#section-5.1">Section 5.1</a>).  Designers therefore need to
      consider other mechanisms to provide equivalent protection (e.g.,
      to restrict use to a controlled environment <a href="rfc7510.html#section-3.6">[RFC7510]
      Section 3.6</a>).





<span class="grey">Eggert, et al.            Best Current Practice                [Page 35]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-36" id="page-36" name="page-36"> </a>
<span class="grey"><a href="rfc8085.html">RFC 8085</a>                  UDP Usage Guidelines                March 2017</span>


   The UDP source port number field has also been leveraged to produce
   entropy with IPv6.  However, in the case of IPv6, the "flow label"
   [<a href="rfc6437.html" title='"IPv6 Flow Label Specification"'>RFC6437</a>] may also alternatively be used to provide entropy for load
   balancing [<a href="rfc6438.html" title='"Using the IPv6 Flow Label for Equal Cost Multipath Routing and Link Aggregation in Tunnels"'>RFC6438</a>].  This use of the flow label for load balancing
   is consistent with the definition of the field, although further
   clarity was needed to ensure the field can be consistently used for
   this purpose.  Therefore, an updated IPv6 flow label [<a href="rfc6437.html" title='"IPv6 Flow Label Specification"'>RFC6437</a>] and
   ECMP routing [<a href="rfc6438.html" title='"Using the IPv6 Flow Label for Equal Cost Multipath Routing and Link Aggregation in Tunnels"'>RFC6438</a>] usage was specified.

   To ensure future opportunities to use the flow label, UDP
   applications SHOULD set the flow label field, even when an entropy
   value is also set in the source port field (e.g., An IPv6 tunnel
   endpoint could copy the source port flow entropy value to the IPv6
   flow label field [<a href="rfc8086.html" title='"GRE- in-UDP Encapsulation"'>RFC8086</a>]).  Router vendors are encouraged to start
   using the IPv6 flow label as a part of the flow hash, providing
   support for IP-level ECMP without requiring use of UDP.  The end-to-
   end use of flow labels for load balancing is a long-term solution.
   Even if the usage of the flow label has been clarified, there will be
   a transition time before a significant proportion of endpoints start
   to assign a good quality flow label to the flows that they originate.
   The use of load balancing using the transport header fields will
   likely continue until widespread deployment is finally achieved.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/5.1.2.%20%20Applications%20Using%20Multiple%20UDP%20Ports"></a><a class="selflink" href="#section-5.1.2" name="section-5.1.2">5.1.2</a>.  Applications Using Multiple UDP Ports</span>

   A single application may exchange several types of data.  In some
   cases, this may require multiple UDP flows (e.g., multiple sets of
   flows, identified by different five-tuples).  [<a href="rfc6335.html" title='"Internet Assigned Numbers Authority (IANA) Procedures for the Management of the Service Name and Transport Protocol Port Number Registry"'>RFC6335</a>] recommends
   application developers not to apply to IANA to be assigned multiple
   well-known ports (user or system).  It does not discuss the
   implications of using multiple flows with the same well-known port or
   pairs of dynamic ports (e.g., identified by a service name or
   signaling protocol).

   Use of multiple flows can affect the network in several ways:

   o  Starting a series of successive connections can increase the
      number of state bindings in middleboxes (e.g., NAPT or Firewall)
      along the network path.  UDP-based middlebox traversal usually
      relies on timeouts to remove old state, since middleboxes are
      unaware when a particular flow ceases to be used by an
      application.

   o  Using several flows at the same time may result in seeing
      different network characteristics for each flow.  It cannot be
      assumed both follow the same path (e.g., when ECMP is used,
      traffic is intentionally hashed onto different parallel paths
      based on the port numbers).



<span class="grey">Eggert, et al.            Best Current Practice                [Page 36]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-37" id="page-37" name="page-37"> </a>
<span class="grey"><a href="rfc8085.html">RFC 8085</a>                  UDP Usage Guidelines                March 2017</span>


   o  Using several flows can also increase the occupancy of a binding
      or lookup table in a middlebox (e.g., NAPT or Firewall), which may
      cause the device to change the way it manages the flow state.

   o  Further, using excessive numbers of flows can degrade the ability
      of a unicast congestion control to react to congestion events,
      unless the congestion state is shared between all flows in a
      session.  A receiver-driven multicast congestion control requires
      the sending application to distribute its data over a set of IP
      multicast groups, each receiver is therefore expected to receive
      data from a modest number of simultaneously active UDP ports.

   Therefore, applications MUST NOT assume consistent behavior of
   middleboxes when multiple UDP flows are used; many devices respond
   differently as the number of used ports increases.  Using multiple
   flows with different QoS requirements requires applications to verify
   that the expected performance is achieved using each individual flow
   (five-tuple), see <a href="#section-3.1.9">Section 3.1.9</a>.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.2.%20%20ICMP%20Guidelines"></a><a class="selflink" href="#section-5.2" name="section-5.2">5.2</a>.  ICMP Guidelines</span>

   Applications can utilize information about ICMP error messages that
   the UDP layer passes up for a variety of purposes [<a href="rfc1122.html" title='"Requirements for Internet Hosts - Communication Layers"'>RFC1122</a>].
   Applications SHOULD appropriately validate the payload of ICMP
   messages to ensure these are received in response to transmitted
   traffic (i.e., a reported error condition that corresponds to a UDP
   datagram actually sent by the application).  This requires context,
   such as local state about communication instances to each
   destination, that although readily available in connection-oriented
   transport protocols is not always maintained by UDP-based
   applications.  Note that not all platforms have the necessary APIs to
   support this validation, and some platforms already perform this
   validation internally before passing ICMP information to the
   application.

   Any application response to ICMP error messages SHOULD be robust to
   temporary routing failures (sometimes called "soft errors"), e.g.,
   transient ICMP "unreachable" messages ought to not normally cause a
   communication abort.

   ICMP messages are being increasingly filtered by middleboxes.  A UDP
   application therefore SHOULD NOT rely on their delivery for correct
   and safe operation.








<span class="grey">Eggert, et al.            Best Current Practice                [Page 37]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-38" id="page-38" name="page-38"> </a>
<span class="grey"><a href="rfc8085.html">RFC 8085</a>                  UDP Usage Guidelines                March 2017</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/6.%20%20Security%20Considerations"></a><a class="selflink" href="#section-6" name="section-6">6</a>.  Security Considerations</span>

   UDP does not provide communications security.  Applications that need
   to protect their communications against eavesdropping, tampering, or
   message forgery SHOULD employ end-to-end security services provided
   by other IETF protocols.

   UDP applications SHOULD provide protection from off-path data
   injection attacks using a randomized source port or equivalent
   technique (see <a href="#section-5.1">Section 5.1</a>).

   Applications that respond to short requests with potentially large
   responses are a potential vector for amplification attacks, and
   SHOULD take steps to minimize their potential for being abused as
   part of a DoS attack.  That could mean authenticating the sender
   before responding; noting that the source IP address of a request is
   not a useful authenticator, because it can easily be spoofed.  Or it
   may mean otherwise limiting the cases where short unauthenticated
   requests produce large responses.  Applications MAY also want to
   offer ways to limit the number of requests they respond to in a time
   interval, in order to cap the bandwidth they consume.

   One option for securing UDP communications is with IPsec [<a href="rfc4301.html" title='"Security Architecture for the Internet Protocol"'>RFC4301</a>],
   which can provide authentication for flows of IP packets through the
   Authentication Header (AH) [<a href="rfc4302.html" title='"IP Authentication Header"'>RFC4302</a>] and encryption and/or
   authentication through the Encapsulating Security Payload (ESP)
   [<a href="rfc4303.html" title='"IP Encapsulating Security Payload (ESP)"'>RFC4303</a>].  Applications use the Internet Key Exchange (IKE)
   [<a href="rfc7296.html" title='"Internet Key Exchange Protocol Version 2 (IKEv2)"'>RFC7296</a>] to configure IPsec for their sessions.  Depending on how
   IPsec is configured for a flow, it can authenticate or encrypt the
   UDP headers as well as UDP payloads.  If an application only requires
   authentication, ESP with no encryption but with authentication is
   often a better option than AH, because ESP can operate across
   middleboxes.  An application that uses IPsec requires the support of
   an operating system that implements the IPsec protocol suite, and the
   network path must permit IKE and IPsec traffic.  This may become more
   common with IPv6 deployments [<a href="rfc6092.html" title='"Recommended Simple Security Capabilities in Customer Premises Equipment (CPE) for Providing Residential IPv6 Internet Service"'>RFC6092</a>].

   Although it is possible to use IPsec to secure UDP communications,
   not all operating systems support IPsec or allow applications to
   easily configure it for their flows.  A second option for securing
   UDP communications is through Datagram Transport Layer Security
   (DTLS) [<a href="rfc6347.html" title='"Datagram Transport Layer Security Version 1.2"'>RFC6347</a>][RFC7525].  DTLS provides communication privacy by
   encrypting UDP payloads.  It does not protect the UDP headers.
   Applications can implement DTLS without relying on support from the
   operating system.






<span class="grey">Eggert, et al.            Best Current Practice                [Page 38]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-39" id="page-39" name="page-39"> </a>
<span class="grey"><a href="rfc8085.html">RFC 8085</a>                  UDP Usage Guidelines                March 2017</span>


   Many other options for authenticating or encrypting UDP payloads
   exist.  For example, the GSS-API security framework [<a href="rfc2743.html" title='"Generic Security Service Application Program Interface Version 2, Update 1"'>RFC2743</a>] or
   Cryptographic Message Syntax (CMS) [<a href="rfc5652.html" title='"Cryptographic Message Syntax (CMS)"'>RFC5652</a>] could be used to protect
   UDP payloads.  There exist a number of security options for RTP
   [<a href="rfc3550.html" title='"RTP: A Transport Protocol for Real-Time Applications"'>RFC3550</a>] over UDP, especially to accomplish key-management, see
   [<a href="rfc7201.html" title='"Options for Securing RTP Sessions"'>RFC7201</a>].  These options covers many usages, including point-to-
   point, centralized group communication as well as multicast.  In some
   applications, a better solution is to protect larger stand-alone
   objects, such as files or messages, instead of individual UDP
   payloads.  In these situations, CMS [<a href="rfc5652.html" title='"Cryptographic Message Syntax (CMS)"'>RFC5652</a>], S/MIME [<a href="rfc5751.html" title='"Secure/Multipurpose Internet Mail Extensions (S/MIME) Version 3.2 Message Specification"'>RFC5751</a>] or
   OpenPGP [<a href="rfc4880.html" title='"OpenPGP Message Format"'>RFC4880</a>] could be used.  In addition, there are many
   non-IETF protocols in this area.

   Like congestion control mechanisms, security mechanisms are difficult
   to design and implement correctly.  It is hence RECOMMENDED that
   applications employ well-known standard security mechanisms such as
   DTLS or IPsec, rather than inventing their own.

   The Generalized TTL Security Mechanism (GTSM) [<a href="rfc5082.html" title='"The Generalized TTL Security Mechanism (GTSM)"'>RFC5082</a>] may be used
   with UDP applications when the intended endpoint is on the same link
   as the sender.  This lightweight mechanism allows a receiver to
   filter unwanted packets.

   In terms of congestion control, [<a href="rfc2309.html" title='"Recommendations on Queue Management and Congestion Avoidance in the Internet"'>RFC2309</a>] and [<a href="rfc2914.html" title='"Congestion Control Principles"'>RFC2914</a>] discuss the
   dangers of congestion-unresponsive flows to the Internet.  [<a href="rfc8084.html" title='"Network Transport Circuit Breakers"'>RFC8084</a>]
   describes methods that can be used to set a performance envelope that
   can assist in preventing congestion collapse in the absence of
   congestion control or when the congestion control fails to react to
   congestion events.  This document provides guidelines to designers of
   UDP-based applications to congestion-control their transmissions, and
   does not raise any additional security concerns.

   Some network operators have experienced surges of UDP attack traffic
   that are multiple orders of magnitude above the baseline traffic rate
   for UDP.  This can motivate operators to limit the data rate or
   packet rate of UDP traffic.  This may in turn limit the throughput
   that an application can achieve using UDP and could also result in
   higher packet loss for UDP traffic that would not be experienced if
   other transport protocols had been used.

   A UDP application with a long-lived association between the sender
   and receiver, ought to be designed so that the sender periodically
   checks that the receiver still wants ("consents") to receive traffic
   and need to be designed to stop if there is no explicit confirmation
   of this [<a href="rfc7675.html" title='"Session Traversal Utilities for NAT (STUN) Usage for Consent Freshness"'>RFC7675</a>].  Applications that require communications in two
   directions to implement protocol functions (such as reliability or





<span class="grey">Eggert, et al.            Best Current Practice                [Page 39]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-40" id="page-40" name="page-40"> </a>
<span class="grey"><a href="rfc8085.html">RFC 8085</a>                  UDP Usage Guidelines                March 2017</span>


   congestion control) will need to independently check both directions
   of communication, and may have to exchange keep-alive messages to
   traverse middleboxes (see <a href="#section-3.5">Section 3.5</a>).

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/7.%20%20Summary"></a><a class="selflink" href="#section-7" name="section-7">7</a>.  Summary</span>

   This section summarizes the key guidelines made in Sections <a href="#section-3">3</a> - <a href="#section-6">6</a> in
   a tabular format (Table 1) for easy referencing.

   +---------------------------------------------------------+---------+
   | Recommendation                                          | Section |
   +---------------------------------------------------------+---------+
   | MUST tolerate a wide range of Internet path conditions  | 3       |
   | SHOULD use a full-featured transport (e.g., TCP)        |         |
   |                                                         |         |
   | SHOULD control rate of transmission                     | 3.1     |
   | SHOULD perform congestion control over all traffic      |         |
   |                                                         |         |
   | for bulk transfers,                                     | 3.1.2   |
   | SHOULD consider implementing TFRC                       |         |
   | else, SHOULD in other ways use bandwidth similar to TCP |         |
   |                                                         |         |
   | for non-bulk transfers,                                 | 3.1.3   |
   | SHOULD measure RTT and transmit max. 1 datagram/RTT     | 3.1.1   |
   | else, SHOULD send at most 1 datagram every 3 seconds    |         |
   | SHOULD back-off retransmission timers following loss    |         |
   |                                                         |         |
   | SHOULD provide mechanisms to regulate the bursts of     | 3.1.6   |
   | transmission                                            |         |
   |                                                         |         |
   | MAY implement ECN; a specific set of application        | 3.1.7   |
   | mechanisms are REQUIRED if ECN is used.                 |         |
   |                                                         |         |
   | for DiffServ, SHOULD NOT rely on implementation of PHBs | 3.1.8   |
   |                                                         |         |
   | for QoS-enabled paths, MAY choose not to use CC         | 3.1.9   |
   |                                                         |         |
   | SHOULD NOT rely solely on QoS for their capacity        | 3.1.10  |
   | non-CC controlled flows SHOULD implement a transport    |         |
   | circuit breaker                                         |         |
   | MAY implement a circuit breaker for other applications  |         |
   |                                                         |         |
   | for tunnels carrying IP traffic,                        | 3.1.11  |
   | SHOULD NOT perform congestion control                   |         |
   | MUST correctly process the IP ECN field                 |         |
   |                                                         |         |





<span class="grey">Eggert, et al.            Best Current Practice                [Page 40]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-41" id="page-41" name="page-41"> </a>
<span class="grey"><a href="rfc8085.html">RFC 8085</a>                  UDP Usage Guidelines                March 2017</span>


   | for non-IP tunnels or rate not determined by traffic,   |         |
   | SHOULD perform CC or use circuit breaker                | 3.1.11  |
   | SHOULD restrict types of traffic transported by the     |         |
   | tunnel                                                  |         |
   |                                                         |         |
   | SHOULD NOT send datagrams that exceed the PMTU, i.e.,   | 3.2     |
   | SHOULD discover PMTU or send datagrams &lt; minimum PMTU;  |         |
   | Specific application mechanisms are REQUIRED if PLPMTUD |         |
   | is used.                                                |         |
   |                                                         |         |
   | SHOULD handle datagram loss, duplication, reordering    | 3.3     |
   | SHOULD be robust to delivery delays up to 2 minutes     |         |
   |                                                         |         |
   | SHOULD enable IPv4 UDP checksum                         | 3.4     |
   | SHOULD enable IPv6 UDP checksum; Specific application   | 3.4.1   |
   | mechanisms are REQUIRED if a zero IPv6 UDP checksum is  |         |
   | used.                                                   |         |
   |                                                         |         |
   | SHOULD provide protection from off-path attacks         | 5.1     |
   | else, MAY use UDP-Lite with suitable checksum coverage  | 3.4.2   |
   |                                                         |         |
   | SHOULD NOT always send middlebox keep-alive messages    | 3.5     |
   | MAY use keep-alives when needed (min. interval 15 sec)  |         |
   |                                                         |         |
   | Applications specified for use in limited use (or       | 3.6     |
   | controlled environments) SHOULD identify equivalent     |         |
   | mechanisms and describe their use case.                 |         |
   |                                                         |         |
   | Bulk-multicast apps SHOULD implement congestion control | 4.1.1   |
   |                                                         |         |
   | Low volume multicast apps SHOULD implement congestion   | 4.1.2   |
   | control                                                 |         |
   |                                                         |         |
   | Multicast apps SHOULD use a safe PMTU                   | 4.2     |
   |                                                         |         |
   | SHOULD avoid using multiple ports                       | 5.1.2   |
   | MUST check received IP source address                   |         |
   |                                                         |         |
   | SHOULD validate payload in ICMP messages                | 5.2     |
   |                                                         |         |
   | SHOULD use a randomized source port or equivalent       | 6       |
   | technique, and, for client/server applications, SHOULD  |         |
   | send responses from source address matching request     |         |
   | 5.1                                                     |         |
   | SHOULD use standard IETF security protocols when needed | 6       |
   +---------------------------------------------------------+---------+

                    Table 1: Summary of Recommendations



<span class="grey">Eggert, et al.            Best Current Practice                [Page 41]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-42" id="page-42" name="page-42"> </a>
<span class="grey"><a href="rfc8085.html">RFC 8085</a>                  UDP Usage Guidelines                March 2017</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/8.%20%20References"></a><a class="selflink" href="#section-8" name="section-8">8</a>.  References</span>

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/8.1.%20%20Normative%20References"></a><a class="selflink" href="#section-8.1" name="section-8.1">8.1</a>.  Normative References</span>

   [<a id="ref-RFC768" name="ref-RFC768">RFC768</a>]   Postel, J., "User Datagram Protocol", STD 6, <a href="rfc768.html">RFC 768</a>,
              DOI 10.17487/RFC0768, August 1980,
              &lt;<a href="http://www.rfc-editor.org/info/rfc768">http://www.rfc-editor.org/info/rfc768</a>&gt;.

   [<a id="ref-RFC793" name="ref-RFC793">RFC793</a>]   Postel, J., "Transmission Control Protocol", STD 7,
              <a href="rfc793.html">RFC 793</a>, DOI 10.17487/RFC0793, September 1981,
              &lt;<a href="http://www.rfc-editor.org/info/rfc793">http://www.rfc-editor.org/info/rfc793</a>&gt;.

   [<a id="ref-RFC1122" name="ref-RFC1122">RFC1122</a>]  Braden, R., Ed., "Requirements for Internet Hosts -
              Communication Layers", STD 3, <a href="rfc1122.html">RFC 1122</a>,
              DOI 10.17487/RFC1122, October 1989,
              &lt;<a href="http://www.rfc-editor.org/info/rfc1122">http://www.rfc-editor.org/info/rfc1122</a>&gt;.

   [<a id="ref-RFC1191" name="ref-RFC1191">RFC1191</a>]  Mogul, J. and S. Deering, "Path MTU discovery", <a href="rfc1191.html">RFC 1191</a>,
              DOI 10.17487/RFC1191, November 1990,
              &lt;<a href="http://www.rfc-editor.org/info/rfc1191">http://www.rfc-editor.org/info/rfc1191</a>&gt;.

   [<a id="ref-RFC1981" name="ref-RFC1981">RFC1981</a>]  McCann, J., Deering, S., and J. Mogul, "Path MTU Discovery
              for IP version 6", <a href="rfc1981.html">RFC 1981</a>, DOI 10.17487/RFC1981, August
              1996, &lt;<a href="http://www.rfc-editor.org/info/rfc1981">http://www.rfc-editor.org/info/rfc1981</a>&gt;.

   [<a id="ref-RFC2119" name="ref-RFC2119">RFC2119</a>]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", <a href="https://tools.ietf.org/html/bcp14">BCP 14</a>, <a href="rfc2119.html">RFC 2119</a>,
              DOI 10.17487/RFC2119, March 1997,
              &lt;<a href="http://www.rfc-editor.org/info/rfc2119">http://www.rfc-editor.org/info/rfc2119</a>&gt;.

   [<a id="ref-RFC2460" name="ref-RFC2460">RFC2460</a>]  Deering, S. and R. Hinden, "Internet Protocol, Version 6
              (IPv6) Specification", <a href="rfc2460.html">RFC 2460</a>, DOI 10.17487/RFC2460,
              December 1998, &lt;<a href="http://www.rfc-editor.org/info/rfc2460">http://www.rfc-editor.org/info/rfc2460</a>&gt;.

   [<a id="ref-RFC2914" name="ref-RFC2914">RFC2914</a>]  Floyd, S., "Congestion Control Principles", <a href="https://tools.ietf.org/html/bcp41">BCP 41</a>,
              <a href="rfc2914.html">RFC 2914</a>, DOI 10.17487/RFC2914, September 2000,
              &lt;<a href="http://www.rfc-editor.org/info/rfc2914">http://www.rfc-editor.org/info/rfc2914</a>&gt;.

   [<a id="ref-RFC3828" name="ref-RFC3828">RFC3828</a>]  Larzon, L-A., Degermark, M., Pink, S., Jonsson, L-E., Ed.,
              and G. Fairhurst, Ed., "The Lightweight User Datagram
              Protocol (UDP-Lite)", <a href="rfc3828.html">RFC 3828</a>, DOI 10.17487/RFC3828, July
              2004, &lt;<a href="http://www.rfc-editor.org/info/rfc3828">http://www.rfc-editor.org/info/rfc3828</a>&gt;.

   [<a id="ref-RFC4787" name="ref-RFC4787">RFC4787</a>]  Audet, F., Ed. and C. Jennings, "Network Address
              Translation (NAT) Behavioral Requirements for Unicast
              UDP", <a href="https://tools.ietf.org/html/bcp127">BCP 127</a>, <a href="rfc4787.html">RFC 4787</a>, DOI 10.17487/RFC4787, January
              2007, &lt;<a href="http://www.rfc-editor.org/info/rfc4787">http://www.rfc-editor.org/info/rfc4787</a>&gt;.




<span class="grey">Eggert, et al.            Best Current Practice                [Page 42]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-43" id="page-43" name="page-43"> </a>
<span class="grey"><a href="rfc8085.html">RFC 8085</a>                  UDP Usage Guidelines                March 2017</span>


   [<a id="ref-RFC4821" name="ref-RFC4821">RFC4821</a>]  Mathis, M. and J. Heffner, "Packetization Layer Path MTU
              Discovery", <a href="rfc4821.html">RFC 4821</a>, DOI 10.17487/RFC4821, March 2007,
              &lt;<a href="http://www.rfc-editor.org/info/rfc4821">http://www.rfc-editor.org/info/rfc4821</a>&gt;.

   [<a id="ref-RFC5348" name="ref-RFC5348">RFC5348</a>]  Floyd, S., Handley, M., Padhye, J., and J. Widmer, "TCP
              Friendly Rate Control (TFRC): Protocol Specification",
              <a href="rfc5348.html">RFC 5348</a>, DOI 10.17487/RFC5348, September 2008,
              &lt;<a href="http://www.rfc-editor.org/info/rfc5348">http://www.rfc-editor.org/info/rfc5348</a>&gt;.

   [<a id="ref-RFC5405" name="ref-RFC5405">RFC5405</a>]  Eggert, L. and G. Fairhurst, "Unicast UDP Usage Guidelines
              for Application Designers", <a href="https://tools.ietf.org/html/bcp145">BCP 145</a>, <a href="rfc5405.html">RFC 5405</a>,
              DOI 10.17487/RFC5405, November 2008,
              &lt;<a href="http://www.rfc-editor.org/info/rfc5405">http://www.rfc-editor.org/info/rfc5405</a>&gt;.

   [<a id="ref-RFC6040" name="ref-RFC6040">RFC6040</a>]  Briscoe, B., "Tunnelling of Explicit Congestion
              Notification", <a href="rfc6040.html">RFC 6040</a>, DOI 10.17487/RFC6040, November
              2010, &lt;<a href="http://www.rfc-editor.org/info/rfc6040">http://www.rfc-editor.org/info/rfc6040</a>&gt;.

   [<a id="ref-RFC6298" name="ref-RFC6298">RFC6298</a>]  Paxson, V., Allman, M., Chu, J., and M. Sargent,
              "Computing TCP's Retransmission Timer", <a href="rfc6298.html">RFC 6298</a>,
              DOI 10.17487/RFC6298, June 2011,
              &lt;<a href="http://www.rfc-editor.org/info/rfc6298">http://www.rfc-editor.org/info/rfc6298</a>&gt;.

   [<a id="ref-RFC8084" name="ref-RFC8084">RFC8084</a>]  Fairhurst, G., "Network Transport Circuit Breakers",
              <a href="https://tools.ietf.org/html/bcp208">BCP 208</a>, <a href="rfc8084.html">RFC 8084</a>, DOI 10.17487/RFC8084, March 2017,
              &lt;<a href="http://www.rfc-editor.org/info/rfc8084">http://www.rfc-editor.org/info/rfc8084</a>&gt;.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/8.2.%20%20Informative%20References"></a><a class="selflink" href="#section-8.2" name="section-8.2">8.2</a>.  Informative References</span>

   [<a id="ref-ALLMAN" name="ref-ALLMAN">ALLMAN</a>]   Allman, M. and E. Blanton, "Notes on burst mitigation for
              transport protocols", March 2005.

   [<a id="ref-BEHAVE-APP" name="ref-BEHAVE-APP">BEHAVE-APP</a>]
              Ford, B., "Application Design Guidelines for Traversal
              through Network Address Translators", Work in Progress,
              <a href="https://tools.ietf.org/html/draft-ford-behave-app-05">draft-ford-behave-app-05</a>, March 2007.

   [<a id="ref-ENCAP" name="ref-ENCAP">ENCAP</a>]    Nordmark, E., Ed., Tian, A., Gross, J., Hudson, J.,
              Kreeger, L., Garg, P., Thaler, P., and T. Herbert,
              "Encapsulation Considerations", Work in Progress,
              <a href="https://tools.ietf.org/html/draft-ietf-rtgwg-dt-encap-02">draft-ietf-rtgwg-dt-encap-02</a>, October 2016.

   [<a id="ref-FABER" name="ref-FABER">FABER</a>]    Faber, T., Touch, J., and W. Yue, "The TIME-WAIT State in
              TCP and Its Effect on Busy Servers", Proc. IEEE Infocom,
              March 1999.






<span class="grey">Eggert, et al.            Best Current Practice                [Page 43]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-44" id="page-44" name="page-44"> </a>
<span class="grey"><a href="rfc8085.html">RFC 8085</a>                  UDP Usage Guidelines                March 2017</span>


   [<a id="ref-INT-TUNNELS" name="ref-INT-TUNNELS">INT-TUNNELS</a>]
              Touch, J. and W. Townsley, "IP Tunnels in the Internet
              Architecture", Work in Progress,
              <a href="https://tools.ietf.org/html/draft-ietf-intarea-tunnels-03">draft-ietf-intarea-tunnels-03</a>, July 2016.

   [<a id="ref-POSIX" name="ref-POSIX">POSIX</a>]    IEEE Std. 1003.1-2001, , "Standard for Information
              Technology - Portable Operating System Interface (POSIX)",
              Open Group Technical Standard: Base Specifications Issue
              6, ISO/IEC 9945:2002, December 2001.

   [<a id="ref-RFC919" name="ref-RFC919">RFC919</a>]   Mogul, J., "Broadcasting Internet Datagrams", STD 5,
              <a href="rfc919.html">RFC 919</a>, DOI 10.17487/RFC0919, October 1984,
              &lt;<a href="http://www.rfc-editor.org/info/rfc919">http://www.rfc-editor.org/info/rfc919</a>&gt;.

   [<a id="ref-RFC1112" name="ref-RFC1112">RFC1112</a>]  Deering, S., "Host extensions for IP multicasting", STD 5,
              <a href="rfc1112.html">RFC 1112</a>, DOI 10.17487/RFC1112, August 1989,
              &lt;<a href="http://www.rfc-editor.org/info/rfc1112">http://www.rfc-editor.org/info/rfc1112</a>&gt;.

   [<a id="ref-RFC1536" name="ref-RFC1536">RFC1536</a>]  Kumar, A., Postel, J., Neuman, C., Danzig, P., and S.
              Miller, "Common DNS Implementation Errors and Suggested
              Fixes", <a href="rfc1536.html">RFC 1536</a>, DOI 10.17487/RFC1536, October 1993,
              &lt;<a href="http://www.rfc-editor.org/info/rfc1536">http://www.rfc-editor.org/info/rfc1536</a>&gt;.

   [<a id="ref-RFC1546" name="ref-RFC1546">RFC1546</a>]  Partridge, C., Mendez, T., and W. Milliken, "Host
              Anycasting Service", <a href="rfc1546.html">RFC 1546</a>, DOI 10.17487/RFC1546,
              November 1993, &lt;<a href="http://www.rfc-editor.org/info/rfc1546">http://www.rfc-editor.org/info/rfc1546</a>&gt;.

   [<a id="ref-RFC2309" name="ref-RFC2309">RFC2309</a>]  Braden, B., Clark, D., Crowcroft, J., Davie, B., Deering,
              S., Estrin, D., Floyd, S., Jacobson, V., Minshall, G.,
              Partridge, C., Peterson, L., Ramakrishnan, K., Shenker,
              S., Wroclawski, J., and L. Zhang, "Recommendations on
              Queue Management and Congestion Avoidance in the
              Internet", <a href="rfc2309.html">RFC 2309</a>, DOI 10.17487/RFC2309, April 1998,
              &lt;<a href="http://www.rfc-editor.org/info/rfc2309">http://www.rfc-editor.org/info/rfc2309</a>&gt;.

   [<a id="ref-RFC2475" name="ref-RFC2475">RFC2475</a>]  Blake, S., Black, D., Carlson, M., Davies, E., Wang, Z.,
              and W. Weiss, "An Architecture for Differentiated
              Services", <a href="rfc2475.html">RFC 2475</a>, DOI 10.17487/RFC2475, December 1998,
              &lt;<a href="http://www.rfc-editor.org/info/rfc2475">http://www.rfc-editor.org/info/rfc2475</a>&gt;.

   [<a id="ref-RFC2675" name="ref-RFC2675">RFC2675</a>]  Borman, D., Deering, S., and R. Hinden, "IPv6 Jumbograms",
              <a href="rfc2675.html">RFC 2675</a>, DOI 10.17487/RFC2675, August 1999,
              &lt;<a href="http://www.rfc-editor.org/info/rfc2675">http://www.rfc-editor.org/info/rfc2675</a>&gt;.

   [<a id="ref-RFC2743" name="ref-RFC2743">RFC2743</a>]  Linn, J., "Generic Security Service Application Program
              Interface Version 2, Update 1", <a href="rfc2743.html">RFC 2743</a>,
              DOI 10.17487/RFC2743, January 2000,
              &lt;<a href="http://www.rfc-editor.org/info/rfc2743">http://www.rfc-editor.org/info/rfc2743</a>&gt;.



<span class="grey">Eggert, et al.            Best Current Practice                [Page 44]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-45" id="page-45" name="page-45"> </a>
<span class="grey"><a href="rfc8085.html">RFC 8085</a>                  UDP Usage Guidelines                March 2017</span>


   [<a id="ref-RFC2887" name="ref-RFC2887">RFC2887</a>]  Handley, M., Floyd, S., Whetten, B., Kermode, R.,
              Vicisano, L., and M. Luby, "The Reliable Multicast Design
              Space for Bulk Data Transfer", <a href="rfc2887.html">RFC 2887</a>,
              DOI 10.17487/RFC2887, August 2000,
              &lt;<a href="http://www.rfc-editor.org/info/rfc2887">http://www.rfc-editor.org/info/rfc2887</a>&gt;.

   [<a id="ref-RFC2983" name="ref-RFC2983">RFC2983</a>]  Black, D., "Differentiated Services and Tunnels",
              <a href="rfc2983.html">RFC 2983</a>, DOI 10.17487/RFC2983, October 2000,
              &lt;<a href="http://www.rfc-editor.org/info/rfc2983">http://www.rfc-editor.org/info/rfc2983</a>&gt;.

   [<a id="ref-RFC3048" name="ref-RFC3048">RFC3048</a>]  Whetten, B., Vicisano, L., Kermode, R., Handley, M.,
              Floyd, S., and M. Luby, "Reliable Multicast Transport
              Building Blocks for One-to-Many Bulk-Data Transfer",
              <a href="rfc3048.html">RFC 3048</a>, DOI 10.17487/RFC3048, January 2001,
              &lt;<a href="http://www.rfc-editor.org/info/rfc3048">http://www.rfc-editor.org/info/rfc3048</a>&gt;.

   [<a id="ref-RFC3124" name="ref-RFC3124">RFC3124</a>]  Balakrishnan, H. and S. Seshan, "The Congestion Manager",
              <a href="rfc3124.html">RFC 3124</a>, DOI 10.17487/RFC3124, June 2001,
              &lt;<a href="http://www.rfc-editor.org/info/rfc3124">http://www.rfc-editor.org/info/rfc3124</a>&gt;.

   [<a id="ref-RFC3168" name="ref-RFC3168">RFC3168</a>]  Ramakrishnan, K., Floyd, S., and D. Black, "The Addition
              of Explicit Congestion Notification (ECN) to IP",
              <a href="rfc3168.html">RFC 3168</a>, DOI 10.17487/RFC3168, September 2001,
              &lt;<a href="http://www.rfc-editor.org/info/rfc3168">http://www.rfc-editor.org/info/rfc3168</a>&gt;.

   [<a id="ref-RFC3261" name="ref-RFC3261">RFC3261</a>]  Rosenberg, J., Schulzrinne, H., Camarillo, G., Johnston,
              A., Peterson, J., Sparks, R., Handley, M., and E.
              Schooler, "SIP: Session Initiation Protocol", <a href="rfc3261.html">RFC 3261</a>,
              DOI 10.17487/RFC3261, June 2002,
              &lt;<a href="http://www.rfc-editor.org/info/rfc3261">http://www.rfc-editor.org/info/rfc3261</a>&gt;.

   [<a id="ref-RFC3303" name="ref-RFC3303">RFC3303</a>]  Srisuresh, P., Kuthan, J., Rosenberg, J., Molitor, A., and
              A. Rayhan, "Middlebox communication architecture and
              framework", <a href="rfc3303.html">RFC 3303</a>, DOI 10.17487/RFC3303, August 2002,
              &lt;<a href="http://www.rfc-editor.org/info/rfc3303">http://www.rfc-editor.org/info/rfc3303</a>&gt;.

   [<a id="ref-RFC3493" name="ref-RFC3493">RFC3493</a>]  Gilligan, R., Thomson, S., Bound, J., McCann, J., and W.
              Stevens, "Basic Socket Interface Extensions for IPv6",
              <a href="rfc3493.html">RFC 3493</a>, DOI 10.17487/RFC3493, February 2003,
              &lt;<a href="http://www.rfc-editor.org/info/rfc3493">http://www.rfc-editor.org/info/rfc3493</a>&gt;.

   [<a id="ref-RFC3550" name="ref-RFC3550">RFC3550</a>]  Schulzrinne, H., Casner, S., Frederick, R., and V.
              Jacobson, "RTP: A Transport Protocol for Real-Time
              Applications", STD 64, <a href="rfc3550.html">RFC 3550</a>, DOI 10.17487/RFC3550,
              July 2003, &lt;<a href="http://www.rfc-editor.org/info/rfc3550">http://www.rfc-editor.org/info/rfc3550</a>&gt;.






<span class="grey">Eggert, et al.            Best Current Practice                [Page 45]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-46" id="page-46" name="page-46"> </a>
<span class="grey"><a href="rfc8085.html">RFC 8085</a>                  UDP Usage Guidelines                March 2017</span>


   [<a id="ref-RFC3551" name="ref-RFC3551">RFC3551</a>]  Schulzrinne, H. and S. Casner, "RTP Profile for Audio and
              Video Conferences with Minimal Control", STD 65, <a href="rfc3551.html">RFC 3551</a>,
              DOI 10.17487/RFC3551, July 2003,
              &lt;<a href="http://www.rfc-editor.org/info/rfc3551">http://www.rfc-editor.org/info/rfc3551</a>&gt;.

   [<a id="ref-RFC3738" name="ref-RFC3738">RFC3738</a>]  Luby, M. and V. Goyal, "Wave and Equation Based Rate
              Control (WEBRC) Building Block", <a href="rfc3738.html">RFC 3738</a>,
              DOI 10.17487/RFC3738, April 2004,
              &lt;<a href="http://www.rfc-editor.org/info/rfc3738">http://www.rfc-editor.org/info/rfc3738</a>&gt;.

   [<a id="ref-RFC3758" name="ref-RFC3758">RFC3758</a>]  Stewart, R., Ramalho, M., Xie, Q., Tuexen, M., and P.
              Conrad, "Stream Control Transmission Protocol (SCTP)
              Partial Reliability Extension", <a href="rfc3758.html">RFC 3758</a>,
              DOI 10.17487/RFC3758, May 2004,
              &lt;<a href="http://www.rfc-editor.org/info/rfc3758">http://www.rfc-editor.org/info/rfc3758</a>&gt;.

   [<a id="ref-RFC3819" name="ref-RFC3819">RFC3819</a>]  Karn, P., Ed., Bormann, C., Fairhurst, G., Grossman, D.,
              Ludwig, R., Mahdavi, J., Montenegro, G., Touch, J., and L.
              Wood, "Advice for Internet Subnetwork Designers", <a href="https://tools.ietf.org/html/bcp89">BCP 89</a>,
              <a href="rfc3819.html">RFC 3819</a>, DOI 10.17487/RFC3819, July 2004,
              &lt;<a href="http://www.rfc-editor.org/info/rfc3819">http://www.rfc-editor.org/info/rfc3819</a>&gt;.

   [<a id="ref-RFC4301" name="ref-RFC4301">RFC4301</a>]  Kent, S. and K. Seo, "Security Architecture for the
              Internet Protocol", <a href="rfc4301.html">RFC 4301</a>, DOI 10.17487/RFC4301,
              December 2005, &lt;<a href="http://www.rfc-editor.org/info/rfc4301">http://www.rfc-editor.org/info/rfc4301</a>&gt;.

   [<a id="ref-RFC4302" name="ref-RFC4302">RFC4302</a>]  Kent, S., "IP Authentication Header", <a href="rfc4302.html">RFC 4302</a>,
              DOI 10.17487/RFC4302, December 2005,
              &lt;<a href="http://www.rfc-editor.org/info/rfc4302">http://www.rfc-editor.org/info/rfc4302</a>&gt;.

   [<a id="ref-RFC4303" name="ref-RFC4303">RFC4303</a>]  Kent, S., "IP Encapsulating Security Payload (ESP)",
              <a href="rfc4303.html">RFC 4303</a>, DOI 10.17487/RFC4303, December 2005,
              &lt;<a href="http://www.rfc-editor.org/info/rfc4303">http://www.rfc-editor.org/info/rfc4303</a>&gt;.

   [<a id="ref-RFC4340" name="ref-RFC4340">RFC4340</a>]  Kohler, E., Handley, M., and S. Floyd, "Datagram
              Congestion Control Protocol (DCCP)", <a href="rfc4340.html">RFC 4340</a>,
              DOI 10.17487/RFC4340, March 2006,
              &lt;<a href="http://www.rfc-editor.org/info/rfc4340">http://www.rfc-editor.org/info/rfc4340</a>&gt;.

   [<a id="ref-RFC4341" name="ref-RFC4341">RFC4341</a>]  Floyd, S. and E. Kohler, "Profile for Datagram Congestion
              Control Protocol (DCCP) Congestion Control ID 2: TCP-like
              Congestion Control", <a href="rfc4341.html">RFC 4341</a>, DOI 10.17487/RFC4341, March
              2006, &lt;<a href="http://www.rfc-editor.org/info/rfc4341">http://www.rfc-editor.org/info/rfc4341</a>&gt;.








<span class="grey">Eggert, et al.            Best Current Practice                [Page 46]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-47" id="page-47" name="page-47"> </a>
<span class="grey"><a href="rfc8085.html">RFC 8085</a>                  UDP Usage Guidelines                March 2017</span>


   [<a id="ref-RFC4342" name="ref-RFC4342">RFC4342</a>]  Floyd, S., Kohler, E., and J. Padhye, "Profile for
              Datagram Congestion Control Protocol (DCCP) Congestion
              Control ID 3: TCP-Friendly Rate Control (TFRC)", <a href="rfc4342.html">RFC 4342</a>,
              DOI 10.17487/RFC4342, March 2006,
              &lt;<a href="http://www.rfc-editor.org/info/rfc4342">http://www.rfc-editor.org/info/rfc4342</a>&gt;.

   [<a id="ref-RFC4380" name="ref-RFC4380">RFC4380</a>]  Huitema, C., "Teredo: Tunneling IPv6 over UDP through
              Network Address Translations (NATs)", <a href="rfc4380.html">RFC 4380</a>,
              DOI 10.17487/RFC4380, February 2006,
              &lt;<a href="http://www.rfc-editor.org/info/rfc4380">http://www.rfc-editor.org/info/rfc4380</a>&gt;.

   [<a id="ref-RFC4607" name="ref-RFC4607">RFC4607</a>]  Holbrook, H. and B. Cain, "Source-Specific Multicast for
              IP", <a href="rfc4607.html">RFC 4607</a>, DOI 10.17487/RFC4607, August 2006,
              &lt;<a href="http://www.rfc-editor.org/info/rfc4607">http://www.rfc-editor.org/info/rfc4607</a>&gt;.

   [<a id="ref-RFC4654" name="ref-RFC4654">RFC4654</a>]  Widmer, J. and M. Handley, "TCP-Friendly Multicast
              Congestion Control (TFMCC): Protocol Specification",
              <a href="rfc4654.html">RFC 4654</a>, DOI 10.17487/RFC4654, August 2006,
              &lt;<a href="http://www.rfc-editor.org/info/rfc4654">http://www.rfc-editor.org/info/rfc4654</a>&gt;.

   [<a id="ref-RFC4880" name="ref-RFC4880">RFC4880</a>]  Callas, J., Donnerhacke, L., Finney, H., Shaw, D., and R.
              Thayer, "OpenPGP Message Format", <a href="rfc4880.html">RFC 4880</a>,
              DOI 10.17487/RFC4880, November 2007,
              &lt;<a href="http://www.rfc-editor.org/info/rfc4880">http://www.rfc-editor.org/info/rfc4880</a>&gt;.

   [<a id="ref-RFC4890" name="ref-RFC4890">RFC4890</a>]  Davies, E. and J. Mohacsi, "Recommendations for Filtering
              ICMPv6 Messages in Firewalls", <a href="rfc4890.html">RFC 4890</a>,
              DOI 10.17487/RFC4890, May 2007,
              &lt;<a href="http://www.rfc-editor.org/info/rfc4890">http://www.rfc-editor.org/info/rfc4890</a>&gt;.

   [<a id="ref-RFC4960" name="ref-RFC4960">RFC4960</a>]  Stewart, R., Ed., "Stream Control Transmission Protocol",
              <a href="rfc4960.html">RFC 4960</a>, DOI 10.17487/RFC4960, September 2007,
              &lt;<a href="http://www.rfc-editor.org/info/rfc4960">http://www.rfc-editor.org/info/rfc4960</a>&gt;.

   [<a id="ref-RFC4963" name="ref-RFC4963">RFC4963</a>]  Heffner, J., Mathis, M., and B. Chandler, "IPv4 Reassembly
              Errors at High Data Rates", <a href="rfc4963.html">RFC 4963</a>,
              DOI 10.17487/RFC4963, July 2007,
              &lt;<a href="http://www.rfc-editor.org/info/rfc4963">http://www.rfc-editor.org/info/rfc4963</a>&gt;.

   [<a id="ref-RFC4987" name="ref-RFC4987">RFC4987</a>]  Eddy, W., "TCP SYN Flooding Attacks and Common
              Mitigations", <a href="rfc4987.html">RFC 4987</a>, DOI 10.17487/RFC4987, August 2007,
              &lt;<a href="http://www.rfc-editor.org/info/rfc4987">http://www.rfc-editor.org/info/rfc4987</a>&gt;.

   [<a id="ref-RFC5082" name="ref-RFC5082">RFC5082</a>]  Gill, V., Heasley, J., Meyer, D., Savola, P., Ed., and C.
              Pignataro, "The Generalized TTL Security Mechanism
              (GTSM)", <a href="rfc5082.html">RFC 5082</a>, DOI 10.17487/RFC5082, October 2007,
              &lt;<a href="http://www.rfc-editor.org/info/rfc5082">http://www.rfc-editor.org/info/rfc5082</a>&gt;.




<span class="grey">Eggert, et al.            Best Current Practice                [Page 47]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-48" id="page-48" name="page-48"> </a>
<span class="grey"><a href="rfc8085.html">RFC 8085</a>                  UDP Usage Guidelines                March 2017</span>


   [<a id="ref-RFC5245" name="ref-RFC5245">RFC5245</a>]  Rosenberg, J., "Interactive Connectivity Establishment
              (ICE): A Protocol for Network Address Translator (NAT)
              Traversal for Offer/Answer Protocols", <a href="rfc5245.html">RFC 5245</a>,
              DOI 10.17487/RFC5245, April 2010,
              &lt;<a href="http://www.rfc-editor.org/info/rfc5245">http://www.rfc-editor.org/info/rfc5245</a>&gt;.

   [<a id="ref-RFC5622" name="ref-RFC5622">RFC5622</a>]  Floyd, S. and E. Kohler, "Profile for Datagram Congestion
              Control Protocol (DCCP) Congestion ID 4: TCP-Friendly Rate
              Control for Small Packets (TFRC-SP)", <a href="rfc5622.html">RFC 5622</a>,
              DOI 10.17487/RFC5622, August 2009,
              &lt;<a href="http://www.rfc-editor.org/info/rfc5622">http://www.rfc-editor.org/info/rfc5622</a>&gt;.

   [<a id="ref-RFC5652" name="ref-RFC5652">RFC5652</a>]  Housley, R., "Cryptographic Message Syntax (CMS)", STD 70,
              <a href="rfc5652.html">RFC 5652</a>, DOI 10.17487/RFC5652, September 2009,
              &lt;<a href="http://www.rfc-editor.org/info/rfc5652">http://www.rfc-editor.org/info/rfc5652</a>&gt;.

   [<a id="ref-RFC5681" name="ref-RFC5681">RFC5681</a>]  Allman, M., Paxson, V., and E. Blanton, "TCP Congestion
              Control", <a href="rfc5681.html">RFC 5681</a>, DOI 10.17487/RFC5681, September 2009,
              &lt;<a href="http://www.rfc-editor.org/info/rfc5681">http://www.rfc-editor.org/info/rfc5681</a>&gt;.

   [<a id="ref-RFC5740" name="ref-RFC5740">RFC5740</a>]  Adamson, B., Bormann, C., Handley, M., and J. Macker,
              "NACK-Oriented Reliable Multicast (NORM) Transport
              Protocol", <a href="rfc5740.html">RFC 5740</a>, DOI 10.17487/RFC5740, November 2009,
              &lt;<a href="http://www.rfc-editor.org/info/rfc5740">http://www.rfc-editor.org/info/rfc5740</a>&gt;.

   [<a id="ref-RFC5751" name="ref-RFC5751">RFC5751</a>]  Ramsdell, B. and S. Turner, "Secure/Multipurpose Internet
              Mail Extensions (S/MIME) Version 3.2 Message
              Specification", <a href="rfc5751.html">RFC 5751</a>, DOI 10.17487/RFC5751, January
              2010, &lt;<a href="http://www.rfc-editor.org/info/rfc5751">http://www.rfc-editor.org/info/rfc5751</a>&gt;.

   [<a id="ref-RFC5775" name="ref-RFC5775">RFC5775</a>]  Luby, M., Watson, M., and L. Vicisano, "Asynchronous
              Layered Coding (ALC) Protocol Instantiation", <a href="rfc5775.html">RFC 5775</a>,
              DOI 10.17487/RFC5775, April 2010,
              &lt;<a href="http://www.rfc-editor.org/info/rfc5775">http://www.rfc-editor.org/info/rfc5775</a>&gt;.

   [<a id="ref-RFC5971" name="ref-RFC5971">RFC5971</a>]  Schulzrinne, H. and R. Hancock, "GIST: General Internet
              Signalling Transport", <a href="rfc5971.html">RFC 5971</a>, DOI 10.17487/RFC5971,
              October 2010, &lt;<a href="http://www.rfc-editor.org/info/rfc5971">http://www.rfc-editor.org/info/rfc5971</a>&gt;.

   [<a id="ref-RFC5973" name="ref-RFC5973">RFC5973</a>]  Stiemerling, M., Tschofenig, H., Aoun, C., and E. Davies,
              "NAT/Firewall NSIS Signaling Layer Protocol (NSLP)",
              <a href="rfc5973.html">RFC 5973</a>, DOI 10.17487/RFC5973, October 2010,
              &lt;<a href="http://www.rfc-editor.org/info/rfc5973">http://www.rfc-editor.org/info/rfc5973</a>&gt;.

   [<a id="ref-RFC6056" name="ref-RFC6056">RFC6056</a>]  Larsen, M. and F. Gont, "Recommendations for Transport-
              Protocol Port Randomization", <a href="https://tools.ietf.org/html/bcp156">BCP 156</a>, <a href="rfc6056.html">RFC 6056</a>,
              DOI 10.17487/RFC6056, January 2011,
              &lt;<a href="http://www.rfc-editor.org/info/rfc6056">http://www.rfc-editor.org/info/rfc6056</a>&gt;.



<span class="grey">Eggert, et al.            Best Current Practice                [Page 48]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-49" id="page-49" name="page-49"> </a>
<span class="grey"><a href="rfc8085.html">RFC 8085</a>                  UDP Usage Guidelines                March 2017</span>


   [<a id="ref-RFC6092" name="ref-RFC6092">RFC6092</a>]  Woodyatt, J., Ed., "Recommended Simple Security
              Capabilities in Customer Premises Equipment (CPE) for
              Providing Residential IPv6 Internet Service", <a href="rfc6092.html">RFC 6092</a>,
              DOI 10.17487/RFC6092, January 2011,
              &lt;<a href="http://www.rfc-editor.org/info/rfc6092">http://www.rfc-editor.org/info/rfc6092</a>&gt;.

   [<a id="ref-RFC6335" name="ref-RFC6335">RFC6335</a>]  Cotton, M., Eggert, L., Touch, J., Westerlund, M., and S.
              Cheshire, "Internet Assigned Numbers Authority (IANA)
              Procedures for the Management of the Service Name and
              Transport Protocol Port Number Registry", <a href="https://tools.ietf.org/html/bcp165">BCP 165</a>,
              <a href="rfc6335.html">RFC 6335</a>, DOI 10.17487/RFC6335, August 2011,
              &lt;<a href="http://www.rfc-editor.org/info/rfc6335">http://www.rfc-editor.org/info/rfc6335</a>&gt;.

   [<a id="ref-RFC6347" name="ref-RFC6347">RFC6347</a>]  Rescorla, E. and N. Modadugu, "Datagram Transport Layer
              Security Version 1.2", <a href="rfc6347.html">RFC 6347</a>, DOI 10.17487/RFC6347,
              January 2012, &lt;<a href="http://www.rfc-editor.org/info/rfc6347">http://www.rfc-editor.org/info/rfc6347</a>&gt;.

   [<a id="ref-RFC6396" name="ref-RFC6396">RFC6396</a>]  Blunk, L., Karir, M., and C. Labovitz, "Multi-Threaded
              Routing Toolkit (MRT) Routing Information Export Format",
              <a href="rfc6396.html">RFC 6396</a>, DOI 10.17487/RFC6396, October 2011,
              &lt;<a href="http://www.rfc-editor.org/info/rfc6396">http://www.rfc-editor.org/info/rfc6396</a>&gt;.

   [<a id="ref-RFC6437" name="ref-RFC6437">RFC6437</a>]  Amante, S., Carpenter, B., Jiang, S., and J. Rajahalme,
              "IPv6 Flow Label Specification", <a href="rfc6437.html">RFC 6437</a>,
              DOI 10.17487/RFC6437, November 2011,
              &lt;<a href="http://www.rfc-editor.org/info/rfc6437">http://www.rfc-editor.org/info/rfc6437</a>&gt;.

   [<a id="ref-RFC6438" name="ref-RFC6438">RFC6438</a>]  Carpenter, B. and S. Amante, "Using the IPv6 Flow Label
              for Equal Cost Multipath Routing and Link Aggregation in
              Tunnels", <a href="rfc6438.html">RFC 6438</a>, DOI 10.17487/RFC6438, November 2011,
              &lt;<a href="http://www.rfc-editor.org/info/rfc6438">http://www.rfc-editor.org/info/rfc6438</a>&gt;.

   [<a id="ref-RFC6513" name="ref-RFC6513">RFC6513</a>]  Rosen, E., Ed. and R. Aggarwal, Ed., "Multicast in MPLS/
              BGP IP VPNs", <a href="rfc6513.html">RFC 6513</a>, DOI 10.17487/RFC6513, February
              2012, &lt;<a href="http://www.rfc-editor.org/info/rfc6513">http://www.rfc-editor.org/info/rfc6513</a>&gt;.

   [<a id="ref-RFC6679" name="ref-RFC6679">RFC6679</a>]  Westerlund, M., Johansson, I., Perkins, C., O'Hanlon, P.,
              and K. Carlberg, "Explicit Congestion Notification (ECN)
              for RTP over UDP", <a href="rfc6679.html">RFC 6679</a>, DOI 10.17487/RFC6679, August
              2012, &lt;<a href="http://www.rfc-editor.org/info/rfc6679">http://www.rfc-editor.org/info/rfc6679</a>&gt;.

   [<a id="ref-RFC6726" name="ref-RFC6726">RFC6726</a>]  Paila, T., Walsh, R., Luby, M., Roca, V., and R. Lehtonen,
              "FLUTE - File Delivery over Unidirectional Transport",
              <a href="rfc6726.html">RFC 6726</a>, DOI 10.17487/RFC6726, November 2012,
              &lt;<a href="http://www.rfc-editor.org/info/rfc6726">http://www.rfc-editor.org/info/rfc6726</a>&gt;.






<span class="grey">Eggert, et al.            Best Current Practice                [Page 49]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-50" id="page-50" name="page-50"> </a>
<span class="grey"><a href="rfc8085.html">RFC 8085</a>                  UDP Usage Guidelines                March 2017</span>


   [<a id="ref-RFC6773" name="ref-RFC6773">RFC6773</a>]  Phelan, T., Fairhurst, G., and C. Perkins, "DCCP-UDP: A
              Datagram Congestion Control Protocol UDP Encapsulation for
              NAT Traversal", <a href="rfc6773.html">RFC 6773</a>, DOI 10.17487/RFC6773, November
              2012, &lt;<a href="http://www.rfc-editor.org/info/rfc6773">http://www.rfc-editor.org/info/rfc6773</a>&gt;.

   [<a id="ref-RFC6807" name="ref-RFC6807">RFC6807</a>]  Farinacci, D., Shepherd, G., Venaas, S., and Y. Cai,
              "Population Count Extensions to Protocol Independent
              Multicast (PIM)", <a href="rfc6807.html">RFC 6807</a>, DOI 10.17487/RFC6807, December
              2012, &lt;<a href="http://www.rfc-editor.org/info/rfc6807">http://www.rfc-editor.org/info/rfc6807</a>&gt;.

   [<a id="ref-RFC6887" name="ref-RFC6887">RFC6887</a>]  Wing, D., Ed., Cheshire, S., Boucadair, M., Penno, R., and
              P. Selkirk, "Port Control Protocol (PCP)", <a href="rfc6887.html">RFC 6887</a>,
              DOI 10.17487/RFC6887, April 2013,
              &lt;<a href="http://www.rfc-editor.org/info/rfc6887">http://www.rfc-editor.org/info/rfc6887</a>&gt;.

   [<a id="ref-RFC6935" name="ref-RFC6935">RFC6935</a>]  Eubanks, M., Chimento, P., and M. Westerlund, "IPv6 and
              UDP Checksums for Tunneled Packets", <a href="rfc6935.html">RFC 6935</a>,
              DOI 10.17487/RFC6935, April 2013,
              &lt;<a href="http://www.rfc-editor.org/info/rfc6935">http://www.rfc-editor.org/info/rfc6935</a>&gt;.

   [<a id="ref-RFC6936" name="ref-RFC6936">RFC6936</a>]  Fairhurst, G. and M. Westerlund, "Applicability Statement
              for the Use of IPv6 UDP Datagrams with Zero Checksums",
              <a href="rfc6936.html">RFC 6936</a>, DOI 10.17487/RFC6936, April 2013,
              &lt;<a href="http://www.rfc-editor.org/info/rfc6936">http://www.rfc-editor.org/info/rfc6936</a>&gt;.

   [<a id="ref-RFC6951" name="ref-RFC6951">RFC6951</a>]  Tuexen, M. and R. Stewart, "UDP Encapsulation of Stream
              Control Transmission Protocol (SCTP) Packets for End-Host
              to End-Host Communication", <a href="rfc6951.html">RFC 6951</a>,
              DOI 10.17487/RFC6951, May 2013,
              &lt;<a href="http://www.rfc-editor.org/info/rfc6951">http://www.rfc-editor.org/info/rfc6951</a>&gt;.

   [<a id="ref-RFC7143" name="ref-RFC7143">RFC7143</a>]  Chadalapaka, M., Satran, J., Meth, K., and D. Black,
              "Internet Small Computer System Interface (iSCSI) Protocol
              (Consolidated)", <a href="rfc7143.html">RFC 7143</a>, DOI 10.17487/RFC7143, April
              2014, &lt;<a href="http://www.rfc-editor.org/info/rfc7143">http://www.rfc-editor.org/info/rfc7143</a>&gt;.

   [<a id="ref-RFC7201" name="ref-RFC7201">RFC7201</a>]  Westerlund, M. and C. Perkins, "Options for Securing RTP
              Sessions", <a href="rfc7201.html">RFC 7201</a>, DOI 10.17487/RFC7201, April 2014,
              &lt;<a href="http://www.rfc-editor.org/info/rfc7201">http://www.rfc-editor.org/info/rfc7201</a>&gt;.

   [<a id="ref-RFC7296" name="ref-RFC7296">RFC7296</a>]  Kaufman, C., Hoffman, P., Nir, Y., Eronen, P., and T.
              Kivinen, "Internet Key Exchange Protocol Version 2
              (IKEv2)", STD 79, <a href="rfc7296.html">RFC 7296</a>, DOI 10.17487/RFC7296, October
              2014, &lt;<a href="http://www.rfc-editor.org/info/rfc7296">http://www.rfc-editor.org/info/rfc7296</a>&gt;.

   [<a id="ref-RFC7450" name="ref-RFC7450">RFC7450</a>]  Bumgardner, G., "Automatic Multicast Tunneling", <a href="rfc7450.html">RFC 7450</a>,
              DOI 10.17487/RFC7450, February 2015,
              &lt;<a href="http://www.rfc-editor.org/info/rfc7450">http://www.rfc-editor.org/info/rfc7450</a>&gt;.



<span class="grey">Eggert, et al.            Best Current Practice                [Page 50]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-51" id="page-51" name="page-51"> </a>
<span class="grey"><a href="rfc8085.html">RFC 8085</a>                  UDP Usage Guidelines                March 2017</span>


   [<a id="ref-RFC7510" name="ref-RFC7510">RFC7510</a>]  Xu, X., Sheth, N., Yong, L., Callon, R., and D. Black,
              "Encapsulating MPLS in UDP", <a href="rfc7510.html">RFC 7510</a>,
              DOI 10.17487/RFC7510, April 2015,
              &lt;<a href="http://www.rfc-editor.org/info/rfc7510">http://www.rfc-editor.org/info/rfc7510</a>&gt;.

   [<a id="ref-RFC7525" name="ref-RFC7525">RFC7525</a>]  Sheffer, Y., Holz, R., and P. Saint-Andre,
              "Recommendations for Secure Use of Transport Layer
              Security (TLS) and Datagram Transport Layer Security
              (DTLS)", <a href="https://tools.ietf.org/html/bcp195">BCP 195</a>, <a href="rfc7525.html">RFC 7525</a>, DOI 10.17487/RFC7525, May
              2015, &lt;<a href="http://www.rfc-editor.org/info/rfc7525">http://www.rfc-editor.org/info/rfc7525</a>&gt;.

   [<a id="ref-RFC7560" name="ref-RFC7560">RFC7560</a>]  Kuehlewind, M., Ed., Scheffenegger, R., and B. Briscoe,
              "Problem Statement and Requirements for Increased Accuracy
              in Explicit Congestion Notification (ECN) Feedback",
              <a href="rfc7560.html">RFC 7560</a>, DOI 10.17487/RFC7560, August 2015,
              &lt;<a href="http://www.rfc-editor.org/info/rfc7560">http://www.rfc-editor.org/info/rfc7560</a>&gt;.

   [<a id="ref-RFC7567" name="ref-RFC7567">RFC7567</a>]  Baker, F., Ed. and G. Fairhurst, Ed., "IETF
              Recommendations Regarding Active Queue Management",
              <a href="https://tools.ietf.org/html/bcp197">BCP 197</a>, <a href="rfc7567.html">RFC 7567</a>, DOI 10.17487/RFC7567, July 2015,
              &lt;<a href="http://www.rfc-editor.org/info/rfc7567">http://www.rfc-editor.org/info/rfc7567</a>&gt;.

   [<a id="ref-RFC7605" name="ref-RFC7605">RFC7605</a>]  Touch, J., "Recommendations on Using Assigned Transport
              Port Numbers", <a href="https://tools.ietf.org/html/bcp165">BCP 165</a>, <a href="rfc7605.html">RFC 7605</a>, DOI 10.17487/RFC7605,
              August 2015, &lt;<a href="http://www.rfc-editor.org/info/rfc7605">http://www.rfc-editor.org/info/rfc7605</a>&gt;.

   [<a id="ref-RFC7657" name="ref-RFC7657">RFC7657</a>]  Black, D., Ed. and P. Jones, "Differentiated Services
              (Diffserv) and Real-Time Communication", <a href="rfc7657.html">RFC 7657</a>,
              DOI 10.17487/RFC7657, November 2015,
              &lt;<a href="http://www.rfc-editor.org/info/rfc7657">http://www.rfc-editor.org/info/rfc7657</a>&gt;.

   [<a id="ref-RFC7675" name="ref-RFC7675">RFC7675</a>]  Perumal, M., Wing, D., Ravindranath, R., Reddy, T., and M.
              Thomson, "Session Traversal Utilities for NAT (STUN) Usage
              for Consent Freshness", <a href="rfc7675.html">RFC 7675</a>, DOI 10.17487/RFC7675,
              October 2015, &lt;<a href="http://www.rfc-editor.org/info/rfc7675">http://www.rfc-editor.org/info/rfc7675</a>&gt;.

   [<a id="ref-RFC8083" name="ref-RFC8083">RFC8083</a>]  Perkins, C. and V. Singh, "Multimedia Congestion Control:
              Circuit Breakers for Unicast RTP Sessions", <a href="rfc8083.html">RFC 8083</a>,
              DOI 10.17487/RFC8083, March 2017,
              &lt;<a href="http://www.rfc-editor.org/info/rfc8083">http://www.rfc-editor.org/info/rfc8083</a>&gt;.

   [<a id="ref-RFC8086" name="ref-RFC8086">RFC8086</a>]  Yong, L., Ed., Crabbe, E., Xu, X., and T. Herbert, "GRE-
              in-UDP Encapsulation", <a href="rfc8086.html">RFC 8086</a>, DOI 10.17487/RFC8086,
              March 2017, &lt;<a href="http://www.rfc-editor.org/info/rfc8086">http://www.rfc-editor.org/info/rfc8086</a>&gt;.







<span class="grey">Eggert, et al.            Best Current Practice                [Page 51]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-52" id="page-52" name="page-52"> </a>
<span class="grey"><a href="rfc8085.html">RFC 8085</a>                  UDP Usage Guidelines                March 2017</span>


   [<a id="ref-RFC8087" name="ref-RFC8087">RFC8087</a>]  Fairhurst, G. and M. Welzl, "The Benefits of Using
              Explicit Congestion Notification (ECN)", <a href="rfc8087.html">RFC 8087</a>,
              DOI 10.17487/RFC8087, March 2017,
              &lt;<a href="http://www.rfc-editor.org/info/rfc8087">http://www.rfc-editor.org/info/rfc8087</a>&gt;.

   [<a id="ref-STEVENS" name="ref-STEVENS">STEVENS</a>]  Stevens, W., Fenner, B., and A. Rudoff, "UNIX Network
              Programming, The sockets Networking API", Addison-Wesley,
              2004.

   [<a id="ref-UPnP" name="ref-UPnP">UPnP</a>]     UPnP Forum, , "Internet Gateway Device (IGD) Standardized
              Device Control Protocol V 1.0", November 2001.








































<span class="grey">Eggert, et al.            Best Current Practice                [Page 52]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-53" id="page-53" name="page-53"> </a>
<span class="grey"><a href="rfc8085.html">RFC 8085</a>                  UDP Usage Guidelines                March 2017</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/Appendix%20A.%20%20Case%20Study%20of%20the%20Use%20of%20IPv6%20UDP%20Zero-Checksum%20Mode"></a><a class="selflink" href="#appendix-A" name="appendix-A">Appendix A</a>.  Case Study of the Use of IPv6 UDP Zero-Checksum Mode</span>

   This appendix provides a brief review of MPLS-in-UDP as an example of
   a UDP Tunnel Encapsulation that defines a UDP encapsulation.  The
   purpose of the appendix is to provide a concrete example of which
   mechanisms were required in order to safely use UDP zero-checksum
   mode for MPLS-in-UDP tunnels over IPv6.  By default, UDP requires a
   checksum for use with IPv6.  An option has been specified that
   permits a zero IPv6 UDP checksum when used in specific environments,
   specified in [<a href="rfc7510.html" title='"Encapsulating MPLS in UDP"'>RFC7510</a>], and defines a set of operational constraints
   for use of this mode.  These are summarized below:

   A UDP tunnel or encapsulation using a zero-checksum mode with IPv6
   must only be deployed within a single network (with a single network
   operator) or networks of an adjacent set of cooperating network
   operators where traffic is managed to avoid congestion, rather than
   over the Internet where congestion control is required.  MPLS-in-UDP
   has been specified for networks under single administrative control
   (such as within a single operator's network) where it is known
   (perhaps through knowledge of equipment types and lower-layer checks)
   that packet corruption is exceptionally unlikely and where the
   operator is willing to take the risk of undetected packet corruption.

   The tunnel encapsulator SHOULD use different IPv6 addresses for each
   UDP tunnel that uses the UDP zero-checksum mode, regardless of the
   decapsulator, to strengthen the decapsulator's check of the IPv6
   source address (i.e., the same IPv6 source address SHOULD NOT be used
   with more than one IPv6 destination address, independent of whether
   that destination address is a unicast or multicast address).  Use of
   MPLS-in-UDP may be extended to networks within a set of closely
   cooperating network administrations (such as network operators who
   have agreed to work together to jointly provide specific services)
   [<a href="rfc7510.html" title='"Encapsulating MPLS in UDP"'>RFC7510</a>].

   The requirement for MPLS-in-UDP endpoints to check the source IPv6
   address in addition to the destination IPv6 address, plus the strong
   recommendation against reuse of source IPv6 addresses among MPLS-in-
   UDP tunnels collectively provide some mitigation for the absence of
   UDP checksum coverage of the IPv6 header.  In addition, the MPLS data
   plane only forwards packets with valid labels (i.e., labels that have
   been distributed by the tunnel egress Label Switched Router, LSR),
   providing some additional opportunity to detect MPLS-in-UDP packet
   misdelivery when the misdelivered packet contains a label that is not
   valid for forwarding at the receiving LSR.  The expected result for
   IPv6 UDP zero-checksum mode for MPLS-in-UDP is that corruption of the
   destination IPv6 address will usually cause packet discard, as
   offsetting corruptions to the source IPv6 and/or MPLS top label are
   unlikely.



<span class="grey">Eggert, et al.            Best Current Practice                [Page 53]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-54" id="page-54" name="page-54"> </a>
<span class="grey"><a href="rfc8085.html">RFC 8085</a>                  UDP Usage Guidelines                March 2017</span>


   Additional assurance is provided by the restrictions in the above
   exceptions that limit usage of IPv6 UDP zero-checksum mode to well-
   managed networks for which MPLS packet corruption has not been a
   problem in practice.  Hence, MPLS-in-UDP is suitable for transmission
   over lower layers in well-managed networks that are allowed by the
   exceptions stated above and the rate of corruption of the inner IP
   packet on such networks is not expected to increase by comparison to
   MPLS traffic that is not encapsulated in UDP.  For these reasons,
   MPLS-in-UDP does not provide an additional integrity check when UDP
   zero-checksum mode is used with IPv6, and this design is in
   accordance with requirements 2, 3, and 5 specified in <a href="rfc6936.html#section-5">Section 5 of
   [RFC6936]</a>.

   The MPLS-in-UDP encapsulation does not provide a mechanism to safely
   fall back to using a checksum when a path change occurs that
   redirects a tunnel over a path that includes a middlebox that
   discards IPv6 datagrams with a zero UDP checksum.  In this case, the
   MPLS-in-UDP tunnel will be black-holed by that middlebox.
   Recommended changes to allow firewalls, NATs and other middleboxes to
   support use of an IPv6 zero UDP checksum are described in <a href="rfc6936.html#section-5">Section 5
   of [RFC6936]</a>.  MPLS does not accumulate incorrect state as a
   consequence of label-stack corruption.  A corrupt MPLS label results
   in either packet discard or forwarding (and forgetting) of the packet
   without accumulation of MPLS protocol state.  Active monitoring of
   MPLS-in-UDP traffic for errors is REQUIRED because the occurrence of
   errors will result in some accumulation of error information outside
   the MPLS protocol for operational and management purposes.  This
   design is in accordance with requirement 4 specified in <a href="rfc6936.html#section-5">Section 5 of
   [RFC6936]</a>.  In addition, IPv6 traffic with a zero UDP checksum MUST
   be actively monitored for errors by the network operator.

   Operators SHOULD also deploy packet filters to prevent IPv6 packets
   with a zero UDP checksum from escaping from the network due to
   misconfiguration or packet errors.  In addition, IPv6 traffic with a
   zero UDP checksum MUST be actively monitored for errors by the
   network operator.















<span class="grey">Eggert, et al.            Best Current Practice                [Page 54]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-55" id="page-55" name="page-55"> </a>
<span class="grey"><a href="rfc8085.html">RFC 8085</a>                  UDP Usage Guidelines                March 2017</span>


Acknowledgments

   The middlebox traversal guidelines in <a href="#section-3.5">Section 3.5</a> incorporate ideas
   from Section 5 of [<a href="#ref-BEHAVE-APP">BEHAVE-APP</a>] by Bryan Ford, Pyda Srisuresh, and Dan
   Kegel.  The protocol timer guidelines in <a href="#section-3.1.1">Section 3.1.1</a> were largely
   contributed by Mark Allman.

   G.  Fairhurst received funding from the European Union's Horizon 2020
   research and innovation program 2014-2018 under grant agreement No.
   644334 (NEAT).  Lars Eggert has received funding from the European
   Union's Horizon 2020 research and innovation program 2014-2018 under
   grant agreement No. 644866 (SSICLOPS).  This document reflects only
   the authors' views and the European Commission is not responsible for
   any use that may be made of the information it contains.

Authors' Addresses

   Lars Eggert
   NetApp
   Sonnenallee 1
   Kirchheim  85551
   Germany

   Phone: +49 151 120 55791
   Email: lars@netapp.com
   URI:   <a href="https://eggert.org/">https://eggert.org/</a>


   Godred Fairhurst
   University of Aberdeen
   Department of Engineering
   Fraser Noble Building
   Aberdeen  AB24 3UE
   Scotland

   Email: gorry@erg.abdn.ac.uk
   URI:   <a href="http://www.erg.abdn.ac.uk/">http://www.erg.abdn.ac.uk/</a>


   Greg Shepherd
   Cisco Systems
   Tasman Drive
   San Jose
   United States of America

   Email: gjshep@gmail.com





Eggert, et al.            Best Current Practice                [Page 55]

</pre><br/>
    <span class="noprint"><small><small>Html markup produced by rfcmarkup 1.126, available from
      <a href="https://tools.ietf.org/tools/rfcmarkup/">https://tools.ietf.org/tools/rfcmarkup/</a>
    </small></small></span>
  </div>




</body><!-- Mirrored from tools.ietf.org/html/rfc8085 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 06 Mar 2018 23:18:18 GMT --></html>