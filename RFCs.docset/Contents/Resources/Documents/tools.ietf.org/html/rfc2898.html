<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml"><!-- Mirrored from tools.ietf.org/html/rfc2898 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 06 Mar 2018 23:18:51 GMT --><!-- Added by HTTrack --><head><meta content="text/html;charset=utf-8" http-equiv="content-type"/><!-- /Added by HTTrack -->

    <meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
    <meta content="index,follow" name="robots"/>
    <meta content="rfcmarkup version 1.126" name="creator"/>
    <link href="http://purl.org/dc/elements/1.1/" rel="schema.DC"/>
<meta content="urn:ietf:rfc:2898" name="DC.Identifier"/>
<meta content="This document provides recommendations for the implementation of
password-based cryptography, covering key derivation functions,
encryption schemes, message-authentication schemes, and ASN.1 syntax
identifying the techniques. This memo provides information for the
Internet community." name="DC.Description.Abstract"/>
<meta content="Burt Kaliski &lt;bkaliski@rsasecurity.com&gt;" name="DC.Creator"/>
<meta content="September, 2000" name="DC.Date.Issued"/>
<meta content="PKCS #5: Password-Based Cryptography Specification Version 2.0" name="DC.Title"/>

    <link href="https://tools.ietf.org/images/rfc.png" rel="icon" type="image/png"/>
    <link href="https://tools.ietf.org/images/rfc.png" rel="shortcut icon" type="image/png"/>
    <title>RFC 2898 - PKCS #5: Password-Based Cryptography Specification Version 2.0</title>
    
    
    <style type="text/css">
	@media only screen 
	  and (min-width: 992px)
	  and (max-width: 1199px) {
	    body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 768px)
	  and (max-width: 991px) {
            body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 480px)
	  and (max-width: 767px) {
            body { font-size: 11pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (max-width: 479px) {
            body { font-size: 8pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-device-width : 375px) 
	  and (max-device-width : 667px) {
            body { font-size: 9.5pt; }
            div.content { width: 96ex; margin: 0 1px; }
        }
	@media only screen 
	  and (min-device-width: 1200px) {
            body { font-size: 10pt; margin: 0 4em; }
            div.content { width: 96ex; margin: 0; }
        }
        h1, h2, h3, h4, h5, h6, .h1, .h2, .h3, .h4, .h5, .h6 {
	    font-weight: bold;
            line-height: 0pt;
            display: inline;
            white-space: pre;
            font-family: monospace;
            font-size: 1em;
	    font-weight: bold;
        }
        pre {
            font-size: 1em;
            margin-top: 0px;
            margin-bottom: 0px;
        }
	.pre {
	    white-space: pre;
	    font-family: monospace;
	}
	.header{
	    font-weight: bold;
	}
        .newpage {
            page-break-before: always;
        }
        .invisible {
            text-decoration: none;
            color: white;
        }
        a.selflink {
          color: black;
          text-decoration: none;
        }
        @media print {
            body {
                font-family: monospace;
                font-size: 10.5pt;
            }
            h1, h2, h3, h4, h5, h6 {
                font-size: 1em;
            }
        
            a:link, a:visited {
                color: inherit;
                text-decoration: none;
            }
            .noprint {
                display: none;
            }
        }
	@media screen {
	    .grey, .grey a:link, .grey a:visited {
		color: #777;
	    }
            .docinfo {
                background-color: #EEE;
            }
            .top {
                border-top: 7px solid #EEE;
            }
            .bgwhite  { background-color: white; }
            .bgred    { background-color: #F44; }
            .bggrey   { background-color: #666; }
            .bgbrown  { background-color: #840; }            
            .bgorange { background-color: #FA0; }
            .bgyellow { background-color: #EE0; }
            .bgmagenta{ background-color: #F4F; }
            .bgblue   { background-color: #66F; }
            .bgcyan   { background-color: #4DD; }
            .bggreen  { background-color: #4F4; }

            .legend   { font-size: 90%; }
            .cplate   { font-size: 70%; border: solid grey 1px; }
	}
    </style>
    <!--[if IE]>
    <style>
    body {
       font-size: 13px;
       margin: 10px 10px;
    }
    </style>
    <![endif]-->

    <script type="text/javascript"><!--
    function addHeaderTags() {
	var spans = document.getElementsByTagName("span");
	for (var i=0; i < spans.length; i++) {
	    var elem = spans[i];
	    if (elem) {
		var level = elem.getAttribute("class");
                if (level == "h1" || level == "h2" || level == "h3" || level == "h4" || level == "h5" || level == "h6") {
                    elem.innerHTML = "<"+level+">"+elem.innerHTML+"</"+level+">";		
                }
	    }
	}
    }
    var legend_html = "Colour legend:<br />      <table>         <tr><td>Unknown:</td>                   <td><span class='cplate bgwhite'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft:</td>                     <td><span class='cplate bgred'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Informational:</td>             <td><span class='cplate bgorange'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Experimental:</td>              <td><span class='cplate bgyellow'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Best Common Practice:</td>      <td><span class='cplate bgmagenta'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Proposed Standard:</td>         <td><span class='cplate bgblue'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft Standard (old designation):</td> <td><span class='cplate bgcyan'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Internet Standard:</td>         <td><span class='cplate bggreen'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Historic:</td>                  <td><span class='cplate bggrey'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Obsolete:</td>                  <td><span class='cplate bgbrown'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>     </table>";
    function showElem(id) {
        var elem = document.getElementById(id);
        elem.innerHTML = eval(id+"_html");
        elem.style.visibility='visible';
    }
    function hideElem(id) {
        var elem = document.getElementById(id);
        elem.style.visibility='hidden';        
        elem.innerHTML = "";
    }
    // -->
    </script>
</head>
<body onload="addHeaderTags()">
  <div class="content">
   <div style="height: 13px;">
      <div class="pre noprint docinfo bgbrown" onclick="showElem('legend');" onmouseout="hideElem('legend')" onmouseover="this.style.cursor='pointer';" style="height: 6px; position: absolute;" title="Click for colour legend.">                                                                        </div>
      <div class="docinfo noprint pre legend" id="legend" onmouseout="hideElem('legend');" onmouseover="showElem('legend');" style="position:absolute; top: 4px; left: 4ex; visibility:hidden; background-color: white; padding: 4px 9px 5px 7px; border: solid #345 1px; ">
      </div>
   </div>
<span class="pre noprint docinfo top">[<a href="index.html" title="Document search and retrieval page">Docs</a>] [<a href="https://tools.ietf.org/rfc/rfc2898.txt" title="Plaintext version of this document">txt</a>|<a href="https://tools.ietf.org/pdf/rfc2898" title="PDF version of this document">pdf</a>] [<a href="https://tools.ietf.org/html/draft-kaliski-pkcs5-v2" title="draft-kaliski-pkcs5-v2">draft-kaliski-p...</a>] [<a href="https://datatracker.ietf.org/doc/rfc2898" title="IESG Datatracker information for this document">Tracker</a>] [<a href="https://tools.ietf.org/rfcdiff?difftype=--hwdiff&amp;url2=rfc2898" title="Inline diff (wdiff)">Diff1</a>] [<a href="https://tools.ietf.org/rfcdiff?url2=rfc2898" title="Side-by-side diff">Diff2</a>] [<a href="https://www.rfc-editor.org/errata_search.php?rfc=2898">Errata</a>]</span><br/>
<span class="pre noprint docinfo">                                                                        </span><br/>
<span class="pre noprint docinfo">Obsoleted by: <a href="rfc8018.html">8018</a>                                         INFORMATIONAL</span><br/>
<span class="pre noprint docinfo">                                                            <span style="color: #C00;">Errata Exist</span></span><br/>
<pre>Network Working Group                                         B. Kaliski
Request for Comments: 2898                              RSA Laboratories
Category: Informational                                   September 2000


           <span class="h1">PKCS #5: Password-Based Cryptography Specification</span>
                              <span class="h1">Version 2.0</span>

Status of this Memo

   This memo provides information for the Internet community.  It does
   not specify an Internet standard of any kind.  Distribution of this
   memo is unlimited.

Copyright Notice

   Copyright (C) The Internet Society (2000).  All Rights Reserved.

Abstract

   This memo represents a republication of PKCS #5 v2.0 from RSA
   Laboratories' Public-Key Cryptography Standards (PKCS) series, and
   change control is retained within the PKCS process.  The body of this
   document, except for the security considerations section, is taken
   directly from that specification.

   This document provides recommendations for the implementation of
   password-based cryptography, covering key derivation functions,
   encryption schemes, message-authentication schemes, and ASN.1 syntax
   identifying the techniques.

   The recommendations are intended for general application within
   computer and communications systems, and as such include a fair
   amount of flexibility. They are particularly intended for the
   protection of sensitive information such as private keys, as in PKCS
   #8 [<a href="#ref-25">25</a>]. It is expected that application standards and implementation
   profiles based on these specifications may include additional
   constraints.

   Other cryptographic techniques based on passwords, such as password-
   based key entity authentication and key establishment protocols
   [<a href="#ref-4" title="pages 72-84">4</a>][5][<a href="#ref-26" title="Internet Society">26</a>] are outside the scope of this document.  Guidelines for
   the selection of passwords are also outside the scope.








<span class="grey">Kaliski                      Informational                      [Page 1]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-2" id="page-2" name="page-2"> </a>
<span class="grey"><a href="rfc2898.html">RFC 2898</a>              Password-Based Cryptography         September 2000</span>


Table of Contents

   <a href="#section-1">1</a>.   Introduction ...............................................  <a href="#page-3">3</a>
   <a href="#section-2">2</a>.   Notation ...................................................  <a href="#page-3">3</a>
   <a href="#section-3">3</a>.   Overview ...................................................  <a href="#page-4">4</a>
   <a href="#section-4">4</a>.   Salt and iteration count ...................................  <a href="#page-6">6</a>
       <a href="#section-4.1">4.1</a>  Salt ...................................................  <a href="#page-6">6</a>
       <a href="#section-4.2">4.2</a>  Iteration count ........................................  <a href="#page-8">8</a>
   <a href="#section-5">5</a>.   Key derivation functions ...................................  <a href="#page-8">8</a>
       <a href="#section-5.1">5.1</a>  PBKDF1 .................................................  <a href="#page-9">9</a>
       <a href="#section-5.2">5.2</a>  PBKDF2 .................................................  <a href="#page-9">9</a>
   <a href="#section-6">6</a>.   Encryption schemes ......................................... <a href="#page-11">11</a>
       <a href="#section-6.1">6.1</a>  PBES1 .................................................. <a href="#page-12">12</a>
            <a href="#section-6.1.1">6.1.1</a>  Encryption operation ............................ <a href="#page-12">12</a>
            <a href="#section-6.1.2">6.1.2</a>  Decryption operation ............................ <a href="#page-13">13</a>
       <a href="#section-6.2">6.2</a>  PBES2 .................................................. <a href="#page-14">14</a>
            <a href="#section-6.2.1">6.2.1</a>  Encryption operation ............................ <a href="#page-14">14</a>
            <a href="#section-6.2.2">6.2.2</a>  Decryption operation ............................ <a href="#page-15">15</a>
   <a href="#section-7">7</a>.   Message authentication schemes ............................. <a href="#page-15">15</a>
       <a href="#section-7.1">7.1</a>  PBMAC1 ................................................. <a href="#page-16">16</a>
            <a href="#section-7.1.1">7.1.1</a>  MAC generation .................................. <a href="#page-16">16</a>
            <a href="#section-7.1.2">7.1.2</a>  MAC verification ................................ <a href="#page-16">16</a>
   <a href="#section-8">8</a>.   Security Considerations .................................... <a href="#page-17">17</a>
   <a href="#section-9">9</a>.   Author's Address............................................ <a href="#page-17">17</a>
   <a href="#appendix-A">A</a>.   ASN.1 syntax ............................................... <a href="#page-18">18</a>
       <a href="#appendix-A.1">A.1</a>  PBKDF1 ................................................. <a href="#page-18">18</a>
       <a href="#appendix-A.2">A.2</a>  PBKDF2 ................................................. <a href="#page-18">18</a>
       <a href="#appendix-A.3">A.3</a>  PBES1 .................................................. <a href="#page-20">20</a>
       <a href="#appendix-A.4">A.4</a>  PBES2 .................................................. <a href="#page-20">20</a>
       <a href="#appendix-A.5">A.5</a>  PBMAC1 ................................................. <a href="#page-21">21</a>
   <a href="#appendix-B">B</a>.   Supporting techniques ...................................... <a href="#page-22">22</a>
       <a href="#appendix-B.1">B.1</a>  Pseudorandom functions ................................. <a href="#page-22">22</a>
       <a href="#appendix-B.2">B.2</a>  Encryption schemes ..................................... <a href="#page-23">23</a>
       <a href="#appendix-B.3">B.3</a>  Message authentication schemes ......................... <a href="#page-26">26</a>
   <a href="#appendix-C">C</a>.   ASN.1 module ............................................... <a href="#page-26">26</a>
   Intellectual Property Considerations ............................ <a href="#page-30">30</a>
   Revision history ................................................ <a href="#page-30">30</a>
   References ...................................................... <a href="#page-31">31</a>
   Contact Information &amp; About PKCS ................................ <a href="#page-33">33</a>
   Full Copyright Statement ........................................ <a href="#page-34">34</a>











<span class="grey">Kaliski                      Informational                      [Page 2]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-3" id="page-3" name="page-3"> </a>
<span class="grey"><a href="rfc2898.html">RFC 2898</a>              Password-Based Cryptography         September 2000</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/1.%20Introduction"></a><a class="selflink" href="#section-1" name="section-1">1</a>. Introduction</span>

   This document provides recommendations for the implementation of
   password-based cryptography, covering the following aspects:

   -  key derivation functions
   -  encryption schemes
   -  message-authentication schemes
   -  ASN.1 syntax identifying the techniques

   The recommendations are intended for general application within
   computer and communications systems, and as such include a fair
   amount of flexibility. They are particularly intended for the
   protection of sensitive information such as private keys, as in PKCS
   #8 [<a href="#ref-25">25</a>]. It is expected that application standards and implementation
   profiles based on these specifications may include additional
   constraints.

   Other cryptographic techniques based on passwords, such as password-
   based key entity authentication and key establishment protocols
   [<a href="#ref-4" title="pages 72-84">4</a>][5][<a href="#ref-26" title="Internet Society">26</a>] are outside the scope of this document.  Guidelines for
   the selection of passwords are also outside the scope.

   This document supersedes PKCS #5 version 1.5 [<a href="#ref-24">24</a>], but includes
   compatible techniques.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/2.%20Notation"></a><a class="selflink" href="#section-2" name="section-2">2</a>. Notation</span>

   C       ciphertext, an octet string

   c       iteration count, a positive integer

   DK      derived key, an octet string

   dkLen   length in octets of derived key, a positive integer

   EM      encoded message, an octet string

   Hash    underlying hash function

   hLen    length in octets of pseudorandom function output, a positive
           integer

   l       length in blocks of derived key, a positive integer

   IV      initialization vector, an octet string

   K       encryption key, an octet string



<span class="grey">Kaliski                      Informational                      [Page 3]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-4" id="page-4" name="page-4"> </a>
<span class="grey"><a href="rfc2898.html">RFC 2898</a>              Password-Based Cryptography         September 2000</span>


   KDF     key derivation function

   M       message, an octet string

   P       password, an octet string

   PRF     underlying pseudorandom function

   PS      padding string, an octet string

   psLen   length in octets of padding string, a positive integer

   S       salt, an octet string

   T       message authentication code, an octet string

   T_1, ..., T_l, U_1, ..., U_c
           intermediate values, octet strings

   01, 02, ..., 08
           octets with value 1, 2, ..., 8

   \xor    bit-wise exclusive-or of two octet strings

   ||  ||  octet length operator

   ||      concatenation operator

   &lt;i..j&gt;  substring extraction operator: extracts octets i through j,
           0 &lt;= i &lt;= j

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/3.%20Overview"></a><a class="selflink" href="#section-3" name="section-3">3</a>. Overview</span>

   In many applications of public-key cryptography, user security is
   ultimately dependent on one or more secret text values or passwords.
   Since a password is not directly applicable as a key to any
   conventional cryptosystem, however, some processing of the password
   is required to perform cryptographic operations with it. Moreover, as
   passwords are often chosen from a relatively small space, special
   care is required in that processing to defend against search attacks.

   A general approach to password-based cryptography, as described by
   Morris and Thompson [<a href="#ref-8" title="22(11):594-597">8</a>] for the protection of password tables, is to
   combine a password with a salt to produce a key. The salt can be
   viewed as an index into a large set of keys derived from the
   password, and need not be kept secret. Although it may be possible
   for an opponent to construct a table of possible passwords (a so-
   called "dictionary attack"), constructing a table of possible keys



<span class="grey">Kaliski                      Informational                      [Page 4]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-5" id="page-5" name="page-5"> </a>
<span class="grey"><a href="rfc2898.html">RFC 2898</a>              Password-Based Cryptography         September 2000</span>


   will be difficult, since there will be many possible keys for each
   password.  An opponent will thus be limited to searching through
   passwords separately for each salt.

   Another approach to password-based cryptography is to construct key
   derivation techniques that are relatively expensive, thereby
   increasing the cost of exhaustive search. One way to do this is to
   include an iteration count in the key derivation technique,
   indicating how many times to iterate some underlying function by
   which keys are derived. A modest number of iterations, say 1000, is
   not likely to be a burden for legitimate parties when computing a
   key, but will be a significant burden for opponents.

   Salt and iteration count formed the basis for password-based
   encryption in PKCS #5 v1.5, and adopted here as well for the various
   cryptographic operations. Thus, password-based key derivation as
   defined here is a function of a password, a salt, and an iteration
   count, where the latter two quantities need not be kept secret.

   From a password-based key derivation function, it is straightforward
   to define password-based encryption and message authentication
   schemes. As in PKCS #5 v1.5, the password-based encryption schemes
   here are based on an underlying, conventional encryption scheme,
   where the key for the conventional scheme is derived from the
   password. Similarly, the password-based message authentication scheme
   is based on an underlying conventional scheme. This two-layered
   approach makes the password-based techniques modular in terms of the
   underlying techniques they can be based on.

   It is expected that the password-based key derivation functions may
   find other applications than just the encryption and message
   authentication schemes defined here. For instance, one might derive a
   set of keys with a single application of a key derivation function,
   rather than derive each key with a separate application of the
   function. The keys in the set would be obtained as substrings of the
   output of the key derivation function. This approach might be
   employed as part of key establishment in a session-oriented protocol.
   Another application is password checking, where the output of the key
   derivation function is stored (along with the salt and iteration
   count) for the purposes of subsequent verification of a password.

   Throughout this document, a password is considered to be an octet
   string of arbitrary length whose interpretation as a text string is
   unspecified. In the interest of interoperability, however, it is
   recommended that applications follow some common text encoding rules.
   ASCII and UTF-8 [<a href="#ref-27" title='"UTF-8, a transformation format of ISO 10646"'>27</a>] are two possibilities. (ASCII is a subset of
   UTF-8.)




<span class="grey">Kaliski                      Informational                      [Page 5]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-6" id="page-6" name="page-6"> </a>
<span class="grey"><a href="rfc2898.html">RFC 2898</a>              Password-Based Cryptography         September 2000</span>


   Although the selection of passwords is outside the scope of this
   document, guidelines have been published [<a href="#ref-17">17</a>] that may well be taken
   into account.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/4.%20Salt%20and%20Iteration%20Count"></a><a class="selflink" href="#section-4" name="section-4">4</a>. Salt and Iteration Count</span>

   Inasmuch as salt and iteration count are central to the techniques
   defined in this document, some further discussion is warranted.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.1%20Salt"></a><a class="selflink" href="#section-4.1" name="section-4.1">4.1</a> Salt</span>

   A salt in password-based cryptography has traditionally served the
   purpose of producing a large set of keys corresponding to a given
   password, among which one is selected at random according to the
   salt. An individual key in the set is selected by applying a key
   derivation function KDF, as

                              DK = KDF (P, S)

   where DK is the derived key, P is the password, and S is the salt.
   This has two benefits:

      1. It is difficult for an opponent to precompute all the keys
         corresponding to a dictionary of passwords, or even the most
         likely keys. If the salt is 64 bits long, for instance, there
         will be as many as 2^64 keys for each password. An opponent is
         thus limited to searching for passwords after a password-based
         operation has been performed and the salt is known.

      2. It is unlikely that the same key will be selected twice.
         Again, if the salt is 64 bits long, the chance of "collision"
         between keys does not become significant until about 2^32 keys
         have been produced, according to the Birthday Paradox. This
         addresses some of the concerns about interactions between
         multiple uses of the same key, which may apply for some
         encryption and authentication techniques.

   In password-based encryption, the party encrypting a message can gain
   assurance that these benefits are realized simply by selecting a
   large and sufficiently random salt when deriving an encryption key
   from a password. A party generating a message authentication code can
   gain such assurance in a similar fashion.

   The party decrypting a message or verifying a message authentication
   code, however, cannot be sure that a salt supplied by another party
   has actually been generated at random. It is possible, for instance,
   that the salt may have been copied from another password-based
   operation, in an attempt to exploit interactions between multiple



<span class="grey">Kaliski                      Informational                      [Page 6]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-7" id="page-7" name="page-7"> </a>
<span class="grey"><a href="rfc2898.html">RFC 2898</a>              Password-Based Cryptography         September 2000</span>


   uses of the same key. For instance, suppose two legitimate parties
   exchange a encrypted message, where the encryption key is an 80-bit
   key derived from a shared password with some salt. An opponent could
   take the salt from that encryption and provide it to one of the
   parties as though it were for a 40-bit key. If the party reveals the
   result of decryption with the 40-bit key, the opponent may be able to
   solve for the 40-bit key. In the case that 40-bit key is the first
   half of the 80-bit key, the opponent can then readily solve for the
   remaining 40 bits of the 80-bit key.

   To defend against such attacks, either the interaction between
   multiple uses of the same key should be carefully analyzed, or the
   salt should contain data that explicitly distinguishes between
   different operations.  For instance, the salt might have an
   additional, non-random octet that specifies whether the derived key
   is for encryption, for message authentication, or for some other
   operation.

   Based on this, the following is recommended for salt selection:

      1. If there is no concern about interactions between multiple uses
         of the same key (or a prefix of that key) with the password-
         based encryption and authentication techniques supported for a
         given password, then the salt may be generated at random and
         need not be checked for a particular format by the party
         receiving the salt. It should be at least eight octets (64
         bits) long.

      2. Otherwise, the salt should contain data that explicitly
         distinguishes between different operations and different key
         lengths, in addition to a random part that is at least eight
         octets long, and this data should be checked or regenerated by
         the party receiving the salt. For instance, the salt could have
         an additional non-random octet that specifies the purpose of
         the derived key. Alternatively, it could be the encoding of a
         structure that specifies detailed information about the derived
         key, such as the encryption or authentication technique and a
         sequence number among the different keys derived from the
         password.  The particular format of the additional data is left
         to the application.

   Note. If a random number generator or pseudorandom generator is not
   available, a deterministic alternative for generating the salt (or
   the random part of it) is to apply a password-based key derivation
   function to the password and the message M to be processed. For
   instance, the salt could be computed with a key derivation function
   as S = KDF (P, M). This approach is not recommended if the message M




<span class="grey">Kaliski                      Informational                      [Page 7]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-8" id="page-8" name="page-8"> </a>
<span class="grey"><a href="rfc2898.html">RFC 2898</a>              Password-Based Cryptography         September 2000</span>


   is known to belong to a small message space (e.g., "Yes" or "No"),
   however, since then there will only be a small number of possible
   salts.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.2%20Iteration%20Count"></a><a class="selflink" href="#section-4.2" name="section-4.2">4.2</a> Iteration Count</span>

   An iteration count has traditionally served the purpose of increasing
   the cost of producing keys from a password, thereby also increasing
   the difficulty of attack. For the methods in this document, a minimum
   of 1000 iterations is recommended. This will increase the cost of
   exhaustive search for passwords significantly, without a noticeable
   impact in the cost of deriving individual keys.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/5.%20Key%20Derivation%20Functions"></a><a class="selflink" href="#section-5" name="section-5">5</a>. Key Derivation Functions</span>

   A key derivation function produces a derived key from a base key and
   other parameters. In a password-based key derivation function, the
   base key is a password and the other parameters are a salt value and
   an iteration count, as outlined in <a href="#section-3">Section 3</a>.

   The primary application of the password-based key derivation
   functions defined here is in the encryption schemes in <a href="#section-6">Section 6</a> and
   the message authentication scheme in <a href="#section-7">Section 7</a>. Other applications
   are certainly possible, hence the independent definition of these
   functions.

   Two functions are specified in this section: PBKDF1 and PBKDF2.
   PBKDF2 is recommended for new applications; PBKDF1 is included only
   for compatibility with existing applications, and is not recommended
   for new applications.

   A typical application of the key derivation functions defined here
   might include the following steps:

      1. Select a salt S and an iteration count c, as outlined in
         <a href="#section-4">Section 4</a>.

      2. Select a length in octets for the derived key, dkLen.

      3. Apply the key derivation function to the password, the salt,
         the iteration count and the key length to produce a derived
         key.

      4. Output the derived key.

   Any number of keys may be derived from a password by varying the
   salt, as described in <a href="#section-3">Section 3</a>.




<span class="grey">Kaliski                      Informational                      [Page 8]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-9" id="page-9" name="page-9"> </a>
<span class="grey"><a href="rfc2898.html">RFC 2898</a>              Password-Based Cryptography         September 2000</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.1%20PBKDF1"></a><a class="selflink" href="#section-5.1" name="section-5.1">5.1</a> PBKDF1</span>

   PBKDF1 applies a hash function, which shall be MD2 [<a href="#ref-6" title='"The MD2 Message-Digest Algorithm"'>6</a>], MD5 [<a href="#ref-19" title='"The MD5 Message-Digest Algorithm"'>19</a>] or
   SHA-1 [<a href="#ref-18">18</a>], to derive keys. The length of the derived key is bounded
   by the length of the hash function output, which is 16 octets for MD2
   and MD5 and 20 octets for SHA-1. PBKDF1 is compatible with the key
   derivation process in PKCS #5 v1.5.

   PBKDF1 is recommended only for compatibility with existing
   applications since the keys it produces may not be large enough for
   some applications.

   PBKDF1 (P, S, c, dkLen)

   Options:        Hash       underlying hash function

   Input:          P          password, an octet string
                   S          salt, an eight-octet string
                   c          iteration count, a positive integer
                   dkLen      intended length in octets of derived key,
                              a positive integer, at most 16 for MD2 or
                              MD5 and 20 for SHA-1

   Output:         DK         derived key, a dkLen-octet string

   Steps:

      1. If dkLen &gt; 16 for MD2 and MD5, or dkLen &gt; 20 for SHA-1, output
         "derived key too long" and stop.

      2. Apply the underlying hash function Hash for c iterations to the
         concatenation of the password P and the salt S, then extract
         the first dkLen octets to produce a derived key DK:

                   T_1 = Hash (P || S) ,
                   T_2 = Hash (T_1) ,
                   ...
                   T_c = Hash (T_{c-1}) ,
                   DK = Tc&lt;0..dkLen-1&gt;

      3. Output the derived key DK.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.2%20PBKDF2"></a><a class="selflink" href="#section-5.2" name="section-5.2">5.2</a> PBKDF2</span>

   PBKDF2 applies a pseudorandom function (see <a href="#appendix-B.1">Appendix B.1</a> for an
   example) to derive keys. The length of the derived key is essentially
   unbounded. (However, the maximum effective search space for the




<span class="grey">Kaliski                      Informational                      [Page 9]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-10" id="page-10" name="page-10"> </a>
<span class="grey"><a href="rfc2898.html">RFC 2898</a>              Password-Based Cryptography         September 2000</span>


   derived key may be limited by the structure of the underlying
   pseudorandom function. See <a href="#appendix-B.1">Appendix B.1</a> for further discussion.)
   PBKDF2 is recommended for new applications.

   PBKDF2 (P, S, c, dkLen)

   Options:        PRF        underlying pseudorandom function (hLen
                              denotes the length in octets of the
                              pseudorandom function output)

   Input:          P          password, an octet string
                   S          salt, an octet string
                   c          iteration count, a positive integer
                   dkLen      intended length in octets of the derived
                              key, a positive integer, at most
                              (2^32 - 1) * hLen

   Output:         DK         derived key, a dkLen-octet string

   Steps:

      1. If dkLen &gt; (2^32 - 1) * hLen, output "derived key too long" and
         stop.

      2. Let l be the number of hLen-octet blocks in the derived key,
         rounding up, and let r be the number of octets in the last
         block:

                   l = CEIL (dkLen / hLen) ,
                   r = dkLen - (l - 1) * hLen .

         Here, CEIL (x) is the "ceiling" function, i.e. the smallest
         integer greater than, or equal to, x.

      3. For each block of the derived key apply the function F defined
         below to the password P, the salt S, the iteration count c, and
         the block index to compute the block:

                   T_1 = F (P, S, c, 1) ,
                   T_2 = F (P, S, c, 2) ,
                   ...
                   T_l = F (P, S, c, l) ,

         where the function F is defined as the exclusive-or sum of the
         first c iterates of the underlying pseudorandom function PRF
         applied to the password P and the concatenation of the salt S
         and the block index i:




<span class="grey">Kaliski                      Informational                     [Page 10]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-11" id="page-11" name="page-11"> </a>
<span class="grey"><a href="rfc2898.html">RFC 2898</a>              Password-Based Cryptography         September 2000</span>


                   F (P, S, c, i) = U_1 \xor U_2 \xor ... \xor U_c

         where

                   U_1 = PRF (P, S || INT (i)) ,
                   U_2 = PRF (P, U_1) ,
                   ...
                   U_c = PRF (P, U_{c-1}) .

         Here, INT (i) is a four-octet encoding of the integer i, most
         significant octet first.

      4. Concatenate the blocks and extract the first dkLen octets to
         produce a derived key DK:

                   DK = T_1 || T_2 ||  ...  || T_l&lt;0..r-1&gt;

      5. Output the derived key DK.

   Note. The construction of the function F follows a "belt-and-
   suspenders" approach. The iterates U_i are computed recursively to
   remove a degree of parallelism from an opponent; they are exclusive-
   ored together to reduce concerns about the recursion degenerating
   into a small set of values.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/6.%20Encryption%20Schemes"></a><a class="selflink" href="#section-6" name="section-6">6</a>. Encryption Schemes</span>

   An encryption scheme, in the symmetric setting, consists of an
   encryption operation and a decryption operation, where the encryption
   operation produces a ciphertext from a message under a key, and the
   decryption operation recovers the message from the ciphertext under
   the same key. In a password-based encryption scheme, the key is a
   password.

   A typical application of a password-based encryption scheme is a
   private-key protection method, where the message contains private-key
   information, as in PKCS #8. The encryption schemes defined here would
   be suitable encryption algorithms in that context.

   Two schemes are specified in this section: PBES1 and PBES2. PBES2 is
   recommended for new applications; PBES1 is included only for
   compatibility with existing applications, and is not recommended for
   new applications.








<span class="grey">Kaliski                      Informational                     [Page 11]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-12" id="page-12" name="page-12"> </a>
<span class="grey"><a href="rfc2898.html">RFC 2898</a>              Password-Based Cryptography         September 2000</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/6.1%20%20%20PBES1"></a><a class="selflink" href="#section-6.1" name="section-6.1">6.1</a>   PBES1</span>

   PBES1 combines the PBKDF1 function (<a href="#section-5.1">Section 5.1</a>) with an underlying
   block cipher, which shall be either DES [<a href="#ref-15">15</a>] or RC2(tm) [<a href="#ref-21" title='"A Description of the RC2(r) Encryption Algorithm"'>21</a>] in CBC
   mode [<a href="#ref-16">16</a>]. PBES1 is compatible with the encryption scheme in PKCS #5
   v1.5.

   PBES1 is recommended only for compatibility with existing
   applications, since it supports only two underlying encryption
   schemes, each of which has a key size (56 or 64 bits) that may not be
   large enough for some applications.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/6.1.1%20%20%20Encryption%20Operation"></a><a class="selflink" href="#section-6.1.1" name="section-6.1.1">6.1.1</a>   Encryption Operation</span>

   The encryption operation for PBES1 consists of the following steps,
   which encrypt a message M under a password P to produce a ciphertext
   C:

      1. Select an eight-octet salt S and an iteration count c, as
         outlined in <a href="#section-4">Section 4</a>.

      2. Apply the PBKDF1 key derivation function (<a href="#section-5.1">Section 5.1</a>) to the
         password P, the salt S, and the iteration count c to produce at
         derived key DK of length 16 octets:

                 DK = PBKDF1 (P, S, c, 16) .

      3. Separate the derived key DK into an encryption key K consisting
         of the first eight octets of DK and an initialization vector IV
         consisting of the next eight octets:

                 K   = DK&lt;0..7&gt; ,
                 IV  = DK&lt;8..15&gt; .

      4. Concatenate M and a padding string PS to form an encoded
         message EM:

                 EM = M || PS ,

         where the padding string PS consists of 8-(||M|| mod 8) octets
         each with value 8-(||M|| mod 8). The padding string PS will
         satisfy one of the following statements:

                 PS = 01, if ||M|| mod 8 = 7 ;
                 PS = 02 02, if ||M|| mod 8 = 6 ;
                 ...
                 PS = 08 08 08 08 08 08 08 08, if ||M|| mod 8 = 0.




<span class="grey">Kaliski                      Informational                     [Page 12]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-13" id="page-13" name="page-13"> </a>
<span class="grey"><a href="rfc2898.html">RFC 2898</a>              Password-Based Cryptography         September 2000</span>


         The length in octets of the encoded message will be a multiple
         of eight and it will be possible to recover the message M
         unambiguously from the encoded message. (This padding rule is
         taken from <a href="rfc1423.html">RFC 1423</a> [<a href="#ref-3" title='"Privacy Enhancement for Internet Electronic Mail: Part III: Algorithms, Modes, and Identifiers"'>3</a>].)

      5. Encrypt the encoded message EM with the underlying block cipher
         (DES or RC2) in cipher block chaining mode under the encryption
         key K with initialization vector IV to produce the ciphertext
         C. For DES, the key K shall be considered as a 64-bit encoding
         of a 56-bit DES key with parity bits ignored (see [<a href="#ref-9">9</a>]). For
         RC2, the "effective key bits" shall be 64 bits.

      6.   Output the ciphertext C.

   The salt S and the iteration count c may be conveyed to the party
   performing decryption in an AlgorithmIdentifier value (see <a href="#appendix-A.3">Appendix</a>
   <a href="#appendix-A.3">A.3</a>).

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/6.1.2%20Decryption%20Operation"></a><a class="selflink" href="#section-6.1.2" name="section-6.1.2">6.1.2</a> Decryption Operation</span>

   The decryption operation for PBES1 consists of the following steps,
   which decrypt a ciphertext C under a password P to recover a message
   M:

      1. Obtain the eight-octet salt S and the iteration count c.

      2. Apply the PBKDF1 key derivation function (<a href="#section-5.1">Section 5.1</a>) to the
         password P, the salt S, and the iteration count c to produce a
         derived key DK of length 16 octets:

                 DK = PBKDF1 (P, S, c, 16)

      3. Separate the derived key DK into an encryption key K consisting
         of the first eight octets of DK and an initialization vector IV
         consisting of the next eight octets:

                 K = DK&lt;0..7&gt; ,
                 IV  = DK&lt;8..15&gt; .

      4. Decrypt the ciphertext C with the underlying block cipher (DES
         or RC2) in cipher block chaining mode under the encryption key
         K with initialization vector IV to recover an encoded message
         EM. If the length in octets of the ciphertext C is not a
         multiple of eight, output "decryption error" and stop.

      5. Separate the encoded message EM into a message M and a padding
         string PS:




<span class="grey">Kaliski                      Informational                     [Page 13]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-14" id="page-14" name="page-14"> </a>
<span class="grey"><a href="rfc2898.html">RFC 2898</a>              Password-Based Cryptography         September 2000</span>


                 EM = M || PS ,

         where the padding string PS consists of some number psLen
         octets each with value psLen, where psLen is between 1 and 8.
         If it is not possible to separate the encoded message EM in
         this manner, output "decryption error" and stop.

      6. Output the recovered message M.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/6.2%20PBES2"></a><a class="selflink" href="#section-6.2" name="section-6.2">6.2</a> PBES2</span>

   PBES2 combines a password-based key derivation function, which shall
   be PBKDF2 (<a href="#section-5.2">Section 5.2</a>) for this version of PKCS #5, with an
   underlying encryption scheme (see <a href="#appendix-B.2">Appendix B.2</a> for examples). The key
   length and any other parameters for the underlying encryption scheme
   depend on the scheme.

   PBES2 is recommended for new applications.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/6.2.1%20%20%20Encryption%20Operation"></a><a class="selflink" href="#section-6.2.1" name="section-6.2.1">6.2.1</a>   Encryption Operation</span>

   The encryption operation for PBES2 consists of the following steps,
   which encrypt a message M under a password P to produce a ciphertext
   C, applying a selected key derivation function KDF and a selected
   underlying encryption scheme:

      1. Select a salt S and an iteration count c, as outlined in
         <a href="#section-4">Section 4</a>.

      2. Select the length in octets, dkLen, for the derived key for the
         underlying encryption scheme.

      3. Apply the selected key derivation function to the password P,
         the salt S, and the iteration count c to produce a derived key
         DK of length dkLen octets:

                 DK = KDF (P, S, c, dkLen) .

      4. Encrypt the message M with the underlying encryption scheme
         under the derived key DK to produce a ciphertext C. (This step
         may involve selection of parameters such as an initialization
         vector and padding, depending on the underlying scheme.)

      5. Output the ciphertext C.







<span class="grey">Kaliski                      Informational                     [Page 14]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-15" id="page-15" name="page-15"> </a>
<span class="grey"><a href="rfc2898.html">RFC 2898</a>              Password-Based Cryptography         September 2000</span>


   The salt S, the iteration count c, the key length dkLen, and
   identifiers for the key derivation function and the underlying
   encryption scheme may be conveyed to the party performing decryption
   in an AlgorithmIdentifier value (see <a href="#appendix-A.4">Appendix A.4</a>).

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/6.2.2%20%20%20Decryption%20Operation"></a><a class="selflink" href="#section-6.2.2" name="section-6.2.2">6.2.2</a>   Decryption Operation</span>

   The decryption operation for PBES2 consists of the following steps,
   which decrypt a ciphertext C under a password P to recover a message
   M:

      1. Obtain the salt S for the operation.

      2. Obtain the iteration count c for the key derivation function.

      3. Obtain the key length in octets, dkLen, for the derived key for
         the underlying encryption scheme.

      4. Apply the selected key derivation function to the password P,
         the salt S, and the iteration count c to produce a derived key
         DK of length dkLen octets:

                 DK = KDF (P, S, c, dkLen) .

      5. Decrypt the ciphertext C with the underlying encryption scheme
         under the derived key DK to recover a message M. If the
         decryption function outputs "decryption error," then output
         "decryption error" and stop.

      6. Output the recovered message M.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/7.%20Message%20Authentication%20Schemes"></a><a class="selflink" href="#section-7" name="section-7">7</a>. Message Authentication Schemes</span>

   A message authentication scheme consists of a MAC (message
   authentication code) generation operation and a MAC verification
   operation, where the MAC generation operation produces a message
   authentication code from a message under a key, and the MAC
   verification operation verifies the message authentication code under
   the same key. In a password-based message authentication scheme, the
   key is a password.

   One scheme is specified in this section: PBMAC1.









<span class="grey">Kaliski                      Informational                     [Page 15]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-16" id="page-16" name="page-16"> </a>
<span class="grey"><a href="rfc2898.html">RFC 2898</a>              Password-Based Cryptography         September 2000</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/7.1%20PBMAC1"></a><a class="selflink" href="#section-7.1" name="section-7.1">7.1</a> PBMAC1</span>

   PBMAC1 combines a password-based key derivation function, which shall
   be PBKDF2  (<a href="#section-5.2">Section 5.2</a>) for this version of PKCS #5, with an
   underlying message authentication scheme (see <a href="#appendix-B.3">Appendix B.3</a> for an
   example). The key length and any other parameters for the underlying
   message authentication scheme depend on the scheme.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/7.1.1%20MAC%20Generation"></a><a class="selflink" href="#section-7.1.1" name="section-7.1.1">7.1.1</a> MAC Generation</span>

   The MAC generation operation for PBMAC1 consists of the following
   steps, which process a message M under a password P to generate a
   message authentication code T, applying a selected key derivation
   function KDF and a selected underlying message authentication scheme:

      1. Select a salt S and an iteration count c, as outlined in
         <a href="#section-4">Section 4</a>.

      2. Select a key length in octets, dkLen, for the derived key for
         the underlying message authentication function.

      3. Apply the selected key derivation function to the password P,
         the salt S, and the iteration count c to produce a derived key
         DK of length dkLen octets:

                 DK = KDF (P, S, c, dkLen) .

      4. Process the message M with the underlying message
         authentication scheme under the derived key DK to generate a
         message authentication code T.

      5. Output the message authentication code T.

   The salt S, the iteration count c, the key length dkLen, and
   identifiers for the key derivation function and underlying message
   authentication scheme may be conveyed to the party performing
   verification in an AlgorithmIdentifier value (see <a href="#appendix-A.5">Appendix A.5</a>).

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/7.1.2%20%20%20MAC%20Verification"></a><a class="selflink" href="#section-7.1.2" name="section-7.1.2">7.1.2</a>   MAC Verification</span>

   The MAC verification operation for PBMAC1 consists of the following
   steps, which process a message M under a password P to verify a
   message authentication code T:

      1. Obtain the salt S and the iteration count c.

      2. Obtain the key length in octets, dkLen, for the derived key for
         the underlying message authentication scheme.



<span class="grey">Kaliski                      Informational                     [Page 16]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-17" id="page-17" name="page-17"> </a>
<span class="grey"><a href="rfc2898.html">RFC 2898</a>              Password-Based Cryptography         September 2000</span>


      3. Apply the selected key derivation function to the password P,
         the salt S, and the iteration count c to produce a derived key
         DK of length dkLen octets:

                 DK = KDF (P, S, c, dkLen) .

      4. Process the message M with the underlying message
         authentication scheme under the derived key DK to verify the
         message authentication code T.

      5. If the message authentication code verifies, output "correct";
         else output "incorrect."

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/8.%20Security%20Considerations"></a><a class="selflink" href="#section-8" name="section-8">8</a>. Security Considerations</span>

   Password-based cryptography is generally limited in the security that
   it can provide, particularly for methods such as those defined in
   this document where off-line password search is possible. While the
   use of salt and iteration count can increase the complexity of attack
   (see <a href="#section-4">Section 4</a> for recommendations), it is essential that passwords
   are selected well, and relevant guidelines (e.g., [<a href="#ref-17">17</a>]) should be
   taken into account. It is also important that passwords be protected
   well if stored.

   In general, different keys should be derived from a password for
   different uses to minimize the possibility of unintended
   interactions. For password-based encryption with a single algorithm,
   a random salt is sufficient to ensure that different keys will be
   produced. In certain other situations, as outlined in <a href="#section-4">Section 4</a>, a
   structured salt is necessary. The recommendations in <a href="#section-4">Section 4</a> should
   thus be taken into account when selecting the salt value.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/9.%20Author%27s%20Address"></a><a class="selflink" href="#section-9" name="section-9">9</a>. Author's Address</span>

   Burt Kaliski
   RSA Laboratories
   20 Crosby Drive
   Bedford, MA 01730 USA

   EMail: bkaliski@rsasecurity.com











<span class="grey">Kaliski                      Informational                     [Page 17]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-18" id="page-18" name="page-18"> </a>
<span class="grey"><a href="rfc2898.html">RFC 2898</a>              Password-Based Cryptography         September 2000</span>


APPENDICES

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/A.%20ASN.1%20Syntax"></a><a class="selflink" href="#appendix-A" name="appendix-A">A</a>. ASN.1 Syntax</span>

   This section defines ASN.1 syntax for the key derivation functions,
   the encryption schemes, the message authentication scheme, and
   supporting techniques. The intended application of these definitions
   includes PKCS #8 and other syntax for key management, encrypted data,
   and integrity-protected data. (Various aspects of ASN.1 are specified
   in several ISO/IEC standards [<a href="#ref-9">9</a>][10][<a href="#ref-11">11</a>][12][<a href="#ref-13">13</a>][14].)

   The object identifier pkcs-5 identifies the arc of the OID tree from
   which the PKCS #5-specific OIDs in this section are derived:

   rsadsi OBJECT IDENTIFIER ::= {iso(1) member-body(2) us(840) 113549}
   pkcs OBJECT IDENTIFIER   ::= {rsadsi 1}
   pkcs-5 OBJECT IDENTIFIER ::= {pkcs 5}

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/A.1%20%20%20PBKDF1"></a><a class="selflink" href="#appendix-A.1" name="appendix-A.1">A.1</a>   PBKDF1</span>

   No object identifier is given for PBKDF1, as the object identifiers
   for PBES1 are sufficient for existing applications and PBKDF2 is
   recommended for new applications.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/A.2%20%20%20PBKDF2"></a><a class="selflink" href="#appendix-A.2" name="appendix-A.2">A.2</a>   PBKDF2</span>

   The object identifier id-PBKDF2 identifies the PBKDF2 key derivation
   function (<a href="#section-5.2">Section 5.2</a>).

   id-PBKDF2 OBJECT IDENTIFIER ::= {pkcs-5 12}

   The parameters field associated with this OID in an
   AlgorithmIdentifier shall have type PBKDF2-params:

   PBKDF2-params ::= SEQUENCE {
       salt CHOICE {
           specified OCTET STRING,
           otherSource AlgorithmIdentifier {{PBKDF2-SaltSources}}
       },
       iterationCount INTEGER (1..MAX),
       keyLength INTEGER (1..MAX) OPTIONAL,
       prf AlgorithmIdentifier {{PBKDF2-PRFs}} DEFAULT
       algid-hmacWithSHA1 }

   The fields of type PKDF2-params have the following meanings:






<span class="grey">Kaliski                      Informational                     [Page 18]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-19" id="page-19" name="page-19"> </a>
<span class="grey"><a href="rfc2898.html">RFC 2898</a>              Password-Based Cryptography         September 2000</span>


   -  salt specifies the salt value, or the source of the salt value.
      It shall either be an octet string or an algorithm ID with an OID
      in the set PBKDF2-SaltSources, which is reserved for future
      versions of PKCS #5.

      The salt-source approach is intended to indicate how the salt
      value is to be generated as a function of parameters in the
      algorithm ID, application data, or both. For instance, it may
      indicate that the salt value is produced from the encoding of a
      structure that specifies detailed information about the derived
      key as suggested in <a href="#section-4.1">Section 4.1</a>. Some of the information may be
      carried elsewhere, e.g., in the encryption algorithm ID. However,
      such facilities are deferred to a future version of PKCS #5.

      In this version, an application may achieve the benefits mentioned
      in <a href="#section-4.1">Section 4.1</a> by choosing a particular interpretation of the salt
      value in the specified alternative.

   PBKDF2-SaltSources ALGORITHM-IDENTIFIER ::= { ... }

   -  iterationCount specifies the iteration count. The maximum
      iteration count allowed depends on the implementation. It is
      expected that implementation profiles may further constrain the
      bounds.

   -  keyLength, an optional field, is the length in octets of the
      derived key. The maximum key length allowed depends on the
      implementation; it is expected that implementation profiles may
      further constrain the bounds. The field is provided for
      convenience only; the key length is not cryptographically
      protected. If there is concern about interaction between
      operations with different key lengths for a given salt (see
      <a href="#section-4.1">Section 4.1</a>), the salt should distinguish among the different key
      lengths.

   -  prf identifies the underlying pseudorandom function. It shall be
      an algorithm ID with an OID in the set PBKDF2-PRFs, which for this
      version of PKCS #5 shall consist of id-hmacWithSHA1 (see <a href="#appendix-B.1.1">Appendix</a>
      <a href="#appendix-B.1.1">B.1.1</a>) and any other OIDs defined by the application.

      PBKDF2-PRFs ALGORITHM-IDENTIFIER ::=
          { {NULL IDENTIFIED BY id-hmacWithSHA1}, ... }

      The default pseudorandom function is HMAC-SHA-1:

      algid-hmacWithSHA1 AlgorithmIdentifier {{PBKDF2-PRFs}} ::=
          {algorithm id-hmacWithSHA1, parameters NULL : NULL}




<span class="grey">Kaliski                      Informational                     [Page 19]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-20" id="page-20" name="page-20"> </a>
<span class="grey"><a href="rfc2898.html">RFC 2898</a>              Password-Based Cryptography         September 2000</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/A.3%20PBES1"></a><a class="selflink" href="#appendix-A.3" name="appendix-A.3">A.3</a> PBES1</span>

   Different object identifiers identify the PBES1 encryption scheme
   (<a href="#section-6.1">Section 6.1</a>) according to the underlying hash function in the key
   derivation function and the underlying block cipher, as summarized in
   the following table:

        Hash Function  Block Cipher      OID
             MD2           DES         pkcs-5.1
             MD2           RC2         pkcs-5.4
             MD5           DES         pkcs-5.3
             MD5           RC2         pkcs-5.6
            SHA-1          DES         pkcs-5.10
            SHA-1          RC2         pkcs-5.11

   pbeWithMD2AndDES-CBC OBJECT IDENTIFIER ::= {pkcs-5 1}
   pbeWithMD2AndRC2-CBC OBJECT IDENTIFIER ::= {pkcs-5 4}
   pbeWithMD5AndDES-CBC OBJECT IDENTIFIER ::= {pkcs-5 3}
   pbeWithMD5AndRC2-CBC OBJECT IDENTIFIER ::= {pkcs-5 6}
   pbeWithSHA1AndDES-CBC OBJECT IDENTIFIER ::= {pkcs-5 10}
   pbeWithSHA1AndRC2-CBC OBJECT IDENTIFIER ::= {pkcs-5 11}

   For each OID, the parameters field associated with the OID in an
   AlgorithmIdentifier shall have type PBEParameter:

   PBEParameter ::= SEQUENCE {
       salt OCTET STRING (SIZE(8)),
       iterationCount INTEGER }

   The fields of type PBEParameter have the following meanings:

   -  salt specifies the salt value, an eight-octet string.

   -  iterationCount specifies the iteration count.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/A.4%20PBES2"></a><a class="selflink" href="#appendix-A.4" name="appendix-A.4">A.4</a> PBES2</span>

   The object identifier id-PBES2 identifies the PBES2 encryption scheme
   (<a href="#section-6.2">Section 6.2</a>).

   id-PBES2 OBJECT IDENTIFIER ::= {pkcs-5 13}

   The parameters field associated with this OID in an
   AlgorithmIdentifier shall have type PBES2-params:

   PBES2-params ::= SEQUENCE {
       keyDerivationFunc AlgorithmIdentifier {{PBES2-KDFs}},
       encryptionScheme AlgorithmIdentifier {{PBES2-Encs}} }



<span class="grey">Kaliski                      Informational                     [Page 20]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-21" id="page-21" name="page-21"> </a>
<span class="grey"><a href="rfc2898.html">RFC 2898</a>              Password-Based Cryptography         September 2000</span>


   The fields of type PBES2-params have the following meanings:

   -  keyDerivationFunc identifies the underlying key derivation
      function. It shall be an algorithm ID with an OID in the set
      PBES2-KDFs, which for this version of PKCS #5 shall consist of
      id-PBKDF2 (Appendix A.2).

   PBES2-KDFs ALGORITHM-IDENTIFIER ::=
       { {PBKDF2-params IDENTIFIED BY id-PBKDF2}, ... }

   -  encryptionScheme identifies the underlying encryption scheme. It
      shall be an algorithm ID with an OID in the set PBES2-Encs, whose
      definition is left to the application. Example underlying
      encryption schemes are given in <a href="#appendix-B.2">Appendix B.2</a>.

   PBES2-Encs ALGORITHM-IDENTIFIER ::= { ... }

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/A.5%20PBMAC1"></a><a class="selflink" href="#appendix-A.5" name="appendix-A.5">A.5</a> PBMAC1</span>

   The object identifier id-PBMAC1 identifies the PBMAC1 message
   authentication scheme (<a href="#section-7.1">Section 7.1</a>).

   id-PBMAC1 OBJECT IDENTIFIER ::= {pkcs-5 14}

   The parameters field associated with this OID in an
   AlgorithmIdentifier shall have type PBMAC1-params:

   PBMAC1-params ::=  SEQUENCE {
       keyDerivationFunc AlgorithmIdentifier {{PBMAC1-KDFs}},
       messageAuthScheme AlgorithmIdentifier {{PBMAC1-MACs}} }

   The keyDerivationFunc field has the same meaning as the corresponding
   field of PBES2-params (Appendix A.4) except that the set of OIDs is
   PBMAC1-KDFs.

   PBMAC1-KDFs ALGORITHM-IDENTIFIER ::=
       { {PBKDF2-params IDENTIFIED BY id-PBKDF2}, ... }

   The messageAuthScheme field identifies the underlying message
   authentication scheme. It shall be an algorithm ID with an OID in the
   set PBMAC1-MACs, whose definition is left to the application. Example
   underlying encryption schemes are given in <a href="#appendix-B.3">Appendix B.3</a>.

   PBMAC1-MACs ALGORITHM-IDENTIFIER ::= { ... }







<span class="grey">Kaliski                      Informational                     [Page 21]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-22" id="page-22" name="page-22"> </a>
<span class="grey"><a href="rfc2898.html">RFC 2898</a>              Password-Based Cryptography         September 2000</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/B.%20Supporting%20Techniques"></a><a class="selflink" href="#appendix-B" name="appendix-B">B</a>. Supporting Techniques</span>

   This section gives several examples of underlying functions and
   schemes supporting the password-based schemes in Sections <a href="#section-5">5</a>, <a href="#section-6">6</a> and <a href="#section-7">7</a>.

   While these supporting techniques are appropriate for applications to
   implement, none of them is required to be implemented. It is
   expected, however, that profiles for PKCS #5 will be developed that
   specify particular supporting techniques.

   This section also gives object identifiers for the supporting
   techniques.  The object identifiers digestAlgorithm and
   encryptionAlgorithm identify the arcs from which certain algorithm
   OIDs referenced in this section are derived:

   digestAlgorithm OBJECT IDENTIFIER ::= {rsadsi 2}
   encryptionAlgorithm OBJECT IDENTIFIER ::= {rsadsi 3}

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/B.1%20Pseudorandom%20functions"></a><a class="selflink" href="#appendix-B.1" name="appendix-B.1">B.1</a> Pseudorandom functions</span>

   An example pseudorandom function for PBKDF2 (<a href="#section-5.2">Section 5.2</a>) is HMAC-
   SHA-1.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/B.1.1%20HMAC-SHA-1"></a><a class="selflink" href="#appendix-B.1.1" name="appendix-B.1.1">B.1.1</a> HMAC-SHA-1</span>

   HMAC-SHA-1 is the pseudorandom function corresponding to the HMAC
   message authentication code [<a href="#ref-7" title='"HMAC: Keyed-Hashing for Message Authentication"'>7</a>] based on the SHA-1 hash function
   [<a href="#ref-18">18</a>].  The pseudorandom function is the same function by which the
   message authentication code is computed, with a full-length output.
   (The first argument to the pseudorandom function PRF serves as HMAC's
   "key," and the second serves as HMAC's "text." In the case of PBKDF2,
   the "key" is thus the password and the "text" is the salt.)  HMAC-
   SHA-1 has a variable key length and a 20-octet (160-bit) output
   value.

   Although the length of the key to HMAC-SHA-1 is essentially
   unbounded, the effective search space for pseudorandom function
   outputs may be limited by the structure of the function. In
   particular, when the key is longer than 512 bits, HMAC-SHA-1 will
   first hash it to 160 bits. Thus, even if a long derived key
   consisting of several pseudorandom function outputs is produced from
   a key, the effective search space for the derived key will be at most
   160 bits. Although the specific limitation for other key sizes
   depends on details of the HMAC construction, one should assume, to be
   conservative, that the effective search space is limited to 160 bits
   for other key sizes as well.





<span class="grey">Kaliski                      Informational                     [Page 22]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-23" id="page-23" name="page-23"> </a>
<span class="grey"><a href="rfc2898.html">RFC 2898</a>              Password-Based Cryptography         September 2000</span>


   (The 160-bit limitation should not generally pose a practical
   limitation in the case of password-based cryptography, since the
   search space for a password is unlikely to be greater than 160 bits.)

   The object identifier id-hmacWithSHA1 identifies the HMAC-SHA-1
   pseudorandom function:

   id-hmacWithSHA1 OBJECT IDENTIFIER ::= {digestAlgorithm 7}

   The parameters field associated with this OID in an
   AlgorithmIdentifier shall have type NULL. This object identifier is
   employed in the object set PBKDF2-PRFs (Appendix A.2).

   Note. Although HMAC-SHA-1 was designed as a message authentication
   code, its proof of security is readily modified to accommodate
   requirements for a pseudorandom function, under stronger assumptions.

   A hash function may also meet the requirements of a pseudorandom
   function under certain assumptions. For instance, the direct
   application of a hash function to to the concatenation of the "key"
   and the "text" may be appropriate, provided that "text" has
   appropriate structure to prevent certain attacks. HMAC-SHA-1 is
   preferable, however, because it treats "key" and "text" as separate
   arguments and does not require "text" to have any structure.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/B.2%20Encryption%20Schemes"></a><a class="selflink" href="#appendix-B.2" name="appendix-B.2">B.2</a> Encryption Schemes</span>

   Example pseudorandom functions for PBES2 (<a href="#section-6.2">Section 6.2</a>) are DES-CBC-
   Pad, DES-EDE2-CBC-Pad, RC2-CBC-Pad, and RC5-CBC-Pad.

   The object identifiers given in this section are intended to be
   employed in the object set PBES2-Encs (Appendix A.4).

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/B.2.1%20DES-CBC-Pad"></a><a class="selflink" href="#appendix-B.2.1" name="appendix-B.2.1">B.2.1</a> DES-CBC-Pad</span>

   DES-CBC-Pad is single-key DES [<a href="#ref-15">15</a>] in CBC mode [<a href="#ref-16">16</a>] with the <a href="rfc1423.html">RFC 1423</a>
   padding operation (see <a href="#section-6.1.1">Section 6.1.1</a>). DES-CBC-Pad has an eight-octet
   encryption key and an eight-octet initialization vector.  The key is
   considered as a 64-bit encoding of a 56-bit DES key with parity bits
   ignored.

   The object identifier desCBC (defined in the NIST/OSI Implementors'
   Workshop agreements) identifies the DES-CBC-Pad encryption scheme:

   desCBC OBJECT IDENTIFIER ::=
       {iso(1) identified-organization(3) oiw(14) secsig(3)
        algorithms(2) 7}




<span class="grey">Kaliski                      Informational                     [Page 23]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-24" id="page-24" name="page-24"> </a>
<span class="grey"><a href="rfc2898.html">RFC 2898</a>              Password-Based Cryptography         September 2000</span>


   The parameters field associated with this OID in an
   AlgorithmIdentifier shall have type OCTET STRING (SIZE(8)),
   specifying the initialization vector for CBC mode.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/B.2.2%20DES-EDE3-CBC-Pad"></a><a class="selflink" href="#appendix-B.2.2" name="appendix-B.2.2">B.2.2</a> DES-EDE3-CBC-Pad</span>

   DES-EDE3-CBC-Pad is three-key triple-DES in CBC mode [<a href="#ref-1" title="Triple Data Encryption Algorithm Modes of Operation. Working draft">1</a>] with the <a href="rfc1423.html">RFC</a>
   <a href="rfc1423.html">1423</a> padding operation. DES-EDE3-CBC-Pad has a 24-octet encryption
   key and an eight-octet initialization vector. The key is considered
   as the concatenation of three eight-octet keys, each of which is a
   64-bit encoding of a 56-bit DES key with parity bits ignored.

   The object identifier des-EDE3-CBC identifies the DES-EDE3-CBC-Pad
   encryption scheme:

   des-EDE3-CBC OBJECT IDENTIFIER ::= {encryptionAlgorithm 7}

   The parameters field associated with this OID in an
   AlgorithmIdentifier shall have type OCTET STRING (SIZE(8)),
   specifying the initialization vector for CBC mode.

   Note. An OID for DES-EDE3-CBC without padding is given in ANSI X9.52
   [<a href="#ref-1" title="Triple Data Encryption Algorithm Modes of Operation. Working draft">1</a>]; the one given here is preferred since it specifies padding.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/B.2.3%20RC2-CBC-Pad"></a><a class="selflink" href="#appendix-B.2.3" name="appendix-B.2.3">B.2.3</a> RC2-CBC-Pad</span>

   RC2-CBC-Pad is the RC2(tm) encryption algorithm [<a href="#ref-21" title='"A Description of the RC2(r) Encryption Algorithm"'>21</a>] in CBC mode with
   the <a href="rfc1423.html">RFC 1423</a> padding operation. RC2-CBC-Pad has a variable key
   length, from one to 128 octets, a separate "effective key bits"
   parameter from one to 1024 bits that limits the effective search
   space independent of the key length, and an eight-octet
   initialization vector.

   The object identifier rc2CBC identifies the RC2-CBC-Pad encryption
   scheme:

   rc2CBC OBJECT IDENTIFIER ::= {encryptionAlgorithm 2}

   The parameters field associated with OID in an AlgorithmIdentifier
   shall have type RC2-CBC-Parameter:

   RC2-CBC-Parameter ::= SEQUENCE {
       rc2ParameterVersion INTEGER OPTIONAL,
       iv OCTET STRING (SIZE(8)) }







<span class="grey">Kaliski                      Informational                     [Page 24]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-25" id="page-25" name="page-25"> </a>
<span class="grey"><a href="rfc2898.html">RFC 2898</a>              Password-Based Cryptography         September 2000</span>


   The fields of type RC2-CBCParameter have the following meanings:

   -  rc2ParameterVersion is a proprietary RSA Security Inc. encoding of
      the "effective key bits" for RC2. The following encodings are
      defined:

         Effective Key Bits         Encoding
                 40                    160
                 64                    120
                128                     58
               b &gt;= 256                  b

   If the rc2ParameterVersion field is omitted, the "effective key bits"
   defaults to 32. (This is for backward compatibility with certain very
   old implementations.)

   -  iv is the eight-octet initialization vector.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/B.2.4%20RC5-CBC-Pad"></a><a class="selflink" href="#appendix-B.2.4" name="appendix-B.2.4">B.2.4</a> RC5-CBC-Pad</span>

   RC5-CBC-Pad is the RC5(tm) encryption algorithm [<a href="#ref-20" title="Springer-Verlag">20</a>] in CBC mode with
   a generalization of the <a href="rfc1423.html">RFC 1423</a> padding operation. This scheme is
   fully specified in [<a href="#ref-2" title='"The RC5, RC5-CBC, RC5-CBC-Pad, and RC5-CTS Algorithms"'>2</a>]. RC5-CBC-Pad has a variable key length, from 0
   to 256 octets, and supports both a 64-bit block size and a 128-bit
   block size. For the former, it has an eight-octet initialization
   vector, and for the latter, a 16-octet initialization vector.
   RC5-CBC-Pad also has a variable number of "rounds" in the encryption
   operation, from 8 to 127.

   Note: The generalization of the padding operation is as follows. For
   RC5 with a 64-bit block size, the padding string is as defined in <a href="rfc1423.html">RFC</a>
   <a href="rfc1423.html">1423</a>. For RC5 with a 128-bit block size, the padding string consists
   of 16-(||M|| mod 16) octets each with value 16-(||M|| mod 16).

   The object identifier rc5-CBC-PAD [<a href="#ref-2" title='"The RC5, RC5-CBC, RC5-CBC-Pad, and RC5-CTS Algorithms"'>2</a>] identifies RC5-CBC-Pad
   encryption scheme:

   rc5-CBC-PAD OBJECT IDENTIFIER ::= {encryptionAlgorithm 9}

   The parameters field associated with this OID in an
   AlgorithmIdentifier shall have type RC5-CBC-Parameters:

   RC5-CBC-Parameters ::= SEQUENCE {
       version INTEGER {v1-0(16)} (v1-0),
       rounds INTEGER (8..127),
       blockSizeInBits INTEGER (64 | 128),
       iv OCTET STRING OPTIONAL }




<span class="grey">Kaliski                      Informational                     [Page 25]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-26" id="page-26" name="page-26"> </a>
<span class="grey"><a href="rfc2898.html">RFC 2898</a>              Password-Based Cryptography         September 2000</span>


   The fields of type RC5-CBC-Parameters have the following meanings:

   -  version is the version of the algorithm, which shall be v1-0.

   -  rounds is the number of rounds in the encryption operation, which
      shall be between 8 and 127.

   -  blockSizeInBits is the block size in bits, which shall be 64 or
      128.

   -  iv is the initialization vector, an eight-octet string for 64-bit
      RC5 and a 16-octet string for 128-bit RC5. The default is a string
      of the appropriate length consisting of zero octets.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/B.3%20Message%20Authentication%20Schemes"></a><a class="selflink" href="#appendix-B.3" name="appendix-B.3">B.3</a> Message Authentication Schemes</span>

   An example message authentication scheme for PBMAC1 (<a href="#section-7.1">Section 7.1</a>) is
   HMAC-SHA-1.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/B.3.1%20HMAC-SHA-1"></a><a class="selflink" href="#appendix-B.3.1" name="appendix-B.3.1">B.3.1</a> HMAC-SHA-1</span>

   HMAC-SHA-1 is the HMAC message authentication scheme [<a href="#ref-7" title='"HMAC: Keyed-Hashing for Message Authentication"'>7</a>] based on the
   SHA-1 hash function [<a href="#ref-18">18</a>]. HMAC-SHA-1 has a variable key length and a
   20-octet (160-bit) message authentication code.

   The object identifier id-hmacWithSHA1 (see <a href="#appendix-B.1.1">Appendix B.1.1</a>) identifies
   the HMAC-SHA-1 message authentication scheme. (The object identifier
   is the same for both the pseudorandom function and the message
   authentication scheme; the distinction is to be understood by
   context.) This object identifier is intended to be employed in the
   object set PBMAC1-Macs (Appendix A.5).

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/C.%20ASN.1%20Module"></a><a class="selflink" href="#appendix-C" name="appendix-C">C</a>. ASN.1 Module</span>

   For reference purposes, the ASN.1 syntax in the preceding sections is
   presented as an ASN.1 module here.

   -- PKCS #5 v2.0 ASN.1 Module
   -- Revised March 25, 1999

   -- This module has been checked for conformance with the
   -- ASN.1 standard by the OSS ASN.1 Tools

   PKCS5v2-0 {iso(1) member-body(2) us(840) rsadsi(113549)
       pkcs(1) pkcs-5(5) modules(16) pkcs5v2-0(1)}

   DEFINITIONS ::= BEGIN




<span class="grey">Kaliski                      Informational                     [Page 26]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-27" id="page-27" name="page-27"> </a>
<span class="grey"><a href="rfc2898.html">RFC 2898</a>              Password-Based Cryptography         September 2000</span>


   -- Basic object identifiers

   rsadsi OBJECT IDENTIFIER ::= {iso(1) member-body(2) us(840) 113549}
   pkcs OBJECT IDENTIFIER ::= {rsadsi 1}

   pkcs-5 OBJECT IDENTIFIER ::= {pkcs 5}

   -- Basic types and classes

   AlgorithmIdentifier { ALGORITHM-IDENTIFIER:InfoObjectSet } ::=
     SEQUENCE {
       algorithm ALGORITHM-IDENTIFIER.&amp;id({InfoObjectSet}),
       parameters ALGORITHM-IDENTIFIER.&amp;Type({InfoObjectSet}
       {@algorithm}) OPTIONAL
   }

   ALGORITHM-IDENTIFIER ::= TYPE-IDENTIFIER

   -- PBKDF2

   PBKDF2Algorithms ALGORITHM-IDENTIFIER ::=
       { {PBKDF2-params IDENTIFIED BY id-PBKDF2}, ...}

   id-PBKDF2 OBJECT IDENTIFIER ::= {pkcs-5 12}

   algid-hmacWithSHA1 AlgorithmIdentifier {{PBKDF2-PRFs}} ::=
       {algorithm id-hmacWithSHA1, parameters NULL : NULL}

   PBKDF2-params ::= SEQUENCE {
       salt CHOICE {
         specified OCTET STRING,
         otherSource AlgorithmIdentifier {{PBKDF2-SaltSources}}
       },
       iterationCount INTEGER (1..MAX),
       keyLength INTEGER (1..MAX) OPTIONAL,
       prf AlgorithmIdentifier {{PBKDF2-PRFs}} DEFAULT
       algid-hmacWithSHA1
   }

   PBKDF2-SaltSources ALGORITHM-IDENTIFIER ::= { ... }

   PBKDF2-PRFs ALGORITHM-IDENTIFIER ::=
       { {NULL IDENTIFIED BY id-hmacWithSHA1}, ... }

   -- PBES1


   PBES1Algorithms ALGORITHM-IDENTIFIER ::= {



<span class="grey">Kaliski                      Informational                     [Page 27]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-28" id="page-28" name="page-28"> </a>
<span class="grey"><a href="rfc2898.html">RFC 2898</a>              Password-Based Cryptography         September 2000</span>


       {PBEParameter IDENTIFIED BY pbeWithMD2AndDES-CBC}  |
       {PBEParameter IDENTIFIED BY pbeWithMD2AndRC2-CBC}  |
       {PBEParameter IDENTIFIED BY pbeWithMD5AndDES-CBC}  |
       {PBEParameter IDENTIFIED BY pbeWithMD5AndRC2-CBC}  |
       {PBEParameter IDENTIFIED BY pbeWithSHA1AndDES-CBC} |
       {PBEParameter IDENTIFIED BY pbeWithSHA1AndRC2-CBC},
       ...
   }

   pbeWithMD2AndDES-CBC OBJECT IDENTIFIER ::= {pkcs-5 1}
   pbeWithMD2AndRC2-CBC OBJECT IDENTIFIER ::= {pkcs-5 4}
   pbeWithMD5AndDES-CBC OBJECT IDENTIFIER ::= {pkcs-5 3}
   pbeWithMD5AndRC2-CBC OBJECT IDENTIFIER ::= {pkcs-5 6}
   pbeWithSHA1AndDES-CBC OBJECT IDENTIFIER ::= {pkcs-5 10}
   pbeWithSHA1AndRC2-CBC OBJECT IDENTIFIER ::= {pkcs-5 11}

   PBEParameter ::= SEQUENCE {
       salt OCTET STRING (SIZE(8)),
       iterationCount INTEGER
   }

   -- PBES2

   PBES2Algorithms ALGORITHM-IDENTIFIER ::=
       { {PBES2-params IDENTIFIED BY id-PBES2}, ...}

   id-PBES2 OBJECT IDENTIFIER ::= {pkcs-5 13}

   PBES2-params ::= SEQUENCE {
       keyDerivationFunc AlgorithmIdentifier {{PBES2-KDFs}},
       encryptionScheme AlgorithmIdentifier {{PBES2-Encs}}
   }

   PBES2-KDFs ALGORITHM-IDENTIFIER ::=
       { {PBKDF2-params IDENTIFIED BY id-PBKDF2}, ... }

   PBES2-Encs ALGORITHM-IDENTIFIER ::= { ... }

   -- PBMAC1

   PBMAC1Algorithms ALGORITHM-IDENTIFIER ::=
       { {PBMAC1-params IDENTIFIED BY id-PBMAC1}, ...}

   id-PBMAC1 OBJECT IDENTIFIER ::= {pkcs-5 14}

   PBMAC1-params ::=  SEQUENCE {
       keyDerivationFunc AlgorithmIdentifier {{PBMAC1-KDFs}},
       messageAuthScheme AlgorithmIdentifier {{PBMAC1-MACs}}



<span class="grey">Kaliski                      Informational                     [Page 28]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-29" id="page-29" name="page-29"> </a>
<span class="grey"><a href="rfc2898.html">RFC 2898</a>              Password-Based Cryptography         September 2000</span>


   }

   PBMAC1-KDFs ALGORITHM-IDENTIFIER ::=
       { {PBKDF2-params IDENTIFIED BY id-PBKDF2}, ... }

   PBMAC1-MACs ALGORITHM-IDENTIFIER ::= { ... }

   -- Supporting techniques

   digestAlgorithm OBJECT IDENTIFIER     ::= {rsadsi 2}
   encryptionAlgorithm OBJECT IDENTIFIER ::= {rsadsi 3}

   SupportingAlgorithms ALGORITHM-IDENTIFIER ::= {
       {NULL IDENTIFIED BY id-hmacWithSHA1} |
       {OCTET STRING (SIZE(8)) IDENTIFIED BY desCBC} |
       {OCTET STRING (SIZE(8)) IDENTIFIED BY des-EDE3-CBC} |
       {RC2-CBC-Parameter IDENTIFIED BY rc2CBC} |
       {RC5-CBC-Parameters IDENTIFIED BY rc5-CBC-PAD},
       ...
   }

   id-hmacWithSHA1 OBJECT IDENTIFIER ::= {digestAlgorithm 7}

   desCBC OBJECT IDENTIFIER ::=
       {iso(1) identified-organization(3) oiw(14) secsig(3)
        algorithms(2) 7} -- from OIW

   des-EDE3-CBC OBJECT IDENTIFIER ::= {encryptionAlgorithm 7}

   rc2CBC OBJECT IDENTIFIER ::= {encryptionAlgorithm 2}

   RC2-CBC-Parameter ::= SEQUENCE {
       rc2ParameterVersion INTEGER OPTIONAL,
       iv OCTET STRING (SIZE(8))
   }

   rc5-CBC-PAD OBJECT IDENTIFIER ::= {encryptionAlgorithm 9}

   RC5-CBC-Parameters ::= SEQUENCE {
       version INTEGER {v1-0(16)} (v1-0),
       rounds INTEGER (8..127),
       blockSizeInBits INTEGER (64 | 128),
       iv OCTET STRING OPTIONAL
   }

   END





<span class="grey">Kaliski                      Informational                     [Page 29]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-30" id="page-30" name="page-30"> </a>
<span class="grey"><a href="rfc2898.html">RFC 2898</a>              Password-Based Cryptography         September 2000</span>


Intellectual Property Considerations

   RSA Security makes no patent claims on the general constructions
   described in this document, although specific underlying techniques
   may be covered. Among the underlying techniques, the RC5 encryption
   algorithm (Appendix B.2.4) is protected by U.S. Patents 5,724,428
   [<a href="#ref-22" title="March 3">22</a>] and 5,835,600 [<a href="#ref-23" title="November 10">23</a>].

   RC2 and RC5 are trademarks of RSA Security.

   License to copy this document is granted provided that it is
   identified as RSA Security Inc. Public-Key Cryptography Standards
   (PKCS) in all material mentioning or referencing this document.

   RSA Security makes no representations regarding intellectual property
   claims by other parties. Such determination is the responsibility of
   the user.

Revision history

   Versions 1.0-1.3

      Versions 1.0-1.3 were distributed to participants in RSA Data
      Security Inc.'s Public-Key Cryptography Standards meetings in
      February and March 1991.

   Version 1.4

      Version 1.4 was part of the June 3, 1991 initial public release of
      PKCS. Version 1.4 was published as NIST/OSI Implementors' Workshop
      document SEC-SIG-91-20.

   Version 1.5

      Version 1.5 incorporated several editorial changes, including
      updates to the references and the addition of a revision history.

   Version 2.0

      Version 2.0 incorporates major editorial changes in terms of the
      document structure, and introduces the PBES2 encryption scheme,
      the PBMAC1 message authentication scheme, and independent
      password-based key derivation functions. This version continues to
      support the encryption process in version 1.5.







<span class="grey">Kaliski                      Informational                     [Page 30]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-31" id="page-31" name="page-31"> </a>
<span class="grey"><a href="rfc2898.html">RFC 2898</a>              Password-Based Cryptography         September 2000</span>


References

   [<a id="ref-1" name="ref-1">1</a>]  American National Standard X9.52 - 1998, Triple Data Encryption
        Algorithm Modes of Operation. Working draft, Accredited
        Standards Committee X9, July 27, 1998.

   [<a id="ref-2" name="ref-2">2</a>]  Baldwin, R. and R. Rivest, "The RC5, RC5-CBC, RC5-CBC-Pad, and
        RC5-CTS Algorithms", <a href="rfc2040.html">RFC 2040</a>, October 1996.

   [<a id="ref-3" name="ref-3">3</a>]  Balenson, D., "Privacy Enhancement for Internet Electronic Mail:
        Part III: Algorithms, Modes, and Identifiers", <a href="rfc1423.html">RFC 1423</a>,
        February 1993.

   [<a id="ref-4" name="ref-4">4</a>]  S.M. Bellovin and M. Merritt. Encrypted key exchange:
        Password-based protocols secure against dictionary attacks. In
        Proceedings of the 1992 IEEE Computer Society Conference on
        Research in Security and Privacy, pages 72-84, IEEE Computer
        Society, 1992.

   [<a id="ref-5" name="ref-5">5</a>]  D. Jablon. Strong password-only authenticated key exchange. ACM
        Computer Communications Review, October 1996.

   [<a id="ref-6" name="ref-6">6</a>]  Kaliski, B., "The MD2 Message-Digest Algorithm", <a href="rfc1319.html">RFC 1319</a>, April
        1992.

   [<a id="ref-7" name="ref-7">7</a>]  Krawczyk, H., Bellare, M. and R. Canetti, "HMAC: Keyed-Hashing
        for Message Authentication", <a href="rfc2104.html">RFC 2104</a>, February 1997.

   [<a id="ref-8" name="ref-8">8</a>]  Robert Morris and Ken Thompson. Password security: A case
        history.  Communications of the ACM, 22(11):594-597, November
        1979.

   [<a id="ref-9" name="ref-9">9</a>]  ISO/IEC 8824-1:1995: Information technology - Abstract Syntax
        Notation One (ASN.1) - Specification of basic notation. 1995.

   [<a id="ref-10" name="ref-10">10</a>] ISO/IEC 8824-1:1995/Amd.1:1995 Information technology - Abstract
        Syntax Notation One (ASN.1) - Specification of basic notation -
        Amendment 1 - Rules of extensibility. 1995.

   [<a id="ref-11" name="ref-11">11</a>] ISO/IEC 8824-2:1995 Information technology - Abstract Syntax
        Notation One (ASN.1) - Information object specification. 1995.

   [<a id="ref-12" name="ref-12">12</a>] ISO/IEC 8824-2:1995/Amd.1:1995 Information technology - Abstract
        Syntax Notation One (ASN.1) - Information object specification -
        Amendment 1 - Rules of extensibility. 1995.

   [<a id="ref-13" name="ref-13">13</a>] ISO/IEC 8824-3:1995 Information technology - Abstract Syntax
        Notation One (ASN.1) - Constraint specification. 1995.



<span class="grey">Kaliski                      Informational                     [Page 31]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-32" id="page-32" name="page-32"> </a>
<span class="grey"><a href="rfc2898.html">RFC 2898</a>              Password-Based Cryptography         September 2000</span>


   [<a id="ref-14" name="ref-14">14</a>] ISO/IEC 8824-4:1995 Information technology - Abstract Syntax
        Notation One (ASN.1) - Parameterization of ASN.1 specifications.
        1995.

   [<a id="ref-15" name="ref-15">15</a>] National Institute of Standards and Technology (NIST). FIPS PUB
        46-2: Data Encryption Standard. December 30, 1993.

   [<a id="ref-16" name="ref-16">16</a>] National Institute of Standards and Technology (NIST). FIPS PUB
        81: DES Modes of Operation. December 2, 1980.

   [<a id="ref-17" name="ref-17">17</a>] National Institute of Standards and Technology (NIST). FIPS PUB
        112: Password Usage. May 30, 1985.

   [<a id="ref-18" name="ref-18">18</a>] National Institute of Standards and Technology (NIST). FIPS PUB
        180-1: Secure Hash Standard. April 1994.

   [<a id="ref-19" name="ref-19">19</a>] Rivest, R., "The MD5 Message-Digest Algorithm", <a href="rfc1321.html">RFC 1321</a>, April
        1992.

   [<a id="ref-20" name="ref-20">20</a>] R.L. Rivest. The RC5 encryption algorithm. In Proceedings of the
        Second International Workshop on Fast Software Encryption, pages
        86-96, Springer-Verlag, 1994.

   [<a id="ref-21" name="ref-21">21</a>] Rivest, R., "A Description of the RC2(r) Encryption Algorithm",
        <a href="rfc2268.html">RFC 2268</a>, March 1998.

   [<a id="ref-22" name="ref-22">22</a>] R.L. Rivest. Block-Encryption Algorithm with Data-Dependent
        Rotations. U.S. Patent No. 5,724,428, March 3, 1998.

   [<a id="ref-23" name="ref-23">23</a>] R.L. Rivest. Block Encryption Algorithm with Data-Dependent
        Rotations. U.S. Patent No. 5,835,600, November 10, 1998.

   [<a id="ref-24" name="ref-24">24</a>] RSA Laboratories. PKCS #5: Password-Based Encryption Standard.
        Version 1.5, November 1993.

   [<a id="ref-25" name="ref-25">25</a>] RSA Laboratories. PKCS #8: Private-Key Information Syntax
        Standard.  Version 1.2, November 1993.

   [<a id="ref-26" name="ref-26">26</a>] T. Wu. The Secure Remote Password protocol. In Proceedings of
        the 1998 Internet Society Network and Distributed System
        Security Symposium, pages 97-111, Internet Society, 1998.

   [<a id="ref-27" name="ref-27">27</a>] Yergeau, F., "UTF-8, a transformation format of ISO 10646", <a href="rfc2279.html">RFC</a>
        <a href="rfc2279.html">2279</a>, January 1998.







<span class="grey">Kaliski                      Informational                     [Page 32]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-33" id="page-33" name="page-33"> </a>
<span class="grey"><a href="rfc2898.html">RFC 2898</a>              Password-Based Cryptography         September 2000</span>


Contact Information &amp; About PKCS

   The Public-Key Cryptography Standards are specifications produced by
   RSA Laboratories in cooperation with secure systems developers
   worldwide for the purpose of accelerating the deployment of public-
   key cryptography. First published in 1991 as a result of meetings
   with a small group of early adopters of public-key technology, the
   PKCS documents have become widely referenced and implemented.
   Contributions from the PKCS series have become part of many formal
   and de facto standards, including ANSI X9 documents, PKIX, SET,
   S/MIME, and SSL.

   Further development of PKCS occurs through mailing list discussions
   and occasional workshops, and suggestions for improvement are
   welcome. For more information, contact:

        PKCS Editor
        RSA Laboratories
        20 Crosby Drive
        Bedford, MA  01730  USA
        pkcs-editor@rsasecurity.com
        <a href="http://www.rsalabs.com/pkcs/">http://www.rsalabs.com/pkcs/</a>





























<span class="grey">Kaliski                      Informational                     [Page 33]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-34" id="page-34" name="page-34"> </a>
<span class="grey"><a href="rfc2898.html">RFC 2898</a>              Password-Based Cryptography         September 2000</span>


Full Copyright Statement

   Copyright (C) The Internet Society (2000).  All Rights Reserved.

   This document and translations of it may be copied and furnished to
   others, and derivative works that comment on or otherwise explain it
   or assist in its implementation may be prepared, copied, published
   and distributed, in whole or in part, without restriction of any
   kind, provided that the above copyright notice and this paragraph are
   included on all such copies and derivative works.  However, this
   document itself may not be modified in any way, such as by removing
   the copyright notice or references to the Internet Society or other
   Internet organizations, except as needed for the purpose of
   developing Internet standards in which case the procedures for
   copyrights defined in the Internet Standards process must be
   followed, or as required to translate it into languages other than
   English.

   The limited permissions granted above are perpetual and will not be
   revoked by the Internet Society or its successors or assigns.

   This document and the information contained herein is provided on an
   "AS IS" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING
   TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING
   BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION
   HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF
   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.

Acknowledgement

   Funding for the RFC Editor function is currently provided by the
   Internet Society.



















Kaliski                      Informational                     [Page 34]

</pre><br/>
    <span class="noprint"><small><small>Html markup produced by rfcmarkup 1.126, available from
      <a href="https://tools.ietf.org/tools/rfcmarkup/">https://tools.ietf.org/tools/rfcmarkup/</a>
    </small></small></span>
  </div>




</body><!-- Mirrored from tools.ietf.org/html/rfc2898 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 06 Mar 2018 23:18:51 GMT --></html>