<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml"><!-- Mirrored from tools.ietf.org/html/rfc7873 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 06 Mar 2018 23:18:19 GMT --><!-- Added by HTTrack --><head><meta content="text/html;charset=utf-8" http-equiv="content-type"/><!-- /Added by HTTrack -->

    <meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
    <meta content="index,follow" name="robots"/>
    <meta content="rfcmarkup version 1.126" name="creator"/>
    <link href="http://purl.org/dc/elements/1.1/" rel="schema.DC"/>
<meta content="draft-eastlake-dnsext-cookies" name="DC.Relation.Replaces"/>
<meta content="urn:ietf:rfc:7873" name="DC.Identifier"/>
<meta content="May, 2016" name="DC.Date.Issued"/>
<meta content="Mark Andrews &lt;marka@isc.org&gt;" name="DC.Creator"/>
<meta content="DNS Cookies are a lightweight DNS transaction security mechanism that
provides limited protection to DNS servers and clients against a
variety of increasingly common denial-of-service and amplification/
forgery or cache poisoning attacks by off-path attackers. DNS Cookies
are tolerant of NAT, NAT-PT (Network Address Translation - Protocol
Translation), and anycast and can be incrementally deployed. (Since
DNS Cookies are only returned to the IP address from which they were
originally received, they cannot be used to generally track Internet
users.)" name="DC.Description.Abstract"/>
<meta content="Domain Name System (DNS) Cookies" name="DC.Title"/>

    <link href="https://tools.ietf.org/images/rfc.png" rel="icon" type="image/png"/>
    <link href="https://tools.ietf.org/images/rfc.png" rel="shortcut icon" type="image/png"/>
    <title>RFC 7873 - Domain Name System (DNS) Cookies</title>
    
    
    <style type="text/css">
	@media only screen 
	  and (min-width: 992px)
	  and (max-width: 1199px) {
	    body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 768px)
	  and (max-width: 991px) {
            body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 480px)
	  and (max-width: 767px) {
            body { font-size: 11pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (max-width: 479px) {
            body { font-size: 8pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-device-width : 375px) 
	  and (max-device-width : 667px) {
            body { font-size: 9.5pt; }
            div.content { width: 96ex; margin: 0 1px; }
        }
	@media only screen 
	  and (min-device-width: 1200px) {
            body { font-size: 10pt; margin: 0 4em; }
            div.content { width: 96ex; margin: 0; }
        }
        h1, h2, h3, h4, h5, h6, .h1, .h2, .h3, .h4, .h5, .h6 {
	    font-weight: bold;
            line-height: 0pt;
            display: inline;
            white-space: pre;
            font-family: monospace;
            font-size: 1em;
	    font-weight: bold;
        }
        pre {
            font-size: 1em;
            margin-top: 0px;
            margin-bottom: 0px;
        }
	.pre {
	    white-space: pre;
	    font-family: monospace;
	}
	.header{
	    font-weight: bold;
	}
        .newpage {
            page-break-before: always;
        }
        .invisible {
            text-decoration: none;
            color: white;
        }
        a.selflink {
          color: black;
          text-decoration: none;
        }
        @media print {
            body {
                font-family: monospace;
                font-size: 10.5pt;
            }
            h1, h2, h3, h4, h5, h6 {
                font-size: 1em;
            }
        
            a:link, a:visited {
                color: inherit;
                text-decoration: none;
            }
            .noprint {
                display: none;
            }
        }
	@media screen {
	    .grey, .grey a:link, .grey a:visited {
		color: #777;
	    }
            .docinfo {
                background-color: #EEE;
            }
            .top {
                border-top: 7px solid #EEE;
            }
            .bgwhite  { background-color: white; }
            .bgred    { background-color: #F44; }
            .bggrey   { background-color: #666; }
            .bgbrown  { background-color: #840; }            
            .bgorange { background-color: #FA0; }
            .bgyellow { background-color: #EE0; }
            .bgmagenta{ background-color: #F4F; }
            .bgblue   { background-color: #66F; }
            .bgcyan   { background-color: #4DD; }
            .bggreen  { background-color: #4F4; }

            .legend   { font-size: 90%; }
            .cplate   { font-size: 70%; border: solid grey 1px; }
	}
    </style>
    <!--[if IE]>
    <style>
    body {
       font-size: 13px;
       margin: 10px 10px;
    }
    </style>
    <![endif]-->

    <script type="text/javascript"><!--
    function addHeaderTags() {
	var spans = document.getElementsByTagName("span");
	for (var i=0; i < spans.length; i++) {
	    var elem = spans[i];
	    if (elem) {
		var level = elem.getAttribute("class");
                if (level == "h1" || level == "h2" || level == "h3" || level == "h4" || level == "h5" || level == "h6") {
                    elem.innerHTML = "<"+level+">"+elem.innerHTML+"</"+level+">";		
                }
	    }
	}
    }
    var legend_html = "Colour legend:<br />      <table>         <tr><td>Unknown:</td>                   <td><span class='cplate bgwhite'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft:</td>                     <td><span class='cplate bgred'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Informational:</td>             <td><span class='cplate bgorange'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Experimental:</td>              <td><span class='cplate bgyellow'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Best Common Practice:</td>      <td><span class='cplate bgmagenta'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Proposed Standard:</td>         <td><span class='cplate bgblue'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft Standard (old designation):</td> <td><span class='cplate bgcyan'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Internet Standard:</td>         <td><span class='cplate bggreen'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Historic:</td>                  <td><span class='cplate bggrey'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Obsolete:</td>                  <td><span class='cplate bgbrown'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>     </table>";
    function showElem(id) {
        var elem = document.getElementById(id);
        elem.innerHTML = eval(id+"_html");
        elem.style.visibility='visible';
    }
    function hideElem(id) {
        var elem = document.getElementById(id);
        elem.style.visibility='hidden';        
        elem.innerHTML = "";
    }
    // -->
    </script>
</head>
<body onload="addHeaderTags()">
  <div class="content">
   <div style="height: 13px;">
      <div class="pre noprint docinfo bgblue" onclick="showElem('legend');" onmouseout="hideElem('legend')" onmouseover="this.style.cursor='pointer';" style="height: 6px; position: absolute;" title="Click for colour legend.">                                                                        </div>
      <div class="docinfo noprint pre legend" id="legend" onmouseout="hideElem('legend');" onmouseover="showElem('legend');" style="position:absolute; top: 4px; left: 4ex; visibility:hidden; background-color: white; padding: 4px 9px 5px 7px; border: solid #345 1px; ">
      </div>
   </div>
<span class="pre noprint docinfo top">[<a href="index.html" title="Document search and retrieval page">Docs</a>] [<a href="https://tools.ietf.org/rfc/rfc7873.txt" title="Plaintext version of this document">txt</a>|<a href="https://tools.ietf.org/pdf/rfc7873" title="PDF version of this document">pdf</a>] [<a href="https://tools.ietf.org/html/draft-ietf-dnsop-cookies" title="draft-ietf-dnsop-cookies">draft-ietf-dnso...</a>] [<a href="https://datatracker.ietf.org/doc/rfc7873" title="IESG Datatracker information for this document">Tracker</a>] [<a href="https://tools.ietf.org/rfcdiff?difftype=--hwdiff&amp;url2=rfc7873" title="Inline diff (wdiff)">Diff1</a>] [<a href="https://tools.ietf.org/rfcdiff?url2=rfc7873" title="Side-by-side diff">Diff2</a>]         </span><br/>
<span class="pre noprint docinfo">                                                                        </span><br/>
<span class="pre noprint docinfo">                                                       PROPOSED STANDARD</span><br/>
<span class="pre noprint docinfo">                                                                        </span><br/>
<pre>Internet Engineering Task Force (IETF)                   D. Eastlake 3rd
Request for Comments: 7873                                        Huawei
Category: Standards Track                                     M. Andrews
ISSN: 2070-1721                                                      ISC
                                                                May 2016


                    <span class="h1">Domain Name System (DNS) Cookies</span>

Abstract

   DNS Cookies are a lightweight DNS transaction security mechanism that
   provides limited protection to DNS servers and clients against a
   variety of increasingly common denial-of-service and amplification/
   forgery or cache poisoning attacks by off-path attackers.  DNS
   Cookies are tolerant of NAT, NAT-PT (Network Address Translation -
   Protocol Translation), and anycast and can be incrementally deployed.
   (Since DNS Cookies are only returned to the IP address from which
   they were originally received, they cannot be used to generally track
   Internet users.)

Status of This Memo

   This is an Internet Standards Track document.

   This document is a product of the Internet Engineering Task Force
   (IETF).  It represents the consensus of the IETF community.  It has
   received public review and has been approved for publication by the
   Internet Engineering Steering Group (IESG).  Further information on
   Internet Standards is available in <a href="rfc7841.html#section-2">Section 2 of RFC 7841</a>.

   Information about the current status of this document, any errata,
   and how to provide feedback on it may be obtained at
   <a href="http://www.rfc-editor.org/info/rfc7873">http://www.rfc-editor.org/info/rfc7873</a>.

















<span class="grey">Eastlake &amp; Andrews           Standards Track                    [Page 1]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-2" id="page-2" name="page-2"> </a>
<span class="grey"><a href="rfc7873.html">RFC 7873</a>                       DNS Cookies                      May 2016</span>


Copyright Notice

   Copyright (c) 2016 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to <a href="https://tools.ietf.org/html/bcp78">BCP 78</a> and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (<a href="http://trustee.ietf.org/license-info">http://trustee.ietf.org/license-info</a>) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.





































<span class="grey">Eastlake &amp; Andrews           Standards Track                    [Page 2]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-3" id="page-3" name="page-3"> </a>
<span class="grey"><a href="rfc7873.html">RFC 7873</a>                       DNS Cookies                      May 2016</span>


Table of Contents

   <a href="#section-1">1</a>. Introduction ....................................................<a href="#page-4">4</a>
      <a href="#section-1.1">1.1</a>. Contents of This Document ..................................<a href="#page-4">4</a>
      <a href="#section-1.2">1.2</a>. Definitions ................................................<a href="#page-5">5</a>
   <a href="#section-2">2</a>. Threats Considered ..............................................<a href="#page-5">5</a>
      <a href="#section-2.1">2.1</a>. Denial-of-Service Attacks ..................................<a href="#page-6">6</a>
           <a href="#section-2.1.1">2.1.1</a>. DNS Amplification Attacks ...........................<a href="#page-6">6</a>
           <a href="#section-2.1.2">2.1.2</a>. DNS Server Denial of Service ........................<a href="#page-6">6</a>
      <a href="#section-2.2">2.2</a>. Cache Poisoning and Answer Forgery Attacks .................<a href="#page-7">7</a>
   <a href="#section-3">3</a>. Comments on Existing DNS Security ...............................<a href="#page-7">7</a>
      <a href="#section-3.1">3.1</a>. Existing DNS Data Security .................................<a href="#page-7">7</a>
      <a href="#section-3.2">3.2</a>. DNS Message/Transaction Security ...........................<a href="#page-8">8</a>
      <a href="#section-3.3">3.3</a>. Conclusions on Existing DNS Security .......................<a href="#page-8">8</a>
   <a href="#section-4">4</a>. DNS COOKIE Option ...............................................<a href="#page-8">8</a>
      <a href="#section-4.1">4.1</a>. Client Cookie .............................................<a href="#page-10">10</a>
      <a href="#section-4.2">4.2</a>. Server Cookie .............................................<a href="#page-10">10</a>
   <a href="#section-5">5</a>. DNS Cookies Protocol Specification .............................<a href="#page-11">11</a>
      <a href="#section-5.1">5.1</a>. Originating a Request .....................................<a href="#page-11">11</a>
      <a href="#section-5.2">5.2</a>. Responding to a Request ...................................<a href="#page-11">11</a>
           <a href="#section-5.2.1">5.2.1</a>. No OPT RR or No COOKIE Option ......................<a href="#page-12">12</a>
           <a href="#section-5.2.2">5.2.2</a>. Malformed COOKIE Option ............................<a href="#page-12">12</a>
           <a href="#section-5.2.3">5.2.3</a>. Only a Client Cookie ...............................<a href="#page-12">12</a>
           <a href="#section-5.2.4">5.2.4</a>. A Client Cookie and an Invalid Server Cookie .......<a href="#page-13">13</a>
           <a href="#section-5.2.5">5.2.5</a>. A Client Cookie and a Valid Server Cookie ..........<a href="#page-13">13</a>
      <a href="#section-5.3">5.3</a>. Processing Responses ......................................<a href="#page-14">14</a>
      <a href="#section-5.4">5.4</a>. Querying for a Server Cookie ..............................<a href="#page-14">14</a>
   <a href="#section-6">6</a>. NAT Considerations and Anycast Server Considerations ...........<a href="#page-15">15</a>
   <a href="#section-7">7</a>. Operational and Deployment Considerations ......................<a href="#page-17">17</a>
      <a href="#section-7.1">7.1</a>. Client and Server Secret Rollover .........................<a href="#page-17">17</a>
      <a href="#section-7.2">7.2</a>. Counters ..................................................<a href="#page-18">18</a>
   <a href="#section-8">8</a>. IANA Considerations ............................................<a href="#page-18">18</a>
   <a href="#section-9">9</a>. Security Considerations ........................................<a href="#page-19">19</a>
      <a href="#section-9.1">9.1</a>. Cookie Algorithm Considerations ...........................<a href="#page-20">20</a>
   <a href="#section-10">10</a>. Implementation Considerations .................................<a href="#page-20">20</a>
   <a href="#section-11">11</a>. References ....................................................<a href="#page-20">20</a>
      <a href="#section-11.1">11.1</a>. Normative References .....................................<a href="#page-20">20</a>
      <a href="#section-11.2">11.2</a>. Informative References ...................................<a href="#page-21">21</a>
   <a href="#appendix-A">Appendix A</a>. Example Client Cookie Algorithms ......................<a href="#page-23">23</a>
      <a href="#appendix-A.1">A.1</a>. A Simple Algorithm ........................................<a href="#page-23">23</a>
      <a href="#appendix-A.2">A.2</a>. A More Complex Algorithm ..................................<a href="#page-23">23</a>
   <a href="#appendix-B">Appendix B</a>. Example Server Cookie Algorithms ......................<a href="#page-23">23</a>
      <a href="#appendix-B.1">B.1</a>. A Simple Algorithm ........................................<a href="#page-23">23</a>
      <a href="#appendix-B.2">B.2</a>. A More Complex Algorithm ..................................<a href="#page-24">24</a>
   Acknowledgments ...................................................<a href="#page-25">25</a>
   Authors' Addresses ................................................<a href="#page-25">25</a>





<span class="grey">Eastlake &amp; Andrews           Standards Track                    [Page 3]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-4" id="page-4" name="page-4"> </a>
<span class="grey"><a href="rfc7873.html">RFC 7873</a>                       DNS Cookies                      May 2016</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/1.%20%20Introduction"></a><a class="selflink" href="#section-1" name="section-1">1</a>.  Introduction</span>

   As with many core Internet protocols, the Domain Name System (DNS)
   was originally designed at a time when the Internet had only a small
   pool of trusted users.  As the Internet has grown exponentially to a
   global information utility, the DNS has increasingly been subject to
   abuse.

   This document describes DNS Cookies, a lightweight DNS transaction
   security mechanism specified as an OPT [<a href="rfc6891.html" title='"Extension Mechanisms for DNS (EDNS(0))"'>RFC6891</a>] option.  The
   DNS Cookie mechanism provides limited protection to DNS servers and
   clients against a variety of increasingly common abuses by off-path
   attackers.  It is compatible with, and can be used in conjunction
   with, other DNS transaction forgery resistance measures such as those
   in [<a href="rfc5452.html" title='"Measures for Making DNS More Resilient against Forged Answers"'>RFC5452</a>].  (Since DNS Cookies are only returned to the IP address
   from which they were originally received, they cannot be used to
   generally track Internet users.)

   The protection provided by DNS Cookies is similar to that provided by
   using TCP for DNS transactions.  Bypassing the weak protection
   provided by using TCP requires, among other things, that an off-path
   attacker guess the 32-bit TCP sequence number in use.  Bypassing the
   weak protection provided by DNS Cookies requires such an attacker to
   guess a 64-bit pseudorandom "cookie" quantity.  Where DNS Cookies are
   not available but TCP is, falling back to using TCP is reasonable.

   If only one party to a DNS transaction supports DNS Cookies, the
   mechanism does not provide a benefit or significantly interfere, but
   if both support it, the additional security provided is automatically
   available.

   The DNS Cookie mechanism is designed to work in the presence of NAT
   and NAT-PT (Network Address Translation - Protocol Translation)
   boxes, and guidance is provided herein on supporting the DNS Cookie
   mechanism in anycast servers.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/1.1.%20%20Contents%20of%20This%20Document"></a><a class="selflink" href="#section-1.1" name="section-1.1">1.1</a>.  Contents of This Document</span>

   In <a href="#section-2">Section 2</a>, we discuss the threats against which the DNS Cookie
   mechanism provides some protection.

   <a href="#section-3">Section 3</a> describes existing DNS security mechanisms and why they are
   not adequate substitutes for DNS Cookies.

   <a href="#section-4">Section 4</a> describes the COOKIE option.

   <a href="#section-5">Section 5</a> provides a protocol description.




<span class="grey">Eastlake &amp; Andrews           Standards Track                    [Page 4]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-5" id="page-5" name="page-5"> </a>
<span class="grey"><a href="rfc7873.html">RFC 7873</a>                       DNS Cookies                      May 2016</span>


   <a href="#section-6">Section 6</a> discusses some NAT considerations and anycast-related
   DNS Cookies design considerations.

   <a href="#section-7">Section 7</a> discusses incremental deployment considerations.

   Sections <a href="#section-8">8</a> and <a href="#section-9">9</a> describe IANA considerations and security
   considerations, respectively.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/1.2.%20%20Definitions"></a><a class="selflink" href="#section-1.2" name="section-1.2">1.2</a>.  Definitions</span>

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
   "OPTIONAL" in this document are to be interpreted as described in
   [<a href="rfc2119.html" title='"Key words for use in RFCs to Indicate Requirement Levels"'>RFC2119</a>].

   "Off-path attacker", for a particular DNS client and server, is
      defined as an attacker who cannot observe the DNS request and
      response messages between that client and server.

   "Soft state" indicates information that is learned or derived by a
      host and that may be discarded when indicated by the policies of
      that host but can be re-instantiated later if needed.  For
      example, it could be discarded after a period of time or when
      storage for caching such data becomes full.  If operations that
      require soft state continue after the information has been
      discarded, the information will be automatically regenerated,
      albeit at some cost.

   "Silently discarded" indicates that there are no DNS protocol message
      consequences.

   "IP address" is used herein as a length-independent term and includes
      both IPv4 and IPv6 addresses.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/2.%20%20Threats%20Considered"></a><a class="selflink" href="#section-2" name="section-2">2</a>.  Threats Considered</span>

   DNS Cookies are intended to provide significant but limited
   protection against certain attacks by off-path attackers, as
   described below.  These attacks include denial of service, cache
   poisoning, and answer forgery.











<span class="grey">Eastlake &amp; Andrews           Standards Track                    [Page 5]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-6" id="page-6" name="page-6"> </a>
<span class="grey"><a href="rfc7873.html">RFC 7873</a>                       DNS Cookies                      May 2016</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/2.1.%20%20Denial-of-Service%20Attacks"></a><a class="selflink" href="#section-2.1" name="section-2.1">2.1</a>.  Denial-of-Service Attacks</span>

   The typical form of the denial-of-service attacks considered herein
   is to send DNS requests with forged source IP addresses to a server.
   The intent can be to attack that server or some other selected host,
   as described below.

   There are also on-path denial-of-service attacks that attempt to
   saturate a server with DNS requests having correct source addresses.
   Cookies do not protect against such attacks, but successful cookie
   validation improves the probability that the correct source IP
   address for the requests is known.  This facilitates contacting the
   managers of the networks from which the requests originate or taking
   other actions for those networks.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/2.1.1.%20%20DNS%20Amplification%20Attacks"></a><a class="selflink" href="#section-2.1.1" name="section-2.1.1">2.1.1</a>.  DNS Amplification Attacks</span>

   A request with a forged source IP address generally causes a response
   to be sent to that forged IP address.  Thus, the forging of many such
   requests with a particular source IP address can result in enough
   traffic being sent to the forged IP address to interfere with service
   to the host at the IP address.  Furthermore, it is generally easy in
   the DNS to create short requests that produce much longer responses,
   thus amplifying the attack.

   The DNS Cookie mechanism can severely limit the traffic amplification
   obtained by requests from an attacker that is off the path between
   the server and the request's source address.  Enforced DNS Cookies
   would make it hard for an off-path attacker to cause any more than
   rate-limited short error responses to be sent to a forged IP address,
   so the attack would be attenuated rather than amplified.  DNS Cookies
   make it more effective to implement a rate-limiting scheme for error
   responses from the server.  Such a scheme would further restrict
   selected host denial-of-service traffic from that server.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/2.1.2.%20%20DNS%20Server%20Denial%20of%20Service"></a><a class="selflink" href="#section-2.1.2" name="section-2.1.2">2.1.2</a>.  DNS Server Denial of Service</span>

   DNS requests that are accepted cause work on the part of DNS servers.
   This is particularly true for recursive servers that may issue one or
   more requests and process the responses thereto, in order to
   determine their response to the initial request; the situation can be
   even worse for recursive servers implementing DNSSEC [<a href="rfc4033.html" title='"DNS Security Introduction and Requirements"'>RFC4033</a>]
   [<a href="rfc4034.html" title='"Resource Records for the DNS Security Extensions"'>RFC4034</a>] [<a href="rfc4035.html" title='"Protocol Modifications for the DNS Security Extensions"'>RFC4035</a>], because they may be induced to perform
   burdensome cryptographic computations in attempts to verify the
   authenticity of data they retrieve in trying to answer the request.






<span class="grey">Eastlake &amp; Andrews           Standards Track                    [Page 6]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-7" id="page-7" name="page-7"> </a>
<span class="grey"><a href="rfc7873.html">RFC 7873</a>                       DNS Cookies                      May 2016</span>


   The computational or communications burden caused by such requests
   may not depend on a forged source IP address, but the use of such
   addresses makes

   + the source of the requests causing the denial-of-service attack
     harder to find and

   + restriction of the IP addresses from which such requests should be
     honored hard or impossible to specify or verify.

   The use of DNS Cookies should enable a server to reject forged
   requests from an off-path attacker with relative ease and before any
   recursive queries or public key cryptographic operations are
   performed.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/2.2.%20%20Cache%20Poisoning%20and%20Answer%20Forgery%20Attacks"></a><a class="selflink" href="#section-2.2" name="section-2.2">2.2</a>.  Cache Poisoning and Answer Forgery Attacks</span>

   The form of the cache poisoning attacks considered is to send forged
   replies to a resolver.  Modern network speeds for well-connected
   hosts are such that, by forging replies from the IP addresses of a
   DNS server to a resolver for names that resolver has been induced to
   resolve or for common names whose resource records have short
   time-to-live values, there can be an unacceptably high probability of
   randomly coming up with a reply that will be accepted and cause false
   DNS information to be cached by that resolver (the Dan Kaminsky
   attack [<a href="#ref-Kaminsky" title="&quot;Dan Kaminsky's 2008 DNS Vulnerability&quot;">Kaminsky</a>]).  This can be used to facilitate phishing attacks
   and other diversions of legitimate traffic to a compromised or
   malicious host such as a web server.

   With the use of DNS Cookies, a resolver can generally reject such
   forged replies.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/3.%20%20Comments%20on%20Existing%20DNS%20Security"></a><a class="selflink" href="#section-3" name="section-3">3</a>.  Comments on Existing DNS Security</span>

   Two forms of security have been added to DNS: data security and
   message/transaction security.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.1.%20%20Existing%20DNS%20Data%20Security"></a><a class="selflink" href="#section-3.1" name="section-3.1">3.1</a>.  Existing DNS Data Security</span>

   DNS data security is one part of DNSSEC and is described in
   [<a href="rfc4033.html" title='"DNS Security Introduction and Requirements"'>RFC4033</a>], [<a href="rfc4034.html" title='"Resource Records for the DNS Security Extensions"'>RFC4034</a>], [<a href="rfc4035.html" title='"Protocol Modifications for the DNS Security Extensions"'>RFC4035</a>], and updates thereto.  It provides
   data origin authentication and authenticated denial of existence.
   DNSSEC is being deployed and can provide strong protection against
   forged data and cache poisoning; however, it has the unintended
   effect of making some denial-of-service attacks worse because of the
   cryptographic computational load it can require and the increased
   size in DNS response packets that it tends to produce.




<span class="grey">Eastlake &amp; Andrews           Standards Track                    [Page 7]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-8" id="page-8" name="page-8"> </a>
<span class="grey"><a href="rfc7873.html">RFC 7873</a>                       DNS Cookies                      May 2016</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.2.%20%20DNS%20Message%2FTransaction%20Security"></a><a class="selflink" href="#section-3.2" name="section-3.2">3.2</a>.  DNS Message/Transaction Security</span>

   The second form of security that has been added to DNS provides
   "transaction" security through TSIG [<a href="rfc2845.html" title='"Secret Key Transaction Authentication for DNS (TSIG)"'>RFC2845</a>] or SIG(0) [<a href="rfc2931.html" title='"DNS Request and Transaction Signatures ( SIG(0)s )"'>RFC2931</a>].
   TSIG could provide strong protection against the attacks for which
   the DNS Cookie mechanism provides weaker protection; however, TSIG is
   non-trivial to deploy in the general Internet because of the burdens
   it imposes.  Among these burdens are pre-agreement and key
   distribution between client and server, keeping track of server-side
   key state, and required time synchronization between client and
   server.

   TKEY [<a href="rfc2930.html" title='"Secret Key Establishment for DNS (TKEY RR)"'>RFC2930</a>] can solve the problem of key distribution for TSIG,
   but some modes of TKEY impose a substantial cryptographic computation
   load and can be dependent on the deployment of DNS data security (see
   <a href="#section-3.1">Section 3.1</a>).

   SIG(0) [<a href="rfc2931.html" title='"DNS Request and Transaction Signatures ( SIG(0)s )"'>RFC2931</a>] provides less denial-of-service protection than TSIG
   or, in one way, even DNS Cookies, because it authenticates complete
   transactions but does not authenticate requests.  In any case, it
   also depends on the deployment of DNS data security and requires
   computationally burdensome public key cryptographic operations.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.3.%20%20Conclusions%20on%20Existing%20DNS%20Security"></a><a class="selflink" href="#section-3.3" name="section-3.3">3.3</a>.  Conclusions on Existing DNS Security</span>

   The existing DNS security mechanisms do not provide the services
   provided by the DNS Cookie mechanism: lightweight message
   authentication of DNS requests and responses with no requirement for
   pre-configuration or per-client server-side state.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/4.%20%20DNS%20COOKIE%20Option"></a><a class="selflink" href="#section-4" name="section-4">4</a>.  DNS COOKIE Option</span>

   The DNS COOKIE option is an OPT RR [<a href="rfc6891.html" title='"Extension Mechanisms for DNS (EDNS(0))"'>RFC6891</a>] option that can be
   included in the RDATA portion of an OPT RR in DNS requests and
   responses.  The option length varies, depending on the circumstances
   in which it is being used.  There are two cases, as described below.
   Both use the same OPTION-CODE; they are distinguished by their
   length.













<span class="grey">Eastlake &amp; Andrews           Standards Track                    [Page 8]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-9" id="page-9" name="page-9"> </a>
<span class="grey"><a href="rfc7873.html">RFC 7873</a>                       DNS Cookies                      May 2016</span>


   In a request sent by a client to a server when the client does not
   know the server's cookie, its length is 8, consisting of an 8-byte
   Client Cookie, as shown in Figure 1.

                         1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |        OPTION-CODE = 10      |       OPTION-LENGTH = 8        |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                                                               |
    +-+-    Client Cookie (fixed size, 8 bytes)              -+-+-+-+
    |                                                               |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

              Figure 1: COOKIE Option, Unknown Server Cookie

   In a request sent by a client when a Server Cookie is known, and in
   all responses to such a request, the length is variable -- from 16 to
   40 bytes, consisting of an 8-byte Client Cookie followed by the
   variable-length (8 bytes to 32 bytes) Server Cookie, as shown in
   Figure 2.  The variability of the option length stems from the
   variable-length Server Cookie.  The Server Cookie is an integer
   number of bytes, with a minimum size of 8 bytes for security and a
   maximum size of 32 bytes for convenience of implementation.

                         1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |        OPTION-CODE = 10      |   OPTION-LENGTH &gt;= 16, &lt;= 40   |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                                                               |
    +-+-    Client Cookie (fixed size, 8 bytes)              -+-+-+-+
    |                                                               |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                                                               |
    /       Server Cookie  (variable size, 8 to 32 bytes)           /
    /                                                               /
    +-+-+-+-...

               Figure 2: COOKIE Option, Known Server Cookie











<span class="grey">Eastlake &amp; Andrews           Standards Track                    [Page 9]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-10" id="page-10" name="page-10"> </a>
<span class="grey"><a href="rfc7873.html">RFC 7873</a>                       DNS Cookies                      May 2016</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.1.%20%20Client%20Cookie"></a><a class="selflink" href="#section-4.1" name="section-4.1">4.1</a>.  Client Cookie</span>

   The Client Cookie SHOULD be a pseudorandom function of the Client IP
   Address, the Server IP Address, and a secret quantity known only to
   the client.  This Client Secret SHOULD have at least 64 bits of
   entropy [<a href="rfc4086.html" title='"Randomness Requirements for Security"'>RFC4086</a>] and be changed periodically (see <a href="#section-7.1">Section 7.1</a>).  The
   selection of the pseudorandom function is a matter private to the
   client, as only the client needs to recognize its own DNS Cookies.

   The Client IP Address is included so that the Client Cookie cannot be
   used to (1) track a client if the Client IP Address changes due to
   privacy mechanisms or (2) impersonate the client by some network
   device that was formerly on path but is no longer on path when the
   Client IP Address changes due to mobility.  However, if the Client IP
   Address is being changed very often, it may be necessary to fix the
   Client Cookie for a particular server for several requests, to avoid
   undue inefficiency due to retries caused by that server not
   recognizing the Client Cookie.

   For further discussion of the Client Cookie field, see <a href="#section-5.1">Section 5.1</a>.
   For example methods of determining a Client Cookie, see <a href="#appendix-A">Appendix A</a>.

   In order to provide minimal authentication, a client MUST send
   Client Cookies that will usually be different for any two servers at
   different IP addresses.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.2.%20%20Server%20Cookie"></a><a class="selflink" href="#section-4.2" name="section-4.2">4.2</a>.  Server Cookie</span>

   The Server Cookie SHOULD consist of or include a 64-bit or larger
   pseudorandom function of the request source (client) IP address, a
   secret quantity known only to the server, and the request
   Client Cookie.  (See <a href="#section-6">Section 6</a> for a discussion of why the
   Client Cookie is used as input to the Server Cookie but the
   Server Cookie is not used as an input to the Client Cookie.)  This
   Server Secret SHOULD have at least 64 bits of entropy [<a href="rfc4086.html" title='"Randomness Requirements for Security"'>RFC4086</a>] and
   be changed periodically (see <a href="#section-7.1">Section 7.1</a>).  The selection of the
   pseudorandom function is a matter private to the server, as only the
   server needs to recognize its own DNS Cookies.

   For further discussion of the Server Cookie field, see <a href="#section-5.2">Section 5.2</a>.
   For example methods of determining a Server Cookie, see <a href="#appendix-B">Appendix B</a>.
   When implemented as recommended, the server need not maintain any
   cookie-related per-client state.

   In order to provide minimal authentication, a server MUST send
   Server Cookies that will usually be different for clients at any two
   different IP addresses or with different Client Cookies.




<span class="grey">Eastlake &amp; Andrews           Standards Track                   [Page 10]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-11" id="page-11" name="page-11"> </a>
<span class="grey"><a href="rfc7873.html">RFC 7873</a>                       DNS Cookies                      May 2016</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/5.%20%20DNS%20Cookies%20Protocol%20Specification"></a><a class="selflink" href="#section-5" name="section-5">5</a>.  DNS Cookies Protocol Specification</span>

   This section discusses using DNS Cookies in the DNS protocol.  The
   cycle of originating a request, responding to that request, and
   processing responses is covered in Sections <a href="#section-5.1">5.1</a>, <a href="#section-5.2">5.2</a>, and <a href="#section-5.3">5.3</a>.  A
   de facto extension to QUERY to allow the prefetching of a
   Server Cookie is specified in <a href="#section-5.4">Section 5.4</a>.  Rollover of the Client
   Secrets and Server Secrets, and transient retention of the old cookie
   or secret, are covered in <a href="#section-7.1">Section 7.1</a>.

   DNS clients and servers SHOULD implement DNS Cookies to decrease
   their vulnerability to the threats discussed in <a href="#section-2">Section 2</a>.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.1.%20%20Originating%20a%20Request"></a><a class="selflink" href="#section-5.1" name="section-5.1">5.1</a>.  Originating a Request</span>

   A DNS client that implements DNS Cookies includes one DNS
   COOKIE option containing a Client Cookie in every DNS request
   it sends, unless DNS Cookies are disabled.

   If the client has a cached Server Cookie for the server against its
   IP address, it uses the longer cookie form and includes that
   Server Cookie in the option along with the Client Cookie (Figure 2).
   Otherwise, it just sends the shorter-form option with a Client Cookie
   (Figure 1).

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.2.%20%20Responding%20to%20a%20Request"></a><a class="selflink" href="#section-5.2" name="section-5.2">5.2</a>.  Responding to a Request</span>

   The Server Cookie, when it occurs in a COOKIE option in a request, is
   intended to weakly assure the server that the request came from a
   client that is both at the source IP address of the request and using
   the Client Cookie included in the option.  This assurance is provided
   by the Server Cookie that server sent to that client in an earlier
   response appearing as the Server Cookie field in the request.

   At a server where DNS Cookies are not implemented and enabled, the
   presence of a COOKIE option is ignored and the server responds as if
   no COOKIE option had been included in the request.

   When DNS Cookies are implemented and enabled, there are five
   possibilities:

   (1) There is no OPT RR at all in the request, or there is an OPT RR
       but the COOKIE option is absent from the OPT RR.

   (2) A COOKIE option is present but is not a legal length or is
       otherwise malformed.





<span class="grey">Eastlake &amp; Andrews           Standards Track                   [Page 11]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-12" id="page-12" name="page-12"> </a>
<span class="grey"><a href="rfc7873.html">RFC 7873</a>                       DNS Cookies                      May 2016</span>


   (3) There is a COOKIE option of valid length in the request with no
       Server Cookie.

   (4) There is a COOKIE option of valid length in the request with a
       Server Cookie, but that Server Cookie is invalid.

   (5) There is a COOKIE option of valid length in the request with a
       correct Server Cookie.

   These five possibilities are discussed in the subsections below.

   In all cases of multiple COOKIE options in a request, only the first
   (the one closest to the DNS header) is considered.  All others are
   ignored.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/5.2.1.%20%20No%20OPT%20RR%20or%20No%20COOKIE%20Option"></a><a class="selflink" href="#section-5.2.1" name="section-5.2.1">5.2.1</a>.  No OPT RR or No COOKIE Option</span>

   If there is no OPT record or no COOKIE option present in the request,
   then the server responds to the request as if the server doesn't
   implement the COOKIE option.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/5.2.2.%20%20Malformed%20COOKIE%20Option"></a><a class="selflink" href="#section-5.2.2" name="section-5.2.2">5.2.2</a>.  Malformed COOKIE Option</span>

   If the COOKIE option is too short to contain a Client Cookie, then
   FORMERR is generated.  If the COOKIE option is longer than that
   required to hold a COOKIE option with just a Client Cookie (8 bytes)
   but is shorter than the minimum COOKIE option with both a
   Client Cookie and a Server Cookie (16 bytes), then FORMERR is
   generated.  If the COOKIE option is longer than the maximum valid
   COOKIE option (40 bytes), then FORMERR is generated.

   In summary, valid cookie lengths are 8 and 16 to 40 inclusive.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/5.2.3.%20%20Only%20a%20Client%20Cookie"></a><a class="selflink" href="#section-5.2.3" name="section-5.2.3">5.2.3</a>.  Only a Client Cookie</span>

   Based on server policy, including rate limiting, the server chooses
   one of the following:

   (1) Silently discard the request.

   (2) Send a BADCOOKIE error response.

   (3) Process the request and provide a normal response.  The RCODE is
       NOERROR, unless some non-cookie error occurs in processing the
       request.






<span class="grey">Eastlake &amp; Andrews           Standards Track                   [Page 12]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-13" id="page-13" name="page-13"> </a>
<span class="grey"><a href="rfc7873.html">RFC 7873</a>                       DNS Cookies                      May 2016</span>


   If the server responds choosing (2) or (3) above, it SHALL generate
   its own COOKIE option containing both the Client Cookie copied from
   the request and a Server Cookie it has generated, and it will add
   this COOKIE option to the response's OPT record.  Servers MUST, at
   least occasionally, respond to such requests to inform the client of
   the correct Server Cookie.  This is necessary so that such a client
   can bootstrap to the more secure state where requests and responses
   have recognized Server Cookies and Client Cookies.  A server is not
   expected to maintain per-client state to achieve this.  For example,
   it could respond to every Nth request across all clients.

   If the request was received over TCP, the server SHOULD take the
   authentication provided by the use of TCP into account and SHOULD
   choose (3).  In this case, if the server is not willing to accept the
   security provided by TCP as a substitute for the security provided by
   DNS Cookies but instead chooses (2), there is some danger of an
   indefinite loop of retries (see <a href="#section-5.3">Section 5.3</a>).

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/5.2.4.%20%20A%20Client%20Cookie%20and%20an%20Invalid%20Server%20Cookie"></a><a class="selflink" href="#section-5.2.4" name="section-5.2.4">5.2.4</a>.  A Client Cookie and an Invalid Server Cookie</span>

   The server examines the Server Cookie to determine if it is a valid
   Server Cookie that it had generated previously.  This determination
   normally involves recalculating the Server Cookie (or the Hash part
   thereof) based on the Server Secret (or the previous Server Secret,
   if it has just changed); the received Client Cookie; the Client IP
   Address; and, possibly, other fields.  See <a href="#appendix-B.2">Appendix B.2</a> for an
   example.  If the cookie is invalid, it could be because

   + it is too old

   + a client's IP address or Client Cookie changed, and the DNS server
     is not aware of the change

   + an anycast cluster of servers is not consistently configured, or

   + an attempt to spoof the client has occurred

   The server SHALL process the request as if the invalid Server Cookie
   was not present, as described in <a href="#section-5.2.3">Section 5.2.3</a>.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/5.2.5.%20%20A%20Client%20Cookie%20and%20a%20Valid%20Server%20Cookie"></a><a class="selflink" href="#section-5.2.5" name="section-5.2.5">5.2.5</a>.  A Client Cookie and a Valid Server Cookie</span>

   When a valid Server Cookie is present in the request, the server can
   assume that the request is from a client that it has talked to before
   and defensive measures for spoofed UDP requests, if any, are no
   longer required.





<span class="grey">Eastlake &amp; Andrews           Standards Track                   [Page 13]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-14" id="page-14" name="page-14"> </a>
<span class="grey"><a href="rfc7873.html">RFC 7873</a>                       DNS Cookies                      May 2016</span>


   The server SHALL process the request and include a COOKIE option in
   the response by (a) copying the complete COOKIE option from the
   request or (b) generating a new COOKIE option containing both the
   Client Cookie copied from the request and a valid Server Cookie it
   has generated.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.3.%20%20Processing%20Responses"></a><a class="selflink" href="#section-5.3" name="section-5.3">5.3</a>.  Processing Responses</span>

   The Client Cookie, when it occurs in a COOKIE option in a DNS reply,
   is intended to weakly assure the client that the reply came from a
   server at the source IP address used in the response packet, because
   the Client Cookie value is the value that client would send to that
   server in a request.  In a DNS reply with multiple COOKIE options,
   all but the first (the one closest to the DNS header) are ignored.

   A DNS client where DNS Cookies are implemented and enabled examines
   the response for DNS Cookies and MUST discard the response if it
   contains an illegal COOKIE option length or an incorrect
   Client Cookie value.  If the client is expecting the response to
   contain a COOKIE option and it is missing, the response MUST be
   discarded.  If the COOKIE option Client Cookie is correct, the client
   caches the Server Cookie provided, even if the response is an error
   response (RCODE non-zero).

   If the extended RCODE in the reply is BADCOOKIE and the Client Cookie
   in the reply matches what was sent, it means that the server was
   unwilling to process the request because it did not have the correct
   Server Cookie in it.  The client SHOULD retry the request using the
   new Server Cookie from the response.  Repeated BADCOOKIE responses to
   requests that use the Server Cookie provided in the previous response
   may be an indication that either the shared secrets or the method for
   generating secrets in an anycast cluster of servers is inconsistent.
   If the reply to a retried request with a fresh Server Cookie is
   BADCOOKIE, the client SHOULD retry using TCP as the transport, since
   the server will likely process the request normally based on the
   security provided by TCP (see <a href="#section-5.2.3">Section 5.2.3</a>).

   If the RCODE is some value other than BADCOOKIE, including zero, the
   further processing of the response proceeds normally.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.4.%20%20Querying%20for%20a%20Server%20Cookie"></a><a class="selflink" href="#section-5.4" name="section-5.4">5.4</a>.  Querying for a Server Cookie</span>

   In many cases, a client will learn the Server Cookie for a server as
   the "side effect" of another transaction; however, there may be times
   when this is not desirable.  Therefore, a means is provided for
   obtaining a Server Cookie through an extension to the QUERY opcode
   for which opcode most existing implementations require that QDCOUNT
   be one (1) (see <a href="rfc1035.html#section-4.1.2">Section 4.1.2 of [RFC1035]</a>).



<span class="grey">Eastlake &amp; Andrews           Standards Track                   [Page 14]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-15" id="page-15" name="page-15"> </a>
<span class="grey"><a href="rfc7873.html">RFC 7873</a>                       DNS Cookies                      May 2016</span>


   For servers with DNS Cookies enabled, the QUERY opcode behavior is
   extended to support queries with an empty Question Section (a QDCOUNT
   of zero (0)), provided that an OPT record is present with a COOKIE
   option.  Such servers will send a reply that has an empty
   Answer Section and has a COOKIE option containing the Client Cookie
   and a valid Server Cookie.

   If such a query provided just a Client Cookie and no Server Cookie,
   the response SHALL have the RCODE NOERROR.

   This mechanism can also be used to confirm/re-establish an existing
   Server Cookie by sending a cached Server Cookie with the
   Client Cookie.  In this case, the response SHALL have the RCODE
   BADCOOKIE if the Server Cookie sent with the query was invalid and
   the RCODE NOERROR if it was valid.

   Servers that don't support the COOKIE option will normally send
   FORMERR in response to such a query, though REFUSED, NOTIMP, and
   NOERROR without a COOKIE option are also possible in such responses.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/6.%20%20NAT%20Considerations%20and%20Anycast%20Server%20Considerations"></a><a class="selflink" href="#section-6" name="section-6">6</a>.  NAT Considerations and Anycast Server Considerations</span>

   In the classic Internet, DNS Cookies could simply be a pseudorandom
   function of the Client IP Address and a Server Secret or the Server
   IP Address and a Client Secret.  You would want to compute the
   Server Cookie that way, so a client could cache its Server Cookie for
   a particular server for an indefinite amount of time and the server
   could easily regenerate and check it.  You could consider the
   Client Cookie to be a weak client signature over the Server IP
   Address that the client checks in replies, and you could extend this
   signature to cover the request ID, for example, or any other
   information that is returned unchanged in the reply.

   But we have this reality called "NAT" [<a href="rfc3022.html" title='"Traditional IP Network Address Translator (Traditional NAT)"'>RFC3022</a>] (including, for the
   purposes of this document, NAT-PT, which has been declared Historic
   [<a href="rfc4966.html" title='"Reasons to Move the Network Address Translator - Protocol Translator (NAT-PT) to Historic Status"'>RFC4966</a>]).  There is no problem with DNS transactions between
   clients and servers behind a NAT box using local IP addresses.  Nor
   is there a problem with NAT translation of internal addresses to
   external addresses or translations between IPv4 and IPv6 addresses,
   as long as the address mapping is relatively stable.  Should the
   external IP address to which an internal client is being mapped
   change occasionally, the disruption is little more than when a client
   rolls over its COOKIE secret.  Also, external access to a DNS server
   behind a NAT box is normally handled by a fixed mapping that forwards
   externally received DNS requests to a specific host.






<span class="grey">Eastlake &amp; Andrews           Standards Track                   [Page 15]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-16" id="page-16" name="page-16"> </a>
<span class="grey"><a href="rfc7873.html">RFC 7873</a>                       DNS Cookies                      May 2016</span>


   However, NAT devices sometimes also map ports.  This can cause
   multiple DNS requests and responses from multiple internal hosts to
   be mapped to a smaller number of external IP addresses, such as one
   address.  Thus, there could be many clients behind a NAT box that
   appear to come from the same source IP address to a server outside
   that NAT box.  If one of these were an attacker (think "zombie" or
   "botnet") behind a NAT box, that attacker could get the Server Cookie
   for some server for the outgoing IP address by just making some
   random request to that server.  It could then include that
   Server Cookie in the COOKIE option of requests to the server with the
   forged local IP address of some other host and/or client behind the
   NAT box.  (An attacker's possession of this Server Cookie will not
   help in forging responses to cause cache poisoning, as such responses
   are protected by the required Client Cookie.)

   To fix this potential defect, it is necessary to distinguish
   different clients behind a NAT box from the point of view of the
   server.  This is why the Server Cookie is specified as a pseudorandom
   function of both the request source IP address and the Client Cookie.
   From this inclusion of the Client Cookie in the calculation of the
   Server Cookie, it follows that, for any particular server, a stable
   Client Cookie is needed.  If, for example, the request ID was
   included in the calculation of the Client Cookie, it would normally
   change with each request to a particular server.  This would mean
   that each request would have to be sent twice: first, to learn the
   new Server Cookie based on this new Client Cookie based on the new
   ID, and then again using this new Client Cookie to actually get an
   answer.  Thus, the input to the Client Cookie computation must be
   limited to the Server IP Address and one or more things that change
   slowly, such as the Client Secret.

   In principle, there could be a similar problem for servers, not due
   to NAT but due to mechanisms like anycast that may cause requests to
   a DNS server at an IP address to be delivered to any one of several
   machines.  (External requests to a DNS server behind a NAT box
   usually occur via port forwarding such that all such requests go to
   one host.)  However, it is impossible to solve this in the way that
   the similar problem was solved for NATed clients; if the
   Server Cookie was included in the calculation of the Client Cookie in
   the same way that the Client Cookie is included in the Server Cookie,
   you would just get an almost infinite series of errors as a request
   was repeatedly retried.

   For servers accessed via anycast, to successfully support
   DNS Cookies, either (1) the server clones must all use the same
   Server Secret or (2) the mechanism that distributes requests to the
   server clones must cause the requests from a particular client to go
   to a particular server for a sufficiently long period of time that



<span class="grey">Eastlake &amp; Andrews           Standards Track                   [Page 16]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-17" id="page-17" name="page-17"> </a>
<span class="grey"><a href="rfc7873.html">RFC 7873</a>                       DNS Cookies                      May 2016</span>


   extra requests due to changes in Server Cookies resulting from
   accessing different server machines are not unduly burdensome.  (When
   such anycast-accessed servers act as recursive servers or otherwise
   act as clients, they normally use a different unique address to
   source their requests, to avoid confusion in the delivery of
   responses.)

   For simplicity, it is RECOMMENDED that the same Server Secret be used
   by each DNS server in a set of anycast servers.  If there is limited
   time skew in updating this secret in different anycast servers, this
   can be handled by a server accepting requests containing a
   Server Cookie based on either its old or new secret for the maximum
   likely time period of such time skew (see also <a href="#section-7.1">Section 7.1</a>).

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/7.%20%20Operational%20and%20Deployment%20Considerations"></a><a class="selflink" href="#section-7" name="section-7">7</a>.  Operational and Deployment Considerations</span>

   The DNS Cookie mechanism is designed for incremental deployment and
   to complement the orthogonal techniques in [<a href="rfc5452.html" title='"Measures for Making DNS More Resilient against Forged Answers"'>RFC5452</a>].  Either or both
   techniques can be deployed independently at each DNS server and
   client.  Thus, installation at the client and server end need not be
   synchronized.

   In particular, a DNS server or client that implements the DNS Cookie
   mechanism can interoperate successfully with a DNS client or server
   that does not implement this mechanism, although, of course, in this
   case it will not get the benefit of the mechanism and the server
   involved might choose to severely rate-limit responses.  When such a
   server or client interoperates with a client or server that also
   implements the DNS Cookie mechanism, these servers and clients get
   the security benefits of the DNS Cookie mechanism.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/7.1.%20%20Client%20and%20Server%20Secret%20Rollover"></a><a class="selflink" href="#section-7.1" name="section-7.1">7.1</a>.  Client and Server Secret Rollover</span>

   The longer a secret is used, the higher the probability that it has
   been compromised.  Thus, clients and servers are configured with a
   lifetime setting for their secret, and they roll over to a new secret
   when that lifetime expires, or earlier due to deliberate jitter as
   described below.  The default lifetime is one day, and the maximum
   permitted is one month.  To be precise and to make it practical to
   stay within limits despite long holiday weekends, daylight saving
   time shifts, and the like, clients and servers MUST NOT continue to
   use the same secret in new requests and responses for more than
   36 days and SHOULD NOT continue to do so for more than 26 hours.

   Many clients rolling over their secret at the same time could briefly
   increase server traffic, and exactly predictable rollover times for
   clients or servers might facilitate guessing attacks.  For example,
   an attacker might increase the priority of attacking secrets they



<span class="grey">Eastlake &amp; Andrews           Standards Track                   [Page 17]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-18" id="page-18" name="page-18"> </a>
<span class="grey"><a href="rfc7873.html">RFC 7873</a>                       DNS Cookies                      May 2016</span>


   believe will be in effect for an extended period of time.  To avoid
   rollover synchronization and predictability, it is RECOMMENDED that
   pseudorandom jitter in the range of plus zero to minus at least 40%
   be applied to the time until a scheduled rollover of a COOKIE secret.

   It is RECOMMENDED that a client keep the Client Cookie it is
   expecting in a reply until there is no longer an outstanding request
   associated with that Client Cookie that the client is tracking.  This
   avoids rejection of replies due to a bad Client Cookie right after a
   change in the Client Secret.

   It is RECOMMENDED that a server retain its previous secret after a
   rollover to a new secret for a configurable period of time not less
   than 1 second or more than 300 seconds, with a default configuration
   of 150 seconds.  Requests with Server Cookies based on its previous
   secret are treated as a correct Server Cookie during that time.  When
   a server responds to a request containing an old Server Cookie that
   the server is treating as correct, the server MUST include a new
   Server Cookie in its response.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/7.2.%20%20Counters"></a><a class="selflink" href="#section-7.2" name="section-7.2">7.2</a>.  Counters</span>

   It is RECOMMENDED that implementations include counters of the
   occurrences of the various types of requests and responses described
   in <a href="#section-5">Section 5</a>.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/8.%20%20IANA%20Considerations"></a><a class="selflink" href="#section-8" name="section-8">8</a>.  IANA Considerations</span>

   IANA has assigned the following DNS EDNS0 option code:

       Value       Name      Status        Reference
      --------    ------    --------    ---------------
         10       COOKIE    Standard       <a href="rfc7873.html">RFC 7873</a>

   IANA has assigned the following DNS error code as an early allocation
   per [<a href="rfc7120.html" title='"Early IANA Allocation of Standards Track Code Points"'>RFC7120</a>]:

       RCODE       Name       Description                 Reference
      --------  ---------  -------------------------   ---------------
         23     BADCOOKIE  Bad/missing Server Cookie      <a href="rfc7873.html">RFC 7873</a>











<span class="grey">Eastlake &amp; Andrews           Standards Track                   [Page 18]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-19" id="page-19" name="page-19"> </a>
<span class="grey"><a href="rfc7873.html">RFC 7873</a>                       DNS Cookies                      May 2016</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/9.%20%20Security%20Considerations"></a><a class="selflink" href="#section-9" name="section-9">9</a>.  Security Considerations</span>

   DNS Cookies provide a weak form of authentication of DNS requests and
   responses.  In particular, they provide no protection against
   "on-path" adversaries; that is, they provide no protection against
   any adversary that can observe the plaintext DNS traffic, such as an
   on-path router, bridge, or any device on an on-path shared link
   (unless the DNS traffic in question on that path is encrypted).

   For example, if a host is connected via an unsecured IEEE Std. 802.11
   link (Wi-Fi), any device in the vicinity that could receive and
   decode the 802.11 transmissions must be considered "on path".  On the
   other hand, in a similar situation but one where 802.11 Robust
   Security (WPA2, also called "Wi-Fi Protected Access 2") is
   appropriately deployed on the Wi-Fi network nodes, only the
   Access Point via which the host is connecting is "on path" as far as
   the 802.11 link is concerned.

   Despite these limitations, deployment of DNS Cookies on the global
   Internet is expected to provide a significant reduction in the
   available launch points for the traffic amplification and denial-of-
   service forgery attacks described in <a href="#section-2">Section 2</a> above.

   Work is underway in the IETF DPRIVE working group to provide
   confidentiality for DNS requests and responses that would be
   compatible with DNS Cookies.

   Should stronger message/transaction security be desired, it is
   suggested that TSIG or SIG(0) security be used (see <a href="#section-3.2">Section 3.2</a>);
   however, it may be useful to use DNS Cookies in conjunction with
   these features.  In particular, DNS Cookies could screen out many DNS
   messages before the cryptographic computations of TSIG or SIG(0) are
   required, and if SIG(0) is in use, DNS Cookies could usefully screen
   out many requests given that SIG(0) does not screen requests but only
   authenticates the response of complete transactions.

   An attacker that does not know the Server Cookie could do a variety
   of things, such as omitting the COOKIE option or sending a random
   Server Cookie.  In general, DNS servers need to take other measures,
   including rate-limiting responses, to protect from abuse in such
   cases.  See further information in <a href="#section-5.2">Section 5.2</a>.

   When a server or client starts receiving an increased level of
   requests with bad Server Cookies or replies with bad Client Cookies,
   it would be reasonable for it to believe that it is likely under
   attack, and it should consider a more frequent rollover of its
   secret.  More rapid rollover decreases the benefit to a
   cookie-guessing attacker if they succeed in guessing a cookie.



<span class="grey">Eastlake &amp; Andrews           Standards Track                   [Page 19]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-20" id="page-20" name="page-20"> </a>
<span class="grey"><a href="rfc7873.html">RFC 7873</a>                       DNS Cookies                      May 2016</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/9.1.%20%20Cookie%20Algorithm%20Considerations"></a><a class="selflink" href="#section-9.1" name="section-9.1">9.1</a>.  Cookie Algorithm Considerations</span>

   The cookie computation algorithm for use in DNS Cookies SHOULD be
   based on a pseudorandom function at least as strong as 64-bit FNV
   (Fowler/Noll/Vo [<a href="#ref-FNV" title='"The FNV Non-Cryptographic Hash Algorithm"'>FNV</a>]), because an excessively weak or trivial
   algorithm could enable adversaries to guess cookies.  However, in
   light of the lightweight plaintext token security provided by
   DNS Cookies, a strong cryptography hash algorithm may not be
   warranted in many cases and would cause an increased computational
   burden.  Nevertheless, there is nothing wrong with using something
   stronger -- for example, HMAC-SHA-256 [<a href="rfc6234.html" title='"US Secure Hash Algorithms (SHA and SHA-based HMAC and HKDF)"'>RFC6234</a>] truncated to 64 bits,
   assuming that a DNS processor has adequate computational resources
   available.  DNS implementations or applications that need somewhat
   stronger security without a significant increase in computational
   load should consider more frequent changes in their client and/or
   Server Secret; however, this does require more frequent generation of
   a cryptographically strong random number [<a href="rfc4086.html" title='"Randomness Requirements for Security"'>RFC4086</a>].  See Appendices A
   and B for specific examples of cookie computation algorithms.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/10.%20%20Implementation%20Considerations"></a><a class="selflink" href="#section-10" name="section-10">10</a>.  Implementation Considerations</span>

   The DNS COOKIE option specified herein is implemented in BIND 9.10
   using an experimental option code.  BIND 9.10.3 (and later) use the
   allocated option code.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/11.%20%20References"></a><a class="selflink" href="#section-11" name="section-11">11</a>.  References</span>

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/11.1.%20%20Normative%20References"></a><a class="selflink" href="#section-11.1" name="section-11.1">11.1</a>.  Normative References</span>

   [<a id="ref-RFC1035" name="ref-RFC1035">RFC1035</a>]  Mockapetris, P., "Domain names - implementation and
              specification", STD 13, <a href="rfc1035.html">RFC 1035</a>, DOI 10.17487/RFC1035,
              November 1987, &lt;<a href="http://www.rfc-editor.org/info/rfc1035">http://www.rfc-editor.org/info/rfc1035</a>&gt;.

   [<a id="ref-RFC2119" name="ref-RFC2119">RFC2119</a>]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", <a href="https://tools.ietf.org/html/bcp14">BCP 14</a>, <a href="rfc2119.html">RFC 2119</a>,
              DOI 10.17487/RFC2119, March 1997,
              &lt;<a href="http://www.rfc-editor.org/info/rfc2119">http://www.rfc-editor.org/info/rfc2119</a>&gt;.

   [<a id="ref-RFC4086" name="ref-RFC4086">RFC4086</a>]  Eastlake 3rd, D., Schiller, J., and S. Crocker,
              "Randomness Requirements for Security", <a href="https://tools.ietf.org/html/bcp106">BCP 106</a>, <a href="rfc4086.html">RFC 4086</a>,
              DOI 10.17487/RFC4086, June 2005,
              &lt;<a href="http://www.rfc-editor.org/info/rfc4086">http://www.rfc-editor.org/info/rfc4086</a>&gt;.









<span class="grey">Eastlake &amp; Andrews           Standards Track                   [Page 20]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-21" id="page-21" name="page-21"> </a>
<span class="grey"><a href="rfc7873.html">RFC 7873</a>                       DNS Cookies                      May 2016</span>


   [<a id="ref-RFC6891" name="ref-RFC6891">RFC6891</a>]  Damas, J., Graff, M., and P. Vixie, "Extension Mechanisms
              for DNS (EDNS(0))", STD 75, <a href="rfc6891.html">RFC 6891</a>,
              DOI 10.17487/RFC6891, April 2013,
              &lt;<a href="http://www.rfc-editor.org/info/rfc6891">http://www.rfc-editor.org/info/rfc6891</a>&gt;.

   [<a id="ref-RFC7120" name="ref-RFC7120">RFC7120</a>]  Cotton, M., "Early IANA Allocation of Standards Track Code
              Points", <a href="https://tools.ietf.org/html/bcp100">BCP 100</a>, <a href="rfc7120.html">RFC 7120</a>, DOI 10.17487/RFC7120,
              January 2014, &lt;<a href="http://www.rfc-editor.org/info/rfc7120">http://www.rfc-editor.org/info/rfc7120</a>&gt;.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/11.2.%20%20Informative%20References"></a><a class="selflink" href="#section-11.2" name="section-11.2">11.2</a>.  Informative References</span>

   [<a id="ref-FNV" name="ref-FNV">FNV</a>]      Fowler, G., Noll, L., Vo, K., and D. Eastlake 3rd, "The
              FNV Non-Cryptographic Hash Algorithm", Work in Progress,
              <a href="https://tools.ietf.org/html/draft-eastlake-fnv-10">draft-eastlake-fnv-10</a>, October 2015.

   [<a id="ref-Kaminsky" name="ref-Kaminsky">Kaminsky</a>] Olney, M., Mullen, P., and K. Miklavcic, "Dan Kaminsky's
              2008 DNS Vulnerability", July 2008, &lt;<a href="https://www.ietf.org/mail-archive/web/dnsop/current/pdf2jgx6rzxN4.pdf">https://www.ietf.org/</a>
              <a href="https://www.ietf.org/mail-archive/web/dnsop/current/pdf2jgx6rzxN4.pdf">mail-archive/web/dnsop/current/pdf2jgx6rzxN4.pdf</a>&gt;.

   [<a id="ref-RFC2845" name="ref-RFC2845">RFC2845</a>]  Vixie, P., Gudmundsson, O., Eastlake 3rd, D., and B.
              Wellington, "Secret Key Transaction Authentication for DNS
              (TSIG)", <a href="rfc2845.html">RFC 2845</a>, DOI 10.17487/RFC2845, May 2000,
              &lt;<a href="http://www.rfc-editor.org/info/rfc2845">http://www.rfc-editor.org/info/rfc2845</a>&gt;.

   [<a id="ref-RFC2930" name="ref-RFC2930">RFC2930</a>]  Eastlake 3rd, D., "Secret Key Establishment for DNS
              (TKEY RR)", <a href="rfc2930.html">RFC 2930</a>, DOI 10.17487/RFC2930,
              September 2000, &lt;<a href="http://www.rfc-editor.org/info/rfc2930">http://www.rfc-editor.org/info/rfc2930</a>&gt;.

   [<a id="ref-RFC2931" name="ref-RFC2931">RFC2931</a>]  Eastlake 3rd, D., "DNS Request and Transaction Signatures
              ( SIG(0)s )", <a href="rfc2931.html">RFC 2931</a>, DOI 10.17487/RFC2931,
              September 2000, &lt;<a href="http://www.rfc-editor.org/info/rfc2931">http://www.rfc-editor.org/info/rfc2931</a>&gt;.

   [<a id="ref-RFC3022" name="ref-RFC3022">RFC3022</a>]  Srisuresh, P. and K. Egevang, "Traditional IP Network
              Address Translator (Traditional NAT)", <a href="rfc3022.html">RFC 3022</a>,
              DOI 10.17487/RFC3022, January 2001,
              &lt;<a href="http://www.rfc-editor.org/info/rfc3022">http://www.rfc-editor.org/info/rfc3022</a>&gt;.

   [<a id="ref-RFC4033" name="ref-RFC4033">RFC4033</a>]  Arends, R., Austein, R., Larson, M., Massey, D., and S.
              Rose, "DNS Security Introduction and Requirements",
              <a href="rfc4033.html">RFC 4033</a>, DOI 10.17487/RFC4033, March 2005,
              &lt;<a href="http://www.rfc-editor.org/info/rfc4033">http://www.rfc-editor.org/info/rfc4033</a>&gt;.

   [<a id="ref-RFC4034" name="ref-RFC4034">RFC4034</a>]  Arends, R., Austein, R., Larson, M., Massey, D., and S.
              Rose, "Resource Records for the DNS Security Extensions",
              <a href="rfc4034.html">RFC 4034</a>, DOI 10.17487/RFC4034, March 2005,
              &lt;<a href="http://www.rfc-editor.org/info/rfc4034">http://www.rfc-editor.org/info/rfc4034</a>&gt;.





<span class="grey">Eastlake &amp; Andrews           Standards Track                   [Page 21]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-22" id="page-22" name="page-22"> </a>
<span class="grey"><a href="rfc7873.html">RFC 7873</a>                       DNS Cookies                      May 2016</span>


   [<a id="ref-RFC4035" name="ref-RFC4035">RFC4035</a>]  Arends, R., Austein, R., Larson, M., Massey, D., and S.
              Rose, "Protocol Modifications for the DNS Security
              Extensions", <a href="rfc4035.html">RFC 4035</a>, DOI 10.17487/RFC4035, March 2005,
              &lt;<a href="http://www.rfc-editor.org/info/rfc4035">http://www.rfc-editor.org/info/rfc4035</a>&gt;.

   [<a id="ref-RFC4966" name="ref-RFC4966">RFC4966</a>]  Aoun, C. and E. Davies, "Reasons to Move the Network
              Address Translator - Protocol Translator (NAT-PT) to
              Historic Status", <a href="rfc4966.html">RFC 4966</a>, DOI 10.17487/RFC4966,
              July 2007, &lt;<a href="http://www.rfc-editor.org/info/rfc4966">http://www.rfc-editor.org/info/rfc4966</a>&gt;.

   [<a id="ref-RFC5452" name="ref-RFC5452">RFC5452</a>]  Hubert, A. and R. van Mook, "Measures for Making DNS
              More Resilient against Forged Answers", <a href="rfc5452.html">RFC 5452</a>,
              DOI 10.17487/RFC5452, January 2009,
              &lt;<a href="http://www.rfc-editor.org/info/rfc5452">http://www.rfc-editor.org/info/rfc5452</a>&gt;.

   [<a id="ref-RFC6234" name="ref-RFC6234">RFC6234</a>]  Eastlake 3rd, D. and T. Hansen, "US Secure Hash Algorithms
              (SHA and SHA-based HMAC and HKDF)", <a href="rfc6234.html">RFC 6234</a>,
              DOI 10.17487/RFC6234, May 2011,
              &lt;<a href="http://www.rfc-editor.org/info/rfc6234">http://www.rfc-editor.org/info/rfc6234</a>&gt;.
































<span class="grey">Eastlake &amp; Andrews           Standards Track                   [Page 22]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-23" id="page-23" name="page-23"> </a>
<span class="grey"><a href="rfc7873.html">RFC 7873</a>                       DNS Cookies                      May 2016</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/Appendix%20A.%20%20Example%20Client%20Cookie%20Algorithms"></a><a class="selflink" href="#appendix-A" name="appendix-A">Appendix A</a>.  Example Client Cookie Algorithms</span>

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/A.1.%20%20A%20Simple%20Algorithm"></a><a class="selflink" href="#appendix-A.1" name="appendix-A.1">A.1</a>.  A Simple Algorithm</span>

   A simple example method to compute Client Cookies is the FNV64 [<a href="#ref-FNV" title='"The FNV Non-Cryptographic Hash Algorithm"'>FNV</a>]
   of the Client IP Address, the Server IP Address, and the Client
   Secret:

      Client Cookie =
         FNV64( Client IP Address | Server IP Address | Client Secret )

   where "|" indicates concatenation.  Some computational resources may
   be saved by pre-computing FNV64 through the Client IP Address.  (If
   the order of the items concatenated above is changed to put the
   Server IP Address last, it might be possible to further reduce the
   computational effort by pre-computing FNV64 through the bytes of both
   the Client IP Address and the Client Secret, but this would reduce
   the strength of the Client Cookie and is NOT RECOMMENDED.)

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/A.2.%20%20A%20More%20Complex%20Algorithm"></a><a class="selflink" href="#appendix-A.2" name="appendix-A.2">A.2</a>.  A More Complex Algorithm</span>

   A more complex algorithm to calculate Client Cookies is given below.
   It uses more computational resources than the simpler algorithm shown
   in <a href="#appendix-A.1">Appendix A.1</a>.

      Client Cookie =
         HMAC-SHA256-64( Client IP Address | Server IP Address,
                          Client Secret )

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/Appendix%20B.%20%20Example%20Server%20Cookie%20Algorithms"></a><a class="selflink" href="#appendix-B" name="appendix-B">Appendix B</a>.  Example Server Cookie Algorithms</span>

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/B.1.%20%20A%20Simple%20Algorithm"></a><a class="selflink" href="#appendix-B.1" name="appendix-B.1">B.1</a>.  A Simple Algorithm</span>

   An example of a simple method producing a 64-bit Server Cookie is the
   FNV64 [<a href="#ref-FNV" title='"The FNV Non-Cryptographic Hash Algorithm"'>FNV</a>] of the request IP address, the Client Cookie, and the
   Server Secret.

      Server Cookie =
         FNV64( Client IP Address | Client Cookie | Server Secret )

   where "|" represents concatenation.  (If the order of the items
   concatenated was changed, it might be possible to reduce the
   computational effort by pre-computing FNV64 through the bytes of the
   Server Secret and Client Cookie, but this would reduce the strength
   of the Server Cookie and is NOT RECOMMENDED.)






<span class="grey">Eastlake &amp; Andrews           Standards Track                   [Page 23]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-24" id="page-24" name="page-24"> </a>
<span class="grey"><a href="rfc7873.html">RFC 7873</a>                       DNS Cookies                      May 2016</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/B.2.%20%20A%20More%20Complex%20Algorithm"></a><a class="selflink" href="#appendix-B.2" name="appendix-B.2">B.2</a>.  A More Complex Algorithm</span>

   Since the Server Cookie has a variable size, the server can store
   various information in that field as long as it is hard for an
   adversary to guess the entire quantity used for authentication.
   There should be 64 bits of entropy in the Server Cookie; for example,
   it could have a sub-field of 64 bits computed pseudorandomly with the
   Server Secret as one of the inputs to the pseudorandom function.
   Types of additional information that could be stored include a
   timestamp and/or a nonce.

   The example below is one variation of the Server Cookie that has been
   implemented in BIND 9.10.3 (and later) releases, where the
   Server Cookie is 128 bits, composed as follows:

         Sub-field      Size
         ---------   ---------
           Nonce      32 bits
           Time       32 bits
           Hash       64 bits

   With this algorithm, the server sends a new 128-bit cookie back with
   every request.  The Nonce field assures a low probability that there
   would be a duplicate.

   The Time field gives the server time and makes it easy to reject old
   cookies.

   The Hash part of the Server Cookie is the part that is hard to guess.
   In BIND 9.10.3 (and later), its computation can be configured to use
   AES, HMAC-SHA-1, or, as shown below, HMAC-SHA-256:

       hash =
           HMAC-SHA256-64( Server Secret,
               (Client Cookie | Nonce | Time | Client IP Address) )

   where "|" represents concatenation.














<span class="grey">Eastlake &amp; Andrews           Standards Track                   [Page 24]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-25" id="page-25" name="page-25"> </a>
<span class="grey"><a href="rfc7873.html">RFC 7873</a>                       DNS Cookies                      May 2016</span>


Acknowledgments

   The suggestions and contributions of the following are gratefully
   acknowledged:

      Alissa Cooper, Bob Harold, Paul Hoffman, David Malone, Yoav Nir,
      Gayle Noble, Dan Romascanu, Tim Wicinski, and Peter Yee

Authors' Addresses

   Donald E. Eastlake 3rd
   Huawei Technologies
   155 Beaver Street
   Milford, MA  01757
   United States

   Phone: +1-508-333-2270
   Email: d3e3e3@gmail.com


   Mark Andrews
   Internet Systems Consortium
   950 Charter Street
   Redwood City, CA  94063
   United States

   Email: marka@isc.org
























Eastlake &amp; Andrews           Standards Track                   [Page 25]

</pre><br/>
    <span class="noprint"><small><small>Html markup produced by rfcmarkup 1.126, available from
      <a href="https://tools.ietf.org/tools/rfcmarkup/">https://tools.ietf.org/tools/rfcmarkup/</a>
    </small></small></span>
  </div>




</body><!-- Mirrored from tools.ietf.org/html/rfc7873 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 06 Mar 2018 23:18:19 GMT --></html>