<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml"><!-- Mirrored from tools.ietf.org/html/rfc7250 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 14 Aug 2018 14:05:03 GMT --><!-- Added by HTTrack --><head><meta content="text/html;charset=utf-8" http-equiv="content-type"/><!-- /Added by HTTrack -->

    <meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
    <meta content="index,follow" name="robots"/>
    <meta content="rfcmarkup version 1.127" name="creator"/>
    <link href="http://purl.org/dc/elements/1.1/" rel="schema.DC"/>
<meta content="draft-wouters-tls-oob-pubkey" name="DC.Relation.Replaces"/>
<meta content="urn:ietf:rfc:7250" name="DC.Identifier"/>
<meta content="June, 2014" name="DC.Date.Issued"/>
<meta content="Weiler, Samuel" name="DC.Creator"/>
<meta content="Gilmore, John" name="DC.Creator"/>
<meta content="Tschofenig, Hannes" name="DC.Creator"/>
<meta content="Kivinen, Tero" name="DC.Creator"/>
<meta content="Wouters, Paul" name="DC.Creator"/>
<meta content="This document specifies a new certificate type and two TLS extensions
for exchanging raw public keys in Transport Layer Security (TLS) and
Datagram Transport Layer Security (DTLS). The new certificate type
allows raw public keys to be used for authentication." name="DC.Description.Abstract"/>
<meta content="Using Raw Public Keys in Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS)" name="DC.Title"/>

    <link href="https://tools.ietf.org/images/rfc.png" rel="icon" type="image/png"/>
    <link href="https://tools.ietf.org/images/rfc.png" rel="shortcut icon" type="image/png"/>
    <title>RFC 7250 - Using Raw Public Keys in Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS)</title>
    
    
    <style type="text/css">
	@media only screen 
	  and (min-width: 992px)
	  and (max-width: 1199px) {
	    body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 768px)
	  and (max-width: 991px) {
            body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 480px)
	  and (max-width: 767px) {
            body { font-size: 11pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (max-width: 479px) {
            body { font-size: 8pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-device-width : 375px) 
	  and (max-device-width : 667px) {
            body { font-size: 9.5pt; }
            div.content { width: 96ex; margin: 0 1px; }
        }
	@media only screen 
	  and (min-device-width: 1200px) {
            body { font-size: 10pt; margin: 0 4em; }
            div.content { width: 96ex; margin: 0; }
        }
        h1, h2, h3, h4, h5, h6, .h1, .h2, .h3, .h4, .h5, .h6 {
	    font-weight: bold;
            line-height: 0pt;
            display: inline;
            white-space: pre;
            font-family: monospace;
            font-size: 1em;
	    font-weight: bold;
        }
        pre {
            font-size: 1em;
            margin-top: 0px;
            margin-bottom: 0px;
        }
	.pre {
	    white-space: pre;
	    font-family: monospace;
	}
	.header{
	    font-weight: bold;
	}
        .newpage {
            page-break-before: always;
        }
        .invisible {
            text-decoration: none;
            color: white;
        }
        a.selflink {
          color: black;
          text-decoration: none;
        }
        @media print {
            body {
                font-family: monospace;
                font-size: 10.5pt;
            }
            h1, h2, h3, h4, h5, h6 {
                font-size: 1em;
            }
        
            a:link, a:visited {
                color: inherit;
                text-decoration: none;
            }
            .noprint {
                display: none;
            }
        }
	@media screen {
	    .grey, .grey a:link, .grey a:visited {
		color: #777;
	    }
            .docinfo {
                background-color: #EEE;
            }
            .top {
                border-top: 7px solid #EEE;
            }
            .bgwhite  { background-color: white; }
            .bgred    { background-color: #F44; }
            .bggrey   { background-color: #666; }
            .bgbrown  { background-color: #840; }            
            .bgorange { background-color: #FA0; }
            .bgyellow { background-color: #EE0; }
            .bgmagenta{ background-color: #F4F; }
            .bgblue   { background-color: #66F; }
            .bgcyan   { background-color: #4DD; }
            .bggreen  { background-color: #4F4; }

            .legend   { font-size: 90%; }
            .cplate   { font-size: 70%; border: solid grey 1px; }
	}
    </style>
    <!--[if IE]>
    <style>
    body {
       font-size: 13px;
       margin: 10px 10px;
    }
    </style>
    <![endif]-->

    <script type="text/javascript"><!--
    function addHeaderTags() {
	var spans = document.getElementsByTagName("span");
	for (var i=0; i < spans.length; i++) {
	    var elem = spans[i];
	    if (elem) {
		var level = elem.getAttribute("class");
                if (level == "h1" || level == "h2" || level == "h3" || level == "h4" || level == "h5" || level == "h6") {
                    elem.innerHTML = "<"+level+">"+elem.innerHTML+"</"+level+">";		
                }
	    }
	}
    }
    var legend_html = "Colour legend:<br />      <table>         <tr><td>Unknown:</td>                   <td><span class='cplate bgwhite'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft:</td>                     <td><span class='cplate bgred'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Informational:</td>             <td><span class='cplate bgorange'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Experimental:</td>              <td><span class='cplate bgyellow'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Best Common Practice:</td>      <td><span class='cplate bgmagenta'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Proposed Standard:</td>         <td><span class='cplate bgblue'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft Standard (old designation):</td> <td><span class='cplate bgcyan'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Internet Standard:</td>         <td><span class='cplate bggreen'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Historic:</td>                  <td><span class='cplate bggrey'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Obsolete:</td>                  <td><span class='cplate bgbrown'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>     </table>";
    function showElem(id) {
        var elem = document.getElementById(id);
        elem.innerHTML = eval(id+"_html");
        elem.style.visibility='visible';
    }
    function hideElem(id) {
        var elem = document.getElementById(id);
        elem.style.visibility='hidden';        
        elem.innerHTML = "";
    }
    // -->
    </script>
</head>
<body onload="addHeaderTags()">
  <div class="content">
   <div style="height: 13px;">
      <div class="pre noprint docinfo bgblue" onclick="showElem('legend');" onmouseout="hideElem('legend')" onmouseover="this.style.cursor='pointer';" style="height: 6px; position: absolute;" title="Click for colour legend.">                                                                        </div>
      <div class="docinfo noprint pre legend" id="legend" onmouseout="hideElem('legend');" onmouseover="showElem('legend');" style="position:absolute; top: 4px; left: 4ex; visibility:hidden; background-color: white; padding: 4px 9px 5px 7px; border: solid #345 1px; ">
      </div>
   </div>
<span class="pre noprint docinfo top">[<a href="index.html" title="Document search and retrieval page">Docs</a>] [<a href="https://tools.ietf.org/rfc/rfc7250.txt" title="Plaintext version of this document">txt</a>|<a href="https://tools.ietf.org/pdf/rfc7250" title="PDF version of this document">pdf</a>] [<a href="https://tools.ietf.org/html/draft-ietf-tls-oob-pubkey" title="draft-ietf-tls-oob-pubkey">draft-ietf-tls-...</a>] [<a href="https://datatracker.ietf.org/doc/rfc7250" title="IESG Datatracker information for this document">Tracker</a>] [<a href="https://tools.ietf.org/rfcdiff?difftype=--hwdiff&amp;url2=rfc7250" title="Inline diff (wdiff)">Diff1</a>] [<a href="https://tools.ietf.org/rfcdiff?url2=rfc7250" title="Side-by-side diff">Diff2</a>] [<a href="https://www.rfc-editor.org/errata_search.php?rfc=7250">Errata</a>]</span><br/>
<span class="pre noprint docinfo">                                                                        </span><br/>
<span class="pre noprint docinfo">                                                       PROPOSED STANDARD</span><br/>
<span class="pre noprint docinfo">                                                            <span style="color: #C00;">Errata Exist</span></span><br/>
<pre>Internet Engineering Task Force (IETF)                   P. Wouters, Ed.
Request for Comments: 7250                                       Red Hat
Category: Standards Track                             H. Tschofenig, Ed.
ISSN: 2070-1721                                                 ARM Ltd.
                                                              J. Gilmore
                                          Electronic Frontier Foundation
                                                               S. Weiler
                                                                 Parsons
                                                              T. Kivinen
                                                           INSIDE Secure
                                                               June 2014


        <span class="h1">Using Raw Public Keys in Transport Layer Security (TLS)</span>
              <span class="h1">and Datagram Transport Layer Security (DTLS)</span>

Abstract

   This document specifies a new certificate type and two TLS extensions
   for exchanging raw public keys in Transport Layer Security (TLS) and
   Datagram Transport Layer Security (DTLS).  The new certificate type
   allows raw public keys to be used for authentication.

Status of This Memo

   This is an Internet Standards Track document.

   This document is a product of the Internet Engineering Task Force
   (IETF).  It represents the consensus of the IETF community.  It has
   received public review and has been approved for publication by the
   Internet Engineering Steering Group (IESG).  Further information on
   Internet Standards is available in <a href="rfc5741.html#section-2">Section 2 of RFC 5741</a>.

   Information about the current status of this document, any errata,
   and how to provide feedback on it may be obtained at
   <a href="http://www.rfc-editor.org/info/rfc7250">http://www.rfc-editor.org/info/rfc7250</a>.















<span class="grey">Wouters, et al.              Standards Track                    [Page 1]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-2" id="page-2" name="page-2"> </a>
<span class="grey"><a href="rfc7250.html">RFC 7250</a>            Using Raw Public Keys in TLS/DTLS          June 2014</span>


Copyright Notice

   Copyright (c) 2014 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to <a href="https://tools.ietf.org/html/bcp78">BCP 78</a> and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (<a href="http://trustee.ietf.org/license-info">http://trustee.ietf.org/license-info</a>) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.

Table of Contents

   <a href="#section-1">1</a>.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   <a href="#page-3">3</a>
   <a href="#section-2">2</a>.  Terminology . . . . . . . . . . . . . . . . . . . . . . . . .   <a href="#page-4">4</a>
   <a href="#section-3">3</a>.  Structure of the Raw Public Key Extension . . . . . . . . . .   <a href="#page-4">4</a>
   <a href="#section-4">4</a>.  TLS Client and Server Handshake Behavior  . . . . . . . . . .   <a href="#page-7">7</a>
     <a href="#section-4.1">4.1</a>.  Client Hello  . . . . . . . . . . . . . . . . . . . . . .   <a href="#page-7">7</a>
     <a href="#section-4.2">4.2</a>.  Server Hello  . . . . . . . . . . . . . . . . . . . . . .   <a href="#page-8">8</a>
     <a href="#section-4.3">4.3</a>.  Client Authentication . . . . . . . . . . . . . . . . . .   <a href="#page-9">9</a>
     <a href="#section-4.4">4.4</a>.  Server Authentication . . . . . . . . . . . . . . . . . .   <a href="#page-9">9</a>
   <a href="#section-5">5</a>.  Examples  . . . . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-10">10</a>
     <a href="#section-5.1">5.1</a>.  TLS Server Uses a Raw Public Key  . . . . . . . . . . . .  <a href="#page-10">10</a>
     <a href="#section-5.2">5.2</a>.  TLS Client and Server Use Raw Public Keys . . . . . . . .  <a href="#page-11">11</a>
     5.3.  Combined Usage of Raw Public Keys and X.509 Certificates   12
   <a href="#section-6">6</a>.  Security Considerations . . . . . . . . . . . . . . . . . . .  <a href="#page-13">13</a>
   <a href="#section-7">7</a>.  IANA Considerations . . . . . . . . . . . . . . . . . . . . .  <a href="#page-14">14</a>
   <a href="#section-8">8</a>.  Acknowledgements  . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-14">14</a>
   <a href="#section-9">9</a>.  References  . . . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-15">15</a>
     <a href="#section-9.1">9.1</a>.  Normative References  . . . . . . . . . . . . . . . . . .  <a href="#page-15">15</a>
     <a href="#section-9.2">9.2</a>.  Informative References  . . . . . . . . . . . . . . . . .  <a href="#page-15">15</a>
   <a href="#appendix-A">Appendix A</a>.  Example Encoding . . . . . . . . . . . . . . . . . .  <a href="#page-17">17</a>















<span class="grey">Wouters, et al.              Standards Track                    [Page 2]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-3" id="page-3" name="page-3"> </a>
<span class="grey"><a href="rfc7250.html">RFC 7250</a>            Using Raw Public Keys in TLS/DTLS          June 2014</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/1.%20%20Introduction"></a><a class="selflink" href="#section-1" name="section-1">1</a>.  Introduction</span>

   Traditionally, TLS client and server public keys are obtained in PKIX
   containers in-band as part of the TLS handshake procedure and are
   validated using trust anchors based on a [<a href="#ref-PKIX" title='"Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile"'>PKIX</a>] certification
   authority (CA).  This method can add a complicated trust relationship
   that is difficult to validate.  Examples of such complexity can be
   seen in [<a href="#ref-Defeating-SSL" title='"New Tricks for Defeating SSL in Practice"'>Defeating-SSL</a>].  TLS is, however, also commonly used with
   self-signed certificates in smaller deployments where the self-signed
   certificates are distributed to all involved protocol endpoints out-
   of-band.  This practice does, however, still require the overhead of
   the certificate generation even though none of the information found
   in the certificate is actually used.

   Alternative methods are available that allow a TLS client/server to
   obtain the TLS server/client public key:

   o  The TLS client can obtain the TLS server public key from a DNSSEC-
      secured resource record using DNS-Based Authentication of Named
      Entities (DANE) [<a href="rfc6698.html" title='"The DNS-Based Authentication of Named Entities (DANE) Transport Layer Security (TLS) Protocol: TLSA"'>RFC6698</a>].

   o  The TLS client or server public key is obtained from a [<a href="#ref-PKIX" title='"Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile"'>PKIX</a>]
      certificate chain from a Lightweight Directory Access Protocol
      [<a href="#ref-LDAP" title='"Lightweight Directory Access Protocol (LDAP): The Protocol"'>LDAP</a>] server or web page.

   o  The TLS client and server public key is provisioned into the
      operating system firmware image and updated via software updates.
      For example:

      Some smart objects use the UDP-based Constrained Application
      Protocol [<a href="#ref-CoAP" title='"The Constrained Application Protocol (CoAP)"'>CoAP</a>] to interact with a Web server to upload sensor
      data at regular intervals, such as temperature readings.  CoAP can
      utilize DTLS for securing the client-to-server communication.  As
      part of the manufacturing process, the embedded device may be
      configured with the address and the public key of a dedicated CoAP
      server, as well as a public/private key pair for the client
      itself.

   This document introduces the use of raw public keys in TLS/DTLS.
   With raw public keys, only a subset of the information found in
   typical certificates is utilized: namely, the SubjectPublicKeyInfo
   structure of a PKIX certificate that carries the parameters necessary
   to describe the public key.  Other parameters found in PKIX
   certificates are omitted.  By omitting various certificate-related
   structures, the resulting raw public key is kept fairly small in
   comparison to the original certificate, and the code to process the
   keys can be simpler.  Only a minimalistic ASN.1 parser is needed;
   code for certificate path validation and other PKIX-related



<span class="grey">Wouters, et al.              Standards Track                    [Page 3]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-4" id="page-4" name="page-4"> </a>
<span class="grey"><a href="rfc7250.html">RFC 7250</a>            Using Raw Public Keys in TLS/DTLS          June 2014</span>


   processing is not required.  Note, however, the SubjectPublicKeyInfo
   structure is still in an ASN.1 format.  To further reduce the size of
   the exchanged information, this specification can be combined with
   the TLS Cached Info extension [<a href="#ref-CACHED-INFO" title='"Transport Layer Security (TLS) Cached Information Extension"'>CACHED-INFO</a>], which enables TLS peers
   to exchange just fingerprints of their public keys.

   The mechanism defined herein only provides authentication when an
   out-of-band mechanism is also used to bind the public key to the
   entity presenting the key.

   <a href="#section-3">Section 3</a> defines the structure of the two new TLS extensions,
   client_certificate_type and server_certificate_type, which can be
   used as part of an extended TLS handshake when raw public keys are to
   be used.  <a href="#section-4">Section 4</a> defines the behavior of the TLS client and the
   TLS server.  Example exchanges are described in <a href="#section-5">Section 5</a>.  <a href="#section-6">Section 6</a>
   describes security considerations with this approach.  Finally, in
   <a href="#section-7">Section 7</a> this document registers a new value to the IANA "TLS
   Certificate Types" subregistry for the support of raw public keys.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/2.%20%20Terminology"></a><a class="selflink" href="#section-2" name="section-2">2</a>.  Terminology</span>

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in <a href="rfc2119.html">RFC 2119</a> [<a href="rfc2119.html" title='"Key words for use in RFCs to Indicate Requirement Levels"'>RFC2119</a>].

   We use the terms "TLS server" and "server" as well as "TLS client"
   and "client" interchangeably.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/3.%20%20Structure%20of%20the%20Raw%20Public%20Key%20Extension"></a><a class="selflink" href="#section-3" name="section-3">3</a>.  Structure of the Raw Public Key Extension</span>

   This section defines the two TLS extensions client_certificate_type
   and server_certificate_type, which can be used as part of an extended
   TLS handshake when raw public keys are used.  <a href="#section-4">Section 4</a> defines the
   behavior of the TLS client and the TLS server using these extensions.

   This specification uses raw public keys whereby the already available
   encoding used in a PKIX certificate in the form of a
   SubjectPublicKeyInfo structure is reused.  To carry the raw public
   key within the TLS handshake, the Certificate payload is used as a
   container, as shown in Figure 1.  The shown Certificate structure is
   an adaptation of its original form [<a href="rfc5246.html" title='"The Transport Layer Security (TLS) Protocol Version 1.2"'>RFC5246</a>].










<span class="grey">Wouters, et al.              Standards Track                    [Page 4]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-5" id="page-5" name="page-5"> </a>
<span class="grey"><a href="rfc7250.html">RFC 7250</a>            Using Raw Public Keys in TLS/DTLS          June 2014</span>


   opaque ASN.1Cert&lt;1..2^24-1&gt;;

   struct {
       select(certificate_type){

            // certificate type defined in this document.
            case RawPublicKey:
              opaque ASN.1_subjectPublicKeyInfo&lt;1..2^24-1&gt;;

           // X.509 certificate defined in <a href="rfc5246.html">RFC 5246</a>
           case X.509:
             ASN.1Cert certificate_list&lt;0..2^24-1&gt;;

           // Additional certificate type based on
           // "TLS Certificate Types" subregistry
       };
   } Certificate;

    Figure 1: Certificate Payload as a Container for the Raw Public Key

   The SubjectPublicKeyInfo structure is defined in Section 4.1 of <a href="rfc5280.html">RFC</a>
   <a href="rfc5280.html">5280</a> [<a href="#ref-PKIX" title='"Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile"'>PKIX</a>] and not only contains the raw keys, such as the public
   exponent and the modulus of an RSA public key, but also an algorithm
   identifier.  The algorithm identifier can also include parameters.
   The SubjectPublicKeyInfo value in the Certificate payload MUST
   contain the DER encoding [<a href="#ref-X.690" title='"Information technology - ASN.1 encoding rules: Specification of Basic Encoding Rules (BER), Canonical Encoding Rules (CER) and Distinguished Encoding Rules (DER)"'>X.690</a>] of the SubjectPublicKeyInfo.  The
   structure, as shown in Figure 2, therefore also contains length
   information.  An example is provided in <a href="#appendix-A">Appendix A</a>.

      SubjectPublicKeyInfo  ::=  SEQUENCE  {
           algorithm               AlgorithmIdentifier,
           subjectPublicKey        BIT STRING  }

      AlgorithmIdentifier   ::=  SEQUENCE  {
           algorithm               OBJECT IDENTIFIER,
           parameters              ANY DEFINED BY algorithm OPTIONAL  }

              Figure 2: SubjectPublicKeyInfo ASN.1 Structure

   The algorithm identifiers are Object Identifiers (OIDs).  <a href="rfc3279.html">RFC 3279</a>
   [<a href="rfc3279.html" title='"Algorithms and Identifiers for the Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile"'>RFC3279</a>] and <a href="rfc5480.html">RFC 5480</a> [<a href="rfc5480.html" title='"Elliptic Curve Cryptography Subject Public Key Information"'>RFC5480</a>], for example, define the OIDs shown
   in Figure 3.  Note that this list is not exhaustive, and more OIDs
   may be defined in future RFCs.








<span class="grey">Wouters, et al.              Standards Track                    [Page 5]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-6" id="page-6" name="page-6"> </a>
<span class="grey"><a href="rfc7250.html">RFC 7250</a>            Using Raw Public Keys in TLS/DTLS          June 2014</span>


   Key Type            | Document                   | OID
   --------------------+----------------------------+-------------------
   RSA                 | <a href="rfc3279.html#section-2.3.1">Section 2.3.1 of RFC 3279</a>  | 1.2.840.113549.1.1
   ....................|............................|...................
   Digital Signature   |                            |
   Algorithm (DSA)     | <a href="rfc3279.html#section-2.3.2">Section 2.3.2 of RFC 3279</a>  | 1.2.840.10040.4.1
   ....................|............................|...................
   Elliptic Curve      |                            |
   Digital Signature   |                            |
   Algorithm (ECDSA)   | <a href="rfc5480.html#section-2">Section 2 of RFC 5480</a>      | 1.2.840.10045.2.1
   --------------------+----------------------------+-------------------

              Figure 3: Example Algorithm Object Identifiers

   The extension format for extended client and server hellos, which
   uses the "extension_data" field, is used to carry the
   ClientCertTypeExtension and the ServerCertTypeExtension structures.
   These two structures are shown in Figure 4.  The CertificateType
   structure is an enum with values taken from the "TLS Certificate
   Types" subregistry of the "Transport Layer Security (TLS) Extensions"
   registry [<a href="#ref-TLS-Ext-Registry" title='"Transport Layer Security (TLS) Extensions"'>TLS-Ext-Registry</a>].

   struct {
           select(ClientOrServerExtension) {
               case client:
                 CertificateType client_certificate_types&lt;1..2^8-1&gt;;
               case server:
                 CertificateType client_certificate_type;
           }
   } ClientCertTypeExtension;

   struct {
           select(ClientOrServerExtension) {
               case client:
                 CertificateType server_certificate_types&lt;1..2^8-1&gt;;
               case server:
                 CertificateType server_certificate_type;
           }
   } ServerCertTypeExtension;

                   Figure 4: CertTypeExtension Structure










<span class="grey">Wouters, et al.              Standards Track                    [Page 6]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-7" id="page-7" name="page-7"> </a>
<span class="grey"><a href="rfc7250.html">RFC 7250</a>            Using Raw Public Keys in TLS/DTLS          June 2014</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/4.%20%20TLS%20Client%20and%20Server%20Handshake%20Behavior"></a><a class="selflink" href="#section-4" name="section-4">4</a>.  TLS Client and Server Handshake Behavior</span>

   This specification extends the ClientHello and the ServerHello
   messages, according to the extension procedures defined in [<a href="rfc5246.html" title='"The Transport Layer Security (TLS) Protocol Version 1.2"'>RFC5246</a>].
   It does not extend or modify any other TLS message.

   Note: No new cipher suites are required to use raw public keys.  All
   existing cipher suites that support a key exchange method compatible
   with the defined extension can be used.

   The high-level message exchange in Figure 5 shows the
   client_certificate_type and server_certificate_type extensions added
   to the client and server hello messages.

    client_hello,
    client_certificate_type,
    server_certificate_type   -&gt;

                              &lt;-  server_hello,
                                  client_certificate_type,
                                  server_certificate_type,
                                  certificate,
                                  server_key_exchange,
                                  certificate_request,
                                  server_hello_done
    certificate,
    client_key_exchange,
    certificate_verify,
    change_cipher_spec,
    finished                  -&gt;

                              &lt;- change_cipher_spec,
                                 finished

   Application Data        &lt;-------&gt;     Application Data

                Figure 5: Basic Raw Public Key TLS Exchange

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.1.%20%20Client%20Hello"></a><a class="selflink" href="#section-4.1" name="section-4.1">4.1</a>.  Client Hello</span>

   In order to indicate the support of raw public keys, clients include
   the client_certificate_type and/or the server_certificate_type
   extensions in an extended client hello message.  The hello extension
   mechanism is described in <a href="#section-7.4.1.4">Section 7.4.1.4</a> of TLS 1.2 [<a href="rfc5246.html" title='"The Transport Layer Security (TLS) Protocol Version 1.2"'>RFC5246</a>].

   The client_certificate_type extension in the client hello indicates
   the certificate types the client is able to provide to the server,
   when requested using a certificate_request message.



<span class="grey">Wouters, et al.              Standards Track                    [Page 7]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-8" id="page-8" name="page-8"> </a>
<span class="grey"><a href="rfc7250.html">RFC 7250</a>            Using Raw Public Keys in TLS/DTLS          June 2014</span>


   The server_certificate_type extension in the client hello indicates
   the types of certificates the client is able to process when provided
   by the server in a subsequent certificate payload.

   The client_certificate_type and server_certificate_type extensions
   sent in the client hello each carry a list of supported certificate
   types, sorted by client preference.  When the client supports only
   one certificate type, it is a list containing a single element.

   The TLS client MUST omit certificate types from the
   client_certificate_type extension in the client hello if it does not
   possess the corresponding raw public key or certificate that it can
   provide to the server when requested using a certificate_request
   message, or if it is not configured to use one with the given TLS
   server.  If the client has no remaining certificate types to send in
   the client hello, other than the default X.509 type, it MUST omit the
   client_certificate_type extension in the client hello.

   The TLS client MUST omit certificate types from the
   server_certificate_type extension in the client hello if it is unable
   to process the corresponding raw public key or other certificate
   type.  If the client has no remaining certificate types to send in
   the client hello, other than the default X.509 certificate type, it
   MUST omit the entire server_certificate_type extension from the
   client hello.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.2.%20%20Server%20Hello"></a><a class="selflink" href="#section-4.2" name="section-4.2">4.2</a>.  Server Hello</span>

   If the server receives a client hello that contains the
   client_certificate_type extension and/or the server_certificate_type
   extension, then three outcomes are possible:

   1.  The server does not support the extension defined in this
       document.  In this case, the server returns the server hello
       without the extensions defined in this document.

   2.  The server supports the extension defined in this document, but
       it does not have any certificate type in common with the client.
       Then, the server terminates the session with a fatal alert of
       type "unsupported_certificate".

   3.  The server supports the extensions defined in this document and
       has at least one certificate type in common with the client.  In
       this case, the processing rules described below are followed.

   The client_certificate_type extension in the client hello indicates
   the certificate types the client is able to provide to the server,
   when requested using a certificate_request message.  If the TLS



<span class="grey">Wouters, et al.              Standards Track                    [Page 8]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-9" id="page-9" name="page-9"> </a>
<span class="grey"><a href="rfc7250.html">RFC 7250</a>            Using Raw Public Keys in TLS/DTLS          June 2014</span>


   server wants to request a certificate from the client (via the
   certificate_request message), it MUST include the
   client_certificate_type extension in the server hello.  This
   client_certificate_type extension in the server hello then indicates
   the type of certificates the client is requested to provide in a
   subsequent certificate payload.  The value conveyed in the
   client_certificate_type extension MUST be selected from one of the
   values provided in the client_certificate_type extension sent in the
   client hello.  The server MUST also include a certificate_request
   payload in the server hello message.

   If the server does not send a certificate_request payload (for
   example, because client authentication happens at the application
   layer or no client authentication is required) or none of the
   certificates supported by the client (as indicated in the
   client_certificate_type extension in the client hello) match the
   server-supported certificate types, then the client_certificate_type
   payload in the server hello MUST be omitted.

   The server_certificate_type extension in the client hello indicates
   the types of certificates the client is able to process when provided
   by the server in a subsequent certificate payload.  If the client
   hello indicates support of raw public keys in the
   server_certificate_type extension and the server chooses to use raw
   public keys, then the TLS server MUST place the SubjectPublicKeyInfo
   structure into the Certificate payload.  With the
   server_certificate_type extension in the server hello, the TLS server
   indicates the certificate type carried in the Certificate payload.
   This additional indication enables avoiding parsing ambiguities since
   the Certificate payload may contain either the X.509 certificate or a
   SubjectPublicKeyInfo structure.  Note that only a single value is
   permitted in the server_certificate_type extension when carried in
   the server hello.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.3.%20%20Client%20Authentication"></a><a class="selflink" href="#section-4.3" name="section-4.3">4.3</a>.  Client Authentication</span>

   When the TLS server has specified RawPublicKey as the
   client_certificate_type, authentication of the TLS client to the TLS
   server is supported only through authentication of the received
   client SubjectPublicKeyInfo via an out-of-band method.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.4.%20%20Server%20Authentication"></a><a class="selflink" href="#section-4.4" name="section-4.4">4.4</a>.  Server Authentication</span>

   When the TLS server has specified RawPublicKey as the
   server_certificate_type, authentication of the TLS server to the TLS
   client is supported only through authentication of the received
   client SubjectPublicKeyInfo via an out-of-band method.




<span class="grey">Wouters, et al.              Standards Track                    [Page 9]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-10" id="page-10" name="page-10"> </a>
<span class="grey"><a href="rfc7250.html">RFC 7250</a>            Using Raw Public Keys in TLS/DTLS          June 2014</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/5.%20%20Examples"></a><a class="selflink" href="#section-5" name="section-5">5</a>.  Examples</span>

   Figures 6, 7, and 8 illustrate example exchanges.  Note that TLS
   ciphersuites using a Diffie-Hellman exchange offering forward secrecy
   can be used with a raw public key, although this document does not
   show the information exchange at that level with the subsequent
   message flows.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.1.%20%20TLS%20Server%20Uses%20a%20Raw%20Public%20Key"></a><a class="selflink" href="#section-5.1" name="section-5.1">5.1</a>.  TLS Server Uses a Raw Public Key</span>

   This section shows an example where the TLS client indicates its
   ability to receive and validate a raw public key from the server.  In
   this example, the client is quite restricted since it is unable to
   process other certificate types sent by the server.  It also does not
   have credentials at the TLS layer it could send to the server and
   therefore omits the client_certificate_type extension.  Hence, the
   client only populates the server_certificate_type extension with the
   raw public key type, as shown in (1).

   When the TLS server receives the client hello, it processes the
   extension.  Since it has a raw public key, it indicates in (2) that
   it had chosen to place the SubjectPublicKeyInfo structure into the
   Certificate payload (3).

   The client uses this raw public key in the TLS handshake together
   with an out-of-band validation technique, such as DANE, to verify it.

  client_hello,
  server_certificate_type=(RawPublicKey) // (1)
                         -&gt;
                         &lt;- server_hello,
                            server_certificate_type=RawPublicKey, // (2)
                            certificate, // (3)
                            server_key_exchange,
                            server_hello_done

  client_key_exchange,
  change_cipher_spec,
  finished               -&gt;

                         &lt;- change_cipher_spec,
                            finished

  Application Data       &lt;-------&gt; Application Data

     Figure 6: Example with Raw Public Key Provided by the TLS Server





<span class="grey">Wouters, et al.              Standards Track                   [Page 10]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-11" id="page-11" name="page-11"> </a>
<span class="grey"><a href="rfc7250.html">RFC 7250</a>            Using Raw Public Keys in TLS/DTLS          June 2014</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.2.%20%20TLS%20Client%20and%20Server%20Use%20Raw%20Public%20Keys"></a><a class="selflink" href="#section-5.2" name="section-5.2">5.2</a>.  TLS Client and Server Use Raw Public Keys</span>

   This section shows an example where the TLS client as well as the TLS
   server use raw public keys.  This is one of the use cases envisioned
   for smart object networking.  The TLS client in this case is an
   embedded device that is configured with a raw public key for use with
   TLS and is also able to process a raw public key sent by the server.
   Therefore, it indicates these capabilities in (1).  As in the
   previously shown example, the server fulfills the client's request,
   indicates this via the RawPublicKey value in the
   server_certificate_type payload (2), and provides a raw public key in
   the Certificate payload back to the client (see (3)).  The TLS server
   demands client authentication, and therefore includes a
   certificate_request (4).  The client_certificate_type payload in (5)
   indicates that the TLS server accepts a raw public key.  The TLS
   client, which has a raw public key pre-provisioned, returns it in the
   Certificate payload (6) to the server.

client_hello,
client_certificate_type=(RawPublicKey) // (1)
server_certificate_type=(RawPublicKey) // (1)
                         -&gt;
                         &lt;-  server_hello,
                             server_certificate_type=RawPublicKey // (2)
                             certificate, // (3)
                             client_certificate_type=RawPublicKey // (5)
                             certificate_request, // (4)
                             server_key_exchange,
                             server_hello_done

certificate, // (6)
client_key_exchange,
change_cipher_spec,
finished                  -&gt;

                         &lt;- change_cipher_spec,
                            finished

Application Data        &lt;-------&gt;     Application Data

   Figure 7: Example with Raw Public Key provided by the TLS Server and
                                the Client









<span class="grey">Wouters, et al.              Standards Track                   [Page 11]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-12" id="page-12" name="page-12"> </a>
<span class="grey"><a href="rfc7250.html">RFC 7250</a>            Using Raw Public Keys in TLS/DTLS          June 2014</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.3.%20%20Combined%20Usage%20of%20Raw%20Public%20Keys%20and%20X.509%20Certificates"></a><a class="selflink" href="#section-5.3" name="section-5.3">5.3</a>.  Combined Usage of Raw Public Keys and X.509 Certificates</span>

   This section shows an example combining a raw public key and an X.509
   certificate.  The client uses a raw public key for client
   authentication, and the server provides an X.509 certificate.  This
   exchange starts with the client indicating its ability to process an
   X.509 certificate, OpenPGP certificate, or a raw public key, if
   provided by the server.  It prefers a raw public key, since the
   RawPublicKey value precedes the other values in the
   server_certificate_type vector.  Additionally, the client indicates
   that it has a raw public key for client-side authentication (see
   (1)).  The server chooses to provide its X.509 certificate in (3) and
   indicates that choice in (2).  For client authentication, the server
   indicates in (4) that it has selected the raw public key format and
   requests a certificate from the client in (5).  The TLS client
   provides a raw public key in (6) after receiving and processing the
   TLS server hello message.

client_hello,
server_certificate_type=(RawPublicKey, X.509, OpenPGP)
client_certificate_type=(RawPublicKey) // (1)
                         -&gt;
                         &lt;-  server_hello,
                             server_certificate_type=X.509 // (2)
                             certificate, // (3)
                             client_certificate_type=RawPublicKey // (4)
                             certificate_request, // (5)
                             server_key_exchange,
                             server_hello_done
certificate, // (6)
client_key_exchange,
change_cipher_spec,
finished                  -&gt;

                          &lt;- change_cipher_spec,
                             finished

Application Data        &lt;-------&gt;     Application Data

                   Figure 8: Hybrid Certificate Example











<span class="grey">Wouters, et al.              Standards Track                   [Page 12]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-13" id="page-13" name="page-13"> </a>
<span class="grey"><a href="rfc7250.html">RFC 7250</a>            Using Raw Public Keys in TLS/DTLS          June 2014</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/6.%20%20Security%20Considerations"></a><a class="selflink" href="#section-6" name="section-6">6</a>.  Security Considerations</span>

   The transmission of raw public keys, as described in this document,
   provides benefits by lowering the over-the-air transmission overhead
   since raw public keys are naturally smaller than an entire
   certificate.  There are also advantages from a code-size point of
   view for parsing and processing these keys.  The cryptographic
   procedures for associating the public key with the possession of a
   private key also follows standard procedures.

   However, the main security challenge is how to associate the public
   key with a specific entity.  Without a secure binding between
   identifier and key, the protocol will be vulnerable to man-in-the-
   middle attacks.  This document assumes that such binding can be made
   out-of-band, and we list a few examples in <a href="#section-1">Section 1</a>.  DANE [<a href="rfc6698.html" title='"The DNS-Based Authentication of Named Entities (DANE) Transport Layer Security (TLS) Protocol: TLSA"'>RFC6698</a>]
   offers one such approach.  In order to address these vulnerabilities,
   specifications that make use of the extension need to specify how the
   identifier and public key are bound.  In addition to ensuring the
   binding is done out-of-band, an implementation also needs to check
   the status of that binding.

   If public keys are obtained using DANE, these public keys are
   authenticated via DNSSEC.  Using pre-configured keys is another out-
   of-band method for authenticating raw public keys.  While pre-
   configured keys are not suitable for a generic Web-based e-commerce
   environment, such keys are a reasonable approach for many smart
   object deployments where there is a close relationship between the
   software running on the device and the server-side communication
   endpoint.  Regardless of the chosen mechanism for out-of-band public
   key validation, an assessment of the most suitable approach has to be
   made prior to the start of a deployment to ensure the security of the
   system.

   An attacker might try to influence the handshake exchange to make the
   parties select different certificate types than they would normally
   choose.

   For this attack, an attacker must actively change one or more
   handshake messages.  If this occurs, the client and server will
   compute different values for the handshake message hashes.  As a
   result, the parties will not accept each others' Finished messages.
   Without the master_secret, the attacker cannot repair the Finished
   messages, so the attack will be discovered.








<span class="grey">Wouters, et al.              Standards Track                   [Page 13]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-14" id="page-14" name="page-14"> </a>
<span class="grey"><a href="rfc7250.html">RFC 7250</a>            Using Raw Public Keys in TLS/DTLS          June 2014</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/7.%20%20IANA%20Considerations"></a><a class="selflink" href="#section-7" name="section-7">7</a>.  IANA Considerations</span>

   IANA has registered a new value in the "TLS Certificate Types"
   subregistry of the "Transport Layer Security (TLS) Extensions"
   registry [<a href="#ref-TLS-Ext-Registry" title='"Transport Layer Security (TLS) Extensions"'>TLS-Ext-Registry</a>], as follows:

   Value: 2
   Description: Raw Public Key
   Reference: <a href="rfc7250.html">RFC 7250</a>

   IANA has allocated two new TLS extensions, client_certificate_type
   and server_certificate_type, from the "TLS ExtensionType Values"
   subregistry defined in [<a href="rfc5246.html" title='"The Transport Layer Security (TLS) Protocol Version 1.2"'>RFC5246</a>].  These extensions are used in both
   the client hello message and the server hello message.  The new
   extension types are used for certificate type negotiation.  The
   values carried in these extensions are taken from the "TLS
   Certificate Types" subregistry of the "Transport Layer Security (TLS)
   Extensions" registry [<a href="#ref-TLS-Ext-Registry" title='"Transport Layer Security (TLS) Extensions"'>TLS-Ext-Registry</a>].

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/8.%20%20Acknowledgements"></a><a class="selflink" href="#section-8" name="section-8">8</a>.  Acknowledgements</span>

   The feedback from the TLS working group meeting at IETF 81 has
   substantially shaped the document, and we would like to thank the
   meeting participants for their input.  The support for hashes of
   public keys has been moved to [<a href="#ref-CACHED-INFO" title='"Transport Layer Security (TLS) Cached Information Extension"'>CACHED-INFO</a>] after the discussions at
   the IETF 82 meeting.

   We would like to thank the following persons for their review
   comments: Martin Rex, Bill Frantz, Zach Shelby, Carsten Bormann,
   Cullen Jennings, Rene Struik, Alper Yegin, Jim Schaad, Barry Leiba,
   Paul Hoffman, Robert Cragie, Nikos Mavrogiannopoulos, Phil Hunt, John
   Bradley, Klaus Hartke, Stefan Jucker, Kovatsch Matthias, Daniel Kahn
   Gillmor, Peter Sylvester, Hauke Mehrtens, Alexey Melnikov, Stephen
   Farrell, Richard Barnes, and James Manger.  Nikos Mavrogiannopoulos
   contributed the design for reusing the certificate type registry.
   Barry Leiba contributed guidance for the IANA Considerations text.
   Stefan Jucker, Kovatsch Matthias, and Klaus Hartke provided
   implementation feedback regarding the SubjectPublicKeyInfo structure.

   Christer Holmberg provided the General Area (Gen-Art) review, Yaron
   Sheffer provided the Security Directorate (SecDir) review, Bert
   Greevenbosch provided the Applications Area Directorate review, and
   Linda Dunbar provided the Operations Directorate review.

   We would like to thank our TLS working group chairs, Eric Rescorla
   and Joe Salowey, for their guidance and support.  Finally, we would
   like to thank Sean Turner, who is the responsible Security Area
   Director for this work, for his review comments and suggestions.



<span class="grey">Wouters, et al.              Standards Track                   [Page 14]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-15" id="page-15" name="page-15"> </a>
<span class="grey"><a href="rfc7250.html">RFC 7250</a>            Using Raw Public Keys in TLS/DTLS          June 2014</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/9.%20%20References"></a><a class="selflink" href="#section-9" name="section-9">9</a>.  References</span>

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/9.1.%20%20Normative%20References"></a><a class="selflink" href="#section-9.1" name="section-9.1">9.1</a>.  Normative References</span>

   [<a id="ref-PKIX" name="ref-PKIX">PKIX</a>]     Cooper, D., Santesson, S., Farrell, S., Boeyen, S.,
              Housley, R., and W. Polk, "Internet X.509 Public Key
              Infrastructure Certificate and Certificate Revocation List
              (CRL) Profile", <a href="rfc5280.html">RFC 5280</a>, May 2008.

   [<a id="ref-RFC2119" name="ref-RFC2119">RFC2119</a>]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", <a href="https://tools.ietf.org/html/bcp14">BCP 14</a>, <a href="rfc2119.html">RFC 2119</a>, March 1997.

   [<a id="ref-RFC3279" name="ref-RFC3279">RFC3279</a>]  Bassham, L., Polk, W., and R. Housley, "Algorithms and
              Identifiers for the Internet X.509 Public Key
              Infrastructure Certificate and Certificate Revocation List
              (CRL) Profile", <a href="rfc3279.html">RFC 3279</a>, April 2002.

   [<a id="ref-RFC5246" name="ref-RFC5246">RFC5246</a>]  Dierks, T. and E. Rescorla, "The Transport Layer Security
              (TLS) Protocol Version 1.2", <a href="rfc5246.html">RFC 5246</a>, August 2008.

   [<a id="ref-RFC5480" name="ref-RFC5480">RFC5480</a>]  Turner, S., Brown, D., Yiu, K., Housley, R., and T. Polk,
              "Elliptic Curve Cryptography Subject Public Key
              Information", <a href="rfc5480.html">RFC 5480</a>, March 2009.

   [<a id="ref-TLS-Ext-Registry" name="ref-TLS-Ext-Registry">TLS-Ext-Registry</a>]
              IANA, "Transport Layer Security (TLS) Extensions",
              &lt;<a href="http://www.iana.org/assignments/tls-extensiontype-values">http://www.iana.org/assignments/</a>
              <a href="http://www.iana.org/assignments/tls-extensiontype-values">tls-extensiontype-values</a>&gt;.

   [<a id="ref-X.690" name="ref-X.690">X.690</a>]    ITU-T, "Information technology - ASN.1 encoding rules:
              Specification of Basic Encoding Rules (BER), Canonical
              Encoding Rules (CER) and Distinguished Encoding Rules
              (DER)", ITU-T Recommendation X.690, ISO/IEC 8825-1:2002,
              2002.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/9.2.%20%20Informative%20References"></a><a class="selflink" href="#section-9.2" name="section-9.2">9.2</a>.  Informative References</span>

   [<a id="ref-ASN.1-Dump" name="ref-ASN.1-Dump">ASN.1-Dump</a>]
              Gutmann, P., "ASN.1 Object Dump Program", February 2013,
              &lt;<a href="http://www.cs.auckland.ac.nz/~pgut001/">http://www.cs.auckland.ac.nz/~pgut001/</a>&gt;.

   [<a id="ref-CACHED-INFO" name="ref-CACHED-INFO">CACHED-INFO</a>]
              Santesson, S. and H. Tschofenig, "Transport Layer Security
              (TLS) Cached Information Extension", Work in Progress,
              February 2014.

   [<a id="ref-CoAP" name="ref-CoAP">CoAP</a>]     Shelby, Z., Hartke, K., and C. Bormann, "The Constrained
              Application Protocol (CoAP)", <a href="rfc7252.html">RFC 7252</a>, June 2014.



<span class="grey">Wouters, et al.              Standards Track                   [Page 15]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-16" id="page-16" name="page-16"> </a>
<span class="grey"><a href="rfc7250.html">RFC 7250</a>            Using Raw Public Keys in TLS/DTLS          June 2014</span>


   [<a id="ref-Defeating-SSL" name="ref-Defeating-SSL">Defeating-SSL</a>]
              Marlinspike, M., "New Tricks for Defeating SSL in
              Practice", February 2009, &lt;<a href="http://www.blackhat.com/presentations/bh-dc-09/Marlinspike/BlackHat-DC-09-Marlinspike-Defeating-SSL.pdf">http://www.blackhat.com/</a>
              <a href="http://www.blackhat.com/presentations/bh-dc-09/Marlinspike/BlackHat-DC-09-Marlinspike-Defeating-SSL.pdf">presentations/bh-dc-09/Marlinspike/</a>
              <a href="http://www.blackhat.com/presentations/bh-dc-09/Marlinspike/BlackHat-DC-09-Marlinspike-Defeating-SSL.pdf">BlackHat-DC-09-Marlinspike-Defeating-SSL.pdf</a>&gt;.

   [<a id="ref-LDAP" name="ref-LDAP">LDAP</a>]     Sermersheim, J., "Lightweight Directory Access Protocol
              (LDAP): The Protocol", <a href="rfc4511.html">RFC 4511</a>, June 2006.

   [<a id="ref-RFC6698" name="ref-RFC6698">RFC6698</a>]  Hoffman, P. and J. Schlyter, "The DNS-Based Authentication
              of Named Entities (DANE) Transport Layer Security (TLS)
              Protocol: TLSA", <a href="rfc6698.html">RFC 6698</a>, August 2012.







































<span class="grey">Wouters, et al.              Standards Track                   [Page 16]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-17" id="page-17" name="page-17"> </a>
<span class="grey"><a href="rfc7250.html">RFC 7250</a>            Using Raw Public Keys in TLS/DTLS          June 2014</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/Appendix%20A.%20%20Example%20Encoding"></a><a class="selflink" href="#appendix-A" name="appendix-A">Appendix A</a>.  Example Encoding</span>

   For example, the hex sequence shown in Figure 9 describes a
   SubjectPublicKeyInfo structure inside the certificate payload.

          0     1     2     3     4     5     6     7     8     9
      +------+-----+-----+-----+-----+-----+-----+-----+-----+-----
   1  | 0x30, 0x81, 0x9f, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48,
   2  | 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x01, 0x05, 0x00, 0x03, 0x81,
   3  | 0x8d, 0x00, 0x30, 0x81, 0x89, 0x02, 0x81, 0x81, 0x00, 0xcd,
   4  | 0xfd, 0x89, 0x48, 0xbe, 0x36, 0xb9, 0x95, 0x76, 0xd4, 0x13,
   5  | 0x30, 0x0e, 0xbf, 0xb2, 0xed, 0x67, 0x0a, 0xc0, 0x16, 0x3f,
   6  | 0x51, 0x09, 0x9d, 0x29, 0x2f, 0xb2, 0x6d, 0x3f, 0x3e, 0x6c,
   7  | 0x2f, 0x90, 0x80, 0xa1, 0x71, 0xdf, 0xbe, 0x38, 0xc5, 0xcb,
   8  | 0xa9, 0x9a, 0x40, 0x14, 0x90, 0x0a, 0xf9, 0xb7, 0x07, 0x0b,
   9  | 0xe1, 0xda, 0xe7, 0x09, 0xbf, 0x0d, 0x57, 0x41, 0x86, 0x60,
   10 | 0xa1, 0xc1, 0x27, 0x91, 0x5b, 0x0a, 0x98, 0x46, 0x1b, 0xf6,
   11 | 0xa2, 0x84, 0xf8, 0x65, 0xc7, 0xce, 0x2d, 0x96, 0x17, 0xaa,
   12 | 0x91, 0xf8, 0x61, 0x04, 0x50, 0x70, 0xeb, 0xb4, 0x43, 0xb7,
   13 | 0xdc, 0x9a, 0xcc, 0x31, 0x01, 0x14, 0xd4, 0xcd, 0xcc, 0xc2,
   14 | 0x37, 0x6d, 0x69, 0x82, 0xd6, 0xc6, 0xc4, 0xbe, 0xf2, 0x34,
   15 | 0xa5, 0xc9, 0xa6, 0x19, 0x53, 0x32, 0x7a, 0x86, 0x0e, 0x91,
   16 | 0x82, 0x0f, 0xa1, 0x42, 0x54, 0xaa, 0x01, 0x02, 0x03, 0x01,
   17 | 0x00, 0x01

      Figure 9: Example SubjectPublicKeyInfo Structure Byte Sequence

   The decoded byte sequence shown in Figure 9 (for example, using Peter
   Gutmann's ASN.1 decoder [<a href="#ref-ASN.1-Dump" title='"ASN.1 Object Dump Program"'>ASN.1-Dump</a>]) illustrates the structure, as
   shown in Figure 10.

   Offset  Length   Description
   -------------------------------------------------------------------
      0     3+159:   SEQUENCE {
      3      2+13:     SEQUENCE {
      5       2+9:      OBJECT IDENTIFIER Value (1 2 840 113549 1 1 1)
                 :             PKCS #1, rsaEncryption
     16       2+0:      NULL
                 :      }
     18     3+141:    BIT STRING, encapsulates {
     22     3+137:      SEQUENCE {
     25     3+129:        INTEGER Value (1024 bit)
    157       2+3:        INTEGER Value (65537)
                 :        }
                 :      }
                 :    }

       Figure 10: Decoding of Example SubjectPublicKeyInfo Structure



<span class="grey">Wouters, et al.              Standards Track                   [Page 17]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-18" id="page-18" name="page-18"> </a>
<span class="grey"><a href="rfc7250.html">RFC 7250</a>            Using Raw Public Keys in TLS/DTLS          June 2014</span>


Authors' Addresses

   Paul Wouters (editor)
   Red Hat

   EMail: pwouters@redhat.com


   Hannes Tschofenig (editor)
   ARM Ltd.
   6060 Hall in Tirol
   Austria

   EMail: Hannes.tschofenig@gmx.net
   URI:   <a href="http://www.tschofenig.priv.at/">http://www.tschofenig.priv.at</a>


   John Gilmore
   Electronic Frontier Foundation
   PO Box 170608
   San Francisco, California  94117
   USA

   Phone: +1 415 221 6524
   EMail: gnu@toad.com
   URI:   <a href="https://www.toad.com/">https://www.toad.com/</a>


   Samuel Weiler
   Parsons
   7110 Samuel Morse Drive
   Columbia, Maryland  21046
   US

   EMail: weiler@tislabs.com


   Tero Kivinen
   INSIDE Secure
   Eerikinkatu 28
   Helsinki  FI-00180
   FI

   EMail: kivinen@iki.fi







Wouters, et al.              Standards Track                   [Page 18]

</pre><br/>
    <span class="noprint"><small><small>Html markup produced by rfcmarkup 1.127, available from
      <a href="https://tools.ietf.org/tools/rfcmarkup/">https://tools.ietf.org/tools/rfcmarkup/</a>
    </small></small></span>
  </div>




</body><!-- Mirrored from tools.ietf.org/html/rfc7250 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 14 Aug 2018 14:05:03 GMT --></html>