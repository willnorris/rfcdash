<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml"><!-- Mirrored from tools.ietf.org/html/rfc6797 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 06 Mar 2018 23:18:27 GMT --><!-- Added by HTTrack --><head><meta content="text/html;charset=utf-8" http-equiv="content-type"/><!-- /Added by HTTrack -->

    <meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
    <meta content="index,follow" name="robots"/>
    <meta content="rfcmarkup version 1.126" name="creator"/>
    <link href="http://purl.org/dc/elements/1.1/" rel="schema.DC"/>
<meta content="draft-hodges-strict-transport-sec" name="DC.Relation.Replaces"/>
<meta content="urn:ietf:rfc:6797" name="DC.Identifier"/>
<meta content="November, 2012" name="DC.Date.Issued"/>
<meta content="Jackson, Collin" name="DC.Creator"/>
<meta content="Barth, Adam" name="DC.Creator"/>
<meta content="Hodges, Jeff" name="DC.Creator"/>
<meta content="This specification defines a mechanism enabling web sites to declare
themselves accessible only via secure connections and/or for users to
be able to direct their user agent(s) to interact with given sites
only over secure connections. This overall policy is referred to as
HTTP Strict Transport Security (HSTS). The policy is declared by web
sites via the Strict-Transport-Security HTTP response header field
and/or by other means, such as user agent configuration, for example.
[STANDARDS-TRACK]" name="DC.Description.Abstract"/>
<meta content="HTTP Strict Transport Security (HSTS)" name="DC.Title"/>

    <link href="https://tools.ietf.org/images/rfc.png" rel="icon" type="image/png"/>
    <link href="https://tools.ietf.org/images/rfc.png" rel="shortcut icon" type="image/png"/>
    <title>RFC 6797 - HTTP Strict Transport Security (HSTS)</title>
    
    
    <style type="text/css">
	@media only screen 
	  and (min-width: 992px)
	  and (max-width: 1199px) {
	    body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 768px)
	  and (max-width: 991px) {
            body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 480px)
	  and (max-width: 767px) {
            body { font-size: 11pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (max-width: 479px) {
            body { font-size: 8pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-device-width : 375px) 
	  and (max-device-width : 667px) {
            body { font-size: 9.5pt; }
            div.content { width: 96ex; margin: 0 1px; }
        }
	@media only screen 
	  and (min-device-width: 1200px) {
            body { font-size: 10pt; margin: 0 4em; }
            div.content { width: 96ex; margin: 0; }
        }
        h1, h2, h3, h4, h5, h6, .h1, .h2, .h3, .h4, .h5, .h6 {
	    font-weight: bold;
            line-height: 0pt;
            display: inline;
            white-space: pre;
            font-family: monospace;
            font-size: 1em;
	    font-weight: bold;
        }
        pre {
            font-size: 1em;
            margin-top: 0px;
            margin-bottom: 0px;
        }
	.pre {
	    white-space: pre;
	    font-family: monospace;
	}
	.header{
	    font-weight: bold;
	}
        .newpage {
            page-break-before: always;
        }
        .invisible {
            text-decoration: none;
            color: white;
        }
        a.selflink {
          color: black;
          text-decoration: none;
        }
        @media print {
            body {
                font-family: monospace;
                font-size: 10.5pt;
            }
            h1, h2, h3, h4, h5, h6 {
                font-size: 1em;
            }
        
            a:link, a:visited {
                color: inherit;
                text-decoration: none;
            }
            .noprint {
                display: none;
            }
        }
	@media screen {
	    .grey, .grey a:link, .grey a:visited {
		color: #777;
	    }
            .docinfo {
                background-color: #EEE;
            }
            .top {
                border-top: 7px solid #EEE;
            }
            .bgwhite  { background-color: white; }
            .bgred    { background-color: #F44; }
            .bggrey   { background-color: #666; }
            .bgbrown  { background-color: #840; }            
            .bgorange { background-color: #FA0; }
            .bgyellow { background-color: #EE0; }
            .bgmagenta{ background-color: #F4F; }
            .bgblue   { background-color: #66F; }
            .bgcyan   { background-color: #4DD; }
            .bggreen  { background-color: #4F4; }

            .legend   { font-size: 90%; }
            .cplate   { font-size: 70%; border: solid grey 1px; }
	}
    </style>
    <!--[if IE]>
    <style>
    body {
       font-size: 13px;
       margin: 10px 10px;
    }
    </style>
    <![endif]-->

    <script type="text/javascript"><!--
    function addHeaderTags() {
	var spans = document.getElementsByTagName("span");
	for (var i=0; i < spans.length; i++) {
	    var elem = spans[i];
	    if (elem) {
		var level = elem.getAttribute("class");
                if (level == "h1" || level == "h2" || level == "h3" || level == "h4" || level == "h5" || level == "h6") {
                    elem.innerHTML = "<"+level+">"+elem.innerHTML+"</"+level+">";		
                }
	    }
	}
    }
    var legend_html = "Colour legend:<br />      <table>         <tr><td>Unknown:</td>                   <td><span class='cplate bgwhite'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft:</td>                     <td><span class='cplate bgred'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Informational:</td>             <td><span class='cplate bgorange'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Experimental:</td>              <td><span class='cplate bgyellow'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Best Common Practice:</td>      <td><span class='cplate bgmagenta'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Proposed Standard:</td>         <td><span class='cplate bgblue'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft Standard (old designation):</td> <td><span class='cplate bgcyan'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Internet Standard:</td>         <td><span class='cplate bggreen'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Historic:</td>                  <td><span class='cplate bggrey'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Obsolete:</td>                  <td><span class='cplate bgbrown'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>     </table>";
    function showElem(id) {
        var elem = document.getElementById(id);
        elem.innerHTML = eval(id+"_html");
        elem.style.visibility='visible';
    }
    function hideElem(id) {
        var elem = document.getElementById(id);
        elem.style.visibility='hidden';        
        elem.innerHTML = "";
    }
    // -->
    </script>
</head>
<body onload="addHeaderTags()">
  <div class="content">
   <div style="height: 13px;">
      <div class="pre noprint docinfo bgblue" onclick="showElem('legend');" onmouseout="hideElem('legend')" onmouseover="this.style.cursor='pointer';" style="height: 6px; position: absolute;" title="Click for colour legend.">                                                                        </div>
      <div class="docinfo noprint pre legend" id="legend" onmouseout="hideElem('legend');" onmouseover="showElem('legend');" style="position:absolute; top: 4px; left: 4ex; visibility:hidden; background-color: white; padding: 4px 9px 5px 7px; border: solid #345 1px; ">
      </div>
   </div>
<span class="pre noprint docinfo top">[<a href="index.html" title="Document search and retrieval page">Docs</a>] [<a href="https://tools.ietf.org/rfc/rfc6797.txt" title="Plaintext version of this document">txt</a>|<a href="https://tools.ietf.org/pdf/rfc6797" title="PDF version of this document">pdf</a>] [<a href="https://tools.ietf.org/html/draft-ietf-websec-strict-transport-sec" title="draft-ietf-websec-strict-transport-sec">draft-ietf-webs...</a>] [<a href="https://datatracker.ietf.org/doc/rfc6797" title="IESG Datatracker information for this document">Tracker</a>] [<a href="https://tools.ietf.org/rfcdiff?difftype=--hwdiff&amp;url2=rfc6797" title="Inline diff (wdiff)">Diff1</a>] [<a href="https://tools.ietf.org/rfcdiff?url2=rfc6797" title="Side-by-side diff">Diff2</a>] [<a href="https://www.rfc-editor.org/errata_search.php?rfc=6797">Errata</a>]</span><br/>
<span class="pre noprint docinfo">                                                                        </span><br/>
<span class="pre noprint docinfo">                                                       PROPOSED STANDARD</span><br/>
<span class="pre noprint docinfo">                                                            <span style="color: #C00;">Errata Exist</span></span><br/>
<pre>Internet Engineering Task Force (IETF)                         J. Hodges
Request for Comments: 6797                                        PayPal
Category: Standards Track                                     C. Jackson
ISSN: 2070-1721                               Carnegie Mellon University
                                                                A. Barth
                                                            Google, Inc.
                                                           November 2012


                 <span class="h1">HTTP Strict Transport Security (HSTS)</span>

Abstract

   This specification defines a mechanism enabling web sites to declare
   themselves accessible only via secure connections and/or for users to
   be able to direct their user agent(s) to interact with given sites
   only over secure connections.  This overall policy is referred to as
   HTTP Strict Transport Security (HSTS).  The policy is declared by web
   sites via the Strict-Transport-Security HTTP response header field
   and/or by other means, such as user agent configuration, for example.

Status of This Memo

   This is an Internet Standards Track document.

   This document is a product of the Internet Engineering Task Force
   (IETF).  It represents the consensus of the IETF community.  It has
   received public review and has been approved for publication by the
   Internet Engineering Steering Group (IESG).  Further information on
   Internet Standards is available in <a href="rfc5741.html#section-2">Section 2 of RFC 5741</a>.

   Information about the current status of this document, any errata,
   and how to provide feedback on it may be obtained at
   <a href="http://www.rfc-editor.org/info/rfc6797">http://www.rfc-editor.org/info/rfc6797</a>.

















<span class="grey">Hodges, et al.               Standards Track                    [Page 1]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-2" id="page-2" name="page-2"> </a>
<span class="grey"><a href="rfc6797.html">RFC 6797</a>          HTTP Strict Transport Security (HSTS)    November 2012</span>


Copyright Notice

   Copyright (c) 2012 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to <a href="https://tools.ietf.org/html/bcp78">BCP 78</a> and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (<a href="http://trustee.ietf.org/license-info">http://trustee.ietf.org/license-info</a>) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.

Table of Contents

   <a href="#section-1">1</a>. Introduction ....................................................<a href="#page-4">4</a>
      <a href="#section-1.1">1.1</a>. Organization of This Specification .........................<a href="#page-6">6</a>
      <a href="#section-1.2">1.2</a>. Document Conventions .......................................<a href="#page-6">6</a>
   <a href="#section-2">2</a>. Overview ........................................................<a href="#page-6">6</a>
      <a href="#section-2.1">2.1</a>. Use Cases ..................................................<a href="#page-6">6</a>
      <a href="#section-2.2">2.2</a>. HTTP Strict Transport Security Policy Effects ..............<a href="#page-6">6</a>
      <a href="#section-2.3">2.3</a>. Threat Model ...............................................<a href="#page-6">6</a>
           <a href="#section-2.3.1">2.3.1</a>. Threats Addressed ...................................<a href="#page-7">7</a>
                  <a href="#section-2.3.1.1">2.3.1.1</a>. Passive Network Attackers ..................<a href="#page-7">7</a>
                  <a href="#section-2.3.1.2">2.3.1.2</a>. Active Network Attackers ...................<a href="#page-7">7</a>
                  <a href="#section-2.3.1.3">2.3.1.3</a>. Web Site Development and Deployment Bugs ...<a href="#page-8">8</a>
           <a href="#section-2.3.2">2.3.2</a>. Threats Not Addressed ...............................<a href="#page-8">8</a>
                  <a href="#section-2.3.2.1">2.3.2.1</a>. Phishing ...................................<a href="#page-8">8</a>
                  <a href="#section-2.3.2.2">2.3.2.2</a>. Malware and Browser Vulnerabilities ........<a href="#page-8">8</a>
      <a href="#section-2.4">2.4</a>. Requirements ...............................................<a href="#page-9">9</a>
           <a href="#section-2.4.1">2.4.1</a>. Overall Requirement .................................<a href="#page-9">9</a>
                  <a href="#section-2.4.1.1">2.4.1.1</a>. Detailed Core Requirements .................<a href="#page-9">9</a>
                  <a href="#section-2.4.1.2">2.4.1.2</a>. Detailed Ancillary Requirements ...........<a href="#page-10">10</a>
   <a href="#section-3">3</a>. Conformance Criteria ...........................................<a href="#page-10">10</a>
   <a href="#section-4">4</a>. Terminology ....................................................<a href="#page-11">11</a>
   <a href="#section-5">5</a>. HSTS Mechanism Overview ........................................<a href="#page-13">13</a>
      <a href="#section-5.1">5.1</a>. HSTS Host Declaration .....................................<a href="#page-13">13</a>
      <a href="#section-5.2">5.2</a>. HSTS Policy ...............................................<a href="#page-13">13</a>
      <a href="#section-5.3">5.3</a>. HSTS Policy Storage and Maintenance by User Agents ........<a href="#page-14">14</a>
      <a href="#section-5.4">5.4</a>. User Agent HSTS Policy Enforcement ........................<a href="#page-14">14</a>
   <a href="#section-6">6</a>. Syntax .........................................................<a href="#page-14">14</a>
      <a href="#section-6.1">6.1</a>. Strict-Transport-Security HTTP Response Header Field ......<a href="#page-15">15</a>
           <a href="#section-6.1.1">6.1.1</a>. The max-age Directive ..............................<a href="#page-16">16</a>
           <a href="#section-6.1.2">6.1.2</a>. The includeSubDomains Directive ....................<a href="#page-16">16</a>
      <a href="#section-6.2">6.2</a>. Examples ..................................................<a href="#page-16">16</a>




<span class="grey">Hodges, et al.               Standards Track                    [Page 2]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-3" id="page-3" name="page-3"> </a>
<span class="grey"><a href="rfc6797.html">RFC 6797</a>          HTTP Strict Transport Security (HSTS)    November 2012</span>


   <a href="#section-7">7</a>. Server Processing Model ........................................<a href="#page-17">17</a>
      <a href="#section-7.1">7.1</a>. HTTP-over-Secure-Transport Request Type ...................<a href="#page-17">17</a>
      <a href="#section-7.2">7.2</a>. HTTP Request Type .........................................<a href="#page-18">18</a>
   <a href="#section-8">8</a>. User Agent Processing Model ....................................<a href="#page-18">18</a>
      8.1. Strict-Transport-Security Response Header Field
           Processing ................................................<a href="#page-19">19</a>
           <a href="#section-8.1.1">8.1.1</a>. Noting an HSTS Host - Storage Model ................<a href="#page-20">20</a>
      <a href="#section-8.2">8.2</a>. Known HSTS Host Domain Name Matching ......................<a href="#page-20">20</a>
      <a href="#section-8.3">8.3</a>. URI Loading and Port Mapping ..............................<a href="#page-21">21</a>
      <a href="#section-8.4">8.4</a>. Errors in Secure Transport Establishment ..................<a href="#page-22">22</a>
      <a href="#section-8.5">8.5</a>. HTTP-Equiv &lt;Meta&gt; Element Attribute .......................<a href="#page-22">22</a>
      <a href="#section-8.6">8.6</a>. Missing Strict-Transport-Security Response Header Field ...<a href="#page-23">23</a>
   <a href="#section-9">9</a>. Constructing an Effective Request URI ..........................<a href="#page-23">23</a>
      <a href="#section-9.1">9.1</a>. ERU Fundamental Definitions ...............................<a href="#page-23">23</a>
      <a href="#section-9.2">9.2</a>. Determining the Effective Request URI .....................<a href="#page-24">24</a>
           <a href="#section-9.2.1">9.2.1</a>. Effective Request URI Examples .....................<a href="#page-24">24</a>
   <a href="#section-10">10</a>. Domain Name IDNA-Canonicalization .............................<a href="#page-25">25</a>
   <a href="#section-11">11</a>. Server Implementation and Deployment Advice ...................<a href="#page-26">26</a>
      <a href="#section-11.1">11.1</a>. Non-Conformant User Agent Considerations .................<a href="#page-26">26</a>
      <a href="#section-11.2">11.2</a>. HSTS Policy Expiration Time Considerations ...............<a href="#page-26">26</a>
      11.3. Using HSTS in Conjunction with Self-Signed Public-Key
            Certificates .............................................<a href="#page-27">27</a>
      <a href="#section-11.4">11.4</a>. Implications of includeSubDomains ........................<a href="#page-28">28</a>
            11.4.1. Considerations for Offering Unsecured HTTP
                    Services at Alternate Ports or Subdomains of an
                    HSTS Host ........................................<a href="#page-28">28</a>
            11.4.2. Considerations for Offering Web Applications at
                    Subdomains of an HSTS Host .......................<a href="#page-29">29</a>
   <a href="#section-12">12</a>. User Agent Implementation Advice ..............................<a href="#page-30">30</a>
      <a href="#section-12.1">12.1</a>. No User Recourse .........................................<a href="#page-30">30</a>
      <a href="#section-12.2">12.2</a>. User-Declared HSTS Policy ................................<a href="#page-30">30</a>
      <a href="#section-12.3">12.3</a>. HSTS Pre-Loaded List .....................................<a href="#page-31">31</a>
      <a href="#section-12.4">12.4</a>. Disallow Mixed Security Context Loads ....................<a href="#page-31">31</a>
      <a href="#section-12.5">12.5</a>. HSTS Policy Deletion .....................................<a href="#page-31">31</a>
   13. Internationalized Domain Names for Applications (IDNA):
       Dependency and Migration ......................................<a href="#page-32">32</a>















<span class="grey">Hodges, et al.               Standards Track                    [Page 3]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-4" id="page-4" name="page-4"> </a>
<span class="grey"><a href="rfc6797.html">RFC 6797</a>          HTTP Strict Transport Security (HSTS)    November 2012</span>


   <a href="#section-14">14</a>. Security Considerations .......................................<a href="#page-32">32</a>
      <a href="#section-14.1">14.1</a>. Underlying Secure Transport Considerations ...............<a href="#page-32">32</a>
      <a href="#section-14.2">14.2</a>. Non-Conformant User Agent Implications ...................<a href="#page-33">33</a>
      14.3. Ramifications of HSTS Policy Establishment Only over
            Error-Free Secure Transport ..............................<a href="#page-33">33</a>
      <a href="#section-14.4">14.4</a>. The Need for includeSubDomains ...........................<a href="#page-34">34</a>
      <a href="#section-14.5">14.5</a>. Denial of Service ........................................<a href="#page-35">35</a>
      <a href="#section-14.6">14.6</a>. Bootstrap MITM Vulnerability .............................<a href="#page-36">36</a>
      <a href="#section-14.7">14.7</a>. Network Time Attacks .....................................<a href="#page-37">37</a>
      14.8. Bogus Root CA Certificate Phish plus DNS Cache
            Poisoning Attack .........................................<a href="#page-37">37</a>
      <a href="#section-14.9">14.9</a>. Creative Manipulation of HSTS Policy Store ...............<a href="#page-37">37</a>
      <a href="#section-14.10">14.10</a>. Internationalized Domain Names ..........................<a href="#page-38">38</a>
   <a href="#section-15">15</a>. IANA Considerations ...........................................<a href="#page-39">39</a>
   <a href="#section-16">16</a>. References ....................................................<a href="#page-39">39</a>
      <a href="#section-16.1">16.1</a>. Normative References .....................................<a href="#page-39">39</a>
      <a href="#section-16.2">16.2</a>. Informative References ...................................<a href="#page-40">40</a>
   <a href="#appendix-A">Appendix A</a>. Design Decision Notes .................................<a href="#page-44">44</a>
   <a href="#appendix-B">Appendix B</a>. Differences between HSTS Policy and Same-Origin
               Policy ................................................<a href="#page-45">45</a>
   <a href="#appendix-C">Appendix C</a>. Acknowledgments .......................................<a href="#page-46">46</a>

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/1.%20%20Introduction"></a><a class="selflink" href="#section-1" name="section-1">1</a>.  Introduction</span>

   HTTP [<a href="rfc2616.html" title='"Hypertext Transfer Protocol -- HTTP/1.1"'>RFC2616</a>] may be used over various transports, typically the
   Transmission Control Protocol (TCP).  However, TCP does not provide
   channel integrity protection, confidentiality, or secure host
   identification.  Thus, the Secure Sockets Layer (SSL) protocol
   [<a href="rfc6101.html" title='"The Secure Sockets Layer (SSL) Protocol Version 3.0"'>RFC6101</a>] and its successor, Transport Layer Security (TLS) [<a href="rfc5246.html" title='"The Transport Layer Security (TLS) Protocol Version 1.2"'>RFC5246</a>]
   were developed in order to provide channel-oriented security and are
   typically layered between application protocols and TCP.  [<a href="rfc2818.html" title='"HTTP Over TLS"'>RFC2818</a>]
   specifies how HTTP is layered onto TLS and defines the Uniform
   Resource Identifier (URI) scheme of "https" (in practice, however,
   HTTP user agents (UAs) typically use either TLS or SSL3, depending
   upon a combination of negotiation with the server and user
   preferences).

   UAs employ various local security policies with respect to the
   characteristics of their interactions with web resources, depending
   on (in part) whether they are communicating with a given web
   resource's host using HTTP or HTTP-over-Secure-Transport.  For
   example, cookies ([<a href="rfc6265.html" title='"HTTP State Management Mechanism"'>RFC6265</a>]) may be flagged as Secure.  UAs are to
   send such Secure cookies to their addressed host only over a secure
   transport.  This is in contrast to non-Secure cookies, which are
   returned to the host regardless of transport (although subject to
   other rules).





<span class="grey">Hodges, et al.               Standards Track                    [Page 4]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-5" id="page-5" name="page-5"> </a>
<span class="grey"><a href="rfc6797.html">RFC 6797</a>          HTTP Strict Transport Security (HSTS)    November 2012</span>


   UAs typically announce to their users any issues with secure
   connection establishment, such as being unable to validate a TLS
   server certificate trust chain, or if a TLS server certificate is
   expired, or if a TLS host's domain name appears incorrectly in the
   TLS server certificate (see <a href="rfc2818.html#section-3.1">Section 3.1 of [RFC2818]</a>).  Often, UAs
   enable users to elect to continue to interact with a web resource's
   host in the face of such issues.  This behavior is sometimes referred
   to as "click(ing) through" security [<a href="#ref-GoodDhamijaEtAl05">GoodDhamijaEtAl05</a>]
   [<a href="#ref-SunshineEgelmanEtAl09">SunshineEgelmanEtAl09</a>]; thus, it can be described as "click-through
   insecurity".

   A key vulnerability enabled by click-through insecurity is the
   leaking of any cookies the web resource may be using to manage a
   user's session.  The threat here is that an attacker could obtain the
   cookies and then interact with the legitimate web resource while
   impersonating the user.

   Jackson and Barth proposed an approach, in [<a href="#ref-ForceHTTPS">ForceHTTPS</a>], to enable
   web resources to declare that any interactions by UAs with the web
   resource must be conducted securely and that any issues with
   establishing a secure transport session are to be treated as fatal
   and without direct user recourse.  The aim is to prevent click-
   through insecurity and address other potential threats.

   This specification embodies and refines the approach proposed in
   [<a href="#ref-ForceHTTPS">ForceHTTPS</a>].  For example, rather than using a cookie to convey
   policy from a web resource's host to a UA, it defines an HTTP
   response header field for this purpose.  Additionally, a web
   resource's host may declare its policy to apply to the entire domain
   name subtree rooted at its host name.  This enables HTTP Strict
   Transport Security (HSTS) to protect so-called "domain cookies",
   which are applied to all subdomains of a given web resource's host
   name.

   This specification also incorporates notions from [<a href="#ref-JacksonBarth2008">JacksonBarth2008</a>]
   in that policy is applied on an "entire-host" basis: it applies to
   HTTP (only) over any TCP port of the issuing host.

   Note that the policy defined by this specification is distinctly
   different than the "same-origin policy" defined in "The Web Origin
   Concept" [<a href="rfc6454.html" title='"The Web Origin Concept"'>RFC6454</a>].  These differences are summarized in <a href="#appendix-B">Appendix B</a>.










<span class="grey">Hodges, et al.               Standards Track                    [Page 5]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-6" id="page-6" name="page-6"> </a>
<span class="grey"><a href="rfc6797.html">RFC 6797</a>          HTTP Strict Transport Security (HSTS)    November 2012</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/1.1.%20%20Organization%20of%20This%20Specification"></a><a class="selflink" href="#section-1.1" name="section-1.1">1.1</a>.  Organization of This Specification</span>

   This specification begins with an overview of the use cases, policy
   effects, threat models, and requirements for HSTS (in <a href="#section-2">Section 2</a>).
   Then, <a href="#section-3">Section 3</a> defines conformance requirements.  <a href="#section-4">Section 4</a> defines
   terminology relevant to this document.  The HSTS mechanism itself is
   formally specified in Sections <a href="#section-5">5</a> through <a href="#section-15">15</a>.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/1.2.%20%20Document%20Conventions"></a><a class="selflink" href="#section-1.2" name="section-1.2">1.2</a>.  Document Conventions</span>

   NOTE:  This is a note to the reader.  These are points that should be
          expressly kept in mind and/or considered.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/2.%20%20Overview"></a><a class="selflink" href="#section-2" name="section-2">2</a>.  Overview</span>

   This section discusses the use cases, summarizes the HSTS Policy, and
   continues with a discussion of the threat model, non-addressed
   threats, and derived requirements.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/2.1.%20%20Use%20Cases"></a><a class="selflink" href="#section-2.1" name="section-2.1">2.1</a>.  Use Cases</span>

   The high-level use case is a combination of:

   o  Web browser user wishes to interact with various web sites (some
      arbitrary, some known) in a secure fashion.

   o  Web site deployer wishes to offer their site in an explicitly
      secure fashion for their own, as well as their users', benefit.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/2.2.%20%20HTTP%20Strict%20Transport%20Security%20Policy%20Effects"></a><a class="selflink" href="#section-2.2" name="section-2.2">2.2</a>.  HTTP Strict Transport Security Policy Effects</span>

   The effects of the HSTS Policy, as applied by a conformant UA in
   interactions with a web resource host wielding such policy (known as
   an HSTS Host), are summarized as follows:

   1.  UAs transform insecure URI references to an HSTS Host into secure
       URI references before dereferencing them.

   2.  The UA terminates any secure transport connection attempts upon
       any and all secure transport errors or warnings.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/2.3.%20%20Threat%20Model"></a><a class="selflink" href="#section-2.3" name="section-2.3">2.3</a>.  Threat Model</span>

   HSTS is concerned with three threat classes: passive network
   attackers, active network attackers, and imperfect web developers.
   However, it is explicitly not a remedy for two other classes of
   threats: phishing and malware.  Threats that are addressed, as well
   as threats that are not addressed, are briefly discussed below.



<span class="grey">Hodges, et al.               Standards Track                    [Page 6]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-7" id="page-7" name="page-7"> </a>
<span class="grey"><a href="rfc6797.html">RFC 6797</a>          HTTP Strict Transport Security (HSTS)    November 2012</span>


   Readers may wish to refer to Section 2 of [<a href="#ref-ForceHTTPS">ForceHTTPS</a>] for details as
   well as relevant citations.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/2.3.1.%20%20Threats%20Addressed"></a><a class="selflink" href="#section-2.3.1" name="section-2.3.1">2.3.1</a>.  Threats Addressed</span>

<span class="h5"><a class="dashAnchor" name="//apple_ref/Section/2.3.1.1.%20%20Passive%20Network%20Attackers"></a><a class="selflink" href="#section-2.3.1.1" name="section-2.3.1.1">2.3.1.1</a>.  Passive Network Attackers</span>

   When a user browses the web on a local wireless network (e.g., an
   802.11-based wireless local area network) a nearby attacker can
   possibly eavesdrop on the user's unencrypted Internet Protocol-based
   connections, such as HTTP, regardless of whether or not the local
   wireless network itself is secured [<a href="#ref-BeckTews09">BeckTews09</a>].  Freely available
   wireless sniffing toolkits (e.g., [<a href="#ref-Aircrack-ng">Aircrack-ng</a>]) enable such passive
   eavesdropping attacks, even if the local wireless network is
   operating in a secure fashion.  A passive network attacker using such
   tools can steal session identifiers/cookies and hijack the user's web
   session(s) by obtaining cookies containing authentication credentials
   [<a href="#ref-ForceHTTPS">ForceHTTPS</a>].  For example, there exist widely available tools, such
   as Firesheep (a web browser extension) [<a href="#ref-Firesheep">Firesheep</a>], that enable their
   wielder to obtain other local users' session cookies for various web
   applications.

   To mitigate such threats, some web sites support, but usually do not
   force, access using end-to-end secure transport -- e.g., signaled
   through URIs constructed with the "https" scheme [<a href="rfc2818.html" title='"HTTP Over TLS"'>RFC2818</a>].  This can
   lead users to believe that accessing such services using secure
   transport protects them from passive network attackers.
   Unfortunately, this is often not the case in real-world deployments,
   as session identifiers are often stored in non-Secure cookies to
   permit interoperability with versions of the service offered over
   insecure transport ("Secure cookies" are those cookies containing the
   "Secure" attribute [<a href="rfc6265.html" title='"HTTP State Management Mechanism"'>RFC6265</a>]).  For example, if the session
   identifier for a web site (an email service, say) is stored in a
   non-Secure cookie, it permits an attacker to hijack the user's
   session if the user's UA makes a single insecure HTTP request to the
   site.

<span class="h5"><a class="dashAnchor" name="//apple_ref/Section/2.3.1.2.%20%20Active%20Network%20Attackers"></a><a class="selflink" href="#section-2.3.1.2" name="section-2.3.1.2">2.3.1.2</a>.  Active Network Attackers</span>

   A determined attacker can mount an active attack, either by
   impersonating a user's DNS server or, in a wireless network, by
   spoofing network frames or offering a similarly named evil twin
   access point.  If the user is behind a wireless home router, an
   attacker can attempt to reconfigure the router using default
   passwords and other vulnerabilities.  Some sites, such as banks, rely
   on end-to-end secure transport to protect themselves and their users
   from such active attackers.  Unfortunately, browsers allow their
   users to easily opt out of these protections in order to be usable



<span class="grey">Hodges, et al.               Standards Track                    [Page 7]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-8" id="page-8" name="page-8"> </a>
<span class="grey"><a href="rfc6797.html">RFC 6797</a>          HTTP Strict Transport Security (HSTS)    November 2012</span>


   for sites that incorrectly deploy secure transport, for example by
   generating and self-signing their own certificates (without also
   distributing their certification authority (CA) certificate to their
   users' browsers).

<span class="h5"><a class="dashAnchor" name="//apple_ref/Section/2.3.1.3.%20%20Web%20Site%20Development%20and%20Deployment%20Bugs"></a><a class="selflink" href="#section-2.3.1.3" name="section-2.3.1.3">2.3.1.3</a>.  Web Site Development and Deployment Bugs</span>

   The security of an otherwise uniformly secure site (i.e., all of its
   content is materialized via "https" URIs) can be compromised
   completely by an active attacker exploiting a simple mistake, such as
   the loading of a cascading style sheet or a SWF (Shockwave Flash)
   movie over an insecure connection (both cascading style sheets and
   SWF movies can script the embedding page, to the surprise of many web
   developers, plus some browsers do not issue so-called "mixed content
   warnings" when SWF files are embedded via insecure connections).
   Even if the site's developers carefully scrutinize their login page
   for "mixed content", a single insecure embedding anywhere on the
   overall site compromises the security of their login page because an
   attacker can script (i.e., control) the login page by injecting code
   (e.g., a script) into another, insecurely loaded, site page.

   NOTE:  "Mixed content" as used above (see also Section 5.3 in
          [<a href="#ref-W3C.REC-wsc-ui-20100812">W3C.REC-wsc-ui-20100812</a>]) refers to the notion termed "mixed
          security context" in this specification and should not be
          confused with the same "mixed content" term used in the
          context of markup languages such as XML and HTML.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/2.3.2.%20%20Threats%20Not%20Addressed"></a><a class="selflink" href="#section-2.3.2" name="section-2.3.2">2.3.2</a>.  Threats Not Addressed</span>

<span class="h5"><a class="dashAnchor" name="//apple_ref/Section/2.3.2.1.%20%20Phishing"></a><a class="selflink" href="#section-2.3.2.1" name="section-2.3.2.1">2.3.2.1</a>.  Phishing</span>

   Phishing attacks occur when an attacker solicits authentication
   credentials from the user by hosting a fake site located on a
   different domain than the real site, perhaps driving traffic to the
   fake site by sending a link in an email message.  Phishing attacks
   can be very effective because users find it difficult to distinguish
   the real site from a fake site.  HSTS is not a defense against
   phishing per se; rather, it complements many existing phishing
   defenses by instructing the browser to protect session integrity and
   long-lived authentication tokens [<a href="#ref-ForceHTTPS">ForceHTTPS</a>].

<span class="h5"><a class="dashAnchor" name="//apple_ref/Section/2.3.2.2.%20%20Malware%20and%20Browser%20Vulnerabilities"></a><a class="selflink" href="#section-2.3.2.2" name="section-2.3.2.2">2.3.2.2</a>.  Malware and Browser Vulnerabilities</span>

   Because HSTS is implemented as a browser security mechanism, it
   relies on the trustworthiness of the user's system to protect the
   session.  Malicious code executing on the user's system can
   compromise a browser session, regardless of whether HSTS is used.




<span class="grey">Hodges, et al.               Standards Track                    [Page 8]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-9" id="page-9" name="page-9"> </a>
<span class="grey"><a href="rfc6797.html">RFC 6797</a>          HTTP Strict Transport Security (HSTS)    November 2012</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/2.4.%20%20Requirements"></a><a class="selflink" href="#section-2.4" name="section-2.4">2.4</a>.  Requirements</span>

   This section identifies and enumerates various requirements derived
   from the use cases and the threats discussed above and also lists the
   detailed core requirements that HTTP Strict Transport Security
   addresses, as well as ancillary requirements that are not directly
   addressed.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/2.4.1.%20%20Overall%20Requirement"></a><a class="selflink" href="#section-2.4.1" name="section-2.4.1">2.4.1</a>.  Overall Requirement</span>

   o  Minimize, for web browser users and web site deployers, the risks
      that are derived from passive and active network attackers, web
      site development and deployment bugs, and insecure user actions.

<span class="h5"><a class="dashAnchor" name="//apple_ref/Section/2.4.1.1.%20%20Detailed%20Core%20Requirements"></a><a class="selflink" href="#section-2.4.1.1" name="section-2.4.1.1">2.4.1.1</a>.  Detailed Core Requirements</span>

   These core requirements are derived from the overall requirement and
   are addressed by this specification.

   1.  Web sites need to be able to declare to UAs that they should be
       accessed using a strict security policy.

   2.  Web sites need to be able to instruct UAs that contact them
       insecurely to do so securely.

   3.  UAs need to retain persistent data about web sites that signal
       strict security policy enablement, for time spans declared by the
       web sites.  Additionally, UAs need to cache the "freshest" strict
       security policy information, in order to allow web sites to
       update the information.

   4.  UAs need to rewrite all insecure UA "http" URI loads to use the
       "https" secure scheme for those web sites for which secure policy
       is enabled.

   5.  Web site administrators need to be able to signal strict security
       policy application to subdomains of higher-level domains for
       which strict security policy is enabled, and UAs need to enforce
       such policy.

       For example, both example.com and foo.example.com could set
       policy for bar.foo.example.com.









<span class="grey">Hodges, et al.               Standards Track                    [Page 9]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-10" id="page-10" name="page-10"> </a>
<span class="grey"><a href="rfc6797.html">RFC 6797</a>          HTTP Strict Transport Security (HSTS)    November 2012</span>


   6.  UAs need to disallow security policy application to peer domains,
       and/or higher-level domains, by domains for which strict security
       policy is enabled.

       For example, neither bar.foo.example.com nor foo.example.com can
       set policy for example.com, nor can bar.foo.example.com set
       policy for foo.example.com.  Also, foo.example.com cannot set
       policy for sibling.example.com.

   7.  UAs need to prevent users from "clicking through" security
       warnings.  Halting connection attempts in the face of secure
       transport exceptions is acceptable.  See also <a href="#section-12.1">Section 12.1</a> ("No
       User Recourse").

   NOTE:  A means for uniformly securely meeting the first core
          requirement above is not specifically addressed by this
          specification (see <a href="#section-14.6">Section 14.6</a> ("Bootstrap MITM
          Vulnerability")).  It may be addressed by a future revision of
          this specification or some other specification.  Note also
          that there are means by which UA implementations may more
          fully meet the first core requirement; see <a href="#section-12">Section 12</a> ("User
          Agent Implementation Advice").

<span class="h5"><a class="dashAnchor" name="//apple_ref/Section/2.4.1.2.%20%20Detailed%20Ancillary%20Requirements"></a><a class="selflink" href="#section-2.4.1.2" name="section-2.4.1.2">2.4.1.2</a>.  Detailed Ancillary Requirements</span>

   These ancillary requirements are also derived from the overall
   requirement.  They are not normatively addressed in this
   specification but could be met by UA implementations at their
   implementor's discretion, although meeting these requirements may be
   complex.

   1.  Disallow "mixed security context" loads (see <a href="#section-2.3.1.3">Section 2.3.1.3</a>).

   2.  Facilitate user declaration of web sites for which strict
       security policy is enabled, regardless of whether the sites
       signal HSTS Policy.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/3.%20%20Conformance%20Criteria"></a><a class="selflink" href="#section-3" name="section-3">3</a>.  Conformance Criteria</span>

   This specification is written for hosts and user agents.

   A conformant host is one that implements all the requirements listed
   in this specification that are applicable to hosts.

   A conformant user agent is one that implements all the requirements
   listed in this specification that are applicable to user agents.





<span class="grey">Hodges, et al.               Standards Track                   [Page 10]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-11" id="page-11" name="page-11"> </a>
<span class="grey"><a href="rfc6797.html">RFC 6797</a>          HTTP Strict Transport Security (HSTS)    November 2012</span>


   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in [<a href="rfc2119.html" title='"Key words for use in RFCs to Indicate Requirement Levels"'>RFC2119</a>].

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/4.%20%20Terminology"></a><a class="selflink" href="#section-4" name="section-4">4</a>.  Terminology</span>

   Terminology is defined in this section.

   ASCII case-insensitive comparison:

      means comparing two strings exactly, codepoint for codepoint,
      except that the characters in the range U+0041 ..  U+005A (i.e.,
      LATIN CAPITAL LETTER A to LATIN CAPITAL LETTER Z) and the
      corresponding characters in the range U+0061 ..  U+007A (i.e.,
      LATIN SMALL LETTER A to LATIN SMALL LETTER Z) are considered to
      also match.  See [<a href="#ref-Unicode" title='"The Unicode Standard"'>Unicode</a>] for details.

   codepoint:

      is a colloquial contraction of Code Point, which is any value in
      the Unicode codespace; that is, the range of integers from 0 to
      10FFFF(hex) [<a href="#ref-Unicode" title='"The Unicode Standard"'>Unicode</a>].

   domain name:

      is also referred to as "DNS name" and is defined in [<a href="rfc1035.html" title='"Domain names - implementation and specification"'>RFC1035</a>] to
      be represented outside of the DNS protocol itself (and
      implementations thereof) as a series of labels separated by dots,
      e.g., "example.com" or "yet.another.example.org".  In the context
      of this specification, domain names appear in that portion of a
      URI satisfying the reg-name production in "Appendix A.  Collected
      ABNF for URI" in [<a href="rfc3986.html" title='"Uniform Resource Identifier (URI): Generic Syntax"'>RFC3986</a>], and the host component from the Host
      HTTP header field production in <a href="rfc2616.html#section-14.23">Section 14.23 of [RFC2616]</a>.

      NOTE:  The domain names appearing in actual URI instances and
             matching the aforementioned production components may or
             may not be a fully qualified domain name.

   domain name label:

      is that portion of a domain name appearing "between the dots",
      i.e., consider "foo.example.com": "foo", "example", and "com" are
      all domain name labels.








<span class="grey">Hodges, et al.               Standards Track                   [Page 11]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-12" id="page-12" name="page-12"> </a>
<span class="grey"><a href="rfc6797.html">RFC 6797</a>          HTTP Strict Transport Security (HSTS)    November 2012</span>


   Effective Request URI:

      is a URI, identifying the target resource, that can be inferred by
      an HTTP host for any given HTTP request it receives.  Such
      inference is necessary because HTTP requests often do not contain
      a complete "absolute" URI identifying the target resource.  See
      <a href="#section-9">Section 9</a> ("Constructing an Effective Request URI").

   HTTP Strict Transport Security:

      is the overall name for the combined UA- and server-side security
      policy defined by this specification.

   HTTP Strict Transport Security Host:

      is a conformant host implementing the HTTP server aspects of the
      HSTS Policy.  This means that an HSTS Host returns the
      "Strict-Transport-Security" HTTP response header field in its HTTP
      response messages sent over secure transport.

   HTTP Strict Transport Security Policy:

      is the name of the combined overall UA- and server-side facets of
      the behavior defined in this specification.

   HSTS:

      See HTTP Strict Transport Security.

   HSTS Host:

      See HTTP Strict Transport Security Host.

   HSTS Policy:

      See HTTP Strict Transport Security Policy.

   Known HSTS Host:

      is an HSTS Host for which the UA has an HSTS Policy in effect;
      i.e., the UA has noted this host as a Known HSTS Host.  See
      <a href="#section-8.1.1">Section 8.1.1</a> ("Noting an HSTS Host - Storage Model") for
      particulars.

   Local policy:

      comprises policy rules that deployers specify and that are often
      manifested as configuration settings.



<span class="grey">Hodges, et al.               Standards Track                   [Page 12]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-13" id="page-13" name="page-13"> </a>
<span class="grey"><a href="rfc6797.html">RFC 6797</a>          HTTP Strict Transport Security (HSTS)    November 2012</span>


   MITM:

      is an acronym for "man in the middle".  See "man-in-the-middle
      attack" in [<a href="rfc4949.html" title='"Internet Security Glossary, Version 2"'>RFC4949</a>].

   Request URI:

      is the URI used to cause a UA to issue an HTTP request message.
      See also "Effective Request URI".

   UA:

      is an acronym for "user agent".  For the purposes of this
      specification, a UA is an HTTP client application typically
      actively manipulated by a user [<a href="rfc2616.html" title='"Hypertext Transfer Protocol -- HTTP/1.1"'>RFC2616</a>].

   unknown HSTS Host:

      is an HSTS Host that the user agent has not noted.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/5.%20%20HSTS%20Mechanism%20Overview"></a><a class="selflink" href="#section-5" name="section-5">5</a>.  HSTS Mechanism Overview</span>

   This section provides an overview of the mechanism by which an HSTS
   Host conveys its HSTS Policy to UAs and how UAs process the HSTS
   Policies received from HSTS Hosts.  The mechanism details are
   specified in Sections <a href="#section-6">6</a> through <a href="#section-15">15</a>.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.1.%20%20HSTS%20Host%20Declaration"></a><a class="selflink" href="#section-5.1" name="section-5.1">5.1</a>.  HSTS Host Declaration</span>

   An HTTP host declares itself an HSTS Host by issuing to UAs an HSTS
   Policy, which is represented by and conveyed via the
   Strict-Transport-Security HTTP response header field over secure
   transport (e.g., TLS).  Upon error-free receipt and processing of
   this header by a conformant UA, the UA regards the host as a Known
   HSTS Host.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.2.%20%20HSTS%20Policy"></a><a class="selflink" href="#section-5.2" name="section-5.2">5.2</a>.  HSTS Policy</span>

   An HSTS Policy directs UAs to communicate with a Known HSTS Host only
   over secure transport and specifies policy retention time duration.

   HSTS Policy explicitly overrides the UA processing of URI references,
   user input (e.g., via the "location bar"), or other information that,
   in the absence of HSTS Policy, might otherwise cause UAs to
   communicate insecurely with the Known HSTS Host.






<span class="grey">Hodges, et al.               Standards Track                   [Page 13]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-14" id="page-14" name="page-14"> </a>
<span class="grey"><a href="rfc6797.html">RFC 6797</a>          HTTP Strict Transport Security (HSTS)    November 2012</span>


   An HSTS Policy may contain an optional directive -- includeSubDomains
   -- specifying that this HSTS Policy also applies to any hosts whose
   domain names are subdomains of the Known HSTS Host's domain name.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.3.%20%20HSTS%20Policy%20Storage%20and%20Maintenance%20by%20User%20Agents"></a><a class="selflink" href="#section-5.3" name="section-5.3">5.3</a>.  HSTS Policy Storage and Maintenance by User Agents</span>

   UAs store and index HSTS Policies based strictly upon the domain
   names of the issuing HSTS Hosts.

   This means that UAs will maintain the HSTS Policy of any given HSTS
   Host separately from any HSTS Policies issued by any other HSTS Hosts
   whose domain names are superdomains or subdomains of the given HSTS
   Host's domain name.  Only the given HSTS Host can update or can cause
   deletion of its issued HSTS Policy.  It accomplishes this by sending
   Strict-Transport-Security HTTP response header fields to UAs with new
   values for policy time duration and subdomain applicability.  Thus,
   UAs cache the "freshest" HSTS Policy information on behalf of an HSTS
   Host.  Specifying a zero time duration signals the UA to delete the
   HSTS Policy (including any asserted includeSubDomains directive) for
   that HSTS Host.  See <a href="#section-8.1">Section 8.1</a> ("Strict-Transport-Security Response
   Header Field Processing") for details.  Additionally, <a href="#section-6.2">Section 6.2</a>
   presents examples of Strict-Transport-Security HTTP response header
   fields.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.4.%20%20User%20Agent%20HSTS%20Policy%20Enforcement"></a><a class="selflink" href="#section-5.4" name="section-5.4">5.4</a>.  User Agent HSTS Policy Enforcement</span>

   When establishing an HTTP connection to a given host, however
   instigated, the UA examines its cache of Known HSTS Hosts to see if
   there are any with domain names that are superdomains of the given
   host's domain name.  If any are found, and of those if any have the
   includeSubDomains directive asserted, then HSTS Policy applies to the
   given host.  Otherwise, HSTS Policy applies to the given host only if
   the given host is itself known to the UA as an HSTS Host.  See
   <a href="#section-8.3">Section 8.3</a> ("URI Loading and Port Mapping") for details.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/6.%20%20Syntax"></a><a class="selflink" href="#section-6" name="section-6">6</a>.  Syntax</span>

   This section defines the syntax of the Strict-Transport-Security HTTP
   response header field and its directives, and presents some examples.

   <a href="#section-7">Section 7</a> ("Server Processing Model") then details how hosts employ
   this header field to declare their HSTS Policy, and <a href="#section-8">Section 8</a> ("User
   Agent Processing Model") details how user agents process the header
   field and apply the HSTS Policy.







<span class="grey">Hodges, et al.               Standards Track                   [Page 14]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-15" id="page-15" name="page-15"> </a>
<span class="grey"><a href="rfc6797.html">RFC 6797</a>          HTTP Strict Transport Security (HSTS)    November 2012</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/6.1.%20%20Strict-Transport-Security%20HTTP%20Response%20Header%20Field"></a><a class="selflink" href="#section-6.1" name="section-6.1">6.1</a>.  Strict-Transport-Security HTTP Response Header Field</span>

   The Strict-Transport-Security HTTP response header field (STS header
   field) indicates to a UA that it MUST enforce the HSTS Policy in
   regards to the host emitting the response message containing this
   header field.

   The ABNF (Augmented Backus-Naur Form) syntax for the STS header field
   is given below.  It is based on the Generic Grammar defined in
   <a href="rfc2616.html#section-2">Section 2 of [RFC2616]</a> (which includes a notion of "implied linear
   whitespace", also known as "implied *LWS").

     Strict-Transport-Security = "Strict-Transport-Security" ":"
                                 [ directive ]  *( ";" [ directive ] )

     directive                 = directive-name [ "=" directive-value ]
     directive-name            = token
     directive-value           = token | quoted-string

   where:

     token          = &lt;token, defined in <a href="rfc2616.html#section-2.2">[RFC2616], Section 2.2</a>&gt;
     quoted-string  = &lt;quoted-string, defined in <a href="rfc2616.html#section-2.2">[RFC2616], Section 2.2</a>&gt;

   The two directives defined in this specification are described below.
   The overall requirements for directives are:

   1.  The order of appearance of directives is not significant.

   2.  All directives MUST appear only once in an STS header field.
       Directives are either optional or required, as stipulated in
       their definitions.

   3.  Directive names are case-insensitive.

   4.  UAs MUST ignore any STS header field containing directives, or
       other header field value data, that does not conform to the
       syntax defined in this specification.

   5.  If an STS header field contains directive(s) not recognized by
       the UA, the UA MUST ignore the unrecognized directives, and if
       the STS header field otherwise satisfies the above requirements
       (1 through 4), the UA MUST process the recognized directives.

   Additional directives extending the semantic functionality of the STS
   header field can be defined in other specifications, with a registry
   (having an IANA policy definition of IETF Review [<a href="rfc5226.html" title='"Guidelines for Writing an IANA Considerations Section in RFCs"'>RFC5226</a>]) defined
   for them at such time.



<span class="grey">Hodges, et al.               Standards Track                   [Page 15]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-16" id="page-16" name="page-16"> </a>
<span class="grey"><a href="rfc6797.html">RFC 6797</a>          HTTP Strict Transport Security (HSTS)    November 2012</span>


   NOTE:  Such future directives will be ignored by UAs implementing
          only this specification, as well as by generally
          non-conforming UAs.  See <a href="#section-14.2">Section 14.2</a> ("Non-Conformant User
          Agent Implications") for further discussion.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/6.1.1.%20%20The%20max-age%20Directive"></a><a class="selflink" href="#section-6.1.1" name="section-6.1.1">6.1.1</a>.  The max-age Directive</span>

   The REQUIRED "max-age" directive specifies the number of seconds,
   after the reception of the STS header field, during which the UA
   regards the host (from whom the message was received) as a Known HSTS
   Host.  See also <a href="#section-8.1.1">Section 8.1.1</a> ("Noting an HSTS Host - Storage
   Model").  The delta-seconds production is specified in [<a href="rfc2616.html" title='"Hypertext Transfer Protocol -- HTTP/1.1"'>RFC2616</a>].

   The syntax of the max-age directive's REQUIRED value (after
   quoted-string unescaping, if necessary) is defined as:

    max-age-value = delta-seconds

    delta-seconds = &lt;1*DIGIT, defined in <a href="rfc2616.html#section-3.3.2">[RFC2616], Section 3.3.2</a>&gt;

   NOTE:  A max-age value of zero (i.e., "max-age=0") signals the UA to
          cease regarding the host as a Known HSTS Host, including the
          includeSubDomains directive (if asserted for that HSTS Host).
          See also <a href="#section-8.1">Section 8.1</a> ("Strict-Transport-Security Response
          Header Field Processing").

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/6.1.2.%20%20The%20includeSubDomains%20Directive"></a><a class="selflink" href="#section-6.1.2" name="section-6.1.2">6.1.2</a>.  The includeSubDomains Directive</span>

   The OPTIONAL "includeSubDomains" directive is a valueless directive
   which, if present (i.e., it is "asserted"), signals the UA that the
   HSTS Policy applies to this HSTS Host as well as any subdomains of
   the host's domain name.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/6.2.%20%20Examples"></a><a class="selflink" href="#section-6.2" name="section-6.2">6.2</a>.  Examples</span>

   The HSTS header field below stipulates that the HSTS Policy is to
   remain in effect for one year (there are approximately 31536000
   seconds in a year), and the policy applies only to the domain of the
   HSTS Host issuing it:

     Strict-Transport-Security: max-age=31536000

   The HSTS header field below stipulates that the HSTS Policy is to
   remain in effect for approximately six months and that the policy
   applies to the domain of the issuing HSTS Host and all of its
   subdomains:

     Strict-Transport-Security: max-age=15768000 ; includeSubDomains



<span class="grey">Hodges, et al.               Standards Track                   [Page 16]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-17" id="page-17" name="page-17"> </a>
<span class="grey"><a href="rfc6797.html">RFC 6797</a>          HTTP Strict Transport Security (HSTS)    November 2012</span>


   The max-age directive value can optionally be quoted:

     Strict-Transport-Security: max-age="31536000"

   The HSTS header field below indicates that the UA must delete the
   entire HSTS Policy associated with the HSTS Host that sent the header
   field:

     Strict-Transport-Security: max-age=0

   The HSTS header field below has exactly the same effect as the one
   immediately above because the includeSubDomains directive's presence
   in the HSTS header field is ignored when max-age is zero:

     Strict-Transport-Security: max-age=0; includeSubDomains

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/7.%20%20Server%20Processing%20Model"></a><a class="selflink" href="#section-7" name="section-7">7</a>.  Server Processing Model</span>

   This section describes the processing model that HSTS Hosts
   implement.  The model comprises two facets: the first being the
   processing rules for HTTP request messages received over a secure
   transport (TLS [<a href="rfc5246.html" title='"The Transport Layer Security (TLS) Protocol Version 1.2"'>RFC5246</a>] or SSL [<a href="rfc6101.html" title='"The Secure Sockets Layer (SSL) Protocol Version 3.0"'>RFC6101</a>]; see also <a href="#section-14.1">Section 14.1</a>
   ("Underlying Secure Transport Considerations")), and the second being
   the processing rules for HTTP request messages received over
   non-secure transports, such as TCP.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/7.1.%20%20HTTP-over-Secure-Transport%20Request%20Type"></a><a class="selflink" href="#section-7.1" name="section-7.1">7.1</a>.  HTTP-over-Secure-Transport Request Type</span>

   When replying to an HTTP request that was conveyed over a secure
   transport, an HSTS Host SHOULD include in its response message an STS
   header field that MUST satisfy the grammar specified above in
   <a href="#section-6.1">Section 6.1</a> ("Strict-Transport-Security HTTP Response Header Field").
   If an STS header field is included, the HSTS Host MUST include only
   one such header field.

   Establishing a given host as a Known HSTS Host, in the context of a
   given UA, MAY be accomplished over HTTP, which is in turn running
   over secure transport, by correctly returning (per this
   specification) at least one valid STS header field to the UA.  Other
   mechanisms, such as a client-side pre-loaded Known HSTS Host list,
   MAY also be used; e.g., see <a href="#section-12">Section 12</a> ("User Agent Implementation
   Advice").

   NOTE:  Including the STS header field is stipulated as a "SHOULD" in
          order to accommodate various server- and network-side caches
          and load-balancing configurations where it may be difficult to
          uniformly emit STS header fields on behalf of a given HSTS
          Host.



<span class="grey">Hodges, et al.               Standards Track                   [Page 17]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-18" id="page-18" name="page-18"> </a>
<span class="grey"><a href="rfc6797.html">RFC 6797</a>          HTTP Strict Transport Security (HSTS)    November 2012</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/7.2.%20%20HTTP%20Request%20Type"></a><a class="selflink" href="#section-7.2" name="section-7.2">7.2</a>.  HTTP Request Type</span>

   If an HSTS Host receives an HTTP request message over a non-secure
   transport, it SHOULD send an HTTP response message containing a
   status code indicating a permanent redirect, such as status code 301
   (<a href="rfc2616.html#section-10.3.2">Section 10.3.2 of [RFC2616]</a>), and a Location header field value
   containing either the HTTP request's original Effective Request URI
   (see <a href="#section-9">Section 9</a> ("Constructing an Effective Request URI")) altered as
   necessary to have a URI scheme of "https", or a URI generated
   according to local policy with a URI scheme of "https".

   NOTE:  The above behavior is a "SHOULD" rather than a "MUST" due to:

      *  Risks in server-side non-secure-to-secure redirects
         [<a href="#ref-OWASP-TLSGuide">OWASP-TLSGuide</a>].

      *  Site deployment characteristics.  For example, a site that
         incorporates third-party components may not behave correctly
         when doing server-side non-secure-to-secure redirects in the
         case of being accessed over non-secure transport but does
         behave correctly when accessed uniformly over secure transport.
         The latter is the case given an HSTS-capable UA that has
         already noted the site as a Known HSTS Host (by whatever means,
         e.g., prior interaction or UA configuration).

   An HSTS Host MUST NOT include the STS header field in HTTP responses
   conveyed over non-secure transport.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/8.%20%20User%20Agent%20Processing%20Model"></a><a class="selflink" href="#section-8" name="section-8">8</a>.  User Agent Processing Model</span>

   This section describes the HTTP Strict Transport Security processing
   model for UAs.  There are several facets to the model, enumerated by
   the following subsections.

   This processing model assumes that the UA implements IDNA2008
   [<a href="rfc5890.html" title='"Internationalized Domain Names for Applications (IDNA): Definitions and Document Framework"'>RFC5890</a>], or possibly IDNA2003 [<a href="rfc3490.html" title='"Internationalizing Domain Names in Applications (IDNA)"'>RFC3490</a>], as noted in <a href="#section-13">Section 13</a>
   ("Internationalized Domain Names for Applications (IDNA): Dependency
   and Migration").  It also assumes that all domain names manipulated
   in this specification's context are already IDNA-canonicalized as
   outlined in <a href="#section-10">Section 10</a> ("Domain Name IDNA-Canonicalization") prior to
   the processing specified in this section.

      NOTE:  [<a href="rfc3490.html" title='"Internationalizing Domain Names in Applications (IDNA)"'>RFC3490</a>] is referenced due to its ongoing relevance to
             actual deployments for the foreseeable future.

   The above assumptions mean that this processing model also
   specifically assumes that appropriate IDNA and Unicode validations
   and character list testing have occurred on the domain names, in



<span class="grey">Hodges, et al.               Standards Track                   [Page 18]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-19" id="page-19" name="page-19"> </a>
<span class="grey"><a href="rfc6797.html">RFC 6797</a>          HTTP Strict Transport Security (HSTS)    November 2012</span>


   conjunction with their IDNA-canonicalization, prior to the processing
   specified in this section.  See the IDNA-specific security
   considerations in <a href="#section-14.10">Section 14.10</a> ("Internationalized Domain Names")
   for rationale and further details.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/8.1.%20%20Strict-Transport-Security%20Response%20Header%20Field%20Processing"></a><a class="selflink" href="#section-8.1" name="section-8.1">8.1</a>.  Strict-Transport-Security Response Header Field Processing</span>

   If an HTTP response, received over a secure transport, includes an
   STS header field, conforming to the grammar specified in <a href="#section-6.1">Section 6.1</a>
   ("Strict-Transport-Security HTTP Response Header Field"), and there
   are no underlying secure transport errors or warnings (see
   <a href="#section-8.4">Section 8.4</a>), the UA MUST either:

   o  Note the host as a Known HSTS Host if it is not already so noted
      (see <a href="#section-8.1.1">Section 8.1.1</a> ("Noting an HSTS Host - Storage Model")),

   or

   o  Update the UA's cached information for the Known HSTS Host if
      either or both of the max-age and includeSubDomains header field
      value tokens are conveying information different than that already
      maintained by the UA.

      The max-age value is essentially a "time to live" value relative
      to the reception time of the STS header field.

      If the max-age header field value token has a value of zero, the
      UA MUST remove its cached HSTS Policy information (including the
      includeSubDomains directive, if asserted) if the HSTS Host is
      known, or the UA MUST NOT note this HSTS Host if it is not yet
      known.

      If a UA receives more than one STS header field in an HTTP
      response message over secure transport, then the UA MUST process
      only the first such header field.

   Otherwise:

   o  If an HTTP response is received over insecure transport, the UA
      MUST ignore any present STS header field(s).

   o  The UA MUST ignore any STS header fields not conforming to the
      grammar specified in <a href="#section-6.1">Section 6.1</a> ("Strict-Transport-Security HTTP
      Response Header Field").







<span class="grey">Hodges, et al.               Standards Track                   [Page 19]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-20" id="page-20" name="page-20"> </a>
<span class="grey"><a href="rfc6797.html">RFC 6797</a>          HTTP Strict Transport Security (HSTS)    November 2012</span>


<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/8.1.1.%20%20Noting%20an%20HSTS%20Host%20-%20Storage%20Model"></a><a class="selflink" href="#section-8.1.1" name="section-8.1.1">8.1.1</a>.  Noting an HSTS Host - Storage Model</span>

   If the substring matching the host production from the Request-URI
   (of the message to which the host responded) syntactically matches
   the IP-literal or IPv4address productions from <a href="rfc3986.html#section-3.2.2">Section 3.2.2 of
   [RFC3986]</a>, then the UA MUST NOT note this host as a Known HSTS Host.

   Otherwise, if the substring does not congruently match a Known HSTS
   Host's domain name, per the matching procedure specified in
   <a href="#section-8.2">Section 8.2</a> ("Known HSTS Host Domain Name Matching"), then the UA
   MUST note this host as a Known HSTS Host, caching the HSTS Host's
   domain name and noting along with it the expiry time of this
   information, as effectively stipulated per the given max-age value,
   as well as whether the includeSubDomains directive is asserted or
   not.  See also <a href="#section-11.2">Section 11.2</a> ("HSTS Policy Expiration Time
   Considerations").

   The UA MUST NOT modify the expiry time or the includeSubDomains
   directive of any superdomain matched Known HSTS Host.

   A Known HSTS Host is "expired" if its cache entry has an expiry date
   in the past.  The UA MUST evict all expired Known HSTS Hosts from its
   cache if, at any time, an expired Known HSTS Host exists in the
   cache.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/8.2.%20%20Known%20HSTS%20Host%20Domain%20Name%20Matching"></a><a class="selflink" href="#section-8.2" name="section-8.2">8.2</a>.  Known HSTS Host Domain Name Matching</span>

   A given domain name may match a Known HSTS Host's domain name in one
   or both of two fashions: a congruent match, or a superdomain match.
   Alternatively, there may be no match.

   The steps below determine whether there are any matches, and if so,
   of which fashion:

      Compare the given domain name with the domain name of each of the
      UA's unexpired Known HSTS Hosts.  For each Known HSTS Host's
      domain name, the comparison is done with the given domain name
      label-by-label (comparing only labels) using an ASCII case-
      insensitive comparison beginning with the rightmost label, and
      continuing right-to-left.  See also <a href="rfc5890.html#section-2.3.2.4">Section 2.3.2.4 of [RFC5890]</a>.

      *  Superdomain Match

         If a label-for-label match between an entire Known HSTS Host's
         domain name and a right-hand portion of the given domain name
         is found, then this Known HSTS Host's domain name is a
         superdomain match for the given domain name.  There could be
         multiple superdomain matches for a given domain name.



<span class="grey">Hodges, et al.               Standards Track                   [Page 20]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-21" id="page-21" name="page-21"> </a>
<span class="grey"><a href="rfc6797.html">RFC 6797</a>          HTTP Strict Transport Security (HSTS)    November 2012</span>


         For example:

            Given domain name (DN):   qaz.bar.foo.example.com

            Superdomain matched
            Known HSTS Host DN:           bar.foo.example.com

            Superdomain matched
            Known HSTS Host DN:               foo.example.com


      *  Congruent Match

         If a label-for-label match between a Known HSTS Host's domain
         name and the given domain name is found -- i.e., there are no
         further labels to compare -- then the given domain name
         congruently matches this Known HSTS Host.

         For example:

            Given domain name:                foo.example.com

            Congruently matched
            Known HSTS Host DN:               foo.example.com


      *  Otherwise, if no matches are found, the given domain name does
         not represent a Known HSTS Host.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/8.3.%20%20URI%20Loading%20and%20Port%20Mapping"></a><a class="selflink" href="#section-8.3" name="section-8.3">8.3</a>.  URI Loading and Port Mapping</span>

   Whenever the UA prepares to "load" (also known as "dereference") any
   "http" URI [<a href="rfc3986.html" title='"Uniform Resource Identifier (URI): Generic Syntax"'>RFC3986</a>] (including when following HTTP redirects
   [<a href="rfc2616.html" title='"Hypertext Transfer Protocol -- HTTP/1.1"'>RFC2616</a>]), the UA MUST first determine whether a domain name is
   given in the URI and whether it matches a Known HSTS Host, using
   these steps:

   1.  Extract from the URI any substring described by the host
       component of the authority component of the URI.

   2.  If the substring is null, then there is no match with any Known
       HSTS Host.

   3.  Else, if the substring is non-null and syntactically matches the
       IP-literal or IPv4address productions from <a href="rfc3986.html#section-3.2.2">Section 3.2.2 of
       [RFC3986]</a>, then there is no match with any Known HSTS Host.





<span class="grey">Hodges, et al.               Standards Track                   [Page 21]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-22" id="page-22" name="page-22"> </a>
<span class="grey"><a href="rfc6797.html">RFC 6797</a>          HTTP Strict Transport Security (HSTS)    November 2012</span>


   4.  Otherwise, the substring is a given domain name, which MUST be
       matched against the UA's Known HSTS Hosts using the procedure in
       <a href="#section-8.2">Section 8.2</a> ("Known HSTS Host Domain Name Matching").

   5.  If, when performing domain name matching any superdomain match
       with an asserted includeSubDomains directive is found, or, if no
       superdomain matches with asserted includeSubDomains directives
       are found and a congruent match is found (with or without an
       asserted includeSubDomains directive), then before proceeding
       with the load:

          The UA MUST replace the URI scheme with "https" [<a href="rfc2818.html" title='"HTTP Over TLS"'>RFC2818</a>], and

          if the URI contains an explicit port component of "80", then
          the UA MUST convert the port component to be "443", or

          if the URI contains an explicit port component that is not
          equal to "80", the port component value MUST be preserved;
          otherwise,

          if the URI does not contain an explicit port component, the UA
          MUST NOT add one.

          NOTE:  These steps ensure that the HSTS Policy applies to HTTP
                 over any TCP port of an HSTS Host.

   NOTE:  In the case where an explicit port is provided (and to a
          lesser extent with subdomains), it is reasonably likely that
          there is actually an HTTP (i.e., non-secure) server running on
          the specified port and that an HTTPS request will thus fail
          (see item 6 in <a href="#appendix-A">Appendix A</a> ("Design Decision Notes")).

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/8.4.%20%20Errors%20in%20Secure%20Transport%20Establishment"></a><a class="selflink" href="#section-8.4" name="section-8.4">8.4</a>.  Errors in Secure Transport Establishment</span>

   When connecting to a Known HSTS Host, the UA MUST terminate the
   connection (see also <a href="#section-12">Section 12</a> ("User Agent Implementation Advice"))
   if there are any errors, whether "warning" or "fatal" or any other
   error level, with the underlying secure transport.  For example, this
   includes any errors found in certificate validity checking that UAs
   employ, such as via Certificate Revocation Lists (CRLs) [<a href="rfc5280.html" title='"Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile"'>RFC5280</a>], or
   via the Online Certificate Status Protocol (OCSP) [<a href="rfc2560.html" title='"X.509 Internet Public Key Infrastructure Online Certificate Status Protocol - OCSP"'>RFC2560</a>], as well
   as via TLS server identity checking [<a href="rfc6125.html" title='"Representation and Verification of Domain-Based Application Service Identity within Internet Public Key Infrastructure Using X.509 (PKIX) Certificates in the Context of Transport Layer Security (TLS)"'>RFC6125</a>].

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/8.5.%20%20HTTP-Equiv%20%3CMeta%3E%20Element%20Attribute"></a><a class="selflink" href="#section-8.5" name="section-8.5">8.5</a>.  HTTP-Equiv &lt;Meta&gt; Element Attribute</span>

   UAs MUST NOT heed http-equiv="Strict-Transport-Security" attribute
   settings on &lt;meta&gt; elements [<a href="#ref-W3C.REC-html401-19991224">W3C.REC-html401-19991224</a>] in received
   content.



<span class="grey">Hodges, et al.               Standards Track                   [Page 22]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-23" id="page-23" name="page-23"> </a>
<span class="grey"><a href="rfc6797.html">RFC 6797</a>          HTTP Strict Transport Security (HSTS)    November 2012</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/8.6.%20%20Missing%20Strict-Transport-Security%20Response%20Header%20Field"></a><a class="selflink" href="#section-8.6" name="section-8.6">8.6</a>.  Missing Strict-Transport-Security Response Header Field</span>

   If a UA receives HTTP responses from a Known HSTS Host over a secure
   channel but the responses are missing the STS header field, the UA
   MUST continue to treat the host as a Known HSTS Host until the
   max-age value for the knowledge of that Known HSTS Host is reached.
   Note that the max-age value could be effectively infinite for a given
   Known HSTS Host.  For example, this would be the case if the Known
   HSTS Host is part of a pre-configured list that is implemented such
   that the list entries never "age out".

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/9.%20%20Constructing%20an%20Effective%20Request%20URI"></a><a class="selflink" href="#section-9" name="section-9">9</a>.  Constructing an Effective Request URI</span>

   This section specifies how an HSTS Host must construct the Effective
   Request URI for a received HTTP request.

   HTTP requests often do not carry an absoluteURI for the target
   resource; instead, the URI needs to be inferred from the Request-URI,
   Host header field, and connection context ([<a href="rfc2616.html" title='"Hypertext Transfer Protocol -- HTTP/1.1"'>RFC2616</a>], Sections <a href="#section-3.2.1">3.2.1</a>,
   5.1.2, and 5.2).  The result of this process is called the "effective
   request URI (ERU)".  The "target resource" is the resource identified
   by the effective request URI.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/9.1.%20%20ERU%20Fundamental%20Definitions"></a><a class="selflink" href="#section-9.1" name="section-9.1">9.1</a>.  ERU Fundamental Definitions</span>

   The first line of an HTTP request message, Request-Line, is specified
   by the following ABNF from <a href="rfc2616.html#section-5.1">[RFC2616], Section 5.1</a>:

     Request-Line   = Method SP Request-URI SP HTTP-Version CRLF

   The Request-URI, within the Request-Line, is specified by the
   following ABNF from <a href="rfc2616.html#section-5.1.2">[RFC2616], Section 5.1.2</a>:

     Request-URI    = "*" | absoluteURI | abs_path | authority

   The Host request header field is specified by the following ABNF from
   <a href="rfc2616.html#section-14.23">[RFC2616], Section 14.23</a>:

     Host = "Host" ":" host [ ":" port ]












<span class="grey">Hodges, et al.               Standards Track                   [Page 23]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-24" id="page-24" name="page-24"> </a>
<span class="grey"><a href="rfc6797.html">RFC 6797</a>          HTTP Strict Transport Security (HSTS)    November 2012</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/9.2.%20%20Determining%20the%20Effective%20Request%20URI"></a><a class="selflink" href="#section-9.2" name="section-9.2">9.2</a>.  Determining the Effective Request URI</span>

   If the Request-URI is an absoluteURI, then the effective request URI
   is the Request-URI.

   If the Request-URI uses the abs_path form or the asterisk form, and
   the Host header field is present, then the effective request URI is
   constructed by concatenating:

   o  the scheme name: "http" if the request was received over an
      insecure TCP connection, or "https" when received over a TLS/
      SSL-secured TCP connection, and

   o  the octet sequence "://", and

   o  the host, and the port (if present), from the Host header field,
      and

   o  the Request-URI obtained from the Request-Line, unless the
      Request-URI is just the asterisk "*".

   If the Request-URI uses the abs_path form or the asterisk form, and
   the Host header field is not present, then the effective request URI
   is undefined.

   Otherwise, when Request-URI uses the authority form, the effective
   request URI is undefined.

   Effective request URIs are compared using the rules described in
   <a href="rfc2616.html#section-3.2.3">[RFC2616] Section 3.2.3</a>, except that empty path components MUST NOT
   be treated as equivalent to an absolute path of "/".

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/9.2.1.%20%20Effective%20Request%20URI%20Examples"></a><a class="selflink" href="#section-9.2.1" name="section-9.2.1">9.2.1</a>.  Effective Request URI Examples</span>

   Example 1: the effective request URI for the message

     GET /pub/WWW/TheProject.html HTTP/1.1
     Host: www.example.org:8080

   (received over an insecure TCP connection) is "http", plus "://",
   plus the authority component "www.example.org:8080", plus the
   request-target "/pub/WWW/TheProject.html".  Thus, it is
   "<a href="http://www.example.org:8080/pub/WWW/TheProject.html">http://www.example.org:8080/pub/WWW/TheProject.html</a>".








<span class="grey">Hodges, et al.               Standards Track                   [Page 24]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-25" id="page-25" name="page-25"> </a>
<span class="grey"><a href="rfc6797.html">RFC 6797</a>          HTTP Strict Transport Security (HSTS)    November 2012</span>


   Example 2: the effective request URI for the message

     OPTIONS * HTTP/1.1
     Host: www.example.org

   (received over an SSL/TLS secured TCP connection) is "https", plus
   "://", plus the authority component "www.example.org".  Thus, it is
   "https://www.example.org".

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/10.%20%20Domain%20Name%20IDNA-Canonicalization"></a><a class="selflink" href="#section-10" name="section-10">10</a>.  Domain Name IDNA-Canonicalization</span>

   An IDNA-canonicalized domain name is the output string generated by
   the following steps.  The input is a putative domain name string
   ostensibly composed of any combination of "A-labels", "U-labels", and
   "NR-LDH labels" (see <a href="rfc5890.html#section-2">Section 2 of [RFC5890]</a>) concatenated using some
   separator character (typically ".").

   1.  Convert the input putative domain name string to an order-
       preserving sequence of individual label strings.

   2.  When implementing IDNA2008, convert, validate, and test each
       A-label and U-label found among the sequence of individual label
       strings, using the procedures defined in Sections <a href="#section-5.3">5.3</a> through <a href="#section-5.5">5.5</a>
       of [<a href="rfc5891.html" title='"Internationalized Domain Names in Applications (IDNA): Protocol"'>RFC5891</a>].

       Otherwise, when implementing IDNA2003, convert each label using
       the "ToASCII" conversion in <a href="rfc3490.html#section-4">Section 4 of [RFC3490]</a> (see also the
       definition of "equivalence of labels" in <a href="rfc3490.html#section-2">Section 2 of [RFC3490]</a>).

   3.  If no errors occurred during the foregoing step, concatenate all
       the labels in the sequence, in order, into a string, separating
       each label from the next with a %x2E (".") character.  The
       resulting string, known as an IDNA-canonicalized domain name, is
       appropriate for use in the context of <a href="#section-8">Section 8</a> ("User Agent
       Processing Model").

       Otherwise, errors occurred.  The input putative domain name
       string was not successfully IDNA-canonicalized.  Invokers of this
       procedure should attempt appropriate error recovery.

   See also Sections <a href="#section-13">13</a> ("Internationalized Domain Names for
   Applications (IDNA): Dependency and Migration") and 14.10
   ("Internationalized Domain Names") of this specification for further
   details and considerations.







<span class="grey">Hodges, et al.               Standards Track                   [Page 25]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-26" id="page-26" name="page-26"> </a>
<span class="grey"><a href="rfc6797.html">RFC 6797</a>          HTTP Strict Transport Security (HSTS)    November 2012</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/11.%20%20Server%20Implementation%20and%20Deployment%20Advice"></a><a class="selflink" href="#section-11" name="section-11">11</a>.  Server Implementation and Deployment Advice</span>

   This section is non-normative.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/11.1.%20%20Non-Conformant%20User%20Agent%20Considerations"></a><a class="selflink" href="#section-11.1" name="section-11.1">11.1</a>.  Non-Conformant User Agent Considerations</span>

   Non-conformant UAs ignore the Strict-Transport-Security header field;
   thus, non-conformant user agents do not address the threats described
   in <a href="#section-2.3.1">Section 2.3.1</a> ("Threats Addressed").  Please refer to <a href="#section-14.2">Section 14.2</a>
   ("Non-Conformant User Agent Implications") for further discussion.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/11.2.%20%20HSTS%20Policy%20Expiration%20Time%20Considerations"></a><a class="selflink" href="#section-11.2" name="section-11.2">11.2</a>.  HSTS Policy Expiration Time Considerations</span>

   Server implementations and deploying web sites need to consider
   whether they are setting an expiry time that is a constant value into
   the future, or whether they are setting an expiry time that is a
   fixed point in time.

   The "constant value into the future" approach can be accomplished by
   constantly sending the same max-age value to UAs.

   For example, a max-age value of 7776000 seconds is 90 days:

     Strict-Transport-Security: max-age=7776000

   Note that each receipt of this header by a UA will require the UA to
   update its notion of when it must delete its knowledge of this Known
   HSTS Host.

   The "fixed point in time" approach can be accomplished by sending
   max-age values that represent the remaining time until the desired
   expiry time.  This would require the HSTS Host to send a newly
   calculated max-age value in each HTTP response.

   A consideration here is whether a deployer wishes to have the
   signaled HSTS Policy expiry time match that for the web site's domain
   certificate.

   Additionally, server implementers should consider employing a default
   max-age value of zero in their deployment configuration systems.
   This will require deployers to willfully set max-age in order to have
   UAs enforce the HSTS Policy for their host and will protect them from
   inadvertently enabling HSTS with some arbitrary non-zero duration.








<span class="grey">Hodges, et al.               Standards Track                   [Page 26]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-27" id="page-27" name="page-27"> </a>
<span class="grey"><a href="rfc6797.html">RFC 6797</a>          HTTP Strict Transport Security (HSTS)    November 2012</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/11.3.%20%20Using%20HSTS%20in%20Conjunction%20with%20Self-Signed%20Public-Key"></a><a class="selflink" href="#section-11.3" name="section-11.3">11.3</a>.  Using HSTS in Conjunction with Self-Signed Public-Key</span>
<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/Certificates"></a>       Certificates</span>

   If all four of the following conditions are true...

   o  a web site/organization/enterprise is generating its own secure
      transport public-key certificates for web sites, and

   o  that organization's root certification authority (CA) certificate
      is not typically embedded by default in browser and/or operating
      system CA certificate stores, and

   o  HSTS Policy is enabled on a host identifying itself using a
      certificate signed by the organization's CA (i.e., a "self-signed
      certificate"), and

   o  this certificate does not match a usable TLS certificate
      association (as defined by <a href="#section-4">Section 4</a> of the TLSA protocol
      specification [<a href="rfc6698.html" title='"The DNS-Based Authentication of Named Entities (DANE) Transport Layer Security (TLS) Protocol: TLSA"'>RFC6698</a>]),

   ...then secure connections to that site will fail, per the HSTS
   design.  This is to protect against various active attacks, as
   discussed above.

   However, if said organization wishes to employ its own CA, and self-
   signed certificates, in concert with HSTS, it can do so by deploying
   its root CA certificate to its users' browsers or operating system CA
   root certificate stores.  It can also, in addition or instead,
   distribute to its users' browsers the end-entity certificate(s) for
   specific hosts.  There are various ways in which this can be
   accomplished (details are out of scope for this specification).  Once
   its root CA certificate is installed in the browsers, it may employ
   HSTS Policy on its site(s).

   Alternatively, that organization can deploy the TLSA protocol; all
   browsers that also use TLSA will then be able to trust the
   certificates identified by usable TLS certificate associations as
   denoted via TLSA.

   NOTE:  Interactively distributing root CA certificates to users,
          e.g., via email, and having the users install them, is
          arguably training the users to be susceptible to a possible
          form of phishing attack.  See <a href="#section-14.8">Section 14.8</a> ("Bogus Root CA
          Certificate Phish plus DNS Cache Poisoning Attack").  Thus,
          care should be taken in the manner in which such certificates
          are distributed and installed on users' systems and browsers.





<span class="grey">Hodges, et al.               Standards Track                   [Page 27]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-28" id="page-28" name="page-28"> </a>
<span class="grey"><a href="rfc6797.html">RFC 6797</a>          HTTP Strict Transport Security (HSTS)    November 2012</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/11.4.%20%20Implications%20of%20includeSubDomains"></a><a class="selflink" href="#section-11.4" name="section-11.4">11.4</a>.  Implications of includeSubDomains</span>

   The includeSubDomains directive has practical implications meriting
   careful consideration; two example scenarios are:

   o  An HSTS Host offers unsecured HTTP-based services on alternate
      ports or at various subdomains of its HSTS Host domain name.

   o  Distinct web applications are offered at distinct subdomains of an
      HSTS Host, such that UAs often interact directly with these
      subdomain web applications without having necessarily interacted
      with a web application offered at the HSTS Host's domain name (if
      any).

   The sections below discuss each of these scenarios in turn.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/11.4.1.%20%20Considerations%20for%20Offering%20Unsecured%20HTTP%20Services%20at"></a><a class="selflink" href="#section-11.4.1" name="section-11.4.1">11.4.1</a>.  Considerations for Offering Unsecured HTTP Services at</span>
<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/Alternate%20Ports%20or%20Subdomains%20of%20an%20HSTS%20Host"></a>         Alternate Ports or Subdomains of an HSTS Host</span>

   For example, certification authorities often offer their CRL
   distribution and OCSP services [<a href="rfc2560.html" title='"X.509 Internet Public Key Infrastructure Online Certificate Status Protocol - OCSP"'>RFC2560</a>] over plain HTTP, and
   sometimes at a subdomain of a publicly available web application that
   may be secured by TLS/SSL.  For example, &lt;https://ca.example.com/&gt; is
   a publicly available web application for "Example CA", a
   certification authority.  Customers use this web application to
   register their public keys and obtain certificates.  "Example CA"
   generates certificates for customers containing
   &lt;<a href="http://crl-and-ocsp.ca.example.com/">http://crl-and-ocsp.ca.example.com/</a>&gt; as the value for the "CRL
   Distribution Points" and "Authority Information Access:OCSP"
   certificate fields.

   If ca.example.com were to issue an HSTS Policy with the
   includeSubDomains directive, then HTTP-based user agents implementing
   HSTS that have interacted with the ca.example.com web application
   would fail to retrieve CRLs and fail to check OCSP for certificates,
   because these services are offered over plain HTTP.

   In this case, Example CA can either:

   o  not use the includeSubDomains directive, or

   o  ensure that HTTP-based services offered at subdomains of
      ca.example.com are also uniformly offered over TLS/SSL, or








<span class="grey">Hodges, et al.               Standards Track                   [Page 28]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-29" id="page-29" name="page-29"> </a>
<span class="grey"><a href="rfc6797.html">RFC 6797</a>          HTTP Strict Transport Security (HSTS)    November 2012</span>


   o  offer plain HTTP-based services at a different domain name, e.g.,
      crl-and-ocsp.ca.example.NET, or

   o  utilize an alternative approach to distributing certificate status
      information, obviating the need to offer CRL distribution and OCSP
      services over plain HTTP (e.g., the "Certificate Status Request"
      TLS extension [<a href="rfc6066.html" title='"Transport Layer Security (TLS) Extensions: Extension Definitions"'>RFC6066</a>], often colloquially referred to as "OCSP
      Stapling").

   NOTE:  The above points are expressly only an example and do not
          purport to address all the involved complexities.  For
          instance, there are many considerations -- on the part of CAs,
          certificate deployers, and applications (e.g., browsers) --
          involved in deploying an approach such as "OCSP Stapling".
          Such issues are out of scope for this specification.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/11.4.2.%20%20Considerations%20for%20Offering%20Web%20Applications%20at%20Subdomains%20of"></a><a class="selflink" href="#section-11.4.2" name="section-11.4.2">11.4.2</a>.  Considerations for Offering Web Applications at Subdomains of</span>
<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/an%20HSTS%20Host"></a>         an HSTS Host</span>

   In this scenario, an HSTS Host declares an HSTS Policy with an
   includeSubDomains directive, and there also exist distinct web
   applications offered at distinct subdomains of the HSTS Host such
   that UAs often interact directly with these subdomain web
   applications without having necessarily interacted with the HSTS
   Host.  In such a case, the UAs will not receive or enforce the HSTS
   Policy.

   For example, the HSTS Host is "example.com", and it is configured to
   emit the STS header field with the includeSubDomains directive.
   However, example.com's actual web application is addressed at
   "www.example.com", and example.com simply redirects user agents to
   "https://www.example.com/".

   If the STS header field is only emitted by "example.com" but UAs
   typically bookmark -- and links (from anywhere on the web) are
   typically established to -- "www.example.com", and "example.com" is
   not contacted directly by all user agents in some non-zero percentage
   of interactions, then some number of UAs will not note "example.com"
   as an HSTS Host, and some number of users of "www.example.com" will
   be unprotected by HSTS Policy.

   To address this, HSTS Hosts should be configured such that the STS
   header field is emitted directly at each HSTS Host domain or
   subdomain name that constitutes a well-known "entry point" to one's
   web application(s), whether or not the includeSubDomains directive is
   employed.





<span class="grey">Hodges, et al.               Standards Track                   [Page 29]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-30" id="page-30" name="page-30"> </a>
<span class="grey"><a href="rfc6797.html">RFC 6797</a>          HTTP Strict Transport Security (HSTS)    November 2012</span>


   Thus, in our example, if the STS header field is emitted from both
   "example.com" and "www.example.com", this issue will be addressed.
   Also, if there are any other well-known entry points to web
   applications offered by "example.com", such as "foo.example.com",
   they should also be configured to emit the STS header field.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/12.%20%20User%20Agent%20Implementation%20Advice"></a><a class="selflink" href="#section-12" name="section-12">12</a>.  User Agent Implementation Advice</span>

   This section is non-normative.

   In order to provide users and web sites more effective protection, as
   well as controls for managing their UA's caching of HSTS Policy, UA
   implementers should consider including features such as the
   following:

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/12.1.%20%20No%20User%20Recourse"></a><a class="selflink" href="#section-12.1" name="section-12.1">12.1</a>.  No User Recourse</span>

   Failing secure connection establishment on any warnings or errors
   (per <a href="#section-8.4">Section 8.4</a> ("Errors in Secure Transport Establishment")) should
   be done with "no user recourse".  This means that the user should not
   be presented with a dialog giving her the option to proceed.  Rather,
   it should be treated similarly to a server error where there is
   nothing further the user can do with respect to interacting with the
   target web application, other than wait and retry.

   Essentially, "any warnings or errors" means anything that would cause
   the UA implementation to announce to the user that something is not
   entirely correct with the connection establishment.

   Not doing this, i.e., allowing user recourse such as "clicking
   through warning/error dialogs", is a recipe for a man-in-the-middle
   attack.  If a web application issues an HSTS Policy, then it is
   implicitly opting into the "no user recourse" approach, whereby all
   certificate errors or warnings cause a connection termination, with
   no chance to "fool" users into making the wrong decision and
   compromising themselves.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/12.2.%20%20User-Declared%20HSTS%20Policy"></a><a class="selflink" href="#section-12.2" name="section-12.2">12.2</a>.  User-Declared HSTS Policy</span>

   A user-declared HSTS Policy is the ability for users to explicitly
   declare a given domain name as representing an HSTS Host, thus
   seeding it as a Known HSTS Host before any actual interaction with
   it.  This would help protect against the bootstrap MITM vulnerability
   as discussed in <a href="#section-14.6">Section 14.6</a> ("Bootstrap MITM Vulnerability").







<span class="grey">Hodges, et al.               Standards Track                   [Page 30]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-31" id="page-31" name="page-31"> </a>
<span class="grey"><a href="rfc6797.html">RFC 6797</a>          HTTP Strict Transport Security (HSTS)    November 2012</span>


   NOTE:  Such a feature is difficult to get right on a per-site basis.
          See the discussion of "rewrite rules" in Section 5.5 of
          [<a href="#ref-ForceHTTPS">ForceHTTPS</a>].  For example, arbitrary web sites may not
          materialize all their URIs using the "https" scheme and thus
          could "break" if a UA were to attempt to access the site
          exclusively using such URIs.  Also note that this feature
          would complement, but is independent of, an "HSTS pre-loaded
          list" feature (see <a href="#section-12.3">Section 12.3</a>).

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/12.3.%20%20HSTS%20Pre-Loaded%20List"></a><a class="selflink" href="#section-12.3" name="section-12.3">12.3</a>.  HSTS Pre-Loaded List</span>

   An HSTS pre-loaded list is a facility whereby web site administrators
   can have UAs pre-configured with HSTS Policy for their site(s) by the
   UA vendor(s) -- a so-called "pre-loaded list" -- in a manner similar
   to how root CA certificates are embedded in browsers "at the
   factory".  This would help protect against the bootstrap MITM
   vulnerability (<a href="#section-14.6">Section 14.6</a>).

   NOTE:  Such a facility would complement a "user-declared HSTS Policy"
          feature (<a href="#section-12.2">Section 12.2</a>).

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/12.4.%20%20Disallow%20Mixed%20Security%20Context%20Loads"></a><a class="selflink" href="#section-12.4" name="section-12.4">12.4</a>.  Disallow Mixed Security Context Loads</span>

   "Mixed security context" loads happen when a web application
   resource, fetched by the UA over a secure transport, subsequently
   causes the fetching of one or more other resources without using
   secure transport.  This is also generally referred to as "mixed
   content" loads (see <a href="#section-5.3">Section 5.3</a> ("Mixed Content") in
   [<a href="#ref-W3C.REC-wsc-ui-20100812">W3C.REC-wsc-ui-20100812</a>]) but should not be confused with the same
   "mixed content" term that is also used in the context of markup
   languages such as XML and HTML.

   NOTE:  In order to provide behavioral uniformity across UA
          implementations, the notion of mixed security context will
          require further standardization work, e.g., to define the
          term(s) more clearly and to define specific behaviors with
          respect to it.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/12.5.%20%20HSTS%20Policy%20Deletion"></a><a class="selflink" href="#section-12.5" name="section-12.5">12.5</a>.  HSTS Policy Deletion</span>

   HSTS Policy deletion is the ability to delete a UA's cached HSTS
   Policy on a per-HSTS Host basis.

   NOTE:  Adding such a feature should be done very carefully in both
          the user interface and security senses.  Deleting a cache
          entry for a Known HSTS Host should be a very deliberate and
          well-considered act -- it shouldn't be something that users
          get used to doing as a matter of course: e.g., just "clicking



<span class="grey">Hodges, et al.               Standards Track                   [Page 31]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-32" id="page-32" name="page-32"> </a>
<span class="grey"><a href="rfc6797.html">RFC 6797</a>          HTTP Strict Transport Security (HSTS)    November 2012</span>


          through" in order to get work done.  Also, implementations
          need to guard against allowing an attacker to inject code,
          e.g., ECMAscript, into the UA that silently and
          programmatically removes entries from the UA's cache of Known
          HSTS Hosts.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/13.%20%20Internationalized%20Domain%20Names%20for%20Applications%20%28IDNA%29%3A%20Dependency"></a><a class="selflink" href="#section-13" name="section-13">13</a>.  Internationalized Domain Names for Applications (IDNA): Dependency</span>
<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/and%20Migration"></a>     and Migration</span>

   Textual domain names on the modern Internet may contain one or more
   "internationalized" domain name labels.  Such domain names are
   referred to as "internationalized domain names" (IDNs).  The
   specification suites defining IDNs and the protocols for their use
   are named "Internationalized Domain Names for Applications (IDNA)".
   At this time, there are two such specification suites: IDNA2008
   [<a href="rfc5890.html" title='"Internationalized Domain Names for Applications (IDNA): Definitions and Document Framework"'>RFC5890</a>] and its predecessor IDNA2003 [<a href="rfc3490.html" title='"Internationalizing Domain Names in Applications (IDNA)"'>RFC3490</a>].

   IDNA2008 obsoletes IDNA2003, but there are differences between the
   two specifications, and thus there can be differences in processing
   (e.g., converting) domain name labels that have been registered under
   one from those registered under the other.  There will be a
   transition period of some time during which IDNA2003-based domain
   name labels will exist in the wild.  In order to facilitate their
   IDNA transition, user agents SHOULD implement IDNA2008 [<a href="rfc5890.html" title='"Internationalized Domain Names for Applications (IDNA): Definitions and Document Framework"'>RFC5890</a>] and
   MAY implement [<a href="rfc5895.html" title='"Mapping Characters for Internationalized Domain Names in Applications (IDNA) 2008"'>RFC5895</a>] (see also <a href="rfc5894.html#section-7">Section 7 of [RFC5894]</a>) or [<a href="#ref-UTS46" title='"Unicode IDNA Compatibility Processing"'>UTS46</a>].
   If a user agent does not implement IDNA2008, the user agent MUST
   implement IDNA2003.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/14.%20%20Security%20Considerations"></a><a class="selflink" href="#section-14" name="section-14">14</a>.  Security Considerations</span>

   This specification concerns the expression, conveyance, and
   enforcement of the HSTS Policy.  The overall HSTS Policy threat
   model, including addressed and unaddressed threats, is given in
   <a href="#section-2.3">Section 2.3</a> ("Threat Model").

   Additionally, the sections below discuss operational ramifications of
   the HSTS Policy, provide feature rationale, discuss potential HSTS
   Policy misuse, and highlight some known vulnerabilities in the HSTS
   Policy regime.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/14.1.%20%20Underlying%20Secure%20Transport%20Considerations"></a><a class="selflink" href="#section-14.1" name="section-14.1">14.1</a>.  Underlying Secure Transport Considerations</span>

   This specification is fashioned to be independent of the secure
   transport underlying HTTP.  However, the threat analysis and
   requirements in <a href="#section-2">Section 2</a> ("Overview") in fact presume TLS or SSL as
   the underlying secure transport.  Thus, employment of HSTS in the
   context of HTTP running over some other secure transport protocol
   would require assessment of that secure transport protocol's security



<span class="grey">Hodges, et al.               Standards Track                   [Page 32]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-33" id="page-33" name="page-33"> </a>
<span class="grey"><a href="rfc6797.html">RFC 6797</a>          HTTP Strict Transport Security (HSTS)    November 2012</span>


   model in conjunction with the specifics of how HTTP is layered over
   it in order to assess HSTS's subsequent security properties in that
   context.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/14.2.%20%20Non-Conformant%20User%20Agent%20Implications"></a><a class="selflink" href="#section-14.2" name="section-14.2">14.2</a>.  Non-Conformant User Agent Implications</span>

   Non-conformant user agents ignore the Strict-Transport-Security
   header field; thus, non-conformant user agents do not address the
   threats described in <a href="#section-2.3.1">Section 2.3.1</a> ("Threats Addressed").

   This means that the web application and its users wielding
   non-conformant UAs will be vulnerable to both of the following:

   o  Passive network attacks due to web site development and deployment
      bugs:

         For example, if the web application contains any insecure
         references (e.g., "http") to the web application server, and if
         not all of its cookies are flagged as "Secure", then its
         cookies will be vulnerable to passive network sniffing and,
         potentially, subsequent misuse of user credentials.

   o  Active network attacks:

         For example, if an attacker is able to place a "man in the
         middle", secure transport connection attempts will likely yield
         warnings to the user, but without HSTS Policy being enforced,
         the present common practice is to allow the user to "click
         through" and proceed.  This renders the user and possibly the
         web application open to abuse by such an attacker.

   This is essentially the status quo for all web applications and their
   users in the absence of HSTS Policy.  Since web application providers
   typically do not control the type or version of UAs their web
   applications interact with, the implication is that HSTS Host
   deployers must generally exercise the same level of care to avoid web
   site development and deployment bugs (see <a href="#section-2.3.1.3">Section 2.3.1.3</a>) as they
   would if they were not asserting HSTS Policy.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/14.3.%20%20Ramifications%20of%20HSTS%20Policy%20Establishment%20Only%20over%20Error-Free"></a><a class="selflink" href="#section-14.3" name="section-14.3">14.3</a>.  Ramifications of HSTS Policy Establishment Only over Error-Free</span>
<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/Secure%20Transport"></a>       Secure Transport</span>

   The user agent processing model defined in <a href="#section-8">Section 8</a> ("User Agent
   Processing Model") stipulates that a host is initially noted as a
   Known HSTS Host, or that updates are made to a Known HSTS Host's
   cached information, only if the UA receives the STS header field over
   a secure transport connection having no underlying secure transport
   errors or warnings.



<span class="grey">Hodges, et al.               Standards Track                   [Page 33]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-34" id="page-34" name="page-34"> </a>
<span class="grey"><a href="rfc6797.html">RFC 6797</a>          HTTP Strict Transport Security (HSTS)    November 2012</span>


   The rationale behind this is that if there is a "man in the middle"
   (MITM) -- whether a legitimately deployed proxy or an illegitimate
   entity -- it could cause various mischief (see also <a href="#appendix-A">Appendix A</a>
   ("Design Decision Notes") item 3, as well as <a href="#section-14.6">Section 14.6</a> ("Bootstrap
   MITM Vulnerability")); for example:

   o  Unauthorized notation of the host as a Known HSTS Host,
      potentially leading to a denial-of-service situation if the host
      does not uniformly offer its services over secure transport (see
      also <a href="#section-14.5">Section 14.5</a> ("Denial of Service")).

   o  Resetting the time to live for the host's designation as a Known
      HSTS Host by manipulating the max-age header field parameter value
      that is returned to the UA.  If max-age is returned as zero, this
      will cause the host to cease being regarded as a Known HSTS Host
      by the UA, leading to either insecure connections to the host or
      possibly denial of service if the host delivers its services only
      over secure transport.

   However, this means that if a UA is "behind" a MITM non-transparent
   TLS proxy -- within a corporate intranet, for example -- and
   interacts with an unknown HSTS Host beyond the proxy, the user could
   possibly be presented with the legacy secure connection error
   dialogs.  Even if the risk is accepted and the user "clicks through",
   the host will not be noted as an HSTS Host.  Thus, as long as the UA
   is behind such a proxy, the user will be vulnerable and will possibly
   be presented with the legacy secure connection error dialogs for
   as-yet unknown HSTS Hosts.

   Once the UA successfully connects to an unknown HSTS Host over error-
   free secure transport, the host will be noted as a Known HSTS Host.
   This will result in the failure of subsequent connection attempts
   from behind interfering proxies.

   The above discussion relates to the recommendation in <a href="#section-12">Section 12</a>
   ("User Agent Implementation Advice") that the secure connection be
   terminated with "no user recourse" whenever there are warnings and
   errors and the host is a Known HSTS Host.  Such a posture protects
   users from "clicking through" security warnings and putting
   themselves at risk.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/14.4.%20%20The%20Need%20for%20includeSubDomains"></a><a class="selflink" href="#section-14.4" name="section-14.4">14.4</a>.  The Need for includeSubDomains</span>

   Without the includeSubDomains directive, a web application would not
   be able to adequately protect so-called "domain cookies" (even if
   these cookies have their "Secure" flag set and thus are conveyed only
   on secure channels).  These are cookies the web application expects
   UAs to return to any and all subdomains of the web application.



<span class="grey">Hodges, et al.               Standards Track                   [Page 34]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-35" id="page-35" name="page-35"> </a>
<span class="grey"><a href="rfc6797.html">RFC 6797</a>          HTTP Strict Transport Security (HSTS)    November 2012</span>


   For example, suppose example.com represents the top-level DNS name
   for a web application.  Further suppose that this cookie is set for
   the entire example.com domain, i.e., it is a "domain cookie", and it
   has its Secure flag set.  Suppose example.com is a Known HSTS Host
   for this UA, but the includeSubDomains directive is not set.

   Now, if an attacker causes the UA to request a subdomain name that is
   unlikely to already exist in the web application, such as
   "https://uxdhbpahpdsf.example.com/", but that the attacker has
   managed to register in the DNS and point at an HTTP server under the
   attacker's control, then:

   1.  The UA is unlikely to already have an HSTS Policy established for
       "uxdhbpahpdsf.example.com".

   2.  The HTTP request sent to uxdhbpahpdsf.example.com will include
       the Secure-flagged domain cookie.

   3.  If "uxdhbpahpdsf.example.com" returns a certificate during TLS
       establishment, and the user "clicks through" any warning that
       might be presented (it is possible, but not certain, that one may
       obtain a requisite certificate for such a domain name such that a
       warning may or may not appear), then the attacker can obtain the
       Secure-flagged domain cookie that's ostensibly being protected.

   Without the "includeSubDomains" directive, HSTS is unable to protect
   such Secure-flagged domain cookies.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/14.5.%20%20Denial%20of%20Service"></a><a class="selflink" href="#section-14.5" name="section-14.5">14.5</a>.  Denial of Service</span>

   HSTS could be used to mount certain forms of Denial-of-Service (DoS)
   attacks against web sites.  A DoS attack is an attack in which one or
   more network entities target a victim entity and attempt to prevent
   the victim from doing useful work.  This section discusses such
   scenarios in terms of HSTS, though this list is not exhaustive.  See
   also [<a href="rfc4732.html" title='"Internet Denial-of- Service Considerations"'>RFC4732</a>] for a discussion of overall Internet DoS
   considerations.

   o  Web applications available over HTTP

      There is an opportunity for perpetrating DoS attacks with web
      applications (or critical portions of them) that are available
      only over HTTP without secure transport, if attackers can cause
      UAs to set HSTS Policy for such web applications' host(s).

      This is because once the HSTS Policy is set for a web
      application's host in a UA, the UA will only use secure transport
      to communicate with the host.  If the host is not using secure



<span class="grey">Hodges, et al.               Standards Track                   [Page 35]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-36" id="page-36" name="page-36"> </a>
<span class="grey"><a href="rfc6797.html">RFC 6797</a>          HTTP Strict Transport Security (HSTS)    November 2012</span>


      transport or is not using it for critical portions of its web
      application, then the web application will be rendered unusable
      for the UA's user.

      NOTE:  This is a use case for UAs to offer an "HSTS Policy
             deletion" feature as noted in <a href="#section-12.5">Section 12.5</a> ("HSTS Policy
             Deletion").

      An HSTS Policy can be set for a victim host in various ways:

      *  If the web application has an HTTP response splitting
         vulnerability [<a href="#ref-CWE-113" title="&quot;CWE-113: Improper Neutralization of CRLF Sequences in HTTP Headers ('HTTP Response Splitting')&quot;">CWE-113</a>] (which can be abused in order to
         facilitate "HTTP header injection").

      *  If an attacker can spoof a redirect from an insecure victim
         site, e.g., &lt;http://example.com/&gt; to &lt;https://example.com/&gt;,
         where the latter is attacker-controlled and has an apparently
         valid certificate.  In this situation, the attacker can then
         set an HSTS Policy for example.com and also for all subdomains
         of example.com.

      *  If an attacker can convince users to manually configure HSTS
         Policy for a victim host.  This assumes that their UAs offer
         such a capability (see <a href="#section-12">Section 12</a> ("User Agent Implementation
         Advice")).  Alternatively, if such UA configuration is
         scriptable, then an attacker can cause UAs to execute his
         script and set HSTS Policies for whichever desired domains.

   o  Inadvertent use of includeSubDomains

      The includeSubDomains directive instructs UAs to automatically
      regard all subdomains of the given HSTS Host as Known HSTS Hosts.
      If any such subdomains do not support properly configured secure
      transport, then they will be rendered unreachable from such UAs.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/14.6.%20%20Bootstrap%20MITM%20Vulnerability"></a><a class="selflink" href="#section-14.6" name="section-14.6">14.6</a>.  Bootstrap MITM Vulnerability</span>

   Bootstrap MITM (man-in-the-middle) vulnerability is a vulnerability
   that users and HSTS Hosts encounter in the situation where the user
   manually enters, or follows a link, to an unknown HSTS Host using an
   "http" URI rather than an "https" URI.  Because the UA uses an
   insecure channel in the initial attempt to interact with the
   specified server, such an initial interaction is vulnerable to
   various attacks (see Section 5.3 of [<a href="#ref-ForceHTTPS">ForceHTTPS</a>]).

   NOTE:  There are various features/facilities that UA implementations
          may employ in order to mitigate this vulnerability.  Please
          see <a href="#section-12">Section 12</a> ("User Agent Implementation Advice").



<span class="grey">Hodges, et al.               Standards Track                   [Page 36]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-37" id="page-37" name="page-37"> </a>
<span class="grey"><a href="rfc6797.html">RFC 6797</a>          HTTP Strict Transport Security (HSTS)    November 2012</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/14.7.%20%20Network%20Time%20Attacks"></a><a class="selflink" href="#section-14.7" name="section-14.7">14.7</a>.  Network Time Attacks</span>

   Active network attacks can subvert network time protocols (such as
   the Network Time Protocol (NTP) [<a href="rfc5905.html" title='"Network Time Protocol Version 4: Protocol and Algorithms Specification"'>RFC5905</a>]) -- making HSTS less
   effective against clients that trust NTP or lack a real time clock.
   Network time attacks are beyond the scope of this specification.
   Note that modern operating systems use NTP by default.  See also
   <a href="rfc4732.html#section-2.10">Section 2.10 of [RFC4732]</a>.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/14.8.%20%20Bogus%20Root%20CA%20Certificate%20Phish%20plus%20DNS%20Cache%20Poisoning%20Attack"></a><a class="selflink" href="#section-14.8" name="section-14.8">14.8</a>.  Bogus Root CA Certificate Phish plus DNS Cache Poisoning Attack</span>

   An attacker could conceivably obtain users' login credentials
   belonging to a victim HSTS-protected web application via a bogus root
   CA certificate phish plus DNS cache poisoning attack.

   For example, the attacker could first convince users of a victim web
   application (which is protected by HSTS Policy) to install the
   attacker's version of a root CA certificate purporting (falsely) to
   represent the CA of the victim web application.  This might be
   accomplished by sending the users a phishing email message with a
   link to such a certificate, which their browsers may offer to install
   if clicked on.

   Then, if the attacker can perform an attack on the users' DNS
   servers, (e.g., via cache poisoning) and turn on HSTS Policy for
   their fake web application, the affected users' browsers would access
   the attacker's web application rather than the legitimate web
   application.

   This type of attack leverages vectors that are outside of the scope
   of HSTS.  However, the feasibility of such threats can be mitigated
   by including in a web application's overall deployment approach
   appropriate employment, in addition to HSTS, of security facilities
   such as DNS Security Extensions [<a href="rfc4033.html" title='"DNS Security Introduction and Requirements"'>RFC4033</a>], plus techniques to block
   email phishing and fake certificate injection.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/14.9.%20%20Creative%20Manipulation%20of%20HSTS%20Policy%20Store"></a><a class="selflink" href="#section-14.9" name="section-14.9">14.9</a>.  Creative Manipulation of HSTS Policy Store</span>

   Since an HSTS Host may select its own host name and subdomains
   thereof, and this information is cached in the HSTS Policy store of
   conforming UAs, it is possible for those who control one or more HSTS
   Hosts to encode information into domain names they control and cause
   such UAs to cache this information as a matter of course in the
   process of noting the HSTS Host.  This information can be retrieved
   by other hosts through cleverly constructed and loaded web resources,
   causing the UA to send queries to (variations of) the encoded domain
   names.  Such queries can reveal whether the UA had previously visited
   the original HSTS Host (and subdomains).



<span class="grey">Hodges, et al.               Standards Track                   [Page 37]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-38" id="page-38" name="page-38"> </a>
<span class="grey"><a href="rfc6797.html">RFC 6797</a>          HTTP Strict Transport Security (HSTS)    November 2012</span>


   Such a technique could potentially be abused as yet another form of
   "web tracking" [<a href="#ref-WebTracking">WebTracking</a>].

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/14.10.%20%20Internationalized%20Domain%20Names"></a><a class="selflink" href="#section-14.10" name="section-14.10">14.10</a>.  Internationalized Domain Names</span>

   Internet security relies in part on the DNS and the domain names it
   hosts.  Domain names are used by users to identify and connect to
   Internet hosts and other network resources.  For example, Internet
   security is compromised if a user entering an internationalized
   domain name (IDN) is connected to different hosts based on different
   interpretations of the IDN.

   The processing models specified in this specification assume that the
   domain names they manipulate are IDNA-canonicalized, and that the
   canonicalization process correctly performed all appropriate IDNA and
   Unicode validations and character list testing per the requisite
   specifications (e.g., as noted in <a href="#section-10">Section 10</a> ("Domain Name IDNA-
   Canonicalization")).  These steps are necessary in order to avoid
   various potentially compromising situations.

   In brief, examples of issues that could stem from lack of careful and
   consistent Unicode and IDNA validations include unexpected processing
   exceptions, truncation errors, and buffer overflows, as well as
   false-positive and/or false-negative domain name matching results.
   Any of the foregoing issues could possibly be leveraged by attackers
   in various ways.

   Additionally, IDNA2008 [<a href="rfc5890.html" title='"Internationalized Domain Names for Applications (IDNA): Definitions and Document Framework"'>RFC5890</a>] differs from IDNA2003 [<a href="rfc3490.html" title='"Internationalizing Domain Names in Applications (IDNA)"'>RFC3490</a>] in
   terms of disallowed characters and character mapping conventions.
   This situation can also lead to false-positive and/or false-negative
   domain name matching results, resulting in, for example, users
   possibly communicating with unintended hosts or not being able to
   reach intended hosts.

   For details, refer to the Security Considerations sections of
   [<a href="rfc5890.html" title='"Internationalized Domain Names for Applications (IDNA): Definitions and Document Framework"'>RFC5890</a>], [<a href="rfc5891.html" title='"Internationalized Domain Names in Applications (IDNA): Protocol"'>RFC5891</a>], and [<a href="rfc3490.html" title='"Internationalizing Domain Names in Applications (IDNA)"'>RFC3490</a>], as well as the specifications
   they normatively reference.  Additionally, [<a href="rfc5894.html" title='"Internationalized Domain Names for Applications (IDNA): Background, Explanation, and Rationale"'>RFC5894</a>] provides
   detailed background and rationale for IDNA2008 in particular, as well
   as IDNA and its issues in general, and should be consulted in
   conjunction with the former specifications.











<span class="grey">Hodges, et al.               Standards Track                   [Page 38]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-39" id="page-39" name="page-39"> </a>
<span class="grey"><a href="rfc6797.html">RFC 6797</a>          HTTP Strict Transport Security (HSTS)    November 2012</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/15.%20%20IANA%20Considerations"></a><a class="selflink" href="#section-15" name="section-15">15</a>.  IANA Considerations</span>

   Below is the Internet Assigned Numbers Authority (IANA) Permanent
   Message Header Field registration information per [<a href="rfc3864.html" title='"Registration Procedures for Message Header Fields"'>RFC3864</a>].

     Header field name:           Strict-Transport-Security
     Applicable protocol:         http
     Status:                      standard
     Author/Change controller:    IETF
     Specification document(s):   this one

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/16.%20%20References"></a><a class="selflink" href="#section-16" name="section-16">16</a>.  References</span>

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/16.1.%20%20Normative%20References"></a><a class="selflink" href="#section-16.1" name="section-16.1">16.1</a>.  Normative References</span>

   [<a id="ref-RFC2119" name="ref-RFC2119">RFC2119</a>]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", <a href="https://tools.ietf.org/html/bcp14">BCP 14</a>, <a href="rfc2119.html">RFC 2119</a>, March 1997.

   [<a id="ref-RFC2616" name="ref-RFC2616">RFC2616</a>]  Fielding, R., Gettys, J., Mogul, J., Frystyk, H.,
              Masinter, L., Leach, P., and T. Berners-Lee, "Hypertext
              Transfer Protocol -- HTTP/1.1", <a href="rfc2616.html">RFC 2616</a>, June 1999.

   [<a id="ref-RFC2818" name="ref-RFC2818">RFC2818</a>]  Rescorla, E., "HTTP Over TLS", <a href="rfc2818.html">RFC 2818</a>, May 2000.

   [<a id="ref-RFC3490" name="ref-RFC3490">RFC3490</a>]  Faltstrom, P., Hoffman, P., and A. Costello,
              "Internationalizing Domain Names in Applications (IDNA)",
              <a href="rfc3490.html">RFC 3490</a>, March 2003.

   [<a id="ref-RFC3864" name="ref-RFC3864">RFC3864</a>]  Klyne, G., Nottingham, M., and J. Mogul, "Registration
              Procedures for Message Header Fields", <a href="https://tools.ietf.org/html/bcp90">BCP 90</a>, <a href="rfc3864.html">RFC 3864</a>,
              September 2004.

   [<a id="ref-RFC3986" name="ref-RFC3986">RFC3986</a>]  Berners-Lee, T., Fielding, R., and L. Masinter, "Uniform
              Resource Identifier (URI): Generic Syntax", STD 66,
              <a href="rfc3986.html">RFC 3986</a>, January 2005.

   [<a id="ref-RFC5246" name="ref-RFC5246">RFC5246</a>]  Dierks, T. and E. Rescorla, "The Transport Layer Security
              (TLS) Protocol Version 1.2", <a href="rfc5246.html">RFC 5246</a>, August 2008.

   [<a id="ref-RFC5890" name="ref-RFC5890">RFC5890</a>]  Klensin, J., "Internationalized Domain Names for
              Applications (IDNA): Definitions and Document Framework",
              <a href="rfc5890.html">RFC 5890</a>, August 2010.

   [<a id="ref-RFC5891" name="ref-RFC5891">RFC5891</a>]  Klensin, J., "Internationalized Domain Names in
              Applications (IDNA): Protocol", <a href="rfc5891.html">RFC 5891</a>, August 2010.






<span class="grey">Hodges, et al.               Standards Track                   [Page 39]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-40" id="page-40" name="page-40"> </a>
<span class="grey"><a href="rfc6797.html">RFC 6797</a>          HTTP Strict Transport Security (HSTS)    November 2012</span>


   [<a id="ref-RFC5895" name="ref-RFC5895">RFC5895</a>]  Resnick, P. and P. Hoffman, "Mapping Characters for
              Internationalized Domain Names in Applications
              (IDNA) 2008", <a href="rfc5895.html">RFC 5895</a>, September 2010.

   [<a id="ref-RFC6698" name="ref-RFC6698">RFC6698</a>]  Hoffman, P. and J. Schlyter, "The DNS-Based Authentication
              of Named Entities (DANE) Transport Layer Security (TLS)
              Protocol: TLSA", <a href="rfc6698.html">RFC 6698</a>, August 2012.

   [<a id="ref-UTS46" name="ref-UTS46">UTS46</a>]    Davis, M. and M. Suignard, "Unicode IDNA Compatibility
              Processing", Unicode Technical Standard #46,
              &lt;<a href="http://unicode.org/reports/tr46/">http://unicode.org/reports/tr46/</a>&gt;.

   [<a id="ref-Unicode" name="ref-Unicode">Unicode</a>]  The Unicode Consortium, "The Unicode Standard",
              &lt;<a href="http://www.unicode.org/versions/latest/">http://www.unicode.org/versions/latest/</a>&gt;.

   [<a id="ref-W3C.REC-html401-19991224" name="ref-W3C.REC-html401-19991224">W3C.REC-html401-19991224</a>]
              Raggett, D., Le Hors, A., and I. Jacobs, "HTML 4.01
              Specification", World Wide Web Consortium Recommendation
              REC-html401-19991224, December 1999,
              &lt;<a href="http://www.w3.org/TR/1999/REC-html401-19991224/">http://www.w3.org/TR/1999/REC-html401-19991224/</a>&gt;.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/16.2.%20%20Informative%20References"></a><a class="selflink" href="#section-16.2" name="section-16.2">16.2</a>.  Informative References</span>

   [<a id="ref-Aircrack-ng" name="ref-Aircrack-ng">Aircrack-ng</a>]
              d'Otreppe, T., "Aircrack-ng", Accessed: 11-Jul-2010,
              &lt;<a href="http://www.aircrack-ng.org/">http://www.aircrack-ng.org/</a>&gt;.

   [<a id="ref-BeckTews09" name="ref-BeckTews09">BeckTews09</a>]
              Beck, M. and E. Tews, "Practical Attacks Against WEP and
              WPA", Second ACM Conference on Wireless Network
              Security Zurich, Switzerland, 2009,
              &lt;<a href="http://dl.acm.org/citation.cfm?id=1514286">http://dl.acm.org/citation.cfm?id=1514286</a>&gt;.

   [<a id="ref-CWE-113" name="ref-CWE-113">CWE-113</a>]  "CWE-113: Improper Neutralization of CRLF Sequences in
              HTTP Headers ('HTTP Response Splitting')", Common Weakness
              Enumeration &lt;<a href="http://cwe.mitre.org/">http://cwe.mitre.org/</a>&gt;, The Mitre
              Corporation &lt;<a href="http://www.mitre.org/">http://www.mitre.org/</a>&gt;,
              &lt;<a href="http://cwe.mitre.org/data/definitions/113.html">http://cwe.mitre.org/data/definitions/113.html</a>&gt;.

   [<a id="ref-Firesheep" name="ref-Firesheep">Firesheep</a>]
              Various, "Firesheep", Wikipedia Online, ongoing, &lt;<a href="https://secure.wikimedia.org/wikipedia/en/w/index.php?title=Firesheep&amp;oldid=517474182">https://</a>
              <a href="https://secure.wikimedia.org/wikipedia/en/w/index.php?title=Firesheep&amp;oldid=517474182">secure.wikimedia.org/wikipedia/en/w/</a>
              <a href="https://secure.wikimedia.org/wikipedia/en/w/index.php?title=Firesheep&amp;oldid=517474182">index.php?title=Firesheep&amp;oldid=517474182</a>&gt;.








<span class="grey">Hodges, et al.               Standards Track                   [Page 40]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-41" id="page-41" name="page-41"> </a>
<span class="grey"><a href="rfc6797.html">RFC 6797</a>          HTTP Strict Transport Security (HSTS)    November 2012</span>


   [<a id="ref-ForceHTTPS" name="ref-ForceHTTPS">ForceHTTPS</a>]
              Jackson, C. and A. Barth, "ForceHTTPS:  Protecting High-
              Security Web Sites from Network Attacks", In Proceedings
              of the 17th International World Wide Web Conference
              (WWW2008) , 2008,
              &lt;<a href="https://crypto.stanford.edu/forcehttps/">https://crypto.stanford.edu/forcehttps/</a>&gt;.

   [<a id="ref-GoodDhamijaEtAl05" name="ref-GoodDhamijaEtAl05">GoodDhamijaEtAl05</a>]
              Good, N., Dhamija, R., Grossklags, J., Thaw, D.,
              Aronowitz, S., Mulligan, D., and J. Konstan, "Stopping
              Spyware at the Gate: A User Study of Privacy, Notice and
              Spyware", In Proceedings of Symposium On Usable Privacy
              and Security (SOUPS) Pittsburgh, PA, USA, July 2005,
              &lt;<a href="http://www.law.berkeley.edu/files/Spyware_at_the_Gate.pdf">http://www.law.berkeley.edu/files/</a>
              <a href="http://www.law.berkeley.edu/files/Spyware_at_the_Gate.pdf">Spyware_at_the_Gate.pdf</a>&gt;.

   [<a id="ref-HTTP1_1-UPD" name="ref-HTTP1_1-UPD">HTTP1_1-UPD</a>]
              Fielding, R., Ed., and J. Reschke, Ed., "Hypertext
              Transfer Protocol (HTTP/1.1): Message Syntax and Routing",
              Work in Progress, October 2012.

   [<a id="ref-JacksonBarth2008" name="ref-JacksonBarth2008">JacksonBarth2008</a>]
              Jackson, C. and A. Barth, "Beware of Finer-Grained
              Origins", Web 2.0 Security and Privacy Workshop, Oakland,
              CA, USA, 2008,
              &lt;<a href="http://seclab.stanford.edu/websec/origins/fgo.pdf">http://seclab.stanford.edu/websec/origins/fgo.pdf</a>&gt;.

   [<a id="ref-OWASP-TLSGuide" name="ref-OWASP-TLSGuide">OWASP-TLSGuide</a>]
              Coates, M., Wichers, D., Boberski, M., and T. Reguly,
              "Transport Layer Protection Cheat Sheet",
              Accessed: 11-Jul-2010, &lt;<a href="http://www.owasp.org/index.php/Transport_Layer_Protection_Cheat_Sheet">http://www.owasp.org/index.php/</a>
              <a href="http://www.owasp.org/index.php/Transport_Layer_Protection_Cheat_Sheet">Transport_Layer_Protection_Cheat_Sheet</a>&gt;.

   [<a id="ref-RFC1035" name="ref-RFC1035">RFC1035</a>]  Mockapetris, P., "Domain names - implementation and
              specification", STD 13, <a href="rfc1035.html">RFC 1035</a>, November 1987.

   [<a id="ref-RFC2560" name="ref-RFC2560">RFC2560</a>]  Myers, M., Ankney, R., Malpani, A., Galperin, S., and C.
              Adams, "X.509 Internet Public Key Infrastructure Online
              Certificate Status Protocol - OCSP", <a href="rfc2560.html">RFC 2560</a>, June 1999.

   [<a id="ref-RFC4033" name="ref-RFC4033">RFC4033</a>]  Arends, R., Austein, R., Larson, M., Massey, D., and S.
              Rose, "DNS Security Introduction and Requirements",
              <a href="rfc4033.html">RFC 4033</a>, March 2005.

   [<a id="ref-RFC4732" name="ref-RFC4732">RFC4732</a>]  Handley, M., Rescorla, E., and IAB, "Internet Denial-of-
              Service Considerations", <a href="rfc4732.html">RFC 4732</a>, December 2006.





<span class="grey">Hodges, et al.               Standards Track                   [Page 41]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-42" id="page-42" name="page-42"> </a>
<span class="grey"><a href="rfc6797.html">RFC 6797</a>          HTTP Strict Transport Security (HSTS)    November 2012</span>


   [<a id="ref-RFC4949" name="ref-RFC4949">RFC4949</a>]  Shirey, R., "Internet Security Glossary, Version 2",
              <a href="rfc4949.html">RFC 4949</a>, August 2007.

   [<a id="ref-RFC5226" name="ref-RFC5226">RFC5226</a>]  Narten, T. and H. Alvestrand, "Guidelines for Writing an
              IANA Considerations Section in RFCs", <a href="https://tools.ietf.org/html/bcp26">BCP 26</a>, <a href="rfc5226.html">RFC 5226</a>,
              May 2008.

   [<a id="ref-RFC5280" name="ref-RFC5280">RFC5280</a>]  Cooper, D., Santesson, S., Farrell, S., Boeyen, S.,
              Housley, R., and W. Polk, "Internet X.509 Public Key
              Infrastructure Certificate and Certificate Revocation List
              (CRL) Profile", <a href="rfc5280.html">RFC 5280</a>, May 2008.

   [<a id="ref-RFC5894" name="ref-RFC5894">RFC5894</a>]  Klensin, J., "Internationalized Domain Names for
              Applications (IDNA): Background, Explanation, and
              Rationale", <a href="rfc5894.html">RFC 5894</a>, August 2010.

   [<a id="ref-RFC5905" name="ref-RFC5905">RFC5905</a>]  Mills, D., Martin, J., Burbank, J., and W. Kasch, "Network
              Time Protocol Version 4: Protocol and Algorithms
              Specification", <a href="rfc5905.html">RFC 5905</a>, June 2010.

   [<a id="ref-RFC6066" name="ref-RFC6066">RFC6066</a>]  Eastlake, D., "Transport Layer Security (TLS) Extensions:
              Extension Definitions", <a href="rfc6066.html">RFC 6066</a>, January 2011.

   [<a id="ref-RFC6101" name="ref-RFC6101">RFC6101</a>]  Freier, A., Karlton, P., and P. Kocher, "The Secure
              Sockets Layer (SSL) Protocol Version 3.0", <a href="rfc6101.html">RFC 6101</a>,
              August 2011.

   [<a id="ref-RFC6125" name="ref-RFC6125">RFC6125</a>]  Saint-Andre, P. and J. Hodges, "Representation and
              Verification of Domain-Based Application Service Identity
              within Internet Public Key Infrastructure Using X.509
              (PKIX) Certificates in the Context of Transport Layer
              Security (TLS)", <a href="rfc6125.html">RFC 6125</a>, March 2011.

   [<a id="ref-RFC6265" name="ref-RFC6265">RFC6265</a>]  Barth, A., "HTTP State Management Mechanism", <a href="rfc6265.html">RFC 6265</a>,
              April 2011.

   [<a id="ref-RFC6454" name="ref-RFC6454">RFC6454</a>]  Barth, A., "The Web Origin Concept", <a href="rfc6454.html">RFC 6454</a>,
              December 2011.

   [<a id="ref-SunshineEgelmanEtAl09" name="ref-SunshineEgelmanEtAl09">SunshineEgelmanEtAl09</a>]
              Sunshine, J., Egelman, S., Almuhimedi, H., Atri, N., and
              L. Cranor, "Crying Wolf: An Empirical Study of SSL Warning
              Effectiveness", In Proceedings of 18th USENIX Security
              Symposium Montreal, Canada, August 2009, &lt;<a href="http://www.usenix.org/events/sec09/tech/full_papers/sunshine.pdf">http://</a>
              <a href="http://www.usenix.org/events/sec09/tech/full_papers/sunshine.pdf">www.usenix.org/events/sec09/tech/full_papers/</a>
              <a href="http://www.usenix.org/events/sec09/tech/full_papers/sunshine.pdf">sunshine.pdf</a>&gt;.





<span class="grey">Hodges, et al.               Standards Track                   [Page 42]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-43" id="page-43" name="page-43"> </a>
<span class="grey"><a href="rfc6797.html">RFC 6797</a>          HTTP Strict Transport Security (HSTS)    November 2012</span>


   [<a id="ref-W3C.REC-wsc-ui-20100812" name="ref-W3C.REC-wsc-ui-20100812">W3C.REC-wsc-ui-20100812</a>]
              Roessler, T. and A. Saldhana, "Web Security Context: User
              Interface Guidelines", World Wide Web Consortium
              Recommendation REC-wsc-ui-20100812, August 2010,
              &lt;<a href="http://www.w3.org/TR/2010/REC-wsc-ui-20100812">http://www.w3.org/TR/2010/REC-wsc-ui-20100812</a>&gt;.

   [<a id="ref-WebTracking" name="ref-WebTracking">WebTracking</a>]
              Schmucker, N., "Web Tracking", SNET2 Seminar Paper
              - Summer Term, 2011, &lt;<a href="http://www.snet.tu-berlin.de/fileadmin/fg220/courses/SS11/snet-project/web-tracking_schmuecker.pdf">http://www.snet.tu-berlin.de/</a>
              <a href="http://www.snet.tu-berlin.de/fileadmin/fg220/courses/SS11/snet-project/web-tracking_schmuecker.pdf">fileadmin/fg220/courses/SS11/snet-project/</a>
              <a href="http://www.snet.tu-berlin.de/fileadmin/fg220/courses/SS11/snet-project/web-tracking_schmuecker.pdf">web-tracking_schmuecker.pdf</a>&gt;.








































<span class="grey">Hodges, et al.               Standards Track                   [Page 43]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-44" id="page-44" name="page-44"> </a>
<span class="grey"><a href="rfc6797.html">RFC 6797</a>          HTTP Strict Transport Security (HSTS)    November 2012</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/Appendix%20A.%20%20Design%20Decision%20Notes"></a><a class="selflink" href="#appendix-A" name="appendix-A">Appendix A</a>.  Design Decision Notes</span>

   This appendix documents various design decisions.

   1.  Cookies aren't appropriate for HSTS Policy expression, as they
       are potentially mutable (while stored in the UA); therefore, an
       HTTP header field is employed.

   2.  We chose to not attempt to specify how "mixed security context
       loads" (also known as "mixed content loads") are handled, due to
       UA implementation considerations as well as classification
       difficulties.

   3.  An HSTS Host may update UA notions of HSTS Policy via new HSTS
       header field parameter values.  We chose to have UAs honor the
       "freshest" information received from a server because there is
       the chance of a web site sending out an erroneous HSTS Policy,
       such as a multi-year max-age value, and/or an incorrect
       includeSubDomains directive.  If the HSTS Host couldn't correct
       such errors over protocol, it would require some form of
       annunciation to users and manual intervention on the users' part,
       which could be a non-trivial problem for both web application
       providers and their users.

   4.  HSTS Hosts are identified only via domain names -- explicit IP
       address identification of all forms is excluded.  This is for
       simplification and also is in recognition of various issues with
       using direct IP address identification in concert with PKI-based
       security.

   5.  The max-age approach of having the HSTS Host provide a simple
       integer number of seconds for a cached HSTS Policy time-to-live
       value, as opposed to an approach of stating an expiration time in
       the future, was chosen for various reasons.  Amongst the reasons
       are no need for clock synchronization, no need to define date and
       time value syntaxes (specification simplicity), and
       implementation simplicity.

   6.  In determining whether port mapping was to be employed, the
       option of merely refusing to dereference any URL with an explicit
       port was considered.  It was felt, though, that the possibility
       that the URI to be dereferenced is incorrect (and there is indeed
       a valid HTTPS server at that port) is worth the small cost of
       possibly wasted HTTPS fetches to HTTP servers.







<span class="grey">Hodges, et al.               Standards Track                   [Page 44]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-45" id="page-45" name="page-45"> </a>
<span class="grey"><a href="rfc6797.html">RFC 6797</a>          HTTP Strict Transport Security (HSTS)    November 2012</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/Appendix%20B.%20%20Differences%20between%20HSTS%20Policy%20and%20Same-Origin%20Policy"></a><a class="selflink" href="#appendix-B" name="appendix-B">Appendix B</a>.  Differences between HSTS Policy and Same-Origin Policy</span>

   HSTS Policy has the following primary characteristics:

      HSTS Policy stipulates requirements for the security
      characteristics of UA-to-host connection establishment, on a
      per-host basis.

      Hosts explicitly declare HSTS Policy to UAs.  Conformant UAs are
      obliged to implement hosts' declared HSTS Policies.

      HSTS Policy is conveyed over protocol from the host to the UA.

      The UA maintains a cache of Known HSTS Hosts.

      UAs apply HSTS Policy whenever making an HTTP connection to a
      Known HSTS Host, regardless of host port number; i.e., it applies
      to all ports on a Known HSTS Host.  Hosts are unable to affect
      this aspect of HSTS Policy.

      Hosts may optionally declare that their HSTS Policy applies to all
      subdomains of their host domain name.

   In contrast, the Same-Origin Policy (SOP) [<a href="rfc6454.html" title='"The Web Origin Concept"'>RFC6454</a>] has the following
   primary characteristics:

      An origin is the scheme, host, and port of a URI identifying a
      resource.

      A UA may dereference a URI, thus loading a representation of the
      resource the URI identifies.  UAs label resource representations
      with their origins, which are derived from their URIs.

      The SOP refers to a collection of principles, implemented within
      UAs, governing the isolation of and communication between resource
      representations within the UA, as well as resource
      representations' access to network resources.

   In summary, although both HSTS Policy and SOP are enforced by UAs,
   HSTS Policy is optionally declared by hosts and is not origin-based,
   while the SOP applies to all resource representations loaded from all
   hosts by conformant UAs.









<span class="grey">Hodges, et al.               Standards Track                   [Page 45]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-46" id="page-46" name="page-46"> </a>
<span class="grey"><a href="rfc6797.html">RFC 6797</a>          HTTP Strict Transport Security (HSTS)    November 2012</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/Appendix%20C.%20%20Acknowledgments"></a><a class="selflink" href="#appendix-C" name="appendix-C">Appendix C</a>.  Acknowledgments</span>

   The authors thank Devdatta Akhawe, Michael Barrett, Ben Campbell,
   Tobias Gondrom, Paul Hoffman, Murray Kucherawy, Barry Leiba, James
   Manger, Alexey Melnikov, Haevard Molland, Yoav Nir, Yngve N.
   Pettersen, Laksh Raghavan, Marsh Ray, Julian Reschke, Eric Rescorla,
   Tom Ritter, Peter Saint-Andre, Brian Smith, Robert Sparks, Maciej
   Stachowiak, Sid Stamm, Andy Steingrubl, Brandon Sterne, Martin
   Thomson, Daniel Veditz, and Jan Wrobel, as well as all the websec
   working group participants and others for their various reviews and
   helpful contributions.

   Thanks to Julian Reschke for his elegant rewriting of the effective
   request URI text, which he did when incorporating the ERU notion into
   the updates to HTTP/1.1 [<a href="#ref-HTTP1_1-UPD">HTTP1_1-UPD</a>].  Subsequently, the ERU text in
   this spec was lifted from Julian's work in the updated HTTP/1.1
   (part 1) specification and adapted to the [<a href="rfc2616.html" title='"Hypertext Transfer Protocol -- HTTP/1.1"'>RFC2616</a>] ABNF.

Authors' Addresses

   Jeff Hodges
   PayPal
   2211 North First Street
   San Jose, California  95131
   US

   EMail: Jeff.Hodges@PayPal.com


   Collin Jackson
   Carnegie Mellon University

   EMail: collin.jackson@sv.cmu.edu


   Adam Barth
   Google, Inc.

   EMail: ietf@adambarth.com
   URI:   <a href="http://www.adambarth.com/">http://www.adambarth.com/</a>











Hodges, et al.               Standards Track                   [Page 46]

</pre><br/>
    <span class="noprint"><small><small>Html markup produced by rfcmarkup 1.126, available from
      <a href="https://tools.ietf.org/tools/rfcmarkup/">https://tools.ietf.org/tools/rfcmarkup/</a>
    </small></small></span>
  </div>




</body><!-- Mirrored from tools.ietf.org/html/rfc6797 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 06 Mar 2018 23:18:27 GMT --></html>