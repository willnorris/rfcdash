<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml"><!-- Mirrored from tools.ietf.org/html/rfc3338 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 28 Apr 2015 16:02:16 GMT --><!-- Added by HTTrack --><head><meta content="text/html;charset=utf-8" http-equiv="content-type"/><!-- /Added by HTTrack -->

    <meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
    <meta content="index,follow" name="robots"/>
    <meta content="rfcmarkup version 1.111" name="creator"/>
    <link href="http://purl.org/dc/elements/1.1/" rel="schema.DC"/>
<meta content="urn:ietf:rfc:3338" name="DC.Identifier"/>
<meta content="Durand, Alain" name="DC.Creator"/>
<meta content="Nordmark, Erik" name="DC.Creator"/>
<meta content="Lee, Seungyun" name="DC.Creator"/>
<meta content="October, 2002" name="DC.Date.Issued"/>
<meta content='Dual Stack Hosts Using "Bump-in-the-API" (BIA)' name="DC.Title"/>

    <link href="http://tools.ietf.org/images/rfc.png" rel="icon" type="image/png"/>
    <link href="http://tools.ietf.org/images/rfc.png" rel="shortcut icon" type="image/png"/>
    <title>RFC 3338 - Dual Stack Hosts Using "Bump-in-the-API" (BIA)</title>
    
    
    <style type="text/css">
	body {
	    margin: 0px 8px;
            font-size: 1em;
	}
        h1, h2, h3, h4, h5, h6, .h1, .h2, .h3, .h4, .h5, .h6 {
	    font-weight: bold;
            line-height: 0pt;
            display: inline;
            white-space: pre;
            font-family: monospace;
            font-size: 1em;
	    font-weight: bold;
        }
        pre {
            font-size: 1em;
            margin-top: 0px;
            margin-bottom: 0px;
        }
	.pre {
	    white-space: pre;
	    font-family: monospace;
	}
	.header{
	    font-weight: bold;
	}
        .newpage {
            page-break-before: always;
        }
        .invisible {
            text-decoration: none;
            color: white;
        }
        a.selflink {
          color: black;
          text-decoration: none;
        }
        @media print {
            body {
                font-family: monospace;
                font-size: 10.5pt;
            }
            h1, h2, h3, h4, h5, h6 {
                font-size: 1em;
            }
        
            a:link, a:visited {
                color: inherit;
                text-decoration: none;
            }
            .noprint {
                display: none;
            }
        }
	@media screen {
	    .grey, .grey a:link, .grey a:visited {
		color: #777;
	    }
            .docinfo {
                background-color: #EEE;
            }
            .top {
                border-top: 7px solid #EEE;
            }
            .bgwhite  { background-color: white; }
            .bgred    { background-color: #F44; }
            .bggrey   { background-color: #666; }
            .bgbrown  { background-color: #840; }            
            .bgorange { background-color: #FA0; }
            .bgyellow { background-color: #EE0; }
            .bgmagenta{ background-color: #F4F; }
            .bgblue   { background-color: #66F; }
            .bgcyan   { background-color: #4DD; }
            .bggreen  { background-color: #4F4; }

            .legend   { font-size: 90%; }
            .cplate   { font-size: 70%; border: solid grey 1px; }
	}
    </style>
    <!--[if IE]>
    <style>
    body {
       font-size: 13px;
       margin: 10px 10px;
    }
    </style>
    <![endif]-->

    <script type="text/javascript"><!--
    function addHeaderTags() {
	var spans = document.getElementsByTagName("span");
	for (var i=0; i < spans.length; i++) {
	    var elem = spans[i];
	    if (elem) {
		var level = elem.getAttribute("class");
                if (level == "h1" || level == "h2" || level == "h3" || level == "h4" || level == "h5" || level == "h6") {
                    elem.innerHTML = "<"+level+">"+elem.innerHTML+"</"+level+">";		
                }
	    }
	}
    }
    var legend_html = "Colour legend:<br />      <table>         <tr><td>Unknown:</td>                   <td><span class='cplate bgwhite'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft:</td>                     <td><span class='cplate bgred'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Informational:</td>             <td><span class='cplate bgorange'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Experimental:</td>              <td><span class='cplate bgyellow'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Best Common Practice:</td>      <td><span class='cplate bgmagenta'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Proposed Standard:</td>         <td><span class='cplate bgblue'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft Standard (old designation):</td> <td><span class='cplate bgcyan'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Internet Standard:</td>         <td><span class='cplate bggreen'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Historic:</td>                  <td><span class='cplate bggrey'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Obsolete:</td>                  <td><span class='cplate bgbrown'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>     </table>";
    function showElem(id) {
        var elem = document.getElementById(id);
        elem.innerHTML = eval(id+"_html");
        elem.style.visibility='visible';
    }
    function hideElem(id) {
        var elem = document.getElementById(id);
        elem.style.visibility='hidden';        
        elem.innerHTML = "";
    }
    // -->
    </script>
</head>
<body onload="addHeaderTags()">
   <div style="height: 13px;">
      <div class="pre noprint docinfo bgbrown" onclick="showElem('legend');" onmouseout="hideElem('legend')" onmouseover="this.style.cursor='pointer';" style="height: 6px; position: absolute;" title="Click for colour legend.">                                                                        </div>
      <div class="docinfo noprint pre legend" id="legend" onmouseout="hideElem('legend');" onmouseover="showElem('legend');" style="position:absolute; top: 4px; left: 4ex; visibility:hidden; background-color: white; padding: 4px 9px 5px 7px; border: solid #345 1px; ">
      </div>
   </div>
<span class="pre noprint docinfo top">[<a href="index.html" title="Document search and retrieval page">Docs</a>] [<a href="http://tools.ietf.org/rfc/rfc3338.txt" title="Plaintext version of this document">txt</a>|<a href="http://tools.ietf.org/pdf/rfc3338" title="PDF version of this document">pdf</a>] [<a href="http://tools.ietf.org/html/draft-ietf-ngtrans-bia" title="draft-ietf-ngtrans-bia">draft-ietf-ngtran...</a>] [<a href="http://tools.ietf.org/rfcdiff?difftype=--hwdiff&amp;url2=rfc3338" title="Inline diff (wdiff)">Diff1</a>] [<a href="http://tools.ietf.org/rfcdiff?url2=rfc3338" title="Side-by-side diff">Diff2</a>]                 </span><br/>
<span class="pre noprint docinfo">                                                                        </span><br/>
<span class="pre noprint docinfo">Obsoleted by: <a href="rfc6535.html">6535</a>                                          EXPERIMENTAL</span><br/>
<span class="pre noprint docinfo">                                                                        </span><br/>
<pre>Network Working Group                                             S. Lee
Request for Comments: 3338                                     M-K. Shin
Category: Experimental                                          Y-J. Kim
                                                                    ETRI
                                                             E. Nordmark
                                                               A. Durand
                                                        Sun Microsystems
                                                            October 2002


             <span class="h1">Dual Stack Hosts Using "Bump-in-the-API" (BIA)</span>

Status of this Memo

   This memo defines an Experimental Protocol for the Internet
   community.  It does not specify an Internet standard of any kind.
   Discussion and suggestions for improvement are requested.
   Distribution of this memo is unlimited.

Copyright Notice

   Copyright (C) The Internet Society (2002).  All Rights Reserved.

Abstract

   This document specifies a mechanism of dual stack hosts using a
   technique called "Bump-in-the-API"(BIA) which allows for the hosts to
   communicate with other IPv6 hosts using existing IPv4 applications.
   The goal of this mechanism is the same as that of the Bump-in-the-
   stack mechanism, but this mechanism provides the translation method
   between the IPv4 APIs and IPv6 APIs.  Thus, the goal is simply
   achieved without IP header translation.



















<span class="grey">Lee, et al.                   Experimental                      [Page 1]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-2" id="page-2" name="page-2"> </a>
<span class="grey"><a href="rfc3338.html">RFC 3338</a>               Dual Stack Hosts Using BIA           October 2002</span>


Table of Contents:

   <a href="#section-1">1</a>.  Introduction ................................................  <a href="#page-2">2</a>
   <a href="#section-2">2</a>.  Applicability and Disclaimer ................................  <a href="#page-3">3</a>
   <a href="#section-2.1">2.1</a> Applicability ...............................................  <a href="#page-3">3</a>
   <a href="#section-2.2">2.2</a> Disclaimer ..................................................  <a href="#page-4">4</a>
   <a href="#section-3">3</a>.  Dual Stack Host Architecture Using BIA ......................  <a href="#page-4">4</a>
   <a href="#section-3.1">3.1</a> Function Mapper .............................................  <a href="#page-4">4</a>
   <a href="#section-3.2">3.2</a> Name Resolver ...............................................  <a href="#page-5">5</a>
   <a href="#section-3.3">3.3</a> Address Mapper ..............................................  <a href="#page-5">5</a>
   <a href="#section-4">4</a>.  Behavior Example ............................................  <a href="#page-6">6</a>
   <a href="#section-4.1">4.1</a> Originator Behavior .........................................  <a href="#page-6">6</a>
   <a href="#section-4.2">4.2</a> Recipient Behavior ..........................................  <a href="#page-8">8</a>
   <a href="#section-5">5</a>.  Considerations  ............................................. <a href="#page-10">10</a>
   <a href="#section-5.1">5.1</a> Socket API Conversion ....................................... <a href="#page-10">10</a>
   <a href="#section-5.2">5.2</a> ICMP Messages Handling ...................................... <a href="#page-10">10</a>
   <a href="#section-5.3">5.3</a> IPv4 Address Pool and Mapping Table ......................... <a href="#page-10">10</a>
   <a href="#section-5.4">5.4</a> Internally Assigned IPv4 Addresses .......................... <a href="#page-10">10</a>
   <a href="#section-5.5">5.5</a> Mismatch Between DNS Result and Peer Application Version .... <a href="#page-11">11</a>
   <a href="#section-5.6">5.6</a> Implementation Issues ....................................... <a href="#page-11">11</a>
   <a href="#section-6">6</a>.  Limitations ................................................. <a href="#page-12">12</a>
   <a href="#section-7">7</a>.  Security Considerations ..................................... <a href="#page-12">12</a>
   <a href="#section-8">8</a>.  Acknowledgments ............................................. <a href="#page-12">12</a>
   <a href="#section-9">9</a>.  References .................................................. <a href="#page-12">12</a>
   Appendix:  API list intercepted by BIA .......................... <a href="#page-14">14</a>
   Authors Addresses ............................................... <a href="#page-16">16</a>
   Full Copyright Statement ........................................ <a href="#page-17">17</a>

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/1.%20Introduction"></a><a class="selflink" href="#section-1" name="section-1">1</a>. Introduction</span>

   <a href="rfc2767.html">RFC2767</a> [<a href="#ref-BIS" title='"Dual Stack Hosts using the "'>BIS</a>] specifies a host translation mechanism using a
   technique called "Bump-in-the-Stack".  It translates IPv4 into IPv6,
   and vice versa using the IP conversion mechanism defined in [<a href="#ref-SIIT" title='"Stateless IP/ICMP Translator (SIIT)"'>SIIT</a>].
   BIS allows hosts to communicate with other IPv6 hosts using existing
   IPv4 applications.  However, this approach is to use an API
   translator which is inserted between the TCP/IP module and network
   card driver, so that it has the same limitations as the [<a href="#ref-SIIT" title='"Stateless IP/ICMP Translator (SIIT)"'>SIIT</a>] based
   IP header translation methods.  In addition, its implementation is
   dependent upon the network interface driver.

   This document specifies a new mechanism of dual stack hosts called
   Bump-in-the-API(BIA) technique.  The BIA technique inserts an API
   translator between the socket API module and the TCP/IP module in the
   dual stack hosts, so that it translates the IPv4 socket API function
   into IPv6 socket API function and vice versa.  With this mechanism,
   the translation can be simplified without IP header translation.





<span class="grey">Lee, et al.                   Experimental                      [Page 2]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-3" id="page-3" name="page-3"> </a>
<span class="grey"><a href="rfc3338.html">RFC 3338</a>               Dual Stack Hosts Using BIA           October 2002</span>


   Using BIA, the dual stack host assumes that there exists both
   TCP(UDP)/IPv4 and TCP(UDP)/IPv6 stacks on the local node.

   When IPv4 applications on the dual stack communicate with other IPv6
   hosts, the API translator detects the socket API functions from IPv4
   applications and invokes the IPv6 socket API functions to communicate
   with the IPv6 hosts, and vice versa.  In order to support
   communication between IPv4 applications and the target IPv6 hosts,
   pooled IPv4 addresses will be assigned through the name resolver in
   the API translator.

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in [<a href="rfc2119.html">RFC 2119</a>].

   This document uses terms defined in [IPv6],[<a href="#ref-TRANS-MECH" title='"Transition Mechanisms for IPv6 Hosts and Routers"'>TRANS-MECH</a>] and [<a href="#ref-BIS" title='"Dual Stack Hosts using the "'>BIS</a>].

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/2.%20Applicability%20and%20Disclaimer"></a><a class="selflink" href="#section-2" name="section-2">2</a>. Applicability and Disclaimer</span>

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/2.1%20Applicability"></a><a class="selflink" href="#section-2.1" name="section-2.1">2.1</a> Applicability</span>

   The main purposes of BIA are the same as BIS [<a href="#ref-BIS" title='"Dual Stack Hosts using the "'>BIS</a>].  It makes IPv4
   applications communicate with IPv6 hosts without any modification of
   those IPv4 applications.  However, while BIS is for systems with no
   IPv6 stack, BIA is for systems with an IPv6 stack, but on which some
   applications are  not yet available on IPv6 and source code is not
   available preventing the application from being ported.  It's good
   for early adopters who do not have all applications handy, but not
   for mainstream production usage.

   There is an issue about a client node running BIA trying to contact a
   dual stack node on a port number that is only associated with an IPv4
   application (see <a href="#section-5.5">section 5.5</a>).  There are 2 approaches.

   - The client application SHOULD cycle through all the addresses and
     end up trying the IPv4 one.

   - BIA SHOULD do the work.

   It is not clear at this time which behavior is desirable (it may very
   well be application dependent), so we need to get feedback from
   experimentation.









<span class="grey">Lee, et al.                   Experimental                      [Page 3]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-4" id="page-4" name="page-4"> </a>
<span class="grey"><a href="rfc3338.html">RFC 3338</a>               Dual Stack Hosts Using BIA           October 2002</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/2.2%20Disclaimer"></a><a class="selflink" href="#section-2.2" name="section-2.2">2.2</a> Disclaimer</span>

   BIA SHOULD NOT be used for an IPv4 application for which source code
   is available.  We strongly recommend that application programmers
   SHOULD NOT use this mechanism when application source code is
   available.  As well, it SHOULD NOT be used as an excuse not to port
   software or delay porting.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/3.%20Dual%20Stack%20Host%20Architecture%20Using%20BIA"></a><a class="selflink" href="#section-3" name="section-3">3</a>. Dual Stack Host Architecture Using BIA</span>

   Figure 1 shows the architecture of the host in which BIA is
   installed.

               +----------------------------------------------+
               | +------------------------------------------+ |
               | |                                          | |
               | |             IPv4 applications            | |
               | |                                          | |
               | +------------------------------------------+ |
               | +------------------------------------------+ |
               | |           Socket API (IPv4, IPv6)        | |
               | +------------------------------------------+ |
               | +-[ API translator]------------------------+ |
               | | +-----------+ +---------+ +------------+ | |
               | | | Name      | | Address | | Function   | | |
               | | | Resolver  | | Mapper  | | Mapper     | | |
               | | +-----------+ +---------+ +------------+ | |
               | +------------------------------------------+ |
               | +--------------------+ +-------------------+ |
               | |                    | |                   | |
               | |    TCP(UDP)/IPv4   | |   TCP(UDP)/IPv6   | |
               | |                    | |                   | |
               | +--------------------+ +-------------------+ |
               +----------------------------------------------+

            Figure 1 Architecture of the dual stack host using BIA

   Dual stack hosts defined in <a href="rfc2893.html">RFC2893</a> [<a href="#ref-TRANS-MECH" title='"Transition Mechanisms for IPv6 Hosts and Routers"'>TRANS-MECH</a>] need applications,
   TCP/IP modules and addresses for both IPv4 and IPv6.  The proposed
   hosts in this document have an API translator to communicate with
   other IPv6 hosts using existing IPv4 applications.  The API
   translator consists of 3 modules, a name resolver, an address mapper
   and a function mapper.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.1%20Function%20Mapper"></a><a class="selflink" href="#section-3.1" name="section-3.1">3.1</a> Function Mapper</span>

   It translates an IPv4 socket API function into an IPv6 socket API
   function, and vice versa.



<span class="grey">Lee, et al.                   Experimental                      [Page 4]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-5" id="page-5" name="page-5"> </a>
<span class="grey"><a href="rfc3338.html">RFC 3338</a>               Dual Stack Hosts Using BIA           October 2002</span>


   When detecting the IPv4 socket API functions from IPv4 applications,
   it intercepts the function call and invokes new IPv6 socket API
   functions which correspond to the IPv4 socket API functions.  Those
   IPv6 API functions are used to communicate with the target IPv6
   hosts.  When detecting the IPv6 socket API functions from the data
   received from the IPv6 hosts, it works symmetrically in relation to
   the previous case.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.2%20Name%20Resolver"></a><a class="selflink" href="#section-3.2" name="section-3.2">3.2</a> Name Resolver</span>

   It returns a proper answer in response to the IPv4 application's
   request.

   When an IPv4 application tries to resolve names via the resolver
   library (e.g. gethostbyname()), BIA intercept the function call and
   instead call the IPv6 equivalent functions (e.g. getnameinfo()) that
   will resolve both A and AAAA records.

   If the AAAA record is available, it requests the address mapper to
   assign an IPv4 address corresponding to the IPv6 address, then
   creates the A record for the assigned IPv4 address, and returns the A
   record to the application.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.3%20Address%20Mapper"></a><a class="selflink" href="#section-3.3" name="section-3.3">3.3</a> Address Mapper</span>

   It internally maintains a table of the pairs of an IPv4 address and
   an IPv6 address.  The IPv4 addresses are assigned from an IPv4
   address pool.  It uses the unassigned IPv4 addresses
   (e.g., 0.0.0.1 ~ 0.0.0.255).

   When the name resolver or the function mapper requests it to assign
   an IPv4 address corresponding to an IPv6 address, it selects and
   returns an IPv4 address out of the pool, and registers a new entry
   into the table dynamically.  The registration occurs in the following
   2 cases:

   (1) When the name resolver gets only an 'AAAA' record for the target
       host name and there is not a mapping entry for the IPv6 address.

   (2) When the function mapper gets a socket API function call from the
       data received and there is not a mapping entry for the IPv6
       source address.

   NOTE: This is the same as that of the Address Mapper in [<a href="#ref-BIS" title='"Dual Stack Hosts using the "'>BIS</a>].







<span class="grey">Lee, et al.                   Experimental                      [Page 5]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-6" id="page-6" name="page-6"> </a>
<span class="grey"><a href="rfc3338.html">RFC 3338</a>               Dual Stack Hosts Using BIA           October 2002</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/4.%20Behavior%20Examples"></a><a class="selflink" href="#section-4" name="section-4">4</a>. Behavior Examples</span>

   This section describes behaviors of the proposed dual stack host
   called "dual stack", which communicates with an IPv6 host called
   "host6" using an IPv4 application.

   In this section, the meanings of arrows are as follows:

       ---&gt; A DNS message for name resolving created by the applications
            and the name resolver in the API translator.
       +++&gt; An IPv4 address request to and reply from the address mapper
            for the name resolver and the function mapper.
       ===&gt; Data flow by socket API functions created by the
            applications and the function mapper in the API translator.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.1%20Originator%20Behavior"></a><a class="selflink" href="#section-4.1" name="section-4.1">4.1</a> Originator Behavior</span>

   This sub-section describes the behavior when the "dual stack" sends
   data to "host6".

   When an IPv4 application sends a DNS query to its name server, the
   name resolver intercepts the query and then creates a new query to
   resolve both A and AAAA records.  When only the AAAA record is
   resolved, the name resolver requests the address mapper to assign an
   IPv4 address corresponding to the IPv6 address.

   The name resolver creates an A record for the assigned IPv4 address
   and returns it to the IPv4 applications.

   In order for the IPv4 application to send IPv4 packets to host6, it
   calls the IPv4 socket API function.

   The function mapper detects the socket API function from the
   application.  If the result is from IPv6 applications, it skips the
   translation.  In the case of IPv4 applications, it requires an IPv6
   address to invoke the IPv6 socket API function, thus the function
   mapper requests an IPv6 address to the address mapper.  The address
   mapper selects an IPv4 address from the table and returns the
   destination IPv6 address.  Using this IPv6 address, the function
   mapper invokes an IPv6 socket API function corresponding to the IPv4
   socket API function.

   When the function mapper receives an IPv6 function call,it requests
   the IPv4 address to the address mapper in order to translate the IPv6
   socket API function into an IPv4 socket API function.  Then, the
   function mapper invokes the socket API function for the IPv4
   applications.




<span class="grey">Lee, et al.                   Experimental                      [Page 6]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-7" id="page-7" name="page-7"> </a>
<span class="grey"><a href="rfc3338.html">RFC 3338</a>               Dual Stack Hosts Using BIA           October 2002</span>


   Figure 2 illustrates the behavior described above:

"dual stack"                                                "host6"
IPv4    Socket |     [ API Translator ]    | TCP(UDP)/IP          Name
appli-  API    |Name      Address  Function| (v6/v4)             Server
cation         |Resolver  Mapper   Mapper  |
 |        |        |        |        |         |              |       |
&lt;&lt;Resolve an IPv4 address for "host6".&gt;&gt;       |              |       |
 |        |        |        |        |         |              |       |
 |--------|-------&gt;|  Query of 'A' records for host6.         |       |
 |        |        |        |        |         |              |       |
 |        |        |--------|--------|---------|--------------|------&gt;|
 |        |        |  Query of 'A' records and 'AAAA' for host6       |
 |        |        |        |        |         |              |       |
 |        |        |&lt;-------|--------|---------|--------------|-------|
 |        |        |  Reply with the 'AAAA' record.           |       |
 |        |        |        |        |         |              |
 |        |        |&lt;&lt;The 'AAAA' record is resolved.&gt;&gt;        |
 |        |        |        |        |         |              |
 |        |        |+++++++&gt;|  Request one IPv4 address       |
 |        |        |        |  corresponding to the IPv6 address.
 |        |        |        |        |         |              |
 |        |        |        |&lt;&lt;Assign one IPv4 address.&gt;&gt;     |
 |        |        |        |        |         |              |
 |        |        |&lt;+++++++|  Reply with the IPv4 address.   |
 |        |        |        |        |         |              |
 |        |        |&lt;&lt;Create 'A' record for the IPv4 address.&gt;&gt;
 |        |        |        |        |         |              |
 |&lt;-------|--------| Reply with the 'A' record.|              |
 |        |        |        |        |         |              |

              Figure 2 Behavior of the originator (1/2)



















<span class="grey">Lee, et al.                   Experimental                      [Page 7]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-8" id="page-8" name="page-8"> </a>
<span class="grey"><a href="rfc3338.html">RFC 3338</a>               Dual Stack Hosts Using BIA           October 2002</span>


"dual stack"                                               "host6"
IPv4    Socket |     [ API Translator ]    | TCP(UDP)/IP
appli-  API    |Name      Address  Function| (v6/v4)
cation         |Resolver  Mapper   Mapper  |
 |        |        |        |        |         |              |
&lt;&lt;Call IPv4 Socket API function &gt;&gt;   |         |              |
 |        |        |        |        |         |              |
 |========|========|========|=======&gt;|An IPv4 Socket API function Call
 |        |        |        |        |         |              |
 |        |        |        |&lt;+++++++|  Request IPv6 addresses|
 |        |        |        |        |  corresponding to the  |
 |        |        |        |        |  IPv4 addresses.       |
 |        |        |        |        |         |              |
 |        |        |        |+++++++&gt;| Reply with the IPv6 addresses.
 |        |        |        |        |         |              |
 |        |        |        |        |&lt;&lt;Translate IPv4 into IPv6.&gt;&gt;
 |        |        |        |        |         |              |
 |  An IPv6 Socket API function call.|=========|=============&gt;|
 |        |        |        |        |         |              |
 |        |        |        |        |&lt;&lt;Reply an IPv6 data    |
 |        |        |        |        |  to dual stack.&gt;&gt;      |
 |        |        |        |        |         |              |
 |  An IPv6 Socket API function call.|&lt;========|==============|
 |        |        |        |        |         |              |
 |        |        |        |        |&lt;&lt;Translate IPv6 into IPv4.&gt;&gt;
 |        |        |        |        |         |              |
 |        |        |        |&lt;+++++++|  Request IPv4 addresses|
 |        |        |        |        |  corresponding to the  |
 |        |        |        |        |  IPv6 addresses.       |
 |        |        |        |        |         |              |
 |        |        |        |+++++++&gt;| Reply with the IPv4 addresses.
 |        |        |        |        |         |              |
 |&lt;=======|========|========|========|  An IPv4 Socket function call.
 |        |        |        |        |         |              |

              Figure 2 Behavior of the originator (2/2)

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.2%20Recipient%20Behavior"></a><a class="selflink" href="#section-4.2" name="section-4.2">4.2</a> Recipient Behavior</span>

   This subsection describes the recipient behavior of "dual stack".
   The communication is triggered by "host6".

   "host6" resolves the address of "dual stack" with 'AAAA' records
   through its name server, and then sends an IPv6 packet to the "dual
   stack".

   The IPv6 packet reaches the "dual stack" and the function mapper
   detects it.



<span class="grey">Lee, et al.                   Experimental                      [Page 8]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-9" id="page-9" name="page-9"> </a>
<span class="grey"><a href="rfc3338.html">RFC 3338</a>               Dual Stack Hosts Using BIA           October 2002</span>


   The function mapper requests the IPv4 address to the address mapper
   in order to invoke the IPv4 socket API function to communicate with
   the IPv4 application.  Then the function mapper invokes the
   corresponding IPv4 socket API function for the IPv4 applications
   corresponding to the IPv6 functions.

   Figure 3 illustrates the behavior described above:

   "dual stack"                                               "host6"
   IPv4    Socket |     [ API Translator ]    | TCP(UDP)/IP
   appli-  API    |Name      Address  Function| (v6/v4)
   cation         |Resolver  Mapper   Mapper  |
    |        |        |        |        |         |              |
   &lt;&lt;Receive data from "host6".&gt;&gt;       |         |              |
    |        |        |        |        |         |              |
    |      An IPv6 Socket function call.|&lt;========|==============|
    |        |        |        |        |         |              |
    |        |        |        |&lt;+++++++|  Request IPv4 addresses|
    |        |        |        |        |  corresponding to the IPv6
    |        |        |        |        |  addresses.            |
    |        |        |        |        |         |              |
    |        |        |        |+++++++&gt;| Reply with the IPv4 addresses.
    |        |        |        |        |         |              |
    |        |        |        |        |&lt;&lt;Translate IPv6 into IPv4.&gt;&gt;
    |        |        |        |        |         |              |
    |&lt;=======|========|========|========|  An IPv4 function call |
    |        |        |        |        |         |              |
   &lt;&lt;Reply an IPv4 data to "host6".&gt;&gt;   |         |              |
    |        |        |        |        |         |              |
    |========|========|========|=======&gt;|  An IPv4 function call |
    |        |        |        |        |         |              |
    |        |        |        |        |&lt;&lt;Translate IPv4 into IPv6.&gt;&gt;
    |        |        |        |        |         |              |
    |        |        |        |&lt;+++++++|  Request IPv6 addresses|
    |        |        |        |        |  corresponding to the IPv4
    |        |        |        |        |  addresses.            |
    |        |        |        |        |         |              |
    |        |        |        |+++++++&gt;| Reply with the IPv6 addresses.
    |        |        |        |        |         |              |
    |      An IPv6 Socket function call.|=========|=============&gt;|
    |        |        |        |        |         |              |

             Figure 3 Behavior of Receiving data from IPv6 host








<span class="grey">Lee, et al.                   Experimental                      [Page 9]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-10" id="page-10" name="page-10"> </a>
<span class="grey"><a href="rfc3338.html">RFC 3338</a>               Dual Stack Hosts Using BIA           October 2002</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/5.%20Considerations"></a><a class="selflink" href="#section-5" name="section-5">5</a>. Considerations</span>

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.1%20Socket%20API%20Conversion"></a><a class="selflink" href="#section-5.1" name="section-5.1">5.1</a> Socket API Conversion</span>

   IPv4 socket API functions are translated into semantically the same
   IPv6 socket API functions and vice versa.  See <a href="#appendix-A">Appendix A</a> for the API
   list intercepted by BIA.  IP addresses embedded in application layer
   protocols (e.g., FTP) can be translated in API functions.  Its
   implementation depends on operating systems.

   NOTE: Basically, IPv4 socket API functions are not fully compatible
   with IPv6 since the IPv6 has new advanced features.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.2%20ICMP%20Message%20Handling"></a><a class="selflink" href="#section-5.2" name="section-5.2">5.2</a> ICMP Message Handling</span>

   When an application needs ICMP messages values (e.g., Type, Code,
   etc.) sent from a network layer, ICMPv4 message values MAY be
   translated into ICMPv6 message values based on [<a href="#ref-SIIT" title='"Stateless IP/ICMP Translator (SIIT)"'>SIIT</a>], and vice
   versa.  It can be implemented using raw socket.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.3%20IPv4%20Address%20Pool%20and%20Mapping%20Table"></a><a class="selflink" href="#section-5.3" name="section-5.3">5.3</a> IPv4 Address Pool and Mapping Table</span>

   The address pool consists of the unassigned IPv4 addresses.  This
   pool can be implemented at different granularity in the node e.g., a
   single pool per node, or at some finer granularity such as per user
   or per process.  However, if a number of IPv4 applications
   communicate with IPv6 hosts, the available address spaces will be
   exhausted.  As a result, it will be impossible for IPv4 applications
   to communicate with IPv6 nodes.  It requires smart management
   techniques for address pool.  For example, it is desirable for the
   mapper to free the oldest entry and reuse the IPv4 address for
   creating a new entry.  This issues is the same as [<a href="#ref-BIS" title='"Dual Stack Hosts using the "'>BIS</a>].  In case of
   a per-node address mapping table, it MAY cause a larger risk of
   running out of address.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.4%20Internally%20Assigned%20IPv4%20Addresses"></a><a class="selflink" href="#section-5.4" name="section-5.4">5.4</a> Internally Assigned IPv4 Addresses</span>

   The IPv4 addresses, which are internally assigned to IPv6 target
   hosts out of the pool, are the unassigned IPv4 addresses (e.g.,
   0.0.0.1 ~ 0.0.0.255).  There is no potential collision with another
   use of the private address space when the IPv4 address flows out from
   the host.









<span class="grey">Lee, et al.                   Experimental                     [Page 10]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-11" id="page-11" name="page-11"> </a>
<span class="grey"><a href="rfc3338.html">RFC 3338</a>               Dual Stack Hosts Using BIA           October 2002</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.5%20Mismatch%20between%20DNS%20result%28AAAA%29%20and%20Peer%20Application"></a><a class="selflink" href="#section-5.5" name="section-5.5">5.5</a> Mismatch between DNS result(AAAA) and Peer Application</span>
<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/Version%28v4%29"></a>    Version(v4)</span>

   If a server application you are using does not support IPv6 yet, but
   runs on a machine that supports other IPv6 services and this is
   listed with a AAAA record in the DNS, a client IPv4 application using
   BIA might fail to connect to the server application, because there is
   a mismatch between DNS query result (i.e., AAAA) and a server
   application version(i.e., IPv4).  A solution is to try all the
   addresses listed in the DNS and just not fail after the first
   attempt.  We have two approaches:  the client application itself
   SHOULD cycle through all the addresses and end up trying the IPv4
   one.  Or it SHOULD be done by some extensions of name resolver and
   API translator in BIA.  For this, BIA SHOULD do iterated jobs for
   finding the working address used by the other application out of
   addresses returned by the extended name resolver.  It may very well
   be application dependent.  Note that BIA might be able to do the
   iteraction over all addresses for TCP sockets, since BIA can observe
   when the connect call fails.  But for UDP sockets it is hard if not
   impossible for BIA to know which address worked, hence the
   application must do the iteraction over all addresses until it finds
   a working address.

   Another way to avoid this type of problems is to make BIA only come
   into effect when no A records exist for the peer.  Thus traffic from
   an application using BIA on a dual-stack host to a dual-stack host
   would use IPv4.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.6%20Implementation%20Issues"></a><a class="selflink" href="#section-5.6" name="section-5.6">5.6</a> Implementation Issues</span>

   Some operating systems support the preload library functions, so it
   is easy to implement the API translator by using it.  For example,
   the user can replace all existing socket API functions with user-
   defined socket API functions which translate the socket API function.
   In this case, every IPv4 application has its own translation library
   using a preloaded library which will be bound into the application
   before executing it dynamically.

   Some other operating systems support the user-defined layered
   protocol allowing a user to develop some additional protocols and put
   them in the existing protocol stack.  In this case, the API
   translator can be implemented as a layered protocol module.

   In the above two approaches, it is assumed that there exists both
   TCP(UDP)/IPv4 and TCP(UDP)/IPv6 stacks and there is no need to modify
   or to add a new TCP-UDP/IPv6 stack.





<span class="grey">Lee, et al.                   Experimental                     [Page 11]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-12" id="page-12" name="page-12"> </a>
<span class="grey"><a href="rfc3338.html">RFC 3338</a>               Dual Stack Hosts Using BIA           October 2002</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/6.%20Limitations"></a><a class="selflink" href="#section-6" name="section-6">6</a>. Limitations</span>

   In common with [<a href="#ref-NAT-PT" title='"Network Address Translation - Protocol Translation (NAT-PT)"'>NAT-PT</a>], BIA needs to translate IP addresses embedded
   in application layer protocols, e.g., FTP.  So it may not work for
   new applications which embed addresses in payloads.

   This mechanism supports unicast communications only.  In order to
   support multicast functions, some other additional functionalities
   must be considered in the function mapper module.

   Since the IPv6 API has new advanced features, it is difficult to
   translate such kinds of IPv6 APIs into IPv4 APIs.  Thus, IPv6 inbound
   communication with advanced features may be discarded.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/7.%20Security%20Considerations"></a><a class="selflink" href="#section-7" name="section-7">7</a>. Security Considerations</span>

   The security consideration of BIA mostly relies on that of [<a href="#ref-NAT-PT" title='"Network Address Translation - Protocol Translation (NAT-PT)"'>NAT-PT</a>].
   The differences are due to the address translation occurring at the
   API and not in the network layer.  That is, since the mechanism uses
   the API translator at the socket API level, hosts can utilize the
   security of the network layer (e.g., IPsec) when they communicate
   with IPv6 hosts using IPv4 applications via the mechanism.  As well,
   there isn't a DNS ALG as in NAT-PT, so there is no interference with
   DNSSEC.

   The use of address pooling may open a denial of service attack
   vulnerability.  So BIA should employ the same sort of protection
   techniques as [<a href="#ref-NAT-PT" title='"Network Address Translation - Protocol Translation (NAT-PT)"'>NAT-PT</a>] does.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/8.%20Acknowledgments"></a><a class="selflink" href="#section-8" name="section-8">8</a>. Acknowledgments</span>

   We would like to acknowledge the implementation contributions by
   Wanjik Lee (wjlee@arang.miryang.ac.kr) and i2soft Corporation
   (www.i2soft.net).

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/9.%20References"></a><a class="selflink" href="#section-9" name="section-9">9</a>. References</span>

   [<a id="ref-TRANS-MECH" name="ref-TRANS-MECH">TRANS-MECH</a>] Gilligan, R. and E. Nordmark, "Transition Mechanisms for
                IPv6 Hosts and Routers", <a href="rfc2893.html">RFC 2893</a>, August 2000.

   [<a id="ref-SIIT" name="ref-SIIT">SIIT</a>]       Nordmark, E., "Stateless IP/ICMP Translator (SIIT)", <a href="rfc2765.html">RFC</a>
                <a href="rfc2765.html">2765</a>, February 2000.

   [<a id="ref-FTP" name="ref-FTP">FTP</a>]        Postel, J. and J. Reynolds, "File Transfer Protocol",
                STD 9, <a href="rfc959.html">RFC 959</a>, October 1985.






<span class="grey">Lee, et al.                   Experimental                     [Page 12]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-13" id="page-13" name="page-13"> </a>
<span class="grey"><a href="rfc3338.html">RFC 3338</a>               Dual Stack Hosts Using BIA           October 2002</span>


   [<a id="ref-NAT" name="ref-NAT">NAT</a>]        Srisuresh, P. and K. Egevang, "Traditional IP Network
                Address Translator (Traditional NAT)", <a href="rfc3022.html">RFC 3022</a>, January
                2001.

   [<a id="ref-IPV4" name="ref-IPV4">IPV4</a>]       Postel, J., "Internet Protocol", STD 5, <a href="rfc791.html">RFC 791</a>,
                September 1981.

   [<a id="ref-IPV6" name="ref-IPV6">IPV6</a>]       Deering, S. and R. Hinden, "Internet Protocol, Version 6
                (IPv6) Specification", <a href="rfc2460.html">RFC 2460</a>, December 1998.

   [<a id="ref-NAT-PT" name="ref-NAT-PT">NAT-PT</a>]     Tsirtsis, G. and P. Srisuresh, "Network Address
                Translation - Protocol Translation (NAT-PT)", <a href="rfc2766.html">RFC 2766</a>,
                February 2000.

   [<a id="ref-BIS" name="ref-BIS">BIS</a>]        Tsuchiya, K., Higuchi, H. and Y. Atarashi, "Dual Stack
                Hosts using the "Bump-In-the-Stack" Technique (BIS)",
                <a href="rfc2767.html">RFC 2767</a>, February 2000.

   [<a id="ref-SOCK-EXT" name="ref-SOCK-EXT">SOCK-EXT</a>]   Gilligan, R., Thomson, S., Bound, J. and W. Stevens,
                "Basic Socket Interface Extensions for IPv6", <a href="rfc2553.html">RFC 2553</a>,
                March 1999.

   [<a id="ref-RFC 2119" name="ref-RFC 2119">RFC 2119</a>]   Bradner S., "Key words for use in RFCs to indicate
                Requirement Levels", <a href="rfc2119.html">RFC 2119</a>, March 1997.



























<span class="grey">Lee, et al.                   Experimental                     [Page 13]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-14" id="page-14" name="page-14"> </a>
<span class="grey"><a href="rfc3338.html">RFC 3338</a>               Dual Stack Hosts Using BIA           October 2002</span>


Appendix A : API list intercepted by BIA

   The following functions are the API list which SHOULD be intercepted
   by BIA module.

   The functions that the application uses to pass addresses into the
   system are:

      bind()
      connect()
      sendmsg()
      sendto()

   The functions that return an address from the system to an
   application are:

      accept()
      recvfrom()
      recvmsg()
      getpeername()
      getsockname()

   The functions that are related to socket options are:

      getsocketopt()
      setsocketopt()

   The functions that are used for conversion of IP addresses embedded
   in application layer protocol (e.g., FTP, DNS, etc.) are:

      recv()
      send()
      read()
      write()

   As well, raw sockets for IPv4 and IPv6 MAY be intercepted.

   Most of the socket functions require a pointer to the socket address
   structure as an argument.  Each IPv4 argument is mapped into
   corresponding an IPv6 argument, and vice versa.

   According to [<a href="#ref-SOCK-EXT" title='"Basic Socket Interface Extensions for IPv6"'>SOCK-EXT</a>], the following new IPv6 basic APIs and
   structures are required.








<span class="grey">Lee, et al.                   Experimental                     [Page 14]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-15" id="page-15" name="page-15"> </a>
<span class="grey"><a href="rfc3338.html">RFC 3338</a>               Dual Stack Hosts Using BIA           October 2002</span>


      IPv4                     new IPv6
      ------------------------------------------------
      AF_INET                  AF_INET6
      sockaddr_in              sockaddr_in6
      gethostbyname()          getaddrinfo()
      gethostbyaddr()          getnameinfo()
      inet_ntoa()/inet_addr()  inet_pton()/inet_ntop()
      INADDR_ANY               in6addr_any

   BIA MAY intercept inet_ntoa() and inet_addr() and use the address
   mapper for those.  Doing that enables BIA to support literal IP
   addresses.

   The gethostbyname() call return a list of addresses.  When the name
   resolver function invokes getaddrinfo() and  getaddrinfo() returns
   multiple IP addresses, whether IPv4 or IPv6, they SHOULD all be
   represented in the addresses returned by gethostbyname().  Thus if
   getaddrinfo() returns multiple IPv6 addresses, this implies that
   multiple address mappings will be created; one for each IPv6 address.
































<span class="grey">Lee, et al.                   Experimental                     [Page 15]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-16" id="page-16" name="page-16"> </a>
<span class="grey"><a href="rfc3338.html">RFC 3338</a>               Dual Stack Hosts Using BIA           October 2002</span>


Authors' Addresses

   Seungyun Lee
   ETRI PEC
   161 Kajong-Dong, Yusong-Gu, Taejon 305-350, Korea
   Tel: +82 42 860 5508
   Fax: +82 42 861 5404
   EMail: syl@pec.etri.re.kr

   Myung-Ki Shin
   ETRI PEC
   161 Kajong-Dong, Yusong-Gu, Taejon 305-350, Korea
   Tel: +82 42 860 4847
   Fax: +82 42 861 5404
   EMail: mkshin@pec.etri.re.kr

   Yong-Jin Kim
   ETRI
   161 Kajong-Dong, Yusong-Gu, Taejon 305-350, Korea
   Tel: +82 42 860 6564
   Fax: +82 42 861 1033
   EMail: yjkim@pec.etri.re.kr

   Alain Durand
   Sun Microsystems, inc.
   25 Network circle
   Menlo Park, CA 94025, USA
   Fax: +1 650 786 5896
   EMail: Alain.Durand@sun.com

   Erik Nordmark
   Sun Microsystems Laboratories
   180, avenue de l'Europe
   38334 SAINT ISMIER Cedex, France
   Tel: +33 (0)4 76 18 88 03
   Fax: +33 (0)4 76 18 88 88
   EMail: erik.nordmark@sun.com














<span class="grey">Lee, et al.                   Experimental                     [Page 16]</span>
</pre><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-17" id="page-17" name="page-17"> </a>
<span class="grey"><a href="rfc3338.html">RFC 3338</a>               Dual Stack Hosts Using BIA           October 2002</span>


Full Copyright Statement

   Copyright (C) The Internet Society (2002).  All Rights Reserved.

   This document and translations of it may be copied and furnished to
   others, and derivative works that comment on or otherwise explain it
   or assist in its implementation may be prepared, copied, published
   and distributed, in whole or in part, without restriction of any
   kind, provided that the above copyright notice and this paragraph are
   included on all such copies and derivative works.  However, this
   document itself may not be modified in any way, such as by removing
   the copyright notice or references to the Internet Society or other
   Internet organizations, except as needed for the purpose of
   developing Internet standards in which case the procedures for
   copyrights defined in the Internet Standards process must be
   followed, or as required to translate it into languages other than
   English.

   The limited permissions granted above are perpetual and will not be
   revoked by the Internet Society or its successors or assigns.

   This document and the information contained herein is provided on an
   "AS IS" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING
   TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING
   BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION
   HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF
   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.

Acknowledgement

   Funding for the RFC Editor function is currently provided by the
   Internet Society.



















Lee, et al.                   Experimental                     [Page 17]

</pre><br/>
<span class="noprint"><small><small>Html markup produced by rfcmarkup 1.111, available from
<a href="https://tools.ietf.org/tools/rfcmarkup/">https://tools.ietf.org/tools/rfcmarkup/</a>
</small></small></span>



</body><!-- Mirrored from tools.ietf.org/html/rfc3338 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 28 Apr 2015 16:02:16 GMT --></html>