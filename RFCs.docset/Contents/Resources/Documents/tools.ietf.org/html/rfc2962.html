<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml"><!-- Mirrored from tools.ietf.org/html/rfc2962 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 06 Mar 2018 23:18:50 GMT --><!-- Added by HTTrack --><head><meta content="text/html;charset=utf-8" http-equiv="content-type"/><!-- /Added by HTTrack -->

    <meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
    <meta content="index,follow" name="robots"/>
    <meta content="rfcmarkup version 1.126" name="creator"/>
    <link href="http://purl.org/dc/elements/1.1/" rel="schema.DC"/>
<meta content="urn:ietf:rfc:2962" name="DC.Identifier"/>
<meta content="This document describes the ALG (Application Level Gateway) for the
SNMP (Simple Network Management Protocol) by which IP (Internet
Protocol) addresses in the payload of SNMP packets are statically
mapped from one group to another. This memo provides information for
the Internet community." name="DC.Description.Abstract"/>
<meta content="Sugla, Binay" name="DC.Creator"/>
<meta content="Raz, Danny" name="DC.Creator"/>
<meta content="Schoenwaelder, Juergen" name="DC.Creator"/>
<meta content="October, 2000" name="DC.Date.Issued"/>
<meta content="An SNMP Application Level Gateway for Payload Address Translation" name="DC.Title"/>

    <link href="https://tools.ietf.org/images/rfc.png" rel="icon" type="image/png"/>
    <link href="https://tools.ietf.org/images/rfc.png" rel="shortcut icon" type="image/png"/>
    <title>RFC 2962 - An SNMP Application Level Gateway for Payload Address Translation</title>
    
    
    <style type="text/css">
	@media only screen 
	  and (min-width: 992px)
	  and (max-width: 1199px) {
	    body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 768px)
	  and (max-width: 991px) {
            body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 480px)
	  and (max-width: 767px) {
            body { font-size: 11pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (max-width: 479px) {
            body { font-size: 8pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-device-width : 375px) 
	  and (max-device-width : 667px) {
            body { font-size: 9.5pt; }
            div.content { width: 96ex; margin: 0 1px; }
        }
	@media only screen 
	  and (min-device-width: 1200px) {
            body { font-size: 10pt; margin: 0 4em; }
            div.content { width: 96ex; margin: 0; }
        }
        h1, h2, h3, h4, h5, h6, .h1, .h2, .h3, .h4, .h5, .h6 {
	    font-weight: bold;
            line-height: 0pt;
            display: inline;
            white-space: pre;
            font-family: monospace;
            font-size: 1em;
	    font-weight: bold;
        }
        pre {
            font-size: 1em;
            margin-top: 0px;
            margin-bottom: 0px;
        }
	.pre {
	    white-space: pre;
	    font-family: monospace;
	}
	.header{
	    font-weight: bold;
	}
        .newpage {
            page-break-before: always;
        }
        .invisible {
            text-decoration: none;
            color: white;
        }
        a.selflink {
          color: black;
          text-decoration: none;
        }
        @media print {
            body {
                font-family: monospace;
                font-size: 10.5pt;
            }
            h1, h2, h3, h4, h5, h6 {
                font-size: 1em;
            }
        
            a:link, a:visited {
                color: inherit;
                text-decoration: none;
            }
            .noprint {
                display: none;
            }
        }
	@media screen {
	    .grey, .grey a:link, .grey a:visited {
		color: #777;
	    }
            .docinfo {
                background-color: #EEE;
            }
            .top {
                border-top: 7px solid #EEE;
            }
            .bgwhite  { background-color: white; }
            .bgred    { background-color: #F44; }
            .bggrey   { background-color: #666; }
            .bgbrown  { background-color: #840; }            
            .bgorange { background-color: #FA0; }
            .bgyellow { background-color: #EE0; }
            .bgmagenta{ background-color: #F4F; }
            .bgblue   { background-color: #66F; }
            .bgcyan   { background-color: #4DD; }
            .bggreen  { background-color: #4F4; }

            .legend   { font-size: 90%; }
            .cplate   { font-size: 70%; border: solid grey 1px; }
	}
    </style>
    <!--[if IE]>
    <style>
    body {
       font-size: 13px;
       margin: 10px 10px;
    }
    </style>
    <![endif]-->

    <script type="text/javascript"><!--
    function addHeaderTags() {
	var spans = document.getElementsByTagName("span");
	for (var i=0; i < spans.length; i++) {
	    var elem = spans[i];
	    if (elem) {
		var level = elem.getAttribute("class");
                if (level == "h1" || level == "h2" || level == "h3" || level == "h4" || level == "h5" || level == "h6") {
                    elem.innerHTML = "<"+level+">"+elem.innerHTML+"</"+level+">";		
                }
	    }
	}
    }
    var legend_html = "Colour legend:<br />      <table>         <tr><td>Unknown:</td>                   <td><span class='cplate bgwhite'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft:</td>                     <td><span class='cplate bgred'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Informational:</td>             <td><span class='cplate bgorange'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Experimental:</td>              <td><span class='cplate bgyellow'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Best Common Practice:</td>      <td><span class='cplate bgmagenta'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Proposed Standard:</td>         <td><span class='cplate bgblue'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft Standard (old designation):</td> <td><span class='cplate bgcyan'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Internet Standard:</td>         <td><span class='cplate bggreen'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Historic:</td>                  <td><span class='cplate bggrey'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Obsolete:</td>                  <td><span class='cplate bgbrown'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>     </table>";
    function showElem(id) {
        var elem = document.getElementById(id);
        elem.innerHTML = eval(id+"_html");
        elem.style.visibility='visible';
    }
    function hideElem(id) {
        var elem = document.getElementById(id);
        elem.style.visibility='hidden';        
        elem.innerHTML = "";
    }
    // -->
    </script>
</head>
<body onload="addHeaderTags()">
  <div class="content">
   <div style="height: 13px;">
      <div class="pre noprint docinfo bgorange" onclick="showElem('legend');" onmouseout="hideElem('legend')" onmouseover="this.style.cursor='pointer';" style="height: 6px; position: absolute;" title="Click for colour legend.">                                                                        </div>
      <div class="docinfo noprint pre legend" id="legend" onmouseout="hideElem('legend');" onmouseover="showElem('legend');" style="position:absolute; top: 4px; left: 4ex; visibility:hidden; background-color: white; padding: 4px 9px 5px 7px; border: solid #345 1px; ">
      </div>
   </div>
<span class="pre noprint docinfo top">[<a href="index.html" title="Document search and retrieval page">Docs</a>] [<a href="https://tools.ietf.org/rfc/rfc2962.txt" title="Plaintext version of this document">txt</a>|<a href="https://tools.ietf.org/pdf/rfc2962" title="PDF version of this document">pdf</a>] [<a href="https://tools.ietf.org/html/draft-ietf-nat-snmp-alg" title="draft-ietf-nat-snmp-alg">draft-ietf-nat-...</a>] [<a href="https://datatracker.ietf.org/doc/rfc2962" title="IESG Datatracker information for this document">Tracker</a>] [<a href="https://tools.ietf.org/rfcdiff?difftype=--hwdiff&amp;url2=rfc2962" title="Inline diff (wdiff)">Diff1</a>] [<a href="https://tools.ietf.org/rfcdiff?url2=rfc2962" title="Side-by-side diff">Diff2</a>] [<a href="https://www.rfc-editor.org/errata_search.php?rfc=2962">Errata</a>]</span><br/>
<span class="pre noprint docinfo">                                                                        </span><br/>
<span class="pre noprint docinfo">                                                           INFORMATIONAL</span><br/>
<span class="pre noprint docinfo">                                                            <span style="color: #C00;">Errata Exist</span></span><br/>
<pre>Network Working Group                                              D. Raz
Request for Comments: 2962                            Lucent Technologies
Category: Informational                                  J. Schoenwaelder
                                                          TU Braunschweig
                                                                 B. Sugla
                                                             ISPSoft Inc.
                                                             October 2000


   <span class="h1">An SNMP Application Level Gateway for Payload Address Translation</span>

Status of this Memo

   This memo provides information for the Internet community.  It does
   not specify an Internet standard of any kind.  Distribution of this
   memo is unlimited.

Copyright Notice

   Copyright (C) The Internet Society (2000).  All Rights Reserved.

IESG Note

   This document describes an SNMP application layer gateway (ALG),
   which may be useful in certain environments.  The document does also
   list the issues and problems that can arise when used as a generic
   SNMP ALG.  Specifically, when using SNMPv3's authentication and
   privacy mechanisms this approach may be very problematic and
   jeopardize the SNMP security.  The reader is urged to carefully
   consider these issues before deciding to deploy this type of SNMP
   ALG.

Abstract

   This document describes the ALG (Application Level Gateway) for the
   SNMP (Simple Network Management Protocol) by which IP (Internet
   Protocol) addresses in the payload of SNMP packets are statically
   mapped from one group to another.  The SNMP ALG is a specific case of
   an Application Level Gateway as described in [<a href="#ref-15" title='"IP Network Address Translator (NAT) Terminology and Considerations"'>15</a>].

   An SNMP ALG allows network management stations to manage multiple
   networks that use conflicting IP addresses.  This can be important in
   environments where there is a need to use SNMP with NAT (Network
   Address Translator) in order to manage several potentially
   overlapping addressing realms.






<span class="grey">Raz, et al.                  Informational                      [Page 1]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-2" id="page-2" name="page-2"> </a>
<span class="grey"><a href="rfc2962.html">RFC 2962</a>            SNMP Payload Address Translation        October 2000</span>


   This document includes a detailed description of the requirements and
   limitations for an implementation of an SNMP Application Level
   Gateway.  It also discusses other approaches to exchange SNMP packets
   across conflicting addressing realms.

Table of Contents

   <a href="#section-1">1</a>.  Introduction ..................................................<a href="#page-2">2</a>
   <a href="#section-2">2</a>.  Terminology and Concepts Used  ................................<a href="#page-5">5</a>
   <a href="#section-3">3</a>.  Problem Scope and Requirements ................................<a href="#page-5">5</a>
   <a href="#section-3.1">3.1</a> IP Addresses in SNMP Messages  ................................<a href="#page-6">6</a>
   <a href="#section-3.2">3.2</a> Requirements ..................................................<a href="#page-7">7</a>
   <a href="#section-4">4</a>.  Translating IP Addresses in SNMP Packets ......................<a href="#page-7">7</a>
   <a href="#section-4.1">4.1</a> Basic SNMP Application Level Gateway ..........................<a href="#page-8">8</a>
   <a href="#section-4.2">4.2</a> Advanced SNMP Application Level Gateway  ......................<a href="#page-8">8</a>
   <a href="#section-4.3">4.3</a> Packet Size and UDP Checksum ..................................<a href="#page-9">9</a>
   <a href="#section-5">5</a>.  Limitations and Alternate Solutions  .........................<a href="#page-10">10</a>
   <a href="#section-6">6</a>.  Security Considerations  .....................................<a href="#page-12">12</a>
   <a href="#section-7">7</a>.  Summary and Recommendations  .................................<a href="#page-13">13</a>
   <a href="#section-8">8</a>.  Current Implementations  .....................................<a href="#page-14">14</a>
   <a href="#section-9">9</a>.  Acknowledgments  .............................................<a href="#page-14">14</a>
   <a href="#section-10">10</a>. References ...................................................<a href="#page-14">14</a>
   <a href="#section-11">11</a>. Authors' Addresses ...........................................<a href="#page-16">16</a>
   <a href="#section-12">12</a>. Description of the Encoding of SNMP Packets  .................<a href="#page-17">17</a>
   <a href="#section-13">13</a>. Full Copyright Statement .....................................<a href="#page-20">20</a>

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/1.%20Introduction"></a><a class="selflink" href="#section-1" name="section-1">1</a>. Introduction</span>

   The need for IP address translation arises when a network's internal
   IP addresses cannot be used outside the network.  Using basic network
   address translation allows local hosts on such private networks
   (addressing realms) to transparently access the external global
   Internet and enables access to selective local hosts from the
   outside.  In particular it is not unlikely to have several addressing
   realms that are using the same private IPv4 address space within the
   same organization.

   In many of these cases, there is a need to manage the local
   addressing realm from a manager site outside the domain. However,
   managing such a network presents unique problems and challenges.
   Most available management applications use SNMP (Simple Network
   Management Protocol) to retrieve information from the network
   elements.  For example, a router may be queried by the management
   application about the addresses of its neighboring elements.  This
   information is then sent by the router back to the management






<span class="grey">Raz, et al.                  Informational                      [Page 2]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-3" id="page-3" name="page-3"> </a>
<span class="grey"><a href="rfc2962.html">RFC 2962</a>            SNMP Payload Address Translation        October 2000</span>


   station as part of the payload of an SNMP packet. In order to retain
   consistency in the view as seen by the management station we need to
   be able to locate and translate IP address related information in the
   payload of such packets.

   The SNMP Application Level Gateway for Payload Address Translation,
   or SNMP ALG, is a technique in which the payload of SNMP packets
   (PDUs) is scanned and IP address related information is translated if
   needed.  In this context, an SNMP ALG can be an additional component
   in a NAT implementation, or it can be a separate entity, that may
   reside in the same gateway or even on a separate node.  Note that in
   our context of management application all devices in the network are
   assumed to have a fixed IP address.  Thus, SNMP ALG should only be
   combined with NAT that uses static address assignment for all the
   devices in the network.

   A typical scenario where SNMP ALG is deployed as part of NAT is
   presented in figure Figure 1.  A manager device is managing a remote
   stub, with translated IP addresses.

         \ | /              .
   +---------------+  WAN   .        +------------------------------+
   |Regional Router|-----------------|Stub Router w/NAT and SNMP ALG|
   +---------------+        .        +------------------------------+
           |                .                   |
           |                .                   |  LAN
      +----------+          .            ---------------
      | Manager  |    Stub border         Managed network
      +----------+

               Figure 1: SNMP ALG in a NAT configuration




















<span class="grey">Raz, et al.                  Informational                      [Page 3]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-4" id="page-4" name="page-4"> </a>
<span class="grey"><a href="rfc2962.html">RFC 2962</a>            SNMP Payload Address Translation        October 2000</span>


   A similar scenario occurs when several subnetworks with private (and
   possibly conflicting) IP addresses are to be managed by the same
   management station.  This scenario is presented in Figure 2.

                         +---------------+     +-----------------+
                         | SNMP ALG      |-----|Management device|
                         +---------------+     +-----------------+
                       T1  |           | T1
                           |           |
       Stub A .............|....   ....|............ Stub B
                           |           |
                 +---------------+   +----------------+
                 |Bi-directional |   |Bi-directional |
                 |NAT Router w/  |   |NAT Router w/  |
                 |static address |   |static address |
                 |mapping        |   |mapping        |
                 +---------------+   +---------------+
                   |                         |
                   |  LAN               LAN  |
           -------------             -------------
        192.10.x.y   |                 |  192.10.x.y
                   /____\           /____\


     Figure 2: Using external SNMP ALG to manage two private networks

   Since the devices in the managed network are monitored by the manager
   device they must obtain a fixed IP address.  Therefore, the NAT used
   in this case must be a basic NAT with a static one to one mapping.

   An SNMP ALG is required to scan all the payload of SNMP packets, to
   detect IP address related data, and to translate this data if needed.
   This is a much more computationally involved process than the bi-
   directional NAT, however they both use the same translation tables.
   In many cases the router may be unable to handle SNMP ALG and retain
   acceptable performance. In these cases it may be better to locate the
   SNMP ALG outside the router, as described in Figure 2.














<span class="grey">Raz, et al.                  Informational                      [Page 4]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-5" id="page-5" name="page-5"> </a>
<span class="grey"><a href="rfc2962.html">RFC 2962</a>            SNMP Payload Address Translation        October 2000</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/2.%20Terminology%20and%20Concepts%20Used"></a><a class="selflink" href="#section-2" name="section-2">2</a>. Terminology and Concepts Used</span>

   In general we adapt the terminology defined in [<a href="#ref-15" title='"IP Network Address Translator (NAT) Terminology and Considerations"'>15</a>].  Our main
   concern are SNMP messages exchanged between SNMP engines.  This
   document only discusses SNMP messages that are send over UDP, which
   is the preferred transport mapping for SNMP messages [<a href="#ref-5" title='"Transport Mappings for Version 2 of the Simple Network Management Protocol (SNMPv2)"'>5</a>].  SNMP
   messages send over other transports can be handled in a similar way.
   Thus, the term SNMP packet is used throughout this document to refer
   to an SNMP message contained in an UDP packet.

   SNMP messages contain SNMP PDUs (Protocol Data Units).  An SNMP PDU
   defines the parameters for a specific SNMP protocol operation.  The
   notion of flow is less relevant in this case, and hence we will focus
   on the information contained in a single SNMP packet.

   There are currently three versions of SNMP. SNMP version 1 (SNMPv1)
   protocol is defined in STD 15, <a href="rfc1157.html">RFC 1157</a> [<a href="#ref-2" title='"A Simple Network Management Protocol (SNMP)"'>2</a>]. The SNMP version 2c
   (SNMPv2c) protocol is defined in <a href="rfc1901.html">RFC 1901</a> [<a href="#ref-3" title='"Introduction to Community-based SNMPv2"'>3</a>], <a href="rfc1905.html">RFC 1905</a> [<a href="#ref-4" title='"Protocol Operations for Version 2 of the Simple Network Management Protocol (SNMPv2)"'>4</a>] and <a href="rfc1906.html">RFC</a>
   <a href="rfc1906.html">1906</a> [<a href="#ref-5" title='"Transport Mappings for Version 2 of the Simple Network Management Protocol (SNMPv2)"'>5</a>].  Finally, the SNMP version 3 (SNMPv3) protocol is defined
   in <a href="rfc1905.html">RFC 1905</a> [<a href="#ref-4" title='"Protocol Operations for Version 2 of the Simple Network Management Protocol (SNMPv2)"'>4</a>], 1906 [<a href="#ref-5" title='"Transport Mappings for Version 2 of the Simple Network Management Protocol (SNMPv2)"'>5</a>], <a href="rfc2572.html">RFC 2572</a> [<a href="#ref-10" title='"Message Processing and Dispatching for the Simple Network Management Protocol (SNMP)"'>10</a>] and <a href="rfc2574.html">RFC 2574</a> [<a href="#ref-12" title='"User-based Security Model (USM) for version 3 of the Simple Network Management Protocol (SNMPv3)"'>12</a>].  See <a href="rfc2570.html">RFC</a>
   <a href="rfc2570.html">2570</a> [<a href="#ref-9" title='"Introduction to Version 3 of the Internet-standard Network Management Framework"'>9</a>] for a more detailed overview over the SNMP standards.  In
   the following, unless otherwise mentioned, we use the term SNMP in
   statements that are applicable to all three SNMP versions.

   SNMP uses ASN.1 [<a href="#ref-13" title='"Information processing systems - Open Systems Interconnection - Specification of Abstract Syntax Notation One (ASN.1)"'>13</a>] to define the abstract syntax of the messages.
   The actual encoding of the messages is done by using the Basic
   Encoding Rules (BER) [<a href="#ref-14" title='"Information processing systems - Open Systems Interconnection - Specification of Basic Encoding Rules for Abstract Syntax Notation One (ASN.1)"'>14</a>], which provide the transfer syntax.

   We refer to packets that go from a management station to the network
   elements as "outgoing", and packets that go from the network elements
   to the management station as "incoming".

   A basic SNMP ALG is an SNMP ALG implementation in which only IP
   address values encoded in the IpAddress type are translated. A basic
   SNMP ALG therefore does not need to be MIB aware.

   An advanced SNMP ALG is an SNMP ALG implementation which is capable
   of handling and replacing IP address values encoded in well known IP
   address data types and instance identifiers derived from those data
   types. This implies that an advanced SNMP ALG is MIB aware.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/3.%20Problem%20Scope%20and%20Requirements"></a><a class="selflink" href="#section-3" name="section-3">3</a>. Problem Scope and Requirements</span>

   As mentioned before, in many cases, there is a need to manage a local
   addressing realm that is using NAT, from a manager site outside the
   realm.  A particular important example is the case of network
   management service providers who provide network management services
   from a remote site.  Such providers may have many customers, each



<span class="grey">Raz, et al.                  Informational                      [Page 5]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-6" id="page-6" name="page-6"> </a>
<span class="grey"><a href="rfc2962.html">RFC 2962</a>            SNMP Payload Address Translation        October 2000</span>


   using the same private address space. When all these addressing
   realms are to be managed from a single management station address
   collision occurs.  There are two straight forward ways to overcome
   the address collision. One can

   1.  reassign IP addresses to the different addressing realms, or
   2.  use static address NAT to hide the address collisions from the
       network management application.

   The first solution is problematic as it requires both a potentially
   large set of IP addresses, and the reconfiguration of a large portion
   of the network.  The problem with the second solution is that many
   network management applications are currently unaware of NAT, and
   because of the large investment needed in order to make them NAT
   aware are likely to remain so in the near future.

   Hence, there is a need for a solution that is transparent to the
   network management application (but not to the user), and that does
   not require a general reconfiguration of a large portion of the
   network (i.e. the addressing realm).  The SNMP ALG described in this
   memo is such a solution.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.1%20IP%20Addresses%20in%20SNMP%20Messages"></a><a class="selflink" href="#section-3.1" name="section-3.1">3.1</a> IP Addresses in SNMP Messages</span>

   SNMP messages can contain IP addresses in various places and formats.
   The following four categories have been identified:

   1.  IP version 4 addresses and masks stored in the IpAddress tagged
       ASN.1 data type which are not part of an instance identifier. An
       example is the ipAdEntNetMask object defined in the IP-MIB [<a href="#ref-6" title='"SNMPv2 Management Information Base for the Internet Protocol using SMIv2"'>6</a>].
   2.  IP version 4 addresses contained in instance identifiers derived
       from index objects using the IpAddress data type.  An example is
       the ipAdEntAddr index object of the IP-MIB [<a href="#ref-6" title='"SNMPv2 Management Information Base for the Internet Protocol using SMIv2"'>6</a>].
   3.  IP addresses (any version) contained in OCTET STRINGS.  Examples
       include addressMapNetworkAddress object of the RMON2-MIB [<a href="#ref-7" title='"Remote Network Monitoring Management Information Base Version 2 using SMIv2"'>7</a>], and
       IP addresses contained in OCTET STRINGS derived from well-known
       textual conventions (e.g. TAddress [<a href="#ref-5" title='"Transport Mappings for Version 2 of the Simple Network Management Protocol (SNMPv2)"'>5</a>] or Ipv6Address [<a href="#ref-8" title='"Management Information Base for IP Version 6: Textual Conventions and General Group"'>8</a>] or
       InetAddress [<a href="#ref-19" title='"Textual Conventions for Internet Network Addresses"'>19</a>]).
   4.  IP addresses (any version) contained in instance identifiers
       derived from OCTET STRINGS.  This may derived from well-known
       textual conventions (e.g. TAddress [<a href="#ref-5" title='"Transport Mappings for Version 2 of the Simple Network Management Protocol (SNMPv2)"'>5</a>] or Ipv6Address [<a href="#ref-8" title='"Management Information Base for IP Version 6: Textual Conventions and General Group"'>8</a>] or
       InetAddress [<a href="#ref-19" title='"Textual Conventions for Internet Network Addresses"'>19</a>]) like the ipv6AddrAddress index object of the
       IPV6-MIB [<a href="#ref-8" title='"Management Information Base for IP Version 6: Textual Conventions and General Group"'>8</a>].

   Textual conventions that can contain IP addresses can be further
   divided in NAT friendly and NAT unfriendly ones.  A NAT friendly
   textual convention ensures that the encoding on the wire contains




<span class="grey">Raz, et al.                  Informational                      [Page 6]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-7" id="page-7" name="page-7"> </a>
<span class="grey"><a href="rfc2962.html">RFC 2962</a>            SNMP Payload Address Translation        October 2000</span>


   sufficient information that an advanced SNMP ALG which understands
   the textual convention and which has the necessary MIB knowledge can
   do a proper translation.  An example of this type is the Ipv6Address
   textual convention.

   A NAT unfriendly textual convention requires that an SNMP ALG, which
   understands the textual convention and which has the necessary MIB
   knowledge, has access to additional information in order to do a
   proper translation.  Examples of this type are the TAddress and the
   InetAddress textual conventions which require that an additional
   varbind is present in an SNMP packet to determine what type of IP
   address a given value represents.  Such a varbind may or may not be
   present depending on the way a management applications retrieves
   data.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.2%20Requirements"></a><a class="selflink" href="#section-3.2" name="section-3.2">3.2</a> Requirements</span>

   An SNMP ALG should provide transparent IP address translation to
   management applications.  An SNMP ALG must be compatible with the
   behavior of the SNMP protocol operations as defined by <a href="rfc1157.html">RFC 1157</a> [<a href="#ref-2" title='"A Simple Network Management Protocol (SNMP)"'>2</a>]
   and <a href="rfc1905.html">RFC 1905</a> [<a href="#ref-4" title='"Protocol Operations for Version 2 of the Simple Network Management Protocol (SNMPv2)"'>4</a>] and must not have negative impact on the security
   provided by the SNMP protocol.  A fully transparent SNMP ALG must be
   able to translate all categories of IP addresses as described above,
   when provided with the specified OID's and the encoding details.

   The SNMP ALG requires bi-directional NAT devices enroute, that
   support static address mapping for all nodes in the respective
   private realms.  When there are multiple private realms supported by
   a single SNMP ALG, the external addresses assumed by each of the NAT
   devices must not collide with each other.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/4.%20Translating%20IP%20Addresses%20in%20SNMP%20Packets"></a><a class="selflink" href="#section-4" name="section-4">4</a>. Translating IP Addresses in SNMP Packets</span>

   This section describes several ways to translate IP addresses in SNMP
   packets.

   A general SNMP ALG must be capable to translate IP addresses in
   outgoing and incoming SNMP packets.

   SNMP messages send over UDP may experience fragmentation at the IP
   layer. In an extreme case, fragmentation may cause an IP address type
   to be partitioned into two different fragments.  In order to
   translate IP addresses in SNMP messages, the complete SNMP message
   must be available. As described in [<a href="#ref-18" title='"Traditional IP Network Address Translator (Traditional NAT)"'>18</a>], fragments of UDP packets do
   not carry the destination/source port number with them.  Hence, an
   SNMP ALG must reassemble IP packets which contain SNMP messages.  The





<span class="grey">Raz, et al.                  Informational                      [Page 7]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-8" id="page-8" name="page-8"> </a>
<span class="grey"><a href="rfc2962.html">RFC 2962</a>            SNMP Payload Address Translation        October 2000</span>


   good news is, however, that usually SNMP agents are aware of the MTU,
   and that SNMP packets are usually relatively small.  Some SNMP
   implementations also set the don't fragment (DF) bit in the IP header
   [<a href="#ref-1" title='"Internet Protocol"'>1</a>] to avoid fragmentation.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.1%20Basic%20SNMP%20Application%20Level%20Gateway"></a><a class="selflink" href="#section-4.1" name="section-4.1">4.1</a> Basic SNMP Application Level Gateway</span>

   A basic SNMP ALG is an SNMP ALG implementation in which only IP
   address values encoded in the IpAddress base type are translated.  A
   basic SNMP ALG implementation parses an ASN.1/BER encoded SNMP packet
   looking for elements that are encoded using the IpAddress base type.
   <a href="#appendix-A">Appendix A</a> contains a more detailed description of the structure and
   encoding used by SNMP.

   An IpAddress value can be identified easily by its tag value (0x40).
   Once an IpAddress has been detected, the SNMP ALG checks the
   translation table and decides whether the address should be
   translated. If the address needs translation, the 4 bytes
   representing the IPv4 address are replaced with the translated IPv4
   address and the UDP checksum is adjusted.  <a href="#section-4.3">Section 4.3</a> describes an
   efficient algorithm to adjust the UDP checksum without recalculating
   it.

   The basic SNMP ALG does not require knowledge of any MIBs since it
   relies on the ASN.1/BER encoding of SNMP packets.  It is therefore
   easy to implement.  A basic SNMP ALG does not change the overall
   messages size and hence it does not cause translated messages to be
   lost due to message size constraints.

   However, a basic SNMP ALG is only able to translate IPv4 addresses in
   objects that use the IpAddress base type. Furthermore, a basic SNMP
   ALG is not capable to translate IP addresses in objects that are
   index components of conceptual tables.  This is especially
   problematic on index components that are not accessible.  Hence, the
   basic SNMP ALG is restricted to the first out of the four possible
   ways to represent IP addresses in SNMP messages (see <a href="#section-3.1">Section 3.1</a>).

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.2%20Advanced%20SNMP%20Application%20Level%20Gateway"></a><a class="selflink" href="#section-4.2" name="section-4.2">4.2</a> Advanced SNMP Application Level Gateway</span>

   An advanced SNMP ALG is an SNMP ALG implementation which is capable
   of handling and replacing IP address values encoded in well known IP
   address data types and instance identifiers derived from those data
   types.  Hence, an advanced SNMP ALG may be able to transparently map
   IP addresses that are in the format 1-4 as described in <a href="#section-3.1">Section 3.1</a>.
   This implies that an advanced SNMP ALG must be MIB aware.






<span class="grey">Raz, et al.                  Informational                      [Page 8]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-9" id="page-9" name="page-9"> </a>
<span class="grey"><a href="rfc2962.html">RFC 2962</a>            SNMP Payload Address Translation        October 2000</span>


   An advanced SNMP ALG must maintain an OBJECT IDENTIFIER (OID)
   translation table in order to identify IP addresses that are not
   encoded in an IpAddress base type.  The OID translation table needs
   to maintain information about the OIDs where translation may be
   needed.  Furthermore, the translation table needs to keep information
   about instance identifiers for conceptual tables that contain IP
   addresses.  Such an OID translation table may be populated offline by
   using a MIB compiler which loads the MIBs used within an addressing
   realm and searches for types, textual conventions and table indexes
   that may contain IP addresses.

   The translation function scans the packet for these specific OIDs,
   checks the translation table and replaces the data if needed.  Note
   that since OIDs do not have a fixed size this search is much more
   computationally consuming, and the lookup operation may be expensive.

   The ability to translate IP addresses that are part of the index of a
   conceptual table is a required feature of an advanced SNMP ALG.  IP
   addresses embedded in an instance identifier are ASN.1/BER encoded
   according to the OID encoding rules. For example, the OID for the
   10.1.2.3 instance of the ipAdEntIfIndex object of the IP-MIB [<a href="#ref-6" title='"SNMPv2 Management Information Base for the Internet Protocol using SMIv2"'>6</a>] is
   encoded as 06 0D 2B 06 01 02 01 04 14 01 02 0A 01 02 03.  Replacing
   the embedded private IPv4 address with 135.180.140.202 leads to the
   OID 06 11 2B 06 01 02 01 04 14 01 02 81 07 81 34 81 0C 81 4A.  This
   example shows that an advanced SNMP ALG may change the overall packet
   size since IP addresses embedded in an OID can change the size of the
   ASN.1/BER encoded OID.

   Another effect of an advanced SNMP ALG is that it changes the
   lexicographic ordering of rows in conceptual tables as seen by the
   SNMP manager.  This may have severe side-effects for management
   applications that use lexicographic ordering to retrieve only parts
   of a conceptual table.  Many SNMP managers check lexicographic
   ordering to detect loops caused by broken agents. Such a manager will
   incorrectly report agents behind an advanced SNMP ALG as broken SNMP
   agents.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.3%20Packet%20Size%20and%20UDP%20Checksum"></a><a class="selflink" href="#section-4.3" name="section-4.3">4.3</a> Packet Size and UDP Checksum</span>

   Changing an IpAddress value in an SNMP packet does not change the
   size of the SNMP packet.  A basic SNMP ALG does therefore never
   change the size of the underlying UDP packet.

   An advanced SNMP ALG may change the size of an SNMP packet since a
   different number of bytes may be needed to encode a different IP
   address.  This is highly undesirable but unavoidable in the general
   case.  A change of the SNMP packet size requires additional changes
   in the UDP and IP headers.  Increasing packet sizes are especially



<span class="grey">Raz, et al.                  Informational                      [Page 9]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-10" id="page-10" name="page-10"> </a>
<span class="grey"><a href="rfc2962.html">RFC 2962</a>            SNMP Payload Address Translation        October 2000</span>


   problematic with SNMPv3.  The SNMPv3 message header contains the
   msgMaxSize field so that agents can generate Response PDUs for
   GetBulkRequest PDUs that are close to the maximum message size the
   receiver can handle.  An SNMP ALG which increases the size of an SNMP
   packet may have the effect that the Response PDU can not be processed
   anymore.  Thus, an advanced SNMP ALG may cause some SNMPv3
   interactions to fail.

   In both cases, the UDP checksum must be adjusted when making an IP
   address translation.  We can use the algorithm from [<a href="#ref-18" title='"Traditional IP Network Address Translator (Traditional NAT)"'>18</a>], but a small
   modification must be introduced as the modified bytes may start on an
   odd position.  The C code shown in Figure 3 adjusts the checksum to a
   replacement of one byte in an odd or even position.

        void checksumbyte(unsigned char *chksum, unsigned char *optr,
        unsigned char *nptr, int odd)
        /* assuming: unsigned char is 8 bits, long is 32 bits,
           we replace one byte by one byte in an odd position.
          - chksum points to the chksum in the packet
          - optr points to the old byte in the packet
          - nptr points to the new byte in the packet
          - odd is 1 if the byte is in an odd position 0 otherwise
        */
        {  long x, old, new;
           x=chksum[0]*256+chksum[1];
           x=~x &amp; 0xFFFF;
           if (odd) old=optr[0]*256; else old=optr[0];
           x-=old &amp; 0xFFFF;
           if (x&lt;=0) { x--; x&amp;=0xFFFF; }
           if (odd) new=nptr[0]*256; else new=nptr[0];
           x+=new &amp; 0xFFFF;
           if (x &amp; 0x10000) { x++; x&amp;=0xFFFF; }
           x=~x &amp; 0xFFFF;
           chksum[0]=x/256; chksum[1]=x &amp; 0xFF;
        }

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/5.%20Limitations%20and%20Alternate%20Solutions"></a><a class="selflink" href="#section-5" name="section-5">5</a>. Limitations and Alternate Solutions</span>

   Making SNMP ALGs completely transparent to all management
   applications is not an achievable task.  The basic SNMP ALG described
   in <a href="#section-4.1">Section 4.1</a> only translates IP addresses encoded in the IpAddress
   base type.  Such an SNMP ALG achieves only very limited transparency
   since IP addresses are frequently used as part of an index into a
   conceptual table.  A management application will therefore see both
   the translated as well as the original address, which can lead to






<span class="grey">Raz, et al.                  Informational                     [Page 10]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-11" id="page-11" name="page-11"> </a>
<span class="grey"><a href="rfc2962.html">RFC 2962</a>            SNMP Payload Address Translation        October 2000</span>


   confusion and erroneous behavior of management applications.
   However, a certain class of management applications like e.g.
   network discovery tools may work pretty well across NATs with a basic
   SNMP ALG in place.

   An advanced SNMP ALG described in <a href="#section-4.2">Section 4.2</a> achieves better
   transparency.  However, an advanced SNMP ALG can only claim to be
   transparent for the set of data types (textual conventions)
   understood by the advanced SNMP ALG implementation and for a given
   set of MIB modules.  The price paid for better transparency is
   additional complexity, potentially increased SNMP packet sizes and
   mixed up lexicographic ordering.  Especially with SNMPv3, there is an
   opportunity that communication fails due to increased packet sizes.
   Management applications that rely on lexicographic ordering will show
   erroneous behavior.

   Both, basic and advanced SNMP ALGs, introduce problems when using
   SNMPv3 security features.  The SNMPv3 authentication mechanism
   protects the whole SNMP message against modifications while the
   SNMPv3 privacy mechanism protects the payload of SNMPv3 messages
   against unauthorized access.  Thus, an SNMP ALG must have access to
   all localized keys in use in order to modify SNMPv3 messages without
   invalidating them.  Furthermore, the SNMP ALG must track any key
   changes in order to function.  More details on the security
   implications of using SNMP ALGs can be found in <a href="#section-6">Section 6</a>.

   Finally, an SNMP ALG only deals with SNMP traffic and does not modify
   the payload of any other protocol.  However, management systems
   usually use a set of protocols to manage a network.  In particular
   the telnet protocol is often used to configure or troubleshoot
   managed devices.  Hence, a management system and the human network
   operator must generally be aware that a network address translation
   is occurring, even in the presence of an SNMP ALG.

   A possible alternative to SNMP ALGs are SNMP proxies, as defined in
   <a href="rfc2573.html">RFC 2573</a> [<a href="#ref-11" title='"SNMP Applications"'>11</a>].  An SNMP proxy forwarder application forwards SNMP
   messages to other SNMP engines according to the context, and
   irrespective of the specific managed object types being accessed.
   The proxy forwarder also forwards the response to such previously
   forwarded messages back to the SNMP engine from which the original
   message was received.  Such a proxy forwarder can be used in a NAT
   environment to address SNMP engines with conflicting IP addresses.
   (Just replace the box SNMP ALG with a box labeled SNMP PROXY in
   Figure 2.)  The deployment of SNMP proxys has the advantage that
   different security levels can be used inside and outside of the
   conflicting addressing realms.





<span class="grey">Raz, et al.                  Informational                     [Page 11]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-12" id="page-12" name="page-12"> </a>
<span class="grey"><a href="rfc2962.html">RFC 2962</a>            SNMP Payload Address Translation        October 2000</span>


   The proxy solution, which is structurally preferable, requires that
   the management application is aware of the proxy situation.
   Furthermore, management applications have to use internal data
   structures for network elements that allow for conflicting IP
   addresses since conflicting IP addresses are not translated by the
   SNMP proxy.  Deployment of proxies may also involve the need to
   reconfigure network elements and management stations to direct their
   traffic (notifications and requests) to the proxy forwarder.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/6.%20Security%20Considerations"></a><a class="selflink" href="#section-6" name="section-6">6</a>. Security Considerations</span>

   SNMPv1 and SNMPv2c have very week security services based on
   community strings. All management information is sent in cleartext
   without encryption and/or authentication. In such an environment,
   SNMP messages can be modified by any intermediate node and management
   application are not able to verify the integrity of SNMP messages.
   Furthermore, an SNMP ALG does not need to have knowledge of the
   community strings in order to translate embedded IP addresses.  Thus,
   deployment of SNMP ALGs in an SNMPv1/SNMPv2c environment introduces
   no additional security problems.

   SNMPv3 supports three security levels: no authentication and no
   encryption (noAuth/noPriv), authentication and no encryption
   (auth/noPriv), and authentication and encryption (auth/priv).  SNMPv3
   messages without authentication and encryption (noAuth/noPriv) are
   send in cleartext.  In such a case the usage of SNMP ALGs introduces
   no additional security problems.

   However, the usage of SNMP ALG introduces new problems when SNMPv3
   authentication and optionally encryption is used.  First, SNMPv3
   messages with authentication and optionally encryption (auth/noPriv
   and auth/priv) can only be processed by an SNMP ALG which supports
   the corresponding cryptographic algorithms and which has access to
   the keys in use.  Furthermore, as keys may be updated, the SNMP ALG
   must have a mechanism that tracks key changes (either by analyzing
   the key change interactions or by propagating key changes by other
   mechanisms).  Second, the computational complexity of processing SNMP
   messages may increase dramatically.  The message has to be decrypted
   before the translation takes place.  If any translation is done the
   hash signature used to authenticate the message and to protect its
   integrity must be recomputed.

   In general, key exchange protocols are complicated and designing an
   SNMP ALG which maintains the keys for a set of SNMP engines is a
   non-trivial task. The User-based Security Model for SNMPv3 [<a href="#ref-12" title='"User-based Security Model (USM) for version 3 of the Simple Network Management Protocol (SNMPv3)"'>12</a>]
   defines a mechanism which takes a password and generates localized





<span class="grey">Raz, et al.                  Informational                     [Page 12]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-13" id="page-13" name="page-13"> </a>
<span class="grey"><a href="rfc2962.html">RFC 2962</a>            SNMP Payload Address Translation        October 2000</span>


   keys for every SNMP engine.  The localized keys have the property
   that a compromised single localized key does not automatically give
   an attacker access to other SNMP engines, even if the key for other
   SNMP engines is derived from the same password.

   An SNMP ALG implementation which maintains lists of (localized) keys
   is a potential target to attack the security of all the systems which
   use these keys.  An SNMP ALG implementation which maintains passwords
   in order to generate localized keys is a potential target to attack
   the security of all systems that use the same password.  Hence, an
   SNMP ALG implementation must be properly secured so that people who
   are not authorized to access keys or passwords can not access them.

   Finally, SNMP ALGs do not allow a network operator to use different
   security levels on both sides of the NAT.  Using a secure SNMP
   version outside of a private addressing realm while the private
   addressing realm runs an unsecured version of SNMP may be highly
   desirable in many scenarios, e.g. management outsourcing scenarios.
   The deployment of SNMPv3 proxies instead of SNMP ALGs should be
   considered in these cases since SNMP proxies can be configured to use
   different security levels and parameters on both sides of the
   proxies.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/7.%20Summary%20and%20Recommendations"></a><a class="selflink" href="#section-7" name="section-7">7</a>. Summary and Recommendations</span>

   Several approaches to address SNMP agents across NAT devices have
   been discussed in this memo.

   1.  Basic SNMP ALGs as described in <a href="#section-4.1">Section 4.1</a> provide very limited
       transparency since they only translate IPv4 addresses encoded in
       the IpAddress base type.  They are fast and efficient and may be
       sufficient to execute simple management applications (e.g.
       topology discovery applications) in a NAT environment. However,
       other management applications are likely to fail due to the
       limited transparency provided by a basic SNMP ALG.  Basic SNMP
       ALGs are problematic in a secure SNMP environment since they need
       to maintain lists of keys or passwords in order to function.
   2.  Advanced SNMP ALGs as described in <a href="#section-4.2">Section 4.2</a> provide better
       transparency.  They can be transparent for the set of data types
       they understand and for a given set of MIB modules.  However, an
       advanced SNMP ALG is much more complex and less efficiency than a
       basic SNMP ALG. An advanced SNMP ALG may break the lexicographic
       ordering when IP addresses are used to index conceptual tables
       and it may change the SNMP packet sizes.  Especially with SNMPv3,
       there is an opportunity that communication fails due to increased
       message sizes.  Advanced SNMP ALGs are problematic in a secure
       SNMP environment, since they need to maintain lists of keys or
       passwords in order to function.



<span class="grey">Raz, et al.                  Informational                     [Page 13]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-14" id="page-14" name="page-14"> </a>
<span class="grey"><a href="rfc2962.html">RFC 2962</a>            SNMP Payload Address Translation        October 2000</span>


   3.  SNMP proxies as described in <a href="rfc2573.html">RFC 2573</a> [<a href="#ref-11" title='"SNMP Applications"'>11</a>] allow management
       applications to access SNMP agents with conflicting IP addresses.
       No address translation is performed on the SNMP payload by an
       SNMP proxy forwarder.  Hence, management applications must be
       able to deal with network elements that have conflicting IP
       addresses.  This solution requires that management applications
       are aware of the proxy situation.  Deployment of proxies may also
       involve the need to reconfigure network elements and management
       stations to direct their traffic (notifications and requests) to
       the proxy forwarder.  SNMP proxies have the advantage that they
       allow to use different security levels inside and outside of a
       given addressing realm.

   It is recommended that network operators who need to manage networks
   in a NAT environment make a careful analysis before deploying a
   solution.  In particular, it must be analyzed whether the management
   applications will work with the transparency and the side-effects
   provided by SNMP ALGs.  Furthermore, it should be researched whether
   the management applications are able to deal with conflicting IP
   addresses for network devices.  Finally, the additional complexity
   introduced to the over all management system by using SNMP ALGs must
   be compared to the complexity introduced by the structurally
   preferable SNMP proxy forwarders.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/8.%20Current%20Implementations"></a><a class="selflink" href="#section-8" name="section-8">8</a>. Current Implementations</span>

   A basic SNMP ALG as described in <a href="#section-4.1">Section 4.1</a> was implemented for
   SNMPv1 at Bell-Labs, running on a Solaris Machine.  The solution
   described in Figure 2, where SNMP ALG was combined with the NAT
   implementation of Lucent's PortMaster3, was deployed successfully in
   a large network management service organization.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/9.%20Acknowledgments"></a><a class="selflink" href="#section-9" name="section-9">9</a>. Acknowledgments</span>

   We thank Pyda Srisuresh, for the support, encouragement, and advice
   throughout the work on this document.  We also thank Brett A. Denison
   for his contribution to the work that led to this document.
   Additional useful comments have been made by members of the NAT
   working group.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/10.%20References"></a><a class="selflink" href="#section-10" name="section-10">10</a>. References</span>

   [<a id="ref-1" name="ref-1">1</a>]  Postel, J., "Internet Protocol", STD 5, <a href="rfc791.html">RFC 791</a>, September 1981.

   [<a id="ref-2" name="ref-2">2</a>]  Case, J., Fedor, M., Schoffstall, M. and J. Davin, "A Simple
        Network Management Protocol (SNMP)", STD 15, <a href="rfc1157.html">RFC 1157</a>, May 1990.





<span class="grey">Raz, et al.                  Informational                     [Page 14]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-15" id="page-15" name="page-15"> </a>
<span class="grey"><a href="rfc2962.html">RFC 2962</a>            SNMP Payload Address Translation        October 2000</span>


   [<a id="ref-3" name="ref-3">3</a>]  Case, J., McCloghrie, K., Rose, M. and S. Waldbusser,
        "Introduction to Community-based SNMPv2", <a href="rfc1901.html">RFC 1901</a>, January
        1996.

   [<a id="ref-4" name="ref-4">4</a>]  Case, J., McCloghrie, K., Rose, M. and S. Waldbusser, "Protocol
        Operations for Version 2 of the Simple Network Management
        Protocol (SNMPv2)", <a href="rfc1905.html">RFC 1905</a>, January 1996.

   [<a id="ref-5" name="ref-5">5</a>]  Case, J., McCloghrie, K., Rose, M. and S. Waldbusser, "Transport
        Mappings for Version 2 of the Simple Network Management Protocol
        (SNMPv2)", <a href="rfc1906.html">RFC 1906</a>, January 1996.

   [<a id="ref-6" name="ref-6">6</a>]  McCloghrie, K., "SNMPv2 Management Information Base for the
        Internet Protocol using SMIv2", <a href="rfc2011.html">RFC 2011</a>, November 1996.

   [<a id="ref-7" name="ref-7">7</a>]  Waldbusser, S., "Remote Network Monitoring Management
        Information Base Version 2 using SMIv2", <a href="rfc2021.html">RFC 2021</a>, January 1997.

   [<a id="ref-8" name="ref-8">8</a>]  Haskin, D. and S. Onishi, "Management Information Base for IP
        Version 6: Textual Conventions and General Group", <a href="rfc2465.html">RFC 2465</a>,
        December 1998.

   [<a id="ref-9" name="ref-9">9</a>]  Case, J., Mundy, R., Partain, D. and B. Stewart, "Introduction
        to Version 3 of the Internet-standard Network Management
        Framework", <a href="rfc2570.html">RFC 2570</a>, April 1999.

   [<a id="ref-10" name="ref-10">10</a>] Case, J., Harrington, D., Presuhn, R. and B. Wijnen, "Message
        Processing and Dispatching for the Simple Network Management
        Protocol (SNMP)", <a href="rfc2572.html">RFC 2572</a>, April 1999.

   [<a id="ref-11" name="ref-11">11</a>] Levi, D., Meyer, P. and B. Stewart, "SNMP Applications", <a href="rfc2573.html">RFC</a>
        <a href="rfc2573.html">2573</a>, April 1999.

   [<a id="ref-12" name="ref-12">12</a>] Blumenthal, U. and B. Wijnen, "User-based Security Model (USM)
        for version 3 of the Simple Network Management Protocol
        (SNMPv3)", <a href="rfc2574.html">RFC 2574</a>, April 1999.

   [<a id="ref-13" name="ref-13">13</a>] ISO, "Information processing systems - Open Systems
        Interconnection - Specification of Abstract Syntax Notation One
        (ASN.1)", International Standard 8824, December 1987.

   [<a id="ref-14" name="ref-14">14</a>] ISO, "Information processing systems - Open Systems
        Interconnection - Specification of Basic Encoding Rules for
        Abstract Syntax Notation One (ASN.1)", International Standard
        8825, December 1987.

   [<a id="ref-15" name="ref-15">15</a>] Srisuresh, P. and M. Holdrege, "IP Network Address Translator
        (NAT) Terminology and Considerations", <a href="rfc2663.html">RFC 2663</a>, August 1999.



<span class="grey">Raz, et al.                  Informational                     [Page 15]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-16" id="page-16" name="page-16"> </a>
<span class="grey"><a href="rfc2962.html">RFC 2962</a>            SNMP Payload Address Translation        October 2000</span>


   [<a id="ref-16" name="ref-16">16</a>] Miller, M., "Managing Internetworks with SNMP", MT Books, 1997.

   [<a id="ref-17" name="ref-17">17</a>] Perkins, D. and E. McGinnis, "Understanding SNMP MIBs", Prentice
        Hall, ISBN 0-13-437708-7, 1997.

   [<a id="ref-18" name="ref-18">18</a>] Srisuresh, P. and K. Egevang, "Traditional IP Network Address
        Translator (Traditional NAT)", Work in Progress.

   [<a id="ref-19" name="ref-19">19</a>] Daniele, M., Haberman, B., Routhier, S. and J. Schoenwaelder,
        "Textual Conventions for Internet Network Addresses", <a href="rfc2851.html">RFC 2851</a>,
        June 2000.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/11.%20Authors%27%20Addresses"></a><a class="selflink" href="#section-11" name="section-11">11</a>. Authors' Addresses</span>

   Danny Raz
   Lucent Technologies
   101 Crawfords Corner Rd
   Holmdel, NJ  07733-3030
   USA

   Phone: +1 732 949-6712
   Fax:   +1 732 949-0399
   EMail: raz@lucent.com
   URI:   <a href="http://www.bell-labs.com/">http://www.bell-labs.com/</a>


   Juergen Schoenwaelder
   TU Braunschweig
   Bueltenweg 74/75
   38106 Braunschweig
   Germany

   Phone: +49 531 391-3266
   Fax:   +49 531 391-5936
   EMail: schoenw@ibr.cs.tu-bs.de
   URI:   <a href="http://www.ibr.cs.tu-bs.de/">http://www.ibr.cs.tu-bs.de/</a>


   Binay Sugla
   ISPSoft Inc.
   106 Apple Street
   Tinton Falls, NJ  07724
   USA

   Phone: +1 732 936-1763
   EMail: sugla@ispsoft.com
   URI:   <a href="http://www.ispsoft.com/">http://www.ispsoft.com/</a>




<span class="grey">Raz, et al.                  Informational                     [Page 16]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-17" id="page-17" name="page-17"> </a>
<span class="grey"><a href="rfc2962.html">RFC 2962</a>            SNMP Payload Address Translation        October 2000</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/12.%20Appendix%20A.%20Description%20of%20the%20Encoding%20of%20SNMP%20Packets"></a><a class="selflink" href="#section-12" name="section-12">12</a>. <a href="#appendix-A">Appendix A</a>. Description of the Encoding of SNMP Packets</span>

   SNMP packets use the ASN.1/BER encoding.  We will not cover the full
   details of this encoding in this document.  These details can be
   found in the International Standards ISO-8824 [<a href="#ref-13" title='"Information processing systems - Open Systems Interconnection - Specification of Abstract Syntax Notation One (ASN.1)"'>13</a>] and ISO-8825 [<a href="#ref-14" title='"Information processing systems - Open Systems Interconnection - Specification of Basic Encoding Rules for Abstract Syntax Notation One (ASN.1)"'>14</a>].
   A good description of ASN.1/BER can be found in the book "Managing
   Internetworks with SNMP", by M. A. Miller [<a href="#ref-16" title='"Managing Internetworks with SNMP"'>16</a>], or in <a href="#appendix-A">Appendix A</a> of
   the book "Understanding SNMP MIBs", by D. Perkins, and E. McGinnis
   [<a href="#ref-17" title='"Understanding SNMP MIBs"'>17</a>].

   Each variable that is referred to in an SNMP packet is uniquely
   identified by an OID (Object Identifier), usually written as a
   sequence of numbers separated by dots (e.g. 1.3.6.1.2.1.1.3.0).  Each
   variable also has an associated base type (this is not very accurate
   but good enough for this level of description).  One possible base
   type is the IpAddress type. The base type of each variable and its
   OID are conveyed by the ASN.1/BER encoding.  Note that it is possible
   to associate additional type information with a variable by using
   textual conventions.  The additional type semantics provided by
   textual conventions are not conveyed by the ASN.1/BER encoding.

   When a value of a variable is needed by a manager it sends a get-
   request PDU with the OID of that variable, and a NULL value.  The
   managed element then responds by sending a get-response PDU that
   contains the same OID, the base type of the variable, and the current
   value. Figure 4 shows an example of real data contained in an SNMPv1
   GetResponse PDU.

   The first 20 bytes contain the IPv4 4 header. The next 8 bytes
   contain the UDP header.  The last two bytes of the UDP header contain
   the UDP checksum (D3 65).  The next four bytes 30 82 00 3E are the
   beginning of the SNMP message: 30 is SEQUENCE, and 82 00 3E is the
   length of the data in the SEQUENCE in bytes (62).  The data in the
   SEQUENCE is the version (02 01 00) and the community string (04 06 70
   75 62 6C 69 63).  The last element in the SEQUENCE of the SNMPv1
   message is the SNMP PDU.















<span class="grey">Raz, et al.                  Informational                     [Page 17]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-18" id="page-18" name="page-18"> </a>
<span class="grey"><a href="rfc2962.html">RFC 2962</a>            SNMP Payload Address Translation        October 2000</span>


      +-----------------------------------------+
      |       IP Header                         |     45 00 00 5E
      |                                         |     47 40 00 00
      |                                         |     3F 11 39 00
      |                                         |     87 B4 8C CA
      |                                         |     87 B4 8C 16
      +-----------------------------------------+
      |       UDP Header                        |     00 A1 05 F5
      |                                         |     00 4A D3 65
      +-----------------------------------------+
      |       SNMP Message                      |     30 82 00 3E
      |  Version                     |          |     02 01 00 04
      |  Community                              |     06 70 75 62
      |                              |          |     6C 69 63 A2
      |   PDU Type                   |          |     82 00 2F 02
      |             Request ID                  |     04 6C F2 0C
      |           |       Error Status          |     5C 02 01 00
      |       Error Index            | SEQUENCE |     02 01 00 30
      |  OF                          | SEQUENCE |     82 00 1F 30
      |                              |   OID    |     82 00 1B 06
      |           |                             |     13 2B 06 01
      |                                         |     02 01 07 05
      |                                         |     01 01 81 40
      |                                         |     81 34 81 0C
      |                                         |     81 4A 84 08
      |  IpAddress          | 135    | 180      |     40 04 87 B4
      |  140      | 202     +-------------------+     8C CA
      +---------------------+

   The SNMP PDU itself is a tagged SEQUENCE: A2 indicates a GetResponse
   PDU and 82 00 2F is the length of the data in the GetResponse PDU in
   bytes (47).  The data in the GetResponse PDU is the request-id (02 04
   6C F2 0C 5C), the error-status (02 01 00), and the error-index (02 01
   00).  Now follow the variables which contain the real payload: A
   SEQUENCE OF of length 31 (30 82 00 1F) containing a SEQUENCE of
   length 27 (30 82 00 1B).  In it, the first object is an OID of length
   19 (06 13) with the value 1.3.6.1.2.1.7.5.1.1.192.180.140.202.520.
   The last 6 bytes 40 04 87 B4 8C CA represent an IpAddress: 40 is the
   identification of the base type IpAddress, 04 is the length, and the
   next four bytes are the IP address value (135.180.140.202).

   The example also shows an IP address embedded in an OID.  The OID
   prefix resolves to the udpLocalAddress of the UDP-MIB, which is
   indexed by the udpLocalAddress 192.180.140.202 (81 40 81 34 81 0C 81







<span class="grey">Raz, et al.                  Informational                     [Page 18]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-19" id="page-19" name="page-19"> </a>
<span class="grey"><a href="rfc2962.html">RFC 2962</a>            SNMP Payload Address Translation        October 2000</span>


   4A) and the udpLocalPort 520 (84 08). The SNMP packet actually shows
   an internal contradiction caused by a basic SNMP ALG since the
   udpLocalAddress encoded in the OID (192.180.140.202) is not equal to
   the value of the udpLocalAddress object instance (135.180.140.202).















































<span class="grey">Raz, et al.                  Informational                     [Page 19]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-20" id="page-20" name="page-20"> </a>
<span class="grey"><a href="rfc2962.html">RFC 2962</a>            SNMP Payload Address Translation        October 2000</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/13.%20%20Full%20Copyright%20Statement"></a><a class="selflink" href="#section-13" name="section-13">13</a>.  Full Copyright Statement</span>

   Copyright (C) The Internet Society (2000).  All Rights Reserved.

   This document and translations of it may be copied and furnished to
   others, and derivative works that comment on or otherwise explain it
   or assist in its implementation may be prepared, copied, published
   and distributed, in whole or in part, without restriction of any
   kind, provided that the above copyright notice and this paragraph are
   included on all such copies and derivative works.  However, this
   document itself may not be modified in any way, such as by removing
   the copyright notice or references to the Internet Society or other
   Internet organizations, except as needed for the purpose of
   developing Internet standards in which case the procedures for
   copyrights defined in the Internet Standards process must be
   followed, or as required to translate it into languages other than
   English.

   The limited permissions granted above are perpetual and will not be
   revoked by the Internet Society or its successors or assigns.

   This document and the information contained herein is provided on an
   "AS IS" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING
   TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING
   BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION
   HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF
   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.

Acknowledgement

   Funding for the RFC Editor function is currently provided by the
   Internet Society.



















Raz, et al.                  Informational                     [Page 20]

</pre><br/>
    <span class="noprint"><small><small>Html markup produced by rfcmarkup 1.126, available from
      <a href="https://tools.ietf.org/tools/rfcmarkup/">https://tools.ietf.org/tools/rfcmarkup/</a>
    </small></small></span>
  </div>




</body><!-- Mirrored from tools.ietf.org/html/rfc2962 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 06 Mar 2018 23:18:50 GMT --></html>