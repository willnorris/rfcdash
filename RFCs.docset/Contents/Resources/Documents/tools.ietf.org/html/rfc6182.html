<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml"><!-- Mirrored from tools.ietf.org/html/rfc6182 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 06 Mar 2018 23:18:31 GMT --><!-- Added by HTTrack --><head><meta content="text/html;charset=utf-8" http-equiv="content-type"/><!-- /Added by HTTrack -->

    <meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
    <meta content="index,follow" name="robots"/>
    <meta content="rfcmarkup version 1.126" name="creator"/>
    <link href="http://purl.org/dc/elements/1.1/" rel="schema.DC"/>
<meta content="draft-ford-mptcp-architecture" name="DC.Relation.Replaces"/>
<meta content="urn:ietf:rfc:6182" name="DC.Identifier"/>
<meta content="March, 2011" name="DC.Date.Issued"/>
<meta content="Handley, Mark" name="DC.Creator"/>
<meta content="Raiciu, Costin" name="DC.Creator"/>
<meta content="Ford, Alan" name="DC.Creator"/>
<meta content="Iyengar, Janardhan" name="DC.Creator"/>
<meta content="Barre, Sebastien" name="DC.Creator"/>
<meta content="Hosts are often connected by multiple paths, but TCP restricts
communications to a single path per transport connection. Resource
usage within the network would be more efficient were these multiple
paths able to be used concurrently. This should enhance user
experience through improved resilience to network failure and higher
throughput.  This document outlines architectural guidelines for the
development of a Multipath Transport Protocol, with references to how
these architectural components come together in the development of a
Multipath TCP protocol. This document lists certain high level design
decisions that provide foundations for the design of the MPTCP
protocol, based upon these architectural requirements." name="DC.Description.Abstract"/>
<meta content="Architectural Guidelines for Multipath TCP Development" name="DC.Title"/>

    <link href="https://tools.ietf.org/images/rfc.png" rel="icon" type="image/png"/>
    <link href="https://tools.ietf.org/images/rfc.png" rel="shortcut icon" type="image/png"/>
    <title>RFC 6182 - Architectural Guidelines for Multipath TCP Development</title>
    
    
    <style type="text/css">
	@media only screen 
	  and (min-width: 992px)
	  and (max-width: 1199px) {
	    body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 768px)
	  and (max-width: 991px) {
            body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 480px)
	  and (max-width: 767px) {
            body { font-size: 11pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (max-width: 479px) {
            body { font-size: 8pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-device-width : 375px) 
	  and (max-device-width : 667px) {
            body { font-size: 9.5pt; }
            div.content { width: 96ex; margin: 0 1px; }
        }
	@media only screen 
	  and (min-device-width: 1200px) {
            body { font-size: 10pt; margin: 0 4em; }
            div.content { width: 96ex; margin: 0; }
        }
        h1, h2, h3, h4, h5, h6, .h1, .h2, .h3, .h4, .h5, .h6 {
	    font-weight: bold;
            line-height: 0pt;
            display: inline;
            white-space: pre;
            font-family: monospace;
            font-size: 1em;
	    font-weight: bold;
        }
        pre {
            font-size: 1em;
            margin-top: 0px;
            margin-bottom: 0px;
        }
	.pre {
	    white-space: pre;
	    font-family: monospace;
	}
	.header{
	    font-weight: bold;
	}
        .newpage {
            page-break-before: always;
        }
        .invisible {
            text-decoration: none;
            color: white;
        }
        a.selflink {
          color: black;
          text-decoration: none;
        }
        @media print {
            body {
                font-family: monospace;
                font-size: 10.5pt;
            }
            h1, h2, h3, h4, h5, h6 {
                font-size: 1em;
            }
        
            a:link, a:visited {
                color: inherit;
                text-decoration: none;
            }
            .noprint {
                display: none;
            }
        }
	@media screen {
	    .grey, .grey a:link, .grey a:visited {
		color: #777;
	    }
            .docinfo {
                background-color: #EEE;
            }
            .top {
                border-top: 7px solid #EEE;
            }
            .bgwhite  { background-color: white; }
            .bgred    { background-color: #F44; }
            .bggrey   { background-color: #666; }
            .bgbrown  { background-color: #840; }            
            .bgorange { background-color: #FA0; }
            .bgyellow { background-color: #EE0; }
            .bgmagenta{ background-color: #F4F; }
            .bgblue   { background-color: #66F; }
            .bgcyan   { background-color: #4DD; }
            .bggreen  { background-color: #4F4; }

            .legend   { font-size: 90%; }
            .cplate   { font-size: 70%; border: solid grey 1px; }
	}
    </style>
    <!--[if IE]>
    <style>
    body {
       font-size: 13px;
       margin: 10px 10px;
    }
    </style>
    <![endif]-->

    <script type="text/javascript"><!--
    function addHeaderTags() {
	var spans = document.getElementsByTagName("span");
	for (var i=0; i < spans.length; i++) {
	    var elem = spans[i];
	    if (elem) {
		var level = elem.getAttribute("class");
                if (level == "h1" || level == "h2" || level == "h3" || level == "h4" || level == "h5" || level == "h6") {
                    elem.innerHTML = "<"+level+">"+elem.innerHTML+"</"+level+">";		
                }
	    }
	}
    }
    var legend_html = "Colour legend:<br />      <table>         <tr><td>Unknown:</td>                   <td><span class='cplate bgwhite'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft:</td>                     <td><span class='cplate bgred'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Informational:</td>             <td><span class='cplate bgorange'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Experimental:</td>              <td><span class='cplate bgyellow'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Best Common Practice:</td>      <td><span class='cplate bgmagenta'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Proposed Standard:</td>         <td><span class='cplate bgblue'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft Standard (old designation):</td> <td><span class='cplate bgcyan'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Internet Standard:</td>         <td><span class='cplate bggreen'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Historic:</td>                  <td><span class='cplate bggrey'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Obsolete:</td>                  <td><span class='cplate bgbrown'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>     </table>";
    function showElem(id) {
        var elem = document.getElementById(id);
        elem.innerHTML = eval(id+"_html");
        elem.style.visibility='visible';
    }
    function hideElem(id) {
        var elem = document.getElementById(id);
        elem.style.visibility='hidden';        
        elem.innerHTML = "";
    }
    // -->
    </script>
</head>
<body onload="addHeaderTags()">
  <div class="content">
   <div style="height: 13px;">
      <div class="pre noprint docinfo bgorange" onclick="showElem('legend');" onmouseout="hideElem('legend')" onmouseover="this.style.cursor='pointer';" style="height: 6px; position: absolute;" title="Click for colour legend.">                                                                        </div>
      <div class="docinfo noprint pre legend" id="legend" onmouseout="hideElem('legend');" onmouseover="showElem('legend');" style="position:absolute; top: 4px; left: 4ex; visibility:hidden; background-color: white; padding: 4px 9px 5px 7px; border: solid #345 1px; ">
      </div>
   </div>
<span class="pre noprint docinfo top">[<a href="index.html" title="Document search and retrieval page">Docs</a>] [<a href="https://tools.ietf.org/rfc/rfc6182.txt" title="Plaintext version of this document">txt</a>|<a href="https://tools.ietf.org/pdf/rfc6182" title="PDF version of this document">pdf</a>] [<a href="https://tools.ietf.org/html/draft-ietf-mptcp-architecture" title="draft-ietf-mptcp-architecture">draft-ietf-mptc...</a>] [<a href="https://datatracker.ietf.org/doc/rfc6182" title="IESG Datatracker information for this document">Tracker</a>] [<a href="https://tools.ietf.org/rfcdiff?difftype=--hwdiff&amp;url2=rfc6182" title="Inline diff (wdiff)">Diff1</a>] [<a href="https://tools.ietf.org/rfcdiff?url2=rfc6182" title="Side-by-side diff">Diff2</a>]         </span><br/>
<span class="pre noprint docinfo">                                                                        </span><br/>
<span class="pre noprint docinfo">                                                           INFORMATIONAL</span><br/>
<span class="pre noprint docinfo">                                                                        </span><br/>
<pre>Internet Engineering Task Force (IETF)                           A. Ford
Request for Comments: 6182                           Roke Manor Research
Category: Informational                                        C. Raiciu
ISSN: 2070-1721                                               M. Handley
                                               University College London
                                                                S. Barre
                                        Universite catholique de Louvain
                                                              J. Iyengar
                                           Franklin and Marshall College
                                                              March 2011


         <span class="h1">Architectural Guidelines for Multipath TCP Development</span>

Abstract

   Hosts are often connected by multiple paths, but TCP restricts
   communications to a single path per transport connection.  Resource
   usage within the network would be more efficient were these multiple
   paths able to be used concurrently.  This should enhance user
   experience through improved resilience to network failure and higher
   throughput.

   This document outlines architectural guidelines for the development
   of a Multipath Transport Protocol, with references to how these
   architectural components come together in the development of a
   Multipath TCP (MPTCP).  This document lists certain high-level design
   decisions that provide foundations for the design of the MPTCP
   protocol, based upon these architectural requirements.

Status of This Memo

   This document is not an Internet Standards Track specification; it is
   published for informational purposes.

   This document is a product of the Internet Engineering Task Force
   (IETF).  It represents the consensus of the IETF community.  It has
   received public review and has been approved for publication by the
   Internet Engineering Steering Group (IESG).  Not all documents
   approved by the IESG are a candidate for any level of Internet
   Standard; see <a href="rfc5741.html#section-2">Section 2 of RFC 5741</a>.

   Information about the current status of this document, any errata,
   and how to provide feedback on it may be obtained at
   <a href="http://www.rfc-editor.org/info/rfc6182">http://www.rfc-editor.org/info/rfc6182</a>.






<span class="grey">Ford, et al.                  Informational                     [Page 1]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-2" id="page-2" name="page-2"> </a>
<span class="grey"><a href="rfc6182.html">RFC 6182</a>                   MPTCP Architecture                 March 2011</span>


Copyright Notice

   Copyright (c) 2011 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to <a href="https://tools.ietf.org/html/bcp78">BCP 78</a> and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (<a href="http://trustee.ietf.org/license-info">http://trustee.ietf.org/license-info</a>) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.





































<span class="grey">Ford, et al.                  Informational                     [Page 2]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-3" id="page-3" name="page-3"> </a>
<span class="grey"><a href="rfc6182.html">RFC 6182</a>                   MPTCP Architecture                 March 2011</span>


Table of Contents

   <a href="#section-1">1</a>. Introduction ....................................................<a href="#page-4">4</a>
      <a href="#section-1.1">1.1</a>. Requirements Language ......................................<a href="#page-5">5</a>
      <a href="#section-1.2">1.2</a>. Terminology ................................................<a href="#page-5">5</a>
      <a href="#section-1.3">1.3</a>. Reference Scenario .........................................<a href="#page-6">6</a>
   <a href="#section-2">2</a>. Goals ...........................................................<a href="#page-6">6</a>
      <a href="#section-2.1">2.1</a>. Functional Goals ...........................................<a href="#page-6">6</a>
      <a href="#section-2.2">2.2</a>. Compatibility Goals ........................................<a href="#page-7">7</a>
           <a href="#section-2.2.1">2.2.1</a>. Application Compatibility ...........................<a href="#page-7">7</a>
           <a href="#section-2.2.2">2.2.2</a>. Network Compatibility ...............................<a href="#page-8">8</a>
           <a href="#section-2.2.3">2.2.3</a>. Compatibility with Other Network Users .............<a href="#page-10">10</a>
      <a href="#section-2.3">2.3</a>. Security Goals ............................................<a href="#page-10">10</a>
      <a href="#section-2.4">2.4</a>. Related Protocols .........................................<a href="#page-10">10</a>
   <a href="#section-3">3</a>. An Architectural Basis for Multipath TCP .......................<a href="#page-11">11</a>
   <a href="#section-4">4</a>. A Functional Decomposition of MPTCP ............................<a href="#page-12">12</a>
   <a href="#section-5">5</a>. High-Level Design Decisions ....................................<a href="#page-14">14</a>
      <a href="#section-5.1">5.1</a>. Sequence Numbering ........................................<a href="#page-14">14</a>
      <a href="#section-5.2">5.2</a>. Reliability and Retransmissions ...........................<a href="#page-15">15</a>
      <a href="#section-5.3">5.3</a>. Buffers ...................................................<a href="#page-17">17</a>
      <a href="#section-5.4">5.4</a>. Signaling .................................................<a href="#page-18">18</a>
      <a href="#section-5.5">5.5</a>. Path Management ...........................................<a href="#page-19">19</a>
      <a href="#section-5.6">5.6</a>. Connection Identification .................................<a href="#page-20">20</a>
      <a href="#section-5.7">5.7</a>. Congestion Control ........................................<a href="#page-21">21</a>
      <a href="#section-5.8">5.8</a>. Security ..................................................<a href="#page-21">21</a>
   <a href="#section-6">6</a>. Software Interactions ..........................................<a href="#page-23">23</a>
      <a href="#section-6.1">6.1</a>. Interactions with Applications ............................<a href="#page-23">23</a>
      <a href="#section-6.2">6.2</a>. Interactions with Management Systems ......................<a href="#page-23">23</a>
   <a href="#section-7">7</a>. Interactions with Middleboxes ..................................<a href="#page-23">23</a>
   <a href="#section-8">8</a>. Contributors ...................................................<a href="#page-25">25</a>
   <a href="#section-9">9</a>. Acknowledgements ...............................................<a href="#page-25">25</a>
   <a href="#section-10">10</a>. Security Considerations .......................................<a href="#page-26">26</a>
   <a href="#section-11">11</a>. References ....................................................<a href="#page-26">26</a>
      <a href="#section-11.1">11.1</a>. Normative References .....................................<a href="#page-26">26</a>
      <a href="#section-11.2">11.2</a>. Informative References ...................................<a href="#page-26">26</a>
















<span class="grey">Ford, et al.                  Informational                     [Page 3]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-4" id="page-4" name="page-4"> </a>
<span class="grey"><a href="rfc6182.html">RFC 6182</a>                   MPTCP Architecture                 March 2011</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/1.%20%20Introduction"></a><a class="selflink" href="#section-1" name="section-1">1</a>.  Introduction</span>

   As the Internet evolves, demands on Internet resources are ever-
   increasing, but often these resources (in particular, bandwidth)
   cannot be fully utilized due to protocol constraints both on the end-
   systems and within the network.  If these resources could be used
   concurrently, end user experience could be greatly improved.  Such
   enhancements would also reduce the necessary expenditure on network
   infrastructure that would otherwise be needed to create an equivalent
   improvement in user experience.  By the application of resource
   pooling [<a href="#ref-3" title='"The Resource Pooling Principle"'>3</a>], these available resources can be 'pooled' such that they
   appear as a single logical resource to the user.

   Multipath transport aims to realize some of the goals of resource
   pooling by simultaneously making use of multiple disjoint (or
   partially disjoint) paths across a network.  The two key benefits of
   multipath transport are the following:

   o  To increase the resilience of the connectivity by providing
      multiple paths, protecting end hosts from the failure of one.

   o  To increase the efficiency of the resource usage, and thus
      increase the network capacity available to end hosts.

   Multipath TCP is a modified version of TCP [<a href="#ref-1" title='"Transmission Control Protocol"'>1</a>] that implements a
   multipath transport and achieves these goals by pooling multiple
   paths within a transport connection, transparently to the
   application.  Multipath TCP is primarily concerned with utilizing
   multiple paths end-to-end, where one or both of the end hosts are
   multihomed.  It may also have applications where multiple paths exist
   within the network and can be manipulated by an end host, such as
   using different port numbers with Equal Cost MultiPath (ECMP) [<a href="#ref-4" title='"Analysis of an Equal-Cost Multi-Path Algorithm"'>4</a>].

   MPTCP, defined in [<a href="#ref-5" title='"TCP Extensions for Multipath Operation with Multiple Addresses"'>5</a>], is a specific protocol that instantiates the
   Multipath TCP concept.  This document looks both at general
   architectural principles for a Multipath TCP fulfilling the goals
   described in <a href="#section-2">Section 2</a>, as well as the key design decisions behind
   MPTCP, which are detailed in <a href="#section-5">Section 5</a>.

   Although multihoming and multipath functions are not new to transport
   protocols (Stream Control Transmission Protocol (SCTP) [<a href="#ref-6" title='"Stream Control Transmission Protocol"'>6</a>] being a
   notable example), MPTCP aims to gain wide-scale deployment by
   recognizing the importance of application and network compatibility
   goals.  These goals, discussed in detail in <a href="#section-2">Section 2</a>, relate to the
   appearance of MPTCP to the network (so non-MPTCP-aware entities see
   it as TCP) and to the application (through providing a service
   equivalent to TCP for non-MPTCP-aware applications).




<span class="grey">Ford, et al.                  Informational                     [Page 4]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-5" id="page-5" name="page-5"> </a>
<span class="grey"><a href="rfc6182.html">RFC 6182</a>                   MPTCP Architecture                 March 2011</span>


   This document has three key purposes: (i) it describes goals for a
   multipath transport -- goals that MPTCP is designed to meet; (ii) it
   lays out an architectural basis for MPTCP's design -- a discussion
   that applies to other multipath transports as well; and (iii) it
   discusses and documents high-level design decisions made in MPTCP's
   development, and considers their implications.

   Companion documents to this architectural overview are those that
   provide details of the protocol extensions [<a href="#ref-5" title='"TCP Extensions for Multipath Operation with Multiple Addresses"'>5</a>], congestion control
   algorithms [<a href="#ref-7" title='"Coupled Congestion Control for Multipath Transport Protocols"'>7</a>], and application-level considerations [<a href="#ref-8" title='"MPTCP Application Interface Considerations"'>8</a>].  Put
   together, these components specify a complete Multipath TCP design.
   Note that specific components are replaceable in accordance with the
   layer and functional decompositions discussed in this document.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/1.1.%20%20Requirements%20Language"></a><a class="selflink" href="#section-1.1" name="section-1.1">1.1</a>.  Requirements Language</span>

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in <a href="rfc2119.html">RFC 2119</a> [<a href="#ref-2" title='"Key words for use in RFCs to Indicate Requirement Levels"'>2</a>].

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/1.2.%20%20Terminology"></a><a class="selflink" href="#section-1.2" name="section-1.2">1.2</a>.  Terminology</span>

   Regular/Single-Path TCP:  The standard version of TCP [<a href="#ref-1" title='"Transmission Control Protocol"'>1</a>] in use
      today, operating between a single pair of IP addresses and ports.

   Multipath TCP:  A modified version of the TCP protocol that supports
      the simultaneous use of multiple paths between hosts.

   Path:  A sequence of links between a sender and a receiver, defined
      in this context by a source and destination address pair.

   Host:  An end host either initiating or terminating a Multipath TCP
      connection.

   MPTCP:  The proposed protocol extensions specified in [<a href="#ref-5" title='"TCP Extensions for Multipath Operation with Multiple Addresses"'>5</a>] to provide
      a Multipath TCP implementation.

   Subflow:  A flow of TCP segments operating over an individual path,
      which forms part of a larger Multipath TCP connection.

   (Multipath TCP) Connection:  A set of one or more subflows combined
      to provide a single Multipath TCP service to an application at a
      host.








<span class="grey">Ford, et al.                  Informational                     [Page 5]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-6" id="page-6" name="page-6"> </a>
<span class="grey"><a href="rfc6182.html">RFC 6182</a>                   MPTCP Architecture                 March 2011</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/1.3.%20%20Reference%20Scenario"></a><a class="selflink" href="#section-1.3" name="section-1.3">1.3</a>.  Reference Scenario</span>

   The diagram shown in Figure 1 illustrates a typical usage scenario
   for Multipath TCP.  Two hosts, A and B, are communicating with each
   other.  These hosts are multihomed and multi-addressed, providing two
   disjoint connections to the Internet.  The addresses on each host are
   referred to as A1, A2, B1, and B2.  There are therefore up to four
   different paths between the two hosts: A1-B1, A1-B2, A2-B1, A2-B2.

               +------+           __________           +------+
               |      |A1 ______ (          ) ______ B1|      |
               | Host |--/      (            )      \--| Host |
               |      |        (   Internet   )        |      |
               |  A   |--\______(            )______/--|   B  |
               |      |A2        (__________)        B2|      |
               +------+                                +------+

               Figure 1: Simple Multipath TCP Usage Scenario

   The scenario could have any number of addresses (1 or more) on each
   host, as long as the number of paths available between the two hosts
   is 2 or more (i.e., num_addr(A) * num_addr(B) &gt; 1).  The paths
   created by these address combinations through the Internet need not
   be entirely disjoint -- potential fairness issues introduced by
   shared bottlenecks need to be handled by the Multipath TCP congestion
   controller.  Furthermore, the paths through the Internet often do not
   provide a pure end-to-end service, and instead may be affected by
   middleboxes such as NATs and firewalls.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/2.%20%20Goals"></a><a class="selflink" href="#section-2" name="section-2">2</a>.  Goals</span>

   This section outlines primary goals that Multipath TCP aims to meet.
   These are broadly broken down into the following: functional goals,
   which steer services and features that Multipath TCP must provide,
   and compatibility goals, which determine how Multipath TCP should
   appear to entities that interact with it.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/2.1.%20%20Functional%20Goals"></a><a class="selflink" href="#section-2.1" name="section-2.1">2.1</a>.  Functional Goals</span>

   In supporting the use of multiple paths, Multipath TCP has the
   following two functional goals.

   o  Improve Throughput: Multipath TCP MUST support the concurrent use
      of multiple paths.  To meet the minimum performance incentives for
      deployment, a Multipath TCP connection over multiple paths SHOULD
      achieve no worse throughput than a single TCP connection over the
      best constituent path.




<span class="grey">Ford, et al.                  Informational                     [Page 6]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-7" id="page-7" name="page-7"> </a>
<span class="grey"><a href="rfc6182.html">RFC 6182</a>                   MPTCP Architecture                 March 2011</span>


   o  Improve Resilience: Multipath TCP MUST support the use of multiple
      paths interchangeably for resilience purposes, by permitting
      segments to be sent and re-sent on any available path.  It follows
      that, in the worst case, the protocol MUST be no less resilient
      than regular single-path TCP.

   As distribution of traffic among available paths and responses to
   congestion are done in accordance with resource pooling principles
   [<a href="#ref-3" title='"The Resource Pooling Principle"'>3</a>], a secondary effect of meeting these goals is that widespread use
   of Multipath TCP over the Internet should improve overall network
   utility by shifting load away from congested bottlenecks and by
   taking advantage of spare capacity wherever possible.

   Furthermore, Multipath TCP SHOULD feature automatic negotiation of
   its use.  A host supporting Multipath TCP that requires the other
   host to do so too must be able to detect reliably whether this host
   does in fact support the required extensions, using them if so, and
   otherwise automatically falling back to single-path TCP.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/2.2.%20%20Compatibility%20Goals"></a><a class="selflink" href="#section-2.2" name="section-2.2">2.2</a>.  Compatibility Goals</span>

   In addition to the functional goals listed above, a Multipath TCP
   must meet a number of compatibility goals in order to support
   deployment in today's Internet.  These goals fall into the following
   categories.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/2.2.1.%20%20Application%20Compatibility"></a><a class="selflink" href="#section-2.2.1" name="section-2.2.1">2.2.1</a>.  Application Compatibility</span>

   Application compatibility refers to the appearance of Multipath TCP
   to the application both in terms of the API that can be used and the
   expected service model that is provided.

   Multipath TCP MUST follow the same service model as TCP [<a href="#ref-1" title='"Transmission Control Protocol"'>1</a>]: in-
   order, reliable, and byte-oriented delivery.  Furthermore, a
   Multipath TCP connection SHOULD provide the application with no worse
   throughput or resilience than it would expect from running a single
   TCP connection over any one of its available paths.  A Multipath TCP
   may not, however, be able to provide the same level of consistency of
   throughput and latency as a single TCP connection.  These, and other,
   application considerations are discussed in detail in [<a href="#ref-8" title='"MPTCP Application Interface Considerations"'>8</a>].

   A multipath-capable equivalent of TCP MUST retain some level of
   backward compatibility with existing TCP APIs, so that existing
   applications can use the newer transport merely by upgrading the
   operating systems of the end hosts.  This does not preclude the use
   of an advanced API to permit multipath-aware applications to specify





<span class="grey">Ford, et al.                  Informational                     [Page 7]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-8" id="page-8" name="page-8"> </a>
<span class="grey"><a href="rfc6182.html">RFC 6182</a>                   MPTCP Architecture                 March 2011</span>


   preferences, nor for users to configure their systems in a different
   way from the default, for example switching on or off the automatic
   use of multipath extensions.

   It is possible for regular TCP sessions today to survive brief breaks
   in connectivity by retaining state at end hosts before a timeout
   occurs.  It would be desirable to support similar session continuity
   in MPTCP; however, the circumstances could be different.  Whilst in
   regular TCP the IP addresses will remain constant across the break in
   connectivity, in MPTCP a different interface may appear.  It is
   desirable (but not mandated) to support this kind of "break-before-
   make" session continuity.  This places constraints on security
   mechanisms, however, as discussed in <a href="#section-5.8">Section 5.8</a>.  Timeouts for this
   function would be locally configured.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/2.2.2.%20%20Network%20Compatibility"></a><a class="selflink" href="#section-2.2.2" name="section-2.2.2">2.2.2</a>.  Network Compatibility</span>

   In the traditional Internet architecture, network devices operate at
   the network layer and lower layers, with the layers above the network
   layer instantiated only at the end hosts.  While this architecture,
   shown in Figure 2, was initially largely adhered to, this layering no
   longer reflects the "ground truth" in the Internet with the
   proliferation of middleboxes [<a href="#ref-9" title='"Middleboxes: Taxonomy and Issues"'>9</a>].  Middleboxes routinely interpose on
   the transport layer; sometimes even completely terminating transport
   connections, thus leaving the application layer as the first real
   end-to-end layer, as shown in Figure 3.

   +-------------+                                       +-------------+
   | Application |&lt;------------ end-to-end -------------&gt;| Application |
   +-------------+                                       +-------------+
   |  Transport  |&lt;------------ end-to-end -------------&gt;|  Transport  |
   +-------------+   +-------------+   +-------------+   +-------------+
   |   Network   |&lt;-&gt;|   Network   |&lt;-&gt;|   Network   |&lt;-&gt;|   Network   |
   +-------------+   +-------------+   +-------------+   +-------------+
      End Host           Router             Router          End Host

                Figure 2: Traditional Internet Architecture














<span class="grey">Ford, et al.                  Informational                     [Page 8]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-9" id="page-9" name="page-9"> </a>
<span class="grey"><a href="rfc6182.html">RFC 6182</a>                   MPTCP Architecture                 March 2011</span>


   +-------------+                                       +-------------+
   | Application |&lt;------------ end-to-end -------------&gt;| Application |
   +-------------+                     +-------------+   +-------------+
   |  Transport  |&lt;-------------------&gt;|  Transport  |&lt;-&gt;|  Transport  |
   +-------------+   +-------------+   +-------------+   +-------------+
   |   Network   |&lt;-&gt;|   Network   |&lt;-&gt;|   Network   |&lt;-&gt;|   Network   |
   +-------------+   +-------------+   +-------------+   +-------------+
                                          Firewall,
      End Host           Router         NAT, or Proxy      End Host

                        Figure 3: Internet Reality

   Middleboxes that interpose on the transport layer result in loss of
   "fate-sharing" [<a href="#ref-10" title='"Internet Transparency"'>10</a>], that is, they often hold "hard" state that, when
   lost or corrupted, results in loss or corruption of the end-to-end
   transport connection.

   The network compatibility goal requires that the multipath extension
   to TCP retain compatibility with the Internet as it exists today,
   including making reasonable efforts to be able to traverse
   predominant middleboxes such as firewalls, NATs, and performance-
   enhancing proxies [<a href="#ref-9" title='"Middleboxes: Taxonomy and Issues"'>9</a>].  This requirement comes from recognizing
   middleboxes as a significant deployment bottleneck for any transport
   that is not TCP or UDP, and constrains Multipath TCP to appear as TCP
   does on the wire and to use established TCP extensions where
   necessary.  To ensure "end-to-endness" of the transport, Multipath
   TCP MUST preserve fate-sharing without making any assumptions about
   middlebox behavior.

   A detailed analysis of middlebox behavior and the impact on the
   Multipath TCP architecture is presented in <a href="#section-7">Section 7</a>.  In addition,
   network compatibility must be retained to the extent that Multipath
   TCP MUST fall back to regular TCP if there are insurmountable
   incompatibilities for the multipath extension on a path.

   Middleboxes may also cause some TCP features to be able to exist on
   one subflow but not another.  Typically, these will be at the subflow
   level (such as selective acknowledgment (SACK) [<a href="#ref-11" title='"TCP Selective Acknowledgment Options"'>11</a>]) and thus do not
   affect the connection-level behavior.  In the future, any proposed
   TCP connection-level extensions should consider how they can coexist
   with MPTCP.

   The modifications to support Multipath TCP remain at the transport
   layer, although some knowledge of the underlying network layer is
   required.  Multipath TCP SHOULD work with IPv4 and IPv6
   interchangeably, i.e., one connection may operate over both IPv4 and
   IPv6 networks.




<span class="grey">Ford, et al.                  Informational                     [Page 9]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-10" id="page-10" name="page-10"> </a>
<span class="grey"><a href="rfc6182.html">RFC 6182</a>                   MPTCP Architecture                 March 2011</span>


<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/2.2.3.%20%20Compatibility%20with%20Other%20Network%20Users"></a><a class="selflink" href="#section-2.2.3" name="section-2.2.3">2.2.3</a>.  Compatibility with Other Network Users</span>

   As a corollary to both network and application compatibility, the
   architecture must enable new Multipath TCP flows to coexist
   gracefully with existing single-path TCP flows, competing for
   bandwidth neither unduly aggressively nor unduly timidly (unless low-
   precedence operation is specifically requested by the application,
   such as with LEDBAT).  The use of multiple paths MUST NOT unduly harm
   users using single-path TCP at shared bottlenecks, beyond the impact
   that would occur from another single-path TCP flow.  Multiple
   Multipath TCP flows on a shared bottleneck MUST share bandwidth
   between each other with similar fairness to that which occurs at a
   shared bottleneck with single-path TCP.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/2.3.%20%20Security%20Goals"></a><a class="selflink" href="#section-2.3" name="section-2.3">2.3</a>.  Security Goals</span>

   The extension of TCP with multipath capabilities will bring with it a
   number of new threats, analyzed in detail in [<a href="#ref-12" title='"Threat Analysis for TCP Extensions for Multipath Operation with Multiple Addresses"'>12</a>].  The security goal
   for Multipath TCP is to provide a service no less secure than
   regular, single-path TCP.  This will be achieved through a
   combination of existing TCP security mechanisms (potentially modified
   to align with the Multipath TCP extensions) and of protection against
   the new multipath threats identified.  The design decisions derived
   from this goal are presented in <a href="#section-5.8">Section 5.8</a>.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/2.4.%20%20Related%20Protocols"></a><a class="selflink" href="#section-2.4" name="section-2.4">2.4</a>.  Related Protocols</span>

   There are several similarities between SCTP [<a href="#ref-6" title='"Stream Control Transmission Protocol"'>6</a>] and MPTCP, in that
   both can make use of multiple addresses at end hosts to give some
   multipath capability.  In SCTP, the primary use case is to support
   redundancy and mobility for multihomed hosts (i.e., a single path
   will change one of its end host addresses); the simultaneous use of
   multiple paths is not supported.  Extensions are proposed to support
   simultaneous multipath transport [<a href="#ref-13" title='"Load Sharing for the Stream Control Transmission Protocol (SCTP)"'>13</a>], but these are yet to be
   standardized.  By far the most widely used stream-based transport
   protocol is, however, TCP [<a href="#ref-1" title='"Transmission Control Protocol"'>1</a>], and SCTP does not meet the network and
   application compatibility goals specified in <a href="#section-2.2">Section 2.2</a>.  For
   network compatibility, there are issues with various middleboxes
   (especially NATs) that are unaware of SCTP and consequently end up
   blocking it.  For application compatibility, applications need to
   actively choose to use SCTP, and with the deployment issues, very few
   choose to do so.  MPTCP's compatibility goals are in part based on
   these observations of SCTP's deployment issues.








<span class="grey">Ford, et al.                  Informational                    [Page 10]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-11" id="page-11" name="page-11"> </a>
<span class="grey"><a href="rfc6182.html">RFC 6182</a>                   MPTCP Architecture                 March 2011</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/3.%20%20An%20Architectural%20Basis%20for%20Multipath%20TCP"></a><a class="selflink" href="#section-3" name="section-3">3</a>.  An Architectural Basis for Multipath TCP</span>

   This section presents one possible transport architecture that the
   authors believe can effectively support the goals for Multipath TCP.
   The new Internet model described here is based on ideas proposed
   earlier in Tng ("Transport next-generation") [<a href="#ref-14" title='"Breaking Up the Transport Logjam"'>14</a>].  While by no means
   the only possible architecture supporting multipath transport, Tng
   incorporates many lessons learned from previous transport research
   and development practice, and offers a strong starting point from
   which to consider the extant Internet architecture and its bearing on
   the design of any new Internet transports or transport extensions.

          +------------------+
          |    Application   |
          +------------------+  ^ Application-oriented transport
          |                  |  | functions (Semantic Layer)
          + - - Transport - -+ ----------------------------------
          |                  |  | Network-oriented transport
          +------------------+  v functions (Flow+Endpoint Layer)
          |      Network     |
          +------------------+
            Existing Layers             Tng Decomposition

              Figure 4: Decomposition of Transport Functions

   Tng loosely splits the transport layer into "application-oriented"
   and "network-oriented" layers, as shown in Figure 4.  The
   application-oriented "Semantic" layer implements functions driven
   primarily by concerns of supporting and protecting the application's
   end-to-end communication, while the network-oriented "Flow+Endpoint"
   layer implements functions such as endpoint identification (using
   port numbers) and congestion control.  These network-oriented
   functions, while traditionally located in the ostensibly "end-to-end"
   Transport layer, have proven in practice to be of great concern to
   network operators and the middleboxes they deploy in the network to
   enforce network usage policies [<a href="#ref-15" title='"Traditional IP Network Address Translator (Traditional NAT)"'>15</a>] [<a href="#ref-16" title='"Behavior of and Requirements for Internet Firewalls"'>16</a>] or optimize communication
   performance [<a href="#ref-17" title='"Performance Enhancing Proxies Intended to Mitigate Link-Related Degradations"'>17</a>].  Figure 5 shows how middleboxes interact with
   different layers in this decomposed model of the transport layer: the
   application-oriented layer operates end-to-end, while the network-
   oriented layer operates "segment-by-segment" and can be interposed
   upon by middleboxes.










<span class="grey">Ford, et al.                  Informational                    [Page 11]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-12" id="page-12" name="page-12"> </a>
<span class="grey"><a href="rfc6182.html">RFC 6182</a>                   MPTCP Architecture                 March 2011</span>


   +-------------+                                       +-------------+
   | Application |&lt;------------ end-to-end -------------&gt;| Application |
   +-------------+                                       +-------------+
   |  Semantic   |&lt;------------ end-to-end -------------&gt;|  Semantic   |
   +-------------+   +-------------+   +-------------+   +-------------+
   |Flow+Endpoint|&lt;-&gt;|Flow+Endpoint|&lt;-&gt;|Flow+Endpoint|&lt;-&gt;|Flow+Endpoint|
   +-------------+   +-------------+   +-------------+   +-------------+
   |   Network   |&lt;-&gt;|   Network   |&lt;-&gt;|   Network   |&lt;-&gt;|   Network   |
   +-------------+   +-------------+   +-------------+   +-------------+
                        Firewall         Performance
      End Host           or NAT        Enhancing Proxy      End Host

              Figure 5: Middleboxes in the New Internet Model

   MPTCP's architectural design follows Tng's decomposition as shown in
   Figure 6.  MPTCP, which provides application compatibility through
   the preservation of TCP-like semantics of global ordering of
   application data and reliability, is an instantiation of the
   "application-oriented" Semantic layer; whereas the subflow TCP
   component, which provides network compatibility by appearing and
   behaving as a TCP flow in the network, is an instantiation of the
   "network-oriented" Flow+Endpoint layer.

     +--------------------------+    +-------------------------------+
     |      Application         |    |          Application          |
     +--------------------------+    +-------------------------------+
     |        Semantic          |    |             MPTCP             |
     |------------+-------------|    + - - - - - - - + - - - - - - - +
     | Flow+Endpt | Flow+Endpt  |    | Subflow (TCP) | Subflow (TCP) |
     +------------+-------------+    +---------------+---------------+
     |   Network  |   Network   |    |       IP      |       IP      |
     +------------+-------------+    +---------------+---------------+

        Figure 6: Relationship between Tng (Left) and MPTCP (Right)

   As a protocol extension to TCP, MPTCP thus explicitly acknowledges
   middleboxes in its design, and specifies a protocol that operates at
   two scales: the MPTCP component operates end-to-end, while it allows
   the TCP component to operate segment-by-segment.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/4.%20%20A%20Functional%20Decomposition%20of%20MPTCP"></a><a class="selflink" href="#section-4" name="section-4">4</a>.  A Functional Decomposition of MPTCP</span>

   The previous two sections have discussed the goals for a Multipath
   TCP design, and provided a basis for decomposing the functions of a
   transport protocol in order to better understand the form a solution
   should take.  This section builds upon this analysis by presenting
   the functional components that are used within the MPTCP design.




<span class="grey">Ford, et al.                  Informational                    [Page 12]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-13" id="page-13" name="page-13"> </a>
<span class="grey"><a href="rfc6182.html">RFC 6182</a>                   MPTCP Architecture                 March 2011</span>


   MPTCP makes use of (what appear to the network to be) standard TCP
   sessions, termed "subflows", to provide the underlying transport per
   path, and as such these retain the network compatibility desired.
   MPTCP-specific information is carried in a TCP-compatible manner,
   although this mechanism is separate from the actual information being
   transferred so could evolve in future revisions.  Figure 7
   illustrates the layered architecture.

                                   +-------------------------------+
                                   |           Application         |
      +---------------+            +-------------------------------+
      |  Application  |            |             MPTCP             |
      +---------------+            + - - - - - - - + - - - - - - - +
      |      TCP      |            | Subflow (TCP) | Subflow (TCP) |
      +---------------+            +-------------------------------+
      |      IP       |            |       IP      |      IP       |
      +---------------+            +-------------------------------+

      Figure 7: Comparison of Standard TCP and MPTCP Protocol Stacks

   Situated below the application, the MPTCP extension in turn manages
   multiple TCP subflows below it.  In order to do this, it must
   implement the following functions:

   o  Path Management: This is the function to detect and use multiple
      paths between two hosts.  MPTCP uses the presence of multiple IP
      addresses at one or both of the hosts as an indicator of this.
      The path management features of the MPTCP protocol are the
      mechanisms to signal alternative addresses to hosts, and
      mechanisms to set up new subflows joined to an existing MPTCP
      connection.

   o  Packet Scheduling: This function breaks the byte stream received
      from the application into segments to be transmitted on one of the
      available subflows.  The MPTCP design makes use of a data sequence
      mapping, associating segments sent on different subflows to a
      connection-level sequence numbering, thus allowing segments sent
      on different subflows to be correctly re-ordered at the receiver.
      The packet scheduler is dependent upon information about the
      availability of paths exposed by the path management component,
      and then makes use of the subflows to transmit queued segments.
      This function is also responsible for connection-level re-ordering
      on receipt of packets from the TCP subflows, according to the
      attached data sequence mappings.

   o  Subflow (single-path TCP) Interface: A subflow component takes
      segments from the packet-scheduling component and transmits them
      over the specified path, ensuring detectable delivery to the host.



<span class="grey">Ford, et al.                  Informational                    [Page 13]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-14" id="page-14" name="page-14"> </a>
<span class="grey"><a href="rfc6182.html">RFC 6182</a>                   MPTCP Architecture                 March 2011</span>


      MPTCP uses TCP underneath for network compatibility; TCP ensures
      in-order, reliable delivery.  TCP adds its own sequence numbers to
      the segments; these are used to detect and retransmit lost packets
      at the subflow layer.  On receipt, the subflow passes its
      reassembled data to the packet scheduling component for
      connection-level reassembly; the data sequence mapping from the
      sender's packet scheduling component allows re-ordering of the
      entire byte stream.

   o  Congestion Control: This function coordinates congestion control
      across the subflows.  As specified, this congestion control
      algorithm MUST ensure that an MPTCP connection does not unfairly
      take more bandwidth than a single path TCP flow would take at a
      shared bottleneck.  An algorithm to support this is specified in
      [<a href="#ref-7" title='"Coupled Congestion Control for Multipath Transport Protocols"'>7</a>].

   These functions fit together as follows.  The path management looks
   after the discovery (and if necessary, initialization) of multiple
   paths between two hosts.  The packet scheduler then receives a stream
   of data from the application destined for the network, and undertakes
   the necessary operations on it (such as segmenting the data into
   connection-level segments, and adding a connection-level sequence
   number) before sending it on to a subflow.  The subflow then adds its
   own sequence number, ACKs, and passes them to network.  The receiving
   subflow re-orders data (if necessary) and passes it to the packet
   scheduling component, which performs connection level re-ordering,
   and sends the data stream to the application.  Finally, the
   congestion control component exists as part of the packet scheduling,
   in order to schedule which segments should be sent at what rate on
   which subflow.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/5.%20%20High-Level%20Design%20Decisions"></a><a class="selflink" href="#section-5" name="section-5">5</a>.  High-Level Design Decisions</span>

   There is seemingly a wide range of choices when designing a multipath
   extension to TCP.  However, the goals as discussed earlier in this
   document constrain the possible solutions, leaving relative little
   choice in many areas.  This section outlines high-level design
   choices that draw from the architectural basis discussed earlier in
   <a href="#section-3">Section 3</a>, which the design of MPTCP [<a href="#ref-5" title='"TCP Extensions for Multipath Operation with Multiple Addresses"'>5</a>] takes into account.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.1.%20%20Sequence%20Numbering"></a><a class="selflink" href="#section-5.1" name="section-5.1">5.1</a>.  Sequence Numbering</span>

   MPTCP uses two levels of sequence spaces: a connection-level sequence
   number and another sequence number for each subflow.  This permits
   connection-level segmentation and reassembly and retransmission of
   the same part of connection-level sequence space on different
   subflow-level sequence space.




<span class="grey">Ford, et al.                  Informational                    [Page 14]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-15" id="page-15" name="page-15"> </a>
<span class="grey"><a href="rfc6182.html">RFC 6182</a>                   MPTCP Architecture                 March 2011</span>


   The alternative approach would be to use a single connection-level
   sequence number, which gets sent on multiple subflows.  This has two
   problems: first, the individual subflows will appear to the network
   as TCP sessions with gaps in the sequence space; this in turn may
   upset certain middleboxes such as intrusion detection systems, or
   certain transparent proxies, and would thus go against the network
   compatibility goal.  Second, the sender would not be able to
   attribute packet losses or receptions to the correct path when the
   same segment is sent on multiple paths (i.e., in the case of
   retransmissions).

   The sender must be able to tell the receiver how to reassemble the
   data, for delivery to the application.  In order to achieve this, the
   receiver must determine how subflow-level data (carrying subflow
   sequence numbers) maps at the connection level.  This is referred to
   as the "data sequence mapping".  This mapping can be represented as a
   tuple of (data sequence number, subflow sequence number, length),
   i.e., for a given number of bytes (the length), the subflow sequence
   space beginning at the given sequence number maps to the connection-
   level sequence space (beginning at the given data sequence number).
   This information could conceivably have various sources.

   One option to signal the data sequence mapping would be to use
   existing fields in the TCP segment (such as subflow sequence number,
   length) and add only the data sequence number to each segment, for
   instance, as a TCP option.  This would be vulnerable, however, to
   middleboxes that re-segment or assemble data, since there is no
   specified behavior for coalescing TCP options.  If one signaled (data
   sequence number, length), this would still be vulnerable to
   middleboxes that coalesce segments and do not understand MPTCP
   signaling so do not correctly rewrite the options.

   Because of these potential issues, the design decision taken in the
   MPTCP protocol is that whenever a mapping for subflow data needs to
   be conveyed to the other host, all three pieces of data (data seq,
   subflow seq, length) must be sent.  To reduce the overhead, it would
   be permissible for the mapping to be sent periodically and cover more
   than a single segment.  Further experimentation is required to
   determine what tradeoffs exist regarding the frequency at which
   mappings should be sent.  It could also be excluded entirely in the
   case of a connection before more than one subflow is used, where the
   data-level and subflow-level sequence space is the same.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.2.%20%20Reliability%20and%20Retransmissions"></a><a class="selflink" href="#section-5.2" name="section-5.2">5.2</a>.  Reliability and Retransmissions</span>

   MPTCP features acknowledgements at connection-level as well as
   subflow-level acknowledgements, in order to provide a robust service
   to the application.



<span class="grey">Ford, et al.                  Informational                    [Page 15]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-16" id="page-16" name="page-16"> </a>
<span class="grey"><a href="rfc6182.html">RFC 6182</a>                   MPTCP Architecture                 March 2011</span>


   Under normal behavior, MPTCP could use the data sequence mapping and
   subflow ACKs to decide when a connection-level segment was received.
   The transmission of TCP ACKs for a subflow are handled entirely at
   the subflow level, in order to maintain TCP semantics and trigger
   subflow-level retransmissions.  This has certain implications on end-
   to-end semantics.  It would mean that once a segment is ACKed at the
   subflow level, it cannot be discarded in the re-order buffer at the
   connection level.  Secondly, unlike in standard TCP, a receiver
   cannot simply drop out-of-order segments if needed (for instance, due
   to memory pressure).  Under certain circumstances, it may be
   desirable to drop segments after acknowledgement on the subflow but
   before delivery to the application, and this can be facilitated by a
   connection-level acknowledgement.

   Furthermore, it is possible to conceive of some cases where
   connection-level acknowledgements could improve robustness.  Consider
   a subflow traversing a transparent proxy: if the proxy ACKs a segment
   and then crashes, the sender will not retransmit the lost segment on
   another subflow, as it thinks the segment has been received.  The
   connection grinds to a halt despite having other working subflows,
   and the sender would be unable to determine the cause of the problem.
   An example situation where this may occur would be mobility between
   wireless access points, each of which operates a transport-level
   proxy.  Finally, as an optimization, it may be feasible for a
   connection-level acknowledgement to be transmitted over the shortest
   Round-Trip Time (RTT) path, potentially reducing send buffer
   requirements (see <a href="#section-5.3">Section 5.3</a>).

   Therefore, to provide a fully robust multipath TCP solution given the
   above constraints, MPTCP for use on the public Internet MUST feature
   explicit connection-level acknowledgements, in addition to subflow-
   level acknowledgements.  A connection-level acknowledgement would
   only be required in order to signal when the receive window moves
   forward; the heuristics for using such a signal are discussed in more
   detail in the protocol specification [<a href="#ref-5" title='"TCP Extensions for Multipath Operation with Multiple Addresses"'>5</a>].

   Regarding retransmissions, it MUST be possible for a segment to be
   retransmitted on a different subflow from that on which it was
   originally sent.  This is one of MPTCP's core goals, in order to
   maintain integrity during temporary or permanent subflow failure, and
   this is enabled by the dual sequence number space.

   The scheduling of retransmissions will have significant impact on
   MPTCP user experience.  The current MPTCP specification suggests that
   data outstanding on subflows that have timed out should be
   rescheduled for transmission on different subflows.  This behavior





<span class="grey">Ford, et al.                  Informational                    [Page 16]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-17" id="page-17" name="page-17"> </a>
<span class="grey"><a href="rfc6182.html">RFC 6182</a>                   MPTCP Architecture                 March 2011</span>


   aims to minimize disruption when a path breaks, and uses the first
   timeout as indicators.  More conservative versions would be to use
   second or third timeouts for the same segment.

   Typically, fast retransmit on an individual subflow will not trigger
   retransmission on another subflow, although this may still be
   desirable in certain cases, for instance, to reduce the receive
   buffer requirements.  However, in all cases with retransmissions on
   different subflows, the lost segments SHOULD still be sent on the
   path that lost them.  This is currently believed to be necessary to
   maintain subflow integrity, as per the network compatibility goal.
   By doing this, some efficiency is lost, and it is unclear at this
   point what the optimal retransmit strategy is.

   Large-scale experiments are therefore required in order to determine
   the most appropriate retransmission strategy, and recommendations
   will be refined once more information is available.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.3.%20%20Buffers"></a><a class="selflink" href="#section-5.3" name="section-5.3">5.3</a>.  Buffers</span>

   To ensure in-order delivery, MPTCP must use a connection level
   receive buffer, where segments are placed until they are in order and
   can be read by the application.

   In regular, single-path TCP, it is usually recommended to set the
   receive buffer to 2*BDP (Bandwidth-Delay Product, i.e., BDP = BW*RTT,
   where BW = Bandwidth and RTT = Round-Trip Time).  One BDP allows
   supporting reordering of segments by the network.  The other BDP
   allows the connection to continue during fast retransmit: when a
   segment is fast retransmitted, the receiver must be able to store
   incoming data during one more RTT.

   For MPTCP, the story is a bit more complicated.  The ultimate goal is
   that a subflow packet loss or subflow failure should not affect the
   throughput of other working subflows; the receiver should have enough
   buffering to store all data until the missing segment is re-
   transmitted and reaches the destination.

   The worst-case scenario would be when the subflow with the highest
   RTT/RTO (Round-Trip Time or Retransmission TimeOut) experiences a
   timeout; in that case, the receiver has to buffer data from all
   subflows for the duration of the RTO.  Thus, the smallest connection-
   level receive buffer that would be needed to avoid stalling with
   subflow failures is sum(BW_i)*RTO_max, where BW_i = Bandwidth for
   each subflow and RTO_max is the largest RTO across all subflows.






<span class="grey">Ford, et al.                  Informational                    [Page 17]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-18" id="page-18" name="page-18"> </a>
<span class="grey"><a href="rfc6182.html">RFC 6182</a>                   MPTCP Architecture                 March 2011</span>


   This is an order of magnitude more than the receive buffer required
   for a single connection, and is probably too expensive for practical
   purposes.  A more sensible requirement is to avoid stalls in the
   absence of timeouts.  Therefore, the RECOMMENDED receive buffer is
   2*sum(BW_i)*RTT_max, where RTT_max is the largest RTT across all
   subflows.  This buffer sizing ensures subflows do not stall when fast
   retransmit is triggered on any subflow.

   The resulting buffer size should be small enough for practical use.
   However, there may be extreme cases where fast, high throughput paths
   (e.g., 100 Mb/s, 10 ms RTT) are used in conjunction with slow paths
   (e.g., 1 Mb/s, 1000 ms RTT).  In that case, the required receive
   buffer would be 12.5 MB, which is likely too big.  In extreme cases
   such as this example, it may be prudent to only use some of the
   fastest available paths for the MPTCP connection, potentially using
   the slow path(s) for backup only.

   Send Buffer: The RECOMMENDED send buffer is the same size as the
   recommended receive buffer, i.e., 2*sum(BW_i)*RTT_max.  This is
   because the sender must locally store the segments sent but
   unacknowledged by the connection level ACK.  The send buffer size
   matters particularly for hosts that maintain a large number of
   ongoing connections.  If the required send buffer is too large, a
   host can choose to only send data on the fast subflows, using the
   slow subflows only in cases of failure.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.4.%20%20Signaling"></a><a class="selflink" href="#section-5.4" name="section-5.4">5.4</a>.  Signaling</span>

   Since MPTCP uses TCP as its subflow transport mechanism, an MPTCP
   connection will also begin as a single TCP connection.  Nevertheless,
   it must signal to the peer that it supports MPTCP and wishes to use
   it on this connection.  As such, a TCP option will be used to
   transmit this information, since this is the established mechanism
   for indicating additional functionality on a TCP session.

   In addition, further signaling is required during the operation of an
   MPTCP session, such as that for reassembly across multiple subflows,
   and for informing the other host about other available IP addresses.

   The MPTCP protocol design will use TCP options for this additional
   signaling.  This has been chosen as the mechanism most fitting in
   with the goals as specified in <a href="#section-2">Section 2</a>.  With this mechanism, the
   signaling required to operate MPTCP is transported separately from
   the data, allowing it to be created and processed separately from the
   data stream, and retaining architectural compatibility with network
   entities.





<span class="grey">Ford, et al.                  Informational                    [Page 18]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-19" id="page-19" name="page-19"> </a>
<span class="grey"><a href="rfc6182.html">RFC 6182</a>                   MPTCP Architecture                 March 2011</span>


   This decision is the consensus of the Working Group (following
   detailed discussions at IETF78), and the main reasons for this are as
   follows:

   o  TCP options are the traditional signaling method for TCP;

   o  A TCP option on a SYN is the most compatible way for an end host
      to signal it is MPTCP capable;

   o  If connection-level ACKs are signaled in the payload, then they
      may suffer from packet loss and may be congestion-controlled,
      which may affect the data throughput in the forward direction and
      could lead to head-of-line blocking;

   o  Middleboxes, such as NAT traversal helpers, can easily parse TCP
      options, e.g., to rewrite addresses.

   On the other hand, the main drawbacks of TCP options compared to TLV
   encoding in the payload are the following:

   o  There is limited space for signaling messages;

   o  A middlebox may, potentially, drop a packet with an unknown
      option;

   o  The transport of control information in options is not necessarily
      reliable.

   The detailed design of MPTCP alleviates these issues as far as
   possible by carefully considering the size of MPTCP options and
   seamlessly falling back to regular TCP on the loss of control data.

   Both option and payload encoding may interfere with offloading of TCP
   processing to high-speed network interface cards, such as
   segmentation, checksumming, and reassembly.  For network cards
   supporting MPTCP, signaling in TCP options should simplify offloading
   due to the separate handling of MPTCP signaling and data.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.5.%20%20Path%20Management"></a><a class="selflink" href="#section-5.5" name="section-5.5">5.5</a>.  Path Management</span>

   Currently, the network does not expose path diversity between pairs
   of IP addresses.  In order to achieve path diversity from today's IP
   networks, in the typical case, MPTCP uses multiple addresses at one
   or both hosts to infer different paths across the network.  It is
   expected that these paths, whilst not necessarily entirely non-
   overlapping, will be sufficiently disjoint to allow multipath to





<span class="grey">Ford, et al.                  Informational                    [Page 19]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-20" id="page-20" name="page-20"> </a>
<span class="grey"><a href="rfc6182.html">RFC 6182</a>                   MPTCP Architecture                 March 2011</span>


   achieve improved throughput and robustness.  The use of multiple IP
   addresses is a simple mechanism that requires no additional features
   in the network.

   Multiple different (source, destination) address pairs will thus be
   used as path selectors in most cases.  However, each path will be
   identified by a standard five-tuple (i.e., source address,
   destination address, source port, destination port, protocol), which
   can allow the extension of MPTCP to use ports as well as addresses as
   path selectors.  This will allow hosts to use port-based load
   balancing with MPTCP, for example, if the network routes different
   ports over different paths (which may be the case with technologies
   such as Equal Cost MultiPath (ECMP) routing [<a href="#ref-4" title='"Analysis of an Equal-Cost Multi-Path Algorithm"'>4</a>]).  It should be
   noted, however, that ISPs often undertake traffic engineering in
   order to optimize resource utilization within their networks, and
   care should be taken (by both ISPs and developers) that MPTCP using
   broadly similar paths does not adversely interfere with this.

   For an increased chance of successfully setting up additional
   subflows (such as when one end is behind a firewall, NAT, or other
   restrictive middlebox), either host SHOULD be able to add new
   subflows to an MPTCP connection.  MPTCP MUST be able to handle paths
   that appear and disappear during the lifetime of a connection (for
   example, through the activation of an additional network interface).

   The path management is a separate function from the packet
   scheduling, subflow interface, and congestion control functions of
   MPTCP, as documented in <a href="#section-4">Section 4</a>.  As such, it would be feasible to
   replace this IP-address-based design with an alternative path
   selection mechanism in the future, with no significant changes to the
   other functional components.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.6.%20%20Connection%20Identification"></a><a class="selflink" href="#section-5.6" name="section-5.6">5.6</a>.  Connection Identification</span>

   Since an MPTCP connection may not be bound to a traditional 5-tuple
   (source address and port, destination address and port, protocol
   number) for the entirety of its existence, it is desirable to provide
   a new mechanism for connection identification.  This will be useful
   for MPTCP-aware applications and for the MPTCP implementation (and
   MPTCP-aware middleboxes) to have a unique identifier with which to
   associate the multiple subflows.

   Therefore, each MPTCP connection requires a connection identifier at
   each host, which is locally unique within that host.  In many ways,
   this is analogous to an ephemeral port number in regular TCP.  The
   manifestation and purpose of such an identifier is out of the scope
   of this architecture document.




<span class="grey">Ford, et al.                  Informational                    [Page 20]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-21" id="page-21" name="page-21"> </a>
<span class="grey"><a href="rfc6182.html">RFC 6182</a>                   MPTCP Architecture                 March 2011</span>


   Non-MPTCP-aware applications will not, however, have access to this
   identifier and in such cases an MPTCP connection will be identified
   by the 5-tuple of the first TCP subflow.  It is out of the scope of
   this document, however, to define the behavior of the MPTCP
   implementation if the first TCP subflow later fails.  If there are
   MPTCP-unaware applications that make assumptions about continued
   existence of the initial address pair, their behavior could be
   disrupted by carrying on regardless.  It is expected that this is a
   very small, possibly negligible, set of applications, however.  MPTCP
   MUST NOT be used for applications that request to bind to a specific
   address or interface, since such applications are making a deliberate
   choice of path in use.

   Since the requirements of applications are not clear at this stage,
   however, it is as yet unconfirmed whether carrying on in the event of
   the loss of the initial address pair would be a damaging assumption
   to make.  This behavior will be an implementation-specific solution,
   and as such it is expected to be chosen by implementors once more
   research has been undertaken to determine its impact.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.7.%20%20Congestion%20Control"></a><a class="selflink" href="#section-5.7" name="section-5.7">5.7</a>.  Congestion Control</span>

   As discussed in network-layer compatibility requirements
   <a href="#section-2.2.3">Section 2.2.3</a>, there are three goals for the congestion control
   algorithms used by an MPTCP implementation: improve throughput (at
   least as well as a single-path TCP connection would perform); do no
   harm to other network users (do not take up more capacity on any one
   path than if it was a single path flow using only that route -- this
   is particularly relevant for shared bottlenecks); and balance
   congestion by moving traffic away from the most congested paths.  To
   achieve these goals, the congestion control algorithms on each
   subflow must be coupled in some way.  A proposal for a suitable
   congestion control algorithm is given in [<a href="#ref-7" title='"Coupled Congestion Control for Multipath Transport Protocols"'>7</a>].

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.8.%20%20Security"></a><a class="selflink" href="#section-5.8" name="section-5.8">5.8</a>.  Security</span>

   A detailed threat analysis for Multipath TCP is presented in a
   separate document [<a href="#ref-12" title='"Threat Analysis for TCP Extensions for Multipath Operation with Multiple Addresses"'>12</a>].  That document focuses on flooding attacks
   and hijacking attacks that can be launched against a Multipath TCP
   connection.

   The basic security goal of Multipath TCP, as introduced in
   <a href="#section-2.3">Section 2.3</a>, can be stated as: "provide a solution that is no worse
   than standard TCP".







<span class="grey">Ford, et al.                  Informational                    [Page 21]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-22" id="page-22" name="page-22"> </a>
<span class="grey"><a href="rfc6182.html">RFC 6182</a>                   MPTCP Architecture                 March 2011</span>


   From the threat analysis, and with this goal in mind, three key
   security requirements can be identified.  A multi-addressed Multipath
   TCP SHOULD be able to do the following:

   o  Provide a mechanism to confirm that the parties in a subflow
      handshake are the same as in the original connection setup (e.g.,
      require use of a key exchanged in the initial handshake in the
      subflow handshake, to limit the scope for hijacking attacks).

   o  Provide verification that the peer can receive traffic at a new
      address before adding it (i.e., verify that the address belongs to
      the other host, to prevent flooding attacks).

   o  Provide replay protection, i.e., ensure that a request to add/
      remove a subflow is 'fresh'.

   Additional mechanisms have been deployed as part of standard TCP
   stacks to provide resistance to Denial-of-Service (DoS) attacks.  For
   example, there are various mechanisms to protect against TCP reset
   attacks [<a href="#ref-18" title="&quot;Improving TCP's Robustness to Blind In-Window Attacks&quot;">18</a>], and Multipath TCP should continue to support similar
   protection.  In addition, TCP SYN Cookies [<a href="#ref-19" title='"TCP SYN Flooding Attacks and Common Mitigations"'>19</a>] were developed to
   allow a TCP server to defer the creation of session state in the
   SYN_RCVD state, and remain stateless until the ESTABLISHED state had
   been reached.  Multipath TCP should, ideally, continue to provide
   such functionality and, at a minimum, avoid significant computational
   burden prior to reaching the ESTABLISHED state (of the Multipath TCP
   connection as a whole).

   It should be noted that aspects of the Multipath TCP design space
   place constraints on the security solution:

   o  The use of TCP options significantly limits the amount of
      information that can be carried in the handshake.

   o  The need to work through middleboxes results in the need to handle
      mutability of packets.

   o  The desire to support a 'break-before-make' (as well as a 'make-
      before-break') approach to adding subflows (within a limited time
      period) implies that a host cannot rely on using a pre-existing
      subflow to support the addition of a new one.

   The MPTCP protocol will be designed with these security requirements
   in mind, and the protocol specification [<a href="#ref-5" title='"TCP Extensions for Multipath Operation with Multiple Addresses"'>5</a>] will document how these
   are met.






<span class="grey">Ford, et al.                  Informational                    [Page 22]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-23" id="page-23" name="page-23"> </a>
<span class="grey"><a href="rfc6182.html">RFC 6182</a>                   MPTCP Architecture                 March 2011</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/6.%20%20Software%20Interactions"></a><a class="selflink" href="#section-6" name="section-6">6</a>.  Software Interactions</span>

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/6.1.%20%20Interactions%20with%20Applications"></a><a class="selflink" href="#section-6.1" name="section-6.1">6.1</a>.  Interactions with Applications</span>

   In the case of applications that have used an existing API call to
   bind to a specific address or interface, the MPTCP extension MUST NOT
   be used.  This is because the applications are indicating a clear
   choice of path to use and thus will have expectations of behavior
   that must be maintained, in order to adhere to the application
   compatibility goals.

   Interactions with applications are presented in [<a href="#ref-8" title='"MPTCP Application Interface Considerations"'>8</a>] -- including, but
   not limited to, performances changes that may be expected, semantic
   changes, and new features that may be requested through an enhanced
   API.

   TCP features the ability to send "Urgent" data, the delivery of which
   to the application may or may not be out-of-band.  The use of this
   feature is not recommended due to security implications and
   implementation differences [<a href="#ref-20" title='"On the Implementation of the TCP Urgent Mechanism"'>20</a>].  MPTCP requires contiguous data to
   support its data sequence mapping over multiple segments, and
   therefore the Urgent pointer cannot interrupt an existing mapping.
   An MPTCP implementation MAY choose to support sending Urgent data,
   and if it does, it SHOULD send the Urgent data on the soonest
   available unassigned subflow sequence space.  Incoming Urgent data
   SHOULD be mapped to connection-level sequence space and delivered to
   the application analogous to Urgent data in regular TCP.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/6.2.%20%20Interactions%20with%20Management%20Systems"></a><a class="selflink" href="#section-6.2" name="section-6.2">6.2</a>.  Interactions with Management Systems</span>

   To enable interactions between TCP and network management systems,
   the TCP [<a href="#ref-21" title='"Management Information Base for the Transmission Control Protocol (TCP)"'>21</a>] and TCP Extended Statistics (ESTATS) [<a href="#ref-22" title='"TCP Extended Statistics MIB"'>22</a>] MIBs have been
   defined.  MPTCP should share these MIBs for aspects that are designed
   to be transparent to the application.

   It is anticipated that an MPTCP MIB will be defined in the future,
   once experience of experimental MPTCP deployments is gathered.  This
   MIB would provide access to MPTCP-specific properties such as whether
   MPTCP is enabled and the number and properties of the individual
   paths in use.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/7.%20%20Interactions%20with%20Middleboxes"></a><a class="selflink" href="#section-7" name="section-7">7</a>.  Interactions with Middleboxes</span>

   As discussed in <a href="#section-2.2">Section 2.2</a>, it is a goal of MPTCP to be deployable
   today and thus compatible with the majority of middleboxes.  This
   section summarizes the issues that may arise with NATs, firewalls,
   proxies, intrusion detection systems, and other middleboxes that, if
   not considered in the protocol design, may hinder its deployment.



<span class="grey">Ford, et al.                  Informational                    [Page 23]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-24" id="page-24" name="page-24"> </a>
<span class="grey"><a href="rfc6182.html">RFC 6182</a>                   MPTCP Architecture                 March 2011</span>


   This section is intended primarily as a description of options and
   considerations only.  Protocol-specific solutions to these issues
   will be given in the companion documents.

   Multipath TCP will be deployed in a network that no longer provides
   just basic datagram delivery.  A myriad of middleboxes are deployed
   to optimize various perceived problems with the Internet protocols:
   NATs primarily address IP address space shortage [<a href="#ref-15" title='"Traditional IP Network Address Translator (Traditional NAT)"'>15</a>], Performance
   Enhancing Proxies (PEPs) optimize TCP for different link
   characteristics [<a href="#ref-17" title='"Performance Enhancing Proxies Intended to Mitigate Link-Related Degradations"'>17</a>], firewalls [<a href="#ref-16" title='"Behavior of and Requirements for Internet Firewalls"'>16</a>] and intrusion detection systems
   try to block malicious content from reaching a host, and traffic
   normalizers [<a href="#ref-23" title='"Network Intrusion Detection: Evasion, Traffic Normalization, and End-to-End Protocol Semantics"'>23</a>] ensure a consistent view of the traffic stream to
   Intrusion Detection Systems (IDS) and hosts.

   All these middleboxes optimize current applications at the expense of
   future applications.  In effect, future applications will often need
   to behave in a similar fashion to existing ones, in order to increase
   the chances of successful deployment.  Further, the precise behavior
   of all these middleboxes is not clearly specified, and implementation
   errors make matters worse, raising the bar for the deployment of new
   technologies.

   The following list of middlebox classes documents behavior that could
   impact the use of MPTCP.  This list is used in [<a href="#ref-5" title='"TCP Extensions for Multipath Operation with Multiple Addresses"'>5</a>] to describe the
   features of the MPTCP protocol that are used to mitigate the impact
   of these middlebox behaviors.

   o  NATs: Network Address Translators decouple the host's local IP
      address (and, in the case of NAPTs, port) with that which is seen
      in the wider Internet when the packets are transmitted through a
      NAT.  This adds complexity, and reduces the chances of success,
      when signaling IP addresses.

   o  PEPs: Performance Enhancing Proxies, which aim to improve the
      performance of protocols over low-performance (e.g., high-latency
      or high-error-rate) links.  As such, they may "split" a TCP
      connection and behavior such as proactive ACKing may occur, and
      therefore it is no longer guaranteed that one host is
      communicating directly with another.  PEPs, firewalls, or other
      middleboxes may also change the declared receive window size.

   o  Traffic Normalizers: These aim to eliminate ambiguities and
      potential attacks at the network level, and amongst other things,
      are unlikely to permit holes in TCP-level sequence space (which
      has an impact on MPTCP's retransmission and subflow sequence
      numbering design choices).





<span class="grey">Ford, et al.                  Informational                    [Page 24]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-25" id="page-25" name="page-25"> </a>
<span class="grey"><a href="rfc6182.html">RFC 6182</a>                   MPTCP Architecture                 March 2011</span>


   o  Firewalls: on top of preventing incoming connections, firewalls
      may also attempt additional protection such as sequence number
      randomization (so a sender cannot reliably know what TCP sequence
      number the receiver will see).

   o  IDSs: Intrusion Detection Systems may look for traffic patterns to
      protect a network and may have false positives with MPTCP and drop
      the connections during normal operation.  Future MPTCP-aware
      middleboxes will require the ability to correlate the various
      paths in use.

   o  Content-Aware Firewalls: Some middleboxes may actively change data
      in packets, such as rewriting URIs in HTTP traffic.

   In addition, all classes of middleboxes may affect TCP traffic in the
   following ways:

   o  TCP Options: some middleboxes may drop packets with unknown TCP
      options or strip those options from the packets.

   o  Segmentation and Coalescing: middleboxes (or even something as
      close to the end host as TCP Segmentation Offloading (TSO) on a
      Network Interface Card (NIC)) may change the packet boundaries
      from those that the sender intended.  It may do this by splitting
      packets or coalescing them together.  This leads to two major
      impacts: where a packet boundary will be cannot be guaranteed and
      what a middlebox will do with TCP options in these cases (they may
      be repeated, dropped, or sent only once) cannot be said for sure.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/8.%20%20Contributors"></a><a class="selflink" href="#section-8" name="section-8">8</a>.  Contributors</span>

   The authors would like to acknowledge the contributions of Andrew
   McDonald and Bryan Ford to this document.

   The authors would also like to thank the following people for
   detailed reviews: Olivier Bonaventure, Gorry Fairhurst, Iljitsch van
   Beijnum, Philip Eardley, Michael Scharf, Lars Eggert, Cullen
   Jennings, Joel Halpern, Juergen Quittek, Alexey Melnikov, David
   Harrington, Jari Arkko, and Stewart Bryant.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/9.%20%20Acknowledgements"></a><a class="selflink" href="#section-9" name="section-9">9</a>.  Acknowledgements</span>

   Alan Ford, Costin Raiciu, Mark Handley, and Sebastien Barre are
   supported by Trilogy (<a href="http://www.trilogy-project.org/">http://www.trilogy-project.org</a>), a research
   project (ICT-216372) partially funded by the European Community under
   its Seventh Framework Program.  The views expressed here are those of
   the author(s) only.  The European Commission is not liable for any
   use that may be made of the information in this document.



<span class="grey">Ford, et al.                  Informational                    [Page 25]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-26" id="page-26" name="page-26"> </a>
<span class="grey"><a href="rfc6182.html">RFC 6182</a>                   MPTCP Architecture                 March 2011</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/10.%20%20Security%20Considerations"></a><a class="selflink" href="#section-10" name="section-10">10</a>.  Security Considerations</span>

   This informational document provides an architectural overview for
   Multipath TCP and so does not, in itself, raise any security issues.
   A separate threat analysis [<a href="#ref-12" title='"Threat Analysis for TCP Extensions for Multipath Operation with Multiple Addresses"'>12</a>] lists threats that can exist with a
   Multipath TCP.  However, a protocol based on the architecture in this
   document will have a number of security requirements.  The high-level
   goals for such a protocol are identified in <a href="#section-2.3">Section 2.3</a>, whilst
   <a href="#section-5.8">Section 5.8</a> provides more detailed discussion of security
   requirements and design decisions which are applied in the MPTCP
   protocol design [<a href="#ref-5" title='"TCP Extensions for Multipath Operation with Multiple Addresses"'>5</a>].

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/11.%20%20References"></a><a class="selflink" href="#section-11" name="section-11">11</a>.  References</span>

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/11.1.%20%20Normative%20References"></a><a class="selflink" href="#section-11.1" name="section-11.1">11.1</a>.  Normative References</span>

   [<a id="ref-1" name="ref-1">1</a>]   Postel, J., "Transmission Control Protocol", STD 7, <a href="rfc793.html">RFC 793</a>,
         September 1981.

   [<a id="ref-2" name="ref-2">2</a>]   Bradner, S., "Key words for use in RFCs to Indicate Requirement
         Levels", <a href="https://tools.ietf.org/html/bcp14">BCP 14</a>, <a href="rfc2119.html">RFC 2119</a>, March 1997.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/11.2.%20%20Informative%20References"></a><a class="selflink" href="#section-11.2" name="section-11.2">11.2</a>.  Informative References</span>

   [<a id="ref-3" name="ref-3">3</a>]   Wischik, D., Handley, M., and M. Bagnulo Braun, "The Resource
         Pooling Principle", ACM SIGCOMM CCR vol. 38 num. 5, pp. 47-52,
         October 2008,
         &lt;<a href="http://ccr.sigcomm.org/online/files/p47-handleyA4.pdf">http://ccr.sigcomm.org/online/files/p47-handleyA4.pdf</a>&gt;.

   [<a id="ref-4" name="ref-4">4</a>]   Hopps, C., "Analysis of an Equal-Cost Multi-Path Algorithm",
         <a href="rfc2992.html">RFC 2992</a>, November 2000.

   [<a id="ref-5" name="ref-5">5</a>]   Ford, A., Raiciu, C., Handley, M., and O. Bonaventure, "TCP
         Extensions for Multipath Operation with Multiple Addresses",
         Work in Progress, March 2011.

   [<a id="ref-6" name="ref-6">6</a>]   Stewart, R., "Stream Control Transmission Protocol", <a href="rfc4960.html">RFC 4960</a>,
         September 2007.

   [<a id="ref-7" name="ref-7">7</a>]   Raiciu, C., Handley, M., and D. Wischik, "Coupled Congestion
         Control for Multipath Transport Protocols", Work in Progress,
         March 2011.

   [<a id="ref-8" name="ref-8">8</a>]   Scharf, M. and A. Ford, "MPTCP Application Interface
         Considerations", Work in Progress, March 2011.

   [<a id="ref-9" name="ref-9">9</a>]   Carpenter, B. and S. Brim, "Middleboxes: Taxonomy and Issues",
         <a href="rfc3234.html">RFC 3234</a>, February 2002.



<span class="grey">Ford, et al.                  Informational                    [Page 26]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-27" id="page-27" name="page-27"> </a>
<span class="grey"><a href="rfc6182.html">RFC 6182</a>                   MPTCP Architecture                 March 2011</span>


   [<a id="ref-10" name="ref-10">10</a>]  Carpenter, B., "Internet Transparency", <a href="rfc2775.html">RFC 2775</a>,
         February 2000.

   [<a id="ref-11" name="ref-11">11</a>]  Mathis, M., Mahdavi, J., Floyd, S., and A. Romanow, "TCP
         Selective Acknowledgment Options", <a href="rfc2018.html">RFC 2018</a>, October 1996.

   [<a id="ref-12" name="ref-12">12</a>]  Bagnulo, M., "Threat Analysis for TCP Extensions for Multipath
         Operation with Multiple Addresses", <a href="rfc6181.html">RFC 6181</a>, March 2011.

   [<a id="ref-13" name="ref-13">13</a>]  Becke, M., Dreibholz, T., Iyengar, J., Natarajan, P., and M.
         Tuexen, "Load Sharing for the Stream Control Transmission
         Protocol (SCTP)", Work in Progress, December 2010.

   [<a id="ref-14" name="ref-14">14</a>]  Ford, B. and J. Iyengar, "Breaking Up the Transport Logjam",
          ACM HotNets, October 2008.

   [<a id="ref-15" name="ref-15">15</a>]  Srisuresh, P. and K. Egevang, "Traditional IP Network Address
         Translator (Traditional NAT)", <a href="rfc3022.html">RFC 3022</a>, January 2001.

   [<a id="ref-16" name="ref-16">16</a>]  Freed, N., "Behavior of and Requirements for Internet
         Firewalls", <a href="rfc2979.html">RFC 2979</a>, October 2000.

   [<a id="ref-17" name="ref-17">17</a>]  Border, J., Kojo, M., Griner, J., Montenegro, G., and Z.
         Shelby, "Performance Enhancing Proxies Intended to Mitigate
         Link-Related Degradations", <a href="rfc3135.html">RFC 3135</a>, June 2001.

   [<a id="ref-18" name="ref-18">18</a>]  Ramaiah, A., Stewart, R., and M. Dalal, "Improving TCP's
         Robustness to Blind In-Window Attacks", <a href="rfc5961.html">RFC 5961</a>, August 2010.

   [<a id="ref-19" name="ref-19">19</a>]  Eddy, W., "TCP SYN Flooding Attacks and Common Mitigations",
         <a href="rfc4987.html">RFC 4987</a>, August 2007.

   [<a id="ref-20" name="ref-20">20</a>]  Gont, F. and A. Yourtchenko, "On the Implementation of the TCP
         Urgent Mechanism", <a href="rfc6093.html">RFC 6093</a>, January 2011.

   [<a id="ref-21" name="ref-21">21</a>]  Raghunarayan, R., "Management Information Base for the
         Transmission Control Protocol (TCP)", <a href="rfc4022.html">RFC 4022</a>, March 2005.

   [<a id="ref-22" name="ref-22">22</a>]  Mathis, M., Heffner, J., and R. Raghunarayan, "TCP Extended
         Statistics MIB", <a href="rfc4898.html">RFC 4898</a>, May 2007.

   [<a id="ref-23" name="ref-23">23</a>]  Handley, M., Paxson, V., and C. Kreibich, "Network Intrusion
         Detection: Evasion, Traffic Normalization, and End-to-End
         Protocol Semantics", Usenix Security 2001, 2001, &lt;<a href="http://www.usenix.org/events/sec01/full_papers/handley/handley.pdf">http://</a>
         <a href="http://www.usenix.org/events/sec01/full_papers/handley/handley.pdf">www.usenix.org/events/sec01/full_papers/handley/handley.pdf</a>&gt;.






<span class="grey">Ford, et al.                  Informational                    [Page 27]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-28" id="page-28" name="page-28"> </a>
<span class="grey"><a href="rfc6182.html">RFC 6182</a>                   MPTCP Architecture                 March 2011</span>


Authors' Addresses

   Alan Ford
   Roke Manor Research
   Old Salisbury Lane
   Romsey, Hampshire  SO51 0ZN
   UK
   Phone: +44 1794 833 465
   EMail: alan.ford@roke.co.uk

   Costin Raiciu
   University College London
   Gower Street
   London  WC1E 6BT
   UK
   EMail: c.raiciu@cs.ucl.ac.uk

   Mark Handley
   University College London
   Gower Street
   London  WC1E 6BT
   UK
   EMail: m.handley@cs.ucl.ac.uk

   Sebastien Barre
   Universite catholique de Louvain
   Pl. Ste Barbe, 2
   Louvain-la-Neuve  1348
   Belgium
   Phone: +32 10 47 91 03
   EMail: sebastien.barre@uclouvain.be

   Janardhan Iyengar
   Franklin and Marshall College
   Mathematics and Computer Science
   PO Box 3003
   Lancaster, PA  17604-3003
   USA
   Phone: 717-358-4774
   EMail: jiyengar@fandm.edu











Ford, et al.                  Informational                    [Page 28]

</pre><br/>
    <span class="noprint"><small><small>Html markup produced by rfcmarkup 1.126, available from
      <a href="https://tools.ietf.org/tools/rfcmarkup/">https://tools.ietf.org/tools/rfcmarkup/</a>
    </small></small></span>
  </div>




</body><!-- Mirrored from tools.ietf.org/html/rfc6182 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 06 Mar 2018 23:18:31 GMT --></html>