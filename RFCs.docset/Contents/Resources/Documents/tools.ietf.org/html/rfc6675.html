<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

<!-- Mirrored from tools.ietf.org/html/rfc6675 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 06 Mar 2018 23:18:27 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head profile="http://dublincore.org/documents/2008/08/04/dc-html/">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="robots" content="index,follow" />
    <meta name="creator" content="rfcmarkup version 1.126" />
    <link rel="schema.DC" href="http://purl.org/dc/elements/1.1/" />
<meta name="DC.Relation.Replaces" content="rfc3517" />
<meta name="DC.Identifier" content="urn:ietf:rfc:6675" />
<meta name="DC.Date.Issued" content="August, 2012" />
<meta name="DC.Creator" content="Wang, Lili" />
<meta name="DC.Creator" content="Kojo, Markku" />
<meta name="DC.Creator" content="Blanton, Ethan" />
<meta name="DC.Creator" content="Nishida, Yoshifumi" />
<meta name="DC.Creator" content="Allman, Mark" />
<meta name="DC.Creator" content="Jarvinen, Ilpo" />
<meta name="DC.Description.Abstract" content="This document presents a conservative loss recovery algorithm for TCP
that is based on the use of the selective acknowledgment (SACK) TCP
option. The algorithm presented in this document conforms to the
spirit of the current congestion control specification (RFC 5681), but
allows TCP senders to recover more effectively when multiple segments
are lost from a single flight of data. This document obsoletes RFC
3517 and describes changes from it. [STANDARDS-TRACK]" />
<meta name="DC.Title" content="A Conservative Loss Recovery Algorithm Based on Selective Acknowledgment (SACK) for TCP" />

    <link rel="icon" href="https://tools.ietf.org/images/rfc.png" type="image/png" />
    <link rel="shortcut icon" href="https://tools.ietf.org/images/rfc.png" type="image/png" />
    <title>RFC 6675 - A Conservative Loss Recovery Algorithm Based on Selective Acknowledgment (SACK) for TCP</title>
    
    
    <style type="text/css">
	@media only screen 
	  and (min-width: 992px)
	  and (max-width: 1199px) {
	    body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 768px)
	  and (max-width: 991px) {
            body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 480px)
	  and (max-width: 767px) {
            body { font-size: 11pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (max-width: 479px) {
            body { font-size: 8pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-device-width : 375px) 
	  and (max-device-width : 667px) {
            body { font-size: 9.5pt; }
            div.content { width: 96ex; margin: 0 1px; }
        }
	@media only screen 
	  and (min-device-width: 1200px) {
            body { font-size: 10pt; margin: 0 4em; }
            div.content { width: 96ex; margin: 0; }
        }
        h1, h2, h3, h4, h5, h6, .h1, .h2, .h3, .h4, .h5, .h6 {
	    font-weight: bold;
            line-height: 0pt;
            display: inline;
            white-space: pre;
            font-family: monospace;
            font-size: 1em;
	    font-weight: bold;
        }
        pre {
            font-size: 1em;
            margin-top: 0px;
            margin-bottom: 0px;
        }
	.pre {
	    white-space: pre;
	    font-family: monospace;
	}
	.header{
	    font-weight: bold;
	}
        .newpage {
            page-break-before: always;
        }
        .invisible {
            text-decoration: none;
            color: white;
        }
        a.selflink {
          color: black;
          text-decoration: none;
        }
        @media print {
            body {
                font-family: monospace;
                font-size: 10.5pt;
            }
            h1, h2, h3, h4, h5, h6 {
                font-size: 1em;
            }
        
            a:link, a:visited {
                color: inherit;
                text-decoration: none;
            }
            .noprint {
                display: none;
            }
        }
	@media screen {
	    .grey, .grey a:link, .grey a:visited {
		color: #777;
	    }
            .docinfo {
                background-color: #EEE;
            }
            .top {
                border-top: 7px solid #EEE;
            }
            .bgwhite  { background-color: white; }
            .bgred    { background-color: #F44; }
            .bggrey   { background-color: #666; }
            .bgbrown  { background-color: #840; }            
            .bgorange { background-color: #FA0; }
            .bgyellow { background-color: #EE0; }
            .bgmagenta{ background-color: #F4F; }
            .bgblue   { background-color: #66F; }
            .bgcyan   { background-color: #4DD; }
            .bggreen  { background-color: #4F4; }

            .legend   { font-size: 90%; }
            .cplate   { font-size: 70%; border: solid grey 1px; }
	}
    </style>
    <!--[if IE]>
    <style>
    body {
       font-size: 13px;
       margin: 10px 10px;
    }
    </style>
    <![endif]-->

    <script type="text/javascript"><!--
    function addHeaderTags() {
	var spans = document.getElementsByTagName("span");
	for (var i=0; i < spans.length; i++) {
	    var elem = spans[i];
	    if (elem) {
		var level = elem.getAttribute("class");
                if (level == "h1" || level == "h2" || level == "h3" || level == "h4" || level == "h5" || level == "h6") {
                    elem.innerHTML = "<"+level+">"+elem.innerHTML+"</"+level+">";		
                }
	    }
	}
    }
    var legend_html = "Colour legend:<br />      <table>         <tr><td>Unknown:</td>                   <td><span class='cplate bgwhite'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft:</td>                     <td><span class='cplate bgred'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Informational:</td>             <td><span class='cplate bgorange'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Experimental:</td>              <td><span class='cplate bgyellow'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Best Common Practice:</td>      <td><span class='cplate bgmagenta'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Proposed Standard:</td>         <td><span class='cplate bgblue'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft Standard (old designation):</td> <td><span class='cplate bgcyan'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Internet Standard:</td>         <td><span class='cplate bggreen'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Historic:</td>                  <td><span class='cplate bggrey'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Obsolete:</td>                  <td><span class='cplate bgbrown'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>     </table>";
    function showElem(id) {
        var elem = document.getElementById(id);
        elem.innerHTML = eval(id+"_html");
        elem.style.visibility='visible';
    }
    function hideElem(id) {
        var elem = document.getElementById(id);
        elem.style.visibility='hidden';        
        elem.innerHTML = "";
    }
    // -->
    </script>
</head>
<body onload="addHeaderTags()">
  <div class="content">
   <div style="height: 13px;">
      <div onmouseover="this.style.cursor='pointer';"
         onclick="showElem('legend');"
         onmouseout="hideElem('legend')"
	 style="height: 6px; position: absolute;"
         class="pre noprint docinfo bgblue"
         title="Click for colour legend." >                                                                        </div>
      <div id="legend"
           class="docinfo noprint pre legend"
           style="position:absolute; top: 4px; left: 4ex; visibility:hidden; background-color: white; padding: 4px 9px 5px 7px; border: solid #345 1px; "
           onmouseover="showElem('legend');"
           onmouseout="hideElem('legend');">
      </div>
   </div>
<span class="pre noprint docinfo top">[<a href="index.html" title="Document search and retrieval page">Docs</a>] [<a href="https://tools.ietf.org/rfc/rfc6675.txt" title="Plaintext version of this document">txt</a>|<a href="https://tools.ietf.org/pdf/rfc6675" title="PDF version of this document">pdf</a>] [<a href="https://tools.ietf.org/html/draft-ietf-tcpm-3517bis" title="draft-ietf-tcpm-3517bis">draft-ietf-tcpm...</a>] [<a href='https://datatracker.ietf.org/doc/rfc6675' title='IESG Datatracker information for this document'>Tracker</a>] [<a href="https://tools.ietf.org/rfcdiff?difftype=--hwdiff&amp;url2=rfc6675" title="Inline diff (wdiff)">Diff1</a>] [<a href="https://tools.ietf.org/rfcdiff?url2=rfc6675" title="Side-by-side diff">Diff2</a>]         </span><br />
<span class="pre noprint docinfo">                                                                        </span><br />
<span class="pre noprint docinfo">                                                       PROPOSED STANDARD</span><br />
<span class="pre noprint docinfo">                                                                        </span><br />
<pre>
Internet Engineering Task Force (IETF)                        E. Blanton
Request for Comments: 6675                             Purdue University
Obsoletes: <a href="rfc3517.html">3517</a>                                                M. Allman
Category: Standards Track                                           ICSI
ISSN: 2070-1721                                                  L. Wang
                                                        Juniper Networks
                                                             I. Jarvinen
                                                                 M. Kojo
                                                  University of Helsinki
                                                              Y. Nishida
                                                            WIDE Project
                                                             August 2012


            <span class="h1">A Conservative Loss Recovery Algorithm Based on</span>
                <span class="h1">Selective Acknowledgment (SACK) for TCP</span>

Abstract

   This document presents a conservative loss recovery algorithm for TCP
   that is based on the use of the selective acknowledgment (SACK) TCP
   option.  The algorithm presented in this document conforms to the
   spirit of the current congestion control specification (<a href="rfc5681.html">RFC 5681</a>),
   but allows TCP senders to recover more effectively when multiple
   segments are lost from a single flight of data.  This document
   obsoletes <a href="rfc3517.html">RFC 3517</a> and describes changes from it.

Status of This Memo

   This is an Internet Standards Track document.

   This document is a product of the Internet Engineering Task Force
   (IETF).  It represents the consensus of the IETF community.  It has
   received public review and has been approved for publication by
   the Internet Engineering Steering Group (IESG).  Further
   information on Internet Standards is available in <a href="rfc5741.html#section-2">Section&nbsp;2 of
   RFC 5741</a>.

   Information about the current status of this document, any
   errata, and how to provide feedback on it may be obtained at
   <a href="http://www.rfc-editor.org/info/rfc6675">http://www.rfc-editor.org/info/rfc6675</a>.










<span class="grey">Blanton, et al.              Standards Track                    [Page 1]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-2" id="page-2" href="#page-2" class="invisible"> </a>
<span class="grey"><a href="rfc6675.html">RFC 6675</a>          SACK Loss Recovery Algorithm for TCP       August 2012</span>


Copyright Notice

   Copyright (c) 2012 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to <a href="https://tools.ietf.org/html/bcp78">BCP 78</a> and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (<a href="http://trustee.ietf.org/license-info">http://trustee.ietf.org/license-info</a>) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.

<span class="h2"><a class="selflink" name="section-1" href="#section-1">1</a>.  Introduction</span>

   This document presents a conservative loss recovery algorithm for TCP
   that is based on the use of the selective acknowledgment (SACK) TCP
   option.  While the TCP SACK option [<a href="rfc2018.html" title="&quot;TCP Selective Acknowledgment Options&quot;">RFC2018</a>] is being steadily
   deployed in the Internet [<a href="#ref-All00" title="&quot;A Web Server's View of the Transport Layer&quot;">All00</a>], there is evidence that hosts are
   not using the SACK information when making retransmission and
   congestion control decisions [<a href="#ref-PF01" title="&quot;Identifying the TCP Behavior of Web Servers&quot;">PF01</a>].  The goal of this document is to
   outline one straightforward method for TCP implementations to use
   SACK information to increase performance.

   [<a name="ref-RFC5681" id="ref-RFC5681">RFC5681</a>] allows advanced loss recovery algorithms to be used by TCP
   [<a href="rfc793.html" title="&quot;Transmission Control Protocol&quot;">RFC793</a>] provided that they follow the spirit of TCP's congestion
   control algorithms [<a href="rfc5681.html" title="&quot;TCP Congestion Control&quot;">RFC5681</a>] [<a href="rfc2914.html" title="&quot;Congestion Control Principles&quot;">RFC2914</a>].  [<a href="rfc6582.html" title="&quot;The NewReno Modification to TCP's Fast Recovery Algorithm&quot;">RFC6582</a>] outlines one such
   advanced recovery algorithm called NewReno.  This document outlines a
   loss recovery algorithm that uses the SACK TCP option [<a href="rfc2018.html" title="&quot;TCP Selective Acknowledgment Options&quot;">RFC2018</a>] to
   enhance TCP's loss recovery.  The algorithm outlined in this
   document, heavily based on the algorithm detailed in [<a href="#ref-FF96" title="&quot;Simulation-based Comparisons of Tahoe, Reno and SACK TCP&quot;">FF96</a>], is a
   conservative replacement of the fast recovery algorithm [<a href="#ref-Jac90" title="&quot;Modified TCP Congestion Avoidance Algorithm&quot;">Jac90</a>]
   [<a href="rfc5681.html" title="&quot;TCP Congestion Control&quot;">RFC5681</a>].  The algorithm specified in this document is a
   straightforward SACK-based loss recovery strategy that follows the
   guidelines set in [<a href="rfc5681.html" title="&quot;TCP Congestion Control&quot;">RFC5681</a>] and can safely be used in TCP
   implementations.  Alternate SACK-based loss recovery methods can be
   used in TCP as implementers see fit (as long as the alternate
   algorithms follow the guidelines provided in [<a href="rfc5681.html" title="&quot;TCP Congestion Control&quot;">RFC5681</a>]).  Please
   note, however, that the SACK-based decisions in this document (such
   as what segments are to be sent at what time) are largely decoupled
   from the congestion control algorithms, and as such can be treated as
   separate issues if so desired.

   This document represents a revision of [<a href="rfc3517.html" title="&quot;A Conservative Selective Acknowledgment (SACK)-based Loss Recovery Algorithm for TCP&quot;">RFC3517</a>] to address several
   situations that are not handled explicitly in that document.  A




<span class="grey">Blanton, et al.              Standards Track                    [Page 2]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-3" id="page-3" href="#page-3" class="invisible"> </a>
<span class="grey"><a href="rfc6675.html">RFC 6675</a>          SACK Loss Recovery Algorithm for TCP       August 2012</span>


   summary of the changes between this document and [<a href="rfc3517.html" title="&quot;A Conservative Selective Acknowledgment (SACK)-based Loss Recovery Algorithm for TCP&quot;">RFC3517</a>] can be
   found in <a href="#section-9">Section 9</a>.

<span class="h2"><a class="selflink" name="section-2" href="#section-2">2</a>.   Definitions</span>

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in <a href="https://tools.ietf.org/html/bcp14">BCP 14</a>, <a href="rfc2119.html">RFC 2119</a>
   [<a href="rfc2119.html" title="&quot;Key words for use in RFCs to Indicate Requirement Levels&quot;">RFC2119</a>].

   The reader is expected to be familiar with the definitions given in
   [<a href="rfc5681.html" title="&quot;TCP Congestion Control&quot;">RFC5681</a>].

   The reader is assumed to be familiar with selective acknowledgments
   as specified in [<a href="rfc2018.html" title="&quot;TCP Selective Acknowledgment Options&quot;">RFC2018</a>].

   For the purposes of explaining the SACK-based loss recovery
   algorithm, we define six variables that a TCP sender stores:

      "HighACK" is the sequence number of the highest byte of data that
      has been cumulatively ACKed at a given point.

      "HighData" is the highest sequence number transmitted at a given
      point.

      "HighRxt" is the highest sequence number which has been
      retransmitted during the current loss recovery phase.

      "RescueRxt" is the highest sequence number which has been
      optimistically retransmitted to prevent stalling of the ACK clock
      when there is loss at the end of the window and no new data is
      available for transmission.

      "Pipe" is a sender's estimate of the number of bytes outstanding
      in the network.  This is used during recovery for limiting the
      sender's sending rate.  The pipe variable allows TCP to use
      fundamentally different congestion control than the algorithm
      specified in [<a href="rfc5681.html" title="&quot;TCP Congestion Control&quot;">RFC5681</a>].  The congestion control algorithm using
      the pipe estimate is often referred to as the "pipe algorithm".

      "DupAcks" is the number of duplicate acknowledgments received
      since the last cumulative acknowledgment.

   For the purposes of this specification, we define a "duplicate
   acknowledgment" as a segment that arrives carrying a SACK block that
   identifies previously unacknowledged and un-SACKed octets between
   HighACK and HighData.  Note that an ACK which carries new SACK data
   is counted as a duplicate acknowledgment under this definition even



<span class="grey">Blanton, et al.              Standards Track                    [Page 3]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-4" id="page-4" href="#page-4" class="invisible"> </a>
<span class="grey"><a href="rfc6675.html">RFC 6675</a>          SACK Loss Recovery Algorithm for TCP       August 2012</span>


   if it carries new data, changes the advertised window, or moves the
   cumulative acknowledgment point, which is different from the
   definition of duplicate acknowledgment in [<a href="rfc5681.html" title="&quot;TCP Congestion Control&quot;">RFC5681</a>].

   We define a variable "DupThresh" that holds the number of duplicate
   acknowledgments required to trigger a retransmission.  Per [<a href="rfc5681.html" title="&quot;TCP Congestion Control&quot;">RFC5681</a>],
   this threshold is defined to be 3 duplicate acknowledgments.
   However, implementers should consult any updates to [<a href="rfc5681.html" title="&quot;TCP Congestion Control&quot;">RFC5681</a>] to
   determine the current value for DupThresh (or method for determining
   its value).

   Finally, a range of sequence numbers [A,B] is said to "cover"
   sequence number S if A &lt;= S &lt;= B.

<span class="h2"><a class="selflink" name="section-3" href="#section-3">3</a>.   Keeping Track of SACK Information</span>

   For a TCP sender to implement the algorithm defined in the next
   section, it must keep a data structure to store incoming selective
   acknowledgment information on a per connection basis.  Such a data
   structure is commonly called the "scoreboard".  The specifics of the
   scoreboard data structure are out of scope for this document (as long
   as the implementation can perform all functions required by this
   specification).

   Note that this document refers to keeping account of (marking)
   individual octets of data transferred across a TCP connection.  A
   real-world implementation of the scoreboard would likely prefer to
   manage this data as sequence number ranges.  The algorithms presented
   here allow this, but require the ability to mark arbitrary sequence
   number ranges as having been selectively acknowledged.

   Finally, note that the algorithm in this document assumes a sender
   that is not keeping track of segment boundaries after transmitting a
   segment.  It is possible that there is a more refined and precise
   algorithm available to a sender that keeps this extra state than the
   algorithm presented herein; however, we leave this as future work.

<span class="h2"><a class="selflink" name="section-4" href="#section-4">4</a>.   Processing and Acting Upon SACK Information</span>

   This section describes a specific structure and control flow for
   implementing the TCP behavior described by this standard.  The
   behavior is what is standardized, and this particular collection of
   functions is the strongly recommended means of implementing that
   behavior, though other approaches to achieving that behavior are
   feasible.

   The definition of Sender Maximum Segment Size (SMSS) used in this
   section is provided in [<a href="rfc5681.html" title="&quot;TCP Congestion Control&quot;">RFC5681</a>].



<span class="grey">Blanton, et al.              Standards Track                    [Page 4]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-5" id="page-5" href="#page-5" class="invisible"> </a>
<span class="grey"><a href="rfc6675.html">RFC 6675</a>          SACK Loss Recovery Algorithm for TCP       August 2012</span>


   For the purposes of the algorithm defined in this document, the
   scoreboard SHOULD implement the following functions:

   Update ():

      Given the information provided in an ACK, each octet that is
      cumulatively ACKed or SACKed should be marked accordingly in the
      scoreboard data structure, and the total number of octets SACKed
      should be recorded.

      Note: SACK information is advisory and therefore SACKed data MUST
      NOT be removed from the TCP's retransmission buffer until the data
      is cumulatively acknowledged [<a href="rfc2018.html" title="&quot;TCP Selective Acknowledgment Options&quot;">RFC2018</a>].

   IsLost (SeqNum):

      This routine returns whether the given sequence number is
      considered to be lost.  The routine returns true when either
      DupThresh discontiguous SACKed sequences have arrived above
      'SeqNum' or more than (DupThresh - 1) * SMSS bytes with sequence
      numbers greater than 'SeqNum' have been SACKed.  Otherwise, the
      routine returns false.

   SetPipe ():

      This routine traverses the sequence space from HighACK to HighData
      and MUST set the "pipe" variable to an estimate of the number of
      octets that are currently in transit between the TCP sender and
      the TCP receiver.  After initializing pipe to zero, the following
      steps are taken for each octet 'S1' in the sequence space between
      HighACK and HighData that has not been SACKed:

      (a) If IsLost (S1) returns false:

         Pipe is incremented by 1 octet.

         The effect of this condition is that pipe is incremented for
         packets that have not been SACKed and have not been determined
         to have been lost (i.e., those segments that are still assumed
         to be in the network).

      (b) If S1 &lt;= HighRxt:

         Pipe is incremented by 1 octet.

         The effect of this condition is that pipe is incremented for
         the retransmission of the octet.




<span class="grey">Blanton, et al.              Standards Track                    [Page 5]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-6" id="page-6" href="#page-6" class="invisible"> </a>
<span class="grey"><a href="rfc6675.html">RFC 6675</a>          SACK Loss Recovery Algorithm for TCP       August 2012</span>


      Note that octets retransmitted without being considered lost are
      counted twice by the above mechanism.

   NextSeg ():

      This routine uses the scoreboard data structure maintained by the
      Update() function to determine what to transmit based on the SACK
      information that has arrived from the data receiver (and hence
      been marked in the scoreboard).  NextSeg () MUST return the
      sequence number range of the next segment that is to be
      transmitted, per the following rules:

      (1) If there exists a smallest unSACKed sequence number 'S2' that
          meets the following three criteria for determining loss, the
          sequence range of one segment of up to SMSS octets starting
          with S2 MUST be returned.

          (1.a) S2 is greater than HighRxt.

          (1.b) S2 is less than the highest octet covered by any
                received SACK.

          (1.c) IsLost (S2) returns true.

      (2) If no sequence number 'S2' per rule (1) exists but there
          exists available unsent data and the receiver's advertised
          window allows, the sequence range of one segment of up to SMSS
          octets of previously unsent data starting with sequence number
          HighData+1 MUST be returned.

      (3) If the conditions for rules (1) and (2) fail, but there exists
          an unSACKed sequence number 'S3' that meets the criteria for
          detecting loss given in steps (1.a) and (1.b) above
          (specifically excluding step (1.c)), then one segment of up to
          SMSS octets starting with S3 SHOULD be returned.

      (4) If the conditions for (1), (2), and (3) fail, but there exists
          outstanding unSACKed data, we provide the opportunity for a
          single "rescue" retransmission per entry into loss recovery.
          If HighACK is greater than RescueRxt (or RescueRxt is
          undefined), then one segment of up to SMSS octets that MUST
          include the highest outstanding unSACKed sequence number
          SHOULD be returned, and RescueRxt set to RecoveryPoint.
          HighRxt MUST NOT be updated.

          Note that rules (3) and (4) are a sort of retransmission "last
          resort".  They allow for retransmission of sequence numbers
          even when the sender has less certainty a segment has been



<span class="grey">Blanton, et al.              Standards Track                    [Page 6]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-7" id="page-7" href="#page-7" class="invisible"> </a>
<span class="grey"><a href="rfc6675.html">RFC 6675</a>          SACK Loss Recovery Algorithm for TCP       August 2012</span>


          lost than as with rule (1).  Retransmitting segments via rule
          (3) and (4) will help sustain the TCP's ACK clock and
          therefore can potentially help avoid retransmission timeouts.
          However, in sending these segments, the sender has two copies
          of the same data considered to be in the network (and also in
          the pipe estimate, in the case of (3)).  When an ACK or SACK
          arrives covering this retransmitted segment, the sender cannot
          be sure exactly how much data left the network (one of the two
          transmissions of the packet or both transmissions of the
          packet).  Therefore, the sender may underestimate pipe by
          considering both segments to have left the network when it is
          possible that only one of the two has.

      (5) If the conditions for each of (1), (2), (3), and (4) are not
          met, then NextSeg () MUST indicate failure, and no segment is
          returned.

   Note: The SACK-based loss recovery algorithm outlined in this
   document requires more computational resources than previous TCP loss
   recovery strategies.  However, we believe the scoreboard data
   structure can be implemented in a reasonably efficient manner (both
   in terms of computation complexity and memory usage) in most TCP
   implementations.

<span class="h2"><a class="selflink" name="section-5" href="#section-5">5</a>.   Algorithm Details</span>

   Upon the receipt of any ACK containing SACK information, the
   scoreboard MUST be updated via the Update () routine.

   If the incoming ACK is a cumulative acknowledgment, the TCP MUST
   reset DupAcks to zero.

   If the incoming ACK is a duplicate acknowledgment per the definition
   in <a href="#section-2">Section 2</a> (regardless of its status as a cumulative
   acknowledgment), and the TCP is not currently in loss recovery, the
   TCP MUST increase DupAcks by one and take the following steps:

   (1) If DupAcks &gt;= DupThresh, go to step (4).

       Note: This check covers the case when a TCP receives SACK
       information for multiple segments smaller than SMSS, which can
       potentially prevent IsLost() (next step) from declaring a segment
       as lost.

   (2) If DupAcks &lt; DupThresh but IsLost (HighACK + 1) returns true --
       indicating at least three segments have arrived above the current
       cumulative acknowledgment point, which is taken to indicate loss
       -- go to step (4).



<span class="grey">Blanton, et al.              Standards Track                    [Page 7]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-8" id="page-8" href="#page-8" class="invisible"> </a>
<span class="grey"><a href="rfc6675.html">RFC 6675</a>          SACK Loss Recovery Algorithm for TCP       August 2012</span>


   (3) The TCP MAY transmit previously unsent data segments as per
       Limited Transmit [<a href="rfc5681.html" title="&quot;TCP Congestion Control&quot;">RFC5681</a>], except that the number of octets
       which may be sent is governed by pipe and cwnd as follows:

       (3.1) Set HighRxt to HighACK.

       (3.2) Run SetPipe ().

       (3.3) If (cwnd - pipe) &gt;= 1 SMSS, there exists previously unsent
             data, and the receiver's advertised window allows, transmit
             up to 1 SMSS of data starting with the octet HighData+1 and
             update HighData to reflect this transmission, then return
             to (3.2).

       (3.4) Terminate processing of this ACK.

   (4) Invoke fast retransmit and enter loss recovery as follows:

       (4.1) RecoveryPoint = HighData

             When the TCP sender receives a cumulative ACK for this data
             octet, the loss recovery phase is terminated.

       (4.2) ssthresh = cwnd = (FlightSize / 2)

             The congestion window (cwnd) and slow start threshold
             (ssthresh) are reduced to half of FlightSize per [<a href="rfc5681.html" title="&quot;TCP Congestion Control&quot;">RFC5681</a>].
             Additionally, note that [<a href="rfc5681.html" title="&quot;TCP Congestion Control&quot;">RFC5681</a>] requires that any
             segments sent as part of the Limited Transmit mechanism not
             be counted in FlightSize for the purpose of the above
             equation.

       (4.3) Retransmit the first data segment presumed dropped -- the
             segment starting with sequence number HighACK + 1.  To
             prevent repeated retransmission of the same data or a
             premature rescue retransmission, set both HighRxt and
             RescueRxt to the highest sequence number in the
             retransmitted segment.

       (4.4) Run SetPipe ()

             Set a "pipe" variable to the number of outstanding octets
             currently "in the pipe"; this is the data which has been
             sent by the TCP sender but for which no cumulative or
             selective acknowledgment has been received and the data has
             not been determined to have been dropped in the network.
             It is assumed that the data is still traversing the network
             path.



<span class="grey">Blanton, et al.              Standards Track                    [Page 8]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-9" id="page-9" href="#page-9" class="invisible"> </a>
<span class="grey"><a href="rfc6675.html">RFC 6675</a>          SACK Loss Recovery Algorithm for TCP       August 2012</span>


       (4.5) In order to take advantage of potential additional
             available cwnd, proceed to step (C) below.

   Once a TCP is in the loss recovery phase, the following procedure
   MUST be used for each arriving ACK:

   (A) An incoming cumulative ACK for a sequence number greater than
       RecoveryPoint signals the end of loss recovery, and the loss
       recovery phase MUST be terminated.  Any information contained in
       the scoreboard for sequence numbers greater than the new value of
       HighACK SHOULD NOT be cleared when leaving the loss recovery
       phase.

   (B) Upon receipt of an ACK that does not cover RecoveryPoint, the
       following actions MUST be taken:

       (B.1) Use Update () to record the new SACK information conveyed
             by the incoming ACK.

       (B.2) Use SetPipe () to re-calculate the number of octets still
             in the network.

   (C) If cwnd - pipe &gt;= 1 SMSS, the sender SHOULD transmit one or more
       segments as follows:

       (C.1) The scoreboard MUST be queried via NextSeg () for the
             sequence number range of the next segment to transmit (if
             any), and the given segment sent.  If NextSeg () returns
             failure (no data to send), return without sending anything
             (i.e., terminate steps C.1 -- C.5).

       (C.2) If any of the data octets sent in (C.1) are below HighData,
             HighRxt MUST be set to the highest sequence number of the
             retransmitted segment unless NextSeg () rule (4) was
             invoked for this retransmission.

       (C.3) If any of the data octets sent in (C.1) are above HighData,
             HighData must be updated to reflect the transmission of
             previously unsent data.

       (C.4) The estimate of the amount of data outstanding in the
             network must be updated by incrementing pipe by the number
             of octets transmitted in (C.1).

       (C.5) If cwnd - pipe &gt;= 1 SMSS, return to (C.1)






<span class="grey">Blanton, et al.              Standards Track                    [Page 9]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-10" id="page-10" href="#page-10" class="invisible"> </a>
<span class="grey"><a href="rfc6675.html">RFC 6675</a>          SACK Loss Recovery Algorithm for TCP       August 2012</span>


   Note that steps (A) and (C) can potentially send a burst of
   back-to-back segments into the network if the incoming cumulative
   acknowledgment is for more than SMSS octets of data, or if incoming
   SACK blocks indicate that more than SMSS octets of data have been
   lost in the second half of the window.

<span class="h3"><a class="selflink" name="section-5.1" href="#section-5.1">5.1</a>.  Retransmission Timeouts</span>

   In order to avoid memory deadlocks, the TCP receiver is allowed to
   discard data that has already been selectively acknowledged.  As a
   result, [<a href="rfc2018.html" title="&quot;TCP Selective Acknowledgment Options&quot;">RFC2018</a>] suggests that a TCP sender SHOULD expunge the SACK
   information gathered from a receiver upon a retransmission timeout
   (RTO) "since the timeout might indicate that the data receiver has
   reneged."  Additionally, a TCP sender MUST "ignore prior SACK
   information in determining which data to retransmit."  However, since
   the publication of [<a href="rfc2018.html" title="&quot;TCP Selective Acknowledgment Options&quot;">RFC2018</a>], this has come to be viewed by some as
   too strong.  It has been suggested that, as long as robust tests for
   reneging are present, an implementation can retain and use SACK
   information across a timeout event [<a href="#ref-Errata1610">Errata1610</a>].  While this document
   does not change the specification in [<a href="rfc2018.html" title="&quot;TCP Selective Acknowledgment Options&quot;">RFC2018</a>], we note that
   implementers should consult any updates to [<a href="rfc2018.html" title="&quot;TCP Selective Acknowledgment Options&quot;">RFC2018</a>] on this subject.
   Further, a SACK TCP sender SHOULD utilize all SACK information made
   available during the loss recovery following an RTO.

   If an RTO occurs during loss recovery as specified in this document,
   RecoveryPoint MUST be set to HighData.  Further, the new value of
   RecoveryPoint MUST be preserved and the loss recovery algorithm
   outlined in this document MUST be terminated.  In addition, a new
   recovery phase (as described in <a href="#section-5">Section 5</a>) MUST NOT be initiated
   until HighACK is greater than or equal to the new value of
   RecoveryPoint.

   As described in Sections <a href="#section-4">4</a> and <a href="#section-5">5</a>, Update () SHOULD continue to be
   used appropriately upon receipt of ACKs.  This will allow the
   recovery period after an RTO to benefit from all available
   information provided by the receiver, even if SACK information was
   expunged due to the RTO.

   If there are segments missing from the receiver's buffer following
   processing of the retransmitted segment, the corresponding ACK will
   contain SACK information.  In this case, a TCP sender SHOULD use this
   SACK information when determining what data should be sent in each
   segment following an RTO.  The exact algorithm for this selection is
   not specified in this document (specifically NextSeg () is
   inappropriate during loss recovery after an RTO).  A relatively
   straightforward approach to "filling in" the sequence space reported
   as missing should be a reasonable approach.




<span class="grey">Blanton, et al.              Standards Track                   [Page 10]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-11" id="page-11" href="#page-11" class="invisible"> </a>
<span class="grey"><a href="rfc6675.html">RFC 6675</a>          SACK Loss Recovery Algorithm for TCP       August 2012</span>


<span class="h2"><a class="selflink" name="section-6" href="#section-6">6</a>.  Managing the RTO Timer</span>

   The standard TCP RTO estimator is defined in [<a href="rfc6298.html" title="&quot;Computing TCP's Retransmission Timer&quot;">RFC6298</a>].  Due to the
   fact that the SACK algorithm in this document can have an impact on
   the behavior of the estimator, implementers may wish to consider how
   the timer is managed.  [<a href="rfc6298.html" title="&quot;Computing TCP's Retransmission Timer&quot;">RFC6298</a>] calls for the RTO timer to be
   re-armed each time an ACK arrives that advances the cumulative ACK
   point.  Because the algorithm presented in this document can keep the
   ACK clock going through a fairly significant loss event
   (comparatively longer than the algorithm described in [<a href="rfc5681.html" title="&quot;TCP Congestion Control&quot;">RFC5681</a>]), on
   some networks the loss event could last longer than the RTO.  In this
   case the RTO timer would expire prematurely and a segment that need
   not be retransmitted would be resent.

   Therefore, we give implementers the latitude to use the standard
   [<a href="rfc6298.html" title="&quot;Computing TCP's Retransmission Timer&quot;">RFC6298</a>]-style RTO management or, optionally, a more careful variant
   that re-arms the RTO timer on each retransmission that is sent during
   recovery MAY be used.  This provides a more conservative timer than
   specified in [<a href="rfc6298.html" title="&quot;Computing TCP's Retransmission Timer&quot;">RFC6298</a>], and so may not always be an attractive
   alternative.  However, in some cases it may prevent needless
   retransmissions, go-back-N transmission, and further reduction of the
   congestion window.

<span class="h2"><a class="selflink" name="section-7" href="#section-7">7</a>.  Research</span>

   The algorithm specified in this document is analyzed in [<a href="#ref-FF96" title="&quot;Simulation-based Comparisons of Tahoe, Reno and SACK TCP&quot;">FF96</a>], which
   shows that the above algorithm is effective in reducing transfer time
   over standard TCP Reno [<a href="rfc5681.html" title="&quot;TCP Congestion Control&quot;">RFC5681</a>] when multiple segments are dropped
   from a window of data (especially as the number of drops increases).
   [<a href="#ref-AHKO97" title="&quot;TCP Performance Over Satellite Links&quot;">AHKO97</a>] shows that the algorithm defined in this document can
   greatly improve throughput in connections traversing satellite
   channels.

<span class="h2"><a class="selflink" name="section-8" href="#section-8">8</a>.  Security Considerations</span>

   The algorithm presented in this paper shares security considerations
   with [<a href="rfc5681.html" title="&quot;TCP Congestion Control&quot;">RFC5681</a>].  A key difference is that an algorithm based on SACKs
   is more robust against attackers forging duplicate ACKs to force the
   TCP sender to reduce cwnd.  With SACKs, TCP senders have an
   additional check on whether or not a particular ACK is legitimate.
   While not fool-proof, SACK does provide some amount of protection in
   this area.

   Similarly, [<a href="#ref-CPNI309" title="&quot;Security Assessment of the Transmission Control Protocol (TCP)&quot;">CPNI309</a>] sketches a variant of a blind attack [<a href="rfc5961.html" title="&quot;Improving TCP's Robustness to Blind In-Window Attacks&quot;">RFC5961</a>]
   whereby an attacker can spoof out-of-window data to a TCP endpoint,
   causing it to respond to the legitimate peer with a duplicate
   cumulative ACK, per [<a href="rfc793.html" title="&quot;Transmission Control Protocol&quot;">RFC793</a>].  Adding a SACK-based requirement to
   trigger loss recovery effectively mitigates this attack, as the



<span class="grey">Blanton, et al.              Standards Track                   [Page 11]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-12" id="page-12" href="#page-12" class="invisible"> </a>
<span class="grey"><a href="rfc6675.html">RFC 6675</a>          SACK Loss Recovery Algorithm for TCP       August 2012</span>


   duplicate ACKs caused by out-of-window segments will not contain SACK
   information indicating reception of previously un-SACKED in-window
   data.

<span class="h2"><a class="selflink" name="section-9" href="#section-9">9</a>.  Changes Relative to <a href="rfc3517.html">RFC 3517</a></span>

   The state variable "DupAcks" has been added to the list of variables
   maintained by this algorithm, and its usage specified.

   The function IsLost () has been modified to require that more than
   (DupThresh - 1) * SMSS octets have been SACKed above a given sequence
   number as indication that it is lost, which is changed from the
   minimum requirement of (DupThresh * SMSS) described in [<a href="rfc3517.html" title="&quot;A Conservative Selective Acknowledgment (SACK)-based Loss Recovery Algorithm for TCP&quot;">RFC3517</a>].
   This retains the requirement that at least three segments following
   the sequence number in question have been SACKed, while improving
   detection in the event that the sender has outstanding segments which
   are smaller than SMSS.

   The definition of a "duplicate acknowledgment" has been modified to
   utilize the SACK information in detecting loss.  Duplicate cumulative
   acknowledgments can be caused by either loss or reordering in the
   network.  To disambiguate loss and reordering, TCP's fast retransmit
   algorithm [<a href="rfc5681.html" title="&quot;TCP Congestion Control&quot;">RFC5681</a>] waits until three duplicate ACKs arrive to
   trigger loss recovery.  This notion was then the basis for the
   algorithm specified in [<a href="rfc3517.html" title="&quot;A Conservative Selective Acknowledgment (SACK)-based Loss Recovery Algorithm for TCP&quot;">RFC3517</a>].  However, with SACK information
   there is no need to rely blindly on the cumulative acknowledgment
   field.  We can leverage the additional information present in the
   SACK blocks to understand that three segments lying above a gap in
   the sequence space have arrived at the receiver, and can use this
   understanding to trigger loss recovery.  This notion was used in
   [<a href="rfc3517.html" title="&quot;A Conservative Selective Acknowledgment (SACK)-based Loss Recovery Algorithm for TCP&quot;">RFC3517</a>] during loss recovery, and the change in this document is
   that the notion is also used to enter a loss recovery phase.

   The state variable "RescueRxt" has been added to the list of
   variables maintained by the algorithm, and its usage specified.  This
   variable is used to allow for one extra retransmission per entry into
   loss recovery, in order to keep the ACK clock going under certain
   circumstances involving loss at the end of the window.  This
   mechanism allows for no more than one segment of no larger than 1
   SMSS to be optimistically retransmitted per loss recovery.

   Rule (3) of NextSeg() has been changed from MAY to SHOULD, to
   appropriately reflect the opinion of the authors and working group
   that it should be left in, rather than out, if an implementor does
   not have a compelling reason to do otherwise.






<span class="grey">Blanton, et al.              Standards Track                   [Page 12]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-13" id="page-13" href="#page-13" class="invisible"> </a>
<span class="grey"><a href="rfc6675.html">RFC 6675</a>          SACK Loss Recovery Algorithm for TCP       August 2012</span>


<span class="h2"><a class="selflink" name="section-10" href="#section-10">10</a>.  Acknowledgments</span>

   The authors wish to thank Sally Floyd for encouraging [<a href="rfc3517.html" title="&quot;A Conservative Selective Acknowledgment (SACK)-based Loss Recovery Algorithm for TCP&quot;">RFC3517</a>] and
   commenting on early drafts.  The algorithm described in this document
   is loosely based on an algorithm outlined by Kevin Fall and Sally
   Floyd in [<a href="#ref-FF96" title="&quot;Simulation-based Comparisons of Tahoe, Reno and SACK TCP&quot;">FF96</a>], although the authors of this document assume
   responsibility for any mistakes in the above text.

   [<a name="ref-RFC3517" id="ref-RFC3517">RFC3517</a>] was co-authored by Kevin Fall, who provided crucial input
   to that document and hence this follow-on work.

   Murali Bashyam, Ken Calvert, Tom Henderson, Reiner Ludwig, Jamshid
   Mahdavi, Matt Mathis, Shawn Ostermann, Vern Paxson, and Venkat
   Venkatsubra provided valuable feedback on earlier versions of this
   document.

   We thank Matt Mathis and Jamshid Mahdavi for implementing the
   scoreboard in ns and hence guiding our thinking in keeping track of
   SACK state.

   The first author would like to thank Ohio University and the Ohio
   University Internetworking Research Group for supporting the bulk of
   his work on <a href="rfc3517.html">RFC 3517</a>, from which this document is derived.

<span class="h2"><a class="selflink" name="section-11" href="#section-11">11</a>.  References</span>

<span class="h3"><a class="selflink" name="section-11.1" href="#section-11.1">11.1</a>.  Normative References</span>

   [<a name="ref-RFC793" id="ref-RFC793">RFC793</a>]   Postel, J., "Transmission Control Protocol", STD 7, <a href="rfc793.html">RFC</a>
              <a href="rfc793.html">793</a>, September 1981.

   [<a name="ref-RFC2018" id="ref-RFC2018">RFC2018</a>]  Mathis, M., Mahdavi, J., Floyd, S., and A. Romanow, "TCP
              Selective Acknowledgment Options", <a href="rfc2018.html">RFC 2018</a>, October 1996.

   [<a name="ref-RFC2119" id="ref-RFC2119">RFC2119</a>]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", <a href="https://tools.ietf.org/html/bcp14">BCP 14</a>, <a href="rfc2119.html">RFC 2119</a>, March 1997.

   [<a name="ref-RFC5681" id="ref-RFC5681">RFC5681</a>]  Allman, M., Paxson, V., and E. Blanton, "TCP Congestion
              Control", <a href="rfc5681.html">RFC 5681</a>, September 2009.

<span class="h3"><a class="selflink" name="section-11.2" href="#section-11.2">11.2</a>.  Informative References</span>

   [<a name="ref-AHKO97" id="ref-AHKO97">AHKO97</a>]   Mark Allman, Chris Hayes, Hans Kruse, Shawn Ostermann,
              "TCP Performance Over Satellite Links", Proceedings of the
              Fifth International Conference on Telecommunications
              Systems, Nashville, TN, March, 1997.





<span class="grey">Blanton, et al.              Standards Track                   [Page 13]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-14" id="page-14" href="#page-14" class="invisible"> </a>
<span class="grey"><a href="rfc6675.html">RFC 6675</a>          SACK Loss Recovery Algorithm for TCP       August 2012</span>


   [<a name="ref-All00" id="ref-All00">All00</a>]    Mark Allman, "A Web Server's View of the Transport Layer",
              ACM Computer Communication Review, 30(5), October 2000.

   [<a name="ref-CPNI309" id="ref-CPNI309">CPNI309</a>]  Fernando Gont, "Security Assessment of the Transmission
              Control Protocol (TCP)", CPNI Technical Note 3/2009,
              &lt;<a href="http://www.gont.com.ar/papers/tn-03-09-security-assessment-TCP.pdf">http://www.gont.com.ar/papers/</a>
              <a href="http://www.gont.com.ar/papers/tn-03-09-security-assessment-TCP.pdf">tn-03-09-security-assessment-TCP.pdf</a>&gt;, February 2009.

   [<a name="ref-Errata1610" id="ref-Errata1610">Errata1610</a>]
              RFC Errata, Errata ID 1610, <a href="rfc2018.html">RFC 2018</a>,
              &lt;<a href="http://www.rfc-editor.org/">http://www.rfc-editor.org</a>&gt;.

   [<a name="ref-FF96" id="ref-FF96">FF96</a>]     Kevin Fall and Sally Floyd, "Simulation-based Comparisons
              of Tahoe, Reno and SACK TCP", Computer Communication
              Review, July 1996.

   [<a name="ref-Jac90" id="ref-Jac90">Jac90</a>]    Van Jacobson, "Modified TCP Congestion Avoidance
              Algorithm", Technical Report, LBL, April 1990.

   [<a name="ref-PF01" id="ref-PF01">PF01</a>]     Jitendra Padhye, Sally Floyd "Identifying the TCP Behavior
              of Web Servers", ACM SIGCOMM, August 2001.

   [<a name="ref-RFC6582" id="ref-RFC6582">RFC6582</a>]  Henderson, T., Floyd, S., Gurtov, A., and Y. Nishida, "The
              NewReno Modification to TCP's Fast Recovery Algorithm",
              <a href="rfc6582.html">RFC 6582</a>, April 2012.

   [<a name="ref-RFC2914" id="ref-RFC2914">RFC2914</a>]  Floyd, S., "Congestion Control Principles", <a href="https://tools.ietf.org/html/bcp41">BCP 41</a>, <a href="rfc2914.html">RFC</a>
              <a href="rfc2914.html">2914</a>, September 2000.

   [<a name="ref-RFC6298" id="ref-RFC6298">RFC6298</a>]  Paxson, V., Allman, M., Chu, J., and M. Sargent,
              "Computing TCP's Retransmission Timer", <a href="rfc6298.html">RFC 6298</a>, June
              2011.

   [<a name="ref-RFC3517" id="ref-RFC3517">RFC3517</a>]  Blanton, E., Allman, M., Fall, K., and L. Wang, "A
              Conservative Selective Acknowledgment (SACK)-based Loss
              Recovery Algorithm for TCP", <a href="rfc3517.html">RFC 3517</a>, April 2003.

   [<a name="ref-RFC5961" id="ref-RFC5961">RFC5961</a>]  Ramaiah, A., Stewart, R., and M. Dalal, "Improving TCP's
              Robustness to Blind In-Window Attacks", <a href="rfc5961.html">RFC 5961</a>, August
              2010.











<span class="grey">Blanton, et al.              Standards Track                   [Page 14]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-15" id="page-15" href="#page-15" class="invisible"> </a>
<span class="grey"><a href="rfc6675.html">RFC 6675</a>          SACK Loss Recovery Algorithm for TCP       August 2012</span>


Authors' Addresses

   Ethan Blanton
   Purdue University Computer Sciences
   305 N. University St.
   West Lafayette, IN 47907
   United States
   EMail: elb@psg.com

   Mark Allman
   International Computer Science Institute
   1947 Center St. Suite 600
   Berkeley, CA 94704
   United States
   EMail: mallman@icir.org
   <a href="http://www.icir.org/mallman">http://www.icir.org/mallman</a>

   Lili Wang
   Juniper Networks
   10 Technology Park Drive
   Westford, MA 01886
   United States
   EMail: liliw@juniper.net

   Ilpo Jarvinen
   University of Helsinki
   P.O. Box 68
   FI-00014 UNIVERSITY OF HELSINKI
   Finland
   EMail: ilpo.jarvinen@helsinki.fi

   Markku Kojo
   University of Helsinki
   P.O. Box 68
   FI-00014 UNIVERSITY OF HELSINKI
   Finland
   EMail: kojo@cs.helsinki.fi

   Yoshifumi Nishida
   WIDE Project
   Endo 5322
   Fujisawa, Kanagawa 252-8520
   Japan
   EMail: nishida@wide.ad.jp







Blanton, et al.              Standards Track                   [Page 15]

</pre><br />
    <span class="noprint"><small><small>Html markup produced by rfcmarkup 1.126, available from
      <a href="https://tools.ietf.org/tools/rfcmarkup/">https://tools.ietf.org/tools/rfcmarkup/</a>
    </small></small></span>
  </div>
</body>

<!-- Mirrored from tools.ietf.org/html/rfc6675 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 06 Mar 2018 23:18:27 GMT -->
</html>
