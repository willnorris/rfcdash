<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml"><!-- Mirrored from tools.ietf.org/html/rfc7055 by HTTrack Website Copier/3.x [XR&CO'2013], Tue, 23 Aug 2016 18:36:45 GMT --><!-- Added by HTTrack --><head><meta content="text/html;charset=utf-8" http-equiv="content-type"/><!-- /Added by HTTrack -->

    <meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
    <meta content="index,follow" name="robots"/>
    <meta content="rfcmarkup version 1.119" name="creator"/>
    <link href="http://purl.org/dc/elements/1.1/" rel="schema.DC"/>
<meta content="draft-howlett-eap-gss" name="DC.Relation.Replaces"/>
<meta content="urn:ietf:rfc:7055" name="DC.Identifier"/>
<meta content="December, 2013" name="DC.Date.Issued"/>
<meta content="Hartman, Sam" name="DC.Creator"/>
<meta content="Howlett, Josh" name="DC.Creator"/>
<meta content="This document defines protocols, procedures, and conventions to be
employed by peers implementing the Generic Security Service
Application Program Interface (GSS-API) when using the Extensible
Authentication Protocol mechanism. Through the GS2 family of
mechanisms defined in RFC 5801, these protocols also define how Simple
Authentication and Security Layer (SASL) applications use the
Extensible Authentication Protocol." name="DC.Description.Abstract"/>
<meta content="A GSS-API Mechanism for the Extensible Authentication Protocol" name="DC.Title"/>

    <link href="https://tools.ietf.org/images/rfc.png" rel="icon" type="image/png"/>
    <link href="https://tools.ietf.org/images/rfc.png" rel="shortcut icon" type="image/png"/>
    <title>RFC 7055 - A GSS-API Mechanism for the Extensible Authentication Protocol</title>
    
    
    <style type="text/css">
	@media only screen 
	  and (min-width: 992px)
	  and (max-width: 1199px) {
	    body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 768px)
	  and (max-width: 991px) {
            body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 480px)
	  and (max-width: 767px) {
            body { font-size: 11pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (max-width: 479px) {
            body { font-size: 8pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-device-width : 375px) 
	  and (max-device-width : 667px) {
            body { font-size: 9.5pt; }
            div.content { width: 96ex; margin: 0 1px; }
        }
	@media only screen 
	  and (min-device-width: 1200px) {
            body { font-size: 10pt; margin: 0 4em; }
            div.content { width: 96ex; margin: 0; }
        }
        h1, h2, h3, h4, h5, h6, .h1, .h2, .h3, .h4, .h5, .h6 {
	    font-weight: bold;
            line-height: 0pt;
            display: inline;
            white-space: pre;
            font-family: monospace;
            font-size: 1em;
	    font-weight: bold;
        }
        pre {
            font-size: 1em;
            margin-top: 0px;
            margin-bottom: 0px;
        }
	.pre {
	    white-space: pre;
	    font-family: monospace;
	}
	.header{
	    font-weight: bold;
	}
        .newpage {
            page-break-before: always;
        }
        .invisible {
            text-decoration: none;
            color: white;
        }
        a.selflink {
          color: black;
          text-decoration: none;
        }
        @media print {
            body {
                font-family: monospace;
                font-size: 10.5pt;
            }
            h1, h2, h3, h4, h5, h6 {
                font-size: 1em;
            }
        
            a:link, a:visited {
                color: inherit;
                text-decoration: none;
            }
            .noprint {
                display: none;
            }
        }
	@media screen {
	    .grey, .grey a:link, .grey a:visited {
		color: #777;
	    }
            .docinfo {
                background-color: #EEE;
            }
            .top {
                border-top: 7px solid #EEE;
            }
            .bgwhite  { background-color: white; }
            .bgred    { background-color: #F44; }
            .bggrey   { background-color: #666; }
            .bgbrown  { background-color: #840; }            
            .bgorange { background-color: #FA0; }
            .bgyellow { background-color: #EE0; }
            .bgmagenta{ background-color: #F4F; }
            .bgblue   { background-color: #66F; }
            .bgcyan   { background-color: #4DD; }
            .bggreen  { background-color: #4F4; }

            .legend   { font-size: 90%; }
            .cplate   { font-size: 70%; border: solid grey 1px; }
	}
    </style>
    <!--[if IE]>
    <style>
    body {
       font-size: 13px;
       margin: 10px 10px;
    }
    </style>
    <![endif]-->

    <script type="text/javascript"><!--
    function addHeaderTags() {
	var spans = document.getElementsByTagName("span");
	for (var i=0; i < spans.length; i++) {
	    var elem = spans[i];
	    if (elem) {
		var level = elem.getAttribute("class");
                if (level == "h1" || level == "h2" || level == "h3" || level == "h4" || level == "h5" || level == "h6") {
                    elem.innerHTML = "<"+level+">"+elem.innerHTML+"</"+level+">";		
                }
	    }
	}
    }
    var legend_html = "Colour legend:<br />      <table>         <tr><td>Unknown:</td>                   <td><span class='cplate bgwhite'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft:</td>                     <td><span class='cplate bgred'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Informational:</td>             <td><span class='cplate bgorange'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Experimental:</td>              <td><span class='cplate bgyellow'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Best Common Practice:</td>      <td><span class='cplate bgmagenta'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Proposed Standard:</td>         <td><span class='cplate bgblue'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft Standard (old designation):</td> <td><span class='cplate bgcyan'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Internet Standard:</td>         <td><span class='cplate bggreen'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Historic:</td>                  <td><span class='cplate bggrey'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Obsolete:</td>                  <td><span class='cplate bgbrown'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>     </table>";
    function showElem(id) {
        var elem = document.getElementById(id);
        elem.innerHTML = eval(id+"_html");
        elem.style.visibility='visible';
    }
    function hideElem(id) {
        var elem = document.getElementById(id);
        elem.style.visibility='hidden';        
        elem.innerHTML = "";
    }
    // -->
    </script>
</head>
<body onload="addHeaderTags()">
  <div class="content">
   <div style="height: 13px;">
      <div class="pre noprint docinfo bgblue" onclick="showElem('legend');" onmouseout="hideElem('legend')" onmouseover="this.style.cursor='pointer';" style="height: 6px; position: absolute;" title="Click for colour legend.">                                                                        </div>
      <div class="docinfo noprint pre legend" id="legend" onmouseout="hideElem('legend');" onmouseover="showElem('legend');" style="position:absolute; top: 4px; left: 4ex; visibility:hidden; background-color: white; padding: 4px 9px 5px 7px; border: solid #345 1px; ">
      </div>
   </div>
<span class="pre noprint docinfo top">[<a href="index.html" title="Document search and retrieval page">Docs</a>] [<a href="https://tools.ietf.org/rfc/rfc7055.txt" title="Plaintext version of this document">txt</a>|<a href="https://tools.ietf.org/pdf/rfc7055" title="PDF version of this document">pdf</a>] [<a href="https://tools.ietf.org/html/draft-ietf-abfab-gss-eap" title="draft-ietf-abfab-gss-eap">draft-ietf-abfab-...</a>] [<a href="https://tools.ietf.org/rfcdiff?difftype=--hwdiff&amp;url2=rfc7055" title="Inline diff (wdiff)">Diff1</a>] [<a href="https://tools.ietf.org/rfcdiff?url2=rfc7055" title="Side-by-side diff">Diff2</a>]                 </span><br/>
<span class="pre noprint docinfo">                                                                        </span><br/>
<span class="pre noprint docinfo">                                                       PROPOSED STANDARD</span><br/>
<span class="pre noprint docinfo">                                                                        </span><br/>
<pre>Internet Engineering Task Force (IETF)                   S. Hartman, Ed.
Request for Comments: 7055                             Painless Security
Category: Standards Track                                     J. Howlett
ISSN: 2070-1721                                                JANET(UK)
                                                           December 2013


     <span class="h1">A GSS-API Mechanism for the Extensible Authentication Protocol</span>

Abstract

   This document defines protocols, procedures, and conventions to be
   employed by peers implementing the Generic Security Service
   Application Program Interface (GSS-API) when using the Extensible
   Authentication Protocol mechanism.  Through the GS2 family of
   mechanisms defined in <a href="rfc5801.html">RFC 5801</a>, these protocols also define how
   Simple Authentication and Security Layer (SASL) applications use the
   Extensible Authentication Protocol.

Status of This Memo

   This is an Internet Standards Track document.

   This document is a product of the Internet Engineering Task Force
   (IETF).  It represents the consensus of the IETF community.  It has
   received public review and has been approved for publication by the
   Internet Engineering Steering Group (IESG).  Further information on
   Internet Standards is available in <a href="rfc5741.html#section-2">Section 2 of RFC 5741</a>.

   Information about the current status of this document, any errata,
   and how to provide feedback on it may be obtained at
   <a href="http://www.rfc-editor.org/info/rfc7055">http://www.rfc-editor.org/info/rfc7055</a>.

Copyright Notice

   Copyright (c) 2013 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to <a href="https://tools.ietf.org/html/bcp78">BCP 78</a> and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (<a href="http://trustee.ietf.org/license-info">http://trustee.ietf.org/license-info</a>) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.




<span class="grey">Hartman &amp; Howlett            Standards Track                    [Page 1]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-2" id="page-2" name="page-2"> </a>
<span class="grey"><a href="rfc7055.html">RFC 7055</a>                       EAP GSS-API                 December 2013</span>


Table of Contents

   <a href="#section-1">1</a>. Introduction ....................................................<a href="#page-3">3</a>
      <a href="#section-1.1">1.1</a>. Discovery ..................................................<a href="#page-4">4</a>
      <a href="#section-1.2">1.2</a>. Authentication .............................................<a href="#page-4">4</a>
      <a href="#section-1.3">1.3</a>. Secure Association Protocol ................................<a href="#page-6">6</a>
   <a href="#section-2">2</a>. Requirements Notation ...........................................<a href="#page-6">6</a>
   <a href="#section-3">3</a>. EAP Channel Binding and Naming ..................................<a href="#page-6">6</a>
      <a href="#section-3.1">3.1</a>. Mechanism Name Format ......................................<a href="#page-7">7</a>
      <a href="#section-3.2">3.2</a>. Internationalization of Names .............................<a href="#page-10">10</a>
      <a href="#section-3.3">3.3</a>. Exported Mechanism Names ..................................<a href="#page-10">10</a>
      <a href="#section-3.4">3.4</a>. Acceptor Name RADIUS AVP ..................................<a href="#page-11">11</a>
      <a href="#section-3.5">3.5</a>. Proxy Verification of Acceptor Name .......................<a href="#page-11">11</a>
   <a href="#section-4">4</a>. Selection of EAP Method ........................................<a href="#page-12">12</a>
   <a href="#section-5">5</a>. Context Tokens .................................................<a href="#page-13">13</a>
      <a href="#section-5.1">5.1</a>. Mechanisms and Encryption Types ...........................<a href="#page-14">14</a>
      <a href="#section-5.2">5.2</a>. Processing Received Tokens ................................<a href="#page-15">15</a>
      <a href="#section-5.3">5.3</a>. Error Subtokens ...........................................<a href="#page-16">16</a>
      <a href="#section-5.4">5.4</a>. Initial State .............................................<a href="#page-16">16</a>
           <a href="#section-5.4.1">5.4.1</a>. Vendor Subtoken ....................................<a href="#page-17">17</a>
           <a href="#section-5.4.2">5.4.2</a>. Acceptor Name Request ..............................<a href="#page-17">17</a>
           <a href="#section-5.4.3">5.4.3</a>. Acceptor Name Response .............................<a href="#page-18">18</a>
      <a href="#section-5.5">5.5</a>. Authenticate State ........................................<a href="#page-18">18</a>
           <a href="#section-5.5.1">5.5.1</a>. EAP Request Subtoken ...............................<a href="#page-19">19</a>
           <a href="#section-5.5.2">5.5.2</a>. EAP Response Subtoken ..............................<a href="#page-19">19</a>
      <a href="#section-5.6">5.6</a>. Extensions State ..........................................<a href="#page-20">20</a>
           <a href="#section-5.6.1">5.6.1</a>. Flags Subtoken .....................................<a href="#page-20">20</a>
           <a href="#section-5.6.2">5.6.2</a>. GSS Channel Bindings Subtoken ......................<a href="#page-20">20</a>
           <a href="#section-5.6.3">5.6.3</a>. MIC Subtoken .......................................<a href="#page-21">21</a>
      <a href="#section-5.7">5.7</a>. Example Token .............................................<a href="#page-22">22</a>
      <a href="#section-5.8">5.8</a>. Context Options ...........................................<a href="#page-23">23</a>
   <a href="#section-6">6</a>. Acceptor Services ..............................................<a href="#page-23">23</a>
      <a href="#section-6.1">6.1</a>. GSS-API Channel Binding ...................................<a href="#page-24">24</a>
      <a href="#section-6.2">6.2</a>. Per-Message Security ......................................<a href="#page-24">24</a>
      <a href="#section-6.3">6.3</a>. Pseudorandom Function .....................................<a href="#page-24">24</a>
   <a href="#section-7">7</a>. IANA Considerations ............................................<a href="#page-25">25</a>
      <a href="#section-7.1">7.1</a>. OID Registry ..............................................<a href="#page-25">25</a>
      <a href="#section-7.2">7.2</a>. <a href="rfc4121.html">RFC 4121</a> Token Identifiers ................................<a href="#page-26">26</a>
      <a href="#section-7.3">7.3</a>. GSS-EAP Subtoken Types ....................................<a href="#page-26">26</a>
      <a href="#section-7.4">7.4</a>. RADIUS Attribute Assignments ..............................<a href="#page-27">27</a>
      <a href="#section-7.5">7.5</a>. Registration of the EAP-AES128 SASL Mechanisms ............<a href="#page-28">28</a>
      <a href="#section-7.6">7.6</a>. GSS-EAP Errors ............................................<a href="#page-28">28</a>
      <a href="#section-7.7">7.7</a>. GSS-EAP Context Flags .....................................<a href="#page-30">30</a>
   <a href="#section-8">8</a>. Security Considerations ........................................<a href="#page-30">30</a>
   <a href="#section-9">9</a>. Acknowledgements ...............................................<a href="#page-32">32</a>
   <a href="#section-10">10</a>. References ....................................................<a href="#page-32">32</a>
   <a href="#appendix-A">Appendix A</a>. Pre-publication RADIUS VSA ............................<a href="#page-33">33</a>




<span class="grey">Hartman &amp; Howlett            Standards Track                    [Page 2]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-3" id="page-3" name="page-3"> </a>
<span class="grey"><a href="rfc7055.html">RFC 7055</a>                       EAP GSS-API                 December 2013</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/1.%20%20Introduction"></a><a class="selflink" href="#section-1" name="section-1">1</a>.  Introduction</span>

   The Application Bridging for Federated Access Beyond Web (ABFAB)
   document [<a href="#ref-ABFAB-ARCH">ABFAB-ARCH</a>] describes an architecture for providing
   federated access management to applications using the Generic
   Security Service Application Programming Interface (GSS-API)
   [<a href="rfc2743.html" title='"Generic Security Service Application Program Interface Version 2, Update 1"'>RFC2743</a>] and Simple Authentication and Security Layer (SASL)
   [<a href="rfc4422.html" title='"Simple Authentication and Security Layer (SASL)"'>RFC4422</a>].  This specification provides the core mechanism for
   bringing federated authentication to these applications.

   The Extensible Authentication Protocol (EAP) [<a href="rfc3748.html" title='"Extensible Authentication Protocol (EAP)"'>RFC3748</a>] defines a
   framework for authenticating a network access client and server in
   order to gain access to a network.  A variety of different EAP
   methods are in wide use; one of EAP's strengths is that for most
   types of credentials in common use, there is an EAP method that
   permits the credential to be used.

   EAP is often used in conjunction with a backend Authentication,
   Authorization and Accounting (AAA) server via RADIUS [<a href="rfc3579.html" title='"RADIUS (Remote Authentication Dial In User Service) Support For Extensible Authentication Protocol (EAP)"'>RFC3579</a>] or
   Diameter [<a href="rfc4072.html" title='"Diameter Extensible Authentication Protocol (EAP) Application"'>RFC4072</a>].  In this mode, the Network Access Server (NAS)
   simply tunnels EAP packets over the backend authentication protocol
   to a home EAP/AAA server for the client.  After EAP succeeds, the
   backend authentication protocol is used to communicate key material
   to the NAS.  In this mode, the NAS need not be aware of or have any
   specific support for the EAP method used between the client and the
   home EAP server.  The client and EAP server share a credential that
   depends on the EAP method; the NAS and AAA server share a credential
   based on the backend authentication protocol in use.  The backend
   authentication server acts as a trusted third party, enabling network
   access even though the client and NAS may not actually share any
   common authentication methods.  As described in the architecture
   document [<a href="#ref-ABFAB-ARCH">ABFAB-ARCH</a>], using AAA proxies, this mode can be extended
   beyond one organization to provide federated authentication for
   network access.

   The GSS-API provides a generic framework for applications to use
   security services including authentication and per-message data
   security.  Between protocols that support GSS-API directly or
   protocols that support SASL [<a href="rfc4422.html" title='"Simple Authentication and Security Layer (SASL)"'>RFC4422</a>], many application protocols can
   use GSS-API for security services.  However, with the exception of
   Kerberos [<a href="rfc4121.html" title='"The Kerberos Version 5 Generic Security Service Application Program Interface (GSS-API) Mechanism: Version 2"'>RFC4121</a>], few GSS-API mechanisms are in wide use on the
   Internet.  While GSS-API permits an application to be written
   independent of the specific GSS-API mechanism in use, there is no
   facility to separate the server from the implementation of the
   mechanism as there is with EAP and backend authentication servers.






<span class="grey">Hartman &amp; Howlett            Standards Track                    [Page 3]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-4" id="page-4" name="page-4"> </a>
<span class="grey"><a href="rfc7055.html">RFC 7055</a>                       EAP GSS-API                 December 2013</span>


   The goal of this specification is to combine GSS-API's support for
   application protocols with EAP/AAA's support for common credential
   types and for authenticating to a server without requiring that
   server to specifically support the authentication method in use.  In
   addition, this specification supports the architectural goal of
   transporting attributes about subjects to relying parties.  Together
   this combination will provide federated authentication and
   authorization for GSS-API applications.  This specification meets the
   applicability requirements for EAP to application authentication
   [<a href="rfc7057.html" title='"Update to the Extensible Authentication Protocol (EAP) Applicability Statement for Application Bridging for Federated Access Beyond Web (ABFAB)"'>RFC7057</a>].

   This mechanism is a GSS-API mechanism that encapsulates an EAP
   conversation.  From the perspective of <a href="rfc3748.html">RFC 3748</a>, this specification
   defines a new lower-layer protocol for EAP.  From the perspective of
   the application, this specification defines a new GSS-API mechanism.

   <a href="rfc5247.html#section-1.3">Section 1.3 of [RFC5247]</a> outlines the typical conversation between
   EAP peers where an EAP key is derived:

   Phase 0: Discovery
   Phase 1: Authentication
            1a: EAP authentication
            1b: AAA Key Transport (optional)
   Phase 2: Secure Association Protocol
            2a: Unicast Secure Association
            2b: Multicast Secure Association (optional)

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/1.1.%20%20Discovery"></a><a class="selflink" href="#section-1.1" name="section-1.1">1.1</a>.  Discovery</span>

   GSS-API peers discover each other and discover support for GSS-API in
   an application-dependent mechanism.  SASL [<a href="rfc4422.html" title='"Simple Authentication and Security Layer (SASL)"'>RFC4422</a>] describes how
   discovery of a particular SASL mechanism such as a GSS-API EAP
   mechanism is conducted.  The Simple and Protected Negotiation
   mechanism (SPNEGO) [<a href="rfc4178.html" title='"The Simple and Protected Generic Security Service Application Program Interface (GSS-API) Negotiation Mechanism"'>RFC4178</a>] provides another approach for
   discovering what GSS-API mechanisms are available.  The specific
   approach used for discovery is out of scope for this mechanism.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/1.2.%20%20Authentication"></a><a class="selflink" href="#section-1.2" name="section-1.2">1.2</a>.  Authentication</span>

   GSS-API authenticates a party called the "GSS-API initiator" to the
   GSS-API acceptor, optionally providing authentication of the acceptor
   to the initiator.  Authentication starts with a mechanism-specific
   message called a "context token" sent from the initiator to the
   acceptor.  The acceptor responds, followed by the initiator, and so
   on until authentication succeeds or fails.  GSS-API context tokens
   are reliably delivered by the application using GSS-API.  The
   application is responsible for in-order delivery and retransmission.




<span class="grey">Hartman &amp; Howlett            Standards Track                    [Page 4]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-5" id="page-5" name="page-5"> </a>
<span class="grey"><a href="rfc7055.html">RFC 7055</a>                       EAP GSS-API                 December 2013</span>


   EAP authenticates a party called a "peer" to a party called the "EAP
   server".  A third party called an "EAP pass-through authenticator"
   may decapsulate EAP messages from a lower layer and re-encapsulate
   them into a AAA protocol.  The term EAP authenticator refers to
   whichever of the pass-through authenticator or EAP server receives
   the lower-layer EAP packets.  The first EAP message travels from the
   authenticator to the peer; a GSS-API message is sent from the
   initiator to acceptor to prompt the authenticator to send the first
   EAP message.  The EAP peer maps onto the GSS-API initiator.  The role
   of the GSS-API acceptor is split between the EAP authenticator and
   the EAP server.  When these two entities are combined, the division
   resembles GSS-API acceptors in other mechanisms.  When a more typical
   deployment is used and there is a pass-through authenticator, most
   context establishment takes place on the EAP server and per-message
   operations take place on the authenticator.  EAP messages from the
   peer to the authenticator are called responses; messages from the
   authenticator to the peer are called requests.

   Because GSS-API applications provide guaranteed delivery of context
   tokens, the EAP retransmission timeout MUST be infinite and the EAP
   layer MUST NOT retransmit a message.

   This specification permits a GSS-API acceptor to hand off the
   processing of the EAP packets to a remote EAP server by using AAA
   protocols such as RADIUS, Transport Layer Security (TLS) Encryption
   thereof [<a href="rfc6929.html" title='"Remote Authentication Dial In User Service (RADIUS) Protocol Extensions"'>RFC6929</a>], or Diameter.  In this case, the GSS-API acceptor
   acts as an EAP pass-through authenticator.  The pass-through
   authenticator is responsible for retransmitting AAA messages if a
   response is not received from the AAA server.  If a response cannot
   be received, then the authenticator generates an error at the GSS-API
   level.  If EAP authentication is successful, and where the chosen EAP
   method supports key derivation, EAP keying material may also be
   derived.  If a AAA protocol is used, this can also be used to
   replicate the EAP Key from the EAP server to the EAP authenticator.

   See <a href="#section-5">Section 5</a> for details of the authentication exchange.















<span class="grey">Hartman &amp; Howlett            Standards Track                    [Page 5]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-6" id="page-6" name="page-6"> </a>
<span class="grey"><a href="rfc7055.html">RFC 7055</a>                       EAP GSS-API                 December 2013</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/1.3.%20%20Secure%20Association%20Protocol"></a><a class="selflink" href="#section-1.3" name="section-1.3">1.3</a>.  Secure Association Protocol</span>

   After authentication succeeds, GSS-API provides a number of per-
   message security services that can be used:

      GSS_Wrap() provides integrity and optional confidentiality for a
      message.

      GSS_GetMIC() provides integrity protection for data sent
      independently of the GSS-API

      GSS_Pseudo_random [<a href="rfc4401.html" title='"A Pseudo-Random Function (PRF) API Extension for the Generic Security Service Application Program Interface (GSS-API)"'>RFC4401</a>] provides key derivation functionality.

   These services perform a function similar to secure association
   protocols in network access.  Like secure association protocols,
   these services need to be performed near the authenticator/acceptor
   even when a AAA protocol is used to separate the authenticator from
   the EAP server.  The key used for these per-message services is
   derived from the EAP key; the EAP peer and authenticator derive this
   key as a result of a successful EAP authentication.  In the case that
   the EAP authenticator is acting as a pass-through, it obtains it via
   the AAA protocol.  See <a href="#section-6">Section 6</a> for details.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/2.%20%20Requirements%20Notation"></a><a class="selflink" href="#section-2" name="section-2">2</a>.  Requirements Notation</span>

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in [<a href="rfc2119.html" title='"Key words for use in RFCs to Indicate Requirement Levels"'>RFC2119</a>].

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/3.%20%20EAP%20Channel%20Binding%20and%20Naming"></a><a class="selflink" href="#section-3" name="section-3">3</a>.  EAP Channel Binding and Naming</span>

   EAP authenticates a user to a realm.  The peer knows that it has
   exchanged authentication with an EAP server in a given realm.  Today,
   the peer does not typically know which NAS it is talking to securely.
   That is often fine for network access.  However, privileges to
   delegate to a chat server seem very different than privileges for a
   file server or trading site.  Also, an EAP peer knows the identity of
   the home realm, but perhaps not even the visited realm.

   In contrast, GSS-API takes a name for both the initiator and acceptor
   as inputs to the authentication process.  When mutual authentication
   is used, both parties are authenticated.  The granularity of these
   names is somewhat mechanism dependent.  In the case of the Kerberos
   mechanism, the acceptor name typically identifies both the protocol
   in use (such as IMAP) and the specific instance of the service being
   connected to.  The acceptor name almost always identifies the
   administrative domain providing service.




<span class="grey">Hartman &amp; Howlett            Standards Track                    [Page 6]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-7" id="page-7" name="page-7"> </a>
<span class="grey"><a href="rfc7055.html">RFC 7055</a>                       EAP GSS-API                 December 2013</span>


   A GSS-API EAP mechanism needs to provide GSS-API naming semantics in
   order to work with existing GSS-API applications.  EAP channel
   binding [<a href="rfc6677.html" title='"Channel-Binding Support for Extensible Authentication Protocol (EAP) Methods"'>RFC6677</a>] is used to provide GSS-API naming semantics.
   Channel binding sends a set of attributes from the peer to the EAP
   server either as part of the EAP conversation or as part of a secure
   association protocol.  In addition, attributes are sent in the
   backend authentication protocol from the authenticator to the EAP
   server.  The EAP server confirms the consistency of these attributes.
   Confirming attribute consistency also involves checking consistency
   against a local policy database as discussed in <a href="#section-3.5">Section 3.5</a>.  In
   particular, the peer sends the name of the acceptor it is
   authenticating to as part of channel binding.  The acceptor sends its
   full name as part of the backend authentication protocol.  The EAP
   server confirms consistency of the names.

   EAP channel binding is easily confused with a facility in GSS-API
   also called "channel binding".  GSS-API channel binding provides
   protection against man-in-the-middle attacks when GSS-API is used as
   authentication inside some tunnel; it is similar to a facility called
   "cryptographic binding" in EAP.  See [<a href="rfc5056.html" title='"On the Use of Channel Bindings to Secure Channels"'>RFC5056</a>] for a discussion of
   the differences between these two facilities and <a href="#section-6.1">Section 6.1</a> for how
   GSS-API channel binding is handled in this mechanism.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.1.%20%20Mechanism%20Name%20Format"></a><a class="selflink" href="#section-3.1" name="section-3.1">3.1</a>.  Mechanism Name Format</span>

   Before discussing how the initiator and acceptor names are validated
   in the AAA infrastructure, it is necessary to discuss what composes a
   name for an EAP GSS-API mechanism.  GSS-API permits several types of
   generic names to be imported using GSS_Import_name().  Once a
   mechanism is chosen, these names are converted into a mechanism-
   specific name called a "Mechanism Name".  Note that a Mechanism Name
   is the name of an initiator or acceptor, not of a GSS-API mechanism.
   This section first discusses the mechanism name form and then
   discusses what name forms are supported.

















<span class="grey">Hartman &amp; Howlett            Standards Track                    [Page 7]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-8" id="page-8" name="page-8"> </a>
<span class="grey"><a href="rfc7055.html">RFC 7055</a>                       EAP GSS-API                 December 2013</span>


   The string representation of the GSS-EAP mechanism name has the
   following ABNF [<a href="rfc5234.html" title='"Augmented BNF for Syntax Specifications: ABNF"'>RFC5234</a>] representation:

        char-normal = %x00-2E/%x30-3F/%x41-5B/%x5D-FF
        char-escaped = "\" %x2F / "\" %x40 / "\" %x5C
        name-char = char-normal / char-escaped
        name-string = 1*name-char
        user-or-service = name-string
        host = [name-string]
        realm = name-string
        service-specific = name-string
        service-specifics = service-specific 0*("/" service-specifics)
        name = user-or-service ["/" host [ "/" service-specifics]] [ "@"
                realm ]

   Special characters appearing in a name can be backslash escaped to
   avoid their special meanings.  For example, "\\" represents a literal
   backslash.  This escaping mechanism is a property of the string
   representation; if the components of a name are transported in some
   mechanism that will keep them separate without backslash escaping,
   then backslash SHOULD have no special meaning.

   The user-or-service component is similar to the portion of a network
   access identifier (NAI) before the '@' symbol for initiator names and
   the service name from the registry of GSS-API host-based services in
   the case of acceptor names [<a href="#ref-GSS-IANA" title='"GSS-API Service Name Registry"'>GSS-IANA</a>].  The NAI specification
   provides rules for encoding and string preparation in order to
   support internationalization of NAIs; implementations of this
   mechanism MUST NOT prepare the user-or-service according to these
   rules; see <a href="#section-3.2">Section 3.2</a> for internationalization of this mechanism.
   The host portion is empty for initiators and typically contains the
   domain name of the system on which an acceptor service is running.
   Some services MAY require additional parameters to distinguish the
   entity being authenticated against.  Such parameters are encoded in
   the service-specifics portion of the name.  The EAP server MUST
   reject authentication of any acceptor name that has a non-empty
   service-specifics component unless the EAP server understands the
   service-specifics and authenticates them.  The interpretation of the
   service-specifics is scoped by the user-or-service portion.  The
   realm is similar to the realm portion of a NAI for initiator names;
   again the NAI specification's internationalization rules MUST NOT be
   applied to the realm.  The realm is the administrative realm of a
   service for an acceptor name.

   The string representation of this name form is designed to be
   generally compatible with the string representation of Kerberos names
   defined in [<a href="rfc1964.html" title='"The Kerberos Version 5 GSS-API Mechanism"'>RFC1964</a>].




<span class="grey">Hartman &amp; Howlett            Standards Track                    [Page 8]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-9" id="page-9" name="page-9"> </a>
<span class="grey"><a href="rfc7055.html">RFC 7055</a>                       EAP GSS-API                 December 2013</span>


   The GSS_C_NT_USER_NAME form represents the name of an individual
   user.  From the standpoint of this mechanism, it may take the form of
   either an undecorated user name or a name semantically similar to a
   network access identifier (NAI) [<a href="rfc4282.html" title='"The Network Access Identifier"'>RFC4282</a>].  The name is split at the
   first at-sign ('@') into the part preceding the realm, which is the
   user-or-service portion of the mechanism name, and the realm portion,
   which is the realm portion of the mechanism name.

   The GSS_C_NT_HOSTBASED_SERVICE name form represents a service running
   on a host; it is textually represented as "service@host".  This name
   form is required by most SASL profiles and is used by many existing
   applications that use the Kerberos GSS-API mechanism.  While support
   for this name form is critical, it presents an interesting challenge
   in terms of EAP channel binding.  Consider a case where the server
   communicates with a "server proxy," or a AAA server near the server.
   That server proxy communicates with the EAP server.  The EAP server
   and server proxy are in different administrative realms.  The server
   proxy is in a position to verify that the request comes from the
   indicated host.  However, the EAP server cannot make this
   determination directly.  So, the EAP server needs to determine
   whether to trust the server proxy to verify the host portion of the
   acceptor name.  This trust decision depends both on the host name and
   the realm of the server proxy.  In effect, the EAP server decides
   whether to trust that the realm of the server proxy is the right
   realm for the given hostname and then makes a trust decision about
   the server proxy itself.  The same problem appears in Kerberos:
   there, clients decide what Kerberos realm to trust for a given
   hostname.  The service portion of this name is imported into the
   user-or-service portion of the mechanism name; the host portion is
   imported into the host portion of the mechanism name.  The realm
   portion is empty.  However, authentication will typically fail unless
   some AAA component indicates the realm to the EAP server.  If the
   application server knows its realm, then it should be indicated in
   the outgoing AAA request.  Otherwise, a proxy SHOULD add the realm.
   An alternate form of this name type MAY be used on acceptors; in this
   case, the name form is "service" with no host component.  This is
   imported with the service as user-or-service and an empty host and
   realm portion.  This form is useful when a service is unsure which
   name an initiator knows it by.

   If the null name type or the GSS_EAP_NT_EAP_NAME (OID
   1.3.6.1.5.5.15.2.1) (see <a href="#section-7.1">Section 7.1</a> ) is imported, then the string
   representation above should be directly imported.  Mechanisms MAY
   support the GSS_KRB5_NT_KRB5_PRINCIPAL_NAME name form with the OID
   {iso(1) member-body(2) United States(840) mit(113554) infosys(1)
   gssapi(2) krb5(2) krb5_name(1)}.  In many circumstances, Kerberos
   GSS-API mechanism names will behave as expected when used with the
   GSS-API EAP mechanism, but there are some differences that may cause



<span class="grey">Hartman &amp; Howlett            Standards Track                    [Page 9]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-10" id="page-10" name="page-10"> </a>
<span class="grey"><a href="rfc7055.html">RFC 7055</a>                       EAP GSS-API                 December 2013</span>


   some confusion.  If an implementation does support importing Kerberos
   names it SHOULD fail the import if the Kerberos name is not
   syntactically a valid GSS-API EAP mechanism name as defined in this
   section.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.2.%20%20Internationalization%20of%20Names"></a><a class="selflink" href="#section-3.2" name="section-3.2">3.2</a>.  Internationalization of Names</span>

   For the most part, GSS-EAP names are transported in other protocols;
   those protocols define the internationalization semantics.  For
   example, if a AAA server wishes to communicate the user-or-service
   portion of the initiator name to an acceptor, it does so using
   existing mechanisms in the AAA protocol.  Existing
   internationalization rules are applied.  Similarly, within an
   application, existing specifications such as [<a href="rfc5178.html" title='"Generic Security Service Application Program Interface (GSS-API) Internationalization and Domain-Based Service Names and Name Type"'>RFC5178</a>] define the
   encoding of names that are imported and displayed with the GSS-API.

   This mechanism does introduce a few cases where name components are
   sent.  In these cases, the encoding of the string is UTF-8.  Senders
   SHOULD NOT normalize or map strings before sending.  These strings
   include RADIUS attributes introduced in <a href="#section-3.4">Section 3.4</a>.

   When comparing the host portion of a GSS-EAP acceptor name supplied
   in EAP channel binding by a peer to that supplied by an acceptor, EAP
   servers SHOULD prepare the host portion according to [<a href="rfc5891.html" title='"Internationalized Domain Names in Applications (IDNA): Protocol"'>RFC5891</a>] prior
   to comparison.  Applications MAY prepare domain names prior to
   importing them into this mechanism.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.3.%20%20Exported%20Mechanism%20Names"></a><a class="selflink" href="#section-3.3" name="section-3.3">3.3</a>.  Exported Mechanism Names</span>

   GSS-API provides the GSS_Export_name call.  This call can be used to
   export the binary representation of a name.  This name form can be
   stored on access control lists for binary comparison.

   The exported name token MUST use the format described in <a href="rfc2743.html#section-3.2">Section 3.2
   of RFC 2743</a>.  The mechanism specific portion of this name token is
   the string format of the mechanism name described in <a href="#section-3.1">Section 3.1</a>.

   <a href="rfc2744.html">RFC 2744</a> [<a href="rfc2744.html" title='"Generic Security Service API Version 2 : C-bindings"'>RFC2744</a>] places the requirement that the result of
   importing a name, canonicalizing it to a Mechanism Name and then
   exporting it needs to be the same as importing that name, obtaining
   credentials for that principal, initiating a context with those
   credentials and exporting the name on the acceptor.  In practice, GSS
   mechanisms often, but not always, meet this requirement.  For names
   expected to be used as initiator names, this requirement is met.
   However, permitting empty host and realm components when importing
   host-based services may make it possible for an imported name to





<span class="grey">Hartman &amp; Howlett            Standards Track                   [Page 10]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-11" id="page-11" name="page-11"> </a>
<span class="grey"><a href="rfc7055.html">RFC 7055</a>                       EAP GSS-API                 December 2013</span>


   differ from the exported name actually used.  Other mechanisms such
   as Kerberos have similar situations where imported and exported names
   may differ.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.4.%20%20Acceptor%20Name%20RADIUS%20AVP"></a><a class="selflink" href="#section-3.4" name="section-3.4">3.4</a>.  Acceptor Name RADIUS AVP</span>

   See <a href="#section-7.4">Section 7.4</a> for registrations of RADIUS attribute types to carry
   the acceptor service name.  All the attribute types registered in
   that section are strings.  See <a href="#section-3.1">Section 3.1</a> for details of the values
   in a name.

   If RADIUS is used as a AAA transport, the acceptor MUST send the
   acceptor name in these attribute types.  That is, the acceptor
   decomposes its name and sends any non-empty portion as a RADIUS
   attribute.  With the exception of the service-specifics portion of
   the name, the backslash escaping mechanism is not used in RADIUS
   attributes; backslash has no special meaning.  In the service-
   specifics portion, a literal "/" separates components.  In this one
   attribute, "\/" indicates a slash character that does not separate
   components and "\\" indicates a literal backslash character.

   The initiator MUST require that the EAP method in use support channel
   binding and MUST send the acceptor name as part of the channel
   binding data.  The client MUST NOT indicate mutual authentication in
   the result of GSS_Init_sec_context unless all name elements that the
   client supplied are in a successful channel binding response.  For
   example, if the client supplied a hostname in channel binding data,
   the hostname MUST be in a successful channel binding response.

   If an empty target name is supplied to GSS_Init_sec_context, the
   initiator MUST fail context establishment unless the acceptor
   supplies the acceptor name response (<a href="#section-5.4.3">Section 5.4.3</a>).  If a null
   target name is supplied, the initiator MUST use this response to
   populate EAP channel bindings.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.5.%20%20Proxy%20Verification%20of%20Acceptor%20Name"></a><a class="selflink" href="#section-3.5" name="section-3.5">3.5</a>.  Proxy Verification of Acceptor Name</span>

   Proxies may play a role in verification of the acceptor identity.
   For example, a AAA proxy near the acceptor may be in a position to
   verify the acceptor hostname, while the EAP server is likely to be
   too distant to reliably verify this on its own.

   The EAP server or some proxy trusted by the EAP server is likely to
   be in a position to verify the acceptor realm.  In effect, this proxy
   is confirming that the right AAA credential is used for the claimed
   realm and thus that the acceptor is in the organization it claims to





<span class="grey">Hartman &amp; Howlett            Standards Track                   [Page 11]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-12" id="page-12" name="page-12"> </a>
<span class="grey"><a href="rfc7055.html">RFC 7055</a>                       EAP GSS-API                 December 2013</span>


   be part of.  This proxy is also typically trusted by the EAP server
   to make sure that the hostname claimed by the acceptor is a
   reasonable hostname for the realm of the acceptor.

   A proxy close to the EAP server is unlikely to be in a position to
   confirm that the acceptor is claiming the correct hostname.  Instead,
   this is typically delegated to a proxy near the acceptor.  That proxy
   is typically expected to verify the acceptor hostname and to verify
   the appropriate AAA credential for that host is used.  Such a proxy
   may insert the acceptor realm if it is absent, permitting realm
   configuration to be at the proxy boundary rather than on acceptors.

   Ultimately, specific proxy behavior is a matter for deployment.  The
   EAP server MUST assure that the appropriate validation has been done
   before including acceptor name attributes in a successful channel
   binding response.  If the acceptor service is included, the EAP
   server asserts that the service is plausible for the acceptor.  If
   the acceptor hostname is included, the EAP server asserts that the
   acceptor hostname is verified.  If the realm is included the EAP
   server asserts that the realm has been verified, and if the hostname
   was also included, that the realm and hostname are consistent.  Part
   of this verification MAY be delegated to proxies, but the EAP server
   configuration MUST guarantee that the combination of proxies meets
   these requirements.  Typically, such delegation will involve business
   or operational measures such as cross-organizational agreements as
   well as technical measures.

   It is likely that future technical work will be needed to communicate
   what verification has been done by proxies along the path.  Such
   technical measures will not release the EAP server from its
   responsibility to decide whether proxies on the path should be
   trusted to perform checks delegated to them.  However, technical
   measures could prevent misconfigurations and help to support diverse
   environments.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/4.%20%20Selection%20of%20EAP%20Method"></a><a class="selflink" href="#section-4" name="section-4">4</a>.  Selection of EAP Method</span>

   EAP does not provide a facility for an EAP server to advertise what
   methods are available to a peer.  Instead, a server starts with its
   preferred method selection.  If the peer does not accept that method,
   the peer sends a NAK response containing the list of methods
   supported by the client.

   Providing multiple facilities to negotiate which security mechanism
   to use is undesirable.  <a href="rfc4462.html#section-7.3">Section 7.3 of [RFC4462]</a>describes the problem
   referencing the Secure Shell (SSH) Protocol key exchange negotiation
   and the SPNEGO GSS-API mechanism.  If a client preferred an EAP
   method A, a non-EAP authentication mechanism B, and then an EAP



<span class="grey">Hartman &amp; Howlett            Standards Track                   [Page 12]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-13" id="page-13" name="page-13"> </a>
<span class="grey"><a href="rfc7055.html">RFC 7055</a>                       EAP GSS-API                 December 2013</span>


   method C, then the client would have to commit to using EAP before
   learning whether A is actually supported.  Such a client might end up
   using C when B is available.

   The standard solution to this problem is to perform all the
   negotiation at one layer.  In this case, rather than defining a
   single GSS-API mechanism, a family of mechanisms should be defined.
   Each mechanism corresponds to an EAP method.  The EAP method type
   should be part of the GSS-API OID.  Then, a GSS-API rather than EAP
   facility can be used for negotiation.

   Unfortunately, using a family of mechanisms has a number of problems.
   First, GSS-API assumes that both the initiator and acceptor know the
   entire set of mechanisms that are available.  Some negotiation
   mechanisms are driven by the client; others are driven by the server.
   With EAP GSS-API, the acceptor does not know what methods the EAP
   server implements.  The EAP server that is used depends on the
   identity of the client.  The best solution so far is to accept the
   disadvantages of multi-layer negotiation and commit to using EAP GSS-
   API before a specific EAP method.  This has two main disadvantages.
   First, authentication may fail when other methods might allow
   authentication to succeed.  Second, a non-optimal security mechanism
   may be chosen.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/5.%20%20Context%20Tokens"></a><a class="selflink" href="#section-5" name="section-5">5</a>.  Context Tokens</span>

   All context establishment tokens emitted by the EAP mechanism SHALL
   have the framing described in <a href="rfc2743.html#section-3.1">Section 3.1 of [RFC2743]</a>, as
   illustrated by the following pseudo-ASN.1 structures:

   GSS-API DEFINITIONS ::=
            BEGIN

            MechType ::= OBJECT IDENTIFIER
            -- representing EAP mechanism
            GSSAPI-Token ::=
            -- option indication (delegation, etc.) indicated within
            -- mechanism-specific token
            [APPLICATION 0] IMPLICIT SEQUENCE {
                    thisMech MechType,
                    innerToken ANY DEFINED BY thisMech
                       -- contents mechanism-specific
                       -- ASN.1 structure not required
                    }
            END






<span class="grey">Hartman &amp; Howlett            Standards Track                   [Page 13]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-14" id="page-14" name="page-14"> </a>
<span class="grey"><a href="rfc7055.html">RFC 7055</a>                       EAP GSS-API                 December 2013</span>


   The innerToken field starts with a 16-bit network byte order token
   type identifier.  The remainder of the innerToken field is a set of
   type-length-value subtokens.  The following figure describes the
   structure of the inner token:

              +----------------+---------------------------+
              | Octet Position | Description               |
              +----------------+---------------------------+
              | 0..1           | token ID                  |
              |                |                           |
              | 2..5           | first subtoken type       |
              |                |                           |
              | 6..9           | length  of first subtoken |
              |                |                           |
              | 10..10+n-1     | first subtoken body       |
              |                |                           |
              | 10+n..10+n+3   | second subtoken type      |
              +----------------+---------------------------+

                         Structure of Inner Token

   The inner token continues with length, second subtoken body, and so
   forth.  If a subtoken type is present, its length and body MUST be
   present.

   The length is a four-octet length of the subtoken body in network
   byte order.  The length does not include the length of the type field
   or the length field; the length only covers the body.

   Tokens from the initiator to acceptor use an inner token type with ID
   06 01; tokens from acceptor to initiator use an inner token type with
   ID 06 02.  These token types are registered in the registry of <a href="rfc4121.html">RFC</a>
   <a href="rfc4121.html">4121</a> token types; see <a href="#section-7.2">Section 7.2</a>.

   See <a href="#section-5.7">Section 5.7</a> for the encoding of a complete token.  The following
   sections discuss how mechanism OIDs are chosen and the state machine
   that defines what subtokens are permitted at each point in the
   context establishment process.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.1.%20%20Mechanisms%20and%20Encryption%20Types"></a><a class="selflink" href="#section-5.1" name="section-5.1">5.1</a>.  Mechanisms and Encryption Types</span>

   This mechanism family uses the security services of the Kerberos
   cryptographic framework [<a href="rfc3961.html" title='"Encryption and Checksum Specifications for Kerberos 5"'>RFC3961</a>].  The root of the OID ARC for
   mechanisms described in this document is 1.3.6.1.5.5.15.1.1; a
   Kerberos encryption type number [<a href="rfc3961.html" title='"Encryption and Checksum Specifications for Kerberos 5"'>RFC3961</a>] is appended to that root
   OID to form a mechanism OID.  As such, a particular encryption type
   needs to be chosen.  By convention, there is a single object
   identifier arc for the EAP family of GSS-API mechanisms.  A specific



<span class="grey">Hartman &amp; Howlett            Standards Track                   [Page 14]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-15" id="page-15" name="page-15"> </a>
<span class="grey"><a href="rfc7055.html">RFC 7055</a>                       EAP GSS-API                 December 2013</span>


   mechanism is chosen by adding the numeric Kerberos encryption type
   number to the root of this arc.  However, in order to register the
   SASL name, the specific usage with a given encryption type needs to
   be registered.  This document defines the EAP-AES128 GSS-API
   mechanism.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.2.%20%20Processing%20Received%20Tokens"></a><a class="selflink" href="#section-5.2" name="section-5.2">5.2</a>.  Processing Received Tokens</span>

   Whenever a context token is received, the receiver performs the
   following checks.  First, the receiver confirms the object identifier
   is that of the mechanism being used.  The receiver confirms that the
   token type corresponds to the role of the peer: acceptors will only
   process initiator tokens and initiators will only process acceptor
   tokens.

   Implementations of this mechanism maintain a state machine for the
   context establishment process.  Both the initiator and acceptor start
   out in the initial state; see <a href="#section-5.4">Section 5.4</a> for a description of this
   state.  Associated with each state are a set of subtoken types that
   are processed in that state and rules for processing these subtoken
   types.  The receiver examines the subtokens in order, processing any
   that are appropriate for the current state.  Unknown subtokens or
   subtokens that are not expected in the current state are ignored if
   their critical bit (see below) is clear.

   A state may have a set of required subtoken types.  If a subtoken
   type is required by the current state but no subtoken of that type is
   present, then the context establishment MUST fail.

   The most significant bit (0x80000000) in a subtoken type is the
   critical bit.  If a subtoken with this bit set in the type is
   received, the receiver MUST fail context establishment unless the
   subtoken is understood and processed for the current state.

   The subtoken type MUST be unique within a given token.
















<span class="grey">Hartman &amp; Howlett            Standards Track                   [Page 15]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-16" id="page-16" name="page-16"> </a>
<span class="grey"><a href="rfc7055.html">RFC 7055</a>                       EAP GSS-API                 December 2013</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.3.%20%20Error%20Subtokens"></a><a class="selflink" href="#section-5.3" name="section-5.3">5.3</a>.  Error Subtokens</span>

   The acceptor may always end the exchange by generating an error
   subtoken.  The error subtoken has the following format:

   +--------+----------------------------------------------------------+
   | Pos    | Description                                              |
   +--------+----------------------------------------------------------+
   | 0..3   | 0x80 00 00 01                                            |
   |        |                                                          |
   | 4..7   | length of error token                                    |
   |        |                                                          |
   | 8..11  | major status from <a href="rfc2744.html">RFC 2744</a> as 32-bit network byte order  |
   |        |                                                          |
   | 12..15 | GSS-EAP error code as 32-bit network byte order; see     |
   |        | <a href="#section-7.6">Section 7.6</a>                                              |
   +--------+----------------------------------------------------------+

   Initiators MUST ignore octets beyond the GSS-EAP error code for
   future extensibility.  As indicated, the error token is always marked
   critical.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.4.%20%20Initial%20State"></a><a class="selflink" href="#section-5.4" name="section-5.4">5.4</a>.  Initial State</span>

   Both the acceptor and initiator start the context establishment
   process in the initial state.

   The initiator sends a token to the acceptor.  It MAY be empty; no
   subtokens are required in this state.  Alternatively, the initiator
   MAY include a vendor ID subtoken or an acceptor name request
   subtoken.

   The acceptor responds to this message.  It MAY include an acceptor
   name response subtoken.  It MUST include a first EAP request; this is
   an EAP request/identity message (see <a href="#section-5.5.1">Section 5.5.1</a> for the format of
   this subtoken).

   The initiator and acceptor then transition to authenticate state.













<span class="grey">Hartman &amp; Howlett            Standards Track                   [Page 16]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-17" id="page-17" name="page-17"> </a>
<span class="grey"><a href="rfc7055.html">RFC 7055</a>                       EAP GSS-API                 December 2013</span>


<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/5.4.1.%20%20Vendor%20Subtoken"></a><a class="selflink" href="#section-5.4.1" name="section-5.4.1">5.4.1</a>.  Vendor Subtoken</span>

   The vendor ID subtoken has type 0x0000000B and the following
   structure:

                 +-------------+------------------------+
                 | Pos         | Description            |
                 +-------------+------------------------+
                 | 0..3        | 0x0000000B             |
                 |             |                        |
                 | 4..7        | length of vendor token |
                 |             |                        |
                 | 8..8+length | Vendor ID string       |
                 +-------------+------------------------+

   The vendor ID string is an UTF-8 string describing the vendor of this
   implementation.  This string is unstructured and for debugging
   purposes only.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/5.4.2.%20%20Acceptor%20Name%20Request"></a><a class="selflink" href="#section-5.4.2" name="section-5.4.2">5.4.2</a>.  Acceptor Name Request</span>

   The acceptor name request token is sent from the initiator to the
   acceptor indicating that the initiator wishes a particular acceptor
   name.  This is similar to Transport Layer Security (TLS) Server Name
   Indication [<a href="rfc6066.html" title='"Transport Layer Security (TLS) Extensions: Extension Definitions"'>RFC6066</a>] that permits a client to indicate which one of a
   number of virtual services to contact.  The structure is as follows:

                  +------+------------------------------+
                  | Pos  | Description                  |
                  +------+------------------------------+
                  | 0..3 | 0x00000002                   |
                  |      |                              |
                  | 4..7 | length of subtoken           |
                  |      |                              |
                  | 8..n | string form of acceptor name |
                  +------+------------------------------+

   It is likely that channel binding and thus authentication will fail
   if the acceptor does not choose a name that is a superset of this
   name.  That is, if a hostname is sent, the acceptor needs to be
   willing to accept this hostname.










<span class="grey">Hartman &amp; Howlett            Standards Track                   [Page 17]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-18" id="page-18" name="page-18"> </a>
<span class="grey"><a href="rfc7055.html">RFC 7055</a>                       EAP GSS-API                 December 2013</span>


<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/5.4.3.%20%20Acceptor%20Name%20Response"></a><a class="selflink" href="#section-5.4.3" name="section-5.4.3">5.4.3</a>.  Acceptor Name Response</span>

   The acceptor name response subtoken indicates what acceptor name is
   used.  This is useful, for example, if the initiator supplied no
   target name to the context initialization.  This allows the initiator
   to learn the acceptor name.  EAP channel bindings will provide
   confirmation that the acceptor is accurately naming itself.

   This token is sent from the acceptor to initiator.  In the Initial
   state, this token would typically be sent if the acceptor name
   request is absent, because if the initiator already sent an acceptor
   name, then the initiator knows what acceptor it wishes to contact.
   This subtoken is also sent in Extensions state <a href="#section-5.6">Section 5.6</a>, so the
   initiator can protect against a man-in-the-middle modifying the
   acceptor name request subtoken.

                  +------+------------------------------+
                  | Pos  | Description                  |
                  +------+------------------------------+
                  | 0..3 | 0x00000003                   |
                  |      |                              |
                  | 4..7 | length of subtoken           |
                  |      |                              |
                  | 8..n | string form of acceptor name |
                  +------+------------------------------+

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.5.%20%20Authenticate%20State"></a><a class="selflink" href="#section-5.5" name="section-5.5">5.5</a>.  Authenticate State</span>

   In this state, the acceptor sends EAP requests to the initiator and
   the initiator generates EAP responses.  The goal of the state is to
   perform a successful EAP authentication.  Since the acceptor sends an
   identity request at the end of the initial state, the first half-
   round-trip in this state is a response to that request from the
   initiator.

   The EAP conversation can end in a number of ways:

   o  If the EAP state machine generates an EAP Success message, then
      the EAP authenticator believes the authentication is successful.
      The acceptor MUST confirm that a key has been derived
      (<a href="rfc3748.html#section-7.10">Section 7.10 of [RFC3748]</a>).  The acceptor MUST confirm that this
      success indication is consistent with any protected result
      indication for combined authenticators and with AAA indication of
      success for pass-through authenticators.  If any of these checks
      fail, the acceptor MUST send an error subtoken and fail the
      context establishment.  If these checks succeed, the acceptor
      sends the Success message using the EAP Request subtoken type and
      transitions to Extensions state.  If the initiator receives an EAP



<span class="grey">Hartman &amp; Howlett            Standards Track                   [Page 18]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-19" id="page-19" name="page-19"> </a>
<span class="grey"><a href="rfc7055.html">RFC 7055</a>                       EAP GSS-API                 December 2013</span>


      Success message, it confirms that a key has been derived and that
      the EAP Success is consistent with any protected result
      indication.  If so, it transitions to Extensions state.
      Otherwise, it returns an error to the caller of
      GSS_Init_sec_context without producing an output token.

   o  If the acceptor receives an EAP failure, then the acceptor sends
      this in the EAP Request subtoken type.  If the initiator receives
      an EAP Failure, it returns GSS failure.

   o  If there is some other error, the acceptor MAY return an error
      subtoken.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/5.5.1.%20%20EAP%20Request%20Subtoken"></a><a class="selflink" href="#section-5.5.1" name="section-5.5.1">5.5.1</a>.  EAP Request Subtoken</span>

   The EAP Request subtoken is sent from the acceptor to the initiator.
   This subtoken is always critical and is REQUIRED in the
   authentication state.

                  +-------------+-----------------------+
                  | Pos         | Description           |
                  +-------------+-----------------------+
                  | 0..3        | 0x80000005            |
                  |             |                       |
                  | 4..7        | length of EAP message |
                  |             |                       |
                  | 8..8+length | EAP message           |
                  +-------------+-----------------------+

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/5.5.2.%20%20EAP%20Response%20Subtoken"></a><a class="selflink" href="#section-5.5.2" name="section-5.5.2">5.5.2</a>.  EAP Response Subtoken</span>

   This subtoken is REQUIRED in authentication state messages from the
   initiator to the acceptor.  It is always critical.

                  +-------------+-----------------------+
                  | Pos         | Description           |
                  +-------------+-----------------------+
                  | 0..3        | 0x80000004            |
                  |             |                       |
                  | 4..7        | length of EAP message |
                  |             |                       |
                  | 8..8+length | EAP message           |
                  +-------------+-----------------------+








<span class="grey">Hartman &amp; Howlett            Standards Track                   [Page 19]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-20" id="page-20" name="page-20"> </a>
<span class="grey"><a href="rfc7055.html">RFC 7055</a>                       EAP GSS-API                 December 2013</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.6.%20%20Extensions%20State"></a><a class="selflink" href="#section-5.6" name="section-5.6">5.6</a>.  Extensions State</span>

   After EAP Success, the initiator sends a token to the acceptor
   including additional subtokens that negotiate optional features or
   provide GSS-API channel binding (see <a href="#section-6.1">Section 6.1</a>).  The acceptor then
   responds with a token to the initiator.  When the acceptor produces
   its final token, it returns GSS_S_COMPLETE; when the initiator
   consumes this token, it returns GSS_S_COMPLETE if no errors are
   detected.

   The acceptor SHOULD send an acceptor name response (<a href="#section-5.4.3">Section 5.4.3</a>) so
   that the initiator can get a copy of the acceptor name protected by
   the Message Integrity Check (MIC) subtoken.

   Both the initiator and acceptor MUST include and verify a MIC
   subtoken to protect the extensions exchange.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/5.6.1.%20%20Flags%20Subtoken"></a><a class="selflink" href="#section-5.6.1" name="section-5.6.1">5.6.1</a>.  Flags Subtoken</span>

   This subtoken is sent to convey initiator flags to the acceptor.  The
   flags are sent as a 32-bit integer in network byte order.  The only
   flag defined so far is GSS_C_MUTUAL_FLAG, indicating that the
   initiator successfully performed mutual authentication of the
   acceptor.  This flag is communicated to the acceptor because some
   protocols [<a href="rfc4462.html" title='"Generic Security Service Application Program Interface (GSS-API) Authentication and Key Exchange for the Secure Shell (SSH) Protocol"'>RFC4462</a>] require the acceptor to know whether the
   initiator has confirmed its identity.  This flag has the value 0x2 to
   be consistent with <a href="rfc2744.html">RFC 2744</a>.

                     +-------+-----------------------+
                     | Pos   | Description           |
                     +-------+-----------------------+
                     | 0..3  | 0x0000000C            |
                     |       |                       |
                     | 4..7  | length of flags token |
                     |       |                       |
                     | 8..11 | flags                 |
                     +-------+-----------------------+

   Initiators MUST send 4 octets of flags.  Acceptors MUST ignore flag
   octets beyond the first 4 and MUST ignore flag bits other than
   GSS_C_MUTUAL_FLAG.  Initiators MUST send undefined flag bits as zero.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/5.6.2.%20%20GSS%20Channel%20Bindings%20Subtoken"></a><a class="selflink" href="#section-5.6.2" name="section-5.6.2">5.6.2</a>.  GSS Channel Bindings Subtoken</span>

   This subtoken is always critical when sent.  It is sent from the
   initiator to the acceptor.  The contents of this token are an <a href="rfc3961.html">RFC</a>
   <a href="rfc3961.html">3961</a> get_mic token of the application data from the GSS channel
   bindings structure passed into the context establishment call.



<span class="grey">Hartman &amp; Howlett            Standards Track                   [Page 20]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-21" id="page-21" name="page-21"> </a>
<span class="grey"><a href="rfc7055.html">RFC 7055</a>                       EAP GSS-API                 December 2013</span>


      +-------------+-----------------------------------------------+
      | Pos         | Description                                   |
      +-------------+-----------------------------------------------+
      | 0..3        | 0x80000006                                    |
      |             |                                               |
      | 4..7        | length of token                               |
      |             |                                               |
      | 8..8+length | get_mic  of  channel binding application data |
      +-------------+-----------------------------------------------+

   Again, only the application data is sent in the channel binding.  Any
   initiator and acceptor addresses passed by an application into
   context establishment calls are ignored and not sent over the wire.
   The checksum type of the get_mic token SHOULD be the mandatory-to-
   implement checksum type of the Context Root Key (CRK).  The key to
   use is the CRK and the key usage is 60 (KEY_USAGE_GSSEAP_CHBIND_MIC).
   An acceptor MAY accept any MIC in the channel bindings subtoken if
   the channel bindings input to GSS_Accept_sec_context is not provided.
   If the channel binding input to GSS_Accept_sec_context is provided,
   the acceptor MUST return failure if the channel binding MIC in a
   received channel binding subtoken fails to verify.

   The initiator MUST send this token if channel bindings including
   application data are passed into GSS_Init_sec_context and MUST NOT
   send this token otherwise.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/5.6.3.%20%20MIC%20Subtoken"></a><a class="selflink" href="#section-5.6.3" name="section-5.6.3">5.6.3</a>.  MIC Subtoken</span>

   This subtoken MUST be the last subtoken in the tokens sent in
   Extensions state.  This subtoken is sent both by the initiator and
   acceptor.

    +-------------+--------------------------------------------------+
    | Pos         | Description                                      |
    +-------------+--------------------------------------------------+
    | 0..3        | 0x8000000D for initiator 0x8000000E for acceptor |
    |             |                                                  |
    | 4..7        | length of <a href="rfc3961.html">RFC 3961</a> MIC token                     |
    |             |                                                  |
    | 8..8+length | <a href="rfc3961.html">RFC 3961</a> result of get_mic                       |
    +-------------+--------------------------------------------------+

   As with any call to get_mic, a token is produced as described in <a href="rfc3961.html">RFC</a>
   <a href="rfc3961.html">3961</a> using the CRK (<a href="#section-6">Section 6</a>) as the key and the mandatory checksum
   type for the encryption type of the CRK as the checksum type.  The
   key usage is 61 (KEY_USAGE_GSSEAP_ACCTOKEN_MIC) for the subtoken from





<span class="grey">Hartman &amp; Howlett            Standards Track                   [Page 21]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-22" id="page-22" name="page-22"> </a>
<span class="grey"><a href="rfc7055.html">RFC 7055</a>                       EAP GSS-API                 December 2013</span>


   the acceptor to the initiator and 62 (KEY_USAGE_GSSEAP_INITTOKEN_MIC)
   for the subtoken from the initiator to the acceptor.  The input is as
   follows:

   1.  The DER-encoded object identifier of the mechanism in use; this
       value starts with 0x06 (the tag for object identifier).  When
       encoded in an <a href="rfc2743.html">RFC 2743</a> context token, the object identifier is
       preceded by the tag and length for [Application 0] SEQUENCE.
       This tag and the length of the overall token is not included;
       only the tag, length, and value of the object identifier itself.

   2.  A 16-bit token type in network byte order of the <a href="rfc4121.html">RFC 4121</a> token
       identifier (0x0601 for initiator, 0x0602 for acceptor).

   3.  For each subtoken, other than the MIC subtoken itself, the order
       the subtokens appear in the token is as follows:

   4.

       1.  A four-octet subtoken type in network byte order

       2.  A four-byte length in network byte order

       3.  Length octets of value from that subtoken

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.7.%20%20Example%20Token"></a><a class="selflink" href="#section-5.7" name="section-5.7">5.7</a>.  Example Token</span>

   +----+------+----+------+-----+-------------------------+
   | 60 |  23  | 06 |  09  | 2b  | 06 01 05 05 0f 01 01 11 |
   +----+------+----+------+-----+-------------------------+
   |App0|Token |OID |OID   | 1 3 |  6  1  5  5 15  1  1 17 |
   |Tag |length|Tag |length|      Mechanism object ID      |
   +----+------+----+------+-------------------------------+

   +----------+-------------+-------------+
   |  06 01   | 00 00 00 02 | 00 00 00 0e |
   +----------+-------------|-------------|
   |Initiator | Acceptor    | Length      |
   |context   | name        | (14 octets) |
   |token ID  | request     |             |
   +----------+-------------+-------------+

   +-------------------------------------------+
   | 68 6f 73 74 2f 6c 6f 63 61 6c 68 6f 73 74 |
   +-------------------------------------------+
   | String form of acceptor name              |
   | "host/localhost"                          |
   +-------------------------------------------+



<span class="grey">Hartman &amp; Howlett            Standards Track                   [Page 22]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-23" id="page-23" name="page-23"> </a>
<span class="grey"><a href="rfc7055.html">RFC 7055</a>                       EAP GSS-API                 December 2013</span>


                          Example Initiator Token

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.8.%20%20Context%20Options"></a><a class="selflink" href="#section-5.8" name="section-5.8">5.8</a>.  Context Options</span>

   GSS-API provides a number of optional per-context services requested
   by flags on the call to GSS_Init_sec_context and indicated as outputs
   from both GSS_Init_sec_context and GSS_Accept_sec_context.  This
   section describes how these services are handled.  Which services the
   client selects in the call to GSS_Init_sec_context controls what EAP
   methods MAY be used by the client.  <a href="rfc3748.html#section-7.2">Section 7.2 of RFC 3748</a> describes
   a set of security claims for EAP.  As described below, the selected
   GSS options place requirements on security claims that MUST be met.

   This GSS mechanism MUST only be used with EAP methods that provide
   dictionary-attack resistance.  Typically, dictionary-attack
   resistance is obtained by using an EAP tunnel method to tunnel an
   inner method in TLS.

   The EAP method MUST support key derivation.  Integrity,
   confidentiality, sequencing, and replay detection MUST be indicated
   in the output of GSS_Init_sec_context and GSS_Accept_sec_context
   regardless of which services are requested.

   The PROT_READY service defined in <a href="rfc2743.html#section-1.2.7">Section 1.2.7 of [RFC2743]</a> is never
   available with this mechanism.  Implementations MUST NOT offer this
   flag or permit per-message security services to be used before
   context establishment.

   The EAP method MUST support mutual authentication and channel
   binding.  See <a href="#section-3.4">Section 3.4</a> for details on what is required for
   successful mutual authentication.  Regardless of whether mutual
   authentication is requested, the implementation MUST include channel
   bindings in the EAP authentication.  If mutual authentication is
   requested and successful mutual authentication takes place as defined
   in <a href="#section-3.4">Section 3.4</a>, the initiator MUST send a flags subtoken
   <a href="#section-5.6.1">Section 5.6.1</a> in Extensions state.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/6.%20%20Acceptor%20Services"></a><a class="selflink" href="#section-6" name="section-6">6</a>.  Acceptor Services</span>

   The context establishment process may be passed through to an EAP
   server via a backend authentication protocol.  However, after the EAP
   authentication succeeds, security services are provided directly by
   the acceptor.

   This mechanism uses an <a href="rfc3961.html">RFC 3961</a> cryptographic key called the Context
   Root Key (CRK).  The CRK is derived from the GMSK (GSS-API Master
   Session Key).  The GMSK is the result of the random-to-key [<a href="rfc3961.html" title='"Encryption and Checksum Specifications for Kerberos 5"'>RFC3961</a>]
   operation of the encryption type of this mechanism consuming the



<span class="grey">Hartman &amp; Howlett            Standards Track                   [Page 23]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-24" id="page-24" name="page-24"> </a>
<span class="grey"><a href="rfc7055.html">RFC 7055</a>                       EAP GSS-API                 December 2013</span>


   appropriate number of bits from the EAP MSK.  For example, for
   aes128-cts-hmac-sha1-96, the random-to-key operation consumes 16
   octets of key material; thus, the first 16 bytes of the MSK are input
   to random-to-key to form the GMSK.  If the MSK is too short,
   authentication MUST fail.

   In the following, pseudorandom is the <a href="rfc3961.html">RFC 3961</a> pseudorandom operation
   for the encryption type of the GMSK and random-to-key is the <a href="rfc3961.html">RFC 3961</a>
   random-to-key operation for the enctype of the mechanism.  The
   truncate function takes the initial l bits of its input.  The goal in
   constructing a CRK is to call the pseudorandom function enough times
   to produce the right number of bits of output and discard any excess
   bits of output.

   The CRK is derived from the GMSK using the following procedure:

   Tn = pseudorandom(GMSK, n || "<a href="rfc4121.html">rfc4121</a>-gss-eap")
   CRK = random-to-key(truncate(L, T0 || T1 || .. || Tn))
   L = random-to-key input size

   Where n is a 32-bit integer in network byte order starting at 0 and
   incremented to each call to the pseudo_random operation.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/6.1.%20%20GSS-API%20Channel%20Binding"></a><a class="selflink" href="#section-6.1" name="section-6.1">6.1</a>.  GSS-API Channel Binding</span>

   GSS-API channel binding [<a href="rfc5554.html" title='"Clarifications and Extensions to the Generic Security Service Application Program Interface (GSS-API) for the Use of Channel Bindings"'>RFC5554</a>] is a protected facility for
   exchanging a cryptographic name for an enclosing channel between the
   initiator and acceptor.  The initiator sends channel binding data and
   the acceptor confirms that channel binding data has been checked.

   The acceptor SHOULD accept any channel binding provided by the
   initiator if null channel bindings are passed into
   gss_accept_sec_context.  Protocols such as HTTP Negotiate [<a href="rfc4559.html" title='"SPNEGO-based Kerberos and NTLM HTTP Authentication in Microsoft Windows"'>RFC4559</a>]
   depend on this behavior of some Kerberos implementations.

   As discussed, the GSS channel bindings subtoken is sent in the
   Extensions state.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/6.2.%20%20Per-Message%20Security"></a><a class="selflink" href="#section-6.2" name="section-6.2">6.2</a>.  Per-Message Security</span>

   The per-message tokens of <a href="rfc4121.html#section-4">Section 4 of RFC 4121</a> are used.  The CRK
   SHALL be treated as the initiator sub-session key, the acceptor sub-
   session key and the ticket session key.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/6.3.%20%20Pseudorandom%20Function"></a><a class="selflink" href="#section-6.3" name="section-6.3">6.3</a>.  Pseudorandom Function</span>

   The pseudorandom function defined in [<a href="rfc4402.html" title='"A Pseudo-Random Function (PRF) for the Kerberos V Generic Security Service Application Program Interface (GSS-API) Mechanism"'>RFC4402</a>] is used to provide
   GSS_Pseudo_Random functionality to applications.



<span class="grey">Hartman &amp; Howlett            Standards Track                   [Page 24]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-25" id="page-25" name="page-25"> </a>
<span class="grey"><a href="rfc7055.html">RFC 7055</a>                       EAP GSS-API                 December 2013</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/7.%20%20IANA%20Considerations"></a><a class="selflink" href="#section-7" name="section-7">7</a>.  IANA Considerations</span>

   This specification creates a number of IANA registries.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/7.1.%20%20OID%20Registry"></a><a class="selflink" href="#section-7.1" name="section-7.1">7.1</a>.  OID Registry</span>

   IANA has created a registry of ABFAB object identifiers titled
   "Object Identifiers for Application Bridging for Federated Access".
   The initial contents of the registry are specified below.  The
   registration policy is IETF Review or IESG Approval [<a href="rfc5226.html" title='"Guidelines for Writing an IANA Considerations Section in RFCs"'>RFC5226</a>].  Early
   allocation is permitted.  IANA has updated the reference for the root
   of this OID delegation to point to the newly created registry.

   Decimal   Name        Description                         References
   -------   ----        ----------------------------------  ----------
         0   Reserved    Reserved                            <a href="rfc7055.html">RFC 7055</a>
         1   mechanisms  A sub-arc containing ABFAB          <a href="rfc7055.html">RFC 7055</a>
                         mechanisms
         2   nametypes   A sub-arc containing ABFAB          <a href="rfc7055.html">RFC 7055</a>
                         GSS-API Name Types

   Prefix:
   iso.org.dod.internet.security.mechanisms.abfab
           (1.3.6.1.5.5.15)

   NOTE: the following mechanisms registry is the root of the OID for
   the mechanism in question.  As discussed in <a href="#section-5.1">Section 5.1</a>, a Kerberos
   encryption type number [<a href="rfc3961.html" title='"Encryption and Checksum Specifications for Kerberos 5"'>RFC3961</a>] is appended to the mechanism version
   OID below to form the OID of a specific mechanism.

   Prefix:
   iso.org.dod.internet.security.mechanisms.abfab.mechanisms
           (1.3.6.1.5.5.15.1)

   Decimal   Name          Description                      References
   -------   ----          -------------------------------  ----------
         0   Reserved      Reserved                         <a href="rfc7055.html">RFC 7055</a>
         1   gss-eap-v1    The GSS-EAP mechanism            <a href="rfc7055.html">RFC 7055</a>

   Prefix:
   iso.org.dod.internet.security.mechanisms.abfab.nametypes
           (1.3.6.1.5.5.15.2)

   Decimal   Name          Description            References
   -------   ----          ---------------------  ----------
         0   Reserved      Reserved               <a href="rfc7055.html">RFC 7055</a>
         1   GSS_EAP_NT_EAP_NAME                  <a href="rfc7055.html#section-3.1">RFC 7055, Section 3.1</a>




<span class="grey">Hartman &amp; Howlett            Standards Track                   [Page 25]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-26" id="page-26" name="page-26"> </a>
<span class="grey"><a href="rfc7055.html">RFC 7055</a>                       EAP GSS-API                 December 2013</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/7.2.%20%20RFC%204121%20Token%20Identifiers"></a><a class="selflink" href="#section-7.2" name="section-7.2">7.2</a>.  <a href="rfc4121.html">RFC 4121</a> Token Identifiers</span>

   In the top-level registry titled "Kerberos V GSS-API Mechanism
   Parameters", a subregistry called "Kerberos GSS-API Token Type
   Identifiers" was created; the references for this subregistry are <a href="rfc4121.html">RFC</a>
   <a href="rfc4121.html">4121</a> and this document.  The allocation procedure is Expert Review
   [<a href="rfc5226.html" title='"Guidelines for Writing an IANA Considerations Section in RFCs"'>RFC5226</a>].  The Expert's primary job is to make sure that token type
   identifiers are requested by an appropriate requester for the <a href="rfc4121.html">RFC</a>
   <a href="rfc4121.html">4121</a> mechanism in which they will be used and that multiple values
   are not allocated for the same purpose.  For <a href="rfc4121.html">RFC 4121</a> and this
   mechanism, the Expert is currently expected to make allocations for
   token identifiers from documents in the IETF stream; effectively, for
   these mechanisms, the Expert currently confirms the allocation meets
   the requirements of the IETF Review process.

   The ID field is a hexadecimal token identifier specified in network
   byte order.

   The initial registrations are as follows:

   +-------+-------------------------------+---------------------------+
   | ID    | Description                   | Reference                 |
   +-------+-------------------------------+---------------------------+
   | 01 00 | KRB_AP_REQ                    | <a href="rfc4121.html#section-4.1">RFC 4121, Section 4.1</a>     |
   |       |                               |                           |
   | 02 00 | KRB_AP_REP                    | <a href="rfc4121.html#section-4.1">RFC 4121, Section 4.1</a>     |
   |       |                               |                           |
   | 03 00 | KRB_ERROR                     | <a href="rfc4121.html#section-4.1">RFC 4121, Section 4.1</a>     |
   |       |                               |                           |
   | 04 04 | MIC tokens                    | <a href="rfc4121.html#section-4.2.6.1">RFC 4121, Section 4.2.6.1</a> |
   |       |                               |                           |
   | 05 04 | wrap tokens                   | <a href="rfc4121.html#section-4.2.6.2">RFC 4121, Section 4.2.6.2</a> |
   |       |                               |                           |
   | 06 01 | GSS-EAP initiator context     | <a href="rfc7055.html#section-5">RFC 7055, Section 5</a>       |
   |       | token                         |                           |
   |       |                               |                           |
   | 06 02 | GSS EAP acceptor context      | <a href="rfc7055.html#section-5">RFC 7055, Section 5</a>       |
   |       | token                         |                           |
   +-------+-------------------------------+---------------------------+

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/7.3.%20%20GSS-EAP%20Subtoken%20Types"></a><a class="selflink" href="#section-7.3" name="section-7.3">7.3</a>.  GSS-EAP Subtoken Types</span>

   This document creates a top-level registry called "The Extensible
   Authentication Protocol Mechanism for the Generic Security Service
   Application Programming Interface (GSS-EAP) Parameters".  In any
   short form of that name, including any URI for this registry, it is
   important that the string GSS come before the string EAP; this will




<span class="grey">Hartman &amp; Howlett            Standards Track                   [Page 26]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-27" id="page-27" name="page-27"> </a>
<span class="grey"><a href="rfc7055.html">RFC 7055</a>                       EAP GSS-API                 December 2013</span>


   help to distinguish registries if EAP methods for performing GSS-API
   authentication are ever defined.

   In this registry is a subregistry of subtoken types.  Identifiers are
   32-bit integers; the upper bit (0x80000000) is reserved as a critical
   flag and should not be indicated in the registration.  Assignments of
   GSS-EAP subtoken types are made by Expert Review [<a href="rfc5226.html" title='"Guidelines for Writing an IANA Considerations Section in RFCs"'>RFC5226</a>].  The
   Expert is expected to require a public specification of the subtoken
   similar in detail to registrations given in this document.  The
   security of GSS-EAP depends on making sure that subtoken information
   has adequate protection and that the overall mechanism continues to
   be secure.  Examining the security and architectural consistency of
   the proposed registration is the primary responsibility of the
   Expert.

         +------------+--------------------------+---------------+
         | Type       | Description              | Reference     |
         +------------+--------------------------+---------------+
         | 0x00000001 | Error                    | <a href="#section-5.3">Section 5.3</a>   |
         |            |                          |               |
         | 0x0000000B | Vendor                   | <a href="#section-5.4.1">Section 5.4.1</a> |
         |            |                          |               |
         | 0x00000002 | Acceptor name request    | <a href="#section-5.4.2">Section 5.4.2</a> |
         |            |                          |               |
         | 0x00000003 | Acceptor name response   | <a href="#section-5.4.3">Section 5.4.3</a> |
         |            |                          |               |
         | 0x00000005 | EAP request              | <a href="#section-5.5.1">Section 5.5.1</a> |
         |            |                          |               |
         | 0x00000004 | EAP response             | <a href="#section-5.5.2">Section 5.5.2</a> |
         |            |                          |               |
         | 0x0000000C | Flags                    | <a href="#section-5.6.1">Section 5.6.1</a> |
         |            |                          |               |
         | 0x00000006 | GSS-API channel bindings | <a href="#section-5.6.2">Section 5.6.2</a> |
         |            |                          |               |
         | 0x0000000D | Initiator MIC            | <a href="#section-5.6.3">Section 5.6.3</a> |
         |            |                          |               |
         | 0x0000000E | Acceptor MIC             | <a href="#section-5.6.3">Section 5.6.3</a> |
         +------------+--------------------------+---------------+

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/7.4.%20%20RADIUS%20Attribute%20Assignments"></a><a class="selflink" href="#section-7.4" name="section-7.4">7.4</a>.  RADIUS Attribute Assignments</span>

   The following RADIUS attribute type values [<a href="rfc3575.html" title='"IANA Considerations for RADIUS (Remote Authentication Dial In User Service)"'>RFC3575</a>] are assigned.
   The allocation instructions in <a href="rfc6929.html#section-10.3">Section 10.3 of [RFC6929]</a> have been
   followed.







<span class="grey">Hartman &amp; Howlett            Standards Track                   [Page 27]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-28" id="page-28" name="page-28"> </a>
<span class="grey"><a href="rfc7055.html">RFC 7055</a>                       EAP GSS-API                 December 2013</span>


   +--------------------------------+-------+--------------------------+
   | Description                    | Value | More Information         |
   +--------------------------------+-------+--------------------------+
   | GSS-Acceptor-Service-Name      | 164   | user-or-service portion  |
   |                                |       | of name                  |
   |                                |       |                          |
   | GSS-Acceptor-Host-Name         | 165   | host portion of name     |
   |                                |       |                          |
   | GSS-Acceptor-Service-Specifics | 166   | service-specifics        |
   |                                |       | portion of name          |
   |                                |       |                          |
   | GSS-Acceptor-Realm-Name        | 167   | Realm portion of name    |
   +--------------------------------+-------+--------------------------+

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/7.5.%20%20Registration%20of%20the%20EAP-AES128%20SASL%20Mechanisms"></a><a class="selflink" href="#section-7.5" name="section-7.5">7.5</a>.  Registration of the EAP-AES128 SASL Mechanisms</span>

   Subject:  Registration of SASL mechanisms EAP-AES128 and
      EAP-AES128-PLUS

   SASL mechanism names:  EAP-AES128 and EAP-AES128-PLUS

   Security considerations:  See <a href="rfc5801.html">RFC 5801</a> and <a href="rfc7055.html">RFC 7055</a>

   Published specification (recommended):  <a href="rfc7055.html">RFC 7055</a>

   Person &amp; email address to contact for further information:
      Abfab Working Group, abfab@ietf.org

   Intended usage:  common

   Owner/Change controller:  iesg@ietf.org

   Note:  This mechanism describes the GSS-EAP mechanism used with the
      aes128-cts-hmac-sha1-96 enctype.  The GSS-API OID for this
      mechanism is 1.3.6.1.5.5.15.1.1.17.

      As described in <a href="rfc5801.html">RFC 5801</a>, a PLUS variant of this mechanism is also
      required.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/7.6.%20%20GSS-EAP%20Errors"></a><a class="selflink" href="#section-7.6" name="section-7.6">7.6</a>.  GSS-EAP Errors</span>

   A new subregistry is created in the GSS-EAP parameters registry
   titled "GSS-EAP Error Codes".  The error codes in this registry are
   unsigned 32-bit numbers.  Values less than or equal to 127 are
   assigned by Standards Action [<a href="rfc5226.html" title='"Guidelines for Writing an IANA Considerations Section in RFCs"'>RFC5226</a>].  Values 128 through 255 are
   assigned with the Specification Required assignment policy [<a href="rfc5226.html" title='"Guidelines for Writing an IANA Considerations Section in RFCs"'>RFC5226</a>].





<span class="grey">Hartman &amp; Howlett            Standards Track                   [Page 28]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-29" id="page-29" name="page-29"> </a>
<span class="grey"><a href="rfc7055.html">RFC 7055</a>                       EAP GSS-API                 December 2013</span>


   Values greater than 255 are reserved; updates to registration policy
   may make these values available for assignment and implementations
   MUST be prepared to receive them.

   This table provides the initial contents of the registry.

        +-------+------------------------------------------------+
        | Value | Description                                    |
        +-------+------------------------------------------------+
        | 0     | Reserved                                       |
        |       |                                                |
        | 1     | Buffer is incorrect size                       |
        |       |                                                |
        | 2     | Incorrect mechanism OID                        |
        |       |                                                |
        | 3     | Token is corrupted                             |
        |       |                                                |
        | 4     | Token is truncated                             |
        |       |                                                |
        | 5     | Packet received by direction that sent it      |
        |       |                                                |
        | 6     | Incorrect token type identifier                |
        |       |                                                |
        | 7     | Unhandled critical subtoken received           |
        |       |                                                |
        | 8     | Missing required subtoken                      |
        |       |                                                |
        | 9     | Duplicate subtoken type                        |
        |       |                                                |
        | 10    | Received unexpected subtoken for current state |
        |       |                                                |
        | 11    | EAP did not produce a key                      |
        |       |                                                |
        | 12    | EAP key too short                              |
        |       |                                                |
        | 13    | Authentication rejected                        |
        |       |                                                |
        | 14    | AAA returned an unexpected message type        |
        |       |                                                |
        | 15    | AAA response did not include EAP request       |
        |       |                                                |
        | 16    | Generic AAA failure                            |
        +-------+------------------------------------------------+








<span class="grey">Hartman &amp; Howlett            Standards Track                   [Page 29]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-30" id="page-30" name="page-30"> </a>
<span class="grey"><a href="rfc7055.html">RFC 7055</a>                       EAP GSS-API                 December 2013</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/7.7.%20%20GSS-EAP%20Context%20Flags"></a><a class="selflink" href="#section-7.7" name="section-7.7">7.7</a>.  GSS-EAP Context Flags</span>

   A new subregistry is created in the GSS-EAP parameters registry.
   This registry holds registrations of flag bits sent in the flags
   subtoken (<a href="#section-5.6.1">Section 5.6.1</a>).  There are 32 flag bits available for
   registration represented as hexadecimal numbers from the most
   significant bit 0x80000000 to the least significant bit 0x1.  The
   registration policy for this registry is IETF Review or, in
   exceptional cases, IESG Approval.  The following table indicates
   initial registrations; all other values are available for assignment.

               +------+-------------------+---------------+
               | Flag | Name              | Reference     |
               +------+-------------------+---------------+
               | 0x2  | GSS_C_MUTUAL_FLAG | <a href="#section-5.6.1">Section 5.6.1</a> |
               +------+-------------------+---------------+

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/8.%20%20Security%20Considerations"></a><a class="selflink" href="#section-8" name="section-8">8</a>.  Security Considerations</span>

   <a href="rfc3748.html">RFC 3748</a> discusses security issues surrounding EAP.  <a href="rfc5247.html">RFC 5247</a>
   discusses the security and requirements surrounding key management
   that leverages the AAA infrastructure.  These documents are critical
   to the security analysis of this mechanism.

   <a href="rfc2743.html">RFC 2743</a> discusses generic security considerations for the GSS-API.
   <a href="rfc4121.html">RFC 4121</a> discusses security issues surrounding the specific per-
   message services used in this mechanism.

   As discussed in <a href="#section-4">Section 4</a>, this mechanism may introduce multiple
   layers of security negotiation into application protocols.  Multiple
   layer negotiations are vulnerable to a bid-down attack when a
   mechanism negotiated at the outer layer is preferred to some but not
   all mechanisms negotiated at the inner layer; see <a href="rfc4462.html#section-7.3">Section 7.3 of
   [RFC4462]</a> for an example.  One possible approach to mitigate this
   attack is to construct security policy such that the preference for
   all mechanisms negotiated in the inner layer falls between
   preferences for two outer-layer mechanisms or falls at one end of the
   overall ranked preferences including both the inner and outer layer.
   Another approach is to only use this mechanism when it has
   specifically been selected for a given service.  The second approach
   is likely to be common in practice because one common deployment will
   involve an EAP supplicant interacting with a user to select a given
   identity.  Only when an identity is successfully chosen by the user
   will this mechanism be attempted.

   EAP channel binding is used to give the GSS-API initiator confidence
   in the identity of the GSS-API acceptor.  Thus, the security of this
   mechanism depends on the use and verification of EAP channel binding.



<span class="grey">Hartman &amp; Howlett            Standards Track                   [Page 30]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-31" id="page-31" name="page-31"> </a>
<span class="grey"><a href="rfc7055.html">RFC 7055</a>                       EAP GSS-API                 December 2013</span>


   Today, EAP channel binding is in very limited deployment.  If EAP
   channel binding is not used, then the system may be vulnerable to
   phishing attacks where a user is diverted from one service to
   another.  If the EAP method in question supports mutual
   authentication then users can only be diverted between servers that
   are part of the same AAA infrastructure.  For deployments where
   membership in the AAA infrastructure is limited, this may serve as a
   significant limitation on the value of phishing as an attack.  For
   other deployments, use of EAP channel binding is critical to avoid
   phishing.  These attacks are possible with EAP today although not
   typically with common GSS-API mechanisms.  For this reason,
   implementations are required to implement and use EAP channel
   binding; see <a href="#section-3">Section 3</a> for details.

   The security considerations of EAP channel binding [<a href="rfc6677.html" title='"Channel-Binding Support for Extensible Authentication Protocol (EAP) Methods"'>RFC6677</a>] describe
   the security properties of channel binding.  Two attacks are worth
   calling out here.  First, when a tunneled EAP method is used, it is
   critical that the channel binding be performed with an EAP server
   trusted by the peer.  With existing EAP methods, this typically
   requires validating the certificate of the server tunnel endpoint
   back to a trust anchor and confirming the name of the entity who is a
   subject of that certificate.  EAP methods may suffer from bid-down
   attacks where an attacker can cause a peer to think that a particular
   EAP server does not support channel binding.  This does not directly
   cause a problem because mutual authentication is only offered at the
   GSS-API level when channel binding to the server's identity is
   successful.  However, when an EAP method is not vulnerable to these
   bid-down attacks, additional protection is available.  This mechanism
   will benefit significantly from new strong EAP methods such as
   [<a href="#ref-TEAP" title='"Tunnel EAP Method (TEAP) Version 1"'>TEAP</a>].

   Every proxy in the AAA chain from the authenticator to the EAP server
   needs to be trusted to help verify channel bindings and to protect
   the integrity of key material.  GSS-API applications may be built to
   assume a trust model where the acceptor is directly responsible for
   authentication.  However, GSS-API is definitely used with trusted-
   third-party mechanisms such as Kerberos.

   RADIUS does provide a weak form of hop-by-hop confidentiality of key
   material based on using MD5 as a stream cipher.  Diameter can use TLS
   or IPsec but has no mandatory-to-implement confidentiality mechanism.
   Operationally, protecting key material as it is transported between
   the Identity Provider (IdP) and Relying Party (RP) is critical to
   per-message security and verification of GSS-API channel binding
   [<a href="rfc5056.html" title='"On the Use of Channel Bindings to Secure Channels"'>RFC5056</a>].  Mechanisms such as RADIUS over TLS [<a href="rfc6614.html" title='"Transport Layer Security (TLS) Encryption for RADIUS"'>RFC6614</a>] provide
   significantly better protection of key material than the base RADIUS
   specification.




<span class="grey">Hartman &amp; Howlett            Standards Track                   [Page 31]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-32" id="page-32" name="page-32"> </a>
<span class="grey"><a href="rfc7055.html">RFC 7055</a>                       EAP GSS-API                 December 2013</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/9.%20%20Acknowledgements"></a><a class="selflink" href="#section-9" name="section-9">9</a>.  Acknowledgements</span>

   Luke Howard, Jim Schaad, Alejandro Perez Mendez, Alexey Melnikov, and
   Sujing Zhou provided valuable reviews of this document.

   Rhys Smith provided the text for the OID registry section.  Sam
   Hartman's work on this document has been funded by JANET.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/10.%20%20References"></a><a class="selflink" href="#section-10" name="section-10">10</a>.  References</span>

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/10.1.%20%20Normative%20References"></a><a class="selflink" href="#section-10.1" name="section-10.1">10.1</a>.  Normative References</span>

   [<a id="ref-GSS-IANA" name="ref-GSS-IANA">GSS-IANA</a>] IANA, "GSS-API Service Name Registry",
              &lt;<a href="http://www.iana.org/assignments/gssapi-service-names">http://www.iana.org/assignments/gssapi-service-names</a>&gt;.

   [<a id="ref-RFC2119" name="ref-RFC2119">RFC2119</a>]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", <a href="https://tools.ietf.org/html/bcp14">BCP 14</a>, <a href="rfc2119.html">RFC 2119</a>, March 1997.

   [<a id="ref-RFC2743" name="ref-RFC2743">RFC2743</a>]  Linn, J., "Generic Security Service Application Program
              Interface Version 2, Update 1", <a href="rfc2743.html">RFC 2743</a>, January 2000.

   [<a id="ref-RFC2744" name="ref-RFC2744">RFC2744</a>]  Wray, J., "Generic Security Service API Version 2 :
              C-bindings", <a href="rfc2744.html">RFC 2744</a>, January 2000.

   [<a id="ref-RFC3575" name="ref-RFC3575">RFC3575</a>]  Aboba, B., "IANA Considerations for RADIUS (Remote
              Authentication Dial In User Service)", <a href="rfc3575.html">RFC 3575</a>, July
              2003.

   [<a id="ref-RFC3748" name="ref-RFC3748">RFC3748</a>]  Aboba, B., Blunk, L., Vollbrecht, J., Carlson, J., and H.
              Levkowetz, "Extensible Authentication Protocol (EAP)", <a href="rfc3748.html">RFC</a>
              <a href="rfc3748.html">3748</a>, June 2004.

   [<a id="ref-RFC3961" name="ref-RFC3961">RFC3961</a>]  Raeburn, K., "Encryption and Checksum Specifications for
              Kerberos 5", <a href="rfc3961.html">RFC 3961</a>, February 2005.

   [<a id="ref-RFC4121" name="ref-RFC4121">RFC4121</a>]  Zhu, L., Jaganathan, K., and S. Hartman, "The Kerberos
              Version 5 Generic Security Service Application Program
              Interface (GSS-API) Mechanism: Version 2", <a href="rfc4121.html">RFC 4121</a>, July
              2005.

   [<a id="ref-RFC4282" name="ref-RFC4282">RFC4282</a>]  Aboba, B., Beadles, M., Arkko, J., and P. Eronen, "The
              Network Access Identifier", <a href="rfc4282.html">RFC 4282</a>, December 2005.

   [<a id="ref-RFC4401" name="ref-RFC4401">RFC4401</a>]  Williams, N., "A Pseudo-Random Function (PRF) API
              Extension for the Generic Security Service Application
              Program Interface (GSS-API)", <a href="rfc4401.html">RFC 4401</a>, February 2006.





<span class="grey">Hartman &amp; Howlett            Standards Track                   [Page 32]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-33" id="page-33" name="page-33"> </a>
<span class="grey"><a href="rfc7055.html">RFC 7055</a>                       EAP GSS-API                 December 2013</span>


   [<a id="ref-RFC4402" name="ref-RFC4402">RFC4402</a>]  Williams, N., "A Pseudo-Random Function (PRF) for the
              Kerberos V Generic Security Service Application Program
              Interface (GSS-API) Mechanism", <a href="rfc4402.html">RFC 4402</a>, February 2006.

   [<a id="ref-RFC5056" name="ref-RFC5056">RFC5056</a>]  Williams, N., "On the Use of Channel Bindings to Secure
              Channels", <a href="rfc5056.html">RFC 5056</a>, November 2007.

   [<a id="ref-RFC5226" name="ref-RFC5226">RFC5226</a>]  Narten, T. and H. Alvestrand, "Guidelines for Writing an
              IANA Considerations Section in RFCs", <a href="https://tools.ietf.org/html/bcp26">BCP 26</a>, <a href="rfc5226.html">RFC 5226</a>,
              May 2008.

   [<a id="ref-RFC5234" name="ref-RFC5234">RFC5234</a>]  Crocker, D. and P. Overell, "Augmented BNF for Syntax
              Specifications: ABNF", STD 68, <a href="rfc5234.html">RFC 5234</a>, January 2008.

   [<a id="ref-RFC5554" name="ref-RFC5554">RFC5554</a>]  Williams, N., "Clarifications and Extensions to the
              Generic Security Service Application Program Interface
              (GSS-API) for the Use of Channel Bindings", <a href="rfc5554.html">RFC 5554</a>, May
              2009.

   [<a id="ref-RFC5891" name="ref-RFC5891">RFC5891</a>]  Klensin, J., "Internationalized Domain Names in
              Applications (IDNA): Protocol", <a href="rfc5891.html">RFC 5891</a>, August 2010.

   [<a id="ref-RFC6677" name="ref-RFC6677">RFC6677</a>]  Hartman, S., Clancy, T., and K. Hoeper, "Channel-Binding
              Support for Extensible Authentication Protocol (EAP)
              Methods", <a href="rfc6677.html">RFC 6677</a>, July 2012.

   [<a id="ref-RFC7057" name="ref-RFC7057">RFC7057</a>]  Winter, S. and J. Salowey, "Update to the Extensible
              Authentication Protocol (EAP) Applicability Statement for
              Application Bridging for Federated Access Beyond Web
              (ABFAB)", <a href="rfc7057.html">RFC 7057</a>, December 2013.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/10.2.%20%20Informative%20References"></a><a class="selflink" href="#section-10.2" name="section-10.2">10.2</a>.  Informative References</span>

   [<a id="ref-ABFAB-ARCH" name="ref-ABFAB-ARCH">ABFAB-ARCH</a>]
              Howlett, J., Hartman, S., Tschofenig, H., Lear, E., and J.
              Schaad, "Application Bridging for Federated Access Beyond
              Web (ABFAB) Architecture", Work in Progress, July 2013.

   [<a id="ref-RFC1964" name="ref-RFC1964">RFC1964</a>]  Linn, J., "The Kerberos Version 5 GSS-API Mechanism", <a href="rfc1964.html">RFC</a>
              <a href="rfc1964.html">1964</a>, June 1996.

   [<a id="ref-RFC3579" name="ref-RFC3579">RFC3579</a>]  Aboba, B. and P. Calhoun, "RADIUS (Remote Authentication
              Dial In User Service) Support For Extensible
              Authentication Protocol (EAP)", <a href="rfc3579.html">RFC 3579</a>, September 2003.

   [<a id="ref-RFC4072" name="ref-RFC4072">RFC4072</a>]  Eronen, P., Hiller, T., and G. Zorn, "Diameter Extensible
              Authentication Protocol (EAP) Application", <a href="rfc4072.html">RFC 4072</a>,
              August 2005.



<span class="grey">Hartman &amp; Howlett            Standards Track                   [Page 33]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-34" id="page-34" name="page-34"> </a>
<span class="grey"><a href="rfc7055.html">RFC 7055</a>                       EAP GSS-API                 December 2013</span>


   [<a id="ref-RFC4178" name="ref-RFC4178">RFC4178</a>]  Zhu, L., Leach, P., Jaganathan, K., and W. Ingersoll, "The
              Simple and Protected Generic Security Service Application
              Program Interface (GSS-API) Negotiation Mechanism", <a href="rfc4178.html">RFC</a>
              <a href="rfc4178.html">4178</a>, October 2005.

   [<a id="ref-RFC4422" name="ref-RFC4422">RFC4422</a>]  Melnikov, A. and K. Zeilenga, "Simple Authentication and
              Security Layer (SASL)", <a href="rfc4422.html">RFC 4422</a>, June 2006.

   [<a id="ref-RFC4462" name="ref-RFC4462">RFC4462</a>]  Hutzelman, J., Salowey, J., Galbraith, J., and V. Welch,
              "Generic Security Service Application Program Interface
              (GSS-API) Authentication and Key Exchange for the Secure
              Shell (SSH) Protocol", <a href="rfc4462.html">RFC 4462</a>, May 2006.

   [<a id="ref-RFC4559" name="ref-RFC4559">RFC4559</a>]  Jaganathan, K., Zhu, L., and J. Brezak, "SPNEGO-based
              Kerberos and NTLM HTTP Authentication in Microsoft
              Windows", <a href="rfc4559.html">RFC 4559</a>, June 2006.

   [<a id="ref-RFC5178" name="ref-RFC5178">RFC5178</a>]  Williams, N. and A. Melnikov, "Generic Security Service
              Application Program Interface (GSS-API)
              Internationalization and Domain-Based Service Names and
              Name Type", <a href="rfc5178.html">RFC 5178</a>, May 2008.

   [<a id="ref-RFC5247" name="ref-RFC5247">RFC5247</a>]  Aboba, B., Simon, D., and P. Eronen, "Extensible
              Authentication Protocol (EAP) Key Management Framework",
              <a href="rfc5247.html">RFC 5247</a>, August 2008.

   [<a id="ref-RFC6066" name="ref-RFC6066">RFC6066</a>]  Eastlake, D., "Transport Layer Security (TLS) Extensions:
              Extension Definitions", <a href="rfc6066.html">RFC 6066</a>, January 2011.

   [<a id="ref-RFC6614" name="ref-RFC6614">RFC6614</a>]  Winter, S., McCauley, M., Venaas, S., and K. Wierenga,
              "Transport Layer Security (TLS) Encryption for RADIUS",
              <a href="rfc6614.html">RFC 6614</a>, May 2012.

   [<a id="ref-RFC6929" name="ref-RFC6929">RFC6929</a>]  DeKok, A. and A. Lior, "Remote Authentication Dial In User
              Service (RADIUS) Protocol Extensions", <a href="rfc6929.html">RFC 6929</a>, April
              2013.

   [<a id="ref-TEAP" name="ref-TEAP">TEAP</a>]     Zhou, H., Cam-Winget, N., Salowey, J., and S. Hanna,
              "Tunnel EAP Method (TEAP) Version 1", Work in Progress,
              September 2013.











<span class="grey">Hartman &amp; Howlett            Standards Track                   [Page 34]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-35" id="page-35" name="page-35"> </a>
<span class="grey"><a href="rfc7055.html">RFC 7055</a>                       EAP GSS-API                 December 2013</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/Appendix%20A.%20%20Pre-publication%20RADIUS%20VSA"></a><a class="selflink" href="#appendix-A" name="appendix-A">Appendix A</a>.  Pre-publication RADIUS VSA</span>

   As described in <a href="#section-3.4">Section 3.4</a>, RADIUS attributes are used to carry the
   acceptor name when this family of mechanisms is used with RADIUS.
   Prior to the publication of this specification, a vendor-specific
   RADIUS attribute was used.  This non-normative appendix documents
   that attribute as it may be seen from older implementations.

   Prior to IANA assignment, GSS-EAP used a RADIUS vendor-specific
   attribute for carrying the acceptor name.  The Vendor-Specific
   Attribute (VSA) with enterprise ID 25622 is formatted as a VSA
   according to the recommendation in the RADIUS specification.  The
   following sub-attributes are defined:

   +--------------------------------+-----------+----------------------+
   | Name                           | Attribute | Description          |
   +--------------------------------+-----------+----------------------+
   | GSS-Acceptor-Service-Name      | 128       | user-or-service      |
   |                                |           | portion of name      |
   |                                |           |                      |
   | GSS-Acceptor-Host-Name         | 129       | host portion of name |
   |                                |           |                      |
   | GSS-Acceptor-Service-Specifics | 130       | service-specifics    |
   |                                |           | portion of name      |
   |                                |           |                      |
   | GSS-Acceptor-Realm-Name        | 131       | Realm portion of     |
   |                                |           | name                 |
   +--------------------------------+-----------+----------------------+

Authors' Addresses

   Sam Hartman (editor)
   Painless Security

   EMail: hartmans-ietf@mit.edu


   Josh Howlett
   JANET(UK)

   EMail: josh.howlett@ja.net










Hartman &amp; Howlett            Standards Track                   [Page 35]

</pre><br/>
    <span class="noprint"><small><small>Html markup produced by rfcmarkup 1.119, available from
      <a href="https://tools.ietf.org/tools/rfcmarkup/">https://tools.ietf.org/tools/rfcmarkup/</a>
    </small></small></span>
  </div>




</body><!-- Mirrored from tools.ietf.org/html/rfc7055 by HTTrack Website Copier/3.x [XR&CO'2013], Tue, 23 Aug 2016 18:36:45 GMT --></html>