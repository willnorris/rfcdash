<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml"><!-- Mirrored from tools.ietf.org/html/rfc2748 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 06 Mar 2018 23:18:51 GMT --><!-- Added by HTTrack --><head><meta content="text/html;charset=utf-8" http-equiv="content-type"/><!-- /Added by HTTrack -->

    <meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
    <meta content="index,follow" name="robots"/>
    <meta content="rfcmarkup version 1.126" name="creator"/>
    <link href="http://purl.org/dc/elements/1.1/" rel="schema.DC"/>
<meta content="urn:ietf:rfc:2748" name="DC.Identifier"/>
<meta content="1. Introduction....................................................3
1.1 Basic Model....................................................4
2. The Protocol....................................................7
2.1 Common Header..................................................7
2.2 COPS Specific Object Formats...................................8
2.2.1 Handle Object (Handle).......................................9
2.2.2 Context Object (Context).....................................9
2.2.3 In-Interface Object (IN-Int)................................10
2.2.4 Out-Interface Object (OUT-Int)..............................11
2.2.5 Reason Object (Reason)......................................12
2.2.6 Decision Object (Decision)..................................12
2.2.7 LPDP Decision Object (LPDPDecision).........................14
2.2.8 Error Object (Error)........................................14
2.2.9 Client Specific Information Object (ClientSI)...............14
2.2.10 Keep-Alive Timer Object (KATimer)..........................15
2.2.11 PEP Identification Object (PEPID)..........................15
2.2.12 Report-Type Object (Report-Type)...........................15
2.2.13 PDP Redirect Address (PDPRedirAddr)........................16
2.2.14 Last PDP Address (LastPDPAddr).............................16
2.2.15 Accounting Timer Object (AcctTimer)........................17
2.2.16 Message Integrity Object (Integrity).......................17
2.3 Communication.................................................18
2.4 Client Handle Usage...........................................19
2.5 Synchronization Behavior......................................20
3. Message Content................................................21
3.1 Request (REQ) PEP -&gt; PDP.....................................21
3.2 Decision (DEC) PDP -&gt; PEP....................................22
3.3 Report State (RPT) PEP -&gt; PDP................................23
3.4 Delete Request State (DRQ) PEP -&gt; PDP........................23
3.5 Synchronize State Request (SSQ) PDP -&gt; PEP...................24
3.6 Client-Open (OPN) PEP -&gt; PDP.................................25
3.7 Client-Accept (CAT) PDP -&gt; PEP...............................25
3.8 Client-Close (CC) PEP -&gt; PDP, PDP -&gt; PEP.....................26
3.9 Keep-Alive (KA) PEP -&gt; PDP, PDP -&gt; PEP.......................26
3.10 Synchronize State Complete (SSC) PEP -&gt; PDP..................27
4. Common Operation...............................................28
4.1 Security and Sequence Number Negotiation......................28
4.2 Key Maintenance...............................................29
4.3 PEP Initialization............................................30
4.4 Outsourcing Operations........................................30
4.5 Configuration Operations......................................31
4.6 Keep-Alive Operations.........................................31
4.7 PEP/PDP Close.................................................31
5. Security Considerations........................................32
6. IANA Considerations............................................33
7. References.....................................................34
8. Author Information and Acknowledgments.........................35" name="DC.Description.Abstract"/>
<meta content="Shai Herzog &lt;herzog@iphighway.com&gt;" name="DC.Creator"/>
<meta content="January, 2000" name="DC.Date.Issued"/>
<meta content="The COPS (Common Open Policy Service) Protocol" name="DC.Title"/>

    <link href="https://tools.ietf.org/images/rfc.png" rel="icon" type="image/png"/>
    <link href="https://tools.ietf.org/images/rfc.png" rel="shortcut icon" type="image/png"/>
    <title>RFC 2748 - The COPS (Common Open Policy Service) Protocol</title>
    
    
    <style type="text/css">
	@media only screen 
	  and (min-width: 992px)
	  and (max-width: 1199px) {
	    body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 768px)
	  and (max-width: 991px) {
            body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 480px)
	  and (max-width: 767px) {
            body { font-size: 11pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (max-width: 479px) {
            body { font-size: 8pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-device-width : 375px) 
	  and (max-device-width : 667px) {
            body { font-size: 9.5pt; }
            div.content { width: 96ex; margin: 0 1px; }
        }
	@media only screen 
	  and (min-device-width: 1200px) {
            body { font-size: 10pt; margin: 0 4em; }
            div.content { width: 96ex; margin: 0; }
        }
        h1, h2, h3, h4, h5, h6, .h1, .h2, .h3, .h4, .h5, .h6 {
	    font-weight: bold;
            line-height: 0pt;
            display: inline;
            white-space: pre;
            font-family: monospace;
            font-size: 1em;
	    font-weight: bold;
        }
        pre {
            font-size: 1em;
            margin-top: 0px;
            margin-bottom: 0px;
        }
	.pre {
	    white-space: pre;
	    font-family: monospace;
	}
	.header{
	    font-weight: bold;
	}
        .newpage {
            page-break-before: always;
        }
        .invisible {
            text-decoration: none;
            color: white;
        }
        a.selflink {
          color: black;
          text-decoration: none;
        }
        @media print {
            body {
                font-family: monospace;
                font-size: 10.5pt;
            }
            h1, h2, h3, h4, h5, h6 {
                font-size: 1em;
            }
        
            a:link, a:visited {
                color: inherit;
                text-decoration: none;
            }
            .noprint {
                display: none;
            }
        }
	@media screen {
	    .grey, .grey a:link, .grey a:visited {
		color: #777;
	    }
            .docinfo {
                background-color: #EEE;
            }
            .top {
                border-top: 7px solid #EEE;
            }
            .bgwhite  { background-color: white; }
            .bgred    { background-color: #F44; }
            .bggrey   { background-color: #666; }
            .bgbrown  { background-color: #840; }            
            .bgorange { background-color: #FA0; }
            .bgyellow { background-color: #EE0; }
            .bgmagenta{ background-color: #F4F; }
            .bgblue   { background-color: #66F; }
            .bgcyan   { background-color: #4DD; }
            .bggreen  { background-color: #4F4; }

            .legend   { font-size: 90%; }
            .cplate   { font-size: 70%; border: solid grey 1px; }
	}
    </style>
    <!--[if IE]>
    <style>
    body {
       font-size: 13px;
       margin: 10px 10px;
    }
    </style>
    <![endif]-->

    <script type="text/javascript"><!--
    function addHeaderTags() {
	var spans = document.getElementsByTagName("span");
	for (var i=0; i < spans.length; i++) {
	    var elem = spans[i];
	    if (elem) {
		var level = elem.getAttribute("class");
                if (level == "h1" || level == "h2" || level == "h3" || level == "h4" || level == "h5" || level == "h6") {
                    elem.innerHTML = "<"+level+">"+elem.innerHTML+"</"+level+">";		
                }
	    }
	}
    }
    var legend_html = "Colour legend:<br />      <table>         <tr><td>Unknown:</td>                   <td><span class='cplate bgwhite'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft:</td>                     <td><span class='cplate bgred'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Informational:</td>             <td><span class='cplate bgorange'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Experimental:</td>              <td><span class='cplate bgyellow'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Best Common Practice:</td>      <td><span class='cplate bgmagenta'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Proposed Standard:</td>         <td><span class='cplate bgblue'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft Standard (old designation):</td> <td><span class='cplate bgcyan'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Internet Standard:</td>         <td><span class='cplate bggreen'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Historic:</td>                  <td><span class='cplate bggrey'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Obsolete:</td>                  <td><span class='cplate bgbrown'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>     </table>";
    function showElem(id) {
        var elem = document.getElementById(id);
        elem.innerHTML = eval(id+"_html");
        elem.style.visibility='visible';
    }
    function hideElem(id) {
        var elem = document.getElementById(id);
        elem.style.visibility='hidden';        
        elem.innerHTML = "";
    }
    // -->
    </script>
</head>
<body onload="addHeaderTags()">
  <div class="content">
   <div style="height: 13px;">
      <div class="pre noprint docinfo bgblue" onclick="showElem('legend');" onmouseout="hideElem('legend')" onmouseover="this.style.cursor='pointer';" style="height: 6px; position: absolute;" title="Click for colour legend.">                                                                        </div>
      <div class="docinfo noprint pre legend" id="legend" onmouseout="hideElem('legend');" onmouseover="showElem('legend');" style="position:absolute; top: 4px; left: 4ex; visibility:hidden; background-color: white; padding: 4px 9px 5px 7px; border: solid #345 1px; ">
      </div>
   </div>
<span class="pre noprint docinfo top">[<a href="index.html" title="Document search and retrieval page">Docs</a>] [<a href="https://tools.ietf.org/rfc/rfc2748.txt" title="Plaintext version of this document">txt</a>|<a href="https://tools.ietf.org/pdf/rfc2748" title="PDF version of this document">pdf</a>] [<a href="https://tools.ietf.org/html/draft-ietf-rap-cops" title="draft-ietf-rap-cops">draft-ietf-rap-...</a>] [<a href="https://datatracker.ietf.org/doc/rfc2748" title="IESG Datatracker information for this document">Tracker</a>] [<a href="https://tools.ietf.org/rfcdiff?difftype=--hwdiff&amp;url2=rfc2748" title="Inline diff (wdiff)">Diff1</a>] [<a href="https://tools.ietf.org/rfcdiff?url2=rfc2748" title="Side-by-side diff">Diff2</a>]         </span><br/>
<span class="pre noprint docinfo">                                                                        </span><br/>
<span class="pre noprint docinfo">Updated by: <a href="rfc4261.html">4261</a>                                       PROPOSED STANDARD</span><br/>
<span class="pre noprint docinfo">                                                                        </span><br/>
<pre>Network Working Group                                     D. Durham, Ed.
Request for Comments: 2748                                         Intel
Category: Standards Track                                       J. Boyle
                                                                 Level 3
                                                                R. Cohen
                                                                   Cisco
                                                               S. Herzog
                                                               IPHighway
                                                                R. Rajan
                                                                    AT&amp;T
                                                               A. Sastry
                                                                   Cisco
                                                            January 2000


             <span class="h1">The COPS (Common Open Policy Service) Protocol</span>


Status of this Memo

   This document specifies an Internet standards track protocol for the
   Internet community, and requests discussion and suggestions for
   improvements.  Please refer to the current edition of the "Internet
   Official Protocol Standards" (STD 1) for the standardization state
   and status of this protocol.  Distribution of this memo is unlimited.

Copyright Notice

   Copyright (C) The Internet Society (2000).  All Rights Reserved.

Conventions used in this document

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED",  "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in [<a href="rfc2119.html">RFC-2119</a>].

Abstract

   This document describes a simple client/server model for supporting
   policy control over QoS signaling protocols. The model does not make
   any assumptions about the methods of the policy server, but is based
   on the server returning decisions to policy requests. The model is
   designed to be extensible so that other kinds of policy clients may
   be supported in the future. However, this document makes no claims
   that it is the only or the preferred approach for enforcing future
   types of policies.





<span class="grey">Durham, et al.              Standards Track                     [Page 1]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-2" id="page-2" name="page-2"> </a>
<span class="grey"><a href="rfc2748.html">RFC 2748</a>                          COPS                      January 2000</span>


Table Of Contents

   <a href="#section-1">1</a>. Introduction....................................................<a href="#page-3">3</a>
   <a href="#section-1.1">1.1</a> Basic Model....................................................<a href="#page-4">4</a>
   <a href="#section-2">2</a>. The Protocol....................................................<a href="#page-6">6</a>
   <a href="#section-2.1">2.1</a> Common Header..................................................<a href="#page-6">6</a>
   <a href="#section-2.2">2.2</a> COPS Specific Object Formats...................................<a href="#page-8">8</a>
   <a href="#section-2.2.1">2.2.1</a> Handle Object (Handle).......................................<a href="#page-9">9</a>
   <a href="#section-2.2.2">2.2.2</a> Context Object (Context).....................................<a href="#page-9">9</a>
   <a href="#section-2.2.3">2.2.3</a> In-Interface Object (IN-Int)................................<a href="#page-10">10</a>
   <a href="#section-2.2.4">2.2.4</a> Out-Interface Object (OUT-Int)..............................<a href="#page-11">11</a>
   <a href="#section-2.2.5">2.2.5</a> Reason Object (Reason)......................................<a href="#page-12">12</a>
   <a href="#section-2.2.6">2.2.6</a> Decision Object (Decision)..................................<a href="#page-12">12</a>
   <a href="#section-2.2.7">2.2.7</a> LPDP Decision Object (LPDPDecision).........................<a href="#page-14">14</a>
   <a href="#section-2.2.8">2.2.8</a> Error Object (Error)........................................<a href="#page-14">14</a>
   <a href="#section-2.2.9">2.2.9</a> Client Specific Information Object (ClientSI)...............<a href="#page-15">15</a>
   <a href="#section-2.2.10">2.2.10</a> Keep-Alive Timer Object (KATimer)..........................<a href="#page-15">15</a>
   <a href="#section-2.2.11">2.2.11</a> PEP Identification Object (PEPID)..........................<a href="#page-16">16</a>
   <a href="#section-2.2.12">2.2.12</a> Report-Type Object (Report-Type)...........................<a href="#page-16">16</a>
   <a href="#section-2.2.13">2.2.13</a> PDP Redirect Address (PDPRedirAddr)........................<a href="#page-16">16</a>
   <a href="#section-2.2.14">2.2.14</a> Last PDP Address (LastPDPAddr).............................<a href="#page-17">17</a>
   <a href="#section-2.2.15">2.2.15</a> Accounting Timer Object (AcctTimer)........................<a href="#page-17">17</a>
   <a href="#section-2.2.16">2.2.16</a> Message Integrity Object (Integrity).......................<a href="#page-18">18</a>
   <a href="#section-2.3">2.3</a> Communication.................................................<a href="#page-19">19</a>
   <a href="#section-2.4">2.4</a> Client Handle Usage...........................................<a href="#page-21">21</a>
   <a href="#section-2.5">2.5</a> Synchronization Behavior......................................<a href="#page-21">21</a>
   <a href="#section-3">3</a>. Message Content................................................<a href="#page-22">22</a>
   <a href="#section-3.1">3.1</a> Request (REQ)  PEP -&gt; PDP.....................................<a href="#page-22">22</a>
   <a href="#section-3.2">3.2</a> Decision (DEC)  PDP -&gt; PEP....................................<a href="#page-24">24</a>
   <a href="#section-3.3">3.3</a> Report State (RPT)  PEP -&gt; PDP................................<a href="#page-25">25</a>
   <a href="#section-3.4">3.4</a> Delete Request State (DRQ)  PEP -&gt; PDP........................<a href="#page-25">25</a>
   <a href="#section-3.5">3.5</a> Synchronize State Request (SSQ)  PDP -&gt; PEP...................<a href="#page-26">26</a>
   <a href="#section-3.6">3.6</a> Client-Open (OPN)  PEP -&gt; PDP.................................<a href="#page-26">26</a>
   <a href="#section-3.7">3.7</a> Client-Accept (CAT)  PDP -&gt; PEP...............................<a href="#page-27">27</a>
   <a href="#section-3.8">3.8</a> Client-Close (CC)  PEP -&gt; PDP, PDP -&gt; PEP.....................<a href="#page-28">28</a>
   <a href="#section-3.9">3.9</a> Keep-Alive (KA)  PEP -&gt; PDP, PDP -&gt; PEP.......................<a href="#page-28">28</a>
   <a href="#section-3.10">3.10</a> Synchronize State Complete (SSC) PEP -&gt; PDP..................<a href="#page-29">29</a>
   <a href="#section-4">4</a>. Common Operation...............................................<a href="#page-29">29</a>
   <a href="#section-4.1">4.1</a> Security and Sequence Number Negotiation......................<a href="#page-29">29</a>
   <a href="#section-4.2">4.2</a> Key Maintenance...............................................<a href="#page-31">31</a>
   <a href="#section-4.3">4.3</a> PEP Initialization............................................<a href="#page-31">31</a>
   <a href="#section-4.4">4.4</a> Outsourcing Operations........................................<a href="#page-32">32</a>
   <a href="#section-4.5">4.5</a> Configuration Operations......................................<a href="#page-32">32</a>
   <a href="#section-4.6">4.6</a> Keep-Alive Operations.........................................<a href="#page-33">33</a>
   <a href="#section-4.7">4.7</a> PEP/PDP Close.................................................<a href="#page-33">33</a>
   <a href="#section-5">5</a>. Security Considerations........................................<a href="#page-33">33</a>
   <a href="#section-6">6</a>. IANA Considerations............................................<a href="#page-34">34</a>




<span class="grey">Durham, et al.              Standards Track                     [Page 2]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-3" id="page-3" name="page-3"> </a>
<span class="grey"><a href="rfc2748.html">RFC 2748</a>                          COPS                      January 2000</span>


   <a href="#section-7">7</a>. References.....................................................<a href="#page-35">35</a>
   <a href="#section-8">8</a>. Author Information and Acknowledgments.........................<a href="#page-36">36</a>
   <a href="#section-9">9</a>. Full Copyright Statement.......................................<a href="#page-38">38</a>

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/1.%20Introduction"></a><a class="selflink" href="#section-1" name="section-1">1</a>. Introduction</span>

   This document describes a simple query and response protocol that can
   be used to exchange policy information between a policy server
   (Policy Decision Point or PDP) and its clients (Policy Enforcement
   Points or PEPs).  One example of a policy client is an RSVP router
   that must exercise policy-based admission control over RSVP usage
   [<a href="#ref-RSVP" title='"Resource ReSerVation Protocol (RSVP) Version 1 - Functional Specification"'>RSVP</a>].  We assume that at least one policy server exists in each
   controlled administrative domain. The basic model of interaction
   between a policy server and its clients is compatible with the
   framework document for policy based admission control [<a href="#ref-WRK" title='"A Framework for Policy-Based Admission Control"'>WRK</a>].

   A chief objective of this policy control protocol is to begin with a
   simple but extensible design. The main characteristics of the COPS
   protocol include:

      1. The protocol employs a client/server model where the PEP sends
         requests, updates, and deletes to the remote PDP and the PDP
         returns decisions back to the PEP.

      2. The protocol uses TCP as its transport protocol for reliable
         exchange of messages between policy clients and a server.
         Therefore, no additional mechanisms are necessary for reliable
         communication between a server and its clients.

      3. The protocol is extensible in that it is designed to leverage
         off self-identifying objects and can support diverse client
         specific information without requiring modifications to the
         COPS protocol itself. The protocol was created for the general
         administration, configuration, and enforcement of policies.

      4. COPS provides message level security for authentication, replay
         protection, and message integrity. COPS can also reuse existing
         protocols for security such as IPSEC [<a href="#ref-IPSEC" title='"Security Architecture for the Internet Protocol"'>IPSEC</a>] or TLS to
         authenticate and secure the channel between the PEP and the
         PDP.

      5. The protocol is stateful in two main aspects:  (1)
         Request/Decision state is shared between client and server and
         (2) State from various events (Request/Decision pairs) may be
         inter-associated. By (1) we mean that requests from the client
         PEP are installed or remembered by the remote PDP until they
         are explicitly deleted by the PEP. At the same time, Decisions
         from the remote PDP can be generated asynchronously at any time



<span class="grey">Durham, et al.              Standards Track                     [Page 3]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-4" id="page-4" name="page-4"> </a>
<span class="grey"><a href="rfc2748.html">RFC 2748</a>                          COPS                      January 2000</span>


         for a currently installed request state. By (2) we mean that
         the server may respond to new queries differently because of
         previously installed Request/Decision state(s) that are
         related.

      6. Additionally, the protocol is stateful in that it allows the
         server to push configuration information to the client, and
         then allows the server to remove such state from the client
         when it is no longer applicable.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/1.1%20Basic%20Model"></a><a class="selflink" href="#section-1.1" name="section-1.1">1.1</a> Basic Model</span>

          +----------------+
          |                |
          |  Network Node  |            Policy Server
          |                |
          |   +-----+      |   COPS        +-----+
          |   | PEP |&lt;-----|--------------&gt;| PDP |
          |   +-----+      |               +-----+
          |    ^           |
          |    |           |
          |    \--&gt;+-----+ |
          |        | LPDP| |
          |        +-----+ |
          |                |
          +----------------+

          Figure 1: A COPS illustration.


   Figure 1 Illustrates the layout of various policy components in a
   typical COPS example (taken from [<a href="#ref-WRK" title='"A Framework for Policy-Based Admission Control"'>WRK</a>]). Here, COPS is used to
   communicate policy information between a Policy Enforcement Point
   (PEP) and a remote Policy Decision Point (PDP) within the context of
   a particular type of client. The optional Local Policy Decision Point
   (LPDP) can be used by the device to make local policy decisions in
   the absence of a PDP.

   It is assumed that each participating policy client is functionally
   consistent with a PEP [<a href="#ref-WRK" title='"A Framework for Policy-Based Admission Control"'>WRK</a>]. The PEP may communicate with a policy
   server (herein referred to as a remote PDP [<a href="#ref-WRK" title='"A Framework for Policy-Based Admission Control"'>WRK</a>]) to obtain policy
   decisions or directives.

   The PEP is responsible for initiating a persistent TCP connection to
   a PDP. The PEP uses this TCP connection to send requests to and
   receive decisions from the remote PDP. Communication between the PEP
   and remote PDP is mainly in the form of a stateful request/decision
   exchange, though the remote PDP may occasionally send unsolicited



<span class="grey">Durham, et al.              Standards Track                     [Page 4]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-5" id="page-5" name="page-5"> </a>
<span class="grey"><a href="rfc2748.html">RFC 2748</a>                          COPS                      January 2000</span>


   decisions to the PEP to force changes in previously approved request
   states. The PEP also has the capacity to report to the remote PDP
   that it has successfully completed performing the PDP's decision
   locally, useful for accounting and monitoring purposes. The PEP is
   responsible for notifying the PDP when a request state has changed on
   the PEP. Finally, the PEP is responsible for the deletion of any
   state that is no longer applicable due to events at the client or
   decisions issued by the server.

   When the PEP sends a configuration request, it expects the PDP to
   continuously send named units of configuration data to the PEP via
   decision messages as applicable for the configuration request. When a
   unit of named configuration data is successfully installed on the
   PEP, the PEP should send a report message to the PDP confirming the
   installation. The server may then update or remove the named
   configuration information via a new decision message. When the PDP
   sends a decision to remove named configuration data from the PEP, the
   PEP will delete the specified configuration and send a report message
   to the PDP as confirmation.

   The policy protocol is designed to communicate self-identifying
   objects which contain the data necessary for identifying request
   states, establishing the context for a request, identifying the type
   of request, referencing previously installed requests, relaying
   policy decisions, reporting errors, providing message integrity, and
   transferring client specific/namespace information.

   To distinguish between different kinds of clients, the type of client
   is identified in each message. Different types of clients may have
   different client specific data and may require different kinds of
   policy decisions. It is expected that each new client-type will have
   a corresponding usage draft specifying the specifics of its
   interaction with this policy protocol.

   The context of each request corresponds to the type of event that
   triggered it. The COPS Context object identifies the type of request
   and message (if applicable) that triggered a policy event via its
   message type and request type fields. COPS identifies three types of
   outsourcing events: (1) the arrival of an incoming message (2)
   allocation of local resources, and (3) the forwarding of an outgoing
   message. Each of these events may require different decisions to be
   made. The content of a COPS request/decision message depends on the
   context. A fourth type of request is useful for types of clients that
   wish to receive configuration information from the PDP. This allows a
   PEP to issue a configuration request for a specific named device or
   module that requires configuration information to be installed.





<span class="grey">Durham, et al.              Standards Track                     [Page 5]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-6" id="page-6" name="page-6"> </a>
<span class="grey"><a href="rfc2748.html">RFC 2748</a>                          COPS                      January 2000</span>


   The PEP may also have the capability to make a local policy decision
   via its Local Policy Decision Point (LPDP) [<a href="#ref-WRK" title='"A Framework for Policy-Based Admission Control"'>WRK</a>], however, the PDP
   remains the authoritative decision point at all times. This means
   that the relevant local decision information must be relayed to the
   PDP. That is, the PDP must be granted access to all relevant
   information to make a final policy decision. To facilitate this
   functionality, the PEP must send its local decision information to
   the remote PDP via an LPDP decision object. The PEP must then abide
   by the PDP's decision as it is absolute.

   Finally, fault tolerance is a required capability for this protocol,
   particularly due to the fact it is associated with the security and
   service management of distributed network devices. Fault tolerance
   can be achieved by having both the PEP and remote PDP constantly
   verify their connection to each other via keep-alive messages. When a
   failure is detected, the PEP must try to reconnect to the remote PDP
   or attempt to connect to a backup/alternative PDP. While
   disconnected, the PEP should revert to making local decisions. Once a
   connection is reestablished, the PEP is expected to notify the PDP of
   any deleted state or new events that passed local admission control
   after the connection was lost. Additionally, the remote PDP may
   request that all the PEP's internal state be resynchronized (all
   previously installed requests are to be reissued). After failure and
   before the new connection is fully functional, disruption of service
   can be minimized if the PEP caches previously communicated decisions
   and continues to use them for some limited amount of time. Sections
   2.3 and 2.5 detail COPS mechanisms for achieving reliability.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/2.%20The%20Protocol"></a><a class="selflink" href="#section-2" name="section-2">2</a>. The Protocol</span>

   This section describes the message formats and objects exchanged
   between the PEP and remote PDP.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/2.1%20Common%20Header"></a><a class="selflink" href="#section-2.1" name="section-2.1">2.1</a> Common Header</span>

   Each COPS message consists of the COPS header followed by a number of
   typed objects.

            0              1              2              3
     +--------------+--------------+--------------+--------------+
     |Version| Flags|    Op Code   |       Client-type           |
     +--------------+--------------+--------------+--------------+
     |                      Message Length                       |
     +--------------+--------------+--------------+--------------+

     Global note: //// implies field is reserved, set to 0.





<span class="grey">Durham, et al.              Standards Track                     [Page 6]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-7" id="page-7" name="page-7"> </a>
<span class="grey"><a href="rfc2748.html">RFC 2748</a>                          COPS                      January 2000</span>


       The fields in the header are:
         Version: 4 bits
             COPS version number. Current version is 1.

         Flags: 4 bits
             Defined flag values (all other flags MUST be set to 0):
               0x1 Solicited Message Flag Bit
                This flag is set when the message is solicited by
                another COPS message. This flag is NOT to be set
                (value=0) unless otherwise specified in <a href="#section-3">section 3</a>.

         Op Code: 8 bits
            The COPS operations:
              1 = Request                 (REQ)
              2 = Decision                (DEC)
              3 = Report State            (RPT)
              4 = Delete Request State    (DRQ)
              5 = Synchronize State Req   (SSQ)
              6 = Client-Open             (OPN)
              7 = Client-Accept           (CAT)
              8 = Client-Close            (CC)
              9 = Keep-Alive              (KA)
              10= Synchronize Complete    (SSC)

       Client-type: 16 bits

        The Client-type identifies the policy client. Interpretation of
        all encapsulated objects is relative to the client-type. Client-
        types that set the most significant bit in the client-type field
        are enterprise specific (these are client-types 0x8000 -
        0xFFFF). (See the specific client usage documents for particular
        client-type IDs). For KA Messages, the client-type in the header
        MUST always be set to 0 as the KA is used for connection
        verification (not per client session verification).

        Message Length: 32 bits
        Size of message in octets, which includes the standard COPS
        header and all encapsulated objects. Messages MUST be aligned on
        4 octet intervals.












<span class="grey">Durham, et al.              Standards Track                     [Page 7]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-8" id="page-8" name="page-8"> </a>
<span class="grey"><a href="rfc2748.html">RFC 2748</a>                          COPS                      January 2000</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/2.2%20COPS%20Specific%20Object%20Formats"></a><a class="selflink" href="#section-2.2" name="section-2.2">2.2</a> COPS Specific Object Formats</span>

   All the objects follow the same object format; each object consists
   of one or more 32-bit words with a four-octet header, using the
   following format:

              0             1              2             3
       +-------------+-------------+-------------+-------------+
       |       Length (octets)     |    C-Num    |   C-Type    |
       +-------------+-------------+-------------+-------------+
       |                                                       |
       //                  (Object contents)                   //
       |                                                       |
       +-------------+-------------+-------------+-------------+

   The length is a two-octet value that describes the number of octets
   (including the header) that compose the object. If the length in
   octets does not fall on a 32-bit word boundary, padding MUST be added
   to the end of the object so that it is aligned to the next 32-bit
   boundary before the object can be sent on the wire. On the receiving
   side, a subsequent object boundary can be found by simply rounding up
   the previous stated object length to the next 32-bit boundary.

   Typically, C-Num identifies the class of information contained in the
   object, and the C-Type identifies the subtype or version of the
   information contained in the object.

      C-num: 8 bits
               1  = Handle
               2  = Context
               3  = In Interface
               4  = Out Interface
               5  = Reason code
               6  = Decision
               7  = LPDP Decision
               8  = Error
               9  = Client Specific Info
               10 = Keep-Alive Timer
               11 = PEP Identification
               12 = Report Type
               13 = PDP Redirect Address
               14 = Last PDP Address
               15 = Accounting Timer
               16 = Message Integrity

      C-type: 8 bits
               Values defined per C-num.




<span class="grey">Durham, et al.              Standards Track                     [Page 8]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-9" id="page-9" name="page-9"> </a>
<span class="grey"><a href="rfc2748.html">RFC 2748</a>                          COPS                      January 2000</span>


<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/2.2.1%20Handle%20Object%20%28Handle%29"></a><a class="selflink" href="#section-2.2.1" name="section-2.2.1">2.2.1</a> Handle Object (Handle)</span>

   The Handle Object encapsulates a unique value that identifies an
   installed state. This identification is used by most COPS operations.
   A state corresponding to a handle MUST be explicitly deleted when it
   is no longer applicable. See <a href="#section-2.4">Section 2.4</a> for details.

           C-Num = 1

           C-Type = 1, Client Handle.

   Variable-length field, no implied format other than it is unique from
   other client handles from the same PEP (a.k.a. COPS TCP connection)
   for a particular client-type. It is always initially chosen by the
   PEP and then deleted by the PEP when no longer applicable. The client
   handle is used to refer to a request state initiated by a particular
   PEP and installed at the PDP for a client-type. A PEP will specify a
   client handle in its Request messages, Report messages and Delete
   messages sent to the PDP. In all cases, the client handle is used to
   uniquely identify a particular PEP's request for a client-type.

   The client handle value is set by the PEP and is opaque to the PDP.
   The PDP simply performs a byte-wise comparison on the value in this
   object with respect to the handle object values of other currently
   installed requests.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/2.2.2%20Context%20Object%20%28Context%29"></a><a class="selflink" href="#section-2.2.2" name="section-2.2.2">2.2.2</a> Context Object (Context)</span>

   Specifies the type of event(s) that triggered the query. Required for
   request messages. Admission control, resource allocation, and
   forwarding requests are all amenable to client-types that outsource
   their decision making facility to the PDP. For applicable client-
   types a PEP can also make a request to receive named configuration
   information from the PDP. This named configuration data may be in a
   form useful for setting system attributes on a PEP, or it may be in
   the form of policy rules that are to be directly verified by the PEP.

   Multiple flags can be set for the same request. This is only allowed,
   however, if the set of client specific information in the combined
   request is identical to the client specific information that would be
   specified if individual requests were made for each specified flag.

           C-num = 2, C-Type = 1








<span class="grey">Durham, et al.              Standards Track                     [Page 9]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-10" id="page-10" name="page-10"> </a>
<span class="grey"><a href="rfc2748.html">RFC 2748</a>                          COPS                      January 2000</span>


              0             1               2               3
       +--------------+--------------+--------------+--------------+
       |            R-Type           |            M-Type           |
       +--------------+--------------+--------------+--------------+

           R-Type (Request Type Flag)

               0x01 = Incoming-Message/Admission Control request
               0x02 = Resource-Allocation request
               0x04 = Outgoing-Message request
               0x08 = Configuration request

           M-Type (Message Type)

               Client Specific 16 bit values of protocol message types

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/2.2.3%20In-Interface%20Object%20%28IN-Int%29"></a><a class="selflink" href="#section-2.2.3" name="section-2.2.3">2.2.3</a> In-Interface Object (IN-Int)</span>

   The In-Interface Object is used to identify the incoming interface on
   which a particular request applies and the address where the received
   message originated. For flows or messages generated from the PEP's
   local host, the loop back address and ifindex are used.

   This Interface object is also used to identify the incoming
   (receiving) interface via its ifindex. The ifindex may be used to
   differentiate between sub-interfaces and unnumbered interfaces (see
   RSVP's LIH for an example). When SNMP is supported by the PEP, this
   ifindex integer MUST correspond to the same integer value for the
   interface in the SNMP MIB-II interface index table.

   Note: The ifindex specified in the In-Interface is typically relative
   to the flow of the underlying protocol messages. The ifindex is the
   interface on which the protocol message was received.

           C-Num = 3

           C-Type = 1, IPv4 Address + Interface

               0             1              2             3
       +--------------+--------------+--------------+--------------+
       |                   IPv4 Address format                     |
       +--------------+--------------+--------------+--------------+
       |                          ifindex                          |
       +--------------+--------------+--------------+--------------+

   For this type of the interface object, the IPv4 address specifies the
   IP address that the incoming message came from.




<span class="grey">Durham, et al.              Standards Track                    [Page 10]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-11" id="page-11" name="page-11"> </a>
<span class="grey"><a href="rfc2748.html">RFC 2748</a>                          COPS                      January 2000</span>


           C-Type = 2, IPv6 Address + Interface

               0             1              2             3
       +--------------+--------------+--------------+--------------+
       |                                                           |
       +                                                           +
       |                                                           |
       +                    IPv6 Address format                    +
       |                                                           |
       +                                                           +
       |                                                           |
       +--------------+--------------+--------------+--------------+
       |                          ifindex                          |
       +--------------+--------------+--------------+--------------+

   For this type of the interface object, the IPv6 address specifies the
   IP address that the incoming message came from. The ifindex is used
   to refer to the MIB-II defined local incoming interface on the PEP as
   described above.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/2.2.4%20Out-Interface%20Object%20%28OUT-Int%29"></a><a class="selflink" href="#section-2.2.4" name="section-2.2.4">2.2.4</a> Out-Interface Object (OUT-Int)</span>

   The Out-Interface is used to identify the outgoing interface to which
   a specific request applies and the address for where the forwarded
   message is to be sent. For flows or messages destined to the PEP's
   local host, the loop back address and ifindex are used.  The Out-
   Interface has the same formats as the In-Interface Object.

   This Interface object is also used to identify the outgoing
   (forwarding) interface via its ifindex. The ifindex may be used to
   differentiate between sub-interfaces and unnumbered interfaces (see
   RSVP's LIH for an example). When SNMP is supported by the PEP, this
   ifindex integer MUST correspond to the same integer value for the
   interface in the SNMP MIB-II interface index table.

   Note: The ifindex specified in the Out-Interface is typically
   relative to the flow of the underlying protocol messages. The ifindex
   is the one on which a protocol message is about to be forwarded.

           C-Num = 4

           C-Type = 1, IPv4 Address + Interface

   Same C-Type format as the In-Interface object. The IPv4 address
   specifies the IP address to which the outgoing message is going. The
   ifindex is used to refer to the MIB-II defined local outgoing
   interface on the PEP.




<span class="grey">Durham, et al.              Standards Track                    [Page 11]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-12" id="page-12" name="page-12"> </a>
<span class="grey"><a href="rfc2748.html">RFC 2748</a>                          COPS                      January 2000</span>


           C-Type = 2, IPv6 Address + Interface

   Same C-Type format as the In-Interface object. For this type of the
   interface object, the IPv6 address specifies the IP address to which
   the outgoing message is going. The ifindex is used to refer to the
   MIB-II defined local outgoing interface on the PEP.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/2.2.5%20Reason%20Object%20%28Reason%29"></a><a class="selflink" href="#section-2.2.5" name="section-2.2.5">2.2.5</a> Reason Object (Reason)</span>

   This object specifies the reason why the request state was deleted.
   It appears in the delete request (DRQ) message. The Reason Sub-code
   field is reserved for more detailed client-specific reason codes
   defined in the corresponding documents.

           C-Num = 5, C-Type = 1

               0             1              2             3
       +--------------+--------------+--------------+--------------+
       |         Reason-Code         |       Reason Sub-code       |
       +--------------+--------------+--------------+--------------+

           Reason Code:
               1 = Unspecified
               2 = Management
               3 = Preempted (Another request state takes precedence)
               4 = Tear (Used to communicate a signaled state removal)
               5 = Timeout (Local state has timed-out)
               6 = Route Change (Change invalidates request state)
               7 = Insufficient Resources (No local resource available)
               8 = PDP's Directive (PDP decision caused the delete)
               9 = Unsupported decision (PDP decision not supported)
               10= Synchronize Handle Unknown
               11= Transient Handle (stateless event)
               12= Malformed Decision (could not recover)
               13= Unknown COPS Object from PDP:
                   Sub-code (octet 2) contains unknown object's C-Num
                   and (octet 3) contains unknown object's C-Type.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/2.2.6%20Decision%20Object%20%28Decision%29"></a><a class="selflink" href="#section-2.2.6" name="section-2.2.6">2.2.6</a> Decision Object (Decision)</span>

   Decision made by the PDP. Appears in replies. The specific non-
   mandatory decision objects required in a decision to a particular
   request depend on the type of client.








<span class="grey">Durham, et al.              Standards Track                    [Page 12]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-13" id="page-13" name="page-13"> </a>
<span class="grey"><a href="rfc2748.html">RFC 2748</a>                          COPS                      January 2000</span>


               C-Num = 6
               C-Type = 1, Decision Flags (Mandatory)

               0             1              2             3
       +--------------+--------------+--------------+--------------+
       |        Command-Code         |            Flags            |
       +--------------+--------------+--------------+--------------+

           Commands:
               0 = NULL Decision (No configuration data available)
               1 = Install (Admit request/Install configuration)
               2 = Remove (Remove request/Remove configuration)

           Flags:
               0x01 = Trigger Error (Trigger error message if set)
                Note: Trigger Error is applicable to client-types that
                are capable of sending error notifications for signaled
                messages.

       Flag values not applicable to a given context's R-Type or
       client-type MUST be ignored by the PEP.

              C-Type = 2, Stateless Data

       This type of decision object carries additional stateless
       information that can be applied by the PEP locally. It is a
       variable length object and its internal format SHOULD be
       specified in the relevant COPS extension document for the given
       client-type. This object is optional in Decision messages and is
       interpreted relative to a given context.

       It is expected that even outsourcing PEPs will be able to make
       some simple stateless policy decisions locally in their LPDP. As
       this set is well known and implemented ubiquitously, PDPs are
       aware of it as well (either universally, through configuration,
       or using the Client-Open message). The PDP may also include this
       information in its decision, and the PEP MUST apply it to the
       resource allocation event that generated the request.

               C-Type = 3, Replacement Data

       This type of decision object carries replacement data that is to
       replace existing data in a signaled message. It is a variable
       length object and its internal format SHOULD be specified in the
       relevant COPS extension document for the given client-type. It is
       optional in Decision messages and is interpreted relative to a
       given context.




<span class="grey">Durham, et al.              Standards Track                    [Page 13]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-14" id="page-14" name="page-14"> </a>
<span class="grey"><a href="rfc2748.html">RFC 2748</a>                          COPS                      January 2000</span>


               C-Type = 4, Client Specific Decision Data

       Additional decision types can be introduced using the Client
       Specific Decision Data Object. It is a variable length object and
       its internal format SHOULD be specified in the relevant COPS
       extension document for the given client-type. It is optional in
       Decision messages and is interpreted relative to a given context.

               C-Type = 5, Named Decision Data

       Named configuration information is encapsulated in this version
       of the decision object in response to configuration requests. It
       is a variable length object and its internal format SHOULD be
       specified in the relevant COPS extension document for the given
       client-type. It is optional in Decision messages and is
       interpreted relative to both a given context and decision flags.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/2.2.7%20LPDP%20Decision%20Object%20%28LPDPDecision%29"></a><a class="selflink" href="#section-2.2.7" name="section-2.2.7">2.2.7</a> LPDP Decision Object (LPDPDecision)</span>

   Decision made by the PEP's local policy decision point (LPDP). May
   appear in requests. These objects correspond to and are formatted the
   same as the client specific decision objects defined above.

           C-Num = 7

           C-Type = (same C-Type as for Decision objects)

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/2.2.8%20Error%20Object%20%28Error%29"></a><a class="selflink" href="#section-2.2.8" name="section-2.2.8">2.2.8</a> Error Object (Error)</span>

   This object is used to identify a particular COPS protocol error.
   The error sub-code field contains additional detailed client specific
   error codes. The appropriate Error Sub-codes for a particular
   client-type SHOULD be specified in the relevant COPS extensions
   document.

            C-Num = 8, C-Type = 1

               0             1              2             3
       +--------------+--------------+--------------+--------------+
       |          Error-Code         |        Error Sub-code       |
       +--------------+--------------+--------------+--------------+

           Error-Code:

               1 = Bad handle
               2 = Invalid handle reference
               3 = Bad message format (Malformed Message)
               4 = Unable to process (server gives up on query)



<span class="grey">Durham, et al.              Standards Track                    [Page 14]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-15" id="page-15" name="page-15"> </a>
<span class="grey"><a href="rfc2748.html">RFC 2748</a>                          COPS                      January 2000</span>


               5 = Mandatory client-specific info missing
               6 = Unsupported client-type
               7 = Mandatory COPS object missing
               8 = Client Failure
               9 = Communication Failure
               10= Unspecified
               11= Shutting down
               12= Redirect to Preferred Server
               13= Unknown COPS Object:
                   Sub-code (octet 2) contains unknown object's C-Num
                   and (octet 3) contains unknown object's C-Type.
               14= Authentication Failure
               15= Authentication Required

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/2.2.9%20Client%20Specific%20Information%20Object%20%28ClientSI%29"></a><a class="selflink" href="#section-2.2.9" name="section-2.2.9">2.2.9</a> Client Specific Information Object (ClientSI)</span>

   The various types of this object are required for requests, and used
   in reports and opens when required. It contains client-type specific
   information.

           C-Num = 9,

           C-Type = 1, Signaled ClientSI.

   Variable-length field. All objects/attributes specific to a client's
   signaling protocol or internal state are encapsulated within one or
   more signaled Client Specific Information Objects. The format of the
   data encapsulated in the ClientSI object is determined by the
   client-type.

           C-Type = 2, Named ClientSI.

   Variable-length field. Contains named configuration information
   useful for relaying specific information about the PEP, a request, or
   configured state to the PDP server.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/2.2.10%20Keep-Alive%20Timer%20Object%20%28KATimer%29"></a><a class="selflink" href="#section-2.2.10" name="section-2.2.10">2.2.10</a> Keep-Alive Timer Object (KATimer)</span>

   Times are encoded as 2 octet integer values and are in units of
   seconds.  The timer value is treated as a delta.

           C-Num = 10,

           C-Type = 1, Keep-alive timer value







<span class="grey">Durham, et al.              Standards Track                    [Page 15]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-16" id="page-16" name="page-16"> </a>
<span class="grey"><a href="rfc2748.html">RFC 2748</a>                          COPS                      January 2000</span>


   Timer object used to specify the maximum time interval over which a
   COPS message MUST be sent or received. The range of finite timeouts
   is 1 to 65535 seconds represented as an unsigned two-octet integer.
   The value of zero implies infinity.

               0             1              2             3
      +--------------+--------------+--------------+--------------+
      |        //////////////       |        KA Timer Value       |
      +--------------+--------------+--------------+--------------+

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/2.2.11%20PEP%20Identification%20Object%20%28PEPID%29"></a><a class="selflink" href="#section-2.2.11" name="section-2.2.11">2.2.11</a> PEP Identification Object (PEPID)</span>

   The PEP Identification Object is used to identify the PEP client to
   the remote PDP. It is required for Client-Open messages.

           C-Num = 11, C-Type = 1

   Variable-length field. It is a NULL terminated ASCII string that is
   also zero padded to a 32-bit word boundary (so the object length is a
   multiple of 4 octets). The PEPID MUST contain an ASCII string that
   uniquely identifies the PEP within the policy domain in a manner that
   is persistent across PEP reboots. For example, it may be the PEP's
   statically assigned IP address or DNS name. This identifier may
   safely be used by a PDP as a handle for identifying the PEP in its
   policy rules.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/2.2.12%20Report-Type%20Object%20%28Report-Type%29"></a><a class="selflink" href="#section-2.2.12" name="section-2.2.12">2.2.12</a> Report-Type Object (Report-Type)</span>

   The Type of Report on the request state associated with a handle:

           C-Num = 12, C-Type = 1

               0             1              2             3
       +--------------+--------------+--------------+--------------+
       |         Report-Type         |        /////////////        |
       +--------------+--------------+--------------+--------------+

           Report-Type:
               1 = Success   : Decision was successful at the PEP
               2 = Failure   : Decision could not be completed by PEP
               3 = Accounting: Accounting update for an installed state

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/2.2.13%20PDP%20Redirect%20Address%20%28PDPRedirAddr%29"></a><a class="selflink" href="#section-2.2.13" name="section-2.2.13">2.2.13</a> PDP Redirect Address (PDPRedirAddr)</span>

   A PDP when closing a PEP session for a particular client-type may
   optionally use this object to redirect the PEP to the specified PDP
   server address and TCP port number:




<span class="grey">Durham, et al.              Standards Track                    [Page 16]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-17" id="page-17" name="page-17"> </a>
<span class="grey"><a href="rfc2748.html">RFC 2748</a>                          COPS                      January 2000</span>


       C-Num = 13,

       C-Type = 1, IPv4 Address + TCP Port
                0             1              2             3
       +--------------+--------------+--------------+--------------+
       |                   IPv4 Address format                     |
       +--------------+--------------+--------------+--------------+
       |  /////////////////////////  |       TCP Port Number       |
       +-----------------------------+-----------------------------+

       C-Type = 2, IPv6 Address + TCP Port
                0             1              2             3
       +--------------+--------------+--------------+--------------+
       |                                                           |
       +                                                           +
       |                                                           |
       +                    IPv6 Address format                    +
       |                                                           |
       +                                                           +
       |                                                           |
       +--------------+--------------+--------------+--------------+
       |  /////////////////////////  |       TCP Port Number       |
       +-----------------------------+-----------------------------+

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/2.2.14%20Last%20PDP%20Address%20%28LastPDPAddr%29"></a><a class="selflink" href="#section-2.2.14" name="section-2.2.14">2.2.14</a> Last PDP Address (LastPDPAddr)</span>

   When a PEP sends a Client-Open message for a particular client-type
   the PEP SHOULD specify the last PDP it has successfully opened
   (meaning it received a Client-Accept) since the PEP last rebooted.
   If no PDP was used since the last reboot, the PEP will simply not
   include this object in the Client-Open message.

       C-Num = 14,

       C-Type = 1, IPv4 Address (Same format as PDPRedirAddr)

       C-Type = 2, IPv6 Address (Same format as PDPRedirAddr)

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/2.2.15%20Accounting%20Timer%20Object%20%28AcctTimer%29"></a><a class="selflink" href="#section-2.2.15" name="section-2.2.15">2.2.15</a> Accounting Timer Object (AcctTimer)</span>

   Times are encoded as 2 octet integer values and are in units of
   seconds.  The timer value is treated as a delta.

           C-Num = 15,

           C-Type = 1, Accounting timer value





<span class="grey">Durham, et al.              Standards Track                    [Page 17]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-18" id="page-18" name="page-18"> </a>
<span class="grey"><a href="rfc2748.html">RFC 2748</a>                          COPS                      January 2000</span>


   Optional timer value used to determine the minimum interval between
   periodic accounting type reports. It is used by the PDP to describe
   to the PEP an acceptable interval between unsolicited accounting
   updates via Report messages where applicable. It provides a method
   for the PDP to control the amount of accounting traffic seen by the
   network. The range of finite time values is 1 to 65535 seconds
   represented as an unsigned two-octet integer. A value of zero means
   there SHOULD be no unsolicited accounting updates.

                0             1              2             3
       +--------------+--------------+--------------+--------------+
       |        //////////////       |        ACCT Timer Value     |
       +--------------+--------------+--------------+--------------+

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/2.2.16%20Message%20Integrity%20Object%20%28Integrity%29"></a><a class="selflink" href="#section-2.2.16" name="section-2.2.16">2.2.16</a> Message Integrity Object (Integrity)</span>

   The integrity object includes a sequence number and a message digest
   useful for authenticating and validating the integrity of a COPS
   message. When used, integrity is provided at the end of a COPS
   message as the last COPS object. The digest is then computed over all
   of a particular COPS message up to but not including the digest value
   itself. The sender of a COPS message will compute and fill in the
   digest portion of the Integrity object. The receiver of a COPS
   message will then compute a digest over the received message and
   verify it matches the digest in the received Integrity object.

           C-Num = 16,

           C-Type = 1, HMAC digest

   The HMAC integrity object employs HMAC (Keyed-Hashing for Message
   Authentication) [<a href="#ref-HMAC" title='"HMAC: Keyed-Hashing for Message Authentication"'>HMAC</a>] to calculate the message digest based on a key
   shared between the PEP and its PDP.

   This Integrity object specifies a 32-bit Key ID used to identify a
   specific key shared between a particular PEP and its PDP and the
   cryptographic algorithm to be used. The Key ID allows for multiple
   simultaneous keys to exist on the PEP with corresponding keys on the
   PDP for the given PEPID. The key identified by the Key ID was used to
   compute the message digest in the Integrity object. All
   implementations, at a minimum, MUST support HMAC-MD5-96, which is
   HMAC employing the MD5 Message-Digest Algorithm [<a href="#ref-MD5" title='"The MD5 Message-Digest Algorithm"'>MD5</a>] truncated to
   96-bits to calculate the message digest.

   This object also includes a sequence number that is a 32-bit unsigned
   integer used to avoid replay attacks. The sequence number is
   initiated during an initial Client-Open Client-Accept message
   exchange and is then incremented by one each time a new message is



<span class="grey">Durham, et al.              Standards Track                    [Page 18]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-19" id="page-19" name="page-19"> </a>
<span class="grey"><a href="rfc2748.html">RFC 2748</a>                          COPS                      January 2000</span>


   sent over the TCP connection in the same direction. If the sequence
   number reaches the value of 0xFFFFFFFF, the next increment will
   simply rollover to a value of zero.

   The variable length digest is calculated over a COPS message starting
   with the COPS Header up to the Integrity Object (which MUST be the
   last object in a COPS message) INCLUDING the Integrity object's
   header, Key ID, and Sequence Number. The Keyed Message Digest field
   is not included as part of the digest calculation. In the case of
   HMAC-MD5-96, HMAC-MD5 will produce a 128-bit digest that is then to
   be truncated to 96-bits before being stored in or verified against
   the Keyed Message Digest field as specified in [<a href="#ref-HMAC" title='"HMAC: Keyed-Hashing for Message Authentication"'>HMAC</a>]. The Keyed
   Message Digest MUST be 96-bits when HMAC-MD5-96 is used.

             0             1              2             3
       +-------------+-------------+-------------+-------------+
       |                        Key ID                         |
       +-------------+-------------+-------------+-------------+
       |                    Sequence Number                    |
       +-------------+-------------+-------------+-------------+
       |                                                       |
       +                                                       +
       |               ...Keyed Message Digest...              |
       +                                                       +
       |                                                       |
       +-------------+-------------+-------------+-------------+

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/2.3%20Communication"></a><a class="selflink" href="#section-2.3" name="section-2.3">2.3</a> Communication</span>

   The COPS protocol uses a single persistent TCP connection between the
   PEP and a remote PDP. One PDP implementation per server MUST listen
   on a well-known TCP port number (COPS=3288 [<a href="#ref-IANA">IANA</a>]). The PEP is
   responsible for initiating the TCP connection to a PDP. The location
   of the remote PDP can either be configured, or obtained via a service
   location mechanism [<a href="#ref-SRVLOC" title='"Service Location Protocol , Version 2"'>SRVLOC</a>]. Service discovery is outside the scope
   of this protocol, however.

   If a single PEP can support multiple client-types, it may send
   multiple Client-Open messages, each specifying a particular client-
   type to a PDP over one or more TCP connections. Likewise, a PDP
   residing at a given address and port number may support one or more
   client-types. Given the client-types it supports, a PDP has the
   ability to either accept or reject each client-type independently.
   If a client-type is rejected, the PDP can redirect the PEP to an
   alternative PDP address and TCP port for a given client-type via
   COPS.  Different TCP port numbers can be used to redirect the PEP to
   another PDP implementation running on the same server. Additional
   provisions for supporting multiple client-types (perhaps from



<span class="grey">Durham, et al.              Standards Track                    [Page 19]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-20" id="page-20" name="page-20"> </a>
<span class="grey"><a href="rfc2748.html">RFC 2748</a>                          COPS                      January 2000</span>


   independent PDP vendors) on a single remote PDP server are not
   provided by the COPS protocol, but, rather, are left to the software
   architecture of the given server platform.

   It is possible a single PEP may have open connections to multiple
   PDPs. This is the case when there are physically different PDPs
   supporting different client-types as shown in figure 2.

       +----------------+
       |                |
       |  Network Node  |                  Policy Servers
       |                |
       |   +-----+      | COPS Client Type 1  +-----+
       |   |     |&lt;-----|--------------------&gt;| PDP1|
       |   + PEP +      | COPS Client Type 2  +-----+
       |   |     |&lt;-----|---------\           +-----+
       |   +-----+      |          \----------| PDP2|
       |    ^           |                     +-----+
       |    |           |
       |    \--&gt;+-----+ |
       |        | LPDP| |
       |        +-----+ |
       |                |
       +----------------+

       Figure 2: Multiple PDPs illustration.

   When a TCP connection is torn down or is lost, the PDP is expected to
   eventually clean up any outstanding request state related to
   request/decision exchanges with the PEP. When the PEP detects a lost
   connection due to a timeout condition it SHOULD explicitly send a
   Client-Close message for each opened client-type containing an
   &lt;Error&gt; object indicating the "Communication Failure" Error-Code.
   Additionally, the PEP SHOULD continuously attempt to contact the
   primary PDP or, if unsuccessful, any known backup PDPs. Specifically
   the PEP SHOULD keep trying all relevant PDPs with which it has been
   configured until it can establish a connection. If a PEP is in
   communication with a backup PDP and the primary PDP becomes
   available, the backup PDP is responsible for redirecting the PEP back
   to the primary PDP (via a &lt;Client-Close&gt; message containing a
   &lt;PDPRedirAddr&gt; object identifying the primary PDP to use for each
   affected client-type). <a href="#section-2.5">Section 2.5</a> details synchronization behavior
   between PEPs and PDPs.








<span class="grey">Durham, et al.              Standards Track                    [Page 20]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-21" id="page-21" name="page-21"> </a>
<span class="grey"><a href="rfc2748.html">RFC 2748</a>                          COPS                      January 2000</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/2.4%20Client%20Handle%20Usage"></a><a class="selflink" href="#section-2.4" name="section-2.4">2.4</a> Client Handle Usage</span>

   The client handle is used to identify a unique request state for a
   single PEP per client-type. Client handles are chosen by the PEP and
   are opaque to the PDP. The PDP simply uses the request handle to
   uniquely identify the request state for a particular Client-Type over
   a particular TCP connection and generically tie its decisions to a
   corresponding request. Client handles are initiated in request
   messages and are then used by subsequent request, decision, and
   report messages to reference the same request state. When the PEP is
   ready to remove a local request state, it will issue a delete message
   to the PDP for the corresponding client handle. A handle MUST be
   explicitly deleted by the PEP before it can be used by the PEP to
   identify a new request state. Handles referring to different request
   states MUST be unique within the context of a particular TCP
   connection and client-type.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/2.5%20Synchronization%20Behavior"></a><a class="selflink" href="#section-2.5" name="section-2.5">2.5</a> Synchronization Behavior</span>

   When disconnected from a PDP, the PEP SHOULD revert to making local
   decisions. Once a connection is reestablished, the PEP is expected to
   notify the PDP of any events that have passed local admission
   control. Additionally, the remote PDP may request that all the PEP's
   internal state be resynchronized (all previously installed requests
   are to be reissued) by sending a Synchronize State message.

   After a failure and before a new connection is fully functional,
   disruption of service can be minimized if the PEP caches previously
   communicated decisions and continues to use them for some appropriate
   length of time. Specific rules for such behavior are to be defined in
   the appropriate COPS client-type extension specifications.

   A PEP that caches state from a previous exchange with a disconnected
   PDP MUST communicate this fact to any PDP with which it is able to
   later reconnect. This is accomplished by including the address and
   TCP port of the last PDP for which the PEP is still caching state in
   the Client-Open message. The &lt;LastPDPAddr&gt; object will only be
   included for the last PDP with which the PEP was completely in sync.
   If the service interruption was temporary and the PDP still contains
   the complete state for the PEP, the PDP may choose not to synchronize
   all states. It is still the responsibility of the PEP to update the
   PDP of all state changes that occurred during the disruption of
   service including any states communicated to the previous PDP that
   had been deleted after the connection was lost.  These MUST be
   explicitly deleted after a connection is reestablished. If the PDP
   issues a synchronize request the PEP MUST pass all current states to
   the PDP followed by a Synchronize State Complete message (thus




<span class="grey">Durham, et al.              Standards Track                    [Page 21]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-22" id="page-22" name="page-22"> </a>
<span class="grey"><a href="rfc2748.html">RFC 2748</a>                          COPS                      January 2000</span>


   completing the synchronization process). If the PEP crashes and loses
   all cached state for a client-type, it will simply not include a
   &lt;LastPDPAddr&gt; in its Client-Open message.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/3.%20Message%20Content"></a><a class="selflink" href="#section-3" name="section-3">3</a>. Message Content</span>

   This section describes the basic messages exchanged between a PEP and
   a remote PDP as well as their contents. As a convention, object
   ordering is expected as shown in the BNF for each COPS message unless
   otherwise noted. The Integrity object, if included, MUST always be
   the last object in a message. If security is required and a message
   was received without a valid Integrity object, the receiver MUST send
   a Client-Close message for Client-Type=0 specifying the appropriate
   error code.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.1%20Request%20%28REQ%29"></a><a class="selflink" href="#section-3.1" name="section-3.1">3.1</a> Request (REQ)  </span>PEP -&gt; PDP

   The PEP establishes a request state client handle for which the
   remote PDP may maintain state. The remote PDP then uses this handle
   to refer to the exchanged information and decisions communicated over
   the TCP connection to a particular PEP for a given client-type.

   Once a stateful handle is established for a new request, any
   subsequent modifications of the request can be made using the REQ
   message specifying the previously installed handle. The PEP is
   responsible for notifying the PDP whenever its local state changes so
   the PDP's state will be able to accurately mirror the PEP's state.
























<span class="grey">Durham, et al.              Standards Track                    [Page 22]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-23" id="page-23" name="page-23"> </a>
<span class="grey"><a href="rfc2748.html">RFC 2748</a>                          COPS                      January 2000</span>


   The format of the Request message is as follows:

               &lt;Request Message&gt; ::=  &lt;Common Header&gt;
                                      &lt;Client Handle&gt;
                                      &lt;Context&gt;
                                      [&lt;IN-Int&gt;]
                                      [&lt;OUT-Int&gt;]
                                      [&lt;ClientSI(s)&gt;]
                                      [&lt;LPDPDecision(s)&gt;]
                                      [&lt;Integrity&gt;]

               &lt;ClientSI(s)&gt; ::= &lt;ClientSI&gt; | &lt;ClientSI(s)&gt; &lt;ClientSI&gt;

               &lt;LPDPDecision(s)&gt; ::= &lt;LPDPDecision&gt; |
                                     &lt;LPDPDecision(s)&gt; &lt;LPDPDecision&gt;

               &lt;LPDPDecision&gt; ::= [&lt;Context&gt;]
                                  &lt;LPDPDecision: Flags&gt;
                                  [&lt;LPDPDecision: Stateless Data&gt;]
                                  [&lt;LPDPDecision: Replacement Data&gt;]
                                  [&lt;LPDPDecision: ClientSI Data&gt;]
                                  [&lt;LPDPDecision: Named Data&gt;]


   The context object is used to determine the context within which all
   the other objects are to be interpreted. It also is used to determine
   the kind of decision to be returned from the policy server. This
   decision might be related to admission control, resource allocation,
   object forwarding and substitution, or configuration.

   The interface objects are used to determine the corresponding
   interface on which a signaling protocol message was received or is
   about to be sent. They are typically used if the client is
   participating along the path of a signaling protocol or if the client
   is requesting configuration data for a particular interface.

   ClientSI, the client specific information object, holds the client-
   type specific data for which a policy decision needs to be made. In
   the case of configuration, the Named ClientSI may include named
   information about the module, interface, or functionality to be
   configured. The ordering of multiple ClientSIs is not important.

   Finally, LPDPDecision object holds information regarding the local
   decision made by the LPDP.

   Malformed Request messages MUST result in the PDP specifying a
   Decision message with the appropriate error code.




<span class="grey">Durham, et al.              Standards Track                    [Page 23]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-24" id="page-24" name="page-24"> </a>
<span class="grey"><a href="rfc2748.html">RFC 2748</a>                          COPS                      January 2000</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.2%20Decision%20%28DEC%29"></a><a class="selflink" href="#section-3.2" name="section-3.2">3.2</a> Decision (DEC)  </span>PDP -&gt; PEP

   The PDP responds to the REQ with a DEC message that includes the
   associated client handle and one or more decision objects grouped
   relative to a Context object and Decision Flags object type pair. If
   there was a protocol error an error object is returned instead.

   It is required that the first decision message for a new/updated
   request will have the solicited message flag set (value = 1) in the
   COPS header. This avoids the issue of keeping track of which updated
   request (that is, a request reissued for the same handle) a
   particular decision corresponds. It is important that, for a given
   handle, there be at most one outstanding solicited decision per
   request. This essentially means that the PEP SHOULD NOT issue more
   than one REQ (for a given handle) before it receives a corresponding
   DEC with the solicited message flag set. The PDP MUST always issue
   decisions for requests on a particular handle in the order they
   arrive and all requests MUST have a corresponding decision.

   To avoid deadlock, the PEP can always timeout after issuing a request
   that does not receive a decision. It MUST then delete the timed-out
   handle, and may try again using a new handle.

   The format of the Decision message is as follows:

               &lt;Decision Message&gt; ::= &lt;Common Header&gt;
                                      &lt;Client Handle&gt;
                                      &lt;Decision(s)&gt; | &lt;Error&gt;
                                      [&lt;Integrity&gt;]

               &lt;Decision(s)&gt; ::= &lt;Decision&gt; | &lt;Decision(s)&gt; &lt;Decision&gt;

               &lt;Decision&gt; ::= &lt;Context&gt;
                              &lt;Decision: Flags&gt;
                              [&lt;Decision: Stateless Data&gt;]
                              [&lt;Decision: Replacement Data&gt;]
                              [&lt;Decision: ClientSI Data&gt;]
                              [&lt;Decision: Named Data&gt;]

   The Decision message may include either an Error object or one or
   more context plus associated decision objects. COPS protocol problems
   are reported in the Error object (e.g. an error with the format of
   the original request including malformed request messages, unknown
   COPS objects in the Request, etc.). The applicable Decision object(s)
   depend on the context and the type of client. The only ordering
   requirement for decision objects is that the required Decision Flags
   object type MUST precede the other Decision object types per context
   binding.



<span class="grey">Durham, et al.              Standards Track                    [Page 24]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-25" id="page-25" name="page-25"> </a>
<span class="grey"><a href="rfc2748.html">RFC 2748</a>                          COPS                      January 2000</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.3%20Report%20State%20%28RPT%29"></a><a class="selflink" href="#section-3.3" name="section-3.3">3.3</a> Report State (RPT)  </span>PEP -&gt; PDP

   The RPT message is used by the PEP to communicate to the PDP its
   success or failure in carrying out the PDP's decision, or to report
   an accounting related change in state. The Report-Type specifies the
   kind of report and the optional ClientSI can carry additional
   information per Client-Type.

   For every DEC message containing a configuration context that is
   received by a PEP, the PEP MUST generate a corresponding Report State
   message with the Solicited Message flag set describing its success or
   failure in applying the configuration decision. In addition,
   outsourcing decisions from the PDP MAY result in a corresponding
   solicited Report State from the PEP depending on the context and the
   type of client. RPT messages solicited by decisions for a given
   Client Handle MUST set the Solicited Message flag and MUST be sent in
   the same order as their corresponding Decision messages were
   received. There MUST never be more than one Report State message
   generated with the Solicited Message flag set per Decision.

   The Report State may also be used to provide periodic updates of
   client specific information for accounting and state monitoring
   purposes depending on the type of the client. In such cases the
   accounting report type should be specified utilizing the appropriate
   client specific information object.

              &lt;Report State&gt; ::== &lt;Common Header&gt;
                                  &lt;Client Handle&gt;
                                  &lt;Report-Type&gt;
                                  [&lt;ClientSI&gt;]
                                  [&lt;Integrity&gt;]

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.4%20Delete%20Request%20State%20%28DRQ%29"></a><a class="selflink" href="#section-3.4" name="section-3.4">3.4</a> Delete Request State (DRQ)  </span>PEP -&gt; PDP

   When sent from the PEP this message indicates to the remote PDP that
   the state identified by the client handle is no longer
   available/relevant. This information will then be used by the remote
   PDP to initiate the appropriate housekeeping actions. The reason code
   object is interpreted with respect to the client-type and signifies
   the reason for the removal.

   The format of the Delete Request State message is as follows:

              &lt;Delete Request&gt;  ::= &lt;Common Header&gt;
                                    &lt;Client Handle&gt;
                                    &lt;Reason&gt;
                                    [&lt;Integrity&gt;]




<span class="grey">Durham, et al.              Standards Track                    [Page 25]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-26" id="page-26" name="page-26"> </a>
<span class="grey"><a href="rfc2748.html">RFC 2748</a>                          COPS                      January 2000</span>


   Given the stateful nature of COPS, it is important that when a
   request state is finally removed from the PEP, a DRQ message for this
   request state is sent to the PDP so the corresponding state may
   likewise be removed on the PDP. Request states not explicitly deleted
   by the PEP will be maintained by the PDP until either the client
   session is closed or the connection is terminated.

   Malformed Decision messages MUST trigger a DRQ specifying the
   appropriate erroneous reason code (Bad Message Format) and any
   associated state on the PEP SHOULD either be removed or re-requested.
   If a Decision contained an unknown COPS Decision Object, the PEP MUST
   delete its request specifying the Unknown COPS Object reason code
   because the PEP will be unable to comply with the information
   contained in the unknown object. In any case, after issuing a DRQ,
   the PEP may retry the corresponding Request again.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.5%20Synchronize%20State%20Request%20%28SSQ%29"></a><a class="selflink" href="#section-3.5" name="section-3.5">3.5</a> Synchronize State Request (SSQ)  </span>PDP -&gt; PEP

   The format of the Synchronize State Query message is as follows:

              &lt;Synchronize State&gt; ::= &lt;Common Header&gt;
                                      [&lt;Client Handle&gt;]
                                      [&lt;Integrity&gt;]

   This message indicates that the remote PDP wishes the client (which
   appears in the common header) to re-send its state. If the optional
   Client Handle is present, only the state associated with this handle
   is synchronized. If the PEP does not recognize the requested handle,
   it MUST immediately send a DRQ message to the PDP for the handle that
   was specified in the SSQ message. If no handle is specified in the
   SSQ message, all the active client state MUST be synchronized with
   the PDP.

   The client performs state synchronization by re-issuing request
   queries of the specified client-type for the existing state in the
   PEP. When synchronization is complete, the PEP MUST issue a
   synchronize state complete message to the PDP.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.6%20Client-Open%20%28OPN%29"></a><a class="selflink" href="#section-3.6" name="section-3.6">3.6</a> Client-Open (OPN)  </span>PEP -&gt; PDP

   The Client-Open message can be used by the PEP to specify to the PDP
   the client-types the PEP can support, the last PDP to which the PEP
   connected for the given client-type, and/or client specific feature
   negotiation. A Client-Open message can be sent to the PDP at any time
   and multiple Client-Open messages for the same client-type are
   allowed (in case of global state changes).





<span class="grey">Durham, et al.              Standards Track                    [Page 26]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-27" id="page-27" name="page-27"> </a>
<span class="grey"><a href="rfc2748.html">RFC 2748</a>                          COPS                      January 2000</span>


        &lt;Client-Open&gt;  ::= &lt;Common Header&gt;
                           &lt;PEPID&gt;
                           [&lt;ClientSI&gt;]
                           [&lt;LastPDPAddr&gt;]
                           [&lt;Integrity&gt;]

   The PEPID is a symbolic, variable length name that uniquely
   identifies the specific client to the PDP (see <a href="#section-2.2.11">Section 2.2.11</a>).

   A named ClientSI object can be included for relaying additional
   global information about the PEP to the PDP when required (as
   specified in the appropriate extensions document for the client-
   type).

   The PEP may also provide a Last PDP Address object in its Client-Open
   message specifying the last PDP (for the given client-type) for which
   it is still caching decisions since its last reboot. A PDP can use
   this information to determine the appropriate synchronization
   behavior (See <a href="#section-2.5">section 2.5</a>).

   If the PDP receives a malformed Client-Open message it MUST generate
   a Client-Close message specifying the appropriate error code.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.7%20Client-Accept%20%28CAT%29"></a><a class="selflink" href="#section-3.7" name="section-3.7">3.7</a> Client-Accept (CAT)  </span>PDP -&gt; PEP

   The Client-Accept message is used to positively respond to the
   Client-Open message. This message will return to the PEP a timer
   object indicating the maximum time interval between keep-alive
   messages. Optionally, a timer specifying the minimum allowed interval
   between accounting report messages may be included when applicable.

              &lt;Client-Accept&gt;  ::= &lt;Common Header&gt;
                                   &lt;KA Timer&gt;
                                   [&lt;ACCT Timer&gt;]
                                   [&lt;Integrity&gt;]

   If the PDP refuses the client, it will instead issue a Client-Close
   message.

   The KA Timer corresponds to maximum acceptable intermediate time
   between the generation of messages by the PDP and PEP. The timer
   value is determined by the PDP and is specified in seconds. A timer
   value of 0 implies no secondary connection verification is necessary.

   The optional ACCT Timer allows the PDP to indicate to the PEP that
   periodic accounting reports SHOULD NOT exceed the specified timer
   interval per client handle. This allows the PDP to control the rate
   at which accounting reports are sent by the PEP (when applicable).



<span class="grey">Durham, et al.              Standards Track                    [Page 27]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-28" id="page-28" name="page-28"> </a>
<span class="grey"><a href="rfc2748.html">RFC 2748</a>                          COPS                      January 2000</span>


   In general, accounting type Report messages are sent to the PDP when
   determined appropriate by the PEP. The accounting timer merely is
   used by the PDP to keep the rate of such updates in check (i.e.
   Preventing the PEP from blasting the PDP with accounting reports).
   Not including this object implies there are no PDP restrictions on
   the rate at which accounting updates are generated.

   If the PEP receives a malformed Client-Accept message it MUST
   generate a Client-Close message specifying the appropriate error
   code.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.8%20Client-Close%20%28CC%29"></a><a class="selflink" href="#section-3.8" name="section-3.8">3.8</a> Client-Close (CC)  </span>PEP -&gt; PDP, PDP -&gt; PEP

   The Client-Close message can be issued by either the PDP or PEP to
   notify the other that a particular type of client is no longer being
   supported.

               &lt;Client-Close&gt;  ::= &lt;Common Header&gt;
                                   &lt;Error&gt;
                                   [&lt;PDPRedirAddr&gt;]
                                   [&lt;Integrity&gt;]

   The Error object is included to describe the reason for the close
   (e.g. the requested client-type is not supported by the remote PDP or
   client failure).

   A PDP MAY optionally include a PDP Redirect Address object in order
   to inform the PEP of the alternate PDP it SHOULD use for the client-
   type specified in the common header.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.9%20Keep-Alive%20%28KA%29"></a><a class="selflink" href="#section-3.9" name="section-3.9">3.9</a> Keep-Alive (KA)  </span>PEP -&gt; PDP, PDP -&gt; PEP

   The keep-alive message MUST be transmitted by the PEP within the
   period defined by the minimum of all KA Timer values specified in all
   received CAT messages for the connection. A KA message MUST be
   generated randomly between 1/4 and 3/4 of this minimum KA timer
   interval. When the PDP receives a keep-alive message from a PEP, it
   MUST echo a keep-alive back to the PEP. This message provides
   validation for each side that the connection is still functioning
   even when there is no other messaging.

   Note: The client-type in the header MUST always be set to 0 as the KA
   is used for connection verification (not per client session
   verification).

               &lt;Keep-Alive&gt;  ::= &lt;Common Header&gt;
                                 [&lt;Integrity&gt;]




<span class="grey">Durham, et al.              Standards Track                    [Page 28]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-29" id="page-29" name="page-29"> </a>
<span class="grey"><a href="rfc2748.html">RFC 2748</a>                          COPS                      January 2000</span>


   Both client and server MAY assume the TCP connection is insufficient
   for the client-type with the minimum time value (specified in the CAT
   message) if no communication activity is detected for a period
   exceeding the timer period. For the PEP, such detection implies the
   remote PDP or connection is down and the PEP SHOULD now attempt to
   use an alternative/backup PDP.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.10%20Synchronize%20State%20Complete%20%28SSC%29%20PEP%20-%3E%20PDP"></a><a class="selflink" href="#section-3.10" name="section-3.10">3.10</a> Synchronize State Complete (SSC) PEP -&gt; PDP</span>

   The Synchronize State Complete is sent by the PEP to the PDP after
   the PDP sends a synchronize state request to the PEP and the PEP has
   finished synchronization. It is useful so that the PDP will know when
   all the old client state has been successfully re-requested and,
   thus, the PEP and PDP are completely synchronized. The Client Handle
   object only needs to be included if the corresponding Synchronize
   State Message originally referenced a specific handle.

         &lt;Synchronize State Complete&gt;  ::= &lt;Common Header&gt;
                                           [&lt;Client Handle&gt;]
                                           [&lt;Integrity&gt;]

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/4.%20Common%20Operation"></a><a class="selflink" href="#section-4" name="section-4">4</a>. Common Operation</span>

   This section describes the typical exchanges between remote PDP
   servers and PEP clients.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.1%20Security%20and%20Sequence%20Number%20Negotiation"></a><a class="selflink" href="#section-4.1" name="section-4.1">4.1</a> Security and Sequence Number Negotiation</span>

   COPS message security is negotiated once per connection and covers
   all communication over a particular connection. If COPS level
   security is required, it MUST be negotiated during the initial
   Client-Open/Client-Accept message exchange specifying a Client-Type
   of zero (which is reserved for connection level security negotiation
   and connection verification).

   If a PEP is not configured to use COPS security with a PDP it will
   simply send the PDP Client-Open messages for the supported Client-
   Types as specified in <a href="#section-4.3">section 4.3</a> and will not include the Integrity
   object in any COPS messages.

   Otherwise, security can be initiated by the PEP if it sends the PDP a
   Client-Open message with Client-Type=0 before opening any other
   Client-Type. If the PDP receives a Client-Open with a Client-Type=0
   after another Client-Type has already been opened successfully it
   MUST return a Client-Close message (for Client-Type=0) to that PEP.
   This first Client-Open message MUST specify a Client-Type of zero and
   MUST provide the PEPID and a COPS Integrity object. This Integrity
   object will contain the initial sequence number the PEP requires the



<span class="grey">Durham, et al.              Standards Track                    [Page 29]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-30" id="page-30" name="page-30"> </a>
<span class="grey"><a href="rfc2748.html">RFC 2748</a>                          COPS                      January 2000</span>


   PDP to increment during subsequent communication after the initial
   Client-Open/Client-Accept exchange and the Key ID identifying the
   algorithm and key used to compute the digest.

   Similarly, if the PDP accepts the PEP's security key and algorithm by
   validating the message digest using the identified key, the PDP MUST
   send a Client-Accept message with a Client-Type of zero to the PEP
   carrying an Integrity object. This Integrity object will contain the
   initial sequence number the PDP requires the PEP to increment during
   all subsequent communication with the PDP and the Key ID identifying
   the key and algorithm used to compute the digest.

   If the PEP, from the perspective of a PDP that requires security,
   fails or never performs the security negotiation by not sending an
   initial Client-Open message with a Client-Type=0 including a valid
   Integrity object, the PDP MUST send to the PEP a Client-Close message
   with a Client-Type=0 specifying the appropriate error code.
   Similarly, if the PDP, from the perspective of a PEP that requires
   security, fails the security negotiation by not sending back a
   Client-Accept message with a Client-Type=0 including a valid
   Integrity object, the PEP MUST send to the PDP a Client-Close message
   with a Client-Type=0 specifying the appropriate error code.  Such a
   Client-Close message need not carry an integrity object (as the
   security negotiation did not yet complete).

   The security initialization can fail for one of several reasons: 1.
   The side receiving the message requires COPS level security but an
   Integrity object was not provided (Authentication Required error
   code). 2. A COPS Integrity object was provided, but with an
   unknown/unacceptable C-Type (Unknown COPS Object error code
   specifying the unsupported C-Num and C-Type). 3. The message digest
   or Key ID in the provided Integrity object was incorrect and
   therefore the message could not be authenticated using the identified
   key (Authentication Failure error code).

   Once the initial security negotiation is complete, the PEP will know
   what sequence numbers the PDP expects and the PDP will know what
   sequence numbers the PEP expects. ALL COPS messages must then include
   the negotiated Integrity object specifying the correct sequence
   number with the appropriate message digest (including the Client-
   Open/Client-Accept messages for specific Client-Types). ALL
   subsequent messages from the PDP to the PEP MUST result in an
   increment of the sequence number provided by the PEP in the Integrity
   object of the initial Client-Open message. Likewise, ALL subsequent
   messages from the PEP to the PDP MUST result in an increment of the
   sequence number provided by the PDP in the Integrity object of the
   initial Client-Accept message. Sequence numbers are incremented by
   one starting with the corresponding initial sequence number. For



<span class="grey">Durham, et al.              Standards Track                    [Page 30]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-31" id="page-31" name="page-31"> </a>
<span class="grey"><a href="rfc2748.html">RFC 2748</a>                          COPS                      January 2000</span>


   example, if the sequence number specified to the PEP by the PDP in
   the initial Client-Accept was 10, the next message the PEP sends to
   the PDP will provide an Integrity object with a sequence number of
   11... Then the next message the PEP sends to the PDP will have a
   sequence number of 12 and so on. If any subsequent received message
   contains the wrong sequence number, an unknown Key ID, an invalid
   message digest, or is missing an Integrity object after integrity was
   negotiated, then a Client-Close message MUST be generated for the
   Client-Type zero containing a valid Integrity object and specifying
   the appropriate error code.  The connection should then be dropped.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.2%20Key%20Maintenance"></a><a class="selflink" href="#section-4.2" name="section-4.2">4.2</a> Key Maintenance</span>

   Key maintenance is outside the scope of this document, but COPS
   implementations MUST at least provide the ability to manually
   configure keys and their parameters locally. The key used to produce
   the Integrity object's message digest is identified by the Key ID
   field. Thus, a Key ID parameter is used to identify one of
   potentially multiple simultaneous keys shared by the PEP and PDP. A
   Key ID is relative to a particular PEPID on the PDP or to a
   particular PDP on the PEP. Each key must also be configured with
   lifetime parameters for the time period within which it is valid as
   well as an associated cryptographic algorithm parameter specifying
   the algorithm to be used with the key. At a minimum, all COPS
   implementations MUST support the HMAC-MD5-96 [<a href="#ref-HMAC" title='"HMAC: Keyed-Hashing for Message Authentication"'>HMAC</a>][MD5]
   cryptographic algorithm for computing a message digest for inclusion
   in the Keyed Message Digest of the Integrity object which is appended
   to the message.

   It is good practice to regularly change keys. Keys MUST be
   configurable such that their lifetimes overlap allowing smooth
   transitions between keys. At the midpoint of the lifetime overlap
   between two keys, senders should transition from using the current
   key to the next/longer-lived key. Meanwhile, receivers simply accept
   any identified key received within its configured lifetime and reject
   those that are not.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.3%20PEP%20Initialization"></a><a class="selflink" href="#section-4.3" name="section-4.3">4.3</a> PEP Initialization</span>

   Sometime after a connection is established between the PEP and a
   remote PDP and after security is negotiated (if required), the PEP
   will send one or more Client-Open messages to the remote PDP, one for
   each client-type supported by the PEP. The Client-Open message MUST
   contain the address of the last PDP with which the PEP is still
   caching a complete set of decisions. If no decisions are being cached
   from the previous PDP the LastPDPAddr object MUST NOT be included in
   the Client-Open message (see <a href="#section-2.5">Section 2.5</a>). Each Client-Open message
   MUST at least contain the common header noting one client-type



<span class="grey">Durham, et al.              Standards Track                    [Page 31]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-32" id="page-32" name="page-32"> </a>
<span class="grey"><a href="rfc2748.html">RFC 2748</a>                          COPS                      January 2000</span>


   supported by the PEP. The remote PDP will then respond with separate
   Client-Accept messages for each of the client-types requested by the
   PEP that the PDP can also support.

   If a specific client-type is not supported by the PDP, the PDP will
   instead respond with a Client-Close specifying the client-type is not
   supported and will possibly suggest an alternate PDP address and
   port. Otherwise, the PDP will send a Client-Accept specifying the
   timer interval between keep-alive messages and the PEP may begin
   issuing requests to the PDP.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.4%20Outsourcing%20Operations"></a><a class="selflink" href="#section-4.4" name="section-4.4">4.4</a> Outsourcing Operations</span>

   In the outsourcing scenario, when the PEP receives an event that
   requires a new policy decision it sends a request message to the
   remote PDP. What specifically qualifies as an event for a particular
   client-type SHOULD be specified in the specific document for that
   client-type. The remote PDP then makes a decision and sends a
   decision message back to the PEP. Since the request is stateful, the
   request will be remembered, or installed, on the remote PDP. The
   unique handle (unique per TCP connection and client-type), specified
   in both the request and its corresponding decision identifies this
   request state. The PEP is responsible for deleting this request state
   once the request is no longer applicable.

   The PEP can update a previously installed request state by reissuing
   a request for the previously installed handle. The remote PDP is then
   expected to make new decisions and send a decision message back to
   the PEP. Likewise, the server MAY change a previously issued decision
   on any currently installed request state at any time by issuing an
   unsolicited decision message. At all times the PEP module is expected
   to abide by the PDP's decisions and notify the PDP of any state
   changes.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.5%20Configuration%20Operations"></a><a class="selflink" href="#section-4.5" name="section-4.5">4.5</a> Configuration Operations</span>

   In the configuration scenario, as in the outsourcing scenario, the
   PEP will make a configuration request to the PDP for a particular
   interface, module, or functionality that may be specified in the
   named client specific information object. The PDP will then send
   potentially several decisions containing named units of configuration
   data to the PEP. The PEP is expected to install and use the
   configuration locally. A particular named configuration can be
   updated by simply sending additional decision messages for the same
   named configuration. When the PDP no longer wishes the PEP to use a
   piece of configuration information, it will send a decision message
   specifying the named configuration and a decision flags object with




<span class="grey">Durham, et al.              Standards Track                    [Page 32]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-33" id="page-33" name="page-33"> </a>
<span class="grey"><a href="rfc2748.html">RFC 2748</a>                          COPS                      January 2000</span>


   the remove configuration command. The PEP SHOULD then proceed to
   remove the corresponding configuration and send a report message to
   the PDP that specifies it has been deleted.

   In all cases, the PEP MAY notify the remote PDP of the local status
   of an installed state using the report message where appropriate.
   The report message is to be used to signify when billing can begin,
   what actions were taken, or to produce periodic updates for
   monitoring and accounting purposes depending on the client. This
   message can carry client specific information when needed.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.6%20Keep-Alive%20Operations"></a><a class="selflink" href="#section-4.6" name="section-4.6">4.6</a> Keep-Alive Operations</span>

   The Keep-Alive message is used to validate the connection between the
   client and server is still functioning even when there is no other
   messaging from the PEP to PDP. The PEP MUST generate a COPS KA
   message randomly within one-fourth to three-fourths the minimum KA
   Timer interval specified by the PDP in the Client-Accept message. On
   receiving a Keep-Alive message from the PEP, the PDP MUST then
   respond to this Keep-Alive message by echoing a Keep-Alive message
   back to the PEP. If either side does not receive a Keep-Alive or any
   other COPS message within the minimum KA Timer interval from the
   other, the connection SHOULD be considered lost.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.7%20PEP%2FPDP%20Close"></a><a class="selflink" href="#section-4.7" name="section-4.7">4.7</a> PEP/PDP Close</span>

   Finally, Client-Close messages are used to negate the effects of the
   corresponding Client-Open messages, notifying the other side that the
   specified client-type is no longer supported/active. When the PEP
   detects a lost connection due to a keep-alive timeout condition it
   SHOULD explicitly send a Client-Close message for each opened
   client-type specifying a communications failure error code. Then the
   PEP MAY proceed to terminate the connection to the PDP and attempt to
   reconnect again or try a backup/alternative PDP. When the PDP is
   shutting down, it SHOULD also explicitly send a Client-Close to all
   connected PEPs for each client-type, perhaps specifying an
   alternative PDP to use instead.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/5.%20Security%20Considerations"></a><a class="selflink" href="#section-5" name="section-5">5</a>. Security Considerations</span>

   The COPS protocol provides an Integrity object that can achieve
   authentication, message integrity, and replay prevention. All COPS
   implementations MUST support the COPS Integrity object and its
   mechanisms as described in this document. To ensure the client (PEP)
   is communicating with the correct policy server (PDP) requires
   authentication of the PEP and PDP using a shared secret, and
   consistent proof that the connection remains valid. The shared secret
   minimally requires manual configuration of keys (identified by a Key



<span class="grey">Durham, et al.              Standards Track                    [Page 33]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-34" id="page-34" name="page-34"> </a>
<span class="grey"><a href="rfc2748.html">RFC 2748</a>                          COPS                      January 2000</span>


   ID) shared between the PEP and its PDP. The key is used in
   conjunction with the contents of a COPS message to calculate a
   message digest that is part of the Integrity object. The Integrity
   object is then used to validate all COPS messages sent over the TCP
   connection between a PEP and PDP.

   Key maintenance is outside the scope of this document beyond the
   specific requirements discussed in <a href="#section-4.2">section 4.2</a>. In general, it is
   good practice to regularly change keys to maintain security.
   Furthermore, it is good practice to use localized keys specific to a
   particular PEP such that a stolen PEP will not compromise the
   security of an entire administrative domain.

   The COPS Integrity object also provides sequence numbers to avoid
   replay attacks. The PDP chooses the initial sequence number for the
   PEP and the PEP chooses the initial sequence number for the PDP.
   These initial numbers are then incremented with each successive
   message sent over the connection in the corresponding direction. The
   initial sequence numbers SHOULD be chosen such that they are
   monotonically increasing and never repeat for a particular key.

   Security between the client (PEP) and server (PDP) MAY be provided by
   IP Security [<a href="#ref-IPSEC" title='"Security Architecture for the Internet Protocol"'>IPSEC</a>]. In this case, the IPSEC Authentication Header
   (AH) SHOULD be used for the validation of the connection;
   additionally IPSEC Encapsulation Security Payload (ESP) MAY be used
   to provide both validation and secrecy.

   Transport Layer Security [<a href="#ref-TLS" title='"The TLS Protocol Version 1.0"'>TLS</a>] MAY be used for both connection-level
   validation and privacy.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/6.%20IANA%20Considerations"></a><a class="selflink" href="#section-6" name="section-6">6</a>. IANA Considerations</span>

   The Client-type identifies the policy client application to which a
   message refers. Client-type values within the range 0x0001-0x3FFF are
   reserved Specification Required status as defined in [IANA-
   CONSIDERATIONS]. These values MUST be registered with IANA and their
   behavior and applicability MUST be described in a COPS extension
   document.

   Client-type values in the range 0x4000 - 0x7FFF are reserved for
   Private Use as defined in [<a href="#ref-IANA-CONSIDERATIONS" title='"Guidelines for Writing an IANA Considerations Section in RFCs"'>IANA-CONSIDERATIONS</a>]. These Client-types
   are not tracked by IANA and are not to be used in standards or
   general-release products, as their uniqueness cannot be assured.

   Client-type values in the range 0x8000 - 0xFFFF are First Come First
   Served as defined in [<a href="#ref-IANA-CONSIDERATIONS" title='"Guidelines for Writing an IANA Considerations Section in RFCs"'>IANA-CONSIDERATIONS</a>]. These Client-types are
   tracked by IANA but do not require published documents describing
   their use. IANA merely assures their uniqueness.



<span class="grey">Durham, et al.              Standards Track                    [Page 34]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-35" id="page-35" name="page-35"> </a>
<span class="grey"><a href="rfc2748.html">RFC 2748</a>                          COPS                      January 2000</span>


   Objects in the COPS Protocol are identified by their C-Num and C-Type
   values. IETF Consensus as identified in [<a href="#ref-IANA-CONSIDERATIONS" title='"Guidelines for Writing an IANA Considerations Section in RFCs"'>IANA-CONSIDERATIONS</a>] is
   required to introduce new values for these numbers and, therefore,
   new objects into the base COPS protocol.

   Additional Context Object R-Types, Reason-Codes, Report-Types,
   Decision Object Command-Codes/Flags, and Error-Codes MAY be defined
   for use with future Client-types, but such additions require IETF
   Consensus as defined in [<a href="#ref-IANA-CONSIDERATIONS" title='"Guidelines for Writing an IANA Considerations Section in RFCs"'>IANA-CONSIDERATIONS</a>].

   Context Object M-Types, Reason Sub-Codes, and Error Sub-codes MAY be
   defined relative to a particular Client-type following the same IANA
   considerations as their respective Client-type.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/7.%20References"></a><a class="selflink" href="#section-7" name="section-7">7</a>. References</span>

   [<a id="ref-RSVP" name="ref-RSVP">RSVP</a>]                Braden, R., Zhang, L., Berson, S., Herzog, S.
                         and S. Jamin, "Resource ReSerVation Protocol
                         (RSVP) Version 1 - Functional Specification",
                         <a href="rfc2205.html">RFC 2205</a>, September 1997.

   [<a id="ref-WRK" name="ref-WRK">WRK</a>]                 Yavatkar, R., Pendarakis, D. and R. Guerin, "A
                         Framework for Policy-Based Admission Control",
                         <a href="rfc2753.html">RFC 2753</a>, January 2000.

   [<a id="ref-SRVLOC" name="ref-SRVLOC">SRVLOC</a>]              Guttman, E., Perkins, C., Veizades, J. and M.
                         Day, "Service Location Protocol , Version 2",
                         <a href="rfc2608.html">RFC 2608</a>, June 1999.

   [<a id="ref-INSCH" name="ref-INSCH">INSCH</a>]               Shenker, S. and  J. Wroclawski, "General
                         Characterization Parameters for Integrated
                         Service Network Elements", <a href="rfc2215.html">RFC 2215</a>, September
                         1997.

   [<a id="ref-IPSEC" name="ref-IPSEC">IPSEC</a>]               Atkinson, R., "Security Architecture for the
                         Internet Protocol", <a href="rfc2401.html">RFC 2401</a>, August 1995.

   [<a id="ref-HMAC" name="ref-HMAC">HMAC</a>]                Krawczyk, H., Bellare, M. and R. Canetti,
                         "HMAC: Keyed-Hashing for Message
                         Authentication", <a href="rfc2104.html">RFC 2104</a>, February 1997.

   [<a id="ref-MD5" name="ref-MD5">MD5</a>]                 Rivest, R., "The MD5 Message-Digest Algorithm",
                         <a href="rfc1321.html">RFC 1321</a>, April 1992.

   [<a id="ref-RSVPPR" name="ref-RSVPPR">RSVPPR</a>]              Braden, R. and L. Zhang, "Resource ReSerVation
                         Protocol (RSVP) - Version 1 Message Processing
                         Rules", <a href="rfc2209.html">RFC 2209</a>, September 1997.




<span class="grey">Durham, et al.              Standards Track                    [Page 35]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-36" id="page-36" name="page-36"> </a>
<span class="grey"><a href="rfc2748.html">RFC 2748</a>                          COPS                      January 2000</span>


   [<a id="ref-TLS" name="ref-TLS">TLS</a>]                 Dierks T. and C. Allen, "The TLS Protocol
                         Version 1.0", <a href="rfc2246.html">RFC 2246</a>, January 1999.

   [<a id="ref-IANA" name="ref-IANA">IANA</a>]                <a href="http://www.isi.edu/in-notes/iana/assignments/port-numbers">http://www.isi.edu/in-</a>
                         <a href="http://www.isi.edu/in-notes/iana/assignments/port-numbers">notes/iana/assignments/port-numbers</a>

   [<a id="ref-IANA-CONSIDERATIONS" name="ref-IANA-CONSIDERATIONS">IANA-CONSIDERATIONS</a>] Alvestrand, H. and T. Narten, "Guidelines for
                         Writing an IANA Considerations Section in
                         RFCs", <a href="https://tools.ietf.org/html/bcp26">BCP 26</a>, <a href="rfc2434.html">RFC 2434</a>, October 1998.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/8.%20Author%20Information%20and%20Acknowledgments"></a><a class="selflink" href="#section-8" name="section-8">8</a>. Author Information and Acknowledgments</span>

   Special thanks to Andrew Smith and Timothy O'Malley our WG Chairs,
   Raj Yavatkar, Russell Fenger, Fred Baker, Laura Cunningham, Roch
   Guerin, Ping Pan, and Dimitrios Pendarakis for their valuable
   contributions.

   Jim Boyle
   Level 3 Communications
   1025 Eldorado Boulevard
   Broomfield, CO 80021

   Phone: 720.888.1192
   EMail: jboyle@Level3.net


   Ron Cohen
   CISCO Systems
   4 Maskit St.
   Herzeliya Pituach 46766 Israel

   Phone: +972.9.9700064
   EMail: ronc@cisco.com


   David Durham
   Intel
   2111 NE 25th Avenue
   Hillsboro, OR 97124

   Phone: 503.264.6232
   EMail: David.Durham@intel.com









<span class="grey">Durham, et al.              Standards Track                    [Page 36]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-37" id="page-37" name="page-37"> </a>
<span class="grey"><a href="rfc2748.html">RFC 2748</a>                          COPS                      January 2000</span>


   Raju Rajan
   AT&amp;T Shannon Laboratory
   180 Park Avenue
   P.O. Box 971
   Florham Park, NJ 07932-0971

   EMail: rajan@research.att.com

   Shai Herzog
   IPHighway, Inc.
   55 New York Avenue
   Framingham, MA 01701

   Phone: 508.620.1141
   EMail: herzog@iphighway.com


   Arun Sastry
   Cisco Systems
   4 The Square
   Stockley Park
   Uxbridge, Middlesex UB11 1BN
   UK

   Phone: +44-208-756-8693
   EMail: asastry@cisco.com

























<span class="grey">Durham, et al.              Standards Track                    [Page 37]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-38" id="page-38" name="page-38"> </a>
<span class="grey"><a href="rfc2748.html">RFC 2748</a>                          COPS                      January 2000</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/9.%20%20Full%20Copyright%20Statement"></a><a class="selflink" href="#section-9" name="section-9">9</a>.  Full Copyright Statement</span>

   Copyright (C) The Internet Society (2000).  All Rights Reserved.

   This document and translations of it may be copied and furnished to
   others, and derivative works that comment on or otherwise explain it
   or assist in its implementation may be prepared, copied, published
   and distributed, in whole or in part, without restriction of any
   kind, provided that the above copyright notice and this paragraph are
   included on all such copies and derivative works.  However, this
   document itself may not be modified in any way, such as by removing
   the copyright notice or references to the Internet Society or other
   Internet organizations, except as needed for the purpose of
   developing Internet standards in which case the procedures for
   copyrights defined in the Internet Standards process must be
   followed, or as required to translate it into languages other than
   English.

   The limited permissions granted above are perpetual and will not be
   revoked by the Internet Society or its successors or assigns.

   This document and the information contained herein is provided on an
   "AS IS" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING
   TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING
   BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION
   HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF
   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.

Acknowledgement

   Funding for the RFC Editor function is currently provided by the
   Internet Society.



















Durham, et al.              Standards Track                    [Page 38]

</pre><br/>
    <span class="noprint"><small><small>Html markup produced by rfcmarkup 1.126, available from
      <a href="https://tools.ietf.org/tools/rfcmarkup/">https://tools.ietf.org/tools/rfcmarkup/</a>
    </small></small></span>
  </div>




</body><!-- Mirrored from tools.ietf.org/html/rfc2748 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 06 Mar 2018 23:18:51 GMT --></html>