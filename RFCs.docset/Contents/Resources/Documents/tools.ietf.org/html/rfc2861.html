<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml"><!-- Mirrored from tools.ietf.org/html/rfc2861 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 06 Mar 2018 23:18:50 GMT --><!-- Added by HTTrack --><head><meta content="text/html;charset=utf-8" http-equiv="content-type"/><!-- /Added by HTTrack -->

    <meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
    <meta content="index,follow" name="robots"/>
    <meta content="rfcmarkup version 1.126" name="creator"/>
    <link href="http://purl.org/dc/elements/1.1/" rel="schema.DC"/>
<meta content="urn:ietf:rfc:2861" name="DC.Identifier"/>
<meta content="This document describes a simple modification to TCP's congestion
control algorithms to decay the congestion window cwnd after the
transition from a sufficiently-long application-limited period, while
using the slow-start threshold ssthresh to save information about the
previous value of the congestion window. This memo defines an
Experimental Protocol for the Internet community." name="DC.Description.Abstract"/>
<meta content="Floyd, Sally" name="DC.Creator"/>
<meta content="Padhye, Jitendra" name="DC.Creator"/>
<meta content="Handley, Mark" name="DC.Creator"/>
<meta content="June, 2000" name="DC.Date.Issued"/>
<meta content="TCP Congestion Window Validation" name="DC.Title"/>

    <link href="https://tools.ietf.org/images/rfc.png" rel="icon" type="image/png"/>
    <link href="https://tools.ietf.org/images/rfc.png" rel="shortcut icon" type="image/png"/>
    <title>RFC 2861 - TCP Congestion Window Validation</title>
    
    
    <style type="text/css">
	@media only screen 
	  and (min-width: 992px)
	  and (max-width: 1199px) {
	    body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 768px)
	  and (max-width: 991px) {
            body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 480px)
	  and (max-width: 767px) {
            body { font-size: 11pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (max-width: 479px) {
            body { font-size: 8pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-device-width : 375px) 
	  and (max-device-width : 667px) {
            body { font-size: 9.5pt; }
            div.content { width: 96ex; margin: 0 1px; }
        }
	@media only screen 
	  and (min-device-width: 1200px) {
            body { font-size: 10pt; margin: 0 4em; }
            div.content { width: 96ex; margin: 0; }
        }
        h1, h2, h3, h4, h5, h6, .h1, .h2, .h3, .h4, .h5, .h6 {
	    font-weight: bold;
            line-height: 0pt;
            display: inline;
            white-space: pre;
            font-family: monospace;
            font-size: 1em;
	    font-weight: bold;
        }
        pre {
            font-size: 1em;
            margin-top: 0px;
            margin-bottom: 0px;
        }
	.pre {
	    white-space: pre;
	    font-family: monospace;
	}
	.header{
	    font-weight: bold;
	}
        .newpage {
            page-break-before: always;
        }
        .invisible {
            text-decoration: none;
            color: white;
        }
        a.selflink {
          color: black;
          text-decoration: none;
        }
        @media print {
            body {
                font-family: monospace;
                font-size: 10.5pt;
            }
            h1, h2, h3, h4, h5, h6 {
                font-size: 1em;
            }
        
            a:link, a:visited {
                color: inherit;
                text-decoration: none;
            }
            .noprint {
                display: none;
            }
        }
	@media screen {
	    .grey, .grey a:link, .grey a:visited {
		color: #777;
	    }
            .docinfo {
                background-color: #EEE;
            }
            .top {
                border-top: 7px solid #EEE;
            }
            .bgwhite  { background-color: white; }
            .bgred    { background-color: #F44; }
            .bggrey   { background-color: #666; }
            .bgbrown  { background-color: #840; }            
            .bgorange { background-color: #FA0; }
            .bgyellow { background-color: #EE0; }
            .bgmagenta{ background-color: #F4F; }
            .bgblue   { background-color: #66F; }
            .bgcyan   { background-color: #4DD; }
            .bggreen  { background-color: #4F4; }

            .legend   { font-size: 90%; }
            .cplate   { font-size: 70%; border: solid grey 1px; }
	}
    </style>
    <!--[if IE]>
    <style>
    body {
       font-size: 13px;
       margin: 10px 10px;
    }
    </style>
    <![endif]-->

    <script type="text/javascript"><!--
    function addHeaderTags() {
	var spans = document.getElementsByTagName("span");
	for (var i=0; i < spans.length; i++) {
	    var elem = spans[i];
	    if (elem) {
		var level = elem.getAttribute("class");
                if (level == "h1" || level == "h2" || level == "h3" || level == "h4" || level == "h5" || level == "h6") {
                    elem.innerHTML = "<"+level+">"+elem.innerHTML+"</"+level+">";		
                }
	    }
	}
    }
    var legend_html = "Colour legend:<br />      <table>         <tr><td>Unknown:</td>                   <td><span class='cplate bgwhite'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft:</td>                     <td><span class='cplate bgred'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Informational:</td>             <td><span class='cplate bgorange'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Experimental:</td>              <td><span class='cplate bgyellow'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Best Common Practice:</td>      <td><span class='cplate bgmagenta'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Proposed Standard:</td>         <td><span class='cplate bgblue'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft Standard (old designation):</td> <td><span class='cplate bgcyan'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Internet Standard:</td>         <td><span class='cplate bggreen'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Historic:</td>                  <td><span class='cplate bggrey'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Obsolete:</td>                  <td><span class='cplate bgbrown'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>     </table>";
    function showElem(id) {
        var elem = document.getElementById(id);
        elem.innerHTML = eval(id+"_html");
        elem.style.visibility='visible';
    }
    function hideElem(id) {
        var elem = document.getElementById(id);
        elem.style.visibility='hidden';        
        elem.innerHTML = "";
    }
    // -->
    </script>
</head>
<body onload="addHeaderTags()">
  <div class="content">
   <div style="height: 13px;">
      <div class="pre noprint docinfo bgbrown" onclick="showElem('legend');" onmouseout="hideElem('legend')" onmouseover="this.style.cursor='pointer';" style="height: 6px; position: absolute;" title="Click for colour legend.">                                                                        </div>
      <div class="docinfo noprint pre legend" id="legend" onmouseout="hideElem('legend');" onmouseover="showElem('legend');" style="position:absolute; top: 4px; left: 4ex; visibility:hidden; background-color: white; padding: 4px 9px 5px 7px; border: solid #345 1px; ">
      </div>
   </div>
<span class="pre noprint docinfo top">[<a href="index.html" title="Document search and retrieval page">Docs</a>] [<a href="https://tools.ietf.org/rfc/rfc2861.txt" title="Plaintext version of this document">txt</a>|<a href="https://tools.ietf.org/pdf/rfc2861" title="PDF version of this document">pdf</a>] [<a href="https://tools.ietf.org/html/draft-handley-tcp-cwv" title="draft-handley-tcp-cwv">draft-handley-t...</a>] [<a href="https://datatracker.ietf.org/doc/rfc2861" title="IESG Datatracker information for this document">Tracker</a>] [<a href="https://tools.ietf.org/rfcdiff?difftype=--hwdiff&amp;url2=rfc2861" title="Inline diff (wdiff)">Diff1</a>] [<a href="https://tools.ietf.org/rfcdiff?url2=rfc2861" title="Side-by-side diff">Diff2</a>] [<a href="https://www.rfc-editor.org/errata_search.php?rfc=2861">Errata</a>]</span><br/>
<span class="pre noprint docinfo">                                                                        </span><br/>
<span class="pre noprint docinfo">Obsoleted by: <a href="rfc7661.html">7661</a>                                              HISTORIC</span><br/>
<span class="pre noprint docinfo">                                                            <span style="color: #C00;">Errata Exist</span></span><br/>
<pre>Network Working Group                                         M. Handley
Request for Comments: 2861                                     J. Padhye
Category: Experimental                                          S. Floyd
                                                                   ACIRI
                                                               June 2000


                    <span class="h1">TCP Congestion Window Validation</span>

Status of this Memo

   This memo defines an Experimental Protocol for the Internet
   community.  It does not specify an Internet standard of any kind.
   Discussion and suggestions for improvement are requested.
   Distribution of this memo is unlimited.

Copyright Notice

   Copyright (C) The Internet Society (2000).  All Rights Reserved.

Abstract

   TCP's congestion window controls the number of packets a TCP flow may
   have in the network at any time.  However, long periods when the
   sender is idle or application-limited can lead to the invalidation of
   the congestion window, in that the congestion window no longer
   reflects current information about the state of the network.  This
   document describes a simple modification to TCP's congestion control
   algorithms to decay the congestion window cwnd after the transition
   from a sufficiently-long application-limited period, while using the
   slow-start threshold ssthresh to save information about the previous
   value of the congestion window.

   An invalid congestion window also results when the congestion window
   is increased (i.e., in TCP's slow-start or congestion avoidance
   phases) during application-limited periods, when the previous value
   of the congestion window might never have been fully utilized.  We
   propose that the TCP sender should not increase the congestion window
   when the TCP sender has been application-limited (and therefore has
   not fully used the current congestion window).  We have explored
   these algorithms both with simulations and with experiments from an
   implementation in FreeBSD.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/1.%20%20Conventions%20and%20Acronyms"></a><a class="selflink" href="#section-1" name="section-1">1</a>.  Conventions and Acronyms</span>

   The keywords MUST, MUST NOT, REQUIRED, SHALL, SHALL NOT, SHOULD,
   SHOULD NOT, RECOMMENDED, MAY, and OPTIONAL, when they appear in this
   document, are to be interpreted as described in [B97].



<span class="grey">Handley, et al.               Experimental                      [Page 1]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-2" id="page-2" name="page-2"> </a>
<span class="grey"><a href="rfc2861.html">RFC 2861</a>            TCP Congestion Window Validation           June 2000</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/2.%20Introduction"></a><a class="selflink" href="#section-2" name="section-2">2</a>. Introduction</span>

   TCP's congestion window controls the number of packets a TCP flow may
   have in the network at any time.  The congestion window is set using
   an Additive-Increase, Multiplicative-Decrease (AIMD) mechanism that
   probes for available bandwidth, dynamically adapting to changing
   network conditions.  This AIMD mechanism works well when the sender
   continually has data to send, as is typically the case for TCP used
   for bulk-data transfer.  In contrast, for TCP used with telnet
   applications, the data sender often has little or no data to send,
   and the sending rate is often determined by the rate at which data is
   generated by the user.  With the advent of the web, including
   developments such as TCP senders with dynamically-created data and
   HTTP 1.1 with persistent-connection TCP, the interaction between
   application-limited periods (when the sender sends less than is
   allowed by the congestion or receiver windows) and network-limited
   periods (when the sender is limited by the TCP window) becomes
   increasingly important.  More precisely, we define a network-limited
   period as any period when the sender is sending a full window of
   data.

   Long periods when the sender is application-limited can lead to the
   invalidation of the congestion window.  During periods when the TCP
   sender is network-limited, the value of the congestion window is
   repeatedly "revalidated" by the successful transmission of a window
   of data without loss.  When the TCP sender is network-limited, there
   is an incoming stream of acknowledgements that "clocks out" new data,
   giving concrete evidence of recent available bandwidth in the
   network.  In contrast, during periods when the TCP sender is
   application-limited, the estimate of available capacity represented
   by the congestion window may become steadily less accurate over time.
   In particular, capacity that had once been used by the network-
   limited connection might now be used by other traffic.

   Current TCP implementations have a range of behaviors for starting up
   after an idle period.  Some current TCP implementations slow-start
   after an idle period longer than the RTO estimate, as suggested in
   [<a href="rfc2581.html" title="V. and W. Stevens">RFC2581</a>] and in the appendix of [VJ88], while other implementations
   don't reduce their congestion window after an idle period.  <a href="rfc2581.html">RFC 2581</a>
   [<a href="rfc2581.html" title="V. and W. Stevens">RFC2581</a>] recommends the following: "a TCP SHOULD set cwnd to no more
   than RW [the initial window] before beginning transmission if the TCP
   has not sent data in an interval exceeding the retransmission
   timeout."  A proposal for TCP's slow-start after idle has also been
   discussed in [<a href="#ref-HTH98" title='"Issues in TCP Slow-Start Restart After Idle"'>HTH98</a>].  The issue of validation of congestion
   information during idle periods has also been addressed in contexts
   other than TCP and IP, for example in "Use-it or Lose-it" mechanisms
   for ATM networks [J96,J95].




<span class="grey">Handley, et al.               Experimental                      [Page 2]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-3" id="page-3" name="page-3"> </a>
<span class="grey"><a href="rfc2861.html">RFC 2861</a>            TCP Congestion Window Validation           June 2000</span>


   To address the revalidation of the congestion window after a
   application-limited period, we propose a simple modification to TCP's
   congestion control algorithms to decay the congestion window cwnd
   after the transition from a sufficiently-long application-limited
   period (i.e., at least one roundtrip time) to a network-limited
   period.  In particular, we propose that after an idle period, the TCP
   sender should reduce its congestion window by half for every RTT that
   the flow has remained idle.

   When the congestion window is reduced, the slow-start threshold
   ssthresh remains as "memory" of the recent congestion window.
   Specifically, ssthresh is never decreased when cwnd is reduced after
   an application-limited period; before cwnd is reduced, ssthresh is
   set to the maximum of its current value, and half-way between the old
   and the new values of cwnd.  This use of ssthresh allows a TCP sender
   increasing its sending rate after an application-limited period to
   quickly slow-start to recover most of the previous value of the
   congestion window.  To be more precise, if ssthresh is less than 3/4
   cwnd when the congestion window is reduced after an application-
   limited period, then ssthresh is increased to 3/4 cwnd before the
   reduction of the congestion window.

   An invalid congestion window also results when the congestion window
   is increased (i.e., in TCP's slow-start or congestion avoidance
   phases) during application-limited periods, when the previous value
   of the congestion window might never have been fully utilized.  As
   far as we know, all current TCP implementations increase the
   congestion window when an acknowledgement arrives, if allowed by the
   receiver's advertised window and the slow-start or congestion
   avoidance window increase algorithm, without checking to see if the
   previous value of the congestion window has in fact been used.  This
   document proposes that the window increase algorithm not be invoked
   during application-limited periods [<a href="#ref-MSML99" title='"http://www.psc.edu/networking/ftp/papers/draft- ratehalving.txt"'>MSML99</a>].  In particular, the TCP
   sender should not increase the congestion window when the TCP sender
   has been application-limited (and therefore has not fully used the
   current congestion window).  This restriction prevents the congestion
   window from growing arbitrarily large, in the absence of evidence
   that the congestion window can be supported by the network.  From
   [MSML99, <a href="#section-5.2">Section 5.2</a>]: "This restriction assures that [cwnd] only
   grows as long as TCP actually succeeds in injecting enough data into
   the network to test the path."

   A somewhat-orthogonal problem associated with maintaining a large
   congestion window after an application-limited period is that the
   sender, with a sudden large amount of data to send after a quiescent
   period, might immediately send a full congestion window of back-to-
   back packets.  This problem of sending large bursts of packets back-
   to-back can be effectively handled using rate-based pacing (RBP,



<span class="grey">Handley, et al.               Experimental                      [Page 3]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-4" id="page-4" name="page-4"> </a>
<span class="grey"><a href="rfc2861.html">RFC 2861</a>            TCP Congestion Window Validation           June 2000</span>


   [<a href="#ref-VH97" title="November">VH97</a>]), or using a maximum burst size control [<a href="#ref-FF96" title='"http://www.aciri.org/floyd/papers.html"'>FF96</a>].  We would
   contend that, even with mechanisms for limiting the sending of back-
   to-back packets or pacing packets out over the period of a roundtrip
   time, an old congestion window that has not been fully used for some
   time can not be trusted as an indication of the bandwidth currently
   available for that flow.  We would contend that the mechanisms to
   pace out packets allowed by the congestion window are largely
   orthogonal to the algorithms used to determine the appropriate size
   of the congestion window.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/3.%20Description"></a><a class="selflink" href="#section-3" name="section-3">3</a>. Description</span>

   When a TCP sender has sufficient data available to fill the available
   network capacity for that flow, cwnd and ssthresh get set to
   appropriate values for the network conditions.  When a TCP sender
   stops sending, the flow stops sampling the network conditions, and so
   the value of the congestion window may become inaccurate.  We believe
   the correct conservative behavior under these circumstances is to
   decay the congestion window by half for every RTT that the flow
   remains inactive.  The value of half is a very conservative figure
   based on how quickly multiplicative decrease would have decayed the
   window in the presence of loss.

   Another possibility is that the sender may not stop sending, but may
   become application-limited rather than network-limited, and offer
   less data to the network than the congestion window allows to be
   sent.  In this case the TCP flow is still sampling network
   conditions, but is not offering sufficient traffic to be sure that
   there is still sufficient capacity in the network for that flow to
   send a full congestion window.  Under these circumstances we believe
   the correct conservative behavior is for the sender to keep track of
   the maximum amount of the congestion window used during each RTT, and
   to decay the congestion window each RTT to midway between the current
   cwnd value and the maximum value used.

   Before the congestion window is reduced, ssthresh is set to the
   maximum of its current value and 3/4 cwnd.  If the sender then has
   more data to send than the decayed cwnd allows, the TCP will slow-
   start (perform exponential increase) at least half-way back up to the
   old value of cwnd.

   The justification for this value of "3/4 cwnd" is that 3/4 cwnd is a
   conservative estimate of the recent average value of the congestion
   window, and the TCP should safely be able to slow-start at least up
   to this point.  For a TCP in steady-state that has been reducing its
   congestion window each time the congestion window reached some
   maximum value `maxwin', the average congestion window has been 3/4
   maxwin.  On average, when the connection becomes application-limited,



<span class="grey">Handley, et al.               Experimental                      [Page 4]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-5" id="page-5" name="page-5"> </a>
<span class="grey"><a href="rfc2861.html">RFC 2861</a>            TCP Congestion Window Validation           June 2000</span>


   cwnd will be 3/4 maxwin, and in this case cwnd itself represents the
   average value of the congestion window.  However, if the connection
   happens to become application-limited when cwnd equals maxwin, then
   the average value of the congestion window is given by 3/4 cwnd.

   An alternate possibility would be to set ssthresh to the maximum of
   the current value of ssthresh, and the old value of cwnd, allowing
   TCP to slow-start all of the way back up to the old value of cwnd.
   Further experimentation can be used to evaluate these two options for
   setting ssthresh.

   For the separate issue of the increase of the congestion window in
   response to an acknowledgement, we believe the correct behavior is
   for the sender to increase the congestion window only if the window
   was full when the acknowledgment arrived.

   We term this set of modifications to TCP Congestion Window Validation
   (CWV) because they are related to ensuring the congestion window is
   always a valid reflection of the current network state as probed by
   the connection.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.1.%20The%20basic%20algorithm%20for%20reducing%20the%20congestion%20window"></a><a class="selflink" href="#section-3.1" name="section-3.1">3.1</a>. The basic algorithm for reducing the congestion window</span>

   A key issue in the CWV algorithm is to determine how to apply the
   guideline of reducing the congestion window once for every roundtrip
   time that the flow is application-limited.  We use TCP's
   retransmission timer (RTO) as a reasonable upper bound on the
   roundtrip time, and reduce the congestion window roughly once per
   RTO.

   This basic algorithm could be implemented in TCP as follows: When TCP
   sends a new packet it checks to see if more than RTO seconds have
   elapsed since the previous packet was sent.  If RTO has elapsed,
   ssthresh is set to the maximum of 3/4 cwnd and the current value of
   ssthresh, and then the congestion window is halved for every RTO that
   elapsed since the previous packet was sent.  In addition, T_prev is
   set to the current time, and W_used is reset to zero.  T_prev will be
   used to determine the elapsed time since the sender last was network-
   limited or had reduced cwnd after an idle period.  When the sender is
   application-limited, W_used holds the maximum congestion window
   actually used since the sender was last network-limited.

   The mechanism for determining the number of RTOs in the most recent
   idle period could also be implemented by using a timer that expires
   every RTO after the last packet was sent instead of a check per
   packet - efficiency constraints on different operating systems may
   dictate which is more efficient to implement.




<span class="grey">Handley, et al.               Experimental                      [Page 5]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-6" id="page-6" name="page-6"> </a>
<span class="grey"><a href="rfc2861.html">RFC 2861</a>            TCP Congestion Window Validation           June 2000</span>


   After TCP sends a packet, it also checks to see if that packet filled
   the congestion window.  If so, the sender is network-limited, and
   sets the variable T_prev to the current TCP clock time, and the
   variable W_used to zero.

   When TCP sends a packet that does not fill the congestion window, and
   the TCP send queue is empty, then the sender is application-limited.
   The sender checks to see if the amount of unacknowledged data is
   greater than W_used; if so, W_used is set to the amount of
   unacknowledged data.  In addition TCP checks to see if the elapsed
   time since T_prev is greater than RTO.  If so, then the TCP has not
   just reduced its congestion window following an idle period.  The TCP
   has been application-limited rather than network-limited for at least
   an entire RTO interval, but for less than two RTO intervals.  In this
   case, TCP sets ssthresh to the maximum of 3/4 cwnd and the current
   value of ssthresh, and reduces its congestion window to
   (cwnd+W_used)/2.  W_used is then set to zero, and T_prev is set to
   the current time, so a further reduction will not take place until at
   least another RTO period has elapsed.  Thus, during an application-
   limited period the CWV algorithm reduces the congestion window once
   per RTO.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.2.%20%20Pseudo-code%20for%20reducing%20the%20congestion%20window"></a><a class="selflink" href="#section-3.2" name="section-3.2">3.2</a>.  Pseudo-code for reducing the congestion window</span>

   Initially:
       T_last = tcpnow, T_prev = tcpnow, W_used = 0

   After sending a data segment:
       If tcpnow - T_last &gt;= RTO
           (The sender has been idle.)
           ssthresh =  max(ssthresh, 3*cwnd/4)
           For i=1  To (tcpnow - T_last)/RTO
               win =  min(cwnd, receiver's declared max window)
               cwnd =  max(win/2, MSS)
           T_prev = tcpnow
           W_used = 0

       T_last = tcpnow

       If window is full
           T_prev = tcpnow
           W_used = 0
       Else
           If no more data is available to send
               W_used =  max(W_used, amount of unacknowledged data)
               If tcpnow - T_prev &gt;= RTO
                   (The sender has been application-limited.)
                   ssthresh =  max(ssthresh, 3*cwnd/4)



<span class="grey">Handley, et al.               Experimental                      [Page 6]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-7" id="page-7" name="page-7"> </a>
<span class="grey"><a href="rfc2861.html">RFC 2861</a>            TCP Congestion Window Validation           June 2000</span>


                   win =  min(cwnd, receiver's declared max window)
                   cwnd = (win + W_used)/2
                   T_prev = tcpnow
                   W_used = 0

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/4.%20Simulations"></a><a class="selflink" href="#section-4" name="section-4">4</a>. Simulations</span>

   The CWV proposal has been implemented as an option in the network
   simulator NS [<a href="#ref-NS" title='"http://www-mash.cs.berkeley.edu/ns/"'>NS</a>].  The simulations in the validation test suite for
   CWV can be run with the command "./test-all-tcp" in the directory
   "tcl/test".  The simulations show the use of CWV to reduce the
   congestion window after a period when the TCP connection was
   application-limited, and to limit the increase in the congestion
   window when a transfer is application-limited.  As the simulations
   illustrate, the use of ssthresh to maintain connection history is a
   critical part of the Congestion Window Validation algorithm.  [<a href="#ref-HPF99" title='"ftp://www- net.cs.umass.edu/pub/Handley99-tcpq-tr-99-77.ps.gz"'>HPF99</a>]
   discusses these simulations in more detail.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/5.%20Experiments"></a><a class="selflink" href="#section-5" name="section-5">5</a>. Experiments</span>

   We have implemented the CWV mechanism in the TCP implementation in
   FreeBSD 3.2.  [<a href="#ref-HPF99" title='"ftp://www- net.cs.umass.edu/pub/Handley99-tcpq-tr-99-77.ps.gz"'>HPF99</a>] discusses these experiments in more detail.

   The first experiment examines the effects of the Congestion Window
   Validation mechanisms for limiting cwnd increases during
   application-limited periods.  The experiment used a real ssh
   connection through a modem link emulated using Dummynet [<a href="#ref-Dummynet" title='"Dummynet and Forward Error Correction"'>Dummynet</a>].
   The link speed is 30Kb/s and the link has five packet buffers
   available.  Today most modem banks have more buffering available than
   this, but the more buffer-limited situation sometimes occurs with
   older modems.  In the first half of the transfer, the user is typing
   away over the connection.  About half way through the time, the user
   lists a moderately large file, which causes a large burst of traffic
   to be transmitted.

   For the unmodified TCP, every returning ACK during the first part of
   the transfer results in an increase in cwnd.  As a result, the large
   burst of data arriving from the application to the transport layer is
   sent as many back-to-back packets, most of which get lost and
   subsequently retransmitted.

   For the modified TCP with Congestion Window Validation, the
   congestion window is not increased when the window is not full, and
   has been decreased during application-limited periods closer to what
   the user actually used.  The burst of traffic is now constrained by
   the congestion window, resulting in a better-behaved flow with





<span class="grey">Handley, et al.               Experimental                      [Page 7]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-8" id="page-8" name="page-8"> </a>
<span class="grey"><a href="rfc2861.html">RFC 2861</a>            TCP Congestion Window Validation           June 2000</span>


   minimal loss.  The end result is that the transfer happens
   approximately 30% faster than the transfer without CWV, due to
   avoiding retransmission timeouts.

   The second experiment uses a real ssh connection over a real dialup
   ppp connection, where the modem bank has much more buffering.  For
   the unmodified TCP, the initial burst from the large file does not
   cause loss, but does cause the RTT to increase to approximately 5
   seconds, where the connection becomes bounded by the receiver's
   window.

   For the modified TCP with Congestion Window Validation, the flow is
   much better behaved, and produces no large burst of traffic.  In this
   case the linear increase for cwnd results in a slow increase in the
   RTT as the buffer slowly fills.

   For the second experiment, both the modified and the unmodified TCP
   finish delivering the data at precisely the same time.  This is
   because the link has been fully utilized in both cases due to the
   modem buffer being larger than the receiver window.  Clearly a modem
   buffer of this size is undesirable due to its effect on the RTT of
   competing flows, but it is necessary with current TCP implementations
   that produce bursts similar to those shown in the top graph.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/6.%20Conclusions"></a><a class="selflink" href="#section-6" name="section-6">6</a>. Conclusions</span>

   This document has presented several TCP algorithms for Congestion
   Window Validation, to be employed after an idle period or a period in
   which the sender was application-limited, and before an increase of
   the congestion window.  The goal of these algorithms is for TCP's
   congestion window to reflect recent knowledge of the TCP connection
   about the state of the network path, while at the same time keeping
   some memory (i.e., in ssthresh) about the earlier state of the path.
   We believe that these modifications will be of benefit to both the
   network and to the TCP flows themselves, by preventing unnecessary
   packet drops due to the TCP sender's failure to update its
   information (or lack of information) about current network
   conditions.  Future work will document and investigate the benefit
   provided by these algorithms, using both simulations and experiments.
   Additional future work will describe a more complex version of the
   CWV algorithm for TCP implementations where the sender does not have
   an accurate estimate of the TCP roundtrip time.









<span class="grey">Handley, et al.               Experimental                      [Page 8]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-9" id="page-9" name="page-9"> </a>
<span class="grey"><a href="rfc2861.html">RFC 2861</a>            TCP Congestion Window Validation           June 2000</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/7.%20References"></a><a class="selflink" href="#section-7" name="section-7">7</a>. References</span>

   [<a id="ref-FF96" name="ref-FF96">FF96</a>]     Fall, K., and Floyd, S., Simulation-based Comparisons of
              Tahoe, Reno, and SACK TCP, Computer Communication Review,
              V. 26 N. 3, July 1996, pp. 5-21.  URL
              "<a href="http://www.aciri.org/floyd/papers.html">http://www.aciri.org/floyd/papers.html</a>".

   [<a id="ref-HPF99" name="ref-HPF99">HPF99</a>]    Mark Handley, Jitendra Padhye, Sally Floyd, TCP Congestion
              Window Validation, UMass CMPSCI Technical Report 99-77,
              September 1999.  URL "<a href="ftp://www-net.cs.umass.edu/pub/Handley99-tcpq-tr-99-77.ps.gz">ftp://www-</a>
              <a href="ftp://www-net.cs.umass.edu/pub/Handley99-tcpq-tr-99-77.ps.gz">net.cs.umass.edu/pub/Handley99-tcpq-tr-99-77.ps.gz</a>".

   [<a id="ref-HTH98" name="ref-HTH98">HTH98</a>]    Amy Hughes, Joe Touch, John Heidemann, "Issues in TCP
              Slow-Start Restart After Idle", Work in Progress.

   [<a id="ref-J88" name="ref-J88">J88</a>]      Jacobson, V., Congestion Avoidance and Control, Originally
              from Proceedings of SIGCOMM '88 (Palo Alto, CA, Aug.
              1988), and revised in 1992.  URL "<a href="http://www-nrg.ee.lbl.gov/nrg-papers.html">http://www-</a>
              <a href="http://www-nrg.ee.lbl.gov/nrg-papers.html">nrg.ee.lbl.gov/nrg-papers.html</a>".

   [<a id="ref-JKBFL96" name="ref-JKBFL96">JKBFL96</a>]  Raj Jain, Shiv Kalyanaraman, Rohit Goyal, Sonia Fahmy, and
              Fang Lu, Comments on "Use-it or Lose-it", ATM Forum
              Document Number:  ATM Forum/96-0178, URL
              "<a href="http://www.netlab.ohio-state.edu/~jain/atmf/af_rl5b2.htm">http://www.netlab.ohio-</a>
              <a href="http://www.netlab.ohio-state.edu/~jain/atmf/af_rl5b2.htm">state.edu/~jain/atmf/af_rl5b2.htm</a>".

   [<a id="ref-JKGFL95" name="ref-JKGFL95">JKGFL95</a>]  R. Jain, S. Kalyanaraman, R. Goyal, S. Fahmy, and F. Lu, A
              Fix for Source End System Rule 5, AF-TM 95-1660, December
              1995, URL "<a href="http://www.netlab.ohio-state.edu/~jain/atmf/af_rl52.htm">http://www.netlab.ohio-</a>
              <a href="http://www.netlab.ohio-state.edu/~jain/atmf/af_rl52.htm">state.edu/~jain/atmf/af_rl52.htm</a>".

   [<a id="ref-MSML99" name="ref-MSML99">MSML99</a>]   Matt Mathis, Jeff Semke, Jamshid Mahdavi, and Kevin Lahey,
              The Rate-Halving Algorithm for TCP Congestion Control,
              June 1999.  URL
              "<a href="http://www.psc.edu/networking/ftp/papers/draft-ratehalving.txt">http://www.psc.edu/networking/ftp/papers/draft-</a>
              <a href="http://www.psc.edu/networking/ftp/papers/draft-ratehalving.txt">ratehalving.txt</a>".

   [<a id="ref-NS" name="ref-NS">NS</a>]       NS, the UCB/LBNL/VINT Network Simulator.  URL
              "<a href="http://www-mash.cs.berkeley.edu/ns/">http://www-mash.cs.berkeley.edu/ns/</a>".

   [<a id="ref-RFC2581" name="ref-RFC2581">RFC2581</a>]  Allman, M., Paxson, V. and W. Stevens, TCP Congestion
              Control, <a href="rfc2581.html">RFC 2581</a>, April 1999.

   [<a id="ref-VH97" name="ref-VH97">VH97</a>]     Vikram Visweswaraiah and John Heidemann. Improving Restart
              of Idle TCP Connections, Technical Report 97-661,
              University of Southern California, November, 1997.





<span class="grey">Handley, et al.               Experimental                      [Page 9]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-10" id="page-10" name="page-10"> </a>
<span class="grey"><a href="rfc2861.html">RFC 2861</a>            TCP Congestion Window Validation           June 2000</span>


   [<a id="ref-Dummynet" name="ref-Dummynet">Dummynet</a>] Luigi Rizzo, "Dummynet and Forward Error Correction",
              Freenix 98, June 1998, New Orleans.  URL
              "<a href="http://info.iet.unipi.it/~luigi/ip_dummynet/">http://info.iet.unipi.it/~luigi/ip_dummynet/</a>".

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/8.%20Security%20Considerations"></a><a class="selflink" href="#section-8" name="section-8">8</a>. Security Considerations</span>

   General security considerations concerning TCP congestion control are
   discussed in <a href="rfc2581.html">RFC 2581</a>.  This document describes a algorithm for one
   aspect of those congestion control procedures, and so the
   considerations described in <a href="rfc2581.html">RFC 2581</a> apply to this algorithm also.
   There are no known additional security concerns for this specific
   algorithm.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/9.%20Authors%27%20Addresses"></a><a class="selflink" href="#section-9" name="section-9">9</a>. Authors' Addresses</span>

   Mark Handley
   AT&amp;T Center for Internet Research at ICSI (ACIRI)

   Phone: +1 510 666 2946
   EMail: mjh@aciri.org
   URL: <a href="http://www.aciri.org/mjh/">http://www.aciri.org/mjh/</a>


   Jitendra Padhye
   AT&amp;T Center for Internet Research at ICSI (ACIRI)

   Phone: +1 510 666 2887
   EMail: padhye@aciri.org
   URL: <a href="http://www-net.cs.umass.edu/~jitu/">http://www-net.cs.umass.edu/~jitu/</a>


   Sally Floyd
   AT&amp;T Center for Internet Research at ICSI (ACIRI)

   Phone: +1 510 666 2989
   EMail: floyd@aciri.org
   URL:  <a href="http://www.aciri.org/floyd/">http://www.aciri.org/floyd/</a>














<span class="grey">Handley, et al.               Experimental                     [Page 10]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-11" id="page-11" name="page-11"> </a>
<span class="grey"><a href="rfc2861.html">RFC 2861</a>            TCP Congestion Window Validation           June 2000</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/10.%20Full%20Copyright%20Statement"></a><a class="selflink" href="#section-10" name="section-10">10</a>. Full Copyright Statement</span>

   Copyright (C) The Internet Society (2000).  All Rights Reserved.

   This document and translations of it may be copied and furnished to
   others, and derivative works that comment on or otherwise explain it
   or assist in its implementation may be prepared, copied, published
   and distributed, in whole or in part, without restriction of any
   kind, provided that the above copyright notice and this paragraph are
   included on all such copies and derivative works.  However, this
   document itself may not be modified in any way, such as by removing
   the copyright notice or references to the Internet Society or other
   Internet organizations, except as needed for the purpose of
   developing Internet standards in which case the procedures for
   copyrights defined in the Internet Standards process must be
   followed, or as required to translate it into languages other than
   English.

   The limited permissions granted above are perpetual and will not be
   revoked by the Internet Society or its successors or assigns.

   This document and the information contained herein is provided on an
   "AS IS" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING
   TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING
   BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION
   HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF
   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.

Acknowledgement

   Funding for the RFC Editor function is currently provided by the
   Internet Society.



















Handley, et al.               Experimental                     [Page 11]

</pre><br/>
    <span class="noprint"><small><small>Html markup produced by rfcmarkup 1.126, available from
      <a href="https://tools.ietf.org/tools/rfcmarkup/">https://tools.ietf.org/tools/rfcmarkup/</a>
    </small></small></span>
  </div>




</body><!-- Mirrored from tools.ietf.org/html/rfc2861 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 06 Mar 2018 23:18:50 GMT --></html>