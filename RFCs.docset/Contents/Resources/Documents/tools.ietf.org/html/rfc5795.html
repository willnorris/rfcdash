<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml"><!-- Mirrored from tools.ietf.org/html/rfc5795 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 06 Mar 2018 23:18:33 GMT --><!-- Added by HTTrack --><head><meta content="text/html;charset=utf-8" http-equiv="content-type"/><!-- /Added by HTTrack -->

    <meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
    <meta content="index,follow" name="robots"/>
    <meta content="rfcmarkup version 1.126" name="creator"/>
    <link href="http://purl.org/dc/elements/1.1/" rel="schema.DC"/>
<meta content="rfc4995" name="DC.Relation.Replaces"/>
<meta content="urn:ietf:rfc:5795" name="DC.Identifier"/>
<meta content="March, 2010" name="DC.Date.Issued"/>
<meta content="Pelletier, Ghyslain" name="DC.Creator"/>
<meta content="Sandlund, Kristofer" name="DC.Creator"/>
<meta content="The Robust Header Compression (ROHC) protocol provides an efficient,
flexible, and future-proof header compression concept. It is designed
to operate efficiently and robustly over various link technologies
with different characteristics.  The ROHC framework, along with a set
of compression profiles, was initially defined in RFC 3095. To improve
and simplify the ROHC specifications, this document explicitly defines
the ROHC framework and the profile for uncompressed separately. More
specifically, the definition of the framework does not modify or
update the definition of the framework specified by RFC 3095.  This
specification obsoletes RFC 4995. It fixes one interoperability issue
that was erroneously introduced in RFC 4995, and adds some minor
clarifications." name="DC.Description.Abstract"/>
<meta content="The RObust Header Compression (ROHC) Framework" name="DC.Title"/>

    <link href="https://tools.ietf.org/images/rfc.png" rel="icon" type="image/png"/>
    <link href="https://tools.ietf.org/images/rfc.png" rel="shortcut icon" type="image/png"/>
    <title>RFC 5795 - The RObust Header Compression (ROHC) Framework</title>
    
    
    <style type="text/css">
	@media only screen 
	  and (min-width: 992px)
	  and (max-width: 1199px) {
	    body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 768px)
	  and (max-width: 991px) {
            body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 480px)
	  and (max-width: 767px) {
            body { font-size: 11pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (max-width: 479px) {
            body { font-size: 8pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-device-width : 375px) 
	  and (max-device-width : 667px) {
            body { font-size: 9.5pt; }
            div.content { width: 96ex; margin: 0 1px; }
        }
	@media only screen 
	  and (min-device-width: 1200px) {
            body { font-size: 10pt; margin: 0 4em; }
            div.content { width: 96ex; margin: 0; }
        }
        h1, h2, h3, h4, h5, h6, .h1, .h2, .h3, .h4, .h5, .h6 {
	    font-weight: bold;
            line-height: 0pt;
            display: inline;
            white-space: pre;
            font-family: monospace;
            font-size: 1em;
	    font-weight: bold;
        }
        pre {
            font-size: 1em;
            margin-top: 0px;
            margin-bottom: 0px;
        }
	.pre {
	    white-space: pre;
	    font-family: monospace;
	}
	.header{
	    font-weight: bold;
	}
        .newpage {
            page-break-before: always;
        }
        .invisible {
            text-decoration: none;
            color: white;
        }
        a.selflink {
          color: black;
          text-decoration: none;
        }
        @media print {
            body {
                font-family: monospace;
                font-size: 10.5pt;
            }
            h1, h2, h3, h4, h5, h6 {
                font-size: 1em;
            }
        
            a:link, a:visited {
                color: inherit;
                text-decoration: none;
            }
            .noprint {
                display: none;
            }
        }
	@media screen {
	    .grey, .grey a:link, .grey a:visited {
		color: #777;
	    }
            .docinfo {
                background-color: #EEE;
            }
            .top {
                border-top: 7px solid #EEE;
            }
            .bgwhite  { background-color: white; }
            .bgred    { background-color: #F44; }
            .bggrey   { background-color: #666; }
            .bgbrown  { background-color: #840; }            
            .bgorange { background-color: #FA0; }
            .bgyellow { background-color: #EE0; }
            .bgmagenta{ background-color: #F4F; }
            .bgblue   { background-color: #66F; }
            .bgcyan   { background-color: #4DD; }
            .bggreen  { background-color: #4F4; }

            .legend   { font-size: 90%; }
            .cplate   { font-size: 70%; border: solid grey 1px; }
	}
    </style>
    <!--[if IE]>
    <style>
    body {
       font-size: 13px;
       margin: 10px 10px;
    }
    </style>
    <![endif]-->

    <script type="text/javascript"><!--
    function addHeaderTags() {
	var spans = document.getElementsByTagName("span");
	for (var i=0; i < spans.length; i++) {
	    var elem = spans[i];
	    if (elem) {
		var level = elem.getAttribute("class");
                if (level == "h1" || level == "h2" || level == "h3" || level == "h4" || level == "h5" || level == "h6") {
                    elem.innerHTML = "<"+level+">"+elem.innerHTML+"</"+level+">";		
                }
	    }
	}
    }
    var legend_html = "Colour legend:<br />      <table>         <tr><td>Unknown:</td>                   <td><span class='cplate bgwhite'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft:</td>                     <td><span class='cplate bgred'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Informational:</td>             <td><span class='cplate bgorange'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Experimental:</td>              <td><span class='cplate bgyellow'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Best Common Practice:</td>      <td><span class='cplate bgmagenta'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Proposed Standard:</td>         <td><span class='cplate bgblue'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft Standard (old designation):</td> <td><span class='cplate bgcyan'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Internet Standard:</td>         <td><span class='cplate bggreen'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Historic:</td>                  <td><span class='cplate bggrey'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Obsolete:</td>                  <td><span class='cplate bgbrown'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>     </table>";
    function showElem(id) {
        var elem = document.getElementById(id);
        elem.innerHTML = eval(id+"_html");
        elem.style.visibility='visible';
    }
    function hideElem(id) {
        var elem = document.getElementById(id);
        elem.style.visibility='hidden';        
        elem.innerHTML = "";
    }
    // -->
    </script>
</head>
<body onload="addHeaderTags()">
  <div class="content">
   <div style="height: 13px;">
      <div class="pre noprint docinfo bgblue" onclick="showElem('legend');" onmouseout="hideElem('legend')" onmouseover="this.style.cursor='pointer';" style="height: 6px; position: absolute;" title="Click for colour legend.">                                                                        </div>
      <div class="docinfo noprint pre legend" id="legend" onmouseout="hideElem('legend');" onmouseover="showElem('legend');" style="position:absolute; top: 4px; left: 4ex; visibility:hidden; background-color: white; padding: 4px 9px 5px 7px; border: solid #345 1px; ">
      </div>
   </div>
<span class="pre noprint docinfo top">[<a href="index.html" title="Document search and retrieval page">Docs</a>] [<a href="https://tools.ietf.org/rfc/rfc5795.txt" title="Plaintext version of this document">txt</a>|<a href="https://tools.ietf.org/pdf/rfc5795" title="PDF version of this document">pdf</a>] [<a href="https://tools.ietf.org/html/draft-ietf-rohc-rfc4995bis" title="draft-ietf-rohc-rfc4995bis">draft-ietf-rohc...</a>] [<a href="https://datatracker.ietf.org/doc/rfc5795" title="IESG Datatracker information for this document">Tracker</a>] [<a href="https://tools.ietf.org/rfcdiff?difftype=--hwdiff&amp;url2=rfc5795" title="Inline diff (wdiff)">Diff1</a>] [<a href="https://tools.ietf.org/rfcdiff?url2=rfc5795" title="Side-by-side diff">Diff2</a>] [<a href="https://www.rfc-editor.org/errata_search.php?rfc=5795">Errata</a>]</span><br/>
<span class="pre noprint docinfo">                                                                        </span><br/>
<span class="pre noprint docinfo">                                                       PROPOSED STANDARD</span><br/>
<span class="pre noprint docinfo">                                                            <span style="color: #C00;">Errata Exist</span></span><br/>
<pre>Internet Engineering Task Force (IETF)                       K. Sandlund
Request for Comments: 5795                                  G. Pelletier
Obsoletes: <a href="rfc4995.html">4995</a>                                                 Ericsson
Category: Standards Track                                   L-E. Jonsson
ISSN: 2070-1721                                               March 2010


             <span class="h1">The RObust Header Compression (ROHC) Framework</span>

Abstract

   The Robust Header Compression (ROHC) protocol provides an efficient,
   flexible, and future-proof header compression concept.  It is
   designed to operate efficiently and robustly over various link
   technologies with different characteristics.

   The ROHC framework, along with a set of compression profiles, was
   initially defined in <a href="rfc3095.html">RFC 3095</a>.  To improve and simplify the ROHC
   specifications, this document explicitly defines the ROHC framework
   and the profile for uncompressed separately.  More specifically, the
   definition of the framework does not modify or update the definition
   of the framework specified by <a href="rfc3095.html">RFC 3095</a>.

   This specification obsoletes <a href="rfc4995.html">RFC 4995</a>.  It fixes one interoperability
   issue that was erroneously introduced in <a href="rfc4995.html">RFC 4995</a>, and adds some
   minor clarifications.

Status of This Memo

   This is an Internet Standards Track document.

   This document is a product of the Internet Engineering Task Force
   (IETF).  It represents the consensus of the IETF community.  It has
   received public review and has been approved for publication by the
   Internet Engineering Steering Group (IESG).  Further information on
   Internet Standards is available in <a href="rfc5741.html#section-2">Section 2 of RFC 5741</a>.

   Information about the current status of this document, any errata,
   and how to provide feedback on it may be obtained at
   <a href="http://www.rfc-editor.org/info/rfc5795">http://www.rfc-editor.org/info/rfc5795</a>.











<span class="grey">Sandlund, et al.             Standards Track                    [Page 1]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-2" id="page-2" name="page-2"> </a>
<span class="grey"><a href="rfc5795.html">RFC 5795</a>                     ROHC Framework                   March 2010</span>


Copyright Notice

   Copyright (c) 2010 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to <a href="https://tools.ietf.org/html/bcp78">BCP 78</a> and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (<a href="http://trustee.ietf.org/license-info">http://trustee.ietf.org/license-info</a>) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.

   This document may contain material from IETF Documents or IETF
   Contributions published or made publicly available before November
   10, 2008.  The person(s) controlling the copyright in some of this
   material may not have granted the IETF Trust the right to allow
   modifications of such material outside the IETF Standards Process.
   Without obtaining an adequate license from the person(s) controlling
   the copyright in such materials, this document may not be modified
   outside the IETF Standards Process, and derivative works of it may
   not be created outside the IETF Standards Process, except to format
   it for publication as an RFC or to translate it into languages other
   than English.

Table of Contents

   <a href="#section-1">1</a>.  Introduction . . . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-4">4</a>
   <a href="#section-2">2</a>.  Terminology  . . . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-5">5</a>
     <a href="#section-2.1">2.1</a>.  Acronyms . . . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-5">5</a>
     <a href="#section-2.2">2.2</a>.  ROHC Terminology . . . . . . . . . . . . . . . . . . . . .  <a href="#page-5">5</a>
   <a href="#section-3">3</a>.  Background (Informative) . . . . . . . . . . . . . . . . . . .  <a href="#page-8">8</a>
     <a href="#section-3.1">3.1</a>.  Header Compression Fundamentals  . . . . . . . . . . . . .  <a href="#page-8">8</a>
     <a href="#section-3.2">3.2</a>.  A Short History of Header Compression  . . . . . . . . . .  <a href="#page-9">9</a>
   <a href="#section-4">4</a>.  Overview of ROHC (Informative) . . . . . . . . . . . . . . . . <a href="#page-10">10</a>
     <a href="#section-4.1">4.1</a>.  General Principles . . . . . . . . . . . . . . . . . . . . <a href="#page-10">10</a>
     <a href="#section-4.2">4.2</a>.  Compression Efficiency, Robustness, and Transparency . . . <a href="#page-11">11</a>
     <a href="#section-4.3">4.3</a>.  Developing the ROHC Protocol . . . . . . . . . . . . . . . <a href="#page-12">12</a>
     <a href="#section-4.4">4.4</a>.  Operational Characteristics of the ROHC Channel  . . . . . <a href="#page-13">13</a>
     <a href="#section-4.5">4.5</a>.  Compression and Master Sequence Number (MSN) . . . . . . . <a href="#page-14">14</a>
     <a href="#section-4.6">4.6</a>.  Static and Dynamic Parts of a Context  . . . . . . . . . . <a href="#page-15">15</a>
   <a href="#section-5">5</a>.  The ROHC Framework (Normative) . . . . . . . . . . . . . . . . <a href="#page-15">15</a>
     <a href="#section-5.1">5.1</a>.  The ROHC Channel . . . . . . . . . . . . . . . . . . . . . <a href="#page-15">15</a>
       <a href="#section-5.1.1">5.1.1</a>.  Contexts and Context Identifiers . . . . . . . . . . . <a href="#page-15">15</a>
       <a href="#section-5.1.2">5.1.2</a>.  Per-Channel Parameters . . . . . . . . . . . . . . . . <a href="#page-16">16</a>
       <a href="#section-5.1.3">5.1.3</a>.  Persistence of Decompressor Contexts . . . . . . . . . <a href="#page-17">17</a>



<span class="grey">Sandlund, et al.             Standards Track                    [Page 2]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-3" id="page-3" name="page-3"> </a>
<span class="grey"><a href="rfc5795.html">RFC 5795</a>                     ROHC Framework                   March 2010</span>


     <a href="#section-5.2">5.2</a>.  ROHC Packets and Packet Types  . . . . . . . . . . . . . . <a href="#page-17">17</a>
       <a href="#section-5.2.1">5.2.1</a>.  General Format of ROHC Packets . . . . . . . . . . . . <a href="#page-18">18</a>
         <a href="#section-5.2.1.1">5.2.1.1</a>.  Format of the Padding Octet  . . . . . . . . . . . <a href="#page-19">19</a>
         <a href="#section-5.2.1.2">5.2.1.2</a>.  Format of the Add-CID Octet  . . . . . . . . . . . <a href="#page-19">19</a>
         <a href="#section-5.2.1.3">5.2.1.3</a>.  General Format of Header . . . . . . . . . . . . . <a href="#page-19">19</a>
       <a href="#section-5.2.2">5.2.2</a>.  Initialization and Refresh (IR) Packet Types . . . . . <a href="#page-20">20</a>
         <a href="#section-5.2.2.1">5.2.2.1</a>.  ROHC IR Header Format  . . . . . . . . . . . . . . <a href="#page-20">20</a>
         <a href="#section-5.2.2.2">5.2.2.2</a>.  ROHC IR-DYN Header Format  . . . . . . . . . . . . <a href="#page-21">21</a>
       <a href="#section-5.2.3">5.2.3</a>.  ROHC Initial Decompressor Processing . . . . . . . . . <a href="#page-22">22</a>
       <a href="#section-5.2.4">5.2.4</a>.  ROHC Feedback  . . . . . . . . . . . . . . . . . . . . <a href="#page-23">23</a>
         <a href="#section-5.2.4.1">5.2.4.1</a>.  ROHC Feedback Format . . . . . . . . . . . . . . . <a href="#page-24">24</a>
       <a href="#section-5.2.5">5.2.5</a>.  ROHC Segmentation  . . . . . . . . . . . . . . . . . . <a href="#page-26">26</a>
         <a href="#section-5.2.5.1">5.2.5.1</a>.  Segmentation Usage Considerations  . . . . . . . . <a href="#page-26">26</a>
         <a href="#section-5.2.5.2">5.2.5.2</a>.  Segmentation Protocol  . . . . . . . . . . . . . . <a href="#page-26">26</a>
     <a href="#section-5.3">5.3</a>.  General Encoding Methods . . . . . . . . . . . . . . . . . <a href="#page-28">28</a>
       <a href="#section-5.3.1">5.3.1</a>.  Header Compression CRCs, Coverage, and Polynomials . . <a href="#page-28">28</a>
         <a href="#section-5.3.1.1">5.3.1.1</a>.  8-bit CRC in IR and IR-DYN Headers . . . . . . . . <a href="#page-28">28</a>
         <a href="#section-5.3.1.2">5.3.1.2</a>.  3-bit CRC in Compressed Headers  . . . . . . . . . <a href="#page-28">28</a>
         <a href="#section-5.3.1.3">5.3.1.3</a>.  7-bit CRC in Compressed Headers  . . . . . . . . . <a href="#page-29">29</a>
         <a href="#section-5.3.1.4">5.3.1.4</a>.  32-bit Segmentation CRC  . . . . . . . . . . . . . <a href="#page-29">29</a>
       <a href="#section-5.3.2">5.3.2</a>.  Self-Describing Variable-Length Values . . . . . . . . <a href="#page-30">30</a>
     <a href="#section-5.4">5.4</a>.  ROHC UNCOMPRESSED -- No Compression  (Profile 0x0000)  . . <a href="#page-30">30</a>
       <a href="#section-5.4.1">5.4.1</a>.  IR Packet  . . . . . . . . . . . . . . . . . . . . . . <a href="#page-31">31</a>
       <a href="#section-5.4.2">5.4.2</a>.  Normal Packet  . . . . . . . . . . . . . . . . . . . . <a href="#page-32">32</a>
       <a href="#section-5.4.3">5.4.3</a>.  Context Initialization . . . . . . . . . . . . . . . . <a href="#page-32">32</a>
       <a href="#section-5.4.4">5.4.4</a>.  Decompressor Operation . . . . . . . . . . . . . . . . <a href="#page-33">33</a>
       <a href="#section-5.4.5">5.4.5</a>.  Feedback . . . . . . . . . . . . . . . . . . . . . . . <a href="#page-33">33</a>
   <a href="#section-6">6</a>.  Overview of a ROHC Profile (Informative) . . . . . . . . . . . <a href="#page-33">33</a>
   <a href="#section-7">7</a>.  Acknowledgments  . . . . . . . . . . . . . . . . . . . . . . . <a href="#page-35">35</a>
   <a href="#section-8">8</a>.  IANA Considerations  . . . . . . . . . . . . . . . . . . . . . <a href="#page-35">35</a>
   <a href="#section-9">9</a>.  Security Considerations  . . . . . . . . . . . . . . . . . . . <a href="#page-36">36</a>
   <a href="#section-10">10</a>. References . . . . . . . . . . . . . . . . . . . . . . . . . . <a href="#page-37">37</a>
     <a href="#section-10.1">10.1</a>. Normative References . . . . . . . . . . . . . . . . . . . <a href="#page-37">37</a>
     <a href="#section-10.2">10.2</a>. Informative References . . . . . . . . . . . . . . . . . . <a href="#page-37">37</a>
   <a href="#appendix-A">Appendix A</a>.  CRC Algorithm . . . . . . . . . . . . . . . . . . . . <a href="#page-39">39</a>
















<span class="grey">Sandlund, et al.             Standards Track                    [Page 3]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-4" id="page-4" name="page-4"> </a>
<span class="grey"><a href="rfc5795.html">RFC 5795</a>                     ROHC Framework                   March 2010</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/1.%20%20Introduction"></a><a class="selflink" href="#section-1" name="section-1">1</a>.  Introduction</span>

   For many types of networks, reducing the deployment and operational
   costs by improving the usage of the bandwidth resources is of vital
   importance.  Header compression over a link is possible because some
   of the information carried within the header of a packet becomes
   compressible between packets belonging to the same flow.

   For links where the overhead of the IP header(s) is problematic, the
   total size of the header may be significant.  Applications
   transferring data carried within RTP [<a href="rfc3550.html" title='"RTP: A Transport Protocol for Real-Time Applications"'>RFC3550</a>] will then, in addition
   to link-layer framing, have an IPv4 [<a href="https://tools.ietf.org/html/rfc0791" title='"Internet Protocol"'>RFC0791</a>] header (20 octets), a
   UDP [<a href="https://tools.ietf.org/html/rfc0768" title='"User Datagram Protocol"'>RFC0768</a>] header (8 octets), and an RTP header (12 octets), for a
   total of 40 octets.  With IPv6 [<a href="rfc2460.html" title='"Internet Protocol, Version 6 (IPv6) Specification"'>RFC2460</a>], the IPv6 header is 40
   octets for a total of 60 octets.  Applications transferring data
   using TCP [<a href="https://tools.ietf.org/html/rfc0793" title='"Transmission Control Protocol"'>RFC0793</a>] will have 20 octets for the transport header, for
   a total size of 40 octets for IPv4 and 60 octets for IPv6.

   The relative gain for specific flows (or applications) depends on the
   size of the payload used in each packet.  For applications such as
   Voice over IP, where the size of the payload containing coded speech
   can be as small as 15-20 octets, this gain will be quite significant.
   Similarly, relative gains for TCP flows carrying large payloads (such
   as file transfers) will be less than for flows carrying smaller
   payloads (such as application signaling, e.g., session initiation).

   As more and more wireless link technologies are being deployed to
   carry IP traffic, care must be taken to address the specific
   characteristics of these technologies within the header compression
   algorithms.  Legacy header compression schemes, such as those defined
   in [<a href="rfc2507.html" title='"IP Header Compression"'>RFC2507</a>] and [<a href="rfc2508.html" title='"Compressing IP/UDP/RTP Headers for Low-Speed Serial Links"'>RFC2508</a>], have been shown to perform inadequately
   over links where both the lossy behavior and the round-trip times are
   non-negligible, such as those observed, for example, in wireless
   links and IP tunnels.

   In addition, a header compression scheme should handle the often non-
   trivial residual errors, i.e., where the lower layer may pass a
   packet that contains undetected bit errors to the decompressor.  It
   should also handle loss and reordering before the compression point,
   as well as on the link between the compression and decompression
   points [<a href="rfc4224.html" title='"RObust Header Compression (ROHC): ROHC over Channels That Can Reorder Packets"'>RFC4224</a>].

   The Robust Header Compression (ROHC) protocol provides an efficient,
   flexible, and future-proof header compression concept.  It is
   designed to operate efficiently and robustly over various link
   technologies with different characteristics.





<span class="grey">Sandlund, et al.             Standards Track                    [Page 4]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-5" id="page-5" name="page-5"> </a>
<span class="grey"><a href="rfc5795.html">RFC 5795</a>                     ROHC Framework                   March 2010</span>


   <a href="rfc3095.html">RFC 3095</a> [<a href="rfc3095.html" title='"RObust Header Compression (ROHC): Framework and four profiles: RTP, UDP, ESP, and uncompressed"'>RFC3095</a>] defines the ROHC framework along with an initial
   set of compression profiles.  To improve and simplify the
   specification, the framework and the profiles' parts have been split
   into separate documents.  This document explicitly defines the ROHC
   framework, but it does not modify or update the definition of the
   framework specified by <a href="rfc3095.html">RFC 3095</a>; both documents can be used
   independently of each other.  This also implies that implementations
   based on either definition will be compatible and interoperable with
   each other.  However, it is the intent to let this specification
   replace <a href="rfc3095.html">RFC 3095</a> as the base specification for all profiles defined
   in the future.

   This document fixes one interoperability issue that was erroneously
   introduced in <a href="rfc4995.html">RFC 4995</a>.  The fix for this issue is located in
   <a href="#section-5.2.4.1">Section 5.2.4.1</a> and clarifies the interpretation of the Size field in
   ROHC feedback.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/2.%20%20Terminology"></a><a class="selflink" href="#section-2" name="section-2">2</a>.  Terminology</span>

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in [<a href="rfc2119.html" title='"Key words for use in RFCs to Indicate Requirement Levels"'>RFC2119</a>].

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/2.1.%20%20Acronyms"></a><a class="selflink" href="#section-2.1" name="section-2.1">2.1</a>.  Acronyms</span>

   This section lists most acronyms used for reference.

   ACK    Acknowledgment.
   CID    Context Identifier.
   CO     Compressed Packet Format.
   CRC    Cyclic Redundancy Check.
   IR     Initialization and Refresh.
   IR-DYN Initialization and Refresh, Dynamic part.
   LSB    Least Significant Bit.
   MRRU   Maximum Reconstructed Reception Unit.
   MSB    Most Significant Bit.
   MSN    Master Sequence Number.
   NACK   Negative Acknowledgment.
   ROHC   RObust Header Compression.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/2.2.%20%20ROHC%20Terminology"></a><a class="selflink" href="#section-2.2" name="section-2.2">2.2</a>.  ROHC Terminology</span>

   Context

      The context of the compressor is the state it uses to compress a
      header.  The context of the decompressor is the state it uses to
      decompress a header.  Either of these or the two in combination
      are usually referred to as "context", when it is clear which is



<span class="grey">Sandlund, et al.             Standards Track                    [Page 5]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-6" id="page-6" name="page-6"> </a>
<span class="grey"><a href="rfc5795.html">RFC 5795</a>                     ROHC Framework                   March 2010</span>


      intended.  The context contains relevant information from previous
      headers in the packet flow, such as static fields and possible
      reference values for compression and decompression.  Moreover,
      additional information describing the packet flow is also part of
      the context, for example, information about the change behavior of
      fields (e.g., the IP Identifier behavior, or the typical inter-
      packet increase in sequence numbers and timestamps).

   Context damage

      When the context of the decompressor is not consistent with the
      context of the compressor, decompression may fail to reproduce the
      original header.  This situation can occur when the context of the
      decompressor has not been initialized properly or when packets
      have been lost or damaged between the compressor and decompressor.

      Packets that cannot be decompressed due to inconsistent contexts
      are said to be lost due to context damage.  Packets that are
      decompressed but contain errors due to inconsistent contexts are
      said to be damaged due to context damage.

   Context repair mechanisms

      Mechanisms used to resynchronize the contexts -- an important task
      since context damage causes loss propagation.  Examples of such
      mechanisms are NACK-based mechanisms, and the periodic refreshes
      of important context information, usually done in unidirectional
      operation.  There are also mechanisms that can reduce the context
      inconsistency probability, for example, repetition of the same
      type of information in multiple packets and CRCs that protect
      context-updating information.

   CRC-8 validation

      The validation of the integrity against bit error(s) in a received
      IR and IR-DYN header using the 8-bit CRC included in the IR/IR-DYN
      header.

   CRC verification

      The verification of the result of a decompression attempt using
      the 3-bit CRC or 7-bit CRC included in the header of a compressed
      packet format.








<span class="grey">Sandlund, et al.             Standards Track                    [Page 6]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-7" id="page-7" name="page-7"> </a>
<span class="grey"><a href="rfc5795.html">RFC 5795</a>                     ROHC Framework                   March 2010</span>


   Damage propagation

      Delivery of incorrect decompressed headers due to context damage,
      such as errors in (i.e., loss of or damage to) previous header(s)
      or feedback.

   Error detection

      Detection of errors by lower layers.  If error detection is not
      perfect, there will be residual errors.

   Error propagation

      Damage propagation or loss propagation.

   ROHC profile

      A compression protocol that specifies how to compress specific
      header combinations.  A ROHC profile may be tailored to handle a
      specific set of link characteristics, e.g., loss characteristics,
      reordering between compression points, etc.  ROHC profiles provide
      the details of the header compression framework defined in this
      document, and each compression profile is associated with a unique
      ROHC profile identifier [<a href="#ref-ROHC-ids" title='"RObust Header Compression (ROHC) Profile Identifiers"'>ROHC-ids</a>].  When setting up a ROHC
      channel, the set of profiles supported by both endpoints of the
      channel is negotiated, and when initializing new contexts, a
      profile identifier from this negotiated set is used to associate
      each compression context with one specific profile.

   Link

      A physical transmission path that constitutes a single IP hop.

   Loss propagation

      Loss of headers, due to errors in (i.e., loss of or damage to)
      previous header(s) or feedback.

   Packet flow

      A sequence of packets where the field values and change patterns
      of field values are such that the headers can be compressed using
      the same context.

   Residual error

      Error introduced during transmission and not detected by lower-
      layer error detection schemes.



<span class="grey">Sandlund, et al.             Standards Track                    [Page 7]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-8" id="page-8" name="page-8"> </a>
<span class="grey"><a href="rfc5795.html">RFC 5795</a>                     ROHC Framework                   March 2010</span>


   ROHC channel

      A logical unidirectional point-to-point channel carrying ROHC
      packets from one compressor to one decompressor, optionally
      carrying ROHC feedback information on the behalf of another
      compressor-decompressor pair operating on a separate ROHC channel
      in the opposite direction.  See also [<a href="rfc3759.html" title='"RObust Header Compression (ROHC): Terminology and Channel Mapping Examples"'>RFC3759</a>].

   This document also makes use of the conceptual terminology defined by
   "ROHC Terminology and Channel Mapping Examples", <a href="rfc3759.html">RFC 3759</a> [<a href="rfc3759.html" title='"RObust Header Compression (ROHC): Terminology and Channel Mapping Examples"'>RFC3759</a>].

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/3.%20%20Background%20%28Informative%29"></a><a class="selflink" href="#section-3" name="section-3">3</a>.  Background (Informative)</span>

   This section provides a background to the subject of header
   compression.  The fundamental ideas are described together with a
   discussion about the history of header compression schemes.  The
   motivations driving the development of the various schemes are
   discussed and their drawbacks identified, thereby providing the
   foundations for the design of the ROHC framework and profiles
   [<a href="rfc3095.html" title='"RObust Header Compression (ROHC): Framework and four profiles: RTP, UDP, ESP, and uncompressed"'>RFC3095</a>].

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.1.%20%20Header%20Compression%20Fundamentals"></a><a class="selflink" href="#section-3.1" name="section-3.1">3.1</a>.  Header Compression Fundamentals</span>

   Header compression is possible because there is significant
   redundancy between header field values within packets, but in
   particular between consecutive packets belonging to the same flow.
   On the path end-to-end, the entire header information is necessary
   for all packets in the flow, but over a single link, some of this
   information becomes redundant and can be reduced, as long as it is
   transparently recovered at the receiving end of the link.  The header
   size can be reduced by first sending field information that is
   expected to remain static for (at least most of) the lifetime of the
   packet flow.  Further compression is achieved for the fields carrying
   information that changes more dynamically by using compression
   methods tailored to their respective assumed change behavior.

   To achieve compression and decompression, some necessary information
   from past packets is maintained in a context.  The compressor and the
   decompressor update their respective contexts upon certain, not
   necessarily synchronized, events.  Impairment events may lead to
   inconsistencies in the decompressor context (i.e., context damage),
   which in turn may cause incorrect decompression.  A Robust Header
   Compression scheme needs mechanisms to minimize the possibility of
   context damage, in combination with mechanisms for context repair.







<span class="grey">Sandlund, et al.             Standards Track                    [Page 8]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-9" id="page-9" name="page-9"> </a>
<span class="grey"><a href="rfc5795.html">RFC 5795</a>                     ROHC Framework                   March 2010</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.2.%20%20A%20Short%20History%20of%20Header%20Compression"></a><a class="selflink" href="#section-3.2" name="section-3.2">3.2</a>.  A Short History of Header Compression</span>

   The first header compression scheme, compressed TCP (CTCP) [<a href="rfc1144.html" title='"Compressing TCP/IP headers for low-speed serial links"'>RFC1144</a>],
   was introduced by Van Jacobson.  CTCP, also often referred to as VJ
   compression, compresses the 40 octets of the TCP/IP header down to 4
   octets.  CTCP uses delta encoding for sequentially changing fields.
   The CTCP compressor detects transport-level retransmissions and sends
   a header that updates the entire context when they occur.  This
   repair mechanism does not require any explicit signaling between the
   compressor and decompressor.

   A general IP header compression scheme, IP header compression
   [<a href="rfc2507.html" title='"IP Header Compression"'>RFC2507</a>], improves somewhat on CTCP.  IP header compression (IPHC)
   can compress arbitrary IP, TCP, and UDP headers.  When compressing
   non-TCP headers, IPHC does not use delta encoding and is robust.  The
   repair mechanism of CTCP is augmented with negative acknowledgments,
   called CONTEXT_STATE messages, which speed up the repair.  This
   context repair mechanism is thus limited by the round-trip time of
   the link.  IPHC does not compress RTP headers.

   CRTP [<a href="rfc2508.html" title='"Compressing IP/UDP/RTP Headers for Low-Speed Serial Links"'>RFC2508</a>] is an RTP extension to IPHC.  CRTP compresses the 40
   octets of IPv4/UDP/RTP headers to a minimum of 2 octets when the UDP
   Checksum is not enabled.  If the UDP Checksum is enabled, the minimum
   CRTP header is 4 octets.

   On lossy links with long round-trip times, CRTP does not perform well
   [<a href="#ref-CRTP-eval" title='"Evaluation of CRTP Performance over Cellular Radio Networks"'>CRTP-eval</a>].  Each packet lost over the link causes decompression of
   several subsequent packets to fail, because the context becomes
   invalidated during at least one link round-trip time from the lost
   packet.  Unfortunately, the large headers that CRTP sends when
   updating the context waste additional bandwidth.

   CRTP uses a local repair mechanism known as TWICE, which was
   introduced by IPHC.  TWICE derives its name from the observation that
   when the flow of compressed packets is regular, the correct guess
   when one packet is lost between the compression points is to apply
   the update in the current packet twice.  While TWICE improves CRTP
   performance significantly, [<a href="#ref-CRTP-eval" title='"Evaluation of CRTP Performance over Cellular Radio Networks"'>CRTP-eval</a>] also found that even with
   TWICE, CRTP doubled the number of lost packets.

   An enhanced variant of CRTP, called eCRTP [<a href="rfc3545.html" title='"Enhanced Compressed RTP (CRTP) for Links with High Delay, Packet Loss and Reordering"'>RFC3545</a>], means to improve
   the robustness of CRTP in the presence of reordering and packet
   losses, while keeping the protocol almost unchanged from CRTP.  As a
   result, eCRTP does provide better means to implement some degree of
   robustness, albeit at the expense of additional overhead, leading to
   a reduction in compression efficiency in comparison to CRTP.





<span class="grey">Sandlund, et al.             Standards Track                    [Page 9]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-10" id="page-10" name="page-10"> </a>
<span class="grey"><a href="rfc5795.html">RFC 5795</a>                     ROHC Framework                   March 2010</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/4.%20%20Overview%20of%20ROHC%20%28Informative%29"></a><a class="selflink" href="#section-4" name="section-4">4</a>.  Overview of ROHC (Informative)</span>

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.1.%20%20General%20Principles"></a><a class="selflink" href="#section-4.1" name="section-4.1">4.1</a>.  General Principles</span>

   As mentioned earlier, header compression is possible per-link due to
   the fact that there is much redundancy between header field values
   within packets, and especially between consecutive packets belonging
   to the same flow.  To utilize these properties for header
   compression, there are a few essential steps to consider.

   The first step consists of identifying and grouping packets together
   into different "flows", so that packet-to-packet redundancy is
   maximized in order to improve the compression ratio.  Grouping
   packets into flows is usually based on source and destination host
   (IP) addresses, transport protocol type (e.g., UDP or TCP), process
   (port) numbers, and potentially additional unique application
   identifiers, such as the synchronization source (SSRC) in RTP
   [<a href="rfc3550.html" title='"RTP: A Transport Protocol for Real-Time Applications"'>RFC3550</a>].  The compressor and decompressor each establish a context
   for the packet flow and identify the context with a Context
   Identifier (CID) included in each compressed header.

   The second step is to understand the change patterns of the various
   header fields.  On a high level, header fields fall into one of the
   following classes:

   INFERRED      These fields contain values that can be inferred from
                 other fields or external sources; for example, the size
                 of the frame carrying the packet can often be derived
                 from the link-layer protocol, and thus does not have to
                 be transmitted by the compression scheme.

   STATIC        Fields classified as STATIC are assumed to be constant
                 throughout the lifetime of the packet flow.  The value
                 of each field is thus only communicated initially.

   STATIC-DEF    Fields classified as STATIC-DEF are used to define a
                 packet flow as discussed above.  Packets for which
                 respective values of these fields differ are treated as
                 belonging to different flows.  These fields are in
                 general compressed as STATIC fields.

   STATIC-KNOWN  Fields classified as STATIC-KNOWN are expected to have
                 well-known values, and therefore their values do not
                 need to be communicated.







<span class="grey">Sandlund, et al.             Standards Track                   [Page 10]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-11" id="page-11" name="page-11"> </a>
<span class="grey"><a href="rfc5795.html">RFC 5795</a>                     ROHC Framework                   March 2010</span>


   CHANGING      These fields are expected to vary randomly, either
                 within a limited value set or range, or in some other
                 manner.  CHANGING fields are usually handled in more
                 sophisticated ways based on a more detailed
                 classification of their expected change patterns.

   Finally, the last step is to choose the encoding method(s) that will
   be applied onto different fields based on classification.  The
   encoding methods, in combination with the identified field behavior,
   provide the input to the design of the compressed header formats.
   The analysis of the probability distribution of the identified change
   patterns then provides the means to optimize the packet formats,
   where the most frequently occurring change patterns for a field
   should be encoded within the most efficient format(s).

   However, compression efficiency has to be traded against two other
   properties: the robustness of the encoding to losses and errors
   between the compressor and the decompressor, and the ability to
   detect and cope with errors in the decompression process.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.2.%20%20Compression%20Efficiency%2C%20Robustness%2C%20and%20Transparency"></a><a class="selflink" href="#section-4.2" name="section-4.2">4.2</a>.  Compression Efficiency, Robustness, and Transparency</span>

   The performance of a header compression protocol can be described
   with three parameters: its compression efficiency, its robustness,
   and its compression transparency.

   Compression efficiency

      The compression efficiency is determined by how much the average
      header size is reduced by applying the compression protocol.

   Robustness

      A robust protocol tolerates packet losses, residual bit errors,
      and out-of-order delivery on the link over which header
      compression takes place, without losing additional packets or
      introducing additional errors in decompressed headers.

   Compression transparency

      The compression transparency is a measure of the extent to which
      the scheme maintains the semantics of the original headers.  If
      all decompressed headers are bitwise identical to the
      corresponding original headers, the scheme is transparent.







<span class="grey">Sandlund, et al.             Standards Track                   [Page 11]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-12" id="page-12" name="page-12"> </a>
<span class="grey"><a href="rfc5795.html">RFC 5795</a>                     ROHC Framework                   March 2010</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.3.%20%20Developing%20the%20ROHC%20Protocol"></a><a class="selflink" href="#section-4.3" name="section-4.3">4.3</a>.  Developing the ROHC Protocol</span>

   The challenge in developing a header compression protocol is to
   conciliate compression efficiency and robustness while maintaining
   transparency, as increasing robustness will always come at the
   expense of a lower compression efficiency, and vice versa.  The
   scheme should also be flexible enough in its design to minimize the
   impacts from the varying round-trip times and loss patterns of links
   where header compression will be used.

   To achieve this, the header compression scheme must provide
   facilities for the decompressor to verify decompression and detect
   potential context damage, as well as context recovery mechanisms such
   as feedback.  Header compression schemes prior to the ones developed
   by the Robust Header Compression (ROHC) Working Group (WG) were not
   designed with the above high-level objectives in mind.

   The ROHC WG has developed header compression solutions to meet the
   needs of present and future link technologies.  While special
   attention has been put towards meeting the more stringent
   requirements stemming from the characteristics of wireless links, the
   results are equally applicable to many other link technologies.

   "RObust Header Compression (ROHC): Framework and four profiles: RTP,
   UDP, ESP, and uncompressed" [<a href="rfc3095.html" title='"RObust Header Compression (ROHC): Framework and four profiles: RTP, UDP, ESP, and uncompressed"'>RFC3095</a>] was published in 2001, as the
   first output of the ROHC WG.  ROHC is a general and extendable
   framework for header compression, on top of which profiles can be
   defined for compression of different protocols headers.  <a href="rfc3095.html">RFC 3095</a>
   introduced a number of new compression techniques, and was successful
   at living up to the requirements placed on it, as described in
   [<a href="rfc3096.html" title='"Requirements for robust IP/UDP/RTP header compression"'>RFC3096</a>].

   Interoperability testing of <a href="rfc3095.html">RFC 3095</a> confirms the capabilities of
   ROHC to meet its purposes, but feedback from implementers has also
   indicated that the protocol specification is complex and sometimes
   obscure.  Most importantly, a clear distinction between framework and
   profiles is not obvious in [<a href="rfc3095.html" title='"RObust Header Compression (ROHC): Framework and four profiles: RTP, UDP, ESP, and uncompressed"'>RFC3095</a>], which also makes development of
   additional profiles troublesome.  This document therefore aims at
   explicitly specifying the ROHC framework, while a companion document
   [<a href="rfc5225.html" title='"RObust Header Compression Version 2 (ROHCv2): Profiles for RTP, UDP, IP, ESP and UDP-Lite"'>RFC5225</a>] specifies revised versions of the compression profiles of
   <a href="rfc3095.html">RFC 3095</a>.










<span class="grey">Sandlund, et al.             Standards Track                   [Page 12]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-13" id="page-13" name="page-13"> </a>
<span class="grey"><a href="rfc5795.html">RFC 5795</a>                     ROHC Framework                   March 2010</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.4.%20%20Operational%20Characteristics%20of%20the%20ROHC%20Channel"></a><a class="selflink" href="#section-4.4" name="section-4.4">4.4</a>.  Operational Characteristics of the ROHC Channel</span>

   Robust header compression can be used over many types of link
   technologies.  The ROHC framework provides flexibility for profiles
   to address a wide range of applications, and this section lists some
   of the operational characteristics of the ROHC channel (see also
   [<a href="rfc3759.html" title='"RObust Header Compression (ROHC): Terminology and Channel Mapping Examples"'>RFC3759</a>]).

   Multiplexing over a single logical channel

      The ROHC channel provides a mechanism to identify a context within
      the general ROHC packet format.  The CID makes it possible for a
      logical channel that supports ROHC to transport multiple header-
      compressed flows, while still making it possible for a channel to
      be dedicated to one single packet flow without any CID overhead.
      More specifically, ROHC uses a distinct CID space per logical
      channel, and the CID can be omitted for one of the flows over the
      ROHC channel when configured to use a small CID space.

   Establishment of channel parameters

      A link layer defining support for the ROHC channel must provide
      the means to establish header compression channel parameters (see
      <a href="#section-5.1">Section 5.1</a>).  This can be achieved through a negotiation
      mechanism, static provisioning, or some out-of-band signaling.

   Packet type identification

      The ROHC channel defines a packet type identifier space, and puts
      restrictions with respect to the use of a number of identifiers
      that are common for all ROHC profiles.  Identifiers that have no
      restrictions, i.e., identifiers that are not defined by this
      document, are available to each profile.  The identifier is part
      of each compressed header, and this makes it possible for the link
      that supports the ROHC channel to allocate one single link-layer
      payload type for ROHC.

   Out-of-order delivery between compression endpoints

      Each profile defines its own level of robustness, including
      tolerance to reordering of packets before but especially between
      compression endpoints, if any.

      For profiles specified in [<a href="rfc3095.html" title='"RObust Header Compression (ROHC): Framework and four profiles: RTP, UDP, ESP, and uncompressed"'>RFC3095</a>], the channel between the
      compressor and decompressor is required to maintain in-order
      delivery of the packets; i.e., the definition of these profiles
      assumes that the decompressor always receives packets in the same
      order as the compressor sent them.  The impacts of reordering on



<span class="grey">Sandlund, et al.             Standards Track                   [Page 13]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-14" id="page-14" name="page-14"> </a>
<span class="grey"><a href="rfc5795.html">RFC 5795</a>                     ROHC Framework                   March 2010</span>


      the performance of these profiles are described in [<a href="rfc4224.html" title='"RObust Header Compression (ROHC): ROHC over Channels That Can Reorder Packets"'>RFC4224</a>].
      However, reordering before the compression point is handled, i.e.,
      these profiles make no assumption that the compressor will receive
      packets in order.

      For the ROHCv2 profiles specified in [<a href="rfc5225.html" title='"RObust Header Compression Version 2 (ROHCv2): Profiles for RTP, UDP, IP, ESP and UDP-Lite"'>RFC5225</a>], their definitions
      assume that the decompressor can receive packets out of order,
      i.e., not in the same order that the compressor sent them.
      Reordering before the compression point is also dealt with.

   Duplication of packets

      The link supporting the ROHC channel is required to not duplicate
      packets (however, duplication of packets can occur before they
      reach the compressor; i.e., there is no assumption that the
      compressor will receive only one copy of each packet).

   Framing

      The link layer must provide framing that makes it possible to
      distinguish frame boundaries and individual frames.

   Error detection/protection

      ROHC profiles should be designed to cope with residual errors in
      the headers delivered to the decompressor.  CRCs are used to
      detect decompression failures and to prevent or reduce damage
      propagation.  However, it is recommended that lower layers deploy
      error detection for ROHC headers and that ROHC headers with high
      residual error rates not be delivered.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.5.%20%20Compression%20and%20Master%20Sequence%20Number%20%28MSN%29"></a><a class="selflink" href="#section-4.5" name="section-4.5">4.5</a>.  Compression and Master Sequence Number (MSN)</span>

   Compression of header fields is based on the establishment of a
   function to a sequence number, called the master sequence number
   (MSN).  This function describes the change pattern of the field with
   respect to a change in the MSN.

   Change patterns include, for example, fields that increase
   monotonically or by a small value, fields that seldom change, and
   fields that remain unchanging for the entire lifetime of the packet
   flow, in which case the function to the MSN is equivalent to a
   constant value.

   The compressor first establishes functions for each of the header
   fields, and then reliably communicates the MSN.  When the change
   pattern of the field does not match the established function, i.e.,




<span class="grey">Sandlund, et al.             Standards Track                   [Page 14]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-15" id="page-15" name="page-15"> </a>
<span class="grey"><a href="rfc5795.html">RFC 5795</a>                     ROHC Framework                   March 2010</span>


   the existing function gives a result that is different from the field
   in the header being compressed, additional information can be sent to
   update the parameters of that function.

   The MSN is defined per profile.  It can be either derived directly
   from one of the fields of the protocol being compressed (e.g., the
   RTP SN [<a href="rfc5225.html" title='"RObust Header Compression Version 2 (ROHCv2): Profiles for RTP, UDP, IP, ESP and UDP-Lite"'>RFC5225</a>]), or it can be created and maintained by the
   compressor (e.g., the MSN for compression of UDP in profile 0x0102
   [<a href="rfc5225.html" title='"RObust Header Compression Version 2 (ROHCv2): Profiles for RTP, UDP, IP, ESP and UDP-Lite"'>RFC5225</a>] or the MSN in ROHC-TCP [<a href="rfc4996.html" title='"RObust Header Compression (ROHC): A Profile for TCP/IP (ROHC-TCP)"'>RFC4996</a>]).

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.6.%20%20Static%20and%20Dynamic%20Parts%20of%20a%20Context"></a><a class="selflink" href="#section-4.6" name="section-4.6">4.6</a>.  Static and Dynamic Parts of a Context</span>

   A compression context can be conceptually divided into two different
   parts, the static context and the dynamic context, each based on the
   properties of the fields that are being compressed.

   The static part includes the information necessary to compress and
   decompress the fields whose change behavior is classified as STATIC,
   STATIC-KNOWN, or STATIC-DEF (as described in <a href="#section-4.1">Section 4.1</a> above).

   The dynamic part includes the state maintained for all the other
   fields, i.e., those that are classified as CHANGING.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/5.%20%20The%20ROHC%20Framework%20%28Normative%29"></a><a class="selflink" href="#section-5" name="section-5">5</a>.  The ROHC Framework (Normative)</span>

   This section normatively defines the parts common to all ROHC
   profiles, i.e., the framework.  The framework specifies the
   requirements and functionality of the ROHC channel, including how to
   handle multiple compressed packet flows over the same channel.

   Finally, this section specifies encoding methods used in the packet
   formats that are common to all profiles.  These encoding methods may
   be reused within profile specifications for encoding fields in
   profile-specific parts of a packet format, without requiring their
   redefinition.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.1.%20%20The%20ROHC%20Channel"></a><a class="selflink" href="#section-5.1" name="section-5.1">5.1</a>.  The ROHC Channel</span>

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/5.1.1.%20%20Contexts%20and%20Context%20Identifiers"></a><a class="selflink" href="#section-5.1.1" name="section-5.1.1">5.1.1</a>.  Contexts and Context Identifiers</span>

   Associated with each compressed flow is a context.  The context is
   the state that the compressor and the decompressor maintain in order
   to correctly compress or decompress the headers of the packet in the
   flow.  Each context is identified using a CID.







<span class="grey">Sandlund, et al.             Standards Track                   [Page 15]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-16" id="page-16" name="page-16"> </a>
<span class="grey"><a href="rfc5795.html">RFC 5795</a>                     ROHC Framework                   March 2010</span>


   A context is considered to be a new context when the CID is
   associated with a profile for the first time since the creation of
   the ROHC channel, or when the CID gets associated from the reception
   of an IR (this does not apply to the IR-DYN) with a different profile
   than the profile in the context.

   Context information is conceptually kept in a table.  The context
   table is indexed using the CID, which is sent along with compressed
   headers and feedback information.

   The CID space can be either small, which means that CIDs can take the
   values 0 through 15, or large, which means that CIDs take values
   between 0 and 2^14 - 1 = 16383.  Whether the CID space is large or
   small MUST be established, possibly by negotiation, before any
   compressed packet may be sent over the ROHC channel.

   The CID space is distinct for each channel, i.e., CID 3 over channel
   A and CID 3 over channel B do not refer to the same context, even if
   the endpoints of A and B are the same nodes.  In particular, CIDs for
   any pair of ROHC channels are not related (two associated ROHC
   channels serving as feedback channels for one another do not even
   need to have CID spaces of the same size).

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/5.1.2.%20%20Per-Channel%20Parameters"></a><a class="selflink" href="#section-5.1.2" name="section-5.1.2">5.1.2</a>.  Per-Channel Parameters</span>

   The ROHC channel is based on a number of parameters that form part of
   the established channel state and the per-context state.  The state
   of the ROHC channel MUST be established before the first ROHC packet
   may be sent, which may be achieved using negotiation protocols
   provided by the link layer (see also [<a href="rfc3241.html" title='"Robust Header Compression (ROHC) over PPP"'>RFC3241</a>], which describes an
   option for negotiation of ROHC parameters for PPP).  This section
   describes some of this channel state information in an abstract way:

   LARGE_CIDS: Boolean; if false, the small CID representation (0 octets
   or 1 prefix octet, covering CID 0 to 15) is used; if true, the large
   CID representation (1 or 2 embedded CID octets covering CID 0 to
   16383) is used.  See also <a href="#section-5.1.1">Section 5.1.1</a> and <a href="#section-5.2.1.3">Section 5.2.1.3</a>.

   MAX_CID: Non-negative integer; highest CID number to be used by the
   compressor (note that this parameter is not coupled to, but in effect
   further constrained by, LARGE_CIDS).  This value represents an
   agreement by the decompressor that it can provide sufficient memory
   resources to host at least MAX_CID+1 contexts; the decompressor MUST
   maintain established contexts within this space until either the CID
   gets re-used by the establishment of a new context, or until the
   channel is taken down.





<span class="grey">Sandlund, et al.             Standards Track                   [Page 16]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-17" id="page-17" name="page-17"> </a>
<span class="grey"><a href="rfc5795.html">RFC 5795</a>                     ROHC Framework                   March 2010</span>


   PROFILES: Set of non-negative integers, where each integer indicates
   a profile supported by both the compressor and the decompressor.  A
   profile is identified by a 16-bit value, where the 8 LSB bits
   indicate the actual profile, and the 8 MSB bits indicate the variant
   of that profile.  The ROHC compressed header format identifies the
   profile used with only the 8 LSB bits; this means that if multiple
   variants of the same profile are available for a ROHC channel, the
   PROFILES set after negotiation MUST NOT include more than one variant
   of the same profile.  The compressor MUST NOT compress using a
   profile that is not in PROFILES.

   FEEDBACK_FOR: Optional reference to a ROHC channel in the opposite
   direction between the same compression endpoints.  If provided, this
   parameter indicates to which other ROHC channel any feedback sent on
   this ROHC channel refers (see [<a href="rfc3759.html" title='"RObust Header Compression (ROHC): Terminology and Channel Mapping Examples"'>RFC3759</a>]).

   MRRU: Non-negative integer.  Maximum Reconstructed Reception Unit.
   This is the size of the largest reconstructed unit in octets that the
   decompressor is expected to reassemble from segments (see
   <a href="#section-5.2.5">Section 5.2.5</a>).  This size includes the segmentation CRC.  If MRRU is
   negotiated to be 0, segmentation MUST NOT be used on the channel, and
   received segments MUST be discarded by the decompressor.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/5.1.3.%20%20Persistence%20of%20Decompressor%20Contexts"></a><a class="selflink" href="#section-5.1.3" name="section-5.1.3">5.1.3</a>.  Persistence of Decompressor Contexts</span>

   As part of the negotiated channel parameters, the compressor and
   decompressor have through the MAX_CID parameter agreed on the highest
   context identification (CID) number to be used.  By agreeing on the
   MAX_CID, the decompressor also agrees to provide memory resources to
   host at least MAX_CID+1 contexts, and an established context with a
   CID within this negotiated space SHOULD be kept by the decompressor
   until either the CID gets re-used, or the channel is taken down or
   re-negotiated.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.2.%20%20ROHC%20Packets%20and%20Packet%20Types"></a><a class="selflink" href="#section-5.2" name="section-5.2">5.2</a>.  ROHC Packets and Packet Types</span>

   This section uses the following convention in the diagrams when
   representing various ROHC packet types, formats, and fields:

         - colons ":" indicate that the part is optional
         - slashes "/" indicate variable length

   The ROHC packet type indication scheme has been designed to provide
   optional padding, a feedback packet type, an optional Add-CID octet
   (which includes 4 bits of CID), and a simple segmentation and
   reassembly mechanism.





<span class="grey">Sandlund, et al.             Standards Track                   [Page 17]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-18" id="page-18" name="page-18"> </a>
<span class="grey"><a href="rfc5795.html">RFC 5795</a>                     ROHC Framework                   March 2010</span>


   The following packet types are reserved at the ROHC framework level:

         11100000 : Padding
         1110nnnn : Add-CID octet (nnnn=CID with values 0x1 through 0xF)
         11110    : Feedback
         11111000 : IR-DYN packet
         1111110  : IR packet
         1111111  : Segment

   Other packet types can be defined and used by individual profiles:

         0        : available (not reserved by ROHC framework)
         10       : available (not reserved by ROHC framework)
         110      : available (not reserved by ROHC framework)
         1111101  : available (not reserved by ROHC framework)
         11111001 : available (not reserved by ROHC framework)

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/5.2.1.%20%20General%20Format%20of%20ROHC%20Packets"></a><a class="selflink" href="#section-5.2.1" name="section-5.2.1">5.2.1</a>.  General Format of ROHC Packets</span>

   A ROHC packet has the following general format:

       --- --- --- --- --- --- --- ---
      :           Padding             :
       --- --- --- --- --- --- --- ---
      :           Feedback            :
       --- --- --- --- --- --- --- ---
      :            Header             :
       --- --- --- --- --- --- --- ---
      :           Payload             :
       --- --- --- --- --- --- --- ---

   Padding: Any number (zero or more) of padding octets, where the
   format of a padding octet is as defined in <a href="#section-5.2.1.1">Section 5.2.1.1</a>.

   Feedback: Any number (zero or more) of feedback elements, where the
   format of a feedback element is as defined in <a href="#section-5.2.4.1">Section 5.2.4.1</a>.

   Header: Either a profile-specific CO header (see <a href="#section-5.2.1.3">Section 5.2.1.3</a>), an
   IR or IR-DYN header (see <a href="#section-5.2.2">Section 5.2.2</a>), or a ROHC Segment (see
   <a href="#section-5.2.5">Section 5.2.5</a>).  There can be at most one Header in a ROHC packet,
   but it may also be omitted (if the packet contains Feedback only).

   Payload: Corresponds to zero or more octets of payload from the
   uncompressed packet, starting with the first octet in the
   uncompressed packet after the last header compressible by the current
   profile.

   At least one of Feedback or Header MUST be present.



<span class="grey">Sandlund, et al.             Standards Track                   [Page 18]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-19" id="page-19" name="page-19"> </a>
<span class="grey"><a href="rfc5795.html">RFC 5795</a>                     ROHC Framework                   March 2010</span>


<span class="h5"><a class="dashAnchor" name="//apple_ref/Section/5.2.1.1.%20%20Format%20of%20the%20Padding%20Octet"></a><a class="selflink" href="#section-5.2.1.1" name="section-5.2.1.1">5.2.1.1</a>.  Format of the Padding Octet</span>

   Padding octet:

        0   1   2   3   4   5   6   7
      +---+---+---+---+---+---+---+---+
      | 1   1   1   0   0   0   0   0 |
      +---+---+---+---+---+---+---+---+

   Note: The Padding octet MUST NOT be interpreted as an Add-CID octet
   for CID 0.

<span class="h5"><a class="dashAnchor" name="//apple_ref/Section/5.2.1.2.%20%20Format%20of%20the%20Add-CID%20Octet"></a><a class="selflink" href="#section-5.2.1.2" name="section-5.2.1.2">5.2.1.2</a>.  Format of the Add-CID Octet</span>

   Add-CID octet:

        0   1   2   3   4   5   6   7
      +---+---+---+---+---+---+---+---+
      | 1   1   1   0 |      CID      |
      +---+---+---+---+---+---+---+---+

   CID: 0x1 through 0xF indicates CIDs 1 through 15.

   Note: The Padding octet looks like an Add-CID octet for CID 0.

<span class="h5"><a class="dashAnchor" name="//apple_ref/Section/5.2.1.3.%20%20General%20Format%20of%20Header"></a><a class="selflink" href="#section-5.2.1.3" name="section-5.2.1.3">5.2.1.3</a>.  General Format of Header</span>

   All ROHC packet types have the following general Header format:

        0              x-1  x       7
       --- --- --- --- --- --- --- ---
      :         Add-CID octet         :  if CID 1-15 and small CIDs
      +--- --- --- --- ---+--- --- ---+
      | type indication   |   body    |  1 octet (8-x bits of body)
      +--- --- --- --- ---+--- --- ---+
      :                               :
      /    0, 1, or 2 octets of CID   /  1 or 2 octets if large CIDs
      :                               :
      +---+---+---+---+---+---+---+---+
      /             body              /  variable length
      +---+---+---+---+---+---+---+---+

   type indication: ROHC packet type.

   body: Interpreted according to the packet type indication and CID
   information, as defined by individual profiles.





<span class="grey">Sandlund, et al.             Standards Track                   [Page 19]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-20" id="page-20" name="page-20"> </a>
<span class="grey"><a href="rfc5795.html">RFC 5795</a>                     ROHC Framework                   March 2010</span>


   Thus, the header either starts with a packet type indication or has a
   packet type indication immediately following an Add-CID octet.

   When the ROHC channel is configured with a small CID space:

   o   If an Add-CID immediately precedes the packet type indication,
       the packet has the CID of the Add-CID; otherwise, it has CID 0.

   o   A small CID with the value 0 is represented using zero bits;
       therefore, a flow associated with CID 0 has no CID overhead in
       the compressed header.  In such case, Header starts with a packet
       type indication.

   o   A small CID with a value from 1 to 15 is represented using the
       Add-CID octet as described above.  The Header starts with the
       Add-CID octet, followed by a packet type indication.

   o   There is no large CID in the Header.

   When the ROHC channel is configured with a large CID space:

   o   The large CID is always present and is represented using the
       encoding scheme of <a href="#section-5.3.2">Section 5.3.2</a>, limited to two octets.  In this
       case, the Header starts with a packet type indication.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/5.2.2.%20%20Initialization%20and%20Refresh%20%28IR%29%20Packet%20Types"></a><a class="selflink" href="#section-5.2.2" name="section-5.2.2">5.2.2</a>.  Initialization and Refresh (IR) Packet Types</span>

   IR packet types contain a profile identifier, which determines how
   the rest of the header is to be interpreted.  They also associate a
   profile with a context.  The stored profile parameter further
   determines the syntax and semantics of the packet type identifiers
   and packet types used with a specific context.

   The IR and IR-DYN packets always update the context for all context-
   updating fields carried in the header.  They never clear the context,
   except when initializing a new context (see <a href="#section-5.1.1">Section 5.1.1</a>), or unless
   the profile indicated in the Profile field specifies otherwise.

<span class="h5"><a class="dashAnchor" name="//apple_ref/Section/5.2.2.1.%20%20ROHC%20IR%20Header%20Format"></a><a class="selflink" href="#section-5.2.2.1" name="section-5.2.2.1">5.2.2.1</a>.  ROHC IR Header Format</span>

   The IR header associates a CID with a profile, and typically also
   initializes the context.  It can typically also refresh all (or parts
   of) the context.  For IR, Header has the following general format:








<span class="grey">Sandlund, et al.             Standards Track                   [Page 20]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-21" id="page-21" name="page-21"> </a>
<span class="grey"><a href="rfc5795.html">RFC 5795</a>                     ROHC Framework                   March 2010</span>


        0   1   2   3   4   5   6   7
       --- --- --- --- --- --- --- ---
      :         Add-CID octet         :  if CID 1-15 and small CID
      +---+---+---+---+---+---+---+---+
      | 1   1   1   1   1   1   0 | x |  IR type octet
      +---+---+---+---+---+---+---+---+
      :                               :
      /      0-2 octets of CID        /  1 or 2 octets if large CIDs
      :                               :
      +---+---+---+---+---+---+---+---+
      |            Profile            |  1 octet
      +---+---+---+---+---+---+---+---+
      |              CRC              |  1 octet
      +---+---+---+---+---+---+---+---+
      |                               |
      / profile-specific information  /  variable length
      |                               |
      +---+---+---+---+---+---+---+---+

   x: Profile-specific information.  Interpreted according to the
   profile indicated in the Profile field of the IR header.

   Profile: The profile associated with the CID.  In the IR header, the
   profile identifier is abbreviated to the 8 least significant bits
   (see <a href="#section-5.1.2">Section 5.1.2</a>).

   CRC: 8-bit CRC (see <a href="#section-5.3.1.1">Section 5.3.1.1</a>).

   Profile-specific information: The content of this part of the IR
   header is defined by the individual profiles.  It is interpreted
   according to the profile indicated in the Profile field.

<span class="h5"><a class="dashAnchor" name="//apple_ref/Section/5.2.2.2.%20%20ROHC%20IR-DYN%20Header%20Format"></a><a class="selflink" href="#section-5.2.2.2" name="section-5.2.2.2">5.2.2.2</a>.  ROHC IR-DYN Header Format</span>

   In contrast to the IR header, the IR-DYN header can never initialize
   a non-initialized context.  However, it can redefine what profile is
   associated with a context, if the profile indicated in the IR-DYN
   header allows this.  Thus, this packet type is also reserved at the
   framework level.  The IR-DYN header typically also initializes or
   refreshes parts of a context.  For IR-DYN, Header has the following
   general format:










<span class="grey">Sandlund, et al.             Standards Track                   [Page 21]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-22" id="page-22" name="page-22"> </a>
<span class="grey"><a href="rfc5795.html">RFC 5795</a>                     ROHC Framework                   March 2010</span>


        0   1   2   3   4   5   6   7
       --- --- --- --- --- --- --- ---
      :         Add-CID octet         :  if CID 1-15 and small CID
      +---+---+---+---+---+---+---+---+
      | 1   1   1   1   1   0   0   0 |  IR-DYN type octet
      +---+---+---+---+---+---+---+---+
      :                               :
      /      0-2 octets of CID        /  1 or 2 octets if large CIDs
      :                               :
      +---+---+---+---+---+---+---+---+
      |            Profile            |  1 octet
      +---+---+---+---+---+---+---+---+
      |              CRC              |  1 octet
      +---+---+---+---+---+---+---+---+
      |                               |
      / profile-specific information  /  variable length
      |                               |
      +---+---+---+---+---+---+---+---+

   Profile: The profile associated with the CID.  This is abbreviated in
   the same way as in IR packets.

   CRC: 8-bit CRC (see <a href="#section-5.3.1.1">Section 5.3.1.1</a>).

   Profile-specific information: The content of this part of the IR-DYN
   header is defined by the individual profiles.  It is interpreted
   according to the profile indicated in the Profile field.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/5.2.3.%20%20ROHC%20Initial%20Decompressor%20Processing"></a><a class="selflink" href="#section-5.2.3" name="section-5.2.3">5.2.3</a>.  ROHC Initial Decompressor Processing</span>

   Initially, all contexts are in no context state.  Thus, all packets
   referencing a non-initialized context, except packets that have
   enough information on the static fields, cannot be decompressed by
   the decompressor.

   When the decompressor receives a packet of type IR, the profile
   indicated in the IR packet determines how it is to be processed.

   o  If the 8-bit CRC fails to verify the integrity of the header, the
      packet MUST NOT be decompressed and delivered to upper layers.  If
      a profile is indicated in the context, the logic of that profile
      determines what, if any, feedback is to be sent.  If no profile is
      noted in the context, the logic used to determine what, if any,
      feedback to send is up to the implementation.  However, it may be
      suitable to take no further actions, as any part of the IR header
      covered by the CRC may have caused the failure.





<span class="grey">Sandlund, et al.             Standards Track                   [Page 22]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-23" id="page-23" name="page-23"> </a>
<span class="grey"><a href="rfc5795.html">RFC 5795</a>                     ROHC Framework                   March 2010</span>


   When the decompressor receives a packet of type IR-DYN, the profile
   indicated in the IR-DYN packet determines how it is to be processed.

   o  If the 8-bit CRC fails to verify the integrity of the header, the
      packet MUST NOT be decompressed and delivered to upper layers.  If
      a profile is indicated in the context, the logic of that profile
      determines what, if any, feedback is to be sent.  If no profile is
      noted in the context, the logic used to determine what, if any,
      feedback to send is up to the implementation.  However, it may be
      suitable to take no further actions, as any part of the IR-DYN
      header covered by the CRC may have caused the failure.

   o  If the context has not already been initialized, the packet MUST
      NOT be decompressed and delivered to upper layers.  The logic of
      the profile indicated in the IR-DYN header (if verified by the
      8-bit CRC), determines what, if any, feedback is to be sent.

   If a parsing error occurs for any packet type, the decompressor MUST
   discard the packet without further processing.  For example, a CID
   field is present in the compressed header when the large CID space is
   used for the ROHC channel, and the field is coded using the self-
   describing variable-length encoding of <a href="#section-5.3.2">Section 5.3.2</a>; if the field
   starts with 110 or 111, this would generate a parsing error for the
   decompressor because this field must not be encoded with a size
   larger than 2 octets.

   It is RECOMMENDED that profiles disallow the decompressor to make a
   decompression attempt for packets carrying only a 3-bit CRC after it
   has invalidated some or all of the entire dynamic context, until a
   packet that contains sufficient information on the dynamic fields is
   received, decompressed, and successfully verified by a 7- or 8-bit
   CRC.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/5.2.4.%20%20ROHC%20Feedback"></a><a class="selflink" href="#section-5.2.4" name="section-5.2.4">5.2.4</a>.  ROHC Feedback</span>

   Feedback carries information from the decompressor to the compressor.
   Feedback can be sent over a ROHC channel that operates in the same
   direction as the feedback.

   The general ROHC packet format allows transport of feedback using
   interspersion or piggybacking (see [<a href="rfc3759.html" title='"RObust Header Compression (ROHC): Terminology and Channel Mapping Examples"'>RFC3759</a>]), or a combination of
   both, over a ROHC channel.  This is facilitated by the following
   properties:

   Reserved packet type:

      A feedback packet type is reserved at the framework level.  The
      packet type can carry variable-length feedback information.



<span class="grey">Sandlund, et al.             Standards Track                   [Page 23]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-24" id="page-24" name="page-24"> </a>
<span class="grey"><a href="rfc5795.html">RFC 5795</a>                     ROHC Framework                   March 2010</span>


   CID information:

      The feedback information sent on a particular channel is passed
      to, and interpreted by, the compressor associated with feedback on
      that channel.  Thus, each feedback element contains CID
      information from the channel for which the feedback is sent.  The
      ROHC feedback scheme thus requires that a channel carries feedback
      to at most one compressor.  How a compressor is associated with
      the feedback for a particular channel is outside the scope of this
      specification.  See also [<a href="rfc3759.html" title='"RObust Header Compression (ROHC): Terminology and Channel Mapping Examples"'>RFC3759</a>].

   Length information:

      The length of a feedback element can be determined by examining
      the first few octets of the feedback.  This enables piggybacking
      of feedback, and also the concatenation of more than one feedback
      element in a packet.  The length information thus decouples the
      decompressor from the associated same-side compressor, as the
      decompressor can extract the feedback information from the
      compressed header without parsing its content and hand over the
      extracted information.

   The association between compressor-decompressor pairs operating in
   opposite directions, for the purpose of exchanging piggyback and/or
   interspersed feedback, SHOULD be maintained for the lifetime of the
   ROHC channel.  Otherwise, it is RECOMMENDED that the compressor be
   notified if the feedback channel is no longer available: the
   compressor SHOULD then restart compression by creating a new context
   for each packet flow, and SHOULD use a CID value that was not
   previously associated with the profile used to compress the flow.

<span class="h5"><a class="dashAnchor" name="//apple_ref/Section/5.2.4.1.%20%20ROHC%20Feedback%20Format"></a><a class="selflink" href="#section-5.2.4.1" name="section-5.2.4.1">5.2.4.1</a>.  ROHC Feedback Format</span>

   ROHC defines three different categories of feedback messages:
   acknowledgment (ACK), negative ACK (NACK), and NACK for the entire
   context (STATIC-NACK).  Other types of information may be defined in
   profile-specific feedback information.

      ACK: Acknowledges successful decompression of a packet.  Indicates
      that the decompressor considers its context to be valid.

      NACK: Indicates that the decompressor considers some or all of the
      dynamic part of its context invalid.

      STATIC-NACK : Indicates that the decompressor considers its entire
      static context invalid, or that it has not been established.





<span class="grey">Sandlund, et al.             Standards Track                   [Page 24]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-25" id="page-25" name="page-25"> </a>
<span class="grey"><a href="rfc5795.html">RFC 5795</a>                     ROHC Framework                   March 2010</span>


   Feedback sent on a ROHC channel consists of one or more concatenated
   feedback elements, where each feedback element has the following
   format:

       0   1   2   3   4   5   6   7
     +---+---+---+---+---+---+---+---+
     | 1   1   1   1   0 |   Code    |  feedback type
     +---+---+---+---+---+---+---+---+
     :             Size              :  if Code = 0
     +---+---+---+---+---+---+---+---+
     :         Add-CID octet         :  if for small CIDs and (CID != 0)
     +---+---+---+---+---+---+---+---+
     :                               :
     /           large CID           /  1-2 octets if for large CIDs
     :                               :
     +---+---+---+---+---+---+---+---+
     /         FEEDBACK data         /  variable length
     +---+---+---+---+---+---+---+---+

   Code:

      0 indicates that a Size octet is present.

      1-7 indicates the total size of the FEEDBACK data field and the
      CID field (if any), in octets.

   Size: Indicates the total size of the FEEDBACK data field and the CID
   field (if any), in octets.

   FEEDBACK data: FEEDBACK-1 or FEEDBACK-2 (see below).

   CID information in a feedback element indicates the context for which
   feedback is sent.  The LARGE_CIDS parameter that controls whether a
   large CID is present is taken from the channel state of the receiving
   compressor's channel, not from the state of the channel carrying the
   feedback.

   The large CID field, if present, is encoded according to
   <a href="#section-5.3.2">Section 5.3.2</a>, and it MUST NOT be encoded using more than 2 octets.

   The FEEDBACK data field can have either of the following two formats:

   FEEDBACK-1:

        0   1   2   3   4   5   6   7
      +---+---+---+---+---+---+---+---+
      | profile-specific information  |  1 octet
      +---+---+---+---+---+---+---+---+



<span class="grey">Sandlund, et al.             Standards Track                   [Page 25]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-26" id="page-26" name="page-26"> </a>
<span class="grey"><a href="rfc5795.html">RFC 5795</a>                     ROHC Framework                   March 2010</span>


   FEEDBACK-2:

        0   1   2   3   4   5   6   7
      +---+---+---+---+---+---+---+---+
      |Acktype|                       |
      +---+---+   profile-specific    /  at least 2 octets
      /             information       |
      +---+---+---+---+---+---+---+---+


      Acktype:  0 = ACK
                1 = NACK
                2 = STATIC-NACK
                3 is reserved (MUST NOT be used.  Otherwise unparsable.)

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/5.2.5.%20%20ROHC%20Segmentation"></a><a class="selflink" href="#section-5.2.5" name="section-5.2.5">5.2.5</a>.  ROHC Segmentation</span>

   ROHC defines a simple segmentation protocol.  The compressor may
   perform segmentation, e.g., to accommodate packets that are larger
   than a specific size configured for the channel.

<span class="h5"><a class="dashAnchor" name="//apple_ref/Section/5.2.5.1.%20%20Segmentation%20Usage%20Considerations"></a><a class="selflink" href="#section-5.2.5.1" name="section-5.2.5.1">5.2.5.1</a>.  Segmentation Usage Considerations</span>

   The ROHC segmentation protocol is not particularly efficient.  It is
   not intended to replace link-layer segmentation functions; these
   SHOULD be used whenever available and efficient for the task at hand.

   The ROHC segmentation protocol has been designed with an assumption
   of in-order delivery of packets between the compressor and the
   decompressor, using only a CRC for error detection, and no sequence
   numbers.  If in-order delivery cannot be guaranteed, ROHC
   segmentation MUST NOT be used.

   The segmentation protocol also assumes that all segments of a ROHC
   packet corresponding to one context are received without interference
   from other ROHC packets over the channel, including any ROHC packet
   corresponding to a different context.  Based on this assumption,
   segments do not carry CID information, and therefore cannot be
   associated with a specific context until all segments have been
   received and the whole unit has been reconstructed.

<span class="h5"><a class="dashAnchor" name="//apple_ref/Section/5.2.5.2.%20%20Segmentation%20Protocol"></a><a class="selflink" href="#section-5.2.5.2" name="section-5.2.5.2">5.2.5.2</a>.  Segmentation Protocol</span>

   ROHC segmentation is applied to the combination of the Header and the
   Payload fields of the ROHC packet, as defined in <a href="#section-5.2.1">Section 5.2.1</a>.






<span class="grey">Sandlund, et al.             Standards Track                   [Page 26]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-27" id="page-27" name="page-27"> </a>
<span class="grey"><a href="rfc5795.html">RFC 5795</a>                     ROHC Framework                   March 2010</span>


   Segment format:

        0   1   2   3   4   5   6   7
      +---+---+---+---+---+---+---+---+
      | 1   1   1   1   1   1   1 | F |  segment type
      +---+---+---+---+---+---+---+---+
      /           Segment             /  variable length
      +---+---+---+---+---+---+---+---+

   F: Final bit.  If set, it indicates that this is the last segment of
   a reconstructed unit.

   Padding and/or Feedback may precede the segment type octet.  There is
   no per-segment CID, but CID information is of course part of the
   reconstructed unit.  The reconstructed unit MUST NOT contain padding,
   segments, or feedback.

   When a final segment is received, the decompressor reassembles the
   segment carried in this packet and any non-final segments that
   immediately preceded it into a single reconstructed unit, in the
   order they were received.  All segments for one reconstructed unit
   have to be received consecutively and in the correct order by the
   decompressor.  If a non-segment ROHC packet directly follows a non-
   final segment, the reassembly of the current reconstructed unit is
   aborted and the decompressor MUST discard the non-final segments so
   far received on this channel.

   Reconstructed unit:

        0   1   2   3   4   5   6   7
      +---+---+---+---+---+---+---+---+
      /            Header             /
      +---+---+---+---+---+---+---+---+
      :            Payload            :
      +---+---+---+---+---+---+---+---+
      /              CRC              /  4 octets
      +---+---+---+---+---+---+---+---+

   Header: See <a href="#section-5.2.1">Section 5.2.1</a>

   Payload: See <a href="#section-5.2.1">Section 5.2.1</a>

   CRC: 32-bit CRC computed using the polynomial of <a href="#section-5.3.1.4">Section 5.3.1.4</a>








<span class="grey">Sandlund, et al.             Standards Track                   [Page 27]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-28" id="page-28" name="page-28"> </a>
<span class="grey"><a href="rfc5795.html">RFC 5795</a>                     ROHC Framework                   March 2010</span>


   If the reconstructed unit is 4 octets or less, or if the CRC fails,
   or if it is larger than the channel parameter MRRU (see
   <a href="#section-5.1.2">Section 5.1.2</a>), the reconstructed unit MUST be discarded by the
   decompressor.  If the CRC succeeds, the reconstructed unit can be
   further processed.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.3.%20%20General%20Encoding%20Methods"></a><a class="selflink" href="#section-5.3" name="section-5.3">5.3</a>.  General Encoding Methods</span>

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/5.3.1.%20%20Header%20Compression%20CRCs%2C%20Coverage%2C%20and%20Polynomials"></a><a class="selflink" href="#section-5.3.1" name="section-5.3.1">5.3.1</a>.  Header Compression CRCs, Coverage, and Polynomials</span>

   This section describes how to calculate the CRCs used by ROHC.  For
   all CRCs, the algorithm used to calculate the CRC is the same as the
   one used in [<a href="rfc1662.html" title='"PPP in HDLC-like Framing"'>RFC1662</a>], defined in <a href="#appendix-A">Appendix A</a> of this document, with
   the polynomials specified in subsequent sections.

<span class="h5"><a class="dashAnchor" name="//apple_ref/Section/5.3.1.1.%20%208-bit%20CRC%20in%20IR%20and%20IR-DYN%20Headers"></a><a class="selflink" href="#section-5.3.1.1" name="section-5.3.1.1">5.3.1.1</a>.  8-bit CRC in IR and IR-DYN Headers</span>

   The coverage for the 8-bit CRC in the IR and IR-DYN headers is
   profile-dependent, but it MUST cover at least the initial part of the
   header ending with the Profile field, including the CID or an Add-CID
   octet.  Feedback and padding are not part of Header (<a href="#section-5.2.1">Section 5.2.1</a>)
   and are thus not included in the CRC calculation.  As a rule of thumb
   for profile specifications, any other information that initializes
   the decompressor context SHOULD also be covered by a CRC.

   More specifically, the 8-bit CRC does not cover only and entirely the
   original uncompressed header; therefore, it does not provide the
   means for the decompressor to verify a decompression attempt, or the
   means to verify the correctness of the entire decompressor context.
   However, when successful, it does provide enough robustness for the
   decompressor to update its context with the information carried
   within the IR or the IR-DYN header.

   The CRC polynomial for the 8-bit CRC is:

         C(x) = 1 + x + x^2 + x^8

   When computing the CRC, the CRC field in the header is set to zero,
   and the initial content of the CRC register is set to all 1's.

<span class="h5"><a class="dashAnchor" name="//apple_ref/Section/5.3.1.2.%20%203-bit%20CRC%20in%20Compressed%20Headers"></a><a class="selflink" href="#section-5.3.1.2" name="section-5.3.1.2">5.3.1.2</a>.  3-bit CRC in Compressed Headers</span>

   The 3-bit CRC in compressed headers is calculated over all octets of
   the entire original header, before compression, in the following
   manner.

   The initial content of the CRC register is set to all 1's.




<span class="grey">Sandlund, et al.             Standards Track                   [Page 28]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-29" id="page-29" name="page-29"> </a>
<span class="grey"><a href="rfc5795.html">RFC 5795</a>                     ROHC Framework                   March 2010</span>


   The polynomial for the 3-bit CRC is:

         C(x) = 1 + x + x^3

   The purpose of the 3-bit CRC is to provide the means for the
   decompressor to verify the outcome of a decompression attempt for
   small compressed headers, and to detect context damage based on
   aggregated probability over a number of decompression attempts.
   However, it is too weak to provide enough success guarantees from the
   decompression of one single header.  Therefore, compressed headers
   carrying a 3-bit CRC are normally not suitable to perform context
   repairs at the decompressor; hence, profiles should refrain from
   allowing decompression of such a header when some or the entire
   decompressor context is assumed invalid.

<span class="h5"><a class="dashAnchor" name="//apple_ref/Section/5.3.1.3.%20%207-bit%20CRC%20in%20Compressed%20Headers"></a><a class="selflink" href="#section-5.3.1.3" name="section-5.3.1.3">5.3.1.3</a>.  7-bit CRC in Compressed Headers</span>

   The 7-bit CRC in compressed headers is calculated over all octets of
   the entire original header, before compression, in the following
   manner.

   The initial content of the CRC register is set to all 1's.

   The polynomial for the 7-bit CRC is:

         C(x) = 1 + x + x^2 + x^3 + x^6 + x^7

   The purpose of the 7-bit CRC is to provide the means for the
   decompressor to verify the outcome of a decompression attempt for a
   larger compressed header, and to provide enough protection to
   validate a context repair at the decompressor.  The 7-bit CRC is
   strong enough to assume a repair to be successful from the
   decompression of one single header; hence, profiles may allow
   decompression of a header carrying a 7-bit CRC when some of the
   decompressor context is assumed invalid.

<span class="h5"><a class="dashAnchor" name="//apple_ref/Section/5.3.1.4.%20%2032-bit%20Segmentation%20CRC"></a><a class="selflink" href="#section-5.3.1.4" name="section-5.3.1.4">5.3.1.4</a>.  32-bit Segmentation CRC</span>

   The 32-bit CRC is used by the segmentation scheme to verify the
   reconstructed unit, and it is thus calculated over the segmented
   unit, i.e., over the Header and the Payload fields of the ROHC
   packet.

   The initial content of the CRC register is set to all 1's.







<span class="grey">Sandlund, et al.             Standards Track                   [Page 29]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-30" id="page-30" name="page-30"> </a>
<span class="grey"><a href="rfc5795.html">RFC 5795</a>                     ROHC Framework                   March 2010</span>


   The polynomial for the 32-bit CRC is:

         C(x) = x^0 + x^1 + x^2 + x^4 + x^5 + x^7 + x^8 + x^10 +
                x^11 + x^12 + x^16 + x^22 + x^23 + x^26 + x^32

   The purpose of the 32-bit CRC is to verify the reconstructed unit.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/5.3.2.%20%20Self-Describing%20Variable-Length%20Values"></a><a class="selflink" href="#section-5.3.2" name="section-5.3.2">5.3.2</a>.  Self-Describing Variable-Length Values</span>

   The values of many fields and compression parameters can vary widely.
   To optimize the transfer of such values, a variable number of octets
   are used to encode them.  The first few bits of the first octet
   determine the number of octets used:

      First bit is 0: 1 octet.
               7 bits transferred.
               Up to 127 decimal.
               Encoded octets in hexadecimal: 00 to 7F

      First bits are 10: 2 octets.
               14 bits transferred.
               Up to 16 383 decimal.
               Encoded octets in hexadecimal: 80 00 to BF FF

      First bits are 110: 3 octets.
               21 bits transferred.
               Up to 2 097 151 decimal.
               Encoded octets in hexadecimal: C0 00 00 to DF FF FF

      First bits are 111: 4 octets.
               29 bits transferred.
               Up to 536 870 911 decimal.
               Encoded octets in hexadecimal: E0 00 00 00 to FF FF FF FF

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.4.%20%20ROHC%20UNCOMPRESSED%20--%20No%20Compression"></a><a class="selflink" href="#section-5.4" name="section-5.4">5.4</a>.  ROHC UNCOMPRESSED -- No Compression  </span>(Profile 0x0000)

   This section describes the uncompressed ROHC profile.  The profile
   identifier for this profile is 0x0000.

   Profile 0x0000 provides a way to send IP packets without compressing
   them.  This can be used for any packet for which a compression
   profile is not available in the set of profiles supported by the ROHC
   channel, or for which compression is not desirable for some reason.








<span class="grey">Sandlund, et al.             Standards Track                   [Page 30]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-31" id="page-31" name="page-31"> </a>
<span class="grey"><a href="rfc5795.html">RFC 5795</a>                     ROHC Framework                   March 2010</span>


   After initialization, the only overhead for sending packets using
   Profile 0x0000 is the size of the CID.  When uncompressed packets are
   frequent, Profile 0x0000 should be associated with a CID the size of
   zero or one octet.  Profile 0x0000 SHOULD be associated with at most
   one CID.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/5.4.1.%20%20IR%20Packet"></a><a class="selflink" href="#section-5.4.1" name="section-5.4.1">5.4.1</a>.  IR Packet</span>

   The initialization and refresh packet (IR packet) for Profile 0x0000
   has the following Header format:

        0   1   2   3   4   5   6   7
       --- --- --- --- --- --- --- ---
      :         Add-CID octet         : if for small CIDs and (CID != 0)
      +---+---+---+---+---+---+---+---+
      | 1   1   1   1   1   1   0 |res|
      +---+---+---+---+---+---+---+---+
      :                               :
      /    0-2 octets of CID info     / 1-2 octets if for large CIDs
      :                               :
      +---+---+---+---+---+---+---+---+
      |         Profile = 0x00        | 1 octet
      +---+---+---+---+---+---+---+---+
      |              CRC              | 1 octet
      +---+---+---+---+---+---+---+---+

   res: MUST be set to zero; otherwise, the decompressor MUST discard
   the packet.

   Profile: 0x00

   CRC: 8-bit CRC, computed using the polynomial of <a href="#section-5.3.1.1">Section 5.3.1.1</a>.
   The CRC covers the first octet of the IR Header through the Profile
   octet of the IR Header, i.e., it does not cover the CRC itself.
   Neither does it cover any preceding Padding or Feedback, nor the
   Payload.

   For the IR packet, Payload has the following format:

       --- --- --- --- --- --- --- ---
      :                               : (optional)
      /           IP packet           / variable length
      :                               :
       --- --- --- --- --- --- --- ---

   IP packet: An uncompressed IP packet may be included in the IR
   packet.  The decompressor determines if the IP packet is present by
   considering the length of the IR packet.



<span class="grey">Sandlund, et al.             Standards Track                   [Page 31]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-32" id="page-32" name="page-32"> </a>
<span class="grey"><a href="rfc5795.html">RFC 5795</a>                     ROHC Framework                   March 2010</span>


<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/5.4.2.%20%20Normal%20Packet"></a><a class="selflink" href="#section-5.4.2" name="section-5.4.2">5.4.2</a>.  Normal Packet</span>

   A Normal packet is a normal IP packet plus CID information.  For the
   Normal Packet, the following format corresponds to the Header and
   Payload (as defined in <a href="#section-5.2.1">Section 5.2.1</a>):

        0   1   2   3   4   5   6   7
       --- --- --- --- --- --- --- ---
      :         Add-CID octet         : if for small CIDs and (CID != 0)
      +---+---+---+---+---+---+---+---+
      |   first octet of IP packet    |
      +---+---+---+---+---+---+---+---+
      :                               :
      /    0-2 octets of CID info     / 1-2 octets if for large CIDs
      :                               :
      +---+---+---+---+---+---+---+---+
      |                               |
      /       rest of IP packet       / variable length
      |                               |
      +---+---+---+---+---+---+---+---+

   Note that the first octet of the IP packet starts with the bit
   pattern 0100 (IPv4) or 0110 (IPv6).  This does not conflict with any
   reserved packet types.

   When the channel uses small CIDs, and profile 0x0000 is associated
   with a CID &gt; 0, an Add-CID octet precedes the IP packet.  When the
   channel uses large CIDs, the CID is placed so that it starts at the
   second octet of the combined Header/Payload format above.

   A Normal Packet may carry Padding and/or Feedback as any other ROHC
   packet, preceding the combined Header/Payload.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/5.4.3.%20%20Context%20Initialization"></a><a class="selflink" href="#section-5.4.3" name="section-5.4.3">5.4.3</a>.  Context Initialization</span>

   The compressor initializes the static context associated with the
   UNCOMPRESSED profile by sending IR packets (see <a href="#section-5.4.1">Section 5.4.1</a>).
   During context initialization, it is RECOMMENDED that the compressor
   sends IR packets until it is reasonably confident that the
   decompressor has successfully received at least one IR packet.  For
   example, this confidence can be based on feedback from the
   decompressor, or on knowledge of the characteristics of the link.

   The compressor SHOULD periodically transmit IR packets for a context
   associated with the UNCOMPRESSED profile, at least until it receives
   feedback from the decompressor for that context.  The compressor MAY
   stop the periodic sending of IR packets once it has received
   feedback.



<span class="grey">Sandlund, et al.             Standards Track                   [Page 32]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-33" id="page-33" name="page-33"> </a>
<span class="grey"><a href="rfc5795.html">RFC 5795</a>                     ROHC Framework                   March 2010</span>


<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/5.4.4.%20%20Decompressor%20Operation"></a><a class="selflink" href="#section-5.4.4" name="section-5.4.4">5.4.4</a>.  Decompressor Operation</span>

   When an IR packet is received, the decompressor first validates its
   header using the 8-bit CRC.

   o   If the header fails validation, the decompressor MUST NOT deliver
       the IP packet to upper layers.

   o   If the header is successfully validated, the decompressor

       1.  initializes the context if it has no valid context for the
           given CID already associated to the specified profile,

       2.  delivers the IP packet to upper layers if present,

       3.  MAY send an ACK.

   When any other packet is received while the decompressor has no
   context, it is discarded without further action.

   When a Normal packet is received and the decompressor has a valid
   context, the IP packet is extracted and delivered to upper layers.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/5.4.5.%20%20Feedback"></a><a class="selflink" href="#section-5.4.5" name="section-5.4.5">5.4.5</a>.  Feedback</span>

   The only kind of feedback defined by Profile 0x0000 is ACK, using the
   FEEDBACK-1 format of <a href="#section-5.2.4.1">Section 5.2.4.1</a>, where the value of the profile-
   specific octet in the FEEDBACK-1 is 0 (zero).  The FEEDBACK-2 format
   is thus not defined for Profile 0x0000.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/6.%20%20Overview%20of%20a%20ROHC%20Profile%20%28Informative%29"></a><a class="selflink" href="#section-6" name="section-6">6</a>.  Overview of a ROHC Profile (Informative)</span>

   The ROHC protocol consists of a framework part and a profile part.
   The framework defines the mechanisms common to all profiles, while
   the profile defines the compression algorithm and profile-specific
   packet formats.

   <a href="#section-5">Section 5</a> specifies the details of the ROHC framework.  This section
   provides an informative overview of the elements that make a profile
   specification.  The normative specification of individual profiles is
   outside the scope of this document.

   A ROHC profile defines the elements that build up the compression
   protocol.  A ROHC profile consists of:







<span class="grey">Sandlund, et al.             Standards Track                   [Page 33]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-34" id="page-34" name="page-34"> </a>
<span class="grey"><a href="rfc5795.html">RFC 5795</a>                     ROHC Framework                   March 2010</span>


   Packet formats:

   o  Bits-on-the-wire

         The profile defines the layout of the bits for profile-specific
         packet types that it defines, and for the profile-specific
         parts of packet types common to all profiles (e.g., IR and IR-
         DYN).

   o  Field encodings

         Bits and groups of bits from the packet format layout, referred
         to as Compressed fields, represent the result of an encoding
         method specific for that compressed field within a specific
         packet format.  The profile defines these encoding methods.

   o  Updating properties

         The profile-specific packet formats may update the state of the
         decompressor, and may do so in different ways.  The profile
         defines how individual profile-specific fields, or entire
         profile-specific packet types, update the decompressor context.

   o  Verification

         Packets that update the state of the decompressor are verified
         to prevent incorrect updates to the decompressor context.  The
         profile defines the mechanisms used to verify the decompression
         of a packet.

   Context management:

   o  Robustness logic

         Packets may be lost or reordered between the compressor and the
         decompressor.  The profile defines mechanisms to minimize the
         impacts of such events and prevent damage propagation.

   o  Repair mechanism

         Despite the robustness logic, impairment events may still lead
         to decompression failure(s), and even to context damage at the
         decompressor.  The profile defines context repair mechanisms,
         including feedback logic if used.







<span class="grey">Sandlund, et al.             Standards Track                   [Page 34]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-35" id="page-35" name="page-35"> </a>
<span class="grey"><a href="rfc5795.html">RFC 5795</a>                     ROHC Framework                   March 2010</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/7.%20%20Acknowledgments"></a><a class="selflink" href="#section-7" name="section-7">7</a>.  Acknowledgments</span>

   The authors would like to acknowledge all who have contributed to
   previous ROHC work, and especially to the authors of <a href="rfc3095.html">RFC 3095</a>
   [<a href="rfc3095.html" title='"RObust Header Compression (ROHC): Framework and four profiles: RTP, UDP, ESP, and uncompressed"'>RFC3095</a>], which is the technical basis for this document.  Thanks
   also to the various individuals who contributed to the <a href="rfc3095.html">RFC 3095</a>
   corrections and clarifications document [<a href="rfc4815.html" title='"RObust Header Compression (ROHC): Corrections and Clarifications to RFC 3095"'>RFC4815</a>], from which
   technical contents, when applicable, have been incorporated into this
   document.  Thanks to Jani Juvan for discovering an inconsistency
   between the feedback structure described in [<a href="rfc4995.html" title='"The RObust Header Compression (ROHC) Framework"'>RFC4995</a>] and the one
   described in [<a href="rfc3095.html" title='"RObust Header Compression (ROHC): Framework and four profiles: RTP, UDP, ESP, and uncompressed"'>RFC3095</a>], which made this update to [<a href="rfc4995.html" title='"The RObust Header Compression (ROHC) Framework"'>RFC4995</a>]
   necessary.

   Committed WG document reviewers were Carl Knutsson, Biplab Sarkar,
   and Robert Stangarone, who reviewed the document during working group
   last calls.  Additional thanks to Bert Wijnen and Brian Carpenter for
   comments during IETF Last Call.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/8.%20%20IANA%20Considerations"></a><a class="selflink" href="#section-8" name="section-8">8</a>.  IANA Considerations</span>

   An IANA registry for "RObust Header Compression (ROHC) Profile
   Identifiers" [<a href="#ref-ROHC-ids" title='"RObust Header Compression (ROHC) Profile Identifiers"'>ROHC-ids</a>] was created by <a href="rfc3095.html">RFC 3095</a> [<a href="rfc3095.html" title='"RObust Header Compression (ROHC): Framework and four profiles: RTP, UDP, ESP, and uncompressed"'>RFC3095</a>].  The
   assignment policy, as outlined by <a href="rfc3095.html">RFC 3095</a>, is the following:

   The ROHC profile identifier is a non-negative integer.  In many
   negotiation protocols, it will be represented as a 16-bit value.  Due
   to the way the profile identifier is abbreviated in ROHC packets, the
   8 LSBs of the profile identifier have a special significance: Two
   profile identifiers with identical 8 LSBs should be assigned only if
   the higher-numbered one is intended to supersede the lower-numbered
   one.  To highlight this relationship, profile identifiers should be
   given in hexadecimal (for example, as in 0x1234, which would
   supersede 0x0A34).

   Following the policies outlined in [<a href="rfc5226.html" title='"Guidelines for Writing an IANA Considerations Section in RFCs"'>RFC5226</a>], the IANA policy for
   assigning new values for the profile identifier is Specification
   Required: values and their meanings must be documented in an RFC or
   in some other permanent and readily available reference, in
   sufficient detail that interoperability between independent
   implementations is possible.  In the 8 LSBs, the range 0 to 127 is
   reserved for IETF standard-track specifications; the range 128 to 254
   is available for other specifications that meet this requirement
   (such as Informational RFCs).  The LSB value 255 is reserved for
   future extensibility of the present specification.







<span class="grey">Sandlund, et al.             Standards Track                   [Page 35]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-36" id="page-36" name="page-36"> </a>
<span class="grey"><a href="rfc5795.html">RFC 5795</a>                     ROHC Framework                   March 2010</span>


   The following profile identifiers have so far been allocated:

      Profile Identifier    Usage                      Reference
      ------------------    ----------------------     ---------
      0x0000                ROHC uncompressed          <a href="rfc5795.html">RFC 5795</a>
      0x0001                ROHC RTP                   <a href="rfc3095.html">RFC 3095</a>
      0x0002                ROHC UDP                   <a href="rfc3095.html">RFC 3095</a>
      0x0003                ROHC ESP                   <a href="rfc3095.html">RFC 3095</a>
      0x0004                ROHC IP                    <a href="rfc3843.html">RFC 3843</a>
      0x0005                ROHC LLA                   <a href="rfc3242.html">RFC 3242</a>
      0x0105                ROHC LLA with R-mode       <a href="rfc3408.html">RFC 3408</a>
      0x0006                ROHC TCP                   <a href="rfc4996.html">RFC 4996</a>
      0x0007                ROHC RTP/UDP-Lite          <a href="rfc4019.html">RFC 4019</a>
      0x0008                ROHC UDP-Lite              <a href="rfc4019.html">RFC 4019</a>
      0x0101                ROHCv2 RTP                 <a href="rfc5225.html">RFC 5225</a>
      0x0102                ROHCv2 UDP                 <a href="rfc5225.html">RFC 5225</a>
      0x0103                ROHCv2 ESP                 <a href="rfc5225.html">RFC 5225</a>
      0x0104                ROHCv2 IP                  <a href="rfc5225.html">RFC 5225</a>
      0x0107                ROHCv2 RTP/UDP-Lite        <a href="rfc5225.html">RFC 5225</a>
      0x0108                ROHCv2 UDP-Lite            <a href="rfc5225.html">RFC 5225</a>

   New profiles will need new identifiers to be assigned by the IANA,
   but this document does not require any additional IANA action.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/9.%20%20Security%20Considerations"></a><a class="selflink" href="#section-9" name="section-9">9</a>.  Security Considerations</span>

   Because encryption eliminates the redundancy that header compression
   schemes try to exploit, there is some inducement to forego encryption
   of headers in order to enable operation over low-bandwidth links.

   A malfunctioning or malicious header compressor could cause the
   header decompressor to reconstitute packets that do not match the
   original packets but still have valid headers and possibly also valid
   transport checksums.  Such corruption may be detected with end-to-end
   authentication and integrity mechanisms, which will not be affected
   by the compression.  Moreover, the ROHC header compression scheme
   uses an internal checksum for verification of reconstructed headers,
   which reduces the probability of producing decompressed headers not
   matching the original ones without this being noticed.

   Denial-of-service attacks are possible if an intruder can introduce,
   for example, bogus IR, IR-DYN, or feedback packets onto the link and
   thereby cause compression efficiency to be reduced.  However, an
   intruder having the ability to inject arbitrary packets at the link
   layer in this manner raises additional security issues that dwarf
   those related to the use of header compression.





<span class="grey">Sandlund, et al.             Standards Track                   [Page 36]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-37" id="page-37" name="page-37"> </a>
<span class="grey"><a href="rfc5795.html">RFC 5795</a>                     ROHC Framework                   March 2010</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/10.%20%20References"></a><a class="selflink" href="#section-10" name="section-10">10</a>.  References</span>

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/10.1.%20%20Normative%20References"></a><a class="selflink" href="#section-10.1" name="section-10.1">10.1</a>.  Normative References</span>

   [<a id="ref-RFC2119" name="ref-RFC2119">RFC2119</a>]    Bradner, S., "Key words for use in RFCs to Indicate
                Requirement Levels", <a href="https://tools.ietf.org/html/bcp14">BCP 14</a>, <a href="rfc2119.html">RFC 2119</a>, March 1997.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/10.2.%20%20Informative%20References"></a><a class="selflink" href="#section-10.2" name="section-10.2">10.2</a>.  Informative References</span>

   [<a id="ref-CRTP-eval" name="ref-CRTP-eval">CRTP-eval</a>]  Degermark, M., Hannu, H., Jonsson, L., and K. Svanbro,
                ""Evaluation of CRTP Performance over Cellular Radio
                Networks", IEEE Personal Communication Magazine, Volume
                7, number 4, pp. 20-25, August 2000.", 2000.

   [<a id="ref-RFC0768" name="ref-RFC0768">RFC0768</a>]    Postel, J., "User Datagram Protocol", STD 6, <a href="rfc768.html">RFC 768</a>,
                August 1980.

   [<a id="ref-RFC0791" name="ref-RFC0791">RFC0791</a>]    Postel, J., "Internet Protocol", STD 5, <a href="rfc791.html">RFC 791</a>,
                September 1981.

   [<a id="ref-RFC0793" name="ref-RFC0793">RFC0793</a>]    Postel, J., "Transmission Control Protocol", STD 7,
                <a href="rfc793.html">RFC 793</a>, September 1981.

   [<a id="ref-RFC1144" name="ref-RFC1144">RFC1144</a>]    Jacobson, V., "Compressing TCP/IP headers for low-speed
                serial links", <a href="rfc1144.html">RFC 1144</a>, February 1990.

   [<a id="ref-RFC1662" name="ref-RFC1662">RFC1662</a>]    Simpson, W., "PPP in HDLC-like Framing", STD 51,
                <a href="rfc1662.html">RFC 1662</a>, July 1994.

   [<a id="ref-RFC2460" name="ref-RFC2460">RFC2460</a>]    Deering, S. and R. Hinden, "Internet Protocol, Version 6
                (IPv6) Specification", <a href="rfc2460.html">RFC 2460</a>, December 1998.

   [<a id="ref-RFC2507" name="ref-RFC2507">RFC2507</a>]    Degermark, M., Nordgren, B., and S. Pink, "IP Header
                Compression", <a href="rfc2507.html">RFC 2507</a>, February 1999.

   [<a id="ref-RFC2508" name="ref-RFC2508">RFC2508</a>]    Casner, S. and V. Jacobson, "Compressing IP/UDP/RTP
                Headers for Low-Speed Serial Links", <a href="rfc2508.html">RFC 2508</a>,
                February 1999.

   [<a id="ref-RFC3095" name="ref-RFC3095">RFC3095</a>]    Bormann, C., Burmeister, C., Degermark, M., Fukushima,
                H., Hannu, H., Jonsson, L-E., Hakenberg, R., Koren, T.,
                Le, K., Liu, Z., Martensson, A., Miyazaki, A., Svanbro,
                K., Wiebke, T., Yoshimura, T., and H. Zheng, "RObust
                Header Compression (ROHC): Framework and four profiles:
                RTP, UDP, ESP, and uncompressed", <a href="rfc3095.html">RFC 3095</a>, July 2001.

   [<a id="ref-RFC3096" name="ref-RFC3096">RFC3096</a>]    Degermark, M., "Requirements for robust IP/UDP/RTP
                header compression", <a href="rfc3096.html">RFC 3096</a>, July 2001.



<span class="grey">Sandlund, et al.             Standards Track                   [Page 37]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-38" id="page-38" name="page-38"> </a>
<span class="grey"><a href="rfc5795.html">RFC 5795</a>                     ROHC Framework                   March 2010</span>


   [<a id="ref-RFC3241" name="ref-RFC3241">RFC3241</a>]    Bormann, C., "Robust Header Compression (ROHC) over
                PPP", <a href="rfc3241.html">RFC 3241</a>, April 2002.

   [<a id="ref-RFC3545" name="ref-RFC3545">RFC3545</a>]    Koren, T., Casner, S., Geevarghese, J., Thompson, B.,
                and P. Ruddy, "Enhanced Compressed RTP (CRTP) for Links
                with High Delay, Packet Loss and Reordering", <a href="rfc3545.html">RFC 3545</a>,
                July 2003.

   [<a id="ref-RFC3550" name="ref-RFC3550">RFC3550</a>]    Schulzrinne, H., Casner, S., Frederick, R., and V.
                Jacobson, "RTP: A Transport Protocol for Real-Time
                Applications", STD 64, <a href="rfc3550.html">RFC 3550</a>, July 2003.

   [<a id="ref-RFC3759" name="ref-RFC3759">RFC3759</a>]    Jonsson, L-E., "RObust Header Compression (ROHC):
                Terminology and Channel Mapping Examples", <a href="rfc3759.html">RFC 3759</a>,
                April 2004.

   [<a id="ref-RFC4224" name="ref-RFC4224">RFC4224</a>]    Pelletier, G., Jonsson, L-E., and K. Sandlund, "RObust
                Header Compression (ROHC): ROHC over Channels That Can
                Reorder Packets", <a href="rfc4224.html">RFC 4224</a>, January 2006.

   [<a id="ref-RFC4815" name="ref-RFC4815">RFC4815</a>]    Jonsson, L-E., Sandlund, K., Pelletier, G., and P.
                Kremer, "RObust Header Compression (ROHC): Corrections
                and Clarifications to <a href="rfc3095.html">RFC 3095</a>", <a href="rfc4815.html">RFC 4815</a>,
                February 2007.

   [<a id="ref-RFC4995" name="ref-RFC4995">RFC4995</a>]    Jonsson, L-E., Pelletier, G., and K. Sandlund, "The
                RObust Header Compression (ROHC) Framework", <a href="rfc4995.html">RFC 4995</a>,
                July 2007.

   [<a id="ref-RFC4996" name="ref-RFC4996">RFC4996</a>]    Pelletier, G., Sandlund, K., Jonsson, L-E., and M. West,
                "RObust Header Compression (ROHC): A Profile for TCP/IP
                (ROHC-TCP)", <a href="rfc4996.html">RFC 4996</a>, July 2007.

   [<a id="ref-RFC5225" name="ref-RFC5225">RFC5225</a>]    Pelletier, G. and K. Sandlund, "RObust Header
                Compression Version 2 (ROHCv2): Profiles for RTP, UDP,
                IP, ESP and UDP-Lite", <a href="rfc5225.html">RFC 5225</a>, April 2008.

   [<a id="ref-RFC5226" name="ref-RFC5226">RFC5226</a>]    Narten, T. and H. Alvestrand, "Guidelines for Writing an
                IANA Considerations Section in RFCs", <a href="https://tools.ietf.org/html/bcp26">BCP 26</a>, <a href="rfc5226.html">RFC 5226</a>,
                May 2008.

   [<a id="ref-ROHC-ids" name="ref-ROHC-ids">ROHC-ids</a>]   IANA, "RObust Header Compression (ROHC) Profile
                Identifiers", &lt;<a href="http://www.iana.org/">http://www.iana.org</a>&gt;.








<span class="grey">Sandlund, et al.             Standards Track                   [Page 38]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-39" id="page-39" name="page-39"> </a>
<span class="grey"><a href="rfc5795.html">RFC 5795</a>                     ROHC Framework                   March 2010</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/Appendix%20A.%20%20CRC%20Algorithm"></a><a class="selflink" href="#appendix-A" name="appendix-A">Appendix A</a>.  CRC Algorithm</span>

     #!/usr/bin/perl -w
   use strict;
   #=================================
   #
   # ROHC CRC demo - Carsten Bormann cabo@tzi.org 2001-08-02
   #
   # This little demo shows the four types of CRC in use in <a href="rfc3095.html">RFC 3095</a>,
   # the specification for robust header compression.  Type your data in
   # hexadecimal form and then press Control+D.
   #
   #---------------------------------
   #
   # utility
   #
   sub dump_bytes($) {
       my $x = shift;
       my $i;
       for ($i = 0; $i &lt; length($x); ) {
     printf("%02x ", ord(substr($x, $i, 1)));
     printf("\n") if (++$i % 16 == 0);
       }
       printf("\n") if ($i % 16 != 0);
   }

   #---------------------------------
   #
   # The CRC calculation algorithm.
   #
   sub do_crc($$$) {
       my $nbits = shift;
       my $poly = shift;
       my $string = shift;

       my $crc = ($nbits == 32 ? 0xffffffff : (1 &lt;&lt; $nbits) - 1);
       for (my $i = 0; $i &lt; length($string); ++$i) {
         my $byte = ord(substr($string, $i, 1));
         for( my $b = 0; $b &lt; 8; $b++ ) {
           if (($crc &amp; 1) ^ ($byte &amp; 1)) {
             $crc &gt;&gt;= 1;
             $crc ^= $poly;
           } else {
           $crc &gt;&gt;= 1;
           }
           $byte &gt;&gt;= 1;
         }
       }



<span class="grey">Sandlund, et al.             Standards Track                   [Page 39]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-40" id="page-40" name="page-40"> </a>
<span class="grey"><a href="rfc5795.html">RFC 5795</a>                     ROHC Framework                   March 2010</span>


       printf "%2d bits, ", $nbits;
       printf "CRC: %02x\n", $crc;
   }

   #---------------------------------
   #
   # Test harness
   #
   $/ = undef;
   $_ = &lt;&gt;;         # read until EOF
   my $string = ""; # extract all that looks hex:
   s/([0-9a-fA-F][0-9a-fA-F])/$string .= chr(hex($1)), ""/eg;
   dump_bytes($string);

   #---------------------------------
   #
   # 32-bit segmentation CRC
   # Note that the text implies this is complemented like for PPP
   # (this differs from 8, 7, and 3-bit CRC)
   #
   #      C(x) = x^0 + x^1 + x^2 + x^4 + x^5 + x^7 + x^8 + x^10 +
   #             x^11 + x^12 + x^16 + x^22 + x^23 + x^26 + x^32
   #
   do_crc(32, 0xedb88320, $string);

   #---------------------------------
   #
   # 8-bit IR/IR-DYN CRC
   #
   #      C(x) = x^0 + x^1 + x^2 + x^8
   #
   do_crc(8, 0xe0, $string);

   #---------------------------------
   #
   # 7-bit FO/SO CRC
   #
   #      C(x) = x^0 + x^1 + x^2 + x^3 + x^6 + x^7
   #
   do_crc(7, 0x79, $string);

   #---------------------------------
   #
   # 3-bit FO/SO CRC
   #
   #      C(x) = x^0 + x^1 + x^3
   #
   do_crc(3, 0x6, $string);



<span class="grey">Sandlund, et al.             Standards Track                   [Page 40]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-41" id="page-41" name="page-41"> </a>
<span class="grey"><a href="rfc5795.html">RFC 5795</a>                     ROHC Framework                   March 2010</span>


Authors' Addresses

   Kristofer Sandlund
   Ericsson
   Box 920
   Lulea  SE-971 28
   Sweden

   Phone: +46 (0) 8 404 41 58
   EMail: kristofer.sandlund@ericsson.com


   Ghyslain Pelletier
   Ericsson
   Box 920
   Lulea  SE-971 28
   Sweden

   Phone: +46 (0) 8 404 29 43
   EMail: ghyslain.pelletier@ericsson.com


   Lars-Erik Jonsson
   Optand 737
   Ostersund  SE-831 92
   Sweden

   Phone: +46 76 830 03 12
   EMail: lars-erik@lejonsson.com






















Sandlund, et al.             Standards Track                   [Page 41]

</pre><br/>
    <span class="noprint"><small><small>Html markup produced by rfcmarkup 1.126, available from
      <a href="https://tools.ietf.org/tools/rfcmarkup/">https://tools.ietf.org/tools/rfcmarkup/</a>
    </small></small></span>
  </div>




</body><!-- Mirrored from tools.ietf.org/html/rfc5795 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 06 Mar 2018 23:18:33 GMT --></html>