<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml"><!-- Mirrored from tools.ietf.org/html/rfc7252 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 06 Mar 2018 23:18:23 GMT --><!-- Added by HTTrack --><head><meta content="text/html;charset=utf-8" http-equiv="content-type"/><!-- /Added by HTTrack -->

    <meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
    <meta content="index,follow" name="robots"/>
    <meta content="rfcmarkup version 1.126" name="creator"/>
    <link href="http://purl.org/dc/elements/1.1/" rel="schema.DC"/>
<meta content="draft-shelby-core-coap" name="DC.Relation.Replaces"/>
<meta content="urn:ietf:rfc:7252" name="DC.Identifier"/>
<meta content="June, 2014" name="DC.Date.Issued"/>
<meta content="Shelby, Zach" name="DC.Creator"/>
<meta content="Hartke, Klaus" name="DC.Creator"/>
<meta content="Bormann, Carsten" name="DC.Creator"/>
<meta content="The Constrained Application Protocol (CoAP) is a specialized web
transfer protocol for use with constrained nodes and constrained
(e.g., low-power, lossy) networks. The nodes often have 8-bit
microcontrollers with small amounts of ROM and RAM, while constrained
networks such as IPv6 over Low-Power Wireless Personal Area Networks
(6LoWPANs) often have high packet error rates and a typical throughput
of 10s of kbit/s. The protocol is designed for machine- to-machine
(M2M) applications such as smart energy and building automation.  CoAP
provides a request/response interaction model between application
endpoints, supports built-in discovery of services and resources, and
includes key concepts of the Web such as URIs and Internet media
types. CoAP is designed to easily interface with HTTP for integration
with the Web while meeting specialized requirements such as multicast
support, very low overhead, and simplicity for constrained
environments." name="DC.Description.Abstract"/>
<meta content="The Constrained Application Protocol (CoAP)" name="DC.Title"/>

    <link href="https://tools.ietf.org/images/rfc.png" rel="icon" type="image/png"/>
    <link href="https://tools.ietf.org/images/rfc.png" rel="shortcut icon" type="image/png"/>
    <title>RFC 7252 - The Constrained Application Protocol (CoAP)</title>
    
    
    <style type="text/css">
	@media only screen 
	  and (min-width: 992px)
	  and (max-width: 1199px) {
	    body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 768px)
	  and (max-width: 991px) {
            body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 480px)
	  and (max-width: 767px) {
            body { font-size: 11pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (max-width: 479px) {
            body { font-size: 8pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-device-width : 375px) 
	  and (max-device-width : 667px) {
            body { font-size: 9.5pt; }
            div.content { width: 96ex; margin: 0 1px; }
        }
	@media only screen 
	  and (min-device-width: 1200px) {
            body { font-size: 10pt; margin: 0 4em; }
            div.content { width: 96ex; margin: 0; }
        }
        h1, h2, h3, h4, h5, h6, .h1, .h2, .h3, .h4, .h5, .h6 {
	    font-weight: bold;
            line-height: 0pt;
            display: inline;
            white-space: pre;
            font-family: monospace;
            font-size: 1em;
	    font-weight: bold;
        }
        pre {
            font-size: 1em;
            margin-top: 0px;
            margin-bottom: 0px;
        }
	.pre {
	    white-space: pre;
	    font-family: monospace;
	}
	.header{
	    font-weight: bold;
	}
        .newpage {
            page-break-before: always;
        }
        .invisible {
            text-decoration: none;
            color: white;
        }
        a.selflink {
          color: black;
          text-decoration: none;
        }
        @media print {
            body {
                font-family: monospace;
                font-size: 10.5pt;
            }
            h1, h2, h3, h4, h5, h6 {
                font-size: 1em;
            }
        
            a:link, a:visited {
                color: inherit;
                text-decoration: none;
            }
            .noprint {
                display: none;
            }
        }
	@media screen {
	    .grey, .grey a:link, .grey a:visited {
		color: #777;
	    }
            .docinfo {
                background-color: #EEE;
            }
            .top {
                border-top: 7px solid #EEE;
            }
            .bgwhite  { background-color: white; }
            .bgred    { background-color: #F44; }
            .bggrey   { background-color: #666; }
            .bgbrown  { background-color: #840; }            
            .bgorange { background-color: #FA0; }
            .bgyellow { background-color: #EE0; }
            .bgmagenta{ background-color: #F4F; }
            .bgblue   { background-color: #66F; }
            .bgcyan   { background-color: #4DD; }
            .bggreen  { background-color: #4F4; }

            .legend   { font-size: 90%; }
            .cplate   { font-size: 70%; border: solid grey 1px; }
	}
    </style>
    <!--[if IE]>
    <style>
    body {
       font-size: 13px;
       margin: 10px 10px;
    }
    </style>
    <![endif]-->

    <script type="text/javascript"><!--
    function addHeaderTags() {
	var spans = document.getElementsByTagName("span");
	for (var i=0; i < spans.length; i++) {
	    var elem = spans[i];
	    if (elem) {
		var level = elem.getAttribute("class");
                if (level == "h1" || level == "h2" || level == "h3" || level == "h4" || level == "h5" || level == "h6") {
                    elem.innerHTML = "<"+level+">"+elem.innerHTML+"</"+level+">";		
                }
	    }
	}
    }
    var legend_html = "Colour legend:<br />      <table>         <tr><td>Unknown:</td>                   <td><span class='cplate bgwhite'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft:</td>                     <td><span class='cplate bgred'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Informational:</td>             <td><span class='cplate bgorange'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Experimental:</td>              <td><span class='cplate bgyellow'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Best Common Practice:</td>      <td><span class='cplate bgmagenta'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Proposed Standard:</td>         <td><span class='cplate bgblue'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft Standard (old designation):</td> <td><span class='cplate bgcyan'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Internet Standard:</td>         <td><span class='cplate bggreen'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Historic:</td>                  <td><span class='cplate bggrey'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Obsolete:</td>                  <td><span class='cplate bgbrown'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>     </table>";
    function showElem(id) {
        var elem = document.getElementById(id);
        elem.innerHTML = eval(id+"_html");
        elem.style.visibility='visible';
    }
    function hideElem(id) {
        var elem = document.getElementById(id);
        elem.style.visibility='hidden';        
        elem.innerHTML = "";
    }
    // -->
    </script>
</head>
<body onload="addHeaderTags()">
  <div class="content">
   <div style="height: 13px;">
      <div class="pre noprint docinfo bgblue" onclick="showElem('legend');" onmouseout="hideElem('legend')" onmouseover="this.style.cursor='pointer';" style="height: 6px; position: absolute;" title="Click for colour legend.">                                                                        </div>
      <div class="docinfo noprint pre legend" id="legend" onmouseout="hideElem('legend');" onmouseover="showElem('legend');" style="position:absolute; top: 4px; left: 4ex; visibility:hidden; background-color: white; padding: 4px 9px 5px 7px; border: solid #345 1px; ">
      </div>
   </div>
<span class="pre noprint docinfo top">[<a href="index.html" title="Document search and retrieval page">Docs</a>] [<a href="https://tools.ietf.org/rfc/rfc7252.txt" title="Plaintext version of this document">txt</a>|<a href="https://tools.ietf.org/pdf/rfc7252" title="PDF version of this document">pdf</a>] [<a href="https://tools.ietf.org/html/draft-ietf-core-coap" title="draft-ietf-core-coap">draft-ietf-core...</a>] [<a href="https://datatracker.ietf.org/doc/rfc7252" title="IESG Datatracker information for this document">Tracker</a>] [<a href="https://tools.ietf.org/rfcdiff?difftype=--hwdiff&amp;url2=rfc7252" title="Inline diff (wdiff)">Diff1</a>] [<a href="https://tools.ietf.org/rfcdiff?url2=rfc7252" title="Side-by-side diff">Diff2</a>] [<a href="https://www.rfc-editor.org/errata_search.php?rfc=7252">Errata</a>]</span><br/>
<span class="pre noprint docinfo">                                                                        </span><br/>
<span class="pre noprint docinfo">Updated by: <a href="rfc7959.html">7959</a>                                       PROPOSED STANDARD</span><br/>
<span class="pre noprint docinfo">                                                            <span style="color: #C00;">Errata Exist</span></span><br/>
<pre>Internet Engineering Task Force (IETF)                         Z. Shelby
Request for Comments: 7252                                           ARM
Category: Standards Track                                      K. Hartke
ISSN: 2070-1721                                               C. Bormann
                                                 Universitaet Bremen TZI
                                                               June 2014


              <span class="h1">The Constrained Application Protocol (CoAP)</span>

Abstract

   The Constrained Application Protocol (CoAP) is a specialized web
   transfer protocol for use with constrained nodes and constrained
   (e.g., low-power, lossy) networks.  The nodes often have 8-bit
   microcontrollers with small amounts of ROM and RAM, while constrained
   networks such as IPv6 over Low-Power Wireless Personal Area Networks
   (6LoWPANs) often have high packet error rates and a typical
   throughput of 10s of kbit/s.  The protocol is designed for machine-
   to-machine (M2M) applications such as smart energy and building
   automation.

   CoAP provides a request/response interaction model between
   application endpoints, supports built-in discovery of services and
   resources, and includes key concepts of the Web such as URIs and
   Internet media types.  CoAP is designed to easily interface with HTTP
   for integration with the Web while meeting specialized requirements
   such as multicast support, very low overhead, and simplicity for
   constrained environments.

Status of This Memo

   This is an Internet Standards Track document.

   This document is a product of the Internet Engineering Task Force
   (IETF).  It represents the consensus of the IETF community.  It has
   received public review and has been approved for publication by the
   Internet Engineering Steering Group (IESG).  Further information on
   Internet Standards is available in <a href="rfc5741.html#section-2">Section 2 of RFC 5741</a>.

   Information about the current status of this document, any errata,
   and how to provide feedback on it may be obtained at
   <a href="http://www.rfc-editor.org/info/rfc7252">http://www.rfc-editor.org/info/rfc7252</a>.








<span class="grey">Shelby, et al.               Standards Track                    [Page 1]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-2" id="page-2" name="page-2"> </a>
<span class="grey"><a href="rfc7252.html">RFC 7252</a>       The Constrained Application Protocol (CoAP)     June 2014</span>


Copyright Notice

   Copyright (c) 2014 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to <a href="https://tools.ietf.org/html/bcp78">BCP 78</a> and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (<a href="http://trustee.ietf.org/license-info">http://trustee.ietf.org/license-info</a>) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.

Table of Contents

   <a href="#section-1">1</a>.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   <a href="#page-5">5</a>
     <a href="#section-1.1">1.1</a>.  Features  . . . . . . . . . . . . . . . . . . . . . . . .   <a href="#page-5">5</a>
     <a href="#section-1.2">1.2</a>.  Terminology . . . . . . . . . . . . . . . . . . . . . . .   <a href="#page-6">6</a>
   <a href="#section-2">2</a>.  Constrained Application Protocol  . . . . . . . . . . . . . .  <a href="#page-10">10</a>
     <a href="#section-2.1">2.1</a>.  Messaging Model . . . . . . . . . . . . . . . . . . . . .  <a href="#page-11">11</a>
     <a href="#section-2.2">2.2</a>.  Request/Response Model  . . . . . . . . . . . . . . . . .  <a href="#page-12">12</a>
     <a href="#section-2.3">2.3</a>.  Intermediaries and Caching  . . . . . . . . . . . . . . .  <a href="#page-15">15</a>
     <a href="#section-2.4">2.4</a>.  Resource Discovery  . . . . . . . . . . . . . . . . . . .  <a href="#page-15">15</a>
   <a href="#section-3">3</a>.  Message Format  . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-15">15</a>
     <a href="#section-3.1">3.1</a>.  Option Format . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-17">17</a>
     <a href="#section-3.2">3.2</a>.  Option Value Formats  . . . . . . . . . . . . . . . . . .  <a href="#page-19">19</a>
   <a href="#section-4">4</a>.  Message Transmission  . . . . . . . . . . . . . . . . . . . .  <a href="#page-20">20</a>
     <a href="#section-4.1">4.1</a>.  Messages and Endpoints  . . . . . . . . . . . . . . . . .  <a href="#page-20">20</a>
     <a href="#section-4.2">4.2</a>.  Messages Transmitted Reliably . . . . . . . . . . . . . .  <a href="#page-21">21</a>
     <a href="#section-4.3">4.3</a>.  Messages Transmitted without Reliability  . . . . . . . .  <a href="#page-23">23</a>
     <a href="#section-4.4">4.4</a>.  Message Correlation . . . . . . . . . . . . . . . . . . .  <a href="#page-24">24</a>
     <a href="#section-4.5">4.5</a>.  Message Deduplication . . . . . . . . . . . . . . . . . .  <a href="#page-24">24</a>
     <a href="#section-4.6">4.6</a>.  Message Size  . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-25">25</a>
     <a href="#section-4.7">4.7</a>.  Congestion Control  . . . . . . . . . . . . . . . . . . .  <a href="#page-26">26</a>
     <a href="#section-4.8">4.8</a>.  Transmission Parameters . . . . . . . . . . . . . . . . .  <a href="#page-27">27</a>
       <a href="#section-4.8.1">4.8.1</a>.  Changing the Parameters . . . . . . . . . . . . . . .  <a href="#page-27">27</a>
       <a href="#section-4.8.2">4.8.2</a>.  Time Values Derived from Transmission Parameters  . .  <a href="#page-28">28</a>
   <a href="#section-5">5</a>.  Request/Response Semantics  . . . . . . . . . . . . . . . . .  <a href="#page-31">31</a>
     <a href="#section-5.1">5.1</a>.  Requests  . . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-31">31</a>
     <a href="#section-5.2">5.2</a>.  Responses . . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-31">31</a>
       <a href="#section-5.2.1">5.2.1</a>.  Piggybacked . . . . . . . . . . . . . . . . . . . . .  <a href="#page-33">33</a>
       <a href="#section-5.2.2">5.2.2</a>.  Separate  . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-33">33</a>
       <a href="#section-5.2.3">5.2.3</a>.  Non-confirmable . . . . . . . . . . . . . . . . . . .  <a href="#page-34">34</a>
     <a href="#section-5.3">5.3</a>.  Request/Response Matching . . . . . . . . . . . . . . . .  <a href="#page-34">34</a>
       <a href="#section-5.3.1">5.3.1</a>.  Token . . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-34">34</a>
       <a href="#section-5.3.2">5.3.2</a>.  Request/Response Matching Rules . . . . . . . . . . .  <a href="#page-35">35</a>



<span class="grey">Shelby, et al.               Standards Track                    [Page 2]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-3" id="page-3" name="page-3"> </a>
<span class="grey"><a href="rfc7252.html">RFC 7252</a>       The Constrained Application Protocol (CoAP)     June 2014</span>


     <a href="#section-5.4">5.4</a>.  Options . . . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-36">36</a>
       <a href="#section-5.4.1">5.4.1</a>.  Critical/Elective . . . . . . . . . . . . . . . . . .  <a href="#page-37">37</a>
       <a href="#section-5.4.2">5.4.2</a>.  Proxy Unsafe or Safe-to-Forward and NoCacheKey  . . .  <a href="#page-38">38</a>
       <a href="#section-5.4.3">5.4.3</a>.  Length  . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-38">38</a>
       <a href="#section-5.4.4">5.4.4</a>.  Default Values  . . . . . . . . . . . . . . . . . . .  <a href="#page-38">38</a>
       <a href="#section-5.4.5">5.4.5</a>.  Repeatable Options  . . . . . . . . . . . . . . . . .  <a href="#page-39">39</a>
       <a href="#section-5.4.6">5.4.6</a>.  Option Numbers  . . . . . . . . . . . . . . . . . . .  <a href="#page-39">39</a>
     <a href="#section-5.5">5.5</a>.  Payloads and Representations  . . . . . . . . . . . . . .  <a href="#page-40">40</a>
       <a href="#section-5.5.1">5.5.1</a>.  Representation  . . . . . . . . . . . . . . . . . . .  <a href="#page-40">40</a>
       <a href="#section-5.5.2">5.5.2</a>.  Diagnostic Payload  . . . . . . . . . . . . . . . . .  <a href="#page-41">41</a>
       <a href="#section-5.5.3">5.5.3</a>.  Selected Representation . . . . . . . . . . . . . . .  <a href="#page-41">41</a>
       <a href="#section-5.5.4">5.5.4</a>.  Content Negotiation . . . . . . . . . . . . . . . . .  <a href="#page-41">41</a>
     <a href="#section-5.6">5.6</a>.  Caching . . . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-42">42</a>
       <a href="#section-5.6.1">5.6.1</a>.  Freshness Model . . . . . . . . . . . . . . . . . . .  <a href="#page-43">43</a>
       <a href="#section-5.6.2">5.6.2</a>.  Validation Model  . . . . . . . . . . . . . . . . . .  <a href="#page-43">43</a>
     <a href="#section-5.7">5.7</a>.  Proxying  . . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-44">44</a>
       <a href="#section-5.7.1">5.7.1</a>.  Proxy Operation . . . . . . . . . . . . . . . . . . .  <a href="#page-44">44</a>
       <a href="#section-5.7.2">5.7.2</a>.  Forward-Proxies . . . . . . . . . . . . . . . . . . .  <a href="#page-46">46</a>
       <a href="#section-5.7.3">5.7.3</a>.  Reverse-Proxies . . . . . . . . . . . . . . . . . . .  <a href="#page-46">46</a>
     <a href="#section-5.8">5.8</a>.  Method Definitions  . . . . . . . . . . . . . . . . . . .  <a href="#page-47">47</a>
       <a href="#section-5.8.1">5.8.1</a>.  GET . . . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-47">47</a>
       <a href="#section-5.8.2">5.8.2</a>.  POST  . . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-47">47</a>
       <a href="#section-5.8.3">5.8.3</a>.  PUT . . . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-48">48</a>
       <a href="#section-5.8.4">5.8.4</a>.  DELETE  . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-48">48</a>
     <a href="#section-5.9">5.9</a>.  Response Code Definitions . . . . . . . . . . . . . . . .  <a href="#page-48">48</a>
       <a href="#section-5.9.1">5.9.1</a>.  Success 2.xx  . . . . . . . . . . . . . . . . . . . .  <a href="#page-48">48</a>
       <a href="#section-5.9.2">5.9.2</a>.  Client Error 4.xx . . . . . . . . . . . . . . . . . .  <a href="#page-50">50</a>
       <a href="#section-5.9.3">5.9.3</a>.  Server Error 5.xx . . . . . . . . . . . . . . . . . .  <a href="#page-51">51</a>
     <a href="#section-5.10">5.10</a>. Option Definitions  . . . . . . . . . . . . . . . . . . .  <a href="#page-52">52</a>
       <a href="#section-5.10.1">5.10.1</a>.  Uri-Host, Uri-Port, Uri-Path, and Uri-Query  . . . .  <a href="#page-53">53</a>
       <a href="#section-5.10.2">5.10.2</a>.  Proxy-Uri and Proxy-Scheme . . . . . . . . . . . . .  <a href="#page-54">54</a>
       <a href="#section-5.10.3">5.10.3</a>.  Content-Format . . . . . . . . . . . . . . . . . . .  <a href="#page-55">55</a>
       <a href="#section-5.10.4">5.10.4</a>.  Accept . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-55">55</a>
       <a href="#section-5.10.5">5.10.5</a>.  Max-Age  . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-55">55</a>
       <a href="#section-5.10.6">5.10.6</a>.  ETag . . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-56">56</a>
       <a href="#section-5.10.7">5.10.7</a>.  Location-Path and Location-Query . . . . . . . . . .  <a href="#page-57">57</a>
       <a href="#section-5.10.8">5.10.8</a>.  Conditional Request Options  . . . . . . . . . . . .  <a href="#page-57">57</a>
       <a href="#section-5.10.9">5.10.9</a>.  Size1 Option . . . . . . . . . . . . . . . . . . . .  <a href="#page-59">59</a>
   <a href="#section-6">6</a>.  CoAP URIs . . . . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-59">59</a>
     <a href="#section-6.1">6.1</a>.  coap URI Scheme . . . . . . . . . . . . . . . . . . . . .  <a href="#page-59">59</a>
     <a href="#section-6.2">6.2</a>.  coaps URI Scheme  . . . . . . . . . . . . . . . . . . . .  <a href="#page-60">60</a>
     <a href="#section-6.3">6.3</a>.  Normalization and Comparison Rules  . . . . . . . . . . .  <a href="#page-61">61</a>
     <a href="#section-6.4">6.4</a>.  Decomposing URIs into Options . . . . . . . . . . . . . .  <a href="#page-61">61</a>
     <a href="#section-6.5">6.5</a>.  Composing URIs from Options . . . . . . . . . . . . . . .  <a href="#page-62">62</a>
   <a href="#section-7">7</a>.  Discovery . . . . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-64">64</a>
     <a href="#section-7.1">7.1</a>.  Service Discovery . . . . . . . . . . . . . . . . . . . .  <a href="#page-64">64</a>
     <a href="#section-7.2">7.2</a>.  Resource Discovery  . . . . . . . . . . . . . . . . . . .  <a href="#page-64">64</a>
       <a href="#section-7.2.1">7.2.1</a>.  'ct' Attribute  . . . . . . . . . . . . . . . . . . .  <a href="#page-64">64</a>



<span class="grey">Shelby, et al.               Standards Track                    [Page 3]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-4" id="page-4" name="page-4"> </a>
<span class="grey"><a href="rfc7252.html">RFC 7252</a>       The Constrained Application Protocol (CoAP)     June 2014</span>


   <a href="#section-8">8</a>.  Multicast CoAP  . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-65">65</a>
     <a href="#section-8.1">8.1</a>.  Messaging Layer . . . . . . . . . . . . . . . . . . . . .  <a href="#page-65">65</a>
     <a href="#section-8.2">8.2</a>.  Request/Response Layer  . . . . . . . . . . . . . . . . .  <a href="#page-66">66</a>
       <a href="#section-8.2.1">8.2.1</a>.  Caching . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-67">67</a>
       <a href="#section-8.2.2">8.2.2</a>.  Proxying  . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-67">67</a>
   <a href="#section-9">9</a>.  Securing CoAP . . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-68">68</a>
     <a href="#section-9.1">9.1</a>.  DTLS-Secured CoAP . . . . . . . . . . . . . . . . . . . .  <a href="#page-69">69</a>
       <a href="#section-9.1.1">9.1.1</a>.  Messaging Layer . . . . . . . . . . . . . . . . . . .  <a href="#page-70">70</a>
       <a href="#section-9.1.2">9.1.2</a>.  Request/Response Layer  . . . . . . . . . . . . . . .  <a href="#page-71">71</a>
       <a href="#section-9.1.3">9.1.3</a>.  Endpoint Identity . . . . . . . . . . . . . . . . . .  <a href="#page-71">71</a>
   <a href="#section-10">10</a>. Cross-Protocol Proxying between CoAP and HTTP . . . . . . . .  <a href="#page-74">74</a>
     <a href="#section-10.1">10.1</a>.  CoAP-HTTP Proxying . . . . . . . . . . . . . . . . . . .  <a href="#page-75">75</a>
       <a href="#section-10.1.1">10.1.1</a>.  GET  . . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-76">76</a>
       <a href="#section-10.1.2">10.1.2</a>.  PUT  . . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-77">77</a>
       <a href="#section-10.1.3">10.1.3</a>.  DELETE . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-77">77</a>
       <a href="#section-10.1.4">10.1.4</a>.  POST . . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-77">77</a>
     <a href="#section-10.2">10.2</a>.  HTTP-CoAP Proxying . . . . . . . . . . . . . . . . . . .  <a href="#page-77">77</a>
       <a href="#section-10.2.1">10.2.1</a>.  OPTIONS and TRACE  . . . . . . . . . . . . . . . . .  <a href="#page-78">78</a>
       <a href="#section-10.2.2">10.2.2</a>.  GET  . . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-78">78</a>
       <a href="#section-10.2.3">10.2.3</a>.  HEAD . . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-79">79</a>
       <a href="#section-10.2.4">10.2.4</a>.  POST . . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-79">79</a>
       <a href="#section-10.2.5">10.2.5</a>.  PUT  . . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-79">79</a>
       <a href="#section-10.2.6">10.2.6</a>.  DELETE . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-80">80</a>
       <a href="#section-10.2.7">10.2.7</a>.  CONNECT  . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-80">80</a>
   <a href="#section-11">11</a>. Security Considerations . . . . . . . . . . . . . . . . . . .  <a href="#page-80">80</a>
     <a href="#section-11.1">11.1</a>.  Parsing the Protocol and Processing URIs . . . . . . . .  <a href="#page-80">80</a>
     <a href="#section-11.2">11.2</a>.  Proxying and Caching . . . . . . . . . . . . . . . . . .  <a href="#page-81">81</a>
     <a href="#section-11.3">11.3</a>.  Risk of Amplification  . . . . . . . . . . . . . . . . .  <a href="#page-81">81</a>
     <a href="#section-11.4">11.4</a>.  IP Address Spoofing Attacks  . . . . . . . . . . . . . .  <a href="#page-83">83</a>
     <a href="#section-11.5">11.5</a>.  Cross-Protocol Attacks . . . . . . . . . . . . . . . . .  <a href="#page-84">84</a>
     <a href="#section-11.6">11.6</a>.  Constrained-Node Considerations  . . . . . . . . . . . .  <a href="#page-86">86</a>
   <a href="#section-12">12</a>. IANA Considerations . . . . . . . . . . . . . . . . . . . . .  <a href="#page-86">86</a>
     <a href="#section-12.1">12.1</a>.  CoAP Code Registries . . . . . . . . . . . . . . . . . .  <a href="#page-86">86</a>
       <a href="#section-12.1.1">12.1.1</a>.  Method Codes . . . . . . . . . . . . . . . . . . . .  <a href="#page-87">87</a>
       <a href="#section-12.1.2">12.1.2</a>.  Response Codes . . . . . . . . . . . . . . . . . . .  <a href="#page-88">88</a>
     <a href="#section-12.2">12.2</a>.  CoAP Option Numbers Registry . . . . . . . . . . . . . .  <a href="#page-89">89</a>
     <a href="#section-12.3">12.3</a>.  CoAP Content-Formats Registry  . . . . . . . . . . . . .  <a href="#page-91">91</a>
     <a href="#section-12.4">12.4</a>.  URI Scheme Registration  . . . . . . . . . . . . . . . .  <a href="#page-93">93</a>
     <a href="#section-12.5">12.5</a>.  Secure URI Scheme Registration . . . . . . . . . . . . .  <a href="#page-94">94</a>
     <a href="#section-12.6">12.6</a>.  Service Name and Port Number Registration  . . . . . . .  <a href="#page-95">95</a>
     <a href="#section-12.7">12.7</a>.  Secure Service Name and Port Number Registration . . . .  <a href="#page-96">96</a>
     <a href="#section-12.8">12.8</a>.  Multicast Address Registration . . . . . . . . . . . . .  <a href="#page-97">97</a>
   <a href="#section-13">13</a>. Acknowledgements  . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-97">97</a>
   <a href="#section-14">14</a>. References  . . . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-98">98</a>
     <a href="#section-14.1">14.1</a>.  Normative References . . . . . . . . . . . . . . . . . .  <a href="#page-98">98</a>
     <a href="#section-14.2">14.2</a>.  Informative References . . . . . . . . . . . . . . . . . <a href="#page-100">100</a>
   <a href="#appendix-A">Appendix A</a>.  Examples . . . . . . . . . . . . . . . . . . . . . . <a href="#page-104">104</a>
   <a href="#appendix-B">Appendix B</a>.  URI Examples . . . . . . . . . . . . . . . . . . . . <a href="#page-110">110</a>



<span class="grey">Shelby, et al.               Standards Track                    [Page 4]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-5" id="page-5" name="page-5"> </a>
<span class="grey"><a href="rfc7252.html">RFC 7252</a>       The Constrained Application Protocol (CoAP)     June 2014</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/1.%20%20Introduction"></a><a class="selflink" href="#section-1" name="section-1">1</a>.  Introduction</span>

   The use of web services (web APIs) on the Internet has become
   ubiquitous in most applications and depends on the fundamental
   Representational State Transfer [<a href="#ref-REST" title='"Architectural Styles and the Design of Network-based Software Architectures"'>REST</a>] architecture of the Web.

   The work on Constrained RESTful Environments (CoRE) aims at realizing
   the REST architecture in a suitable form for the most constrained
   nodes (e.g., 8-bit microcontrollers with limited RAM and ROM) and
   networks (e.g., 6LoWPAN, [<a href="rfc4944.html" title='"Transmission of IPv6 Packets over IEEE 802.15.4 Networks"'>RFC4944</a>]).  Constrained networks such as
   6LoWPAN support the fragmentation of IPv6 packets into small link-
   layer frames; however, this causes significant reduction in packet
   delivery probability.  One design goal of CoAP has been to keep
   message overhead small, thus limiting the need for fragmentation.

   One of the main goals of CoAP is to design a generic web protocol for
   the special requirements of this constrained environment, especially
   considering energy, building automation, and other machine-to-machine
   (M2M) applications.  The goal of CoAP is not to blindly compress HTTP
   [<a href="rfc2616.html" title='"Hypertext Transfer Protocol -- HTTP/1.1"'>RFC2616</a>], but rather to realize a subset of REST common with HTTP
   but optimized for M2M applications.  Although CoAP could be used for
   refashioning simple HTTP interfaces into a more compact protocol,
   more importantly it also offers features for M2M such as built-in
   discovery, multicast support, and asynchronous message exchanges.

   This document specifies the Constrained Application Protocol (CoAP),
   which easily translates to HTTP for integration with the existing Web
   while meeting specialized requirements such as multicast support,
   very low overhead, and simplicity for constrained environments and
   M2M applications.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/1.1.%20%20Features"></a><a class="selflink" href="#section-1.1" name="section-1.1">1.1</a>.  Features</span>

   CoAP has the following main features:

   o  Web protocol fulfilling M2M requirements in constrained
      environments

   o  UDP [<a href="https://tools.ietf.org/html/rfc0768" title='"User Datagram Protocol"'>RFC0768</a>] binding with optional reliability supporting unicast
      and multicast requests.

   o  Asynchronous message exchanges.

   o  Low header overhead and parsing complexity.

   o  URI and Content-type support.

   o  Simple proxy and caching capabilities.



<span class="grey">Shelby, et al.               Standards Track                    [Page 5]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-6" id="page-6" name="page-6"> </a>
<span class="grey"><a href="rfc7252.html">RFC 7252</a>       The Constrained Application Protocol (CoAP)     June 2014</span>


   o  A stateless HTTP mapping, allowing proxies to be built providing
      access to CoAP resources via HTTP in a uniform way or for HTTP
      simple interfaces to be realized alternatively over CoAP.

   o  Security binding to Datagram Transport Layer Security (DTLS)
      [<a href="rfc6347.html" title='"Datagram Transport Layer Security Version 1.2"'>RFC6347</a>].

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/1.2.%20%20Terminology"></a><a class="selflink" href="#section-1.2" name="section-1.2">1.2</a>.  Terminology</span>

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
   "OPTIONAL" in this document are to be interpreted as described in
   [<a href="rfc2119.html" title='"Key words for use in RFCs to Indicate Requirement Levels"'>RFC2119</a>] when they appear in ALL CAPS.  These words may also appear
   in this document in lowercase, absent their normative meanings.

   This specification requires readers to be familiar with all the terms
   and concepts that are discussed in [<a href="rfc2616.html" title='"Hypertext Transfer Protocol -- HTTP/1.1"'>RFC2616</a>], including "resource",
   "representation", "cache", and "fresh".  (Having been completed
   before the updated set of HTTP RFCs, <a href="rfc7230.html">RFC 7230</a> to <a href="rfc7235.html">RFC 7235</a>, became
   available, this specification specifically references the predecessor
   version -- <a href="rfc2616.html">RFC 2616</a>.)  In addition, this specification defines the
   following terminology:

   Endpoint
      An entity participating in the CoAP protocol.  Colloquially, an
      endpoint lives on a "Node", although "Host" would be more
      consistent with Internet standards usage, and is further
      identified by transport-layer multiplexing information that can
      include a UDP port number and a security association
      (<a href="#section-4.1">Section 4.1</a>).

   Sender
      The originating endpoint of a message.  When the aspect of
      identification of the specific sender is in focus, also "source
      endpoint".

   Recipient
      The destination endpoint of a message.  When the aspect of
      identification of the specific recipient is in focus, also
      "destination endpoint".

   Client
      The originating endpoint of a request; the destination endpoint of
      a response.

   Server
      The destination endpoint of a request; the originating endpoint of
      a response.



<span class="grey">Shelby, et al.               Standards Track                    [Page 6]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-7" id="page-7" name="page-7"> </a>
<span class="grey"><a href="rfc7252.html">RFC 7252</a>       The Constrained Application Protocol (CoAP)     June 2014</span>


   Origin Server
      The server on which a given resource resides or is to be created.

   Intermediary
      A CoAP endpoint that acts both as a server and as a client towards
      an origin server (possibly via further intermediaries).  A common
      form of an intermediary is a proxy; several classes of such
      proxies are discussed in this specification.

   Proxy
      An intermediary that mainly is concerned with forwarding requests
      and relaying back responses, possibly performing caching,
      namespace translation, or protocol translation in the process.  As
      opposed to intermediaries in the general sense, proxies generally
      do not implement specific application semantics.  Based on the
      position in the overall structure of the request forwarding, there
      are two common forms of proxy: forward-proxy and reverse-proxy.
      In some cases, a single endpoint might act as an origin server,
      forward-proxy, or reverse-proxy, switching behavior based on the
      nature of each request.

   Forward-Proxy
      An endpoint selected by a client, usually via local configuration
      rules, to perform requests on behalf of the client, doing any
      necessary translations.  Some translations are minimal, such as
      for proxy requests for "coap" URIs, whereas other requests might
      require translation to and from entirely different application-
      layer protocols.

   Reverse-Proxy
      An endpoint that stands in for one or more other server(s) and
      satisfies requests on behalf of these, doing any necessary
      translations.  Unlike a forward-proxy, the client may not be aware
      that it is communicating with a reverse-proxy; a reverse-proxy
      receives requests as if it were the origin server for the target
      resource.

   CoAP-to-CoAP Proxy
      A proxy that maps from a CoAP request to a CoAP request, i.e.,
      uses the CoAP protocol both on the server and the client side.
      Contrast to cross-proxy.

   Cross-Proxy
      A cross-protocol proxy, or "cross-proxy" for short, is a proxy
      that translates between different protocols, such as a CoAP-to-
      HTTP proxy or an HTTP-to-CoAP proxy.  While this specification
      makes very specific demands of CoAP-to-CoAP proxies, there is more
      variation possible in cross-proxies.



<span class="grey">Shelby, et al.               Standards Track                    [Page 7]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-8" id="page-8" name="page-8"> </a>
<span class="grey"><a href="rfc7252.html">RFC 7252</a>       The Constrained Application Protocol (CoAP)     June 2014</span>


   Confirmable Message
      Some messages require an acknowledgement.  These messages are
      called "Confirmable".  When no packets are lost, each Confirmable
      message elicits exactly one return message of type Acknowledgement
      or type Reset.

   Non-confirmable Message
      Some other messages do not require an acknowledgement.  This is
      particularly true for messages that are repeated regularly for
      application requirements, such as repeated readings from a sensor.

   Acknowledgement Message
      An Acknowledgement message acknowledges that a specific
      Confirmable message arrived.  By itself, an Acknowledgement
      message does not indicate success or failure of any request
      encapsulated in the Confirmable message, but the Acknowledgement
      message may also carry a Piggybacked Response (see below).

   Reset Message
      A Reset message indicates that a specific message (Confirmable or
      Non-confirmable) was received, but some context is missing to
      properly process it.  This condition is usually caused when the
      receiving node has rebooted and has forgotten some state that
      would be required to interpret the message.  Provoking a Reset
      message (e.g., by sending an Empty Confirmable message) is also
      useful as an inexpensive check of the liveness of an endpoint
      ("CoAP ping").

   Piggybacked Response
      A piggybacked Response is included right in a CoAP Acknowledgement
      (ACK) message that is sent to acknowledge receipt of the Request
      for this Response (<a href="#section-5.2.1">Section 5.2.1</a>).

   Separate Response
      When a Confirmable message carrying a request is acknowledged with
      an Empty message (e.g., because the server doesn't have the answer
      right away), a Separate Response is sent in a separate message
      exchange (<a href="#section-5.2.2">Section 5.2.2</a>).

   Empty Message
      A message with a Code of 0.00; neither a request nor a response.
      An Empty message only contains the 4-byte header.









<span class="grey">Shelby, et al.               Standards Track                    [Page 8]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-9" id="page-9" name="page-9"> </a>
<span class="grey"><a href="rfc7252.html">RFC 7252</a>       The Constrained Application Protocol (CoAP)     June 2014</span>


   Critical Option
      An option that would need to be understood by the endpoint
      ultimately receiving the message in order to properly process the
      message (<a href="#section-5.4.1">Section 5.4.1</a>).  Note that the implementation of critical
      options is, as the name "Option" implies, generally optional:
      unsupported critical options lead to an error response or summary
      rejection of the message.

   Elective Option
      An option that is intended to be ignored by an endpoint that does
      not understand it.  Processing the message even without
      understanding the option is acceptable (<a href="#section-5.4.1">Section 5.4.1</a>).

   Unsafe Option
      An option that would need to be understood by a proxy receiving
      the message in order to safely forward the message
      (<a href="#section-5.4.2">Section 5.4.2</a>).  Not every critical option is an unsafe option.

   Safe-to-Forward Option
      An option that is intended to be safe for forwarding by a proxy
      that does not understand it.  Forwarding the message even without
      understanding the option is acceptable (<a href="#section-5.4.2">Section 5.4.2</a>).

   Resource Discovery
      The process where a CoAP client queries a server for its list of
      hosted resources (i.e., links as defined in <a href="#section-7">Section 7</a>).

   Content-Format
      The combination of an Internet media type, potentially with
      specific parameters given, and a content-coding (which is often
      the identity content-coding), identified by a numeric identifier
      defined by the "CoAP Content-Formats" registry.  When the focus is
      less on the numeric identifier than on the combination of these
      characteristics of a resource representation, this is also called
      "representation format".

   Additional terminology for constrained nodes and constrained-node
   networks can be found in [<a href="rfc7228.html" title='"Terminology for Constrained-Node Networks"'>RFC7228</a>].

   In this specification, the term "byte" is used in its now customary
   sense as a synonym for "octet".

   All multi-byte integers in this protocol are interpreted in network
   byte order.

   Where arithmetic is used, this specification uses the notation
   familiar from the programming language C, except that the operator
   "**" stands for exponentiation.



<span class="grey">Shelby, et al.               Standards Track                    [Page 9]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-10" id="page-10" name="page-10"> </a>
<span class="grey"><a href="rfc7252.html">RFC 7252</a>       The Constrained Application Protocol (CoAP)     June 2014</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/2.%20%20Constrained%20Application%20Protocol"></a><a class="selflink" href="#section-2" name="section-2">2</a>.  Constrained Application Protocol</span>

   The interaction model of CoAP is similar to the client/server model
   of HTTP.  However, machine-to-machine interactions typically result
   in a CoAP implementation acting in both client and server roles.  A
   CoAP request is equivalent to that of HTTP and is sent by a client to
   request an action (using a Method Code) on a resource (identified by
   a URI) on a server.  The server then sends a response with a Response
   Code; this response may include a resource representation.

   Unlike HTTP, CoAP deals with these interchanges asynchronously over a
   datagram-oriented transport such as UDP.  This is done logically
   using a layer of messages that supports optional reliability (with
   exponential back-off).  CoAP defines four types of messages:
   Confirmable, Non-confirmable, Acknowledgement, Reset.  Method Codes
   and Response Codes included in some of these messages make them carry
   requests or responses.  The basic exchanges of the four types of
   messages are somewhat orthogonal to the request/response
   interactions; requests can be carried in Confirmable and Non-
   confirmable messages, and responses can be carried in these as well
   as piggybacked in Acknowledgement messages.

   One could think of CoAP logically as using a two-layer approach, a
   CoAP messaging layer used to deal with UDP and the asynchronous
   nature of the interactions, and the request/response interactions
   using Method and Response Codes (see Figure 1).  CoAP is however a
   single protocol, with messaging and request/response as just features
   of the CoAP header.

                        +----------------------+
                        |      Application     |
                        +----------------------+
                        +----------------------+  \
                        |  Requests/Responses  |  |
                        |----------------------|  | CoAP
                        |       Messages       |  |
                        +----------------------+  /
                        +----------------------+
                        |          UDP         |
                        +----------------------+

                    Figure 1: Abstract Layering of CoAP









<span class="grey">Shelby, et al.               Standards Track                   [Page 10]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-11" id="page-11" name="page-11"> </a>
<span class="grey"><a href="rfc7252.html">RFC 7252</a>       The Constrained Application Protocol (CoAP)     June 2014</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/2.1.%20%20Messaging%20Model"></a><a class="selflink" href="#section-2.1" name="section-2.1">2.1</a>.  Messaging Model</span>

   The CoAP messaging model is based on the exchange of messages over
   UDP between endpoints.

   CoAP uses a short fixed-length binary header (4 bytes) that may be
   followed by compact binary options and a payload.  This message
   format is shared by requests and responses.  The CoAP message format
   is specified in <a href="#section-3">Section 3</a>.  Each message contains a Message ID used
   to detect duplicates and for optional reliability.  (The Message ID
   is compact; its 16-bit size enables up to about 250 messages per
   second from one endpoint to another with default protocol
   parameters.)

   Reliability is provided by marking a message as Confirmable (CON).  A
   Confirmable message is retransmitted using a default timeout and
   exponential back-off between retransmissions, until the recipient
   sends an Acknowledgement message (ACK) with the same Message ID (in
   this example, 0x7d34) from the corresponding endpoint; see Figure 2.
   When a recipient is not at all able to process a Confirmable message
   (i.e., not even able to provide a suitable error response), it
   replies with a Reset message (RST) instead of an Acknowledgement
   (ACK).

                        Client              Server
                           |                  |
                           |   CON [0x7d34]   |
                           +-----------------&gt;|
                           |                  |
                           |   ACK [0x7d34]   |
                           |&lt;-----------------+
                           |                  |

                  Figure 2: Reliable Message Transmission

   A message that does not require reliable transmission (for example,
   each single measurement out of a stream of sensor data) can be sent
   as a Non-confirmable message (NON).  These are not acknowledged, but
   still have a Message ID for duplicate detection (in this example,
   0x01a0); see Figure 3.  When a recipient is not able to process a
   Non-confirmable message, it may reply with a Reset message (RST).










<span class="grey">Shelby, et al.               Standards Track                   [Page 11]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-12" id="page-12" name="page-12"> </a>
<span class="grey"><a href="rfc7252.html">RFC 7252</a>       The Constrained Application Protocol (CoAP)     June 2014</span>


                        Client              Server
                           |                  |
                           |   NON [0x01a0]   |
                           +-----------------&gt;|
                           |                  |

                 Figure 3: Unreliable Message Transmission

   See <a href="#section-4">Section 4</a> for details of CoAP messages.

   As CoAP runs over UDP, it also supports the use of multicast IP
   destination addresses, enabling multicast CoAP requests.  <a href="#section-8">Section 8</a>
   discusses the proper use of CoAP messages with multicast addresses
   and precautions for avoiding response congestion.

   Several security modes are defined for CoAP in <a href="#section-9">Section 9</a> ranging from
   no security to certificate-based security.  This document specifies a
   binding to DTLS for securing the protocol; the use of IPsec with CoAP
   is discussed in [<a href="#ref-IPsec-CoAP">IPsec-CoAP</a>].

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/2.2.%20%20Request%2FResponse%20Model"></a><a class="selflink" href="#section-2.2" name="section-2.2">2.2</a>.  Request/Response Model</span>

   CoAP request and response semantics are carried in CoAP messages,
   which include either a Method Code or Response Code, respectively.
   Optional (or default) request and response information, such as the
   URI and payload media type are carried as CoAP options.  A Token is
   used to match responses to requests independently from the underlying
   messages (<a href="#section-5.3">Section 5.3</a>).  (Note that the Token is a concept separate
   from the Message ID.)

   A request is carried in a Confirmable (CON) or Non-confirmable (NON)
   message, and, if immediately available, the response to a request
   carried in a Confirmable message is carried in the resulting
   Acknowledgement (ACK) message.  This is called a piggybacked
   response, detailed in <a href="#section-5.2.1">Section 5.2.1</a>.  (There is no need for
   separately acknowledging a piggybacked response, as the client will
   retransmit the request if the Acknowledgement message carrying the
   piggybacked response is lost.)  Two examples for a basic GET request
   with piggybacked response are shown in Figure 4, one successful, one
   resulting in a 4.04 (Not Found) response.











<span class="grey">Shelby, et al.               Standards Track                   [Page 12]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-13" id="page-13" name="page-13"> </a>
<span class="grey"><a href="rfc7252.html">RFC 7252</a>       The Constrained Application Protocol (CoAP)     June 2014</span>


        Client              Server       Client              Server
           |                  |             |                  |
           |   CON [0xbc90]   |             |   CON [0xbc91]   |
           | GET /temperature |             | GET /temperature |
           |   (Token 0x71)   |             |   (Token 0x72)   |
           +-----------------&gt;|             +-----------------&gt;|
           |                  |             |                  |
           |   ACK [0xbc90]   |             |   ACK [0xbc91]   |
           |   2.05 Content   |             |  4.04 Not Found  |
           |   (Token 0x71)   |             |   (Token 0x72)   |
           |     "22.5 C"     |             |   "Not found"    |
           |&lt;-----------------+             |&lt;-----------------+
           |                  |             |                  |

           Figure 4: Two GET Requests with Piggybacked Responses

   If the server is not able to respond immediately to a request carried
   in a Confirmable message, it simply responds with an Empty
   Acknowledgement message so that the client can stop retransmitting
   the request.  When the response is ready, the server sends it in a
   new Confirmable message (which then in turn needs to be acknowledged
   by the client).  This is called a "separate response", as illustrated
   in Figure 5 and described in more detail in <a href="#section-5.2.2">Section 5.2.2</a>.

                        Client              Server
                           |                  |
                           |   CON [0x7a10]   |
                           | GET /temperature |
                           |   (Token 0x73)   |
                           +-----------------&gt;|
                           |                  |
                           |   ACK [0x7a10]   |
                           |&lt;-----------------+
                           |                  |
                           ... Time Passes  ...
                           |                  |
                           |   CON [0x23bb]   |
                           |   2.05 Content   |
                           |   (Token 0x73)   |
                           |     "22.5 C"     |
                           |&lt;-----------------+
                           |                  |
                           |   ACK [0x23bb]   |
                           +-----------------&gt;|
                           |                  |

             Figure 5: A GET Request with a Separate Response




<span class="grey">Shelby, et al.               Standards Track                   [Page 13]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-14" id="page-14" name="page-14"> </a>
<span class="grey"><a href="rfc7252.html">RFC 7252</a>       The Constrained Application Protocol (CoAP)     June 2014</span>


   If a request is sent in a Non-confirmable message, then the response
   is sent using a new Non-confirmable message, although the server may
   instead send a Confirmable message.  This type of exchange is
   illustrated in Figure 6.

                        Client              Server
                           |                  |
                           |   NON [0x7a11]   |
                           | GET /temperature |
                           |   (Token 0x74)   |
                           +-----------------&gt;|
                           |                  |
                           |   NON [0x23bc]   |
                           |   2.05 Content   |
                           |   (Token 0x74)   |
                           |     "22.5 C"     |
                           |&lt;-----------------+
                           |                  |

       Figure 6: A Request and a Response Carried in Non-confirmable
                                 Messages

   CoAP makes use of GET, PUT, POST, and DELETE methods in a similar
   manner to HTTP, with the semantics specified in <a href="#section-5.8">Section 5.8</a>.  (Note
   that the detailed semantics of CoAP methods are "almost, but not
   entirely unlike" [<a href="#ref-HHGTTG" title="&quot;The Hitchhiker's Guide to the Galaxy&quot;">HHGTTG</a>] those of HTTP methods: intuition taken from
   HTTP experience generally does apply well, but there are enough
   differences that make it worthwhile to actually read the present
   specification.)

   Methods beyond the basic four can be added to CoAP in separate
   specifications.  New methods do not necessarily have to use requests
   and responses in pairs.  Even for existing methods, a single request
   may yield multiple responses, e.g., for a multicast request
   (<a href="#section-8">Section 8</a>) or with the Observe option [<a href="#ref-OBSERVE" title='"Observing Resources in CoAP"'>OBSERVE</a>].

   URI support in a server is simplified as the client already parses
   the URI and splits it into host, port, path, and query components,
   making use of default values for efficiency.  Response Codes relate
   to a small subset of HTTP status codes with a few CoAP-specific codes
   added, as defined in <a href="#section-5.9">Section 5.9</a>.










<span class="grey">Shelby, et al.               Standards Track                   [Page 14]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-15" id="page-15" name="page-15"> </a>
<span class="grey"><a href="rfc7252.html">RFC 7252</a>       The Constrained Application Protocol (CoAP)     June 2014</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/2.3.%20%20Intermediaries%20and%20Caching"></a><a class="selflink" href="#section-2.3" name="section-2.3">2.3</a>.  Intermediaries and Caching</span>

   The protocol supports the caching of responses in order to
   efficiently fulfill requests.  Simple caching is enabled using
   freshness and validity information carried with CoAP responses.  A
   cache could be located in an endpoint or an intermediary.  Caching
   functionality is specified in <a href="#section-5.6">Section 5.6</a>.

   Proxying is useful in constrained networks for several reasons,
   including to limit network traffic, to improve performance, to access
   resources of sleeping devices, and for security reasons.  The
   proxying of requests on behalf of another CoAP endpoint is supported
   in the protocol.  When using a proxy, the URI of the resource to
   request is included in the request, while the destination IP address
   is set to the address of the proxy.  See <a href="#section-5.7">Section 5.7</a> for more
   information on proxy functionality.

   As CoAP was designed according to the REST architecture [<a href="#ref-REST" title='"Architectural Styles and the Design of Network-based Software Architectures"'>REST</a>], and
   thus exhibits functionality similar to that of the HTTP protocol, it
   is quite straightforward to map from CoAP to HTTP and from HTTP to
   CoAP.  Such a mapping may be used to realize an HTTP REST interface
   using CoAP or to convert between HTTP and CoAP.  This conversion can
   be carried out by a cross-protocol proxy ("cross-proxy"), which
   converts the Method or Response Code, media type, and options to the
   corresponding HTTP feature.  <a href="#section-10">Section 10</a> provides more detail about
   HTTP mapping.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/2.4.%20%20Resource%20Discovery"></a><a class="selflink" href="#section-2.4" name="section-2.4">2.4</a>.  Resource Discovery</span>

   Resource discovery is important for machine-to-machine interactions
   and is supported using the CoRE Link Format [<a href="rfc6690.html" title='"Constrained RESTful Environments (CoRE) Link Format"'>RFC6690</a>] as discussed in
   <a href="#section-7">Section 7</a>.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/3.%20%20Message%20Format"></a><a class="selflink" href="#section-3" name="section-3">3</a>.  Message Format</span>

   CoAP is based on the exchange of compact messages that, by default,
   are transported over UDP (i.e., each CoAP message occupies the data
   section of one UDP datagram).  CoAP may also be used over Datagram
   Transport Layer Security (DTLS) (see <a href="#section-9.1">Section 9.1</a>).  It could also be
   used over other transports such as SMS, TCP, or SCTP, the
   specification of which is out of this document's scope.  (UDP-lite
   [<a href="rfc3828.html" title='"The Lightweight User Datagram Protocol (UDP-Lite)"'>RFC3828</a>] and UDP zero checksum [<a href="rfc6936.html" title='"Applicability Statement for the Use of IPv6 UDP Datagrams with Zero Checksums"'>RFC6936</a>] are not supported by CoAP.)

   CoAP messages are encoded in a simple binary format.  The message
   format starts with a fixed-size 4-byte header.  This is followed by a
   variable-length Token value, which can be between 0 and 8 bytes long.





<span class="grey">Shelby, et al.               Standards Track                   [Page 15]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-16" id="page-16" name="page-16"> </a>
<span class="grey"><a href="rfc7252.html">RFC 7252</a>       The Constrained Application Protocol (CoAP)     June 2014</span>


   Following the Token value comes a sequence of zero or more CoAP
   Options in Type-Length-Value (TLV) format, optionally followed by a
   payload that takes up the rest of the datagram.

    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |Ver| T |  TKL  |      Code     |          Message ID           |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |   Token (if any, TKL bytes) ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |   Options (if any) ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |1 1 1 1 1 1 1 1|    Payload (if any) ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                         Figure 7: Message Format

   The fields in the header are defined as follows:

   Version (Ver):  2-bit unsigned integer.  Indicates the CoAP version
      number.  Implementations of this specification MUST set this field
      to 1 (01 binary).  Other values are reserved for future versions.
      Messages with unknown version numbers MUST be silently ignored.

   Type (T):  2-bit unsigned integer.  Indicates if this message is of
      type Confirmable (0), Non-confirmable (1), Acknowledgement (2), or
      Reset (3).  The semantics of these message types are defined in
      <a href="#section-4">Section 4</a>.

   Token Length (TKL):  4-bit unsigned integer.  Indicates the length of
      the variable-length Token field (0-8 bytes).  Lengths 9-15 are
      reserved, MUST NOT be sent, and MUST be processed as a message
      format error.

   Code:  8-bit unsigned integer, split into a 3-bit class (most
      significant bits) and a 5-bit detail (least significant bits),
      documented as "c.dd" where "c" is a digit from 0 to 7 for the
      3-bit subfield and "dd" are two digits from 00 to 31 for the 5-bit
      subfield.  The class can indicate a request (0), a success
      response (2), a client error response (4), or a server error
      response (5).  (All other class values are reserved.)  As a
      special case, Code 0.00 indicates an Empty message.  In case of a
      request, the Code field indicates the Request Method; in case of a
      response, a Response Code.  Possible values are maintained in the
      CoAP Code Registries (<a href="#section-12.1">Section 12.1</a>).  The semantics of requests
      and responses are defined in <a href="#section-5">Section 5</a>.




<span class="grey">Shelby, et al.               Standards Track                   [Page 16]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-17" id="page-17" name="page-17"> </a>
<span class="grey"><a href="rfc7252.html">RFC 7252</a>       The Constrained Application Protocol (CoAP)     June 2014</span>


   Message ID:  16-bit unsigned integer in network byte order.  Used to
      detect message duplication and to match messages of type
      Acknowledgement/Reset to messages of type Confirmable/Non-
      confirmable.  The rules for generating a Message ID and matching
      messages are defined in <a href="#section-4">Section 4</a>.

   The header is followed by the Token value, which may be 0 to 8 bytes,
   as given by the Token Length field.  The Token value is used to
   correlate requests and responses.  The rules for generating a Token
   and correlating requests and responses are defined in <a href="#section-5.3.1">Section 5.3.1</a>.

   Header and Token are followed by zero or more Options (<a href="#section-3.1">Section 3.1</a>).
   An Option can be followed by the end of the message, by another
   Option, or by the Payload Marker and the payload.

   Following the header, token, and options, if any, comes the optional
   payload.  If present and of non-zero length, it is prefixed by a
   fixed, one-byte Payload Marker (0xFF), which indicates the end of
   options and the start of the payload.  The payload data extends from
   after the marker to the end of the UDP datagram, i.e., the Payload
   Length is calculated from the datagram size.  The absence of the
   Payload Marker denotes a zero-length payload.  The presence of a
   marker followed by a zero-length payload MUST be processed as a
   message format error.

   Implementation Note:  The byte value 0xFF may also occur within an
      option length or value, so simple byte-wise scanning for 0xFF is
      not a viable technique for finding the payload marker.  The byte
      0xFF has the meaning of a payload marker only where the beginning
      of another option could occur.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.1.%20%20Option%20Format"></a><a class="selflink" href="#section-3.1" name="section-3.1">3.1</a>.  Option Format</span>

   CoAP defines a number of options that can be included in a message.
   Each option instance in a message specifies the Option Number of the
   defined CoAP option, the length of the Option Value, and the Option
   Value itself.

   Instead of specifying the Option Number directly, the instances MUST
   appear in order of their Option Numbers and a delta encoding is used
   between them: the Option Number for each instance is calculated as
   the sum of its delta and the Option Number of the preceding instance
   in the message.  For the first instance in a message, a preceding
   option instance with Option Number zero is assumed.  Multiple
   instances of the same option can be included by using a delta of
   zero.





<span class="grey">Shelby, et al.               Standards Track                   [Page 17]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-18" id="page-18" name="page-18"> </a>
<span class="grey"><a href="rfc7252.html">RFC 7252</a>       The Constrained Application Protocol (CoAP)     June 2014</span>


   Option Numbers are maintained in the "CoAP Option Numbers" registry
   (<a href="#section-12.2">Section 12.2</a>).  See <a href="#section-5.4">Section 5.4</a> for the semantics of the options
   defined in this document.

     0   1   2   3   4   5   6   7
   +---------------+---------------+
   |               |               |
   |  Option Delta | Option Length |   1 byte
   |               |               |
   +---------------+---------------+
   \                               \
   /         Option Delta          /   0-2 bytes
   \          (extended)           \
   +-------------------------------+
   \                               \
   /         Option Length         /   0-2 bytes
   \          (extended)           \
   +-------------------------------+
   \                               \
   /                               /
   \                               \
   /         Option Value          /   0 or more bytes
   \                               \
   /                               /
   \                               \
   +-------------------------------+

                          Figure 8: Option Format

   The fields in an option are defined as follows:

   Option Delta:  4-bit unsigned integer.  A value between 0 and 12
      indicates the Option Delta.  Three values are reserved for special
      constructs:

      13:  An 8-bit unsigned integer follows the initial byte and
         indicates the Option Delta minus 13.

      14:  A 16-bit unsigned integer in network byte order follows the
         initial byte and indicates the Option Delta minus 269.

      15:  Reserved for the Payload Marker.  If the field is set to this
         value but the entire byte is not the payload marker, this MUST
         be processed as a message format error.







<span class="grey">Shelby, et al.               Standards Track                   [Page 18]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-19" id="page-19" name="page-19"> </a>
<span class="grey"><a href="rfc7252.html">RFC 7252</a>       The Constrained Application Protocol (CoAP)     June 2014</span>


      The resulting Option Delta is used as the difference between the
      Option Number of this option and that of the previous option (or
      zero for the first option).  In other words, the Option Number is
      calculated by simply summing the Option Delta values of this and
      all previous options before it.

   Option Length:  4-bit unsigned integer.  A value between 0 and 12
      indicates the length of the Option Value, in bytes.  Three values
      are reserved for special constructs:

      13:  An 8-bit unsigned integer precedes the Option Value and
         indicates the Option Length minus 13.

      14:  A 16-bit unsigned integer in network byte order precedes the
         Option Value and indicates the Option Length minus 269.

      15:  Reserved for future use.  If the field is set to this value,
         it MUST be processed as a message format error.

   Value:  A sequence of exactly Option Length bytes.  The length and
      format of the Option Value depend on the respective option, which
      MAY define variable-length values.  See <a href="#section-3.2">Section 3.2</a> for the
      formats used in this document; options defined in other documents
      MAY make use of other option value formats.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.2.%20%20Option%20Value%20Formats"></a><a class="selflink" href="#section-3.2" name="section-3.2">3.2</a>.  Option Value Formats</span>

   The options defined in this document make use of the following option
   value formats.

   empty:    A zero-length sequence of bytes.

   opaque:   An opaque sequence of bytes.

   uint:     A non-negative integer that is represented in network byte
             order using the number of bytes given by the Option Length
             field.

             An option definition may specify a range of permissible
             numbers of bytes; if it has a choice, a sender SHOULD
             represent the integer with as few bytes as possible, i.e.,
             without leading zero bytes.  For example, the number 0 is
             represented with an empty option value (a zero-length
             sequence of bytes) and the number 1 by a single byte with
             the numerical value of 1 (bit combination 00000001 in most
             significant bit first notation).  A recipient MUST be
             prepared to process values with leading zero bytes.




<span class="grey">Shelby, et al.               Standards Track                   [Page 19]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-20" id="page-20" name="page-20"> </a>
<span class="grey"><a href="rfc7252.html">RFC 7252</a>       The Constrained Application Protocol (CoAP)     June 2014</span>


             Implementation Note:  The exceptional behavior permitted
                for the sender is intended for highly constrained,
                templated implementations (e.g., hardware
                implementations) that use fixed-size options in the
                templates.

   string:   A Unicode string that is encoded using UTF-8 [<a href="rfc3629.html" title='"UTF-8, a transformation format of ISO 10646"'>RFC3629</a>] in
             Net-Unicode form [<a href="rfc5198.html" title='"Unicode Format for Network Interchange"'>RFC5198</a>].

             Note that here, and in all other places where UTF-8
             encoding is used in the CoAP protocol, the intention is
             that the encoded strings can be directly used and compared
             as opaque byte strings by CoAP protocol implementations.
             There is no expectation and no need to perform
             normalization within a CoAP implementation (except where
             Unicode strings that are not known to be normalized are
             imported from sources outside the CoAP protocol).  Note
             also that ASCII strings (that do not make use of special
             control characters) are always valid UTF-8 Net-Unicode
             strings.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/4.%20%20Message%20Transmission"></a><a class="selflink" href="#section-4" name="section-4">4</a>.  Message Transmission</span>

   CoAP messages are exchanged asynchronously between CoAP endpoints.
   They are used to transport CoAP requests and responses, the semantics
   of which are defined in <a href="#section-5">Section 5</a>.

   As CoAP is bound to unreliable transports such as UDP, CoAP messages
   may arrive out of order, appear duplicated, or go missing without
   notice.  For this reason, CoAP implements a lightweight reliability
   mechanism, without trying to re-create the full feature set of a
   transport like TCP.  It has the following features:

   o  Simple stop-and-wait retransmission reliability with exponential
      back-off for Confirmable messages.

   o  Duplicate detection for both Confirmable and Non-confirmable
      messages.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.1.%20%20Messages%20and%20Endpoints"></a><a class="selflink" href="#section-4.1" name="section-4.1">4.1</a>.  Messages and Endpoints</span>

   A CoAP endpoint is the source or destination of a CoAP message.  The
   specific definition of an endpoint depends on the transport being
   used for CoAP.  For the transports defined in this specification, the
   endpoint is identified depending on the security mode used (see
   <a href="#section-9">Section 9</a>): With no security, the endpoint is solely identified by an
   IP address and a UDP port number.  With other security modes, the
   endpoint is identified as defined by the security mode.



<span class="grey">Shelby, et al.               Standards Track                   [Page 20]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-21" id="page-21" name="page-21"> </a>
<span class="grey"><a href="rfc7252.html">RFC 7252</a>       The Constrained Application Protocol (CoAP)     June 2014</span>


   There are different types of messages.  The type of a message is
   specified by the Type field of the CoAP Header.

   Separate from the message type, a message may carry a request, a
   response, or be Empty.  This is signaled by the Request/Response Code
   field in the CoAP Header and is relevant to the request/response
   model.  Possible values for the field are maintained in the CoAP Code
   Registries (<a href="#section-12.1">Section 12.1</a>).

   An Empty message has the Code field set to 0.00.  The Token Length
   field MUST be set to 0 and bytes of data MUST NOT be present after
   the Message ID field.  If there are any bytes, they MUST be processed
   as a message format error.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.2.%20%20Messages%20Transmitted%20Reliably"></a><a class="selflink" href="#section-4.2" name="section-4.2">4.2</a>.  Messages Transmitted Reliably</span>

   The reliable transmission of a message is initiated by marking the
   message as Confirmable in the CoAP header.  A Confirmable message
   always carries either a request or response, unless it is used only
   to elicit a Reset message, in which case it is Empty.  A recipient
   MUST either (a) acknowledge a Confirmable message with an
   Acknowledgement message or (b) reject the message if the recipient
   lacks context to process the message properly, including situations
   where the message is Empty, uses a code with a reserved class (1, 6,
   or 7), or has a message format error.  Rejecting a Confirmable
   message is effected by sending a matching Reset message and otherwise
   ignoring it.  The Acknowledgement message MUST echo the Message ID of
   the Confirmable message and MUST carry a response or be Empty (see
   Sections <a href="#section-5.2.1">5.2.1</a> and <a href="#section-5.2.2">5.2.2</a>).  The Reset message MUST echo the Message
   ID of the Confirmable message and MUST be Empty.  Rejecting an
   Acknowledgement or Reset message (including the case where the
   Acknowledgement carries a request or a code with a reserved class, or
   the Reset message is not Empty) is effected by silently ignoring it.
   More generally, recipients of Acknowledgement and Reset messages MUST
   NOT respond with either Acknowledgement or Reset messages.

   The sender retransmits the Confirmable message at exponentially
   increasing intervals, until it receives an acknowledgement (or Reset
   message) or runs out of attempts.

   Retransmission is controlled by two things that a CoAP endpoint MUST
   keep track of for each Confirmable message it sends while waiting for
   an acknowledgement (or reset): a timeout and a retransmission
   counter.  For a new Confirmable message, the initial timeout is set
   to a random duration (often not an integral number of seconds)
   between ACK_TIMEOUT and (ACK_TIMEOUT * ACK_RANDOM_FACTOR) (see
   <a href="#section-4.8">Section 4.8</a>), and the retransmission counter is set to 0.  When the
   timeout is triggered and the retransmission counter is less than



<span class="grey">Shelby, et al.               Standards Track                   [Page 21]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-22" id="page-22" name="page-22"> </a>
<span class="grey"><a href="rfc7252.html">RFC 7252</a>       The Constrained Application Protocol (CoAP)     June 2014</span>


   MAX_RETRANSMIT, the message is retransmitted, the retransmission
   counter is incremented, and the timeout is doubled.  If the
   retransmission counter reaches MAX_RETRANSMIT on a timeout, or if the
   endpoint receives a Reset message, then the attempt to transmit the
   message is canceled and the application process informed of failure.
   On the other hand, if the endpoint receives an acknowledgement in
   time, transmission is considered successful.

   This specification makes no strong requirements on the accuracy of
   the clocks used to implement the above binary exponential back-off
   algorithm.  In particular, an endpoint may be late for a specific
   retransmission due to its sleep schedule and may catch up on the next
   one.  However, the minimum spacing before another retransmission is
   ACK_TIMEOUT, and the entire sequence of (re-)transmissions MUST stay
   in the envelope of MAX_TRANSMIT_SPAN (see <a href="#section-4.8.2">Section 4.8.2</a>), even if
   that means a sender may miss an opportunity to transmit.

   A CoAP endpoint that sent a Confirmable message MAY give up in
   attempting to obtain an ACK even before the MAX_RETRANSMIT counter
   value is reached.  For example, the application has canceled the
   request as it no longer needs a response, or there is some other
   indication that the CON message did arrive.  In particular, a CoAP
   request message may have elicited a separate response, in which case
   it is clear to the requester that only the ACK was lost and a
   retransmission of the request would serve no purpose.  However, a
   responder MUST NOT in turn rely on this cross-layer behavior from a
   requester, i.e., it MUST retain the state to create the ACK for the
   request, if needed, even if a Confirmable response was already
   acknowledged by the requester.

   Another reason for giving up retransmission MAY be the receipt of
   ICMP errors.  If it is desired to take account of ICMP errors, to
   mitigate potential spoofing attacks, implementations SHOULD take care
   to check the information about the original datagram in the ICMP
   message, including port numbers and CoAP header information such as
   message type and code, Message ID, and Token; if this is not possible
   due to limitations of the UDP service API, ICMP errors SHOULD be
   ignored.  Packet Too Big errors [<a href="rfc4443.html" title='"Internet Control Message Protocol (ICMPv6) for the Internet Protocol Version 6 (IPv6) Specification"'>RFC4443</a>] ("fragmentation needed and
   DF set" for IPv4 [<a href="https://tools.ietf.org/html/rfc0792" title='"Internet Control Message Protocol"'>RFC0792</a>]) cannot properly occur and SHOULD be
   ignored if the implementation note in <a href="#section-4.6">Section 4.6</a> is followed;
   otherwise, they SHOULD feed into a path MTU discovery algorithm
   [<a href="rfc4821.html" title='"Packetization Layer Path MTU Discovery"'>RFC4821</a>].  Source Quench and Time Exceeded ICMP messages SHOULD be
   ignored.  Host, network, port, or protocol unreachable errors or
   parameter problem errors MAY, after appropriate vetting, be used to
   inform the application of a failure in sending.






<span class="grey">Shelby, et al.               Standards Track                   [Page 22]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-23" id="page-23" name="page-23"> </a>
<span class="grey"><a href="rfc7252.html">RFC 7252</a>       The Constrained Application Protocol (CoAP)     June 2014</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.3.%20%20Messages%20Transmitted%20without%20Reliability"></a><a class="selflink" href="#section-4.3" name="section-4.3">4.3</a>.  Messages Transmitted without Reliability</span>

   Some messages do not require an acknowledgement.  This is
   particularly true for messages that are repeated regularly for
   application requirements, such as repeated readings from a sensor
   where eventual success is sufficient.

   As a more lightweight alternative, a message can be transmitted less
   reliably by marking the message as Non-confirmable.  A Non-
   confirmable message always carries either a request or response and
   MUST NOT be Empty.  A Non-confirmable message MUST NOT be
   acknowledged by the recipient.  A recipient MUST reject the message
   if it lacks context to process the message properly, including the
   case where the message is Empty, uses a code with a reserved class
   (1, 6, or 7), or has a message format error.  Rejecting a Non-
   confirmable message MAY involve sending a matching Reset message, and
   apart from the Reset message the rejected message MUST be silently
   ignored.

   At the CoAP level, there is no way for the sender to detect if a Non-
   confirmable message was received or not.  A sender MAY choose to
   transmit multiple copies of a Non-confirmable message within
   MAX_TRANSMIT_SPAN (limited by the provisions of <a href="#section-4.7">Section 4.7</a>, in
   particular, by PROBING_RATE if no response is received), or the
   network may duplicate the message in transit.  To enable the receiver
   to act only once on the message, Non-confirmable messages specify a
   Message ID as well.  (This Message ID is drawn from the same number
   space as the Message IDs for Confirmable messages.)

   Summarizing Sections <a href="#section-4.2">4.2</a> and <a href="#section-4.3">4.3</a>, the four message types can be used
   as in Table 1.  "*" means that the combination is not used in normal
   operation but only to elicit a Reset message ("CoAP ping").

                   +----------+-----+-----+-----+-----+
                   |          | CON | NON | ACK | RST |
                   +----------+-----+-----+-----+-----+
                   | Request  | X   | X   | -   | -   |
                   | Response | X   | X   | X   | -   |
                   | Empty    | *   | -   | X   | X   |
                   +----------+-----+-----+-----+-----+

                      Table 1: Usage of Message Types









<span class="grey">Shelby, et al.               Standards Track                   [Page 23]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-24" id="page-24" name="page-24"> </a>
<span class="grey"><a href="rfc7252.html">RFC 7252</a>       The Constrained Application Protocol (CoAP)     June 2014</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.4.%20%20Message%20Correlation"></a><a class="selflink" href="#section-4.4" name="section-4.4">4.4</a>.  Message Correlation</span>

   An Acknowledgement or Reset message is related to a Confirmable
   message or Non-confirmable message by means of a Message ID along
   with additional address information of the corresponding endpoint.
   The Message ID is a 16-bit unsigned integer that is generated by the
   sender of a Confirmable or Non-confirmable message and included in
   the CoAP header.  The Message ID MUST be echoed in the
   Acknowledgement or Reset message by the recipient.

   The same Message ID MUST NOT be reused (in communicating with the
   same endpoint) within the EXCHANGE_LIFETIME (<a href="#section-4.8.2">Section 4.8.2</a>).

   Implementation Note:  Several implementation strategies can be
      employed for generating Message IDs.  In the simplest case, a CoAP
      endpoint generates Message IDs by keeping a single Message ID
      variable, which is changed each time a new Confirmable or Non-
      confirmable message is sent, regardless of the destination address
      or port.  Endpoints dealing with large numbers of transactions
      could keep multiple Message ID variables, for example, per prefix
      or destination address.  (Note that some receiving endpoints may
      not be able to distinguish unicast and multicast packets addressed
      to it, so endpoints generating Message IDs need to make sure these
      do not overlap.)  It is strongly recommended that the initial
      value of the variable (e.g., on startup) be randomized, in order
      to make successful off-path attacks on the protocol less likely.

   For an Acknowledgement or Reset message to match a Confirmable or
   Non-confirmable message, the Message ID and source endpoint of the
   Acknowledgement or Reset message MUST match the Message ID and
   destination endpoint of the Confirmable or Non-confirmable message.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.5.%20%20Message%20Deduplication"></a><a class="selflink" href="#section-4.5" name="section-4.5">4.5</a>.  Message Deduplication</span>

   A recipient might receive the same Confirmable message (as indicated
   by the Message ID and source endpoint) multiple times within the
   EXCHANGE_LIFETIME (<a href="#section-4.8.2">Section 4.8.2</a>), for example, when its
   Acknowledgement went missing or didn't reach the original sender
   before the first timeout.  The recipient SHOULD acknowledge each
   duplicate copy of a Confirmable message using the same
   Acknowledgement or Reset message but SHOULD process any request or
   response in the message only once.  This rule MAY be relaxed in case
   the Confirmable message transports a request that is idempotent (see
   <a href="#section-5.1">Section 5.1</a>) or can be handled in an idempotent fashion.  Examples
   for relaxed message deduplication:






<span class="grey">Shelby, et al.               Standards Track                   [Page 24]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-25" id="page-25" name="page-25"> </a>
<span class="grey"><a href="rfc7252.html">RFC 7252</a>       The Constrained Application Protocol (CoAP)     June 2014</span>


   o  A server might relax the requirement to answer all retransmissions
      of an idempotent request with the same response (<a href="#section-4.2">Section 4.2</a>), so
      that it does not have to maintain state for Message IDs.  For
      example, an implementation might want to process duplicate
      transmissions of a GET, PUT, or DELETE request as separate
      requests if the effort incurred by duplicate processing is less
      expensive than keeping track of previous responses would be.

   o  A constrained server might even want to relax this requirement for
      certain non-idempotent requests if the application semantics make
      this trade-off favorable.  For example, if the result of a POST
      request is just the creation of some short-lived state at the
      server, it may be less expensive to incur this effort multiple
      times for a request than keeping track of whether a previous
      transmission of the same request already was processed.

   A recipient might receive the same Non-confirmable message (as
   indicated by the Message ID and source endpoint) multiple times
   within NON_LIFETIME (<a href="#section-4.8.2">Section 4.8.2</a>).  As a general rule that MAY be
   relaxed based on the specific semantics of a message, the recipient
   SHOULD silently ignore any duplicated Non-confirmable message and
   SHOULD process any request or response in the message only once.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.6.%20%20Message%20Size"></a><a class="selflink" href="#section-4.6" name="section-4.6">4.6</a>.  Message Size</span>

   While specific link layers make it beneficial to keep CoAP messages
   small enough to fit into their link-layer packets (see <a href="#section-1">Section 1</a>),
   this is a matter of implementation quality.  The CoAP specification
   itself provides only an upper bound to the message size.  Messages
   larger than an IP packet result in undesirable packet fragmentation.
   A CoAP message, appropriately encapsulated, SHOULD fit within a
   single IP packet (i.e., avoid IP fragmentation) and (by fitting into
   one UDP payload) obviously needs to fit within a single IP datagram.
   If the Path MTU is not known for a destination, an IP MTU of 1280
   bytes SHOULD be assumed; if nothing is known about the size of the
   headers, good upper bounds are 1152 bytes for the message size and
   1024 bytes for the payload size.

   Implementation Note:  CoAP's choice of message size parameters works
      well with IPv6 and with most of today's IPv4 paths.  (However,
      with IPv4, it is harder to absolutely ensure that there is no IP
      fragmentation.  If IPv4 support on unusual networks is a
      consideration, implementations may want to limit themselves to
      more conservative IPv4 datagram sizes such as 576 bytes; per
      [<a href="https://tools.ietf.org/html/rfc0791" title='"Internet Protocol"'>RFC0791</a>], the absolute minimum value of the IP MTU for IPv4 is as
      low as 68 bytes, which would leave only 40 bytes minus security
      overhead for a UDP payload.  Implementations extremely focused on
      this problem set might also set the IPv4 DF bit and perform some



<span class="grey">Shelby, et al.               Standards Track                   [Page 25]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-26" id="page-26" name="page-26"> </a>
<span class="grey"><a href="rfc7252.html">RFC 7252</a>       The Constrained Application Protocol (CoAP)     June 2014</span>


      form of path MTU discovery [<a href="rfc4821.html" title='"Packetization Layer Path MTU Discovery"'>RFC4821</a>]; this should generally be
      unnecessary in realistic use cases for CoAP, however.)  A more
      important kind of fragmentation in many constrained networks is
      that on the adaptation layer (e.g., 6LoWPAN L2 packets are limited
      to 127 bytes including various overheads); this may motivate
      implementations to be frugal in their packet sizes and to move to
      block-wise transfers [<a href="#ref-BLOCK" title='"Blockwise transfers in CoAP"'>BLOCK</a>] when approaching three-digit message
      sizes.

      Message sizes are also of considerable importance to
      implementations on constrained nodes.  Many implementations will
      need to allocate a buffer for incoming messages.  If an
      implementation is too constrained to allow for allocating the
      above-mentioned upper bound, it could apply the following
      implementation strategy for messages not using DTLS security:
      Implementations receiving a datagram into a buffer that is too
      small are usually able to determine if the trailing portion of a
      datagram was discarded and to retrieve the initial portion.  So,
      at least the CoAP header and options, if not all of the payload,
      are likely to fit within the buffer.  A server can thus fully
      interpret a request and return a 4.13 (Request Entity Too Large;
      see <a href="#section-5.9.2.9">Section 5.9.2.9</a>) Response Code if the payload was truncated.
      A client sending an idempotent request and receiving a response
      larger than would fit in the buffer can repeat the request with a
      suitable value for the Block Option [<a href="#ref-BLOCK" title='"Blockwise transfers in CoAP"'>BLOCK</a>].

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.7.%20%20Congestion%20Control"></a><a class="selflink" href="#section-4.7" name="section-4.7">4.7</a>.  Congestion Control</span>

   Basic congestion control for CoAP is provided by the exponential
   back-off mechanism in <a href="#section-4.2">Section 4.2</a>.

   In order not to cause congestion, clients (including proxies) MUST
   strictly limit the number of simultaneous outstanding interactions
   that they maintain to a given server (including proxies) to NSTART.
   An outstanding interaction is either a CON for which an ACK has not
   yet been received but is still expected (message layer) or a request
   for which neither a response nor an Acknowledgment message has yet
   been received but is still expected (which may both occur at the same
   time, counting as one outstanding interaction).  The default value of
   NSTART for this specification is 1.

   Further congestion control optimizations and considerations are
   expected in the future, may for example provide automatic
   initialization of the CoAP transmission parameters defined in
   <a href="#section-4.8">Section 4.8</a>, and thus may allow a value for NSTART greater than one.

   After EXCHANGE_LIFETIME, a client stops expecting a response to a
   Confirmable request for which no acknowledgment message was received.



<span class="grey">Shelby, et al.               Standards Track                   [Page 26]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-27" id="page-27" name="page-27"> </a>
<span class="grey"><a href="rfc7252.html">RFC 7252</a>       The Constrained Application Protocol (CoAP)     June 2014</span>


   The specific algorithm by which a client stops to "expect" a response
   to a Confirmable request that was acknowledged, or to a Non-
   confirmable request, is not defined.  Unless this is modified by
   additional congestion control optimizations, it MUST be chosen in
   such a way that an endpoint does not exceed an average data rate of
   PROBING_RATE in sending to another endpoint that does not respond.

   Note:  CoAP places the onus of congestion control mostly on the
      clients.  However, clients may malfunction or actually be
      attackers, e.g., to perform amplification attacks (<a href="#section-11.3">Section 11.3</a>).
      To limit the damage (to the network and to its own energy
      resources), a server SHOULD implement some rate limiting for its
      response transmission based on reasonable assumptions about
      application requirements.  This is most helpful if the rate limit
      can be made effective for the misbehaving endpoints, only.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.8.%20%20Transmission%20Parameters"></a><a class="selflink" href="#section-4.8" name="section-4.8">4.8</a>.  Transmission Parameters</span>

   Message transmission is controlled by the following parameters:

                   +-------------------+---------------+
                   | name              | default value |
                   +-------------------+---------------+
                   | ACK_TIMEOUT       | 2 seconds     |
                   | ACK_RANDOM_FACTOR | 1.5           |
                   | MAX_RETRANSMIT    | 4             |
                   | NSTART            | 1             |
                   | DEFAULT_LEISURE   | 5 seconds     |
                   | PROBING_RATE      | 1 byte/second |
                   +-------------------+---------------+

                     Table 2: CoAP Protocol Parameters

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/4.8.1.%20%20Changing%20the%20Parameters"></a><a class="selflink" href="#section-4.8.1" name="section-4.8.1">4.8.1</a>.  Changing the Parameters</span>

   The values for ACK_TIMEOUT, ACK_RANDOM_FACTOR, MAX_RETRANSMIT,
   NSTART, DEFAULT_LEISURE (<a href="#section-8.2">Section 8.2</a>), and PROBING_RATE may be
   configured to values specific to the application environment
   (including dynamically adjusted values); however, the configuration
   method is out of scope of this document.  It is RECOMMENDED that an
   application environment use consistent values for these parameters;
   the specific effects of operating with inconsistent values in an
   application environment are outside the scope of the present
   specification.

   The transmission parameters have been chosen to achieve a behavior in
   the presence of congestion that is safe in the Internet.  If a
   configuration desires to use different values, the onus is on the



<span class="grey">Shelby, et al.               Standards Track                   [Page 27]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-28" id="page-28" name="page-28"> </a>
<span class="grey"><a href="rfc7252.html">RFC 7252</a>       The Constrained Application Protocol (CoAP)     June 2014</span>


   configuration to ensure these congestion control properties are not
   violated.  In particular, a decrease of ACK_TIMEOUT below 1 second
   would violate the guidelines of [<a href="rfc5405.html" title='"Unicast UDP Usage Guidelines for Application Designers"'>RFC5405</a>].  ([<a href="#ref-RTO-CONSIDER">RTO-CONSIDER</a>] provides
   some additional background.)  CoAP was designed to enable
   implementations that do not maintain round-trip-time (RTT)
   measurements.  However, where it is desired to decrease the
   ACK_TIMEOUT significantly or increase NSTART, this can only be done
   safely when maintaining such measurements.  Configurations MUST NOT
   decrease ACK_TIMEOUT or increase NSTART without using mechanisms that
   ensure congestion control safety, either defined in the configuration
   or in future standards documents.

   ACK_RANDOM_FACTOR MUST NOT be decreased below 1.0, and it SHOULD have
   a value that is sufficiently different from 1.0 to provide some
   protection from synchronization effects.

   MAX_RETRANSMIT can be freely adjusted, but a value that is too small
   will reduce the probability that a Confirmable message is actually
   received, while a larger value than given here will require further
   adjustments in the time values (see <a href="#section-4.8.2">Section 4.8.2</a>).

   If the choice of transmission parameters leads to an increase of
   derived time values (see <a href="#section-4.8.2">Section 4.8.2</a>), the configuration mechanism
   MUST ensure the adjusted value is also available to all the endpoints
   with which these adjusted values are to be used to communicate.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/4.8.2.%20%20Time%20Values%20Derived%20from%20Transmission%20Parameters"></a><a class="selflink" href="#section-4.8.2" name="section-4.8.2">4.8.2</a>.  Time Values Derived from Transmission Parameters</span>

   The combination of ACK_TIMEOUT, ACK_RANDOM_FACTOR, and MAX_RETRANSMIT
   influences the timing of retransmissions, which in turn influences
   how long certain information items need to be kept by an
   implementation.  To be able to unambiguously reference these derived
   time values, we give them names as follows:

   o  MAX_TRANSMIT_SPAN is the maximum time from the first transmission
      of a Confirmable message to its last retransmission.  For the
      default transmission parameters, the value is (2+4+8+16)*1.5 = 45
      seconds, or more generally:

         ACK_TIMEOUT * ((2 ** MAX_RETRANSMIT) - 1) * ACK_RANDOM_FACTOR











<span class="grey">Shelby, et al.               Standards Track                   [Page 28]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-29" id="page-29" name="page-29"> </a>
<span class="grey"><a href="rfc7252.html">RFC 7252</a>       The Constrained Application Protocol (CoAP)     June 2014</span>


   o  MAX_TRANSMIT_WAIT is the maximum time from the first transmission
      of a Confirmable message to the time when the sender gives up on
      receiving an acknowledgement or reset.  For the default
      transmission parameters, the value is (2+4+8+16+32)*1.5 = 93
      seconds, or more generally:

         ACK_TIMEOUT * ((2 ** (MAX_RETRANSMIT + 1)) - 1) *
         ACK_RANDOM_FACTOR

   In addition, some assumptions need to be made on the characteristics
   of the network and the nodes.

   o  MAX_LATENCY is the maximum time a datagram is expected to take
      from the start of its transmission to the completion of its
      reception.  This constant is related to the MSL (Maximum Segment
      Lifetime) of [<a href="https://tools.ietf.org/html/rfc0793" title='"Transmission Control Protocol"'>RFC0793</a>], which is "arbitrarily defined to be 2
      minutes" ([<a href="https://tools.ietf.org/html/rfc0793" title='"Transmission Control Protocol"'>RFC0793</a>] glossary, page 81).  Note that this is not
      necessarily smaller than MAX_TRANSMIT_WAIT, as MAX_LATENCY is not
      intended to describe a situation when the protocol works well, but
      the worst-case situation against which the protocol has to guard.
      We, also arbitrarily, define MAX_LATENCY to be 100 seconds.  Apart
      from being reasonably realistic for the bulk of configurations as
      well as close to the historic choice for TCP, this value also
      allows Message ID lifetime timers to be represented in 8 bits
      (when measured in seconds).  In these calculations, there is no
      assumption that the direction of the transmission is irrelevant
      (i.e., that the network is symmetric); there is just the
      assumption that the same value can reasonably be used as a maximum
      value for both directions.  If that is not the case, the following
      calculations become only slightly more complex.

   o  PROCESSING_DELAY is the time a node takes to turn around a
      Confirmable message into an acknowledgement.  We assume the node
      will attempt to send an ACK before having the sender time out, so
      as a conservative assumption we set it equal to ACK_TIMEOUT.

   o  MAX_RTT is the maximum round-trip time, or:

         (2 * MAX_LATENCY) + PROCESSING_DELAY

   From these values, we can derive the following values relevant to the
   protocol operation:

   o  EXCHANGE_LIFETIME is the time from starting to send a Confirmable
      message to the time when an acknowledgement is no longer expected,
      i.e., message-layer information about the message exchange can be
      purged.  EXCHANGE_LIFETIME includes a MAX_TRANSMIT_SPAN, a
      MAX_LATENCY forward, PROCESSING_DELAY, and a MAX_LATENCY for the



<span class="grey">Shelby, et al.               Standards Track                   [Page 29]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-30" id="page-30" name="page-30"> </a>
<span class="grey"><a href="rfc7252.html">RFC 7252</a>       The Constrained Application Protocol (CoAP)     June 2014</span>


      way back.  Note that there is no need to consider
      MAX_TRANSMIT_WAIT if the configuration is chosen such that the
      last waiting period (ACK_TIMEOUT * (2 ** MAX_RETRANSMIT) or the
      difference between MAX_TRANSMIT_SPAN and MAX_TRANSMIT_WAIT) is
      less than MAX_LATENCY -- which is a likely choice, as MAX_LATENCY
      is a worst-case value unlikely to be met in the real world.  In
      this case, EXCHANGE_LIFETIME simplifies to:

         MAX_TRANSMIT_SPAN + (2 * MAX_LATENCY) + PROCESSING_DELAY

      or 247 seconds with the default transmission parameters.

   o  NON_LIFETIME is the time from sending a Non-confirmable message to
      the time its Message ID can be safely reused.  If multiple
      transmission of a NON message is not used, its value is
      MAX_LATENCY, or 100 seconds.  However, a CoAP sender might send a
      NON message multiple times, in particular for multicast
      applications.  While the period of reuse is not bounded by the
      specification, an expectation of reliable detection of duplication
      at the receiver is on the timescales of MAX_TRANSMIT_SPAN.
      Therefore, for this purpose, it is safer to use the value:

         MAX_TRANSMIT_SPAN + MAX_LATENCY

      or 145 seconds with the default transmission parameters; however,
      an implementation that just wants to use a single timeout value
      for retiring Message IDs can safely use the larger value for
      EXCHANGE_LIFETIME.

   Table 3 lists the derived parameters introduced in this subsection
   with their default values.

                   +-------------------+---------------+
                   | name              | default value |
                   +-------------------+---------------+
                   | MAX_TRANSMIT_SPAN |          45 s |
                   | MAX_TRANSMIT_WAIT |          93 s |
                   | MAX_LATENCY       |         100 s |
                   | PROCESSING_DELAY  |           2 s |
                   | MAX_RTT           |         202 s |
                   | EXCHANGE_LIFETIME |         247 s |
                   | NON_LIFETIME      |         145 s |
                   +-------------------+---------------+

                   Table 3: Derived Protocol Parameters






<span class="grey">Shelby, et al.               Standards Track                   [Page 30]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-31" id="page-31" name="page-31"> </a>
<span class="grey"><a href="rfc7252.html">RFC 7252</a>       The Constrained Application Protocol (CoAP)     June 2014</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/5.%20%20Request%2FResponse%20Semantics"></a><a class="selflink" href="#section-5" name="section-5">5</a>.  Request/Response Semantics</span>

   CoAP operates under a similar request/response model as HTTP: a CoAP
   endpoint in the role of a "client" sends one or more CoAP requests to
   a "server", which services the requests by sending CoAP responses.
   Unlike HTTP, requests and responses are not sent over a previously
   established connection but are exchanged asynchronously over CoAP
   messages.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.1.%20%20Requests"></a><a class="selflink" href="#section-5.1" name="section-5.1">5.1</a>.  Requests</span>

   A CoAP request consists of the method to be applied to the resource,
   the identifier of the resource, a payload and Internet media type (if
   any), and optional metadata about the request.

   CoAP supports the basic methods of GET, POST, PUT, and DELETE, which
   are easily mapped to HTTP.  They have the same properties of safe
   (only retrieval) and idempotent (you can invoke it multiple times
   with the same effects) as HTTP (see <a href="rfc2616.html#section-9.1">Section 9.1 of [RFC2616]</a>).  The
   GET method is safe; therefore, it MUST NOT take any other action on a
   resource other than retrieval.  The GET, PUT, and DELETE methods MUST
   be performed in such a way that they are idempotent.  POST is not
   idempotent, because its effect is determined by the origin server and
   dependent on the target resource; it usually results in a new
   resource being created or the target resource being updated.

   A request is initiated by setting the Code field in the CoAP header
   of a Confirmable or a Non-confirmable message to a Method Code and
   including request information.

   The methods used in requests are described in detail in <a href="#section-5.8">Section 5.8</a>.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.2.%20%20Responses"></a><a class="selflink" href="#section-5.2" name="section-5.2">5.2</a>.  Responses</span>

   After receiving and interpreting a request, a server responds with a
   CoAP response that is matched to the request by means of a client-
   generated token (<a href="#section-5.3">Section 5.3</a>); note that this is different from the
   Message ID that matches a Confirmable message to its Acknowledgement.

   A response is identified by the Code field in the CoAP header being
   set to a Response Code.  Similar to the HTTP Status Code, the CoAP
   Response Code indicates the result of the attempt to understand and
   satisfy the request.  These codes are fully defined in <a href="#section-5.9">Section 5.9</a>.
   The Response Code numbers to be set in the Code field of the CoAP
   header are maintained in the CoAP Response Code Registry
   (<a href="#section-12.1.2">Section 12.1.2</a>).





<span class="grey">Shelby, et al.               Standards Track                   [Page 31]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-32" id="page-32" name="page-32"> </a>
<span class="grey"><a href="rfc7252.html">RFC 7252</a>       The Constrained Application Protocol (CoAP)     June 2014</span>


                              0
                              0 1 2 3 4 5 6 7
                             +-+-+-+-+-+-+-+-+
                             |class|  detail |
                             +-+-+-+-+-+-+-+-+

                  Figure 9: Structure of a Response Code

   The upper three bits of the 8-bit Response Code number define the
   class of response.  The lower five bits do not have any
   categorization role; they give additional detail to the overall class
   (Figure 9).

   As a human-readable notation for specifications and protocol
   diagnostics, CoAP code numbers including the Response Code are
   documented in the format "c.dd", where "c" is the class in decimal,
   and "dd" is the detail as a two-digit decimal.  For example,
   "Forbidden" is written as 4.03 -- indicating an 8-bit code value of
   hexadecimal 0x83 (4*0x20+3) or decimal 131 (4*32+3).

   There are 3 classes of Response Codes:

   2 - Success:  The request was successfully received, understood, and
      accepted.

   4 - Client Error:  The request contains bad syntax or cannot be
      fulfilled.

   5 - Server Error:  The server failed to fulfill an apparently valid
      request.

   The Response Codes are designed to be extensible: Response Codes in
   the Client Error or Server Error class that are unrecognized by an
   endpoint are treated as being equivalent to the generic Response Code
   of that class (4.00 and 5.00, respectively).  However, there is no
   generic Response Code indicating success, so a Response Code in the
   Success class that is unrecognized by an endpoint can only be used to
   determine that the request was successful without any further
   details.

   The possible Response Codes are described in detail in <a href="#section-5.9">Section 5.9</a>.

   Responses can be sent in multiple ways, which are defined in the
   following subsections.







<span class="grey">Shelby, et al.               Standards Track                   [Page 32]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-33" id="page-33" name="page-33"> </a>
<span class="grey"><a href="rfc7252.html">RFC 7252</a>       The Constrained Application Protocol (CoAP)     June 2014</span>


<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/5.2.1.%20%20Piggybacked"></a><a class="selflink" href="#section-5.2.1" name="section-5.2.1">5.2.1</a>.  Piggybacked</span>

   In the most basic case, the response is carried directly in the
   Acknowledgement message that acknowledges the request (which requires
   that the request was carried in a Confirmable message).  This is
   called a "Piggybacked Response".

   The response is returned in the Acknowledgement message, independent
   of whether the response indicates success or failure.  In effect, the
   response is piggybacked on the Acknowledgement message, and no
   separate message is required to return the response.

   Implementation Note:  The protocol leaves the decision whether to
      piggyback a response or not (i.e., send a separate response) to
      the server.  The client MUST be prepared to receive either.  On
      the quality-of-implementation level, there is a strong expectation
      that servers will implement code to piggyback whenever possible --
      saving resources in the network and both at the client and at the
      server.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/5.2.2.%20%20Separate"></a><a class="selflink" href="#section-5.2.2" name="section-5.2.2">5.2.2</a>.  Separate</span>

   It may not be possible to return a piggybacked response in all cases.
   For example, a server might need longer to obtain the representation
   of the resource requested than it can wait to send back the
   Acknowledgement message, without risking the client repeatedly
   retransmitting the request message (see also the discussion of
   PROCESSING_DELAY in <a href="#section-4.8.2">Section 4.8.2</a>).  The response to a request
   carried in a Non-confirmable message is always sent separately (as
   there is no Acknowledgement message).

   One way to implement this in a server is to initiate the attempt to
   obtain the resource representation and, while that is in progress,
   time out an acknowledgement timer.  A server may also immediately
   send an acknowledgement if it knows in advance that there will be no
   piggybacked response.  In both cases, the acknowledgement effectively
   is a promise that the request will be acted upon later.

   When the server finally has obtained the resource representation, it
   sends the response.  When it is desired that this message is not
   lost, it is sent as a Confirmable message from the server to the
   client and answered by the client with an Acknowledgement, echoing
   the new Message ID chosen by the server.  (It may also be sent as a
   Non-confirmable message; see <a href="#section-5.2.3">Section 5.2.3</a>.)

   When the server chooses to use a separate response, it sends the
   Acknowledgement to the Confirmable request as an Empty message.  Once
   the server sends back an Empty Acknowledgement, it MUST NOT send back



<span class="grey">Shelby, et al.               Standards Track                   [Page 33]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-34" id="page-34" name="page-34"> </a>
<span class="grey"><a href="rfc7252.html">RFC 7252</a>       The Constrained Application Protocol (CoAP)     June 2014</span>


   the response in another Acknowledgement, even if the client
   retransmits another identical request.  If a retransmitted request is
   received (perhaps because the original Acknowledgement was delayed),
   another Empty Acknowledgement is sent, and any response MUST be sent
   as a separate response.

   If the server then sends a Confirmable response, the client's
   Acknowledgement to that response MUST also be an Empty message (one
   that carries neither a request nor a response).  The server MUST stop
   retransmitting its response on any matching Acknowledgement (silently
   ignoring any Response Code or payload) or Reset message.

   Implementation Notes:  Note that, as the underlying datagram
      transport may not be sequence-preserving, the Confirmable message
      carrying the response may actually arrive before or after the
      Acknowledgement message for the request; for the purposes of
      terminating the retransmission sequence, this also serves as an
      acknowledgement.  Note also that, while the CoAP protocol itself
      does not make any specific demands here, there is an expectation
      that the response will come within a time frame that is reasonable
      from an application point of view.  As there is no underlying
      transport protocol that could be instructed to run a keep-alive
      mechanism, the requester may want to set up a timeout that is
      unrelated to CoAP's retransmission timers in case the server is
      destroyed or otherwise unable to send the response.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/5.2.3.%20%20Non-confirmable"></a><a class="selflink" href="#section-5.2.3" name="section-5.2.3">5.2.3</a>.  Non-confirmable</span>

   If the request message is Non-confirmable, then the response SHOULD
   be returned in a Non-confirmable message as well.  However, an
   endpoint MUST be prepared to receive a Non-confirmable response
   (preceded or followed by an Empty Acknowledgement message) in reply
   to a Confirmable request, or a Confirmable response in reply to a
   Non-confirmable request.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.3.%20%20Request%2FResponse%20Matching"></a><a class="selflink" href="#section-5.3" name="section-5.3">5.3</a>.  Request/Response Matching</span>

   Regardless of how a response is sent, it is matched to the request by
   means of a token that is included by the client in the request, along
   with additional address information of the corresponding endpoint.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/5.3.1.%20%20Token"></a><a class="selflink" href="#section-5.3.1" name="section-5.3.1">5.3.1</a>.  Token</span>

   The Token is used to match a response with a request.  The token
   value is a sequence of 0 to 8 bytes.  (Note that every message
   carries a token, even if it is of zero length.)  Every request
   carries a client-generated token that the server MUST echo (without
   modification) in any resulting response.



<span class="grey">Shelby, et al.               Standards Track                   [Page 34]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-35" id="page-35" name="page-35"> </a>
<span class="grey"><a href="rfc7252.html">RFC 7252</a>       The Constrained Application Protocol (CoAP)     June 2014</span>


   A token is intended for use as a client-local identifier for
   differentiating between concurrent requests (see <a href="#section-5.3">Section 5.3</a>); it
   could have been called a "request ID".

   The client SHOULD generate tokens in such a way that tokens currently
   in use for a given source/destination endpoint pair are unique.
   (Note that a client implementation can use the same token for any
   request if it uses a different endpoint each time, e.g., a different
   source port number.)  An empty token value is appropriate e.g., when
   no other tokens are in use to a destination, or when requests are
   made serially per destination and receive piggybacked responses.
   There are, however, multiple possible implementation strategies to
   fulfill this.

   A client sending a request without using Transport Layer Security
   (<a href="#section-9">Section 9</a>) SHOULD use a nontrivial, randomized token to guard
   against spoofing of responses (<a href="#section-11.4">Section 11.4</a>).  This protective use of
   tokens is the reason they are allowed to be up to 8 bytes in size.
   The actual size of the random component to be used for the Token
   depends on the security requirements of the client and the level of
   threat posed by spoofing of responses.  A client that is connected to
   the general Internet SHOULD use at least 32 bits of randomness,
   keeping in mind that not being directly connected to the Internet is
   not necessarily sufficient protection against spoofing.  (Note that
   the Message ID adds little in protection as it is usually
   sequentially assigned, i.e., guessable, and can be circumvented by
   spoofing a separate response.)  Clients that want to optimize the
   Token length may further want to detect the level of ongoing attacks
   (e.g., by tallying recent Token mismatches in incoming messages) and
   adjust the Token length upwards appropriately.  [<a href="rfc4086.html" title='"Randomness Requirements for Security"'>RFC4086</a>] discusses
   randomness requirements for security.

   An endpoint receiving a token it did not generate MUST treat the
   token as opaque and make no assumptions about its content or
   structure.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/5.3.2.%20%20Request%2FResponse%20Matching%20Rules"></a><a class="selflink" href="#section-5.3.2" name="section-5.3.2">5.3.2</a>.  Request/Response Matching Rules</span>

   The exact rules for matching a response to a request are as follows:

   1.  The source endpoint of the response MUST be the same as the
       destination endpoint of the original request.

   2.  In a piggybacked response, the Message ID of the Confirmable
       request and the Acknowledgement MUST match, and the tokens of the
       response and original request MUST match.  In a separate
       response, just the tokens of the response and original request
       MUST match.



<span class="grey">Shelby, et al.               Standards Track                   [Page 35]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-36" id="page-36" name="page-36"> </a>
<span class="grey"><a href="rfc7252.html">RFC 7252</a>       The Constrained Application Protocol (CoAP)     June 2014</span>


   In case a message carrying a response is unexpected (the client is
   not waiting for a response from the identified endpoint, at the
   endpoint addressed, and/or with the given token), the response is
   rejected (Sections <a href="#section-4.2">4.2</a> and <a href="#section-4.3">4.3</a>).

   Implementation Note:  A client that receives a response in a CON
      message may want to clean up the message state right after sending
      the ACK.  If that ACK is lost and the server retransmits the CON,
      the client may no longer have any state to which to correlate this
      response, making the retransmission an unexpected message; the
      client will likely send a Reset message so it does not receive any
      more retransmissions.  This behavior is normal and not an
      indication of an error.  (Clients that are not aggressively
      optimized in their state memory usage will still have message
      state that will identify the second CON as a retransmission.
      Clients that actually expect more messages from the server
      [<a href="#ref-OBSERVE" title='"Observing Resources in CoAP"'>OBSERVE</a>] will have to keep state in any case.)

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.4.%20%20Options"></a><a class="selflink" href="#section-5.4" name="section-5.4">5.4</a>.  Options</span>

   Both requests and responses may include a list of one or more
   options.  For example, the URI in a request is transported in several
   options, and metadata that would be carried in an HTTP header in HTTP
   is supplied as options as well.

   CoAP defines a single set of options that are used in both requests
   and responses:

   o  Content-Format

   o  ETag

   o  Location-Path

   o  Location-Query

   o  Max-Age

   o  Proxy-Uri

   o  Proxy-Scheme

   o  Uri-Host

   o  Uri-Path

   o  Uri-Port




<span class="grey">Shelby, et al.               Standards Track                   [Page 36]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-37" id="page-37" name="page-37"> </a>
<span class="grey"><a href="rfc7252.html">RFC 7252</a>       The Constrained Application Protocol (CoAP)     June 2014</span>


   o  Uri-Query

   o  Accept

   o  If-Match

   o  If-None-Match

   o  Size1

   The semantics of these options along with their properties are
   defined in detail in <a href="#section-5.10">Section 5.10</a>.

   Not all options are defined for use with all methods and Response
   Codes.  The possible options for methods and Response Codes are
   defined in Sections <a href="#section-5.8">5.8</a> and <a href="#section-5.9">5.9</a>, respectively.  In case an option is
   not defined for a Method or Response Code, it MUST NOT be included by
   a sender and MUST be treated like an unrecognized option by a
   recipient.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/5.4.1.%20%20Critical%2FElective"></a><a class="selflink" href="#section-5.4.1" name="section-5.4.1">5.4.1</a>.  Critical/Elective</span>

   Options fall into one of two classes: "critical" or "elective".  The
   difference between these is how an option unrecognized by an endpoint
   is handled:

   o  Upon reception, unrecognized options of class "elective" MUST be
      silently ignored.

   o  Unrecognized options of class "critical" that occur in a
      Confirmable request MUST cause the return of a 4.02 (Bad Option)
      response.  This response SHOULD include a diagnostic payload
      describing the unrecognized option(s) (see <a href="#section-5.5.2">Section 5.5.2</a>).

   o  Unrecognized options of class "critical" that occur in a
      Confirmable response, or piggybacked in an Acknowledgement, MUST
      cause the response to be rejected (<a href="#section-4.2">Section 4.2</a>).

   o  Unrecognized options of class "critical" that occur in a Non-
      confirmable message MUST cause the message to be rejected
      (<a href="#section-4.3">Section 4.3</a>).

   Note that, whether critical or elective, an option is never
   "mandatory" (it is always optional): these rules are defined in order
   to enable implementations to stop processing options they do not
   understand or implement.





<span class="grey">Shelby, et al.               Standards Track                   [Page 37]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-38" id="page-38" name="page-38"> </a>
<span class="grey"><a href="rfc7252.html">RFC 7252</a>       The Constrained Application Protocol (CoAP)     June 2014</span>


   Critical/elective rules apply to non-proxying endpoints.  A proxy
   processes options based on Unsafe/Safe-to-Forward classes as defined
   in <a href="#section-5.7">Section 5.7</a>.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/5.4.2.%20%20Proxy%20Unsafe%20or%20Safe-to-Forward%20and%20NoCacheKey"></a><a class="selflink" href="#section-5.4.2" name="section-5.4.2">5.4.2</a>.  Proxy Unsafe or Safe-to-Forward and NoCacheKey</span>

   In addition to an option being marked as critical or elective,
   options are also classified based on how a proxy is to deal with the
   option if it does not recognize it.  For this purpose, an option can
   either be considered Unsafe to forward (UnSafe is set) or Safe-to-
   Forward (UnSafe is clear).

   In addition, for an option that is marked Safe-to-Forward, the option
   number indicates whether or not it is intended to be part of the
   Cache-Key (<a href="#section-5.6">Section 5.6</a>) in a request.  If some of the NoCacheKey bits
   are 0, it is; if all NoCacheKey bits are 1, it is not (see
   <a href="#section-5.4.6">Section 5.4.6</a>).

   Note:  The Cache-Key indication is relevant only for proxies that do
      not implement the given option as a request option and instead
      rely on the Unsafe/Safe-to-Forward indication only.  For example,
      for ETag, actually using the request option as a part of the
      Cache-Key is grossly inefficient, but it is the best thing one can
      do if ETag is not implemented by a proxy, as the response is going
      to differ based on the presence of the request option.  A more
      useful proxy that does implement the ETag request option is not
      using ETag as a part of the Cache-Key.

      NoCacheKey is indicated in three bits so that only one out of
      eight codepoints is qualified as NoCacheKey, leaving seven out of
      eight codepoints for what appears to be the more likely case.

   Proxy behavior with regard to these classes is defined in
   <a href="#section-5.7">Section 5.7</a>.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/5.4.3.%20%20Length"></a><a class="selflink" href="#section-5.4.3" name="section-5.4.3">5.4.3</a>.  Length</span>

   Option values are defined to have a specific length, often in the
   form of an upper and lower bound.  If the length of an option value
   in a request is outside the defined range, that option MUST be
   treated like an unrecognized option (see <a href="#section-5.4.1">Section 5.4.1</a>).

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/5.4.4.%20%20Default%20Values"></a><a class="selflink" href="#section-5.4.4" name="section-5.4.4">5.4.4</a>.  Default Values</span>

   Options may be defined to have a default value.  If the value of an
   option is intended to be this default value, the option SHOULD NOT be
   included in the message.  If the option is not present, the default
   value MUST be assumed.



<span class="grey">Shelby, et al.               Standards Track                   [Page 38]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-39" id="page-39" name="page-39"> </a>
<span class="grey"><a href="rfc7252.html">RFC 7252</a>       The Constrained Application Protocol (CoAP)     June 2014</span>


   Where a critical option has a default value, this is chosen in such a
   way that the absence of the option in a message can be processed
   properly both by implementations unaware of the critical option and
   by implementations that interpret this absence as the presence of the
   default value for the option.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/5.4.5.%20%20Repeatable%20Options"></a><a class="selflink" href="#section-5.4.5" name="section-5.4.5">5.4.5</a>.  Repeatable Options</span>

   The definition of some options specifies that those options are
   repeatable.  An option that is repeatable MAY be included one or more
   times in a message.  An option that is not repeatable MUST NOT be
   included more than once in a message.

   If a message includes an option with more occurrences than the option
   is defined for, each supernumerary option occurrence that appears
   subsequently in the message MUST be treated like an unrecognized
   option (see <a href="#section-5.4.1">Section 5.4.1</a>).

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/5.4.6.%20%20Option%20Numbers"></a><a class="selflink" href="#section-5.4.6" name="section-5.4.6">5.4.6</a>.  Option Numbers</span>

   An Option is identified by an option number, which also provides some
   additional semantics information, e.g., odd numbers indicate a
   critical option, while even numbers indicate an elective option.
   Note that this is not just a convention, it is a feature of the
   protocol: Whether an option is elective or critical is entirely
   determined by whether its option number is even or odd.

   More generally speaking, an Option number is constructed with a bit
   mask to indicate if an option is Critical or Elective, Unsafe or
   Safe-to-Forward, and, in the case of Safe-to-Forward, to provide a
   Cache-Key indication as shown by the following figure.  In the
   following text, the bit mask is expressed as a single byte that is
   applied to the least significant byte of the option number in
   unsigned integer representation.  When bit 7 (the least significant
   bit) is 1, an option is Critical (and likewise Elective when 0).
   When bit 6 is 1, an option is Unsafe (and likewise Safe-to-Forward
   when 0).  When bit 6 is 0, i.e., the option is not Unsafe, it is not
   a Cache-Key (NoCacheKey) if and only if bits 3-5 are all set to 1;
   all other bit combinations mean that it indeed is a Cache-Key.  These
   classes of options are explained in the next sections.

                       0   1   2   3   4   5   6   7
                     +---+---+---+---+---+---+---+---+
                     |           | NoCacheKey| U | C |
                     +---+---+---+---+---+---+---+---+

          Figure 10: Option Number Mask (Least Significant Byte)




<span class="grey">Shelby, et al.               Standards Track                   [Page 39]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-40" id="page-40" name="page-40"> </a>
<span class="grey"><a href="rfc7252.html">RFC 7252</a>       The Constrained Application Protocol (CoAP)     June 2014</span>


   An endpoint may use an equivalent of the C code in Figure 11 to
   derive the characteristics of an option number "onum".

   Critical = (onum &amp; 1);
   UnSafe = (onum &amp; 2);
   NoCacheKey = ((onum &amp; 0x1e) == 0x1c);

       Figure 11: Determining Characteristics from an Option Number

   The option numbers for the options defined in this document are
   listed in the "CoAP Option Numbers" registry (<a href="#section-12.2">Section 12.2</a>).

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.5.%20%20Payloads%20and%20Representations"></a><a class="selflink" href="#section-5.5" name="section-5.5">5.5</a>.  Payloads and Representations</span>

   Both requests and responses may include a payload, depending on the
   Method or Response Code, respectively.  If a Method or Response Code
   is not defined to have a payload, then a sender MUST NOT include one,
   and a recipient MUST ignore it.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/5.5.1.%20%20Representation"></a><a class="selflink" href="#section-5.5.1" name="section-5.5.1">5.5.1</a>.  Representation</span>

   The payload of requests or of responses indicating success is
   typically a representation of a resource ("resource representation")
   or the result of the requested action ("action result").  Its format
   is specified by the Internet media type and content coding given by
   the Content-Format Option.  In the absence of this option, no default
   value is assumed, and the format will need to be inferred by the
   application (e.g., from the application context).  Payload "sniffing"
   SHOULD only be attempted if no content type is given.

   Implementation Note:  On a quality-of-implementation level, there is
      a strong expectation that a Content-Format indication will be
      provided with resource representations whenever possible.  This is
      not a "SHOULD" level requirement solely because it is not a
      protocol requirement, and it also would be difficult to outline
      exactly in what cases this expectation can be violated.

   For responses indicating a client or server error, the payload is
   considered a representation of the result of the requested action
   only if a Content-Format Option is given.  In the absence of this
   option, the payload is a Diagnostic Payload (<a href="#section-5.5.2">Section 5.5.2</a>).










<span class="grey">Shelby, et al.               Standards Track                   [Page 40]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-41" id="page-41" name="page-41"> </a>
<span class="grey"><a href="rfc7252.html">RFC 7252</a>       The Constrained Application Protocol (CoAP)     June 2014</span>


<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/5.5.2.%20%20Diagnostic%20Payload"></a><a class="selflink" href="#section-5.5.2" name="section-5.5.2">5.5.2</a>.  Diagnostic Payload</span>

   If no Content-Format option is given, the payload of responses
   indicating a client or server error is a brief human-readable
   diagnostic message, explaining the error situation.  This diagnostic
   message MUST be encoded using UTF-8 [<a href="rfc3629.html" title='"UTF-8, a transformation format of ISO 10646"'>RFC3629</a>], more specifically
   using Net-Unicode form [<a href="rfc5198.html" title='"Unicode Format for Network Interchange"'>RFC5198</a>].

   The message is similar to the Reason-Phrase on an HTTP status line.
   It is not intended for end users but for software engineers that
   during debugging need to interpret it in the context of the present,
   English-language specification; therefore, no mechanism for language
   tagging is needed or provided.  In contrast to what is usual in HTTP,
   the payload SHOULD be empty if there is no additional information
   beyond the Response Code.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/5.5.3.%20%20Selected%20Representation"></a><a class="selflink" href="#section-5.5.3" name="section-5.5.3">5.5.3</a>.  Selected Representation</span>

   Not all responses carry a payload that provides a representation of
   the resource addressed by the request.  It is, however, sometimes
   useful to be able to refer to such a representation in relation to a
   response, independent of whether it actually was enclosed.

   We use the term "selected representation" to refer to the current
   representation of a target resource that would have been selected in
   a successful response if the corresponding request had used the
   method GET and excluded any conditional request options
   (<a href="#section-5.10.8">Section 5.10.8</a>).

   Certain response options provide metadata about the selected
   representation, which might differ from the representation included
   in the message for responses to some state-changing methods.  Of the
   response options defined in this specification, only the ETag
   response option (<a href="#section-5.10.6">Section 5.10.6</a>) is defined as metadata about the
   selected representation.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/5.5.4.%20%20Content%20Negotiation"></a><a class="selflink" href="#section-5.5.4" name="section-5.5.4">5.5.4</a>.  Content Negotiation</span>

   A server may be able to supply a representation for a resource in one
   of multiple representation formats.  Without further information from
   the client, it will provide the representation in the format it
   prefers.

   By using the Accept Option (<a href="#section-5.10.4">Section 5.10.4</a>) in a request, the client
   can indicate which content-format it prefers to receive.






<span class="grey">Shelby, et al.               Standards Track                   [Page 41]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-42" id="page-42" name="page-42"> </a>
<span class="grey"><a href="rfc7252.html">RFC 7252</a>       The Constrained Application Protocol (CoAP)     June 2014</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.6.%20%20Caching"></a><a class="selflink" href="#section-5.6" name="section-5.6">5.6</a>.  Caching</span>

   CoAP endpoints MAY cache responses in order to reduce the response
   time and network bandwidth consumption on future, equivalent
   requests.

   The goal of caching in CoAP is to reuse a prior response message to
   satisfy a current request.  In some cases, a stored response can be
   reused without the need for a network request, reducing latency and
   network round-trips; a "freshness" mechanism is used for this purpose
   (see <a href="#section-5.6.1">Section 5.6.1</a>).  Even when a new request is required, it is
   often possible to reuse the payload of a prior response to satisfy
   the request, thereby reducing network bandwidth usage; a "validation"
   mechanism is used for this purpose (see <a href="#section-5.6.2">Section 5.6.2</a>).

   Unlike HTTP, the cacheability of CoAP responses does not depend on
   the request method, but it depends on the Response Code.  The
   cacheability of each Response Code is defined along the Response Code
   definitions in <a href="#section-5.9">Section 5.9</a>.  Response Codes that indicate success and
   are unrecognized by an endpoint MUST NOT be cached.

   For a presented request, a CoAP endpoint MUST NOT use a stored
   response, unless:

   o  the presented request method and that used to obtain the stored
      response match,

   o  all options match between those in the presented request and those
      of the request used to obtain the stored response (which includes
      the request URI), except that there is no need for a match of any
      request options marked as NoCacheKey (<a href="#section-5.4">Section 5.4</a>) or recognized
      by the Cache and fully interpreted with respect to its specified
      cache behavior (such as the ETag request option described in
      <a href="#section-5.10.6">Section 5.10.6</a>; see also <a href="#section-5.4.2">Section 5.4.2</a>), and

   o  the stored response is either fresh or successfully validated as
      defined below.

   The set of request options that is used for matching the cache entry
   is also collectively referred to as the "Cache-Key".  For URI schemes
   other than coap and coaps, matching of those options that constitute
   the request URI may be performed under rules specific to the URI
   scheme.








<span class="grey">Shelby, et al.               Standards Track                   [Page 42]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-43" id="page-43" name="page-43"> </a>
<span class="grey"><a href="rfc7252.html">RFC 7252</a>       The Constrained Application Protocol (CoAP)     June 2014</span>


<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/5.6.1.%20%20Freshness%20Model"></a><a class="selflink" href="#section-5.6.1" name="section-5.6.1">5.6.1</a>.  Freshness Model</span>

   When a response is "fresh" in the cache, it can be used to satisfy
   subsequent requests without contacting the origin server, thereby
   improving efficiency.

   The mechanism for determining freshness is for an origin server to
   provide an explicit expiration time in the future, using the Max-Age
   Option (see <a href="#section-5.10.5">Section 5.10.5</a>).  The Max-Age Option indicates that the
   response is to be considered not fresh after its age is greater than
   the specified number of seconds.

   The Max-Age Option defaults to a value of 60.  Thus, if it is not
   present in a cacheable response, then the response is considered not
   fresh after its age is greater than 60 seconds.  If an origin server
   wishes to prevent caching, it MUST explicitly include a Max-Age
   Option with a value of zero seconds.

   If a client has a fresh stored response and makes a new request
   matching the request for that stored response, the new response
   invalidates the old response.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/5.6.2.%20%20Validation%20Model"></a><a class="selflink" href="#section-5.6.2" name="section-5.6.2">5.6.2</a>.  Validation Model</span>

   When an endpoint has one or more stored responses for a GET request,
   but cannot use any of them (e.g., because they are not fresh), it can
   use the ETag Option (<a href="#section-5.10.6">Section 5.10.6</a>) in the GET request to give the
   origin server an opportunity both to select a stored response to be
   used, and to update its freshness.  This process is known as
   "validating" or "revalidating" the stored response.

   When sending such a request, the endpoint SHOULD add an ETag Option
   specifying the entity-tag of each stored response that is applicable.

   A 2.03 (Valid) response indicates the stored response identified by
   the entity-tag given in the response's ETag Option can be reused
   after updating it as described in <a href="#section-5.9.1.3">Section 5.9.1.3</a>.

   Any other Response Code indicates that none of the stored responses
   nominated in the request is suitable.  Instead, the response SHOULD
   be used to satisfy the request and MAY replace the stored response.










<span class="grey">Shelby, et al.               Standards Track                   [Page 43]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-44" id="page-44" name="page-44"> </a>
<span class="grey"><a href="rfc7252.html">RFC 7252</a>       The Constrained Application Protocol (CoAP)     June 2014</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.7.%20%20Proxying"></a><a class="selflink" href="#section-5.7" name="section-5.7">5.7</a>.  Proxying</span>

   A proxy is a CoAP endpoint that can be tasked by CoAP clients to
   perform requests on their behalf.  This may be useful, for example,
   when the request could otherwise not be made, or to service the
   response from a cache in order to reduce response time and network
   bandwidth or energy consumption.

   In an overall architecture for a Constrained RESTful Environment,
   proxies can serve quite different purposes.  Proxies can be
   explicitly selected by clients, a role that we term "forward-proxy".
   Proxies can also be inserted to stand in for origin servers, a role
   that we term "reverse-proxy".  Orthogonal to this distinction, a
   proxy can map from a CoAP request to a CoAP request (CoAP-to-CoAP
   proxy) or translate from or to a different protocol ("cross-proxy").
   Full definitions of these terms are provided in <a href="#section-1.2">Section 1.2</a>.

   Notes:  The terminology in this specification has been selected to be
      culturally compatible with the terminology used in the wider web
      application environments, without necessarily matching it in every
      detail (which may not even be relevant to Constrained RESTful
      Environments).  Not too much semantics should be ascribed to the
      components of the terms (such as "forward", "reverse", or
      "cross").

      HTTP proxies, besides acting as HTTP proxies, often offer a
      transport-protocol proxying function ("CONNECT") to enable end-to-
      end transport layer security through the proxy.  No such function
      is defined for CoAP-to-CoAP proxies in this specification, as
      forwarding of UDP packets is unlikely to be of much value in
      Constrained RESTful Environments.  See also <a href="#section-10.2.7">Section 10.2.7</a> for the
      cross-proxy case.

   When a client uses a proxy to make a request that will use a secure
   URI scheme (e.g., "coaps" or "https"), the request towards the proxy
   SHOULD be sent using DTLS except where equivalent lower-layer
   security is used for the leg between the client and the proxy.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/5.7.1.%20%20Proxy%20Operation"></a><a class="selflink" href="#section-5.7.1" name="section-5.7.1">5.7.1</a>.  Proxy Operation</span>

   A proxy generally needs a way to determine potential request
   parameters for a request it places to a destination, based on the
   request it received from its client.  This way is fully specified for
   a forward-proxy but may depend on the specific configuration for a
   reverse-proxy.  In particular, the client of a reverse-proxy
   generally does not indicate a locator for the destination,





<span class="grey">Shelby, et al.               Standards Track                   [Page 44]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-45" id="page-45" name="page-45"> </a>
<span class="grey"><a href="rfc7252.html">RFC 7252</a>       The Constrained Application Protocol (CoAP)     June 2014</span>


   necessitating some form of namespace translation in the reverse-
   proxy.  However, some aspects of the operation of proxies are common
   to all its forms.

   If a proxy does not employ a cache, then it simply forwards the
   translated request to the determined destination.  Otherwise, if it
   does employ a cache but does not have a stored response that matches
   the translated request and is considered fresh, then it needs to
   refresh its cache according to <a href="#section-5.6">Section 5.6</a>.  For options in the
   request that the proxy recognizes, it knows whether the option is
   intended to act as part of the key used in looking up the cached
   value or not.  For example, since requests for different Uri-Path
   values address different resources, Uri-Path values are always part
   of the Cache-Key, while, e.g., Token values are never part of the
   Cache-Key.  For options that the proxy does not recognize but that
   are marked Safe-to-Forward in the option number, the option also
   indicates whether it is to be included in the Cache-Key (NoCacheKey
   is not all set) or not (NoCacheKey is all set).  (Options that are
   unrecognized and marked Unsafe lead to 4.02 Bad Option.)

   If the request to the destination times out, then a 5.04 (Gateway
   Timeout) response MUST be returned.  If the request to the
   destination returns a response that cannot be processed by the proxy
   (e.g, due to unrecognized critical options or message format errors),
   then a 5.02 (Bad Gateway) response MUST be returned.  Otherwise, the
   proxy returns the response to the client.

   If a response is generated out of a cache, the generated (or implied)
   Max-Age Option MUST NOT extend the max-age originally set by the
   server, considering the time the resource representation spent in the
   cache.  For example, the Max-Age Option could be adjusted by the
   proxy for each response using the formula:

      proxy-max-age = original-max-age - cache-age

   For example, if a request is made to a proxied resource that was
   refreshed 20 seconds ago and had an original Max-Age of 60 seconds,
   then that resource's proxied max-age is now 40 seconds.  Considering
   potential network delays on the way from the origin server, a proxy
   should be conservative in the max-age values offered.

   All options present in a proxy request MUST be processed at the
   proxy.  Unsafe options in a request that are not recognized by the
   proxy MUST lead to a 4.02 (Bad Option) response being returned by the
   proxy.  A CoAP-to-CoAP proxy MUST forward to the origin server all
   Safe-to-Forward options that it does not recognize.  Similarly,





<span class="grey">Shelby, et al.               Standards Track                   [Page 45]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-46" id="page-46" name="page-46"> </a>
<span class="grey"><a href="rfc7252.html">RFC 7252</a>       The Constrained Application Protocol (CoAP)     June 2014</span>


   Unsafe options in a response that are not recognized by the CoAP-to-
   CoAP proxy server MUST lead to a 5.02 (Bad Gateway) response.  Again,
   Safe-to-Forward options that are not recognized MUST be forwarded.

   Additional considerations for cross-protocol proxying between CoAP
   and HTTP are discussed in <a href="#section-10">Section 10</a>.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/5.7.2.%20%20Forward-Proxies"></a><a class="selflink" href="#section-5.7.2" name="section-5.7.2">5.7.2</a>.  Forward-Proxies</span>

   CoAP distinguishes between requests made (as if) to an origin server
   and requests made through a forward-proxy.  CoAP requests to a
   forward-proxy are made as normal Confirmable or Non-confirmable
   requests to the forward-proxy endpoint, but they specify the request
   URI in a different way: The request URI in a proxy request is
   specified as a string in the Proxy-Uri Option (see <a href="#section-5.10.2">Section 5.10.2</a>),
   while the request URI in a request to an origin server is split into
   the Uri-Host, Uri-Port, Uri-Path, and Uri-Query Options (see
   <a href="#section-5.10.1">Section 5.10.1</a>).  Alternatively, the URI in a proxy request can be
   assembled from a Proxy-Scheme option and the split options mentioned.

   When a proxy request is made to an endpoint and the endpoint is
   unwilling or unable to act as proxy for the request URI, it MUST
   return a 5.05 (Proxying Not Supported) response.  If the authority
   (host and port) is recognized as identifying the proxy endpoint
   itself (see <a href="#section-5.10.2">Section 5.10.2</a>), then the request MUST be treated as a
   local (non-proxied) request.

   Unless a proxy is configured to forward the proxy request to another
   proxy, it MUST translate the request as follows: the scheme of the
   request URI defines the outgoing protocol and its details (e.g., CoAP
   is used over UDP for the "coap" scheme and over DTLS for the "coaps"
   scheme.)  For a CoAP-to-CoAP proxy, the origin server's IP address
   and port are determined by the authority component of the request
   URI, and the request URI is decoded and split into the Uri-Host, Uri-
   Port, Uri-Path and Uri-Query Options.  This consumes the Proxy-Uri or
   Proxy-Scheme option, which is therefore not forwarded to the origin
   server.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/5.7.3.%20%20Reverse-Proxies"></a><a class="selflink" href="#section-5.7.3" name="section-5.7.3">5.7.3</a>.  Reverse-Proxies</span>

   Reverse-proxies do not make use of the Proxy-Uri or Proxy-Scheme
   options but need to determine the destination (next hop) of a request
   from information in the request and information in their
   configuration.  For example, a reverse-proxy might offer various
   resources as if they were its own resources, after having learned of
   their existence through resource discovery.  The reverse-proxy is
   free to build a namespace for the URIs that identify these resources.
   A reverse-proxy may also build a namespace that gives the client more



<span class="grey">Shelby, et al.               Standards Track                   [Page 46]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-47" id="page-47" name="page-47"> </a>
<span class="grey"><a href="rfc7252.html">RFC 7252</a>       The Constrained Application Protocol (CoAP)     June 2014</span>


   control over where the request goes, e.g., by embedding host
   identifiers and port numbers into the URI path of the resources
   offered.

   In processing the response, a reverse-proxy has to be careful that
   ETag option values from different sources are not mixed up on one
   resource offered to its clients.  In many cases, the ETag can be
   forwarded unchanged.  If the mapping from a resource offered by the
   reverse-proxy to resources offered by its various origin servers is
   not unique, the reverse-proxy may need to generate a new ETag, making
   sure the semantics of this option are properly preserved.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.8.%20%20Method%20Definitions"></a><a class="selflink" href="#section-5.8" name="section-5.8">5.8</a>.  Method Definitions</span>

   In this section, each method is defined along with its behavior.  A
   request with an unrecognized or unsupported Method Code MUST generate
   a 4.05 (Method Not Allowed) piggybacked response.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/5.8.1.%20%20GET"></a><a class="selflink" href="#section-5.8.1" name="section-5.8.1">5.8.1</a>.  GET</span>

   The GET method retrieves a representation for the information that
   currently corresponds to the resource identified by the request URI.
   If the request includes an Accept Option, that indicates the
   preferred content-format of a response.  If the request includes an
   ETag Option, the GET method requests that ETag be validated and that
   the representation be transferred only if validation failed.  Upon
   success, a 2.05 (Content) or 2.03 (Valid) Response Code SHOULD be
   present in the response.

   The GET method is safe and idempotent.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/5.8.2.%20%20POST"></a><a class="selflink" href="#section-5.8.2" name="section-5.8.2">5.8.2</a>.  POST</span>

   The POST method requests that the representation enclosed in the
   request be processed.  The actual function performed by the POST
   method is determined by the origin server and dependent on the target
   resource.  It usually results in a new resource being created or the
   target resource being updated.

   If a resource has been created on the server, the response returned
   by the server SHOULD have a 2.01 (Created) Response Code and SHOULD
   include the URI of the new resource in a sequence of one or more
   Location-Path and/or Location-Query Options (<a href="#section-5.10.7">Section 5.10.7</a>).  If the
   POST succeeds but does not result in a new resource being created on
   the server, the response SHOULD have a 2.04 (Changed) Response Code.
   If the POST succeeds and results in the target resource being
   deleted, the response SHOULD have a 2.02 (Deleted) Response Code.
   POST is neither safe nor idempotent.



<span class="grey">Shelby, et al.               Standards Track                   [Page 47]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-48" id="page-48" name="page-48"> </a>
<span class="grey"><a href="rfc7252.html">RFC 7252</a>       The Constrained Application Protocol (CoAP)     June 2014</span>


<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/5.8.3.%20%20PUT"></a><a class="selflink" href="#section-5.8.3" name="section-5.8.3">5.8.3</a>.  PUT</span>

   The PUT method requests that the resource identified by the request
   URI be updated or created with the enclosed representation.  The
   representation format is specified by the media type and content
   coding given in the Content-Format Option, if provided.

   If a resource exists at the request URI, the enclosed representation
   SHOULD be considered a modified version of that resource, and a 2.04
   (Changed) Response Code SHOULD be returned.  If no resource exists,
   then the server MAY create a new resource with that URI, resulting in
   a 2.01 (Created) Response Code.  If the resource could not be created
   or modified, then an appropriate error Response Code SHOULD be sent.

   Further restrictions to a PUT can be made by including the If-Match
   (see <a href="#section-5.10.8.1">Section 5.10.8.1</a>) or If-None-Match (see <a href="#section-5.10.8.2">Section 5.10.8.2</a>)
   options in the request.

   PUT is not safe but is idempotent.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/5.8.4.%20%20DELETE"></a><a class="selflink" href="#section-5.8.4" name="section-5.8.4">5.8.4</a>.  DELETE</span>

   The DELETE method requests that the resource identified by the
   request URI be deleted.  A 2.02 (Deleted) Response Code SHOULD be
   used on success or in case the resource did not exist before the
   request.

   DELETE is not safe but is idempotent.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.9.%20%20Response%20Code%20Definitions"></a><a class="selflink" href="#section-5.9" name="section-5.9">5.9</a>.  Response Code Definitions</span>

   Each Response Code is described below, including any options required
   in the response.  Where appropriate, some of the codes will be
   specified in regards to related Response Codes in HTTP [<a href="rfc2616.html" title='"Hypertext Transfer Protocol -- HTTP/1.1"'>RFC2616</a>];
   this does not mean that any such relationship modifies the HTTP
   mapping specified in <a href="#section-10">Section 10</a>.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/5.9.1.%20%20Success%202.xx"></a><a class="selflink" href="#section-5.9.1" name="section-5.9.1">5.9.1</a>.  Success 2.xx</span>

   This class of Response Code indicates that the clients request was
   successfully received, understood, and accepted.

<span class="h5"><a class="dashAnchor" name="//apple_ref/Section/5.9.1.1.%20%202.01%20Created"></a><a class="selflink" href="#section-5.9.1.1" name="section-5.9.1.1">5.9.1.1</a>.  2.01 Created</span>

   Like HTTP 201 "Created", but only used in response to POST and PUT
   requests.  The payload returned with the response, if any, is a
   representation of the action result.




<span class="grey">Shelby, et al.               Standards Track                   [Page 48]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-49" id="page-49" name="page-49"> </a>
<span class="grey"><a href="rfc7252.html">RFC 7252</a>       The Constrained Application Protocol (CoAP)     June 2014</span>


   If the response includes one or more Location-Path and/or Location-
   Query Options, the values of these options specify the location at
   which the resource was created.  Otherwise, the resource was created
   at the request URI.  A cache receiving this response MUST mark any
   stored response for the created resource as not fresh.

   This response is not cacheable.

<span class="h5"><a class="dashAnchor" name="//apple_ref/Section/5.9.1.2.%20%202.02%20Deleted"></a><a class="selflink" href="#section-5.9.1.2" name="section-5.9.1.2">5.9.1.2</a>.  2.02 Deleted</span>

   This Response Code is like HTTP 204 "No Content" but only used in
   response to requests that cause the resource to cease being
   available, such as DELETE and, in certain circumstances, POST.  The
   payload returned with the response, if any, is a representation of
   the action result.

   This response is not cacheable.  However, a cache MUST mark any
   stored response for the deleted resource as not fresh.

<span class="h5"><a class="dashAnchor" name="//apple_ref/Section/5.9.1.3.%20%202.03%20Valid"></a><a class="selflink" href="#section-5.9.1.3" name="section-5.9.1.3">5.9.1.3</a>.  2.03 Valid</span>

   This Response Code is related to HTTP 304 "Not Modified" but only
   used to indicate that the response identified by the entity-tag
   identified by the included ETag Option is valid.  Accordingly, the
   response MUST include an ETag Option and MUST NOT include a payload.

   When a cache that recognizes and processes the ETag response option
   receives a 2.03 (Valid) response, it MUST update the stored response
   with the value of the Max-Age Option included in the response
   (explicitly, or implicitly as a default value; see also
   <a href="#section-5.6.2">Section 5.6.2</a>).  For each type of Safe-to-Forward option present in
   the response, the (possibly empty) set of options of this type that
   are present in the stored response MUST be replaced with the set of
   options of this type in the response received.  (Unsafe options may
   trigger similar option-specific processing as defined by the option.)

<span class="h5"><a class="dashAnchor" name="//apple_ref/Section/5.9.1.4.%20%202.04%20Changed"></a><a class="selflink" href="#section-5.9.1.4" name="section-5.9.1.4">5.9.1.4</a>.  2.04 Changed</span>

   This Response Code is like HTTP 204 "No Content" but only used in
   response to POST and PUT requests.  The payload returned with the
   response, if any, is a representation of the action result.

   This response is not cacheable.  However, a cache MUST mark any
   stored response for the changed resource as not fresh.







<span class="grey">Shelby, et al.               Standards Track                   [Page 49]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-50" id="page-50" name="page-50"> </a>
<span class="grey"><a href="rfc7252.html">RFC 7252</a>       The Constrained Application Protocol (CoAP)     June 2014</span>


<span class="h5"><a class="dashAnchor" name="//apple_ref/Section/5.9.1.5.%20%202.05%20Content"></a><a class="selflink" href="#section-5.9.1.5" name="section-5.9.1.5">5.9.1.5</a>.  2.05 Content</span>

   This Response Code is like HTTP 200 "OK" but only used in response to
   GET requests.

   The payload returned with the response is a representation of the
   target resource.

   This response is cacheable: Caches can use the Max-Age Option to
   determine freshness (see <a href="#section-5.6.1">Section 5.6.1</a>) and (if present) the ETag
   Option for validation (see <a href="#section-5.6.2">Section 5.6.2</a>).

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/5.9.2.%20%20Client%20Error%204.xx"></a><a class="selflink" href="#section-5.9.2" name="section-5.9.2">5.9.2</a>.  Client Error 4.xx</span>

   This class of Response Code is intended for cases in which the client
   seems to have erred.  These Response Codes are applicable to any
   request method.

   The server SHOULD include a diagnostic payload under the conditions
   detailed in <a href="#section-5.5.2">Section 5.5.2</a>.

   Responses of this class are cacheable: Caches can use the Max-Age
   Option to determine freshness (see <a href="#section-5.6.1">Section 5.6.1</a>).  They cannot be
   validated.

<span class="h5"><a class="dashAnchor" name="//apple_ref/Section/5.9.2.1.%20%204.00%20Bad%20Request"></a><a class="selflink" href="#section-5.9.2.1" name="section-5.9.2.1">5.9.2.1</a>.  4.00 Bad Request</span>

   This Response Code is Like HTTP 400 "Bad Request".

<span class="h5"><a class="dashAnchor" name="//apple_ref/Section/5.9.2.2.%20%204.01%20Unauthorized"></a><a class="selflink" href="#section-5.9.2.2" name="section-5.9.2.2">5.9.2.2</a>.  4.01 Unauthorized</span>

   The client is not authorized to perform the requested action.  The
   client SHOULD NOT repeat the request without first improving its
   authentication status to the server.  Which specific mechanism can be
   used for this is outside this document's scope; see also <a href="#section-9">Section 9</a>.

<span class="h5"><a class="dashAnchor" name="//apple_ref/Section/5.9.2.3.%20%204.02%20Bad%20Option"></a><a class="selflink" href="#section-5.9.2.3" name="section-5.9.2.3">5.9.2.3</a>.  4.02 Bad Option</span>

   The request could not be understood by the server due to one or more
   unrecognized or malformed options.  The client SHOULD NOT repeat the
   request without modification.

<span class="h5"><a class="dashAnchor" name="//apple_ref/Section/5.9.2.4.%20%204.03%20Forbidden"></a><a class="selflink" href="#section-5.9.2.4" name="section-5.9.2.4">5.9.2.4</a>.  4.03 Forbidden</span>

   This Response Code is like HTTP 403 "Forbidden".






<span class="grey">Shelby, et al.               Standards Track                   [Page 50]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-51" id="page-51" name="page-51"> </a>
<span class="grey"><a href="rfc7252.html">RFC 7252</a>       The Constrained Application Protocol (CoAP)     June 2014</span>


<span class="h5"><a class="dashAnchor" name="//apple_ref/Section/5.9.2.5.%20%204.04%20Not%20Found"></a><a class="selflink" href="#section-5.9.2.5" name="section-5.9.2.5">5.9.2.5</a>.  4.04 Not Found</span>

   This Response Code is like HTTP 404 "Not Found".

<span class="h5"><a class="dashAnchor" name="//apple_ref/Section/5.9.2.6.%20%204.05%20Method%20Not%20Allowed"></a><a class="selflink" href="#section-5.9.2.6" name="section-5.9.2.6">5.9.2.6</a>.  4.05 Method Not Allowed</span>

   This Response Code is like HTTP 405 "Method Not Allowed" but with no
   parallel to the "Allow" header field.

<span class="h5"><a class="dashAnchor" name="//apple_ref/Section/5.9.2.7.%20%204.06%20Not%20Acceptable"></a><a class="selflink" href="#section-5.9.2.7" name="section-5.9.2.7">5.9.2.7</a>.  4.06 Not Acceptable</span>

   This Response Code is like HTTP 406 "Not Acceptable", but with no
   response entity.

<span class="h5"><a class="dashAnchor" name="//apple_ref/Section/5.9.2.8.%20%204.12%20Precondition%20Failed"></a><a class="selflink" href="#section-5.9.2.8" name="section-5.9.2.8">5.9.2.8</a>.  4.12 Precondition Failed</span>

   This Response Code is like HTTP 412 "Precondition Failed".

<span class="h5"><a class="dashAnchor" name="//apple_ref/Section/5.9.2.9.%20%204.13%20Request%20Entity%20Too%20Large"></a><a class="selflink" href="#section-5.9.2.9" name="section-5.9.2.9">5.9.2.9</a>.  4.13 Request Entity Too Large</span>

   This Response Code is like HTTP 413 "Request Entity Too Large".

   The response SHOULD include a Size1 Option (<a href="#section-5.10.9">Section 5.10.9</a>) to
   indicate the maximum size of request entity the server is able and
   willing to handle, unless the server is not in a position to make
   this information available.

<span class="h5"><a class="dashAnchor" name="//apple_ref/Section/5.9.2.10.%20%204.15%20Unsupported%20Content-Format"></a><a class="selflink" href="#section-5.9.2.10" name="section-5.9.2.10">5.9.2.10</a>.  4.15 Unsupported Content-Format</span>

   This Response Code is like HTTP 415 "Unsupported Media Type".

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/5.9.3.%20%20Server%20Error%205.xx"></a><a class="selflink" href="#section-5.9.3" name="section-5.9.3">5.9.3</a>.  Server Error 5.xx</span>

   This class of Response Code indicates cases in which the server is
   aware that it has erred or is incapable of performing the request.
   These Response Codes are applicable to any request method.

   The server SHOULD include a diagnostic payload under the conditions
   detailed in <a href="#section-5.5.2">Section 5.5.2</a>.

   Responses of this class are cacheable: Caches can use the Max-Age
   Option to determine freshness (see <a href="#section-5.6.1">Section 5.6.1</a>).  They cannot be
   validated.

<span class="h5"><a class="dashAnchor" name="//apple_ref/Section/5.9.3.1.%20%205.00%20Internal%20Server%20Error"></a><a class="selflink" href="#section-5.9.3.1" name="section-5.9.3.1">5.9.3.1</a>.  5.00 Internal Server Error</span>

   This Response Code is like HTTP 500 "Internal Server Error".




<span class="grey">Shelby, et al.               Standards Track                   [Page 51]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-52" id="page-52" name="page-52"> </a>
<span class="grey"><a href="rfc7252.html">RFC 7252</a>       The Constrained Application Protocol (CoAP)     June 2014</span>


<span class="h5"><a class="dashAnchor" name="//apple_ref/Section/5.9.3.2.%20%205.01%20Not%20Implemented"></a><a class="selflink" href="#section-5.9.3.2" name="section-5.9.3.2">5.9.3.2</a>.  5.01 Not Implemented</span>

   This Response Code is like HTTP 501 "Not Implemented".

<span class="h5"><a class="dashAnchor" name="//apple_ref/Section/5.9.3.3.%20%205.02%20Bad%20Gateway"></a><a class="selflink" href="#section-5.9.3.3" name="section-5.9.3.3">5.9.3.3</a>.  5.02 Bad Gateway</span>

   This Response Code is like HTTP 502 "Bad Gateway".

<span class="h5"><a class="dashAnchor" name="//apple_ref/Section/5.9.3.4.%20%205.03%20Service%20Unavailable"></a><a class="selflink" href="#section-5.9.3.4" name="section-5.9.3.4">5.9.3.4</a>.  5.03 Service Unavailable</span>

   This Response Code is like HTTP 503 "Service Unavailable" but uses
   the Max-Age Option in place of the "Retry-After" header field to
   indicate the number of seconds after which to retry.

<span class="h5"><a class="dashAnchor" name="//apple_ref/Section/5.9.3.5.%20%205.04%20Gateway%20Timeout"></a><a class="selflink" href="#section-5.9.3.5" name="section-5.9.3.5">5.9.3.5</a>.  5.04 Gateway Timeout</span>

   This Response Code is like HTTP 504 "Gateway Timeout".

<span class="h5"><a class="dashAnchor" name="//apple_ref/Section/5.9.3.6.%20%205.05%20Proxying%20Not%20Supported"></a><a class="selflink" href="#section-5.9.3.6" name="section-5.9.3.6">5.9.3.6</a>.  5.05 Proxying Not Supported</span>

   The server is unable or unwilling to act as a forward-proxy for the
   URI specified in the Proxy-Uri Option or using Proxy-Scheme (see
   <a href="#section-5.10.2">Section 5.10.2</a>).

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.10.%20%20Option%20Definitions"></a><a class="selflink" href="#section-5.10" name="section-5.10">5.10</a>.  Option Definitions</span>

   The individual CoAP options are summarized in Table 4 and explained
   in the subsections of this section.

   In this table, the C, U, and N columns indicate the properties
   Critical, UnSafe, and NoCacheKey, respectively.  Since NoCacheKey
   only has a meaning for options that are Safe-to-Forward (not marked
   Unsafe), the column is filled with a dash for UnSafe options.


















<span class="grey">Shelby, et al.               Standards Track                   [Page 52]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-53" id="page-53" name="page-53"> </a>
<span class="grey"><a href="rfc7252.html">RFC 7252</a>       The Constrained Application Protocol (CoAP)     June 2014</span>


   +-----+---+---+---+---+----------------+--------+--------+----------+
   | No. | C | U | N | R | Name           | Format | Length | Default  |
   +-----+---+---+---+---+----------------+--------+--------+----------+
   |   1 | x |   |   | x | If-Match       | opaque | 0-8    | (none)   |
   |   3 | x | x | - |   | Uri-Host       | string | 1-255  | (see     |
   |     |   |   |   |   |                |        |        | below)   |
   |   4 |   |   |   | x | ETag           | opaque | 1-8    | (none)   |
   |   5 | x |   |   |   | If-None-Match  | empty  | 0      | (none)   |
   |   7 | x | x | - |   | Uri-Port       | uint   | 0-2    | (see     |
   |     |   |   |   |   |                |        |        | below)   |
   |   8 |   |   |   | x | Location-Path  | string | 0-255  | (none)   |
   |  11 | x | x | - | x | Uri-Path       | string | 0-255  | (none)   |
   |  12 |   |   |   |   | Content-Format | uint   | 0-2    | (none)   |
   |  14 |   | x | - |   | Max-Age        | uint   | 0-4    | 60       |
   |  15 | x | x | - | x | Uri-Query      | string | 0-255  | (none)   |
   |  17 | x |   |   |   | Accept         | uint   | 0-2    | (none)   |
   |  20 |   |   |   | x | Location-Query | string | 0-255  | (none)   |
   |  35 | x | x | - |   | Proxy-Uri      | string | 1-1034 | (none)   |
   |  39 | x | x | - |   | Proxy-Scheme   | string | 1-255  | (none)   |
   |  60 |   |   | x |   | Size1          | uint   | 0-4    | (none)   |
   +-----+---+---+---+---+----------------+--------+--------+----------+

             C=Critical, U=Unsafe, N=NoCacheKey, R=Repeatable

                             Table 4: Options

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/5.10.1.%20%20Uri-Host%2C%20Uri-Port%2C%20Uri-Path%2C%20and%20Uri-Query"></a><a class="selflink" href="#section-5.10.1" name="section-5.10.1">5.10.1</a>.  Uri-Host, Uri-Port, Uri-Path, and Uri-Query</span>

   The Uri-Host, Uri-Port, Uri-Path, and Uri-Query Options are used to
   specify the target resource of a request to a CoAP origin server.
   The options encode the different components of the request URI in a
   way that no percent-encoding is visible in the option values and that
   the full URI can be reconstructed at any involved endpoint.  The
   syntax of CoAP URIs is defined in <a href="#section-6">Section 6</a>.

   The steps for parsing URIs into options is defined in <a href="#section-6.4">Section 6.4</a>.
   These steps result in zero or more Uri-Host, Uri-Port, Uri-Path, and
   Uri-Query Options being included in a request, where each option
   holds the following values:

   o  the Uri-Host Option specifies the Internet host of the resource
      being requested,

   o  the Uri-Port Option specifies the transport-layer port number of
      the resource,

   o  each Uri-Path Option specifies one segment of the absolute path to
      the resource, and



<span class="grey">Shelby, et al.               Standards Track                   [Page 53]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-54" id="page-54" name="page-54"> </a>
<span class="grey"><a href="rfc7252.html">RFC 7252</a>       The Constrained Application Protocol (CoAP)     June 2014</span>


   o  each Uri-Query Option specifies one argument parameterizing the
      resource.

   Note: Fragments (<a href="rfc3986.html#section-3.5">[RFC3986], Section 3.5</a>) are not part of the request
   URI and thus will not be transmitted in a CoAP request.

   The default value of the Uri-Host Option is the IP literal
   representing the destination IP address of the request message.
   Likewise, the default value of the Uri-Port Option is the destination
   UDP port.  The default values for the Uri-Host and Uri-Port Options
   are sufficient for requests to most servers.  Explicit Uri-Host and
   Uri-Port Options are typically used when an endpoint hosts multiple
   virtual servers.

   The Uri-Path and Uri-Query Option can contain any character sequence.
   No percent-encoding is performed.  The value of a Uri-Path Option
   MUST NOT be "." or ".." (as the request URI must be resolved before
   parsing it into options).

   The steps for constructing the request URI from the options are
   defined in <a href="#section-6.5">Section 6.5</a>.  Note that an implementation does not
   necessarily have to construct the URI; it can simply look up the
   target resource by examining the individual options.

   Examples can be found in <a href="#appendix-B">Appendix B</a>.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/5.10.2.%20%20Proxy-Uri%20and%20Proxy-Scheme"></a><a class="selflink" href="#section-5.10.2" name="section-5.10.2">5.10.2</a>.  Proxy-Uri and Proxy-Scheme</span>

   The Proxy-Uri Option is used to make a request to a forward-proxy
   (see <a href="#section-5.7">Section 5.7</a>).  The forward-proxy is requested to forward the
   request or service it from a valid cache and return the response.

   The option value is an absolute-URI (<a href="rfc3986.html#section-4.3">[RFC3986], Section 4.3</a>).

   Note that the forward-proxy MAY forward the request on to another
   proxy or directly to the server specified by the absolute-URI.  In
   order to avoid request loops, a proxy MUST be able to recognize all
   of its server names, including any aliases, local variations, and the
   numeric IP addresses.

   An endpoint receiving a request with a Proxy-Uri Option that is
   unable or unwilling to act as a forward-proxy for the request MUST
   cause the return of a 5.05 (Proxying Not Supported) response.

   The Proxy-Uri Option MUST take precedence over any of the Uri-Host,
   Uri-Port, Uri-Path or Uri-Query options (each of which MUST NOT be
   included in a request containing the Proxy-Uri Option).




<span class="grey">Shelby, et al.               Standards Track                   [Page 54]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-55" id="page-55" name="page-55"> </a>
<span class="grey"><a href="rfc7252.html">RFC 7252</a>       The Constrained Application Protocol (CoAP)     June 2014</span>


   As a special case to simplify many proxy clients, the absolute-URI
   can be constructed from the Uri-* options.  When a Proxy-Scheme
   Option is present, the absolute-URI is constructed as follows: a CoAP
   URI is constructed from the Uri-* options as defined in <a href="#section-6.5">Section 6.5</a>.
   In the resulting URI, the initial scheme up to, but not including,
   the following colon is then replaced by the content of the Proxy-
   Scheme Option.  Note that this case is only applicable if the
   components of the desired URI other than the scheme component
   actually can be expressed using Uri-* options; for example, to
   represent a URI with a userinfo component in the authority, only
   Proxy-Uri can be used.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/5.10.3.%20%20Content-Format"></a><a class="selflink" href="#section-5.10.3" name="section-5.10.3">5.10.3</a>.  Content-Format</span>

   The Content-Format Option indicates the representation format of the
   message payload.  The representation format is given as a numeric
   Content-Format identifier that is defined in the "CoAP Content-
   Formats" registry (<a href="#section-12.3">Section 12.3</a>).  In the absence of the option, no
   default value is assumed, i.e., the representation format of any
   representation message payload is indeterminate (<a href="#section-5.5">Section 5.5</a>).

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/5.10.4.%20%20Accept"></a><a class="selflink" href="#section-5.10.4" name="section-5.10.4">5.10.4</a>.  Accept</span>

   The CoAP Accept option can be used to indicate which Content-Format
   is acceptable to the client.  The representation format is given as a
   numeric Content-Format identifier that is defined in the "CoAP
   Content-Formats" registry (<a href="#section-12.3">Section 12.3</a>).  If no Accept option is
   given, the client does not express a preference (thus no default
   value is assumed).  The client prefers the representation returned by
   the server to be in the Content-Format indicated.  The server returns
   the preferred Content-Format if available.  If the preferred Content-
   Format cannot be returned, then a 4.06 "Not Acceptable" MUST be sent
   as a response, unless another error code takes precedence for this
   response.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/5.10.5.%20%20Max-Age"></a><a class="selflink" href="#section-5.10.5" name="section-5.10.5">5.10.5</a>.  Max-Age</span>

   The Max-Age Option indicates the maximum time a response may be
   cached before it is considered not fresh (see <a href="#section-5.6.1">Section 5.6.1</a>).

   The option value is an integer number of seconds between 0 and
   2**32-1 inclusive (about 136.1 years).  A default value of 60 seconds
   is assumed in the absence of the option in a response.

   The value is intended to be current at the time of transmission.
   Servers that provide resources with strict tolerances on the value of
   Max-Age SHOULD update the value before each retransmission.  (See
   also <a href="#section-5.7.1">Section 5.7.1</a>.)



<span class="grey">Shelby, et al.               Standards Track                   [Page 55]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-56" id="page-56" name="page-56"> </a>
<span class="grey"><a href="rfc7252.html">RFC 7252</a>       The Constrained Application Protocol (CoAP)     June 2014</span>


<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/5.10.6.%20%20ETag"></a><a class="selflink" href="#section-5.10.6" name="section-5.10.6">5.10.6</a>.  ETag</span>

   An entity-tag is intended for use as a resource-local identifier for
   differentiating between representations of the same resource that
   vary over time.  It is generated by the server providing the
   resource, which may generate it in any number of ways including a
   version, checksum, hash, or time.  An endpoint receiving an entity-
   tag MUST treat it as opaque and make no assumptions about its content
   or structure.  (Endpoints that generate an entity-tag are encouraged
   to use the most compact representation possible, in particular in
   regards to clients and intermediaries that may want to store multiple
   ETag values.)

<span class="h5"><a class="dashAnchor" name="//apple_ref/Section/5.10.6.1.%20%20ETag%20as%20a%20Response%20Option"></a><a class="selflink" href="#section-5.10.6.1" name="section-5.10.6.1">5.10.6.1</a>.  ETag as a Response Option</span>

   The ETag Option in a response provides the current value (i.e., after
   the request was processed) of the entity-tag for the "tagged
   representation".  If no Location-* options are present, the tagged
   representation is the selected representation (<a href="#section-5.5.3">Section 5.5.3</a>) of the
   target resource.  If one or more Location-* options are present and
   thus a location URI is indicated (<a href="#section-5.10.7">Section 5.10.7</a>), the tagged
   representation is the representation that would be retrieved by a GET
   request to the location URI.

   An ETag response option can be included with any response for which
   there is a tagged representation (e.g., it would not be meaningful in
   a 4.04 or 4.00 response).  The ETag Option MUST NOT occur more than
   once in a response.

   There is no default value for the ETag Option; if it is not present
   in a response, the server makes no statement about the entity-tag for
   the tagged representation.

<span class="h5"><a class="dashAnchor" name="//apple_ref/Section/5.10.6.2.%20%20ETag%20as%20a%20Request%20Option"></a><a class="selflink" href="#section-5.10.6.2" name="section-5.10.6.2">5.10.6.2</a>.  ETag as a Request Option</span>

   In a GET request, an endpoint that has one or more representations
   previously obtained from the resource, and has obtained ETag response
   options with these, can specify an instance of the ETag Option for
   one or more of these stored responses.

   A server can issue a 2.03 Valid response (<a href="#section-5.9.1.3">Section 5.9.1.3</a>) in place
   of a 2.05 Content response if one of the ETags given is the entity-
   tag for the current representation, i.e., is valid; the 2.03 Valid
   response then echoes this specific ETag in a response option.

   In effect, a client can determine if any of the stored
   representations is current (see <a href="#section-5.6.2">Section 5.6.2</a>) without needing to
   transfer them again.



<span class="grey">Shelby, et al.               Standards Track                   [Page 56]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-57" id="page-57" name="page-57"> </a>
<span class="grey"><a href="rfc7252.html">RFC 7252</a>       The Constrained Application Protocol (CoAP)     June 2014</span>


   The ETag Option MAY occur zero, one, or multiple times in a request.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/5.10.7.%20%20Location-Path%20and%20Location-Query"></a><a class="selflink" href="#section-5.10.7" name="section-5.10.7">5.10.7</a>.  Location-Path and Location-Query</span>

   The Location-Path and Location-Query Options together indicate a
   relative URI that consists either of an absolute path, a query
   string, or both.  A combination of these options is included in a
   2.01 (Created) response to indicate the location of the resource
   created as the result of a POST request (see <a href="#section-5.8.2">Section 5.8.2</a>).  The
   location is resolved relative to the request URI.

   If a response with one or more Location-Path and/or Location-Query
   Options passes through a cache that interprets these options and the
   implied URI identifies one or more currently stored responses, those
   entries MUST be marked as not fresh.

   Each Location-Path Option specifies one segment of the absolute path
   to the resource, and each Location-Query Option specifies one
   argument parameterizing the resource.  The Location-Path and
   Location-Query Option can contain any character sequence.  No
   percent-encoding is performed.  The value of a Location-Path Option
   MUST NOT be "." or "..".

   The steps for constructing the location URI from the options are
   analogous to <a href="#section-6.5">Section 6.5</a>, except that the first five steps are
   skipped and the result is a relative URI-reference, which is then
   interpreted relative to the request URI.  Note that the relative URI-
   reference constructed this way always includes an absolute path
   (e.g., leaving out Location-Path but supplying Location-Query means
   the path component in the URI is "/").

   The options that are used to compute the relative URI-reference are
   collectively called Location-* options.  Beyond Location-Path and
   Location-Query, more Location-* options may be defined in the future
   and have been reserved option numbers 128, 132, 136, and 140.  If any
   of these reserved option numbers occurs in addition to Location-Path
   and/or Location-Query and are not supported, then a 4.02 (Bad Option)
   error MUST be returned.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/5.10.8.%20%20Conditional%20Request%20Options"></a><a class="selflink" href="#section-5.10.8" name="section-5.10.8">5.10.8</a>.  Conditional Request Options</span>

   Conditional request options enable a client to ask the server to
   perform the request only if certain conditions specified by the
   option are fulfilled.







<span class="grey">Shelby, et al.               Standards Track                   [Page 57]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-58" id="page-58" name="page-58"> </a>
<span class="grey"><a href="rfc7252.html">RFC 7252</a>       The Constrained Application Protocol (CoAP)     June 2014</span>


   For each of these options, if the condition given is not fulfilled,
   then the server MUST NOT perform the requested method.  Instead, the
   server MUST respond with the 4.12 (Precondition Failed) Response
   Code.

   If the condition is fulfilled, the server performs the request method
   as if the conditional request options were not present.

   If the request would, without the conditional request options, result
   in anything other than a 2.xx or 4.12 Response Code, then any
   conditional request options MAY be ignored.

<span class="h5"><a class="dashAnchor" name="//apple_ref/Section/5.10.8.1.%20%20If-Match"></a><a class="selflink" href="#section-5.10.8.1" name="section-5.10.8.1">5.10.8.1</a>.  If-Match</span>

   The If-Match Option MAY be used to make a request conditional on the
   current existence or value of an ETag for one or more representations
   of the target resource.  If-Match is generally useful for resource
   update requests, such as PUT requests, as a means for protecting
   against accidental overwrites when multiple clients are acting in
   parallel on the same resource (i.e., the "lost update" problem).

   The value of an If-Match option is either an ETag or the empty
   string.  An If-Match option with an ETag matches a representation
   with that exact ETag.  An If-Match option with an empty value matches
   any existing representation (i.e., it places the precondition on the
   existence of any current representation for the target resource).

   The If-Match Option can occur multiple times.  If any of the options
   match, then the condition is fulfilled.

   If there is one or more If-Match Options, but none of the options
   match, then the condition is not fulfilled.

<span class="h5"><a class="dashAnchor" name="//apple_ref/Section/5.10.8.2.%20%20If-None-Match"></a><a class="selflink" href="#section-5.10.8.2" name="section-5.10.8.2">5.10.8.2</a>.  If-None-Match</span>

   The If-None-Match Option MAY be used to make a request conditional on
   the nonexistence of the target resource.  If-None-Match is useful for
   resource creation requests, such as PUT requests, as a means for
   protecting against accidental overwrites when multiple clients are
   acting in parallel on the same resource.  The If-None-Match Option
   carries no value.

   If the target resource does exist, then the condition is not
   fulfilled.

   (It is not very useful to combine If-Match and If-None-Match options
   in one request, because the condition will then never be fulfilled.)




<span class="grey">Shelby, et al.               Standards Track                   [Page 58]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-59" id="page-59" name="page-59"> </a>
<span class="grey"><a href="rfc7252.html">RFC 7252</a>       The Constrained Application Protocol (CoAP)     June 2014</span>


<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/5.10.9.%20%20Size1%20Option"></a><a class="selflink" href="#section-5.10.9" name="section-5.10.9">5.10.9</a>.  Size1 Option</span>

   The Size1 option provides size information about the resource
   representation in a request.  The option value is an integer number
   of bytes.  Its main use is with block-wise transfers [<a href="#ref-BLOCK" title='"Blockwise transfers in CoAP"'>BLOCK</a>].  In the
   present specification, it is used in 4.13 responses (<a href="#section-5.9.2.9">Section 5.9.2.9</a>)
   to indicate the maximum size of request entity that the server is
   able and willing to handle.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/6.%20%20CoAP%20URIs"></a><a class="selflink" href="#section-6" name="section-6">6</a>.  CoAP URIs</span>

   CoAP uses the "coap" and "coaps" URI schemes for identifying CoAP
   resources and providing a means of locating the resource.  Resources
   are organized hierarchically and governed by a potential CoAP origin
   server listening for CoAP requests ("coap") or DTLS-secured CoAP
   requests ("coaps") on a given UDP port.  The CoAP server is
   identified via the generic syntax's authority component, which
   includes a host component and optional UDP port number.  The
   remainder of the URI is considered to be identifying a resource that
   can be operated on by the methods defined by the CoAP protocol.  The
   "coap" and "coaps" URI schemes can thus be compared to the "http" and
   "https" URI schemes, respectively.

   The syntax of the "coap" and "coaps" URI schemes is specified in this
   section in Augmented Backus-Naur Form (ABNF) [<a href="rfc5234.html" title='"Augmented BNF for Syntax Specifications: ABNF"'>RFC5234</a>].  The
   definitions of "host", "port", "path-abempty", "query", "segment",
   "IP-literal", "IPv4address", and "reg-name" are adopted from
   [<a href="rfc3986.html" title='"Uniform Resource Identifier (URI): Generic Syntax"'>RFC3986</a>].

   Implementation Note:  Unfortunately, over time, the URI format has
      acquired significant complexity.  Implementers are encouraged to
      examine [<a href="rfc3986.html" title='"Uniform Resource Identifier (URI): Generic Syntax"'>RFC3986</a>] closely.  For example, the ABNF for IPv6
      addresses is more complicated than maybe expected.  Also,
      implementers should take care to perform the processing of
      percent-decoding or percent-encoding exactly once on the way from
      a URI to its decoded components or back.  Percent-encoding is
      crucial for data transparency but may lead to unusual results such
      as a slash character in a path component.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/6.1.%20%20coap%20URI%20Scheme"></a><a class="selflink" href="#section-6.1" name="section-6.1">6.1</a>.  coap URI Scheme</span>

   coap-URI = "coap:" "//" host [ ":" port ] path-abempty [ "?" query ]

   If the host component is provided as an IP-literal or IPv4address,
   then the CoAP server can be reached at that IP address.  If host is a
   registered name, then that name is considered an indirect identifier
   and the endpoint might use a name resolution service, such as DNS, to
   find the address of that host.  The host MUST NOT be empty; if a URI



<span class="grey">Shelby, et al.               Standards Track                   [Page 59]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-60" id="page-60" name="page-60"> </a>
<span class="grey"><a href="rfc7252.html">RFC 7252</a>       The Constrained Application Protocol (CoAP)     June 2014</span>


   is received with a missing authority or an empty host, then it MUST
   be considered invalid.  The port subcomponent indicates the UDP port
   at which the CoAP server is located.  If it is empty or not given,
   then the default port 5683 is assumed.

   The path identifies a resource within the scope of the host and port.
   It consists of a sequence of path segments separated by a slash
   character (U+002F SOLIDUS "/").

   The query serves to further parameterize the resource.  It consists
   of a sequence of arguments separated by an ampersand character
   (U+0026 AMPERSAND "&amp;").  An argument is often in the form of a
   "key=value" pair.

   The "coap" URI scheme supports the path prefix "/.well-known/"
   defined by [<a href="rfc5785.html" title='"Defining Well-Known Uniform Resource Identifiers (URIs)"'>RFC5785</a>] for "well-known locations" in the namespace of a
   host.  This enables discovery of policy or other information about a
   host ("site-wide metadata"), such as hosted resources (see
   <a href="#section-7">Section 7</a>).

   Application designers are encouraged to make use of short but
   descriptive URIs.  As the environments that CoAP is used in are
   usually constrained for bandwidth and energy, the trade-off between
   these two qualities should lean towards the shortness, without
   ignoring descriptiveness.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/6.2.%20%20coaps%20URI%20Scheme"></a><a class="selflink" href="#section-6.2" name="section-6.2">6.2</a>.  coaps URI Scheme</span>

   coaps-URI = "coaps:" "//" host [ ":" port ] path-abempty
               [ "?" query ]

   All of the requirements listed above for the "coap" scheme are also
   requirements for the "coaps" scheme, except that a default UDP port
   of 5684 is assumed if the port subcomponent is empty or not given,
   and the UDP datagrams MUST be secured through the use of DTLS as
   described in <a href="#section-9.1">Section 9.1</a>.

   Considerations for caching of responses to "coaps" identified
   requests are discussed in <a href="#section-11.2">Section 11.2</a>.

   Resources made available via the "coaps" scheme have no shared
   identity with the "coap" scheme even if their resource identifiers
   indicate the same authority (the same host listening to the same UDP
   port).  They are distinct namespaces and are considered to be
   distinct origin servers.






<span class="grey">Shelby, et al.               Standards Track                   [Page 60]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-61" id="page-61" name="page-61"> </a>
<span class="grey"><a href="rfc7252.html">RFC 7252</a>       The Constrained Application Protocol (CoAP)     June 2014</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/6.3.%20%20Normalization%20and%20Comparison%20Rules"></a><a class="selflink" href="#section-6.3" name="section-6.3">6.3</a>.  Normalization and Comparison Rules</span>

   Since the "coap" and "coaps" schemes conform to the URI generic
   syntax, such URIs are normalized and compared according to the
   algorithm defined in <a href="rfc3986.html#section-6">[RFC3986], Section 6</a>, using the defaults
   described above for each scheme.

   If the port is equal to the default port for a scheme, the normal
   form is to elide the port subcomponent.  Likewise, an empty path
   component is equivalent to an absolute path of "/", so the normal
   form is to provide a path of "/" instead.  The scheme and host are
   case insensitive and normally provided in lowercase; IP-literals are
   in recommended form [<a href="rfc5952.html" title='"A Recommendation for IPv6 Address Text Representation"'>RFC5952</a>]; all other components are compared in a
   case-sensitive manner.  Characters other than those in the "reserved"
   set are equivalent to their percent-encoded bytes (see <a href="rfc3986.html#section-2.1">[RFC3986],
   Section 2.1</a>): the normal form is to not encode them.

   For example, the following three URIs are equivalent and cause the
   same options and option values to appear in the CoAP messages:

   coap://example.com:5683/~sensors/temp.xml
   coap://EXAMPLE.com/%7Esensors/temp.xml
   coap://EXAMPLE.com:/%7esensors/temp.xml

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/6.4.%20%20Decomposing%20URIs%20into%20Options"></a><a class="selflink" href="#section-6.4" name="section-6.4">6.4</a>.  Decomposing URIs into Options</span>

   The steps to parse a request's options from a string |url| are as
   follows.  These steps either result in zero or more of the Uri-Host,
   Uri-Port, Uri-Path, and Uri-Query Options being included in the
   request or they fail.

   1.  If the |url| string is not an absolute URI ([<a href="rfc3986.html" title='"Uniform Resource Identifier (URI): Generic Syntax"'>RFC3986</a>]), then fail
       this algorithm.

   2.  Resolve the |url| string using the process of reference
       resolution defined by [<a href="rfc3986.html" title='"Uniform Resource Identifier (URI): Generic Syntax"'>RFC3986</a>].  At this stage, the URL is in
       ASCII encoding [<a href="https://tools.ietf.org/html/rfc0020" title='"ASCII format for network interchange"'>RFC0020</a>], even though the decoded components will
       be interpreted in UTF-8 [<a href="rfc3629.html" title='"UTF-8, a transformation format of ISO 10646"'>RFC3629</a>] after steps 5, 8, and 9.

       NOTE: It doesn't matter what it is resolved relative to, since we
       already know it is an absolute URL at this point.

   3.  If |url| does not have a &lt;scheme&gt; component whose value, when
       converted to ASCII lowercase, is "coap" or "coaps", then fail
       this algorithm.

   4.  If |url| has a &lt;fragment&gt; component, then fail this algorithm.




<span class="grey">Shelby, et al.               Standards Track                   [Page 61]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-62" id="page-62" name="page-62"> </a>
<span class="grey"><a href="rfc7252.html">RFC 7252</a>       The Constrained Application Protocol (CoAP)     June 2014</span>


   5.  If the &lt;host&gt; component of |url| does not represent the request's
       destination IP address as an IP-literal or IPv4address, include a
       Uri-Host Option and let that option's value be the value of the
       &lt;host&gt; component of |url|, converted to ASCII lowercase, and then
       convert all percent-encodings ("%" followed by two hexadecimal
       digits) to the corresponding characters.

       NOTE: In the usual case where the request's destination IP
       address is derived from the host part, this ensures that a Uri-
       Host Option is only used for a &lt;host&gt; component of the form reg-
       name.

   6.  If |url| has a &lt;port&gt; component, then let |port| be that
       component's value interpreted as a decimal integer; otherwise,
       let |port| be the default port for the scheme.

   7.  If |port| does not equal the request's destination UDP port,
       include a Uri-Port Option and let that option's value be |port|.

   8.  If the value of the &lt;path&gt; component of |url| is empty or
       consists of a single slash character (U+002F SOLIDUS "/"), then
       move to the next step.

       Otherwise, for each segment in the &lt;path&gt; component, include a
       Uri-Path Option and let that option's value be the segment (not
       including the delimiting slash characters) after converting each
       percent-encoding ("%" followed by two hexadecimal digits) to the
       corresponding byte.

   9.  If |url| has a &lt;query&gt; component, then, for each argument in the
       &lt;query&gt; component, include a Uri-Query Option and let that
       option's value be the argument (not including the question mark
       and the delimiting ampersand characters) after converting each
       percent-encoding to the corresponding byte.

   Note that these rules completely resolve any percent-encoding.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/6.5.%20%20Composing%20URIs%20from%20Options"></a><a class="selflink" href="#section-6.5" name="section-6.5">6.5</a>.  Composing URIs from Options</span>

   The steps to construct a URI from a request's options are as follows.
   These steps either result in a URI or they fail.  In these steps,
   percent-encoding a character means replacing each of its
   (UTF-8-encoded) bytes by a "%" character followed by two hexadecimal
   digits representing the byte, where the digits A-F are in uppercase
   (as defined in <a href="rfc3986.html#section-2.1">Section 2.1 of [RFC3986]</a>; to reduce variability, the
   hexadecimal notation for percent-encoding in CoAP URIs MUST use
   uppercase letters).  The definitions of "unreserved" and "sub-delims"
   are adopted from [<a href="rfc3986.html" title='"Uniform Resource Identifier (URI): Generic Syntax"'>RFC3986</a>].



<span class="grey">Shelby, et al.               Standards Track                   [Page 62]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-63" id="page-63" name="page-63"> </a>
<span class="grey"><a href="rfc7252.html">RFC 7252</a>       The Constrained Application Protocol (CoAP)     June 2014</span>


   1.   If the request is secured using DTLS, let |url| be the string
        "coaps://".  Otherwise, let |url| be the string "coap://".

   2.   If the request includes a Uri-Host Option, let |host| be that
        option's value, where any non-ASCII characters are replaced by
        their corresponding percent-encoding.  If |host| is not a valid
        reg-name or IP-literal or IPv4address, fail the algorithm.  If
        the request does not include a Uri-Host Option, let |host| be
        the IP-literal (making use of the conventions of [<a href="rfc5952.html" title='"A Recommendation for IPv6 Address Text Representation"'>RFC5952</a>]) or
        IPv4address representing the request's destination IP address.

   3.   Append |host| to |url|.

   4.   If the request includes a Uri-Port Option, let |port| be that
        option's value.  Otherwise, let |port| be the request's
        destination UDP port.

   5.   If |port| is not the default port for the scheme, then append a
        single U+003A COLON character (:) followed by the decimal
        representation of |port| to |url|.

   6.   Let |resource name| be the empty string.  For each Uri-Path
        Option in the request, append a single character U+002F SOLIDUS
        (/) followed by the option's value to |resource name|, after
        converting any character that is not either in the "unreserved"
        set, in the "sub-delims" set, a U+003A COLON (:) character, or a
        U+0040 COMMERCIAL AT (@) character to its percent-encoded form.

   7.   If |resource name| is the empty string, set it to a single
        character U+002F SOLIDUS (/).

   8.   For each Uri-Query Option in the request, append a single
        character U+003F QUESTION MARK (?) (first option) or U+0026
        AMPERSAND (&amp;) (subsequent options) followed by the option's
        value to |resource name|, after converting any character that is
        not either in the "unreserved" set, in the "sub-delims" set
        (except U+0026 AMPERSAND (&amp;)), a U+003A COLON (:), a U+0040
        COMMERCIAL AT (@), a U+002F SOLIDUS (/), or a U+003F QUESTION
        MARK (?) character to its percent-encoded form.

   9.   Append |resource name| to |url|.

   10.  Return |url|.

   Note that these steps have been designed to lead to a URI in normal
   form (see <a href="#section-6.3">Section 6.3</a>).





<span class="grey">Shelby, et al.               Standards Track                   [Page 63]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-64" id="page-64" name="page-64"> </a>
<span class="grey"><a href="rfc7252.html">RFC 7252</a>       The Constrained Application Protocol (CoAP)     June 2014</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/7.%20%20Discovery"></a><a class="selflink" href="#section-7" name="section-7">7</a>.  Discovery</span>

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/7.1.%20%20Service%20Discovery"></a><a class="selflink" href="#section-7.1" name="section-7.1">7.1</a>.  Service Discovery</span>

   As a part of discovering the services offered by a CoAP server, a
   client has to learn about the endpoint used by a server.

   A server is discovered by a client (knowing or) learning a URI that
   references a resource in the namespace of the server.  Alternatively,
   clients can use multicast CoAP (see <a href="#section-8">Section 8</a>) and the "All CoAP
   Nodes" multicast address to find CoAP servers.

   Unless the port subcomponent in a "coap" or "coaps" URI indicates the
   UDP port at which the CoAP server is located, the server is assumed
   to be reachable at the default port.

   The CoAP default port number 5683 MUST be supported by a server that
   offers resources for resource discovery (see <a href="#section-7.2">Section 7.2</a> below) and
   SHOULD be supported for providing access to other resources.  The
   default port number 5684 for DTLS-secured CoAP MAY be supported by a
   server for resource discovery and for providing access to other
   resources.  In addition, other endpoints may be hosted at other
   ports, e.g., in the dynamic port space.

   Implementation Note:  When a CoAP server is hosted by a 6LoWPAN node,
      header compression efficiency is improved when it also supports a
      port number in the 61616-61631 compressed UDP port space defined
      in [<a href="rfc4944.html" title='"Transmission of IPv6 Packets over IEEE 802.15.4 Networks"'>RFC4944</a>] and [<a href="rfc6282.html" title='"Compression Format for IPv6 Datagrams over IEEE 802.15.4-Based Networks"'>RFC6282</a>].  (Note that, as its UDP port differs
      from the default port, it is a different endpoint from the server
      at the default port.)

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/7.2.%20%20Resource%20Discovery"></a><a class="selflink" href="#section-7.2" name="section-7.2">7.2</a>.  Resource Discovery</span>

   The discovery of resources offered by a CoAP endpoint is extremely
   important in machine-to-machine applications where there are no
   humans in the loop and static interfaces result in fragility.  To
   maximize interoperability in a CoRE environment, a CoAP endpoint
   SHOULD support the CoRE Link Format of discoverable resources as
   described in [<a href="rfc6690.html" title='"Constrained RESTful Environments (CoRE) Link Format"'>RFC6690</a>], except where fully manual configuration is
   desired.  It is up to the server which resources are made
   discoverable (if any).

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/7.2.1.%20%20%27ct%27%20Attribute"></a><a class="selflink" href="#section-7.2.1" name="section-7.2.1">7.2.1</a>.  'ct' Attribute</span>

   This section defines a new Web Linking [<a href="rfc5988.html" title='"Web Linking"'>RFC5988</a>] attribute for use
   with [<a href="rfc6690.html" title='"Constrained RESTful Environments (CoRE) Link Format"'>RFC6690</a>].  The Content-Format code "ct" attribute provides a
   hint about the Content-Formats this resource returns.  Note that this
   is only a hint, and it does not override the Content-Format Option of



<span class="grey">Shelby, et al.               Standards Track                   [Page 64]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-65" id="page-65" name="page-65"> </a>
<span class="grey"><a href="rfc7252.html">RFC 7252</a>       The Constrained Application Protocol (CoAP)     June 2014</span>


   a CoAP response obtained by actually requesting the representation of
   the resource.  The value is in the CoAP identifier code format as a
   decimal ASCII integer and MUST be in the range of 0-65535 (16-bit
   unsigned integer).  For example, "application/xml" would be indicated
   as "ct=41".  If no Content-Format code attribute is present, then
   nothing about the type can be assumed.  The Content-Format code
   attribute MAY include a space-separated sequence of Content-Format
   codes, indicating that multiple content-formats are available.  The
   syntax of the attribute value is summarized in the production "ct-
   value" in Figure 12, where "cardinal", "SP", and "DQUOTE" are defined
   as in [<a href="rfc6690.html" title='"Constrained RESTful Environments (CoRE) Link Format"'>RFC6690</a>].

      ct-value =  cardinal
               /  DQUOTE cardinal *( 1*SP cardinal ) DQUOTE

                                 Figure 12

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/8.%20%20Multicast%20CoAP"></a><a class="selflink" href="#section-8" name="section-8">8</a>.  Multicast CoAP</span>

   CoAP supports making requests to an IP multicast group.  This is
   defined by a series of deltas to unicast CoAP.  A more general
   discussion of group communication with CoAP is in [<a href="#ref-GROUPCOMM">GROUPCOMM</a>].

   CoAP endpoints that offer services that they want other endpoints to
   be able to find using multicast service discovery join one or more of
   the appropriate all-CoAP-node multicast addresses (<a href="#section-12.8">Section 12.8</a>) and
   listen on the default CoAP port.  Note that an endpoint might receive
   multicast requests on other multicast addresses, including the all-
   nodes IPv6 address (or via broadcast on IPv4); an endpoint MUST
   therefore be prepared to receive such messages but MAY ignore them if
   multicast service discovery is not desired.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/8.1.%20%20Messaging%20Layer"></a><a class="selflink" href="#section-8.1" name="section-8.1">8.1</a>.  Messaging Layer</span>

   A multicast request is characterized by being transported in a CoAP
   message that is addressed to an IP multicast address instead of a
   CoAP endpoint.  Such multicast requests MUST be Non-confirmable.

   A server SHOULD be aware that a request arrived via multicast, e.g.,
   by making use of modern APIs such as IPV6_RECVPKTINFO [<a href="rfc3542.html" title='"Advanced Sockets Application Program Interface (API) for IPv6"'>RFC3542</a>], if
   available.

   To avoid an implosion of error responses, when a server is aware that
   a request arrived via multicast, it MUST NOT return a Reset message
   in reply to a Non-confirmable message.  If it is not aware, it MAY
   return a Reset message in reply to a Non-confirmable message as
   usual.  Because such a Reset message will look identical to one for a




<span class="grey">Shelby, et al.               Standards Track                   [Page 65]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-66" id="page-66" name="page-66"> </a>
<span class="grey"><a href="rfc7252.html">RFC 7252</a>       The Constrained Application Protocol (CoAP)     June 2014</span>


   unicast message from the sender, the sender MUST avoid using a
   Message ID that is also still active from this endpoint with any
   unicast endpoint that might receive the multicast message.

   At the time of writing, multicast messages can only be carried in UDP
   not in DTLS.  This means that the security modes defined for CoAP in
   this document are not applicable to multicast.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/8.2.%20%20Request%2FResponse%20Layer"></a><a class="selflink" href="#section-8.2" name="section-8.2">8.2</a>.  Request/Response Layer</span>

   When a server is aware that a request arrived via multicast, the
   server MAY always ignore the request, in particular if it doesn't
   have anything useful to respond (e.g., if it only has an empty
   payload or an error response).  The decision for this may depend on
   the application.  (For example, in query filtering as described in
   [<a href="rfc6690.html" title='"Constrained RESTful Environments (CoRE) Link Format"'>RFC6690</a>], a server should not respond to a multicast request if the
   filter does not match.  More examples are in [<a href="#ref-GROUPCOMM">GROUPCOMM</a>].)

   If a server does decide to respond to a multicast request, it should
   not respond immediately.  Instead, it should pick a duration for the
   period of time during which it intends to respond.  For the purposes
   of this exposition, we call the length of this period the Leisure.
   The specific value of this Leisure may depend on the application or
   MAY be derived as described below.  The server SHOULD then pick a
   random point of time within the chosen leisure period to send back
   the unicast response to the multicast request.  If further responses
   need to be sent based on the same multicast address membership, a new
   leisure period starts at the earliest after the previous one
   finishes.

   To compute a value for Leisure, the server should have a group size
   estimate G, a target data transfer rate R (which both should be
   chosen conservatively), and an estimated response size S; a rough
   lower bound for Leisure can then be computed as

                          lb_Leisure = S * G / R

   For example, for a multicast request with link-local scope on a 2.4
   GHz IEEE 802.15.4 (6LoWPAN) network, G could be (relatively
   conservatively) set to 100, S to 100 bytes, and the target rate to 8
   kbit/s = 1 kB/s.  The resulting lower bound for the Leisure is 10
   seconds.

   If a CoAP endpoint does not have suitable data to compute a value for
   Leisure, it MAY resort to DEFAULT_LEISURE.






<span class="grey">Shelby, et al.               Standards Track                   [Page 66]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-67" id="page-67" name="page-67"> </a>
<span class="grey"><a href="rfc7252.html">RFC 7252</a>       The Constrained Application Protocol (CoAP)     June 2014</span>


   When matching a response to a multicast request, only the token MUST
   match; the source endpoint of the response does not need to (and will
   not) be the same as the destination endpoint of the original request.

   For the purposes of interpreting the Location-* options and any links
   embedded in the representation, the request URI (i.e., the base URI
   relative to which the response is interpreted) is formed by replacing
   the multicast address in the Host component of the original request
   URI by the literal IP address of the endpoint actually responding.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/8.2.1.%20%20Caching"></a><a class="selflink" href="#section-8.2.1" name="section-8.2.1">8.2.1</a>.  Caching</span>

   When a client makes a multicast request, it always makes a new
   request to the multicast group (since there may be new group members
   that joined meanwhile or ones that did not get the previous request).
   It MAY update a cache with the received responses.  Then, it uses
   both cached-still-fresh and new responses as the result of the
   request.

   A response received in reply to a GET request to a multicast group
   MAY be used to satisfy a subsequent request on the related unicast
   request URI.  The unicast request URI is obtained by replacing the
   authority part of the request URI with the transport-layer source
   address of the response message.

   A cache MAY revalidate a response by making a GET request on the
   related unicast request URI.

   A GET request to a multicast group MUST NOT contain an ETag option.
   A mechanism to suppress responses the client already has is left for
   further study.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/8.2.2.%20%20Proxying"></a><a class="selflink" href="#section-8.2.2" name="section-8.2.2">8.2.2</a>.  Proxying</span>

   When a forward-proxy receives a request with a Proxy-Uri or URI
   constructed from Proxy-Scheme that indicates a multicast address, the
   proxy obtains a set of responses as described above and sends all
   responses (both cached-still-fresh and new) back to the original
   client.

   This specification does not provide a way to indicate the unicast-
   modified request URI (base URI) in responses thus forwarded.
   Proxying multicast requests is discussed in more detail in
   [<a href="#ref-GROUPCOMM">GROUPCOMM</a>]; one proposal to address the base URI issue can be found
   in Section 3 of [<a href="#ref-CoAP-MISC">CoAP-MISC</a>].






<span class="grey">Shelby, et al.               Standards Track                   [Page 67]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-68" id="page-68" name="page-68"> </a>
<span class="grey"><a href="rfc7252.html">RFC 7252</a>       The Constrained Application Protocol (CoAP)     June 2014</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/9.%20%20Securing%20CoAP"></a><a class="selflink" href="#section-9" name="section-9">9</a>.  Securing CoAP</span>

   This section defines the DTLS binding for CoAP.

   During the provisioning phase, a CoAP device is provided with the
   security information that it needs, including keying materials and
   access control lists.  This specification defines provisioning for
   the RawPublicKey mode in <a href="#section-9.1.3.2.1">Section 9.1.3.2.1</a>.  At the end of the
   provisioning phase, the device will be in one of four security modes
   with the following information for the given mode.  The NoSec and
   RawPublicKey modes are mandatory to implement for this specification.

   NoSec:  There is no protocol-level security (DTLS is disabled).
      Alternative techniques to provide lower-layer security SHOULD be
      used when appropriate.  The use of IPsec is discussed in
      [<a href="#ref-IPsec-CoAP">IPsec-CoAP</a>].  Certain link layers in use with constrained nodes
      also provide link-layer security, which may be appropriate with
      proper key management.

   PreSharedKey:  DTLS is enabled, there is a list of pre-shared keys
      [<a href="rfc4279.html" title='"Pre-Shared Key Ciphersuites for Transport Layer Security (TLS)"'>RFC4279</a>], and each key includes a list of which nodes it can be
      used to communicate with as described in <a href="#section-9.1.3.1">Section 9.1.3.1</a>.  At the
      extreme, there may be one key for each node this CoAP node needs
      to communicate with (1:1 node/key ratio).  Conversely, if more
      than two entities share a specific pre-shared key, this key only
      enables the entities to authenticate as a member of that group and
      not as a specific peer.

   RawPublicKey:  DTLS is enabled and the device has an asymmetric key
      pair without a certificate (a raw public key) that is validated
      using an out-of-band mechanism [<a href="rfc7250.html" title='"Using Raw Public Keys in Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS)"'>RFC7250</a>] as described in
      <a href="#section-9.1.3.2">Section 9.1.3.2</a>.  The device also has an identity calculated from
      the public key and a list of identities of the nodes it can
      communicate with.

   Certificate:  DTLS is enabled and the device has an asymmetric key
      pair with an X.509 certificate [<a href="rfc5280.html" title='"Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile"'>RFC5280</a>] that binds it to its
      subject and is signed by some common trust root as described in
      <a href="#section-9.1.3.3">Section 9.1.3.3</a>.  The device also has a list of root trust anchors
      that can be used for validating a certificate.

   In the "NoSec" mode, the system simply sends the packets over normal
   UDP over IP and is indicated by the "coap" scheme and the CoAP
   default port.  The system is secured only by keeping attackers from
   being able to send or receive packets from the network with the CoAP
   nodes; see <a href="#section-11.5">Section 11.5</a> for an additional complication with this
   approach.




<span class="grey">Shelby, et al.               Standards Track                   [Page 68]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-69" id="page-69" name="page-69"> </a>
<span class="grey"><a href="rfc7252.html">RFC 7252</a>       The Constrained Application Protocol (CoAP)     June 2014</span>


   The other three security modes are achieved using DTLS and are
   indicated by the "coaps" scheme and DTLS-secured CoAP default port.
   The result is a security association that can be used to authenticate
   (within the limits of the security model) and, based on this
   authentication, authorize the communication partner.  CoAP itself
   does not provide protocol primitives for authentication or
   authorization; where this is required, it can either be provided by
   communication security (i.e., IPsec or DTLS) or by object security
   (within the payload).  Devices that require authorization for certain
   operations are expected to require one of these two forms of
   security.  Necessarily, where an intermediary is involved,
   communication security only works when that intermediary is part of
   the trust relationships.  CoAP does not provide a way to forward
   different levels of authorization that clients may have with an
   intermediary to further intermediaries or origin servers -- it
   therefore may be required to perform all authorization at the first
   intermediary.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/9.1.%20%20DTLS-Secured%20CoAP"></a><a class="selflink" href="#section-9.1" name="section-9.1">9.1</a>.  DTLS-Secured CoAP</span>

   Just as HTTP is secured using Transport Layer Security (TLS) over
   TCP, CoAP is secured using Datagram TLS (DTLS) [<a href="rfc6347.html" title='"Datagram Transport Layer Security Version 1.2"'>RFC6347</a>] over UDP
   (see Figure 13).  This section defines the CoAP binding to DTLS,
   along with the minimal mandatory-to-implement configurations
   appropriate for constrained environments.  The binding is defined by
   a series of deltas to unicast CoAP.  In practice, DTLS is TLS with
   added features to deal with the unreliable nature of the UDP
   transport.

                         +----------------------+
                         |      Application     |
                         +----------------------+
                         +----------------------+
                         |  Requests/Responses  |
                         |----------------------|  CoAP
                         |       Messages       |
                         +----------------------+
                         +----------------------+
                         |         DTLS         |
                         +----------------------+
                         +----------------------+
                         |          UDP         |
                         +----------------------+

             Figure 13: Abstract Layering of DTLS-Secured CoAP






<span class="grey">Shelby, et al.               Standards Track                   [Page 69]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-70" id="page-70" name="page-70"> </a>
<span class="grey"><a href="rfc7252.html">RFC 7252</a>       The Constrained Application Protocol (CoAP)     June 2014</span>


   In some constrained nodes (limited flash and/or RAM) and networks
   (limited bandwidth or high scalability requirements), and depending
   on the specific cipher suites in use, all modes of DTLS may not be
   applicable.  Some DTLS cipher suites can add significant
   implementation complexity as well as some initial handshake overhead
   needed when setting up the security association.  Once the initial
   handshake is completed, DTLS adds a limited per-datagram overhead of
   approximately 13 bytes, not including any initialization vectors/
   nonces (e.g., 8 bytes with TLS_PSK_WITH_AES_128_CCM_8 [<a href="rfc6655.html" title='"AES-CCM Cipher Suites for Transport Layer Security (TLS)"'>RFC6655</a>]),
   integrity check values (e.g., 8 bytes with TLS_PSK_WITH_AES_128_CCM_8
   [<a href="rfc6655.html" title='"AES-CCM Cipher Suites for Transport Layer Security (TLS)"'>RFC6655</a>]), and padding required by the cipher suite.  Whether the
   use of a given mode of DTLS is applicable for a CoAP-based
   application should be carefully weighed considering the specific
   cipher suites that may be applicable, whether the session maintenance
   makes it compatible with application flows, and whether sufficient
   resources are available on the constrained nodes and for the added
   network overhead.  (For some modes of using DTLS, this specification
   identifies a mandatory-to-implement cipher suite.  This is an
   implementation requirement to maximize interoperability in those
   cases where these cipher suites are indeed appropriate.  The specific
   security policies of an application may determine the actual set of
   cipher suites that can be used.)  DTLS is not applicable to group
   keying (multicast communication); however, it may be a component in a
   future group key management protocol.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/9.1.1.%20%20Messaging%20Layer"></a><a class="selflink" href="#section-9.1.1" name="section-9.1.1">9.1.1</a>.  Messaging Layer</span>

   The endpoint acting as the CoAP client should also act as the DTLS
   client.  It should initiate a session to the server on the
   appropriate port.  When the DTLS handshake has finished, the client
   may initiate the first CoAP request.  All CoAP messages MUST be sent
   as DTLS "application data".

   The following rules are added for matching an Acknowledgement message
   or Reset message to a Confirmable message, or a Reset message to a
   Non-confirmable message: The DTLS session MUST be the same, and the
   epoch MUST be the same.

   A message is the same when it is sent within the same DTLS session
   and same epoch and has the same Message ID.

   Note: When a Confirmable message is retransmitted, a new DTLS
   sequence_number is used for each attempt, even though the CoAP
   Message ID stays the same.  So a recipient still has to perform
   deduplication as described in <a href="#section-4.5">Section 4.5</a>.  Retransmissions MUST NOT
   be performed across epochs.





<span class="grey">Shelby, et al.               Standards Track                   [Page 70]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-71" id="page-71" name="page-71"> </a>
<span class="grey"><a href="rfc7252.html">RFC 7252</a>       The Constrained Application Protocol (CoAP)     June 2014</span>


   DTLS connections in RawPublicKey and Certificate mode are set up
   using mutual authentication so they can remain up and be reused for
   future message exchanges in either direction.  Devices can close a
   DTLS connection when they need to recover resources, but in general
   they should keep the connection up for as long as possible.  Closing
   the DTLS connection after every CoAP message exchange is very
   inefficient.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/9.1.2.%20%20Request%2FResponse%20Layer"></a><a class="selflink" href="#section-9.1.2" name="section-9.1.2">9.1.2</a>.  Request/Response Layer</span>

   The following rules are added for matching a response to a request:
   The DTLS session MUST be the same, and the epoch MUST be the same.

   This means the response to a DTLS secured request MUST always be DTLS
   secured using the same security session and epoch.  Any attempt to
   supply a NoSec response to a DTLS request simply does not match the
   request and therefore MUST be rejected (unless it does match an
   unrelated NoSec request).

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/9.1.3.%20%20Endpoint%20Identity"></a><a class="selflink" href="#section-9.1.3" name="section-9.1.3">9.1.3</a>.  Endpoint Identity</span>

   Devices SHOULD support the Server Name Indication (SNI) to indicate
   their authority in the SNI HostName field as defined in <a href="rfc6066.html#section-3">Section 3 of
   [RFC6066]</a>.  This is needed so that when a host that acts as a virtual
   server for multiple Authorities receives a new DTLS connection, it
   knows which keys to use for the DTLS session.

<span class="h5"><a class="dashAnchor" name="//apple_ref/Section/9.1.3.1.%20%20Pre-Shared%20Keys"></a><a class="selflink" href="#section-9.1.3.1" name="section-9.1.3.1">9.1.3.1</a>.  Pre-Shared Keys</span>

   When forming a connection to a new node, the system selects an
   appropriate key based on which nodes it is trying to reach and then
   forms a DTLS session using a PSK (Pre-Shared Key) mode of DTLS.
   Implementations in these modes MUST support the mandatory-to-
   implement cipher suite TLS_PSK_WITH_AES_128_CCM_8 as specified in
   [<a href="rfc6655.html" title='"AES-CCM Cipher Suites for Transport Layer Security (TLS)"'>RFC6655</a>].

   Depending on the commissioning model, applications may need to define
   an application profile for identity hints (as required and detailed
   in <a href="rfc4279.html#section-5.2">Section 5.2 of [RFC4279]</a>) to enable the use of PSK identity hints.

   The security considerations of <a href="rfc4279.html#section-7">Section 7 of [RFC4279]</a> apply.  In
   particular, applications should carefully weigh whether or not they
   need Perfect Forward Secrecy (PFS) and select an appropriate cipher
   suite (<a href="rfc4279.html#section-7.1">Section 7.1 of [RFC4279]</a>).  The entropy of the PSK must be
   sufficient to mitigate against brute-force and (where the PSK is not
   chosen randomly but by a human) dictionary attacks (<a href="rfc4279.html#section-7.2">Section 7.2 of
   [RFC4279]</a>).  The cleartext communication of client identities may
   leak data or compromise privacy (<a href="rfc4279.html#section-7.3">Section 7.3 of [RFC4279]</a>).



<span class="grey">Shelby, et al.               Standards Track                   [Page 71]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-72" id="page-72" name="page-72"> </a>
<span class="grey"><a href="rfc7252.html">RFC 7252</a>       The Constrained Application Protocol (CoAP)     June 2014</span>


<span class="h5"><a class="dashAnchor" name="//apple_ref/Section/9.1.3.2.%20%20Raw%20Public%20Key%20Certificates"></a><a class="selflink" href="#section-9.1.3.2" name="section-9.1.3.2">9.1.3.2</a>.  Raw Public Key Certificates</span>

   In this mode, the device has an asymmetric key pair but without an
   X.509 certificate (called a raw public key); for example, the
   asymmetric key pair is generated by the manufacturer and installed on
   the device (see also <a href="#section-11.6">Section 11.6</a>).  A device MAY be configured with
   multiple raw public keys.  The type and length of the raw public key
   depends on the cipher suite used.  Implementations in RawPublicKey
   mode MUST support the mandatory-to-implement cipher suite
   TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8 as specified in [<a href="rfc7251.html" title='"AES- CCM Elliptic Curve Cryptography (ECC) Cipher Suites for Transport Layer Security (TLS)"'>RFC7251</a>],
   [<a href="rfc5246.html" title='"The Transport Layer Security (TLS) Protocol Version 1.2"'>RFC5246</a>], and [<a href="rfc4492.html" title='"Elliptic Curve Cryptography (ECC) Cipher Suites for Transport Layer Security (TLS)"'>RFC4492</a>].  The key used MUST be ECDSA capable.  The
   curve secp256r1 MUST be supported [<a href="rfc4492.html" title='"Elliptic Curve Cryptography (ECC) Cipher Suites for Transport Layer Security (TLS)"'>RFC4492</a>]; this curve is equivalent
   to the NIST P-256 curve.  The hash algorithm is SHA-256.
   Implementations MUST use the Supported Elliptic Curves and Supported
   Point Formats Extensions [<a href="rfc4492.html" title='"Elliptic Curve Cryptography (ECC) Cipher Suites for Transport Layer Security (TLS)"'>RFC4492</a>]; the uncompressed point format
   MUST be supported; [<a href="rfc6090.html" title='"Fundamental Elliptic Curve Cryptography Algorithms"'>RFC6090</a>] can be used as an implementation method.
   Some guidance relevant to the implementation of this cipher suite can
   be found in [<a href="#ref-W3CXMLSEC">W3CXMLSEC</a>].  The mechanism for using raw public keys
   with TLS is specified in [<a href="rfc7250.html" title='"Using Raw Public Keys in Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS)"'>RFC7250</a>].

   Implementation Note:  Specifically, this means the extensions listed
      in Figure 14 with at least the values listed will be present in
      the DTLS handshake.

   Extension: elliptic_curves
    Type: elliptic_curves (0x000a)
    Length: 4
    Elliptic Curves Length: 2
    Elliptic curves (1 curve)
      Elliptic curve: secp256r1 (0x0017)

   Extension: ec_point_formats
    Type: ec_point_formats (0x000b)
    Length: 2
    EC point formats Length: 1
    Elliptic curves point formats (1)
      EC point format: uncompressed (0)

   Extension: signature_algorithms
    Type: signature_algorithms (0x000d)
    Length: 4
    Data (4 bytes): 00 02 04 03
      HashAlgorithm: sha256 (4)
      SignatureAlgorithm: ecdsa (3)

                  Figure 14: DTLS Extensions Present for
                    TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8




<span class="grey">Shelby, et al.               Standards Track                   [Page 72]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-73" id="page-73" name="page-73"> </a>
<span class="grey"><a href="rfc7252.html">RFC 7252</a>       The Constrained Application Protocol (CoAP)     June 2014</span>


<span class="h6"><a class="dashAnchor" name="//apple_ref/Section/9.1.3.2.1.%20%20Provisioning"></a><a class="selflink" href="#section-9.1.3.2.1" name="section-9.1.3.2.1">9.1.3.2.1</a>.  Provisioning</span>

   The RawPublicKey mode was designed to be easily provisioned in M2M
   deployments.  It is assumed that each device has an appropriate
   asymmetric public key pair installed.  An identifier is calculated by
   the endpoint from the public key as described in <a href="rfc6920.html#section-2">Section 2 of
   [RFC6920]</a>.  All implementations that support checking RawPublicKey
   identities MUST support at least the sha-256-120 mode (SHA-256
   truncated to 120 bits).  Implementations SHOULD also support longer
   length identifiers and MAY support shorter lengths.  Note that the
   shorter lengths provide less security against attacks, and their use
   is NOT RECOMMENDED.

   Depending on how identifiers are given to the system that verifies
   them, support for URI, binary, and/or human-speakable format
   [<a href="rfc6920.html" title='"Naming Things with Hashes"'>RFC6920</a>] needs to be implemented.  All implementations SHOULD
   support the binary mode, and implementations that have a user
   interface SHOULD also support the human-speakable format.

   During provisioning, the identifier of each node is collected, for
   example, by reading a barcode on the outside of the device or by
   obtaining a pre-compiled list of the identifiers.  These identifiers
   are then installed in the corresponding endpoint, for example, an M2M
   data collection server.  The identifier is used for two purposes, to
   associate the endpoint with further device information and to perform
   access control.  During (initial and ongoing) provisioning, an access
   control list of identifiers with which the device may start DTLS
   sessions SHOULD also be installed and maintained.

<span class="h5"><a class="dashAnchor" name="//apple_ref/Section/9.1.3.3.%20%20X.509%20Certificates"></a><a class="selflink" href="#section-9.1.3.3" name="section-9.1.3.3">9.1.3.3</a>.  X.509 Certificates</span>

   Implementations in Certificate Mode MUST support the mandatory-to-
   implement cipher suite TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8 as
   specified in [<a href="rfc7251.html" title='"AES- CCM Elliptic Curve Cryptography (ECC) Cipher Suites for Transport Layer Security (TLS)"'>RFC7251</a>], [<a href="rfc5246.html" title='"The Transport Layer Security (TLS) Protocol Version 1.2"'>RFC5246</a>], and [<a href="rfc4492.html" title='"Elliptic Curve Cryptography (ECC) Cipher Suites for Transport Layer Security (TLS)"'>RFC4492</a>].  Namely, the
   certificate includes a SubjectPublicKeyInfo that indicates an
   algorithm of id-ecPublicKey with namedCurves secp256r1 [<a href="rfc5480.html" title='"Elliptic Curve Cryptography Subject Public Key Information"'>RFC5480</a>]; the
   public key format is uncompressed [<a href="rfc5480.html" title='"Elliptic Curve Cryptography Subject Public Key Information"'>RFC5480</a>]; the hash algorithm is
   SHA-256; if included, the key usage extension indicates
   digitalSignature.  Certificates MUST be signed with ECDSA using
   secp256r1, and the signature MUST use SHA-256.  The key used MUST be
   ECDSA capable.  The curve secp256r1 MUST be supported [<a href="rfc4492.html" title='"Elliptic Curve Cryptography (ECC) Cipher Suites for Transport Layer Security (TLS)"'>RFC4492</a>]; this
   curve is equivalent to the NIST P-256 curve.  The hash algorithm is
   SHA-256.  Implementations MUST use the Supported Elliptic Curves and
   Supported Point Formats Extensions [<a href="rfc4492.html" title='"Elliptic Curve Cryptography (ECC) Cipher Suites for Transport Layer Security (TLS)"'>RFC4492</a>]; the uncompressed point
   format MUST be supported; [<a href="rfc6090.html" title='"Fundamental Elliptic Curve Cryptography Algorithms"'>RFC6090</a>] can be used as an implementation
   method.





<span class="grey">Shelby, et al.               Standards Track                   [Page 73]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-74" id="page-74" name="page-74"> </a>
<span class="grey"><a href="rfc7252.html">RFC 7252</a>       The Constrained Application Protocol (CoAP)     June 2014</span>


   The subject in the certificate would be built out of a long-term
   unique identifier for the device such as the EUI-64 [<a href="#ref-EUI64" title='"Guidelines for 64-bit Global Identifier (EUI-64 (TM))"'>EUI64</a>].  The
   subject could also be based on the Fully Qualified Domain Name (FQDN)
   that was used as the Host part of the CoAP URI.  However, the
   device's IP address should not typically be used as the subject, as
   it would change over time.  The discovery process used in the system
   would build up the mapping between IP addresses of the given devices
   and the subject for each device.  Some devices could have more than
   one subject and would need more than a single certificate.

   When a new connection is formed, the certificate from the remote
   device needs to be verified.  If the CoAP node has a source of
   absolute time, then the node SHOULD check that the validity dates of
   the certificate are within range.  The certificate MUST be validated
   as appropriate for the security requirements, using functionality
   equivalent to the algorithm specified in <a href="rfc5280.html#section-6">Section 6 of [RFC5280]</a>.  If
   the certificate contains a SubjectAltName, then the authority of the
   request URI MUST match at least one of the authorities of any CoAP
   URI found in a field of URI type in the SubjectAltName set.  If there
   is no SubjectAltName in the certificate, then the authority of the
   request URI MUST match the Common Name (CN) found in the certificate
   using the matching rules defined in [<a href="rfc3280.html" title='"Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile"'>RFC3280</a>] with the exception that
   certificates with wildcards are not allowed.

   CoRE support for certificate status checking requires further study.
   As a mapping of the Online Certificate Status Protocol (OCSP)
   [<a href="rfc6960.html" title='"X.509 Internet Public Key Infrastructure Online Certificate Status Protocol - OCSP"'>RFC6960</a>] onto CoAP is not currently defined and OCSP may also not be
   easily applicable in all environments, an alternative approach may be
   using the TLS Certificate Status Request extension (<a href="rfc6066.html#section-8">Section 8 of
   [RFC6066]</a>; also known as "OCSP stapling") or preferably the Multiple
   Certificate Status Extension ([<a href="rfc6961.html" title='"The Transport Layer Security (TLS) Multiple Certificate Status Request Extension"'>RFC6961</a>]), if available.

   If the system has a shared key in addition to the certificate, then a
   cipher suite that includes the shared key such as
   TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA [<a href="rfc5489.html" title='"ECDHE_PSK Cipher Suites for Transport Layer Security (TLS)"'>RFC5489</a>] SHOULD be used.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/10.%20%20Cross-Protocol%20Proxying%20between%20CoAP%20and%20HTTP"></a><a class="selflink" href="#section-10" name="section-10">10</a>.  Cross-Protocol Proxying between CoAP and HTTP</span>

   CoAP supports a limited subset of HTTP functionality, and thus cross-
   protocol proxying to HTTP is straightforward.  There might be several
   reasons for proxying between CoAP and HTTP, for example, when
   designing a web interface for use over either protocol or when
   realizing a CoAP-HTTP proxy.  Likewise, CoAP could equally be proxied
   to other protocols such as XMPP [<a href="rfc6120.html" title='"Extensible Messaging and Presence Protocol (XMPP): Core"'>RFC6120</a>] or SIP [<a href="rfc3264.html" title='"An Offer/Answer Model with Session Description Protocol (SDP)"'>RFC3264</a>]; the
   definition of these mechanisms is out of scope for this
   specification.





<span class="grey">Shelby, et al.               Standards Track                   [Page 74]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-75" id="page-75" name="page-75"> </a>
<span class="grey"><a href="rfc7252.html">RFC 7252</a>       The Constrained Application Protocol (CoAP)     June 2014</span>


   There are two possible directions to access a resource via a forward-
   proxy:

   CoAP-HTTP Proxying:  Enables CoAP clients to access resources on HTTP
      servers through an intermediary.  This is initiated by including
      the Proxy-Uri or Proxy-Scheme Option with an "http" or "https" URI
      in a CoAP request to a CoAP-HTTP proxy.

   HTTP-CoAP Proxying:  Enables HTTP clients to access resources on CoAP
      servers through an intermediary.  This is initiated by specifying
      a "coap" or "coaps" URI in the Request-Line of an HTTP request to
      an HTTP-CoAP proxy.

   Either way, only the request/response model of CoAP is mapped to
   HTTP.  The underlying model of Confirmable or Non-confirmable
   messages, etc., is invisible and MUST have no effect on a proxy
   function.  The following sections describe the handling of requests
   to a forward-proxy.  Reverse-proxies are not specified, as the proxy
   function is transparent to the client with the proxy acting as if it
   were the origin server.  However, similar considerations apply to
   reverse-proxies as to forward-proxies, and there generally will be an
   expectation that reverse-proxies operate in a similar way forward-
   proxies would.  As an implementation note, HTTP client libraries may
   make it hard to operate an HTTP-CoAP forward-proxy by not providing a
   way to put a CoAP URI on the HTTP Request-Line; reverse-proxying may
   therefore lead to wider applicability of a proxy.  A separate
   specification may define a convention for URIs operating such an
   HTTP-CoAP reverse-proxy [<a href="#ref-MAPPING" title='"Guidelines for HTTP-CoAP Mapping Implementations"'>MAPPING</a>].

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/10.1.%20%20CoAP-HTTP%20Proxying"></a><a class="selflink" href="#section-10.1" name="section-10.1">10.1</a>.  CoAP-HTTP Proxying</span>

   If a request contains a Proxy-Uri or Proxy-Scheme Option with an
   'http' or 'https' URI [<a href="rfc2616.html" title='"Hypertext Transfer Protocol -- HTTP/1.1"'>RFC2616</a>], then the receiving CoAP endpoint
   (called "the proxy" henceforth) is requested to perform the operation
   specified by the request method on the indicated HTTP resource and
   return the result to the client.  (See also <a href="#section-5.7">Section 5.7</a> for how the
   request to the proxy is formulated, including security requirements.)

   This section specifies for any CoAP request the CoAP response that
   the proxy should return to the client.  How the proxy actually
   satisfies the request is an implementation detail, although the
   typical case is expected to be that the proxy translates and forwards
   the request to an HTTP origin server.








<span class="grey">Shelby, et al.               Standards Track                   [Page 75]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-76" id="page-76" name="page-76"> </a>
<span class="grey"><a href="rfc7252.html">RFC 7252</a>       The Constrained Application Protocol (CoAP)     June 2014</span>


   Since HTTP and CoAP share the basic set of request methods,
   performing a CoAP request on an HTTP resource is not so different
   from performing it on a CoAP resource.  The meanings of the
   individual CoAP methods when performed on HTTP resources are
   explained in the subsections of this section.

   If the proxy is unable or unwilling to service a request with an HTTP
   URI, a 5.05 (Proxying Not Supported) response is returned to the
   client.  If the proxy services the request by interacting with a
   third party (such as the HTTP origin server) and is unable to obtain
   a result within a reasonable time frame, a 5.04 (Gateway Timeout)
   response is returned; if a result can be obtained but is not
   understood, a 5.02 (Bad Gateway) response is returned.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/10.1.1.%20%20GET"></a><a class="selflink" href="#section-10.1.1" name="section-10.1.1">10.1.1</a>.  GET</span>

   The GET method requests the proxy to return a representation of the
   HTTP resource identified by the request URI.

   Upon success, a 2.05 (Content) Response Code SHOULD be returned.  The
   payload of the response MUST be a representation of the target HTTP
   resource, and the Content-Format Option MUST be set accordingly.  The
   response MUST indicate a Max-Age value that is no greater than the
   remaining time the representation can be considered fresh.  If the
   HTTP entity has an entity-tag, the proxy SHOULD include an ETag
   Option in the response and process ETag Options in requests as
   described below.

   A client can influence the processing of a GET request by including
   the following option:

   Accept:  The request MAY include an Accept Option, identifying the
      preferred response content-format.

   ETag:  The request MAY include one or more ETag Options, identifying
      responses that the client has stored.  This requests the proxy to
      send a 2.03 (Valid) response whenever it would send a 2.05
      (Content) response with an entity-tag in the requested set
      otherwise.  Note that CoAP ETags are always strong ETags in the
      HTTP sense; CoAP does not have the equivalent of HTTP weak ETags,
      and there is no good way to make use of these in a cross-proxy.










<span class="grey">Shelby, et al.               Standards Track                   [Page 76]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-77" id="page-77" name="page-77"> </a>
<span class="grey"><a href="rfc7252.html">RFC 7252</a>       The Constrained Application Protocol (CoAP)     June 2014</span>


<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/10.1.2.%20%20PUT"></a><a class="selflink" href="#section-10.1.2" name="section-10.1.2">10.1.2</a>.  PUT</span>

   The PUT method requests the proxy to update or create the HTTP
   resource identified by the request URI with the enclosed
   representation.

   If a new resource is created at the request URI, a 2.01 (Created)
   response MUST be returned to the client.  If an existing resource is
   modified, a 2.04 (Changed) response MUST be returned to indicate
   successful completion of the request.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/10.1.3.%20%20DELETE"></a><a class="selflink" href="#section-10.1.3" name="section-10.1.3">10.1.3</a>.  DELETE</span>

   The DELETE method requests the proxy to delete the HTTP resource
   identified by the request URI at the HTTP origin server.

   A 2.02 (Deleted) response MUST be returned to the client upon success
   or if the resource does not exist at the time of the request.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/10.1.4.%20%20POST"></a><a class="selflink" href="#section-10.1.4" name="section-10.1.4">10.1.4</a>.  POST</span>

   The POST method requests the proxy to have the representation
   enclosed in the request be processed by the HTTP origin server.  The
   actual function performed by the POST method is determined by the
   origin server and dependent on the resource identified by the request
   URI.

   If the action performed by the POST method does not result in a
   resource that can be identified by a URI, a 2.04 (Changed) response
   MUST be returned to the client.  If a resource has been created on
   the origin server, a 2.01 (Created) response MUST be returned.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/10.2.%20%20HTTP-CoAP%20Proxying"></a><a class="selflink" href="#section-10.2" name="section-10.2">10.2</a>.  HTTP-CoAP Proxying</span>

   If an HTTP request contains a Request-URI with a "coap" or "coaps"
   URI, then the receiving HTTP endpoint (called "the proxy" henceforth)
   is requested to perform the operation specified by the request method
   on the indicated CoAP resource and return the result to the client.

   This section specifies for any HTTP request the HTTP response that
   the proxy should return to the client.  Unless otherwise specified,
   all the statements made are RECOMMENDED behavior; some highly
   constrained implementations may need to resort to shortcuts.  How the
   proxy actually satisfies the request is an implementation detail,
   although the typical case is expected to be that the proxy translates
   and forwards the request to a CoAP origin server.  The meanings of
   the individual HTTP methods when performed on CoAP resources are
   explained in the subsections of this section.



<span class="grey">Shelby, et al.               Standards Track                   [Page 77]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-78" id="page-78" name="page-78"> </a>
<span class="grey"><a href="rfc7252.html">RFC 7252</a>       The Constrained Application Protocol (CoAP)     June 2014</span>


   If the proxy is unable or unwilling to service a request with a CoAP
   URI, a 501 (Not Implemented) response is returned to the client.  If
   the proxy services the request by interacting with a third party
   (such as the CoAP origin server) and is unable to obtain a result
   within a reasonable time frame, a 504 (Gateway Timeout) response is
   returned; if a result can be obtained but is not understood, a 502
   (Bad Gateway) response is returned.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/10.2.1.%20%20OPTIONS%20and%20TRACE"></a><a class="selflink" href="#section-10.2.1" name="section-10.2.1">10.2.1</a>.  OPTIONS and TRACE</span>

   As the OPTIONS and TRACE methods are not supported in CoAP, a 501
   (Not Implemented) error MUST be returned to the client.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/10.2.2.%20%20GET"></a><a class="selflink" href="#section-10.2.2" name="section-10.2.2">10.2.2</a>.  GET</span>

   The GET method requests the proxy to return a representation of the
   CoAP resource identified by the Request-URI.

   Upon success, a 200 (OK) response is returned.  The payload of the
   response MUST be a representation of the target CoAP resource, and
   the Content-Type and Content-Encoding header fields MUST be set
   accordingly.  The response MUST indicate a max-age directive that
   indicates a value no greater than the remaining time the
   representation can be considered fresh.  If the CoAP response has an
   ETag option, the proxy should include an ETag header field in the
   response.

   A client can influence the processing of a GET request by including
   the following options:

   Accept:  The most-preferred media type of the HTTP Accept header
      field in a request is mapped to a CoAP Accept option.  HTTP Accept
      media-type ranges, parameters, and extensions are not supported by
      the CoAP Accept option.  If the proxy cannot send a response that
      is acceptable according to the combined Accept field value, then
      the proxy sends a 406 (Not Acceptable) response.  The proxy MAY
      then retry the request with further media types from the HTTP
      Accept header field.

   Conditional GETs:  Conditional HTTP GET requests that include an "If-
      Match" or "If-None-Match" request-header field can be mapped to a
      corresponding CoAP request.  The "If-Modified-Since" and "If-
      Unmodified-Since" request-header fields are not directly supported
      by CoAP but are implemented locally by a caching proxy.







<span class="grey">Shelby, et al.               Standards Track                   [Page 78]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-79" id="page-79" name="page-79"> </a>
<span class="grey"><a href="rfc7252.html">RFC 7252</a>       The Constrained Application Protocol (CoAP)     June 2014</span>


<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/10.2.3.%20%20HEAD"></a><a class="selflink" href="#section-10.2.3" name="section-10.2.3">10.2.3</a>.  HEAD</span>

   The HEAD method is identical to GET except that the server MUST NOT
   return a message-body in the response.

   Although there is no direct equivalent of HTTP's HEAD method in CoAP,
   an HTTP-CoAP proxy responds to HEAD requests for CoAP resources, and
   the HTTP headers are returned without a message-body.

   Implementation Note:  An HTTP-CoAP proxy may want to try using a
      block-wise transfer option [<a href="#ref-BLOCK" title='"Blockwise transfers in CoAP"'>BLOCK</a>] to minimize the amount of data
      actually transferred, but it needs to be prepared for the case
      that the origin server does not support block-wise transfers.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/10.2.4.%20%20POST"></a><a class="selflink" href="#section-10.2.4" name="section-10.2.4">10.2.4</a>.  POST</span>

   The POST method requests the proxy to have the representation
   enclosed in the request be processed by the CoAP origin server.  The
   actual function performed by the POST method is determined by the
   origin server and dependent on the resource identified by the request
   URI.

   If the action performed by the POST method does not result in a
   resource that can be identified by a URI, a 200 (OK) or 204 (No
   Content) response MUST be returned to the client.  If a resource has
   been created on the origin server, a 201 (Created) response MUST be
   returned.

   If any of the Location-* Options are present in the CoAP response, a
   Location header field constructed from the values of these options is
   returned.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/10.2.5.%20%20PUT"></a><a class="selflink" href="#section-10.2.5" name="section-10.2.5">10.2.5</a>.  PUT</span>

   The PUT method requests the proxy to update or create the CoAP
   resource identified by the Request-URI with the enclosed
   representation.

   If a new resource is created at the Request-URI, a 201 (Created)
   response is returned to the client.  If an existing resource is
   modified, either the 200 (OK) or 204 (No Content) Response Codes is
   sent to indicate successful completion of the request.









<span class="grey">Shelby, et al.               Standards Track                   [Page 79]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-80" id="page-80" name="page-80"> </a>
<span class="grey"><a href="rfc7252.html">RFC 7252</a>       The Constrained Application Protocol (CoAP)     June 2014</span>


<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/10.2.6.%20%20DELETE"></a><a class="selflink" href="#section-10.2.6" name="section-10.2.6">10.2.6</a>.  DELETE</span>

   The DELETE method requests the proxy to delete the CoAP resource
   identified by the Request-URI at the CoAP origin server.

   A successful response is 200 (OK) if the response includes an entity
   describing the status or 204 (No Content) if the action has been
   enacted but the response does not include an entity.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/10.2.7.%20%20CONNECT"></a><a class="selflink" href="#section-10.2.7" name="section-10.2.7">10.2.7</a>.  CONNECT</span>

   This method cannot currently be satisfied by an HTTP-CoAP proxy
   function, as TLS to DTLS tunneling has not yet been specified.  For
   now, a 501 (Not Implemented) error is returned to the client.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/11.%20%20Security%20Considerations"></a><a class="selflink" href="#section-11" name="section-11">11</a>.  Security Considerations</span>

   This section analyzes the possible threats to the protocol.  It is
   meant to inform protocol and application developers about the
   security limitations of CoAP as described in this document.  As CoAP
   realizes a subset of the features in HTTP/1.1, the security
   considerations in <a href="rfc2616.html#section-15">Section 15 of [RFC2616]</a> are also pertinent to CoAP.
   This section concentrates on describing limitations specific to CoAP.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/11.1.%20%20Parsing%20the%20Protocol%20and%20Processing%20URIs"></a><a class="selflink" href="#section-11.1" name="section-11.1">11.1</a>.  Parsing the Protocol and Processing URIs</span>

   A network-facing application can exhibit vulnerabilities in its
   processing logic for incoming packets.  Complex parsers are well-
   known as a likely source of such vulnerabilities, such as the ability
   to remotely crash a node, or even remotely execute arbitrary code on
   it.  CoAP attempts to narrow the opportunities for introducing such
   vulnerabilities by reducing parser complexity, by giving the entire
   range of encodable values a meaning where possible, and by
   aggressively reducing complexity that is often caused by unnecessary
   choice between multiple representations that mean the same thing.
   Much of the URI processing has been moved to the clients, further
   reducing the opportunities for introducing vulnerabilities into the
   servers.  Even so, the URI processing code in CoAP implementations is
   likely to be a large source of remaining vulnerabilities and should
   be implemented with special care.  CoAP access control
   implementations need to ensure they don't introduce vulnerabilities
   through discrepancies between the code deriving access control
   decisions from a URI and the code finally serving up the resource
   addressed by the URI.  The most complex parser remaining could be the
   one for the CoRE Link Format, although this also has been designed
   with a goal of reduced implementation complexity [<a href="rfc6690.html" title='"Constrained RESTful Environments (CoRE) Link Format"'>RFC6690</a>].  (See
   also <a href="rfc2616.html#section-15.2">Section 15.2 of [RFC2616]</a>.)




<span class="grey">Shelby, et al.               Standards Track                   [Page 80]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-81" id="page-81" name="page-81"> </a>
<span class="grey"><a href="rfc7252.html">RFC 7252</a>       The Constrained Application Protocol (CoAP)     June 2014</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/11.2.%20%20Proxying%20and%20Caching"></a><a class="selflink" href="#section-11.2" name="section-11.2">11.2</a>.  Proxying and Caching</span>

   As mentioned in <a href="rfc2616.html#section-15.7">Section 15.7 of [RFC2616]</a>, proxies are by their very
   nature men-in-the-middle, breaking any IPsec or DTLS protection that
   a direct CoAP message exchange might have.  They are therefore
   interesting targets for breaking confidentiality or integrity of CoAP
   message exchanges.  As noted in [<a href="rfc2616.html" title='"Hypertext Transfer Protocol -- HTTP/1.1"'>RFC2616</a>], they are also interesting
   targets for breaking availability.

   The threat to confidentiality and integrity of request/response data
   is amplified where proxies also cache.  Note that CoAP does not
   define any of the cache-suppressing Cache-Control options that
   HTTP/1.1 provides to better protect sensitive data.

   For a caching implementation, any access control considerations that
   would apply to making the request that generated the cache entry also
   need to be applied to the value in the cache.  This is relevant for
   clients that implement multiple security domains, as well as for
   proxies that may serve multiple clients.  Also, a caching proxy MUST
   NOT make cached values available to requests that have lesser
   transport-security properties than those the proxy would require to
   perform request forwarding in the first place.

   Unlike the "coap" scheme, responses to "coaps" identified requests
   are never "public" and thus MUST NOT be reused for shared caching,
   unless the cache is able to make equivalent access control decisions
   to the ones that led to the cached entry.  They can, however, be
   reused in a private cache if the message is cacheable by default in
   CoAP.

   Finally, a proxy that fans out Separate Responses (as opposed to
   piggybacked Responses) to multiple original requesters may provide
   additional amplification (see <a href="#section-11.3">Section 11.3</a>).

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/11.3.%20%20Risk%20of%20Amplification"></a><a class="selflink" href="#section-11.3" name="section-11.3">11.3</a>.  Risk of Amplification</span>

   CoAP servers generally reply to a request packet with a response
   packet.  This response packet may be significantly larger than the
   request packet.  An attacker might use CoAP nodes to turn a small
   attack packet into a larger attack packet, an approach known as
   amplification.  There is therefore a danger that CoAP nodes could
   become implicated in denial-of-service (DoS) attacks by using the
   amplifying properties of the protocol: an attacker that is attempting
   to overload a victim but is limited in the amount of traffic it can
   generate can use amplification to generate a larger amount of
   traffic.





<span class="grey">Shelby, et al.               Standards Track                   [Page 81]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-82" id="page-82" name="page-82"> </a>
<span class="grey"><a href="rfc7252.html">RFC 7252</a>       The Constrained Application Protocol (CoAP)     June 2014</span>


   This is particularly a problem in nodes that enable NoSec access, are
   accessible from an attacker, and can access potential victims (e.g.,
   on the general Internet), as the UDP protocol provides no way to
   verify the source address given in the request packet.  An attacker
   need only place the IP address of the victim in the source address of
   a suitable request packet to generate a larger packet directed at the
   victim.

   As a mitigating factor, many constrained networks will only be able
   to generate a small amount of traffic, which may make CoAP nodes less
   attractive for this attack.  However, the limited capacity of the
   constrained network makes the network itself a likely victim of an
   amplification attack.

   Therefore, large amplification factors SHOULD NOT be provided in the
   response if the request is not authenticated.  A CoAP server can
   reduce the amount of amplification it provides to an attacker by
   using slicing/blocking modes of CoAP [<a href="#ref-BLOCK" title='"Blockwise transfers in CoAP"'>BLOCK</a>] and offering large
   resource representations only in relatively small slices.  For
   example, for a 1000-byte resource, a 10-byte request might result in
   an 80-byte response (with a 64-byte block) instead of a 1016-byte
   response, considerably reducing the amplification provided.

   CoAP also supports the use of multicast IP addresses in requests, an
   important requirement for M2M.  Multicast CoAP requests may be the
   source of accidental or deliberate DoS attacks, especially over
   constrained networks.  This specification attempts to reduce the
   amplification effects of multicast requests by limiting when a
   response is returned.  To limit the possibility of malicious use,
   CoAP servers SHOULD NOT accept multicast requests that can not be
   authenticated in some way, cryptographically or by some multicast
   boundary limiting the potential sources.  If possible, a CoAP server
   SHOULD limit the support for multicast requests to the specific
   resources where the feature is required.

   On some general-purpose operating systems providing a POSIX-style API
   [<a href="#ref-IEEE1003.1">IEEE1003.1</a>], it is not straightforward to find out whether a packet
   received was addressed to a multicast address.  While many
   implementations will know whether they have joined a multicast group,
   this creates a problem for packets addressed to multicast addresses
   of the form FF0x::1, which are received by every IPv6 node.
   Implementations SHOULD make use of modern APIs such as
   IPV6_RECVPKTINFO [<a href="rfc3542.html" title='"Advanced Sockets Application Program Interface (API) for IPv6"'>RFC3542</a>], if available, to make this determination.








<span class="grey">Shelby, et al.               Standards Track                   [Page 82]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-83" id="page-83" name="page-83"> </a>
<span class="grey"><a href="rfc7252.html">RFC 7252</a>       The Constrained Application Protocol (CoAP)     June 2014</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/11.4.%20%20IP%20Address%20Spoofing%20Attacks"></a><a class="selflink" href="#section-11.4" name="section-11.4">11.4</a>.  IP Address Spoofing Attacks</span>

   Due to the lack of a handshake in UDP, a rogue endpoint that is free
   to read and write messages carried by the constrained network (i.e.,
   NoSec or PreSharedKey deployments with a nodes/key ratio &gt; 1:1), may
   easily attack a single endpoint, a group of endpoints, as well as the
   whole network, e.g., by:

   1.  spoofing a Reset message in response to a Confirmable message or
       Non-confirmable message, thus making an endpoint "deaf"; or

   2.  spoofing an ACK in response to a CON message, thus potentially
       preventing the sender of the CON message from retransmitting, and
       drowning out the actual response; or

   3.  spoofing the entire response with forged payload/options (this
       has different levels of impact: from single-response disruption,
       to much bolder attacks on the supporting infrastructure, e.g.,
       poisoning proxy caches, or tricking validation/lookup interfaces
       in resource directories and, more generally, any component that
       stores global network state and uses CoAP as the messaging
       facility to handle setting or updating state is a potential
       target.); or

   4.  spoofing a multicast request for a target node; this may result
       in network congestion/collapse, a DoS attack on the victim, or
       forced wake-up from sleeping; or

   5.  spoofing observe messages, etc.

   Response spoofing by off-path attackers can be detected and mitigated
   even without transport layer security by choosing a nontrivial,
   randomized token in the request (<a href="#section-5.3.1">Section 5.3.1</a>).  [<a href="rfc4086.html" title='"Randomness Requirements for Security"'>RFC4086</a>] discusses
   randomness requirements for security.

   In principle, other kinds of spoofing can be detected by CoAP only in
   case Confirmable message semantics is used, because of unexpected
   Acknowledgement or Reset messages coming from the deceived endpoint.
   But this imposes keeping track of the used Message IDs, which is not
   always possible, and moreover detection becomes available usually
   after the damage is already done.  This kind of attack can be
   prevented using security modes other than NoSec.

   With or without source address spoofing, a client can attempt to
   overload a server by sending requests, preferably complex ones, to a
   server; address spoofing makes tracing back, and blocking, this
   attack harder.  Given that the cost of a CON request is small, this
   attack can easily be executed.  Under this attack, a constrained node



<span class="grey">Shelby, et al.               Standards Track                   [Page 83]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-84" id="page-84" name="page-84"> </a>
<span class="grey"><a href="rfc7252.html">RFC 7252</a>       The Constrained Application Protocol (CoAP)     June 2014</span>


   with limited total energy available may exhaust that energy much more
   quickly than planned (battery depletion attack).  Also, if the client
   uses a Confirmable message and the server responds with a Confirmable
   separate response to a (possibly spoofed) address that does not
   respond, the server will have to allocate buffer and retransmission
   logic for each response up to the exhaustion of MAX_TRANSMIT_SPAN,
   making it more likely that it runs out of resources for processing
   legitimate traffic.  The latter problem can be mitigated somewhat by
   limiting the rate of responses as discussed in <a href="#section-4.7">Section 4.7</a>.  An
   attacker could also spoof the address of a legitimate client; this
   might cause the server, if it uses separate responses, to block
   legitimate responses to that client because of NSTART=1.  All these
   attacks can be prevented using a security mode other than NoSec, thus
   leaving only attacks on the security protocol.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/11.5.%20%20Cross-Protocol%20Attacks"></a><a class="selflink" href="#section-11.5" name="section-11.5">11.5</a>.  Cross-Protocol Attacks</span>

   The ability to incite a CoAP endpoint to send packets to a fake
   source address can be used not only for amplification, but also for
   cross-protocol attacks against a victim listening to UDP packets at a
   given address (IP address and port).  This would occur as follows:

   o  The attacker sends a message to a CoAP endpoint with the given
      address as the fake source address.

   o  The CoAP endpoint replies with a message to the given source
      address.

   o  The victim at the given address receives a UDP packet that it
      interprets according to the rules of a different protocol.

   This may be used to circumvent firewall rules that prevent direct
   communication from the attacker to the victim but happen to allow
   communication from the CoAP endpoint (which may also host a valid
   role in the other protocol) to the victim.

   Also, CoAP endpoints may be the victim of a cross-protocol attack
   generated through an endpoint of another UDP-based protocol such as
   DNS.  In both cases, attacks are possible if the security properties
   of the endpoints rely on checking IP addresses (and firewalling off
   direct attacks sent from outside using fake IP addresses).  In
   general, because of their lack of context, UDP-based protocols are
   relatively easy targets for cross-protocol attacks.

   Finally, CoAP URIs transported by other means could be used to incite
   clients to send messages to endpoints of other protocols.





<span class="grey">Shelby, et al.               Standards Track                   [Page 84]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-85" id="page-85" name="page-85"> </a>
<span class="grey"><a href="rfc7252.html">RFC 7252</a>       The Constrained Application Protocol (CoAP)     June 2014</span>


   One mitigation against cross-protocol attacks is strict checking of
   the syntax of packets received, combined with sufficient difference
   in syntax.  As an example, it might help if it were difficult to
   incite a DNS server to send a DNS response that would pass the checks
   of a CoAP endpoint.  Unfortunately, the first two bytes of a DNS
   reply are an ID that can be chosen by the attacker and that map into
   the interesting part of the CoAP header, and the next two bytes are
   then interpreted as CoAP's Message ID (i.e., any value is
   acceptable).  The DNS count words may be interpreted as multiple
   instances of a (nonexistent but elective) CoAP option 0, or possibly
   as a Token.  The echoed query finally may be manufactured by the
   attacker to achieve a desired effect on the CoAP endpoint; the
   response added by the server (if any) might then just be interpreted
   as added payload.

                                   1  1  1  1  1  1
     0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5
   +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
   |                      ID                       | T, TKL, code
   +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
   |QR|   Opcode  |AA|TC|RD|RA|   Z    |   RCODE   | Message ID
   +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
   |                    QDCOUNT                    | (options 0)
   +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
   |                    ANCOUNT                    | (options 0)
   +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
   |                    NSCOUNT                    | (options 0)
   +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
   |                    ARCOUNT                    | (options 0)
   +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+

     Figure 15: DNS Header (<a href="rfc1035.html#section-4.1.1">[RFC1035], Section 4.1.1</a>) vs. CoAP Message

   In general, for any pair of protocols, one of the protocols can very
   well have been designed in a way that enables an attacker to cause
   the generation of replies that look like messages of the other
   protocol.  It is often much harder to ensure or prove the absence of
   viable attacks than to generate examples that may not yet completely
   enable an attack but might be further developed by more creative
   minds.  Cross-protocol attacks can therefore only be completely
   mitigated if endpoints don't authorize actions desired by an attacker
   just based on trusting the source IP address of a packet.
   Conversely, a NoSec environment that completely relies on a firewall
   for CoAP security not only needs to firewall off the CoAP endpoints
   but also all other endpoints that might be incited to send UDP
   messages to CoAP endpoints using some other UDP-based protocol.





<span class="grey">Shelby, et al.               Standards Track                   [Page 85]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-86" id="page-86" name="page-86"> </a>
<span class="grey"><a href="rfc7252.html">RFC 7252</a>       The Constrained Application Protocol (CoAP)     June 2014</span>


   In addition to the considerations above, the security considerations
   for DTLS with respect to cross-protocol attacks apply.  For example,
   if the same DTLS security association ("connection") is used to carry
   data of multiple protocols, DTLS no longer provides protection
   against cross-protocol attacks between these protocols.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/11.6.%20%20Constrained-Node%20Considerations"></a><a class="selflink" href="#section-11.6" name="section-11.6">11.6</a>.  Constrained-Node Considerations</span>

   Implementers on constrained nodes often find themselves without a
   good source of entropy [<a href="rfc4086.html" title='"Randomness Requirements for Security"'>RFC4086</a>].  If that is the case, the node MUST
   NOT be used for processes that require good entropy, such as key
   generation.  Instead, keys should be generated externally and added
   to the device during manufacturing or commissioning.

   Due to their low processing power, constrained nodes are particularly
   susceptible to timing attacks.  Special care must be taken in
   implementation of cryptographic primitives.

   Large numbers of constrained nodes will be installed in exposed
   environments and will have little resistance to tampering, including
   recovery of keying materials.  This needs to be considered when
   defining the scope of credentials assigned to them.  In particular,
   assigning a shared key to a group of nodes may make any single
   constrained node a target for subverting the entire group.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/12.%20%20IANA%20Considerations"></a><a class="selflink" href="#section-12" name="section-12">12</a>.  IANA Considerations</span>

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/12.1.%20%20CoAP%20Code%20Registries"></a><a class="selflink" href="#section-12.1" name="section-12.1">12.1</a>.  CoAP Code Registries</span>

   This document defines two sub-registries for the values of the Code
   field in the CoAP header within the "Constrained RESTful Environments
   (CoRE) Parameters" registry, hereafter referred to as the "CoRE
   Parameters" registry.

   Values in the two sub-registries are eight-bit values notated as
   three decimal digits c.dd separated by a period between the first and
   the second digit; the first digit c is between 0 and 7 and denotes
   the code class; the second and third digits dd denote a decimal
   number between 00 and 31 for the detail.












<span class="grey">Shelby, et al.               Standards Track                   [Page 86]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-87" id="page-87" name="page-87"> </a>
<span class="grey"><a href="rfc7252.html">RFC 7252</a>       The Constrained Application Protocol (CoAP)     June 2014</span>


   All Code values are assigned by sub-registries according to the
   following ranges:

   0.00      Indicates an Empty message (see <a href="#section-4.1">Section 4.1</a>).

   0.01-0.31 Indicates a request.  Values in this range are assigned by
             the "CoAP Method Codes" sub-registry (see <a href="#section-12.1.1">Section 12.1.1</a>).

   1.00-1.31 Reserved

   2.00-5.31 Indicates a response.  Values in this range are assigned by
             the "CoAP Response Codes" sub-registry (see
             <a href="#section-12.1.2">Section 12.1.2</a>).

   6.00-7.31 Reserved

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/12.1.1.%20%20Method%20Codes"></a><a class="selflink" href="#section-12.1.1" name="section-12.1.1">12.1.1</a>.  Method Codes</span>

   The name of the sub-registry is "CoAP Method Codes".

   Each entry in the sub-registry must include the Method Code in the
   range 0.01-0.31, the name of the method, and a reference to the
   method's documentation.

   Initial entries in this sub-registry are as follows:

                       +------+--------+-----------+
                       | Code | Name   | Reference |
                       +------+--------+-----------+
                       | 0.01 | GET    | [<a href="rfc7252.html">RFC7252</a>] |
                       | 0.02 | POST   | [<a href="rfc7252.html">RFC7252</a>] |
                       | 0.03 | PUT    | [<a href="rfc7252.html">RFC7252</a>] |
                       | 0.04 | DELETE | [<a href="rfc7252.html">RFC7252</a>] |
                       +------+--------+-----------+

                        Table 5: CoAP Method Codes

   All other Method Codes are Unassigned.

   The IANA policy for future additions to this sub-registry is "IETF
   Review or IESG Approval" as described in [<a href="rfc5226.html" title='"Guidelines for Writing an IANA Considerations Section in RFCs"'>RFC5226</a>].

   The documentation of a Method Code should specify the semantics of a
   request with that code, including the following properties:

   o  The Response Codes the method returns in the success case.

   o  Whether the method is idempotent, safe, or both.



<span class="grey">Shelby, et al.               Standards Track                   [Page 87]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-88" id="page-88" name="page-88"> </a>
<span class="grey"><a href="rfc7252.html">RFC 7252</a>       The Constrained Application Protocol (CoAP)     June 2014</span>


<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/12.1.2.%20%20Response%20Codes"></a><a class="selflink" href="#section-12.1.2" name="section-12.1.2">12.1.2</a>.  Response Codes</span>

   The name of the sub-registry is "CoAP Response Codes".

   Each entry in the sub-registry must include the Response Code in the
   range 2.00-5.31, a description of the Response Code, and a reference
   to the Response Code's documentation.

   Initial entries in this sub-registry are as follows:

            +------+------------------------------+-----------+
            | Code | Description                  | Reference |
            +------+------------------------------+-----------+
            | 2.01 | Created                      | [<a href="rfc7252.html">RFC7252</a>] |
            | 2.02 | Deleted                      | [<a href="rfc7252.html">RFC7252</a>] |
            | 2.03 | Valid                        | [<a href="rfc7252.html">RFC7252</a>] |
            | 2.04 | Changed                      | [<a href="rfc7252.html">RFC7252</a>] |
            | 2.05 | Content                      | [<a href="rfc7252.html">RFC7252</a>] |
            | 4.00 | Bad Request                  | [<a href="rfc7252.html">RFC7252</a>] |
            | 4.01 | Unauthorized                 | [<a href="rfc7252.html">RFC7252</a>] |
            | 4.02 | Bad Option                   | [<a href="rfc7252.html">RFC7252</a>] |
            | 4.03 | Forbidden                    | [<a href="rfc7252.html">RFC7252</a>] |
            | 4.04 | Not Found                    | [<a href="rfc7252.html">RFC7252</a>] |
            | 4.05 | Method Not Allowed           | [<a href="rfc7252.html">RFC7252</a>] |
            | 4.06 | Not Acceptable               | [<a href="rfc7252.html">RFC7252</a>] |
            | 4.12 | Precondition Failed          | [<a href="rfc7252.html">RFC7252</a>] |
            | 4.13 | Request Entity Too Large     | [<a href="rfc7252.html">RFC7252</a>] |
            | 4.15 | Unsupported Content-Format   | [<a href="rfc7252.html">RFC7252</a>] |
            | 5.00 | Internal Server Error        | [<a href="rfc7252.html">RFC7252</a>] |
            | 5.01 | Not Implemented              | [<a href="rfc7252.html">RFC7252</a>] |
            | 5.02 | Bad Gateway                  | [<a href="rfc7252.html">RFC7252</a>] |
            | 5.03 | Service Unavailable          | [<a href="rfc7252.html">RFC7252</a>] |
            | 5.04 | Gateway Timeout              | [<a href="rfc7252.html">RFC7252</a>] |
            | 5.05 | Proxying Not Supported       | [<a href="rfc7252.html">RFC7252</a>] |
            +------+------------------------------+-----------+

                       Table 6: CoAP Response Codes

   The Response Codes 3.00-3.31 are Reserved for future use.  All other
   Response Codes are Unassigned.

   The IANA policy for future additions to this sub-registry is "IETF
   Review or IESG Approval" as described in [<a href="rfc5226.html" title='"Guidelines for Writing an IANA Considerations Section in RFCs"'>RFC5226</a>].








<span class="grey">Shelby, et al.               Standards Track                   [Page 88]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-89" id="page-89" name="page-89"> </a>
<span class="grey"><a href="rfc7252.html">RFC 7252</a>       The Constrained Application Protocol (CoAP)     June 2014</span>


   The documentation of a Response Code should specify the semantics of
   a response with that code, including the following properties:

   o  The methods the Response Code applies to.

   o  Whether payload is required, optional, or not allowed.

   o  The semantics of the payload.  For example, the payload of a 2.05
      (Content) response is a representation of the target resource; the
      payload in an error response is a human-readable diagnostic
      payload.

   o  The format of the payload.  For example, the format in a 2.05
      (Content) response is indicated by the Content-Format Option; the
      format of the payload in an error response is always Net-Unicode
      text.

   o  Whether the response is cacheable according to the freshness
      model.

   o  Whether the response is validatable according to the validation
      model.

   o  Whether the response causes a cache to mark responses stored for
      the request URI as not fresh.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/12.2.%20%20CoAP%20Option%20Numbers%20Registry"></a><a class="selflink" href="#section-12.2" name="section-12.2">12.2</a>.  CoAP Option Numbers Registry</span>

   This document defines a sub-registry for the Option Numbers used in
   CoAP options within the "CoRE Parameters" registry.  The name of the
   sub-registry is "CoAP Option Numbers".

   Each entry in the sub-registry must include the Option Number, the
   name of the option, and a reference to the option's documentation.

















<span class="grey">Shelby, et al.               Standards Track                   [Page 89]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-90" id="page-90" name="page-90"> </a>
<span class="grey"><a href="rfc7252.html">RFC 7252</a>       The Constrained Application Protocol (CoAP)     June 2014</span>


   Initial entries in this sub-registry are as follows:

                 +--------+------------------+-----------+
                 | Number | Name             | Reference |
                 +--------+------------------+-----------+
                 |      0 | (Reserved)       | [<a href="rfc7252.html">RFC7252</a>] |
                 |      1 | If-Match         | [<a href="rfc7252.html">RFC7252</a>] |
                 |      3 | Uri-Host         | [<a href="rfc7252.html">RFC7252</a>] |
                 |      4 | ETag             | [<a href="rfc7252.html">RFC7252</a>] |
                 |      5 | If-None-Match    | [<a href="rfc7252.html">RFC7252</a>] |
                 |      7 | Uri-Port         | [<a href="rfc7252.html">RFC7252</a>] |
                 |      8 | Location-Path    | [<a href="rfc7252.html">RFC7252</a>] |
                 |     11 | Uri-Path         | [<a href="rfc7252.html">RFC7252</a>] |
                 |     12 | Content-Format   | [<a href="rfc7252.html">RFC7252</a>] |
                 |     14 | Max-Age          | [<a href="rfc7252.html">RFC7252</a>] |
                 |     15 | Uri-Query        | [<a href="rfc7252.html">RFC7252</a>] |
                 |     17 | Accept           | [<a href="rfc7252.html">RFC7252</a>] |
                 |     20 | Location-Query   | [<a href="rfc7252.html">RFC7252</a>] |
                 |     35 | Proxy-Uri        | [<a href="rfc7252.html">RFC7252</a>] |
                 |     39 | Proxy-Scheme     | [<a href="rfc7252.html">RFC7252</a>] |
                 |     60 | Size1            | [<a href="rfc7252.html">RFC7252</a>] |
                 |    128 | (Reserved)       | [<a href="rfc7252.html">RFC7252</a>] |
                 |    132 | (Reserved)       | [<a href="rfc7252.html">RFC7252</a>] |
                 |    136 | (Reserved)       | [<a href="rfc7252.html">RFC7252</a>] |
                 |    140 | (Reserved)       | [<a href="rfc7252.html">RFC7252</a>] |
                 +--------+------------------+-----------+

                       Table 7: CoAP Option Numbers

   The IANA policy for future additions to this sub-registry is split
   into three tiers as follows.  The range of 0..255 is reserved for
   options defined by the IETF (IETF Review or IESG Approval).  The
   range of 256..2047 is reserved for commonly used options with public
   specifications (Specification Required).  The range of 2048..64999 is
   for all other options including private or vendor-specific ones,
   which undergo a Designated Expert review to help ensure that the
   option semantics are defined correctly.  The option numbers between
   65000 and 65535 inclusive are reserved for experiments.  They are not
   meant for vendor-specific use of any kind and MUST NOT be used in
   operational deployments.











<span class="grey">Shelby, et al.               Standards Track                   [Page 90]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-91" id="page-91" name="page-91"> </a>
<span class="grey"><a href="rfc7252.html">RFC 7252</a>       The Constrained Application Protocol (CoAP)     June 2014</span>


          +-------------+---------------------------------------+
          |       Range | Registration Procedures               |
          +-------------+---------------------------------------+
          |       0-255 | IETF Review or IESG Approval          |
          |    256-2047 | Specification Required                |
          |  2048-64999 | Expert Review                         |
          | 65000-65535 | Experimental use (no operational use) |
          +-------------+---------------------------------------+

           Table 8: CoAP Option Numbers: Registration Procedures

   The documentation of an Option Number should specify the semantics of
   an option with that number, including the following properties:

   o  The meaning of the option in a request.

   o  The meaning of the option in a response.

   o  Whether the option is critical or elective, as determined by the
      Option Number.

   o  Whether the option is Safe-to-Forward, and, if yes, whether it is
      part of the Cache-Key, as determined by the Option Number (see
      <a href="#section-5.4.2">Section 5.4.2</a>).

   o  The format and length of the option's value.

   o  Whether the option must occur at most once or whether it can occur
      multiple times.

   o  The default value, if any.  For a critical option with a default
      value, a discussion on how the default value enables processing by
      implementations that do not support the critical option
      (<a href="#section-5.4.4">Section 5.4.4</a>).

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/12.3.%20%20CoAP%20Content-Formats%20Registry"></a><a class="selflink" href="#section-12.3" name="section-12.3">12.3</a>.  CoAP Content-Formats Registry</span>

   Internet media types are identified by a string, such as
   "application/xml" [<a href="rfc2046.html" title='"Multipurpose Internet Mail Extensions (MIME) Part Two: Media Types"'>RFC2046</a>].  In order to minimize the overhead of
   using these media types to indicate the format of payloads, this
   document defines a sub-registry for a subset of Internet media types
   to be used in CoAP and assigns each, in combination with a content-
   coding, a numeric identifier.  The name of the sub-registry is "CoAP
   Content-Formats", within the "CoRE Parameters" registry.







<span class="grey">Shelby, et al.               Standards Track                   [Page 91]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-92" id="page-92" name="page-92"> </a>
<span class="grey"><a href="rfc7252.html">RFC 7252</a>       The Constrained Application Protocol (CoAP)     June 2014</span>


   Each entry in the sub-registry must include the media type registered
   with IANA, the numeric identifier in the range 0-65535 to be used for
   that media type in CoAP, the content-coding associated with this
   identifier, and a reference to a document describing what a payload
   with that media type means semantically.

   CoAP does not include a separate way to convey content-encoding
   information with a request or response, and for that reason the
   content-encoding is also specified for each identifier (if any).  If
   multiple content-encodings will be used with a media type, then a
   separate Content-Format identifier for each is to be registered.
   Similarly, other parameters related to an Internet media type, such
   as level, can be defined for a CoAP Content-Format entry.

   Initial entries in this sub-registry are as follows:

   +--------------------------+----------+----+------------------------+
   | Media type               | Encoding | ID | Reference              |
   +--------------------------+----------+----+------------------------+
   | text/plain;              | -        |  0 | [<a href="rfc2046.html" title='"Multipurpose Internet Mail Extensions (MIME) Part Two: Media Types"'>RFC2046</a>] [<a href="rfc3676.html" title='"The Text/Plain Format and DelSp Parameters"'>RFC3676</a>]    |
   | charset=utf-8            |          |    | [<a href="rfc5147.html" title='"URI Fragment Identifiers for the text/plain Media Type"'>RFC5147</a>]              |
   | application/link-format  | -        | 40 | [<a href="rfc6690.html" title='"Constrained RESTful Environments (CoRE) Link Format"'>RFC6690</a>]              |
   | application/xml          | -        | 41 | [<a href="rfc3023.html" title='"XML Media Types"'>RFC3023</a>]              |
   | application/octet-stream | -        | 42 | [<a href="rfc2045.html" title='"Multipurpose Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies"'>RFC2045</a>] [<a href="rfc2046.html" title='"Multipurpose Internet Mail Extensions (MIME) Part Two: Media Types"'>RFC2046</a>]    |
   | application/exi          | -        | 47 | [<a href="#ref-REC-exi-20140211">REC-exi-20140211</a>]     |
   | application/json         | -        | 50 | [<a href="rfc7159.html" title='"The JavaScript Object Notation (JSON) Data Interchange Format"'>RFC7159</a>]              |
   +--------------------------+----------+----+------------------------+

                       Table 9: CoAP Content-Formats

   The identifiers between 65000 and 65535 inclusive are reserved for
   experiments.  They are not meant for vendor-specific use of any kind
   and MUST NOT be used in operational deployments.  The identifiers
   between 256 and 9999 are reserved for future use in IETF
   specifications (IETF Review or IESG Approval).  All other identifiers
   are Unassigned.

   Because the namespace of single-byte identifiers is so small, the
   IANA policy for future additions in the range 0-255 inclusive to the
   sub-registry is "Expert Review" as described in [<a href="rfc5226.html" title='"Guidelines for Writing an IANA Considerations Section in RFCs"'>RFC5226</a>].  The IANA
   policy for additions in the range 10000-64999 inclusive is "First
   Come First Served" as described in [<a href="rfc5226.html" title='"Guidelines for Writing an IANA Considerations Section in RFCs"'>RFC5226</a>].  This is summarized in
   the following table.








<span class="grey">Shelby, et al.               Standards Track                   [Page 92]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-93" id="page-93" name="page-93"> </a>
<span class="grey"><a href="rfc7252.html">RFC 7252</a>       The Constrained Application Protocol (CoAP)     June 2014</span>


          +-------------+---------------------------------------+
          |       Range | Registration Procedures               |
          +-------------+---------------------------------------+
          |       0-255 | Expert Review                         |
          |    256-9999 | IETF Review or IESG Approval          |
          | 10000-64999 | First Come First Served               |
          | 65000-65535 | Experimental use (no operational use) |
          +-------------+---------------------------------------+

          Table 10: CoAP Content-Formats: Registration Procedures

   In machine-to-machine applications, it is not expected that generic
   Internet media types such as text/plain, application/xml or
   application/octet-stream are useful for real applications in the long
   term.  It is recommended that M2M applications making use of CoAP
   request new Internet media types from IANA indicating semantic
   information about how to create or parse a payload.  For example, a
   Smart Energy application payload carried as XML might request a more
   specific type like application/se+xml or application/se-exi.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/12.4.%20%20URI%20Scheme%20Registration"></a><a class="selflink" href="#section-12.4" name="section-12.4">12.4</a>.  URI Scheme Registration</span>

   This document contains the request for the registration of the
   Uniform Resource Identifier (URI) scheme "coap".  The registration
   request complies with [<a href="rfc4395.html" title='"Guidelines and Registration Procedures for New URI Schemes"'>RFC4395</a>].

   URI scheme name.
      coap

   Status.
      Permanent.

   URI scheme syntax.
      Defined in <a href="rfc7252.html#section-6.1">Section 6.1 of [RFC7252]</a>.

   URI scheme semantics.
      The "coap" URI scheme provides a way to identify resources that
      are potentially accessible over the Constrained Application
      Protocol (CoAP).  The resources can be located by contacting the
      governing CoAP server and operated on by sending CoAP requests to
      the server.  This scheme can thus be compared to the "http" URI
      scheme [<a href="rfc2616.html" title='"Hypertext Transfer Protocol -- HTTP/1.1"'>RFC2616</a>].  See <a href="rfc7252.html#section-6">Section 6 of [RFC7252]</a> for the details of
      operation.

   Encoding considerations.
      The scheme encoding conforms to the encoding rules established for
      URIs in [<a href="rfc3986.html" title='"Uniform Resource Identifier (URI): Generic Syntax"'>RFC3986</a>], i.e., internationalized and reserved characters
      are expressed using UTF-8-based percent-encoding.



<span class="grey">Shelby, et al.               Standards Track                   [Page 93]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-94" id="page-94" name="page-94"> </a>
<span class="grey"><a href="rfc7252.html">RFC 7252</a>       The Constrained Application Protocol (CoAP)     June 2014</span>


   Applications/protocols that use this URI scheme name.
      The scheme is used by CoAP endpoints to access CoAP resources.

   Interoperability considerations.
      None.

   Security considerations.
      See <a href="rfc7252.html#section-11.1">Section 11.1 of [RFC7252]</a>.

   Contact.
      IETF Chair &lt;chair@ietf.org&gt;

   Author/Change controller.
      IESG &lt;iesg@ietf.org&gt;

   References.
      [<a href="rfc7252.html">RFC7252</a>]

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/12.5.%20%20Secure%20URI%20Scheme%20Registration"></a><a class="selflink" href="#section-12.5" name="section-12.5">12.5</a>.  Secure URI Scheme Registration</span>

   This document contains the request for the registration of the
   Uniform Resource Identifier (URI) scheme "coaps".  The registration
   request complies with [<a href="rfc4395.html" title='"Guidelines and Registration Procedures for New URI Schemes"'>RFC4395</a>].

   URI scheme name.
      coaps

   Status.
      Permanent.

   URI scheme syntax.
      Defined in <a href="rfc7252.html#section-6.2">Section 6.2 of [RFC7252]</a>.

   URI scheme semantics.
      The "coaps" URI scheme provides a way to identify resources that
      are potentially accessible over the Constrained Application
      Protocol (CoAP) using Datagram Transport Layer Security (DTLS) for
      transport security.  The resources can be located by contacting
      the governing CoAP server and operated on by sending CoAP requests
      to the server.  This scheme can thus be compared to the "https"
      URI scheme [<a href="rfc2616.html" title='"Hypertext Transfer Protocol -- HTTP/1.1"'>RFC2616</a>].  See <a href="rfc7252.html#section-6">Section 6 of [RFC7252]</a> for the details
      of operation.

   Encoding considerations.
      The scheme encoding conforms to the encoding rules established for
      URIs in [<a href="rfc3986.html" title='"Uniform Resource Identifier (URI): Generic Syntax"'>RFC3986</a>], i.e., internationalized and reserved characters
      are expressed using UTF-8-based percent-encoding.




<span class="grey">Shelby, et al.               Standards Track                   [Page 94]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-95" id="page-95" name="page-95"> </a>
<span class="grey"><a href="rfc7252.html">RFC 7252</a>       The Constrained Application Protocol (CoAP)     June 2014</span>


   Applications/protocols that use this URI scheme name.
      The scheme is used by CoAP endpoints to access CoAP resources
      using DTLS.

   Interoperability considerations.
      None.

   Security considerations.
      See <a href="rfc7252.html#section-11.1">Section 11.1 of [RFC7252]</a>.

   Contact.
      IETF Chair &lt;chair@ietf.org&gt;

   Author/Change controller.
      IESG &lt;iesg@ietf.org&gt;

   References.
      [<a href="rfc7252.html">RFC7252</a>]

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/12.6.%20%20Service%20Name%20and%20Port%20Number%20Registration"></a><a class="selflink" href="#section-12.6" name="section-12.6">12.6</a>.  Service Name and Port Number Registration</span>

   One of the functions of CoAP is resource discovery: a CoAP client can
   ask a CoAP server about the resources offered by it (see <a href="#section-7">Section 7</a>).
   To enable resource discovery just based on the knowledge of an IP
   address, the CoAP port for resource discovery needs to be
   standardized.

   IANA has assigned the port number 5683 and the service name "coap",
   in accordance with [<a href="rfc6335.html" title='"Internet Assigned Numbers Authority (IANA) Procedures for the Management of the Service Name and Transport Protocol Port Number Registry"'>RFC6335</a>].

   Besides unicast, CoAP can be used with both multicast and anycast.

   Service Name.
      coap

   Transport Protocol.
      udp

   Assignee.
      IESG &lt;iesg@ietf.org&gt;

   Contact.
      IETF Chair &lt;chair@ietf.org&gt;

   Description.
      Constrained Application Protocol (CoAP)





<span class="grey">Shelby, et al.               Standards Track                   [Page 95]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-96" id="page-96" name="page-96"> </a>
<span class="grey"><a href="rfc7252.html">RFC 7252</a>       The Constrained Application Protocol (CoAP)     June 2014</span>


   Reference.
      [<a href="rfc7252.html">RFC7252</a>]

   Port Number.
      5683

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/12.7.%20%20Secure%20Service%20Name%20and%20Port%20Number%20Registration"></a><a class="selflink" href="#section-12.7" name="section-12.7">12.7</a>.  Secure Service Name and Port Number Registration</span>

   CoAP resource discovery may also be provided using the DTLS-secured
   CoAP "coaps" scheme.  Thus, the CoAP port for secure resource
   discovery needs to be standardized.

   IANA has assigned the port number 5684 and the service name "coaps",
   in accordance with [<a href="rfc6335.html" title='"Internet Assigned Numbers Authority (IANA) Procedures for the Management of the Service Name and Transport Protocol Port Number Registry"'>RFC6335</a>].

   Besides unicast, DTLS-secured CoAP can be used with anycast.

   Service Name.
      coaps

   Transport Protocol.
      udp

   Assignee.
      IESG &lt;iesg@ietf.org&gt;

   Contact.
      IETF Chair &lt;chair@ietf.org&gt;

   Description.
      DTLS-secured CoAP

   Reference.
      [<a href="rfc7252.html">RFC7252</a>]

   Port Number.
      5684














<span class="grey">Shelby, et al.               Standards Track                   [Page 96]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-97" id="page-97" name="page-97"> </a>
<span class="grey"><a href="rfc7252.html">RFC 7252</a>       The Constrained Application Protocol (CoAP)     June 2014</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/12.8.%20%20Multicast%20Address%20Registration"></a><a class="selflink" href="#section-12.8" name="section-12.8">12.8</a>.  Multicast Address Registration</span>

   <a href="#section-8">Section 8</a>, "Multicast CoAP", defines the use of multicast.  IANA has
   assigned the following multicast addresses for use by CoAP nodes:

   IPv4  -- "All CoAP Nodes" address 224.0.1.187, from the "IPv4
      Multicast Address Space Registry".  As the address is used for
      discovery that may span beyond a single network, it has come from
      the Internetwork Control Block (224.0.1.x, <a href="rfc5771.html">RFC 5771</a>).

   IPv6  -- "All CoAP Nodes" address FF0X::FD, from the "IPv6 Multicast
      Address Space Registry", in the "Variable Scope Multicast
      Addresses" space (<a href="rfc3307.html">RFC 3307</a>).  Note that there is a distinct
      multicast address for each scope that interested CoAP nodes should
      listen to; CoAP needs the Link-Local and Site-Local scopes only.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/13.%20%20Acknowledgements"></a><a class="selflink" href="#section-13" name="section-13">13</a>.  Acknowledgements</span>

   Brian Frank was a contributor to and coauthor of early versions of
   this specification.

   Special thanks to Peter Bigot, Esko Dijk, and Cullen Jennings for
   substantial contributions to the ideas and text in the document,
   along with countless detailed reviews and discussions.

   Thanks to Floris Van den Abeele, Anthony Baire, Ed Beroset, Berta
   Carballido, Angelo P. Castellani, Gilbert Clark, Robert Cragie,
   Pierre David, Esko Dijk, Lisa Dusseault, Mehmet Ersue, Thomas
   Fossati, Tobias Gondrom, Bert Greevenbosch, Tom Herbst, Jeroen
   Hoebeke, Richard Kelsey, Sye Loong Keoh, Ari Keranen, Matthias
   Kovatsch, Avi Lior, Stephan Lohse, Salvatore Loreto, Kerry Lynn,
   Andrew McGregor, Alexey Melnikov, Guido Moritz, Petri Mutka, Colin
   O'Flynn, Charles Palmer, Adriano Pezzuto, Thomas Poetsch, Robert
   Quattlebaum, Akbar Rahman, Eric Rescorla, Dan Romascanu, David Ryan,
   Peter Saint-Andre, Szymon Sasin, Michael Scharf, Dale Seed, Robby
   Simpson, Peter van der Stok, Michael Stuber, Linyi Tian, Gilman
   Tolle, Matthieu Vial, Maciej Wasilak, Fan Xianyou, and Alper Yegin
   for helpful comments and discussions that have shaped the document.
   Special thanks also to the responsible IETF area director at the time
   of completion, Barry Leiba, and the IESG reviewers, Adrian Farrel,
   Martin Stiemerling, Pete Resnick, Richard Barnes, Sean Turner,
   Spencer Dawkins, Stephen Farrell, and Ted Lemon, who contributed in-
   depth reviews.

   Some of the text has been borrowed from the working documents of the
   IETF HTTPBIS working group.





<span class="grey">Shelby, et al.               Standards Track                   [Page 97]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-98" id="page-98" name="page-98"> </a>
<span class="grey"><a href="rfc7252.html">RFC 7252</a>       The Constrained Application Protocol (CoAP)     June 2014</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/14.%20%20References"></a><a class="selflink" href="#section-14" name="section-14">14</a>.  References</span>

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/14.1.%20%20Normative%20References"></a><a class="selflink" href="#section-14.1" name="section-14.1">14.1</a>.  Normative References</span>

   [<a id="ref-RFC0768" name="ref-RFC0768">RFC0768</a>]  Postel, J., "User Datagram Protocol", STD 6, <a href="rfc768.html">RFC 768</a>,
              August 1980.

   [<a id="ref-RFC2045" name="ref-RFC2045">RFC2045</a>]  Freed, N. and N. Borenstein, "Multipurpose Internet Mail
              Extensions (MIME) Part One: Format of Internet Message
              Bodies", <a href="rfc2045.html">RFC 2045</a>, November 1996.

   [<a id="ref-RFC2046" name="ref-RFC2046">RFC2046</a>]  Freed, N. and N. Borenstein, "Multipurpose Internet Mail
              Extensions (MIME) Part Two: Media Types", <a href="rfc2046.html">RFC 2046</a>,
              November 1996.

   [<a id="ref-RFC2119" name="ref-RFC2119">RFC2119</a>]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", <a href="https://tools.ietf.org/html/bcp14">BCP 14</a>, <a href="rfc2119.html">RFC 2119</a>, March 1997.

   [<a id="ref-RFC2616" name="ref-RFC2616">RFC2616</a>]  Fielding, R., Gettys, J., Mogul, J., Frystyk, H.,
              Masinter, L., Leach, P., and T. Berners-Lee, "Hypertext
              Transfer Protocol -- HTTP/1.1", <a href="rfc2616.html">RFC 2616</a>, June 1999.

   [<a id="ref-RFC3023" name="ref-RFC3023">RFC3023</a>]  Murata, M., St. Laurent, S., and D. Kohn, "XML Media
              Types", <a href="rfc3023.html">RFC 3023</a>, January 2001.

   [<a id="ref-RFC3629" name="ref-RFC3629">RFC3629</a>]  Yergeau, F., "UTF-8, a transformation format of ISO
              10646", STD 63, <a href="rfc3629.html">RFC 3629</a>, November 2003.

   [<a id="ref-RFC3676" name="ref-RFC3676">RFC3676</a>]  Gellens, R., "The Text/Plain Format and DelSp Parameters",
              <a href="rfc3676.html">RFC 3676</a>, February 2004.

   [<a id="ref-RFC3986" name="ref-RFC3986">RFC3986</a>]  Berners-Lee, T., Fielding, R., and L. Masinter, "Uniform
              Resource Identifier (URI): Generic Syntax", STD 66, <a href="rfc3986.html">RFC</a>
              <a href="rfc3986.html">3986</a>, January 2005.

   [<a id="ref-RFC4279" name="ref-RFC4279">RFC4279</a>]  Eronen, P. and H. Tschofenig, "Pre-Shared Key Ciphersuites
              for Transport Layer Security (TLS)", <a href="rfc4279.html">RFC 4279</a>, December
              2005.

   [<a id="ref-RFC4395" name="ref-RFC4395">RFC4395</a>]  Hansen, T., Hardie, T., and L. Masinter, "Guidelines and
              Registration Procedures for New URI Schemes", <a href="https://tools.ietf.org/html/bcp35">BCP 35</a>, <a href="rfc4395.html">RFC</a>
              <a href="rfc4395.html">4395</a>, February 2006.

   [<a id="ref-RFC5147" name="ref-RFC5147">RFC5147</a>]  Wilde, E. and M. Duerst, "URI Fragment Identifiers for the
              text/plain Media Type", <a href="rfc5147.html">RFC 5147</a>, April 2008.

   [<a id="ref-RFC5198" name="ref-RFC5198">RFC5198</a>]  Klensin, J. and M. Padlipsky, "Unicode Format for Network
              Interchange", <a href="rfc5198.html">RFC 5198</a>, March 2008.



<span class="grey">Shelby, et al.               Standards Track                   [Page 98]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-99" id="page-99" name="page-99"> </a>
<span class="grey"><a href="rfc7252.html">RFC 7252</a>       The Constrained Application Protocol (CoAP)     June 2014</span>


   [<a id="ref-RFC5226" name="ref-RFC5226">RFC5226</a>]  Narten, T. and H. Alvestrand, "Guidelines for Writing an
              IANA Considerations Section in RFCs", <a href="https://tools.ietf.org/html/bcp26">BCP 26</a>, <a href="rfc5226.html">RFC 5226</a>,
              May 2008.

   [<a id="ref-RFC5234" name="ref-RFC5234">RFC5234</a>]  Crocker, D. and P. Overell, "Augmented BNF for Syntax
              Specifications: ABNF", STD 68, <a href="rfc5234.html">RFC 5234</a>, January 2008.

   [<a id="ref-RFC5246" name="ref-RFC5246">RFC5246</a>]  Dierks, T. and E. Rescorla, "The Transport Layer Security
              (TLS) Protocol Version 1.2", <a href="rfc5246.html">RFC 5246</a>, August 2008.

   [<a id="ref-RFC5280" name="ref-RFC5280">RFC5280</a>]  Cooper, D., Santesson, S., Farrell, S., Boeyen, S.,
              Housley, R., and W. Polk, "Internet X.509 Public Key
              Infrastructure Certificate and Certificate Revocation List
              (CRL) Profile", <a href="rfc5280.html">RFC 5280</a>, May 2008.

   [<a id="ref-RFC5480" name="ref-RFC5480">RFC5480</a>]  Turner, S., Brown, D., Yiu, K., Housley, R., and T. Polk,
              "Elliptic Curve Cryptography Subject Public Key
              Information", <a href="rfc5480.html">RFC 5480</a>, March 2009.

   [<a id="ref-RFC5785" name="ref-RFC5785">RFC5785</a>]  Nottingham, M. and E. Hammer-Lahav, "Defining Well-Known
              Uniform Resource Identifiers (URIs)", <a href="rfc5785.html">RFC 5785</a>, April
              2010.

   [<a id="ref-RFC5952" name="ref-RFC5952">RFC5952</a>]  Kawamura, S. and M. Kawashima, "A Recommendation for IPv6
              Address Text Representation", <a href="rfc5952.html">RFC 5952</a>, August 2010.

   [<a id="ref-RFC5988" name="ref-RFC5988">RFC5988</a>]  Nottingham, M., "Web Linking", <a href="rfc5988.html">RFC 5988</a>, October 2010.

   [<a id="ref-RFC6066" name="ref-RFC6066">RFC6066</a>]  Eastlake, D., "Transport Layer Security (TLS) Extensions:
              Extension Definitions", <a href="rfc6066.html">RFC 6066</a>, January 2011.

   [<a id="ref-RFC6347" name="ref-RFC6347">RFC6347</a>]  Rescorla, E. and N. Modadugu, "Datagram Transport Layer
              Security Version 1.2", <a href="rfc6347.html">RFC 6347</a>, January 2012.

   [<a id="ref-RFC6690" name="ref-RFC6690">RFC6690</a>]  Shelby, Z., "Constrained RESTful Environments (CoRE) Link
              Format", <a href="rfc6690.html">RFC 6690</a>, August 2012.

   [<a id="ref-RFC6920" name="ref-RFC6920">RFC6920</a>]  Farrell, S., Kutscher, D., Dannewitz, C., Ohlman, B.,
              Keranen, A., and P. Hallam-Baker, "Naming Things with
              Hashes", <a href="rfc6920.html">RFC 6920</a>, April 2013.

   [<a id="ref-RFC7250" name="ref-RFC7250">RFC7250</a>]  Wouters, P., Tschofenig, H., Gilmore, J., Weiler, S., and
              T. Kivinen, "Using Raw Public Keys in Transport Layer
              Security (TLS) and Datagram Transport Layer Security
              (DTLS)", <a href="rfc7250.html">RFC 7250</a>, June 2014.






<span class="grey">Shelby, et al.               Standards Track                   [Page 99]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-100" id="page-100" name="page-100"> </a>
<span class="grey"><a href="rfc7252.html">RFC 7252</a>       The Constrained Application Protocol (CoAP)     June 2014</span>


   [<a id="ref-RFC7251" name="ref-RFC7251">RFC7251</a>]  McGrew, D., Bailey, D., Campagna, M., and R. Dugal, "AES-
              CCM Elliptic Curve Cryptography (ECC) Cipher Suites for
              Transport Layer Security (TLS)", <a href="rfc7251.html">RFC 7251</a>, June 2014.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/14.2.%20%20Informative%20References"></a><a class="selflink" href="#section-14.2" name="section-14.2">14.2</a>.  Informative References</span>

   [<a id="ref-BLOCK" name="ref-BLOCK">BLOCK</a>]    Bormann, C. and Z. Shelby, <a href="https://www.google.com/search?sitesearch=tools.ietf.org%2Fhtml%2F&amp;q=inurl:draft-+%22Blockwise+transfers+in+CoAP%22" style="text-decoration: none">"Blockwise transfers in CoAP"</a>,
              Work in Progress, October 2013.

   [<a id="ref-CoAP-MISC" name="ref-CoAP-MISC">CoAP-MISC</a>]
              Bormann, C. and K. Hartke, "Miscellaneous additions to
              CoAP", Work in Progress, December 2013.

   [<a id="ref-EUI64" name="ref-EUI64">EUI64</a>]    IEEE Standards Association, "Guidelines for 64-bit Global
              Identifier (EUI-64 (TM))", Registration Authority
              Tutorials, April 2010, &lt;<a href="http://standards.ieee.org/regauth/oui/tutorials/EUI64.html">http://standards.ieee.org/regauth/</a>
              <a href="http://standards.ieee.org/regauth/oui/tutorials/EUI64.html">oui/tutorials/EUI64.html</a>&gt;.

   [<a id="ref-GROUPCOMM" name="ref-GROUPCOMM">GROUPCOMM</a>]
              Rahman, A. and E. Dijk, <a href="https://www.google.com/search?sitesearch=tools.ietf.org%2Fhtml%2F&amp;q=inurl:draft-+%22Group+Communication+for+CoAP%22" style="text-decoration: none">"Group Communication for CoAP"</a>,
              Work in Progress, December 2013.

   [<a id="ref-HHGTTG" name="ref-HHGTTG">HHGTTG</a>]   Adams, D., "The Hitchhiker's Guide to the Galaxy", Pan
              Books ISBN 3320258648, 1979.

   [<a id="ref-IEEE1003.1" name="ref-IEEE1003.1">IEEE1003.1</a>]
              IEEE and The Open Group, "Portable Operating System
              Interface (POSIX)", The Open Group Base Specifications
              Issue 7, IEEE 1003.1, 2013 Edition,
              &lt;<a href="http://pubs.opengroup.org/onlinepubs/9699919799/">http://pubs.opengroup.org/onlinepubs/9699919799/</a>&gt;.

   [<a id="ref-IPsec-CoAP" name="ref-IPsec-CoAP">IPsec-CoAP</a>]
              Bormann, C., <a href="https://www.google.com/search?sitesearch=tools.ietf.org%2Fhtml%2F&amp;q=inurl:draft-+%22Using+CoAP+with+IPsec%22" style="text-decoration: none">"Using CoAP with IPsec"</a>, Work in Progress,
              December 2012.

   [<a id="ref-MAPPING" name="ref-MAPPING">MAPPING</a>]  Castellani, A., Loreto, S., Rahman, A., Fossati, T., and
              E. Dijk, "Guidelines for HTTP-CoAP Mapping
              Implementations", Work in Progress, February 2014.

   [<a id="ref-OBSERVE" name="ref-OBSERVE">OBSERVE</a>]  Hartke, K., <a href="https://www.google.com/search?sitesearch=tools.ietf.org%2Fhtml%2F&amp;q=inurl:draft-+%22Observing+Resources+in+CoAP%22" style="text-decoration: none">"Observing Resources in CoAP"</a>, Work in
              Progress, April 2014.

   [<a id="ref-REC-exi-20140211" name="ref-REC-exi-20140211">REC-exi-20140211</a>]
              Schneider, J., Kamiya, T., Peintner, D., and R. Kyusakov,
              "Efficient XML Interchange (EXI) Format 1.0 (Second
              Edition)", W3C Recommendation REC-exi-20140211, February
              2014, &lt;<a href="http://www.w3.org/TR/2014/REC-exi-20140211/">http://www.w3.org/TR/2014/REC-exi-20140211/</a>&gt;.




<span class="grey">Shelby, et al.               Standards Track                  [Page 100]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-101" id="page-101" name="page-101"> </a>
<span class="grey"><a href="rfc7252.html">RFC 7252</a>       The Constrained Application Protocol (CoAP)     June 2014</span>


   [<a id="ref-REST" name="ref-REST">REST</a>]     Fielding, R., "Architectural Styles and the Design of
              Network-based Software Architectures", Ph.D. Dissertation,
              University of California, Irvine, 2000,
              &lt;<a href="http://www.ics.uci.edu/~fielding/pubs/dissertation/fielding_dissertation.pdf">http://www.ics.uci.edu/~fielding/pubs/dissertation/</a>
              <a href="http://www.ics.uci.edu/~fielding/pubs/dissertation/fielding_dissertation.pdf">fielding_dissertation.pdf</a>&gt;.

   [<a id="ref-RFC0020" name="ref-RFC0020">RFC0020</a>]  Cerf, V., "ASCII format for network interchange", <a href="rfc20.html">RFC 20</a>,
              October 1969.

   [<a id="ref-RFC0791" name="ref-RFC0791">RFC0791</a>]  Postel, J., "Internet Protocol", STD 5, <a href="rfc791.html">RFC 791</a>, September
              1981.

   [<a id="ref-RFC0792" name="ref-RFC0792">RFC0792</a>]  Postel, J., "Internet Control Message Protocol", STD 5,
              <a href="rfc792.html">RFC 792</a>, September 1981.

   [<a id="ref-RFC0793" name="ref-RFC0793">RFC0793</a>]  Postel, J., "Transmission Control Protocol", STD 7, <a href="rfc793.html">RFC</a>
              <a href="rfc793.html">793</a>, September 1981.

   [<a id="ref-RFC1035" name="ref-RFC1035">RFC1035</a>]  Mockapetris, P., "Domain names - implementation and
              specification", STD 13, <a href="rfc1035.html">RFC 1035</a>, November 1987.

   [<a id="ref-RFC3264" name="ref-RFC3264">RFC3264</a>]  Rosenberg, J. and H. Schulzrinne, "An Offer/Answer Model
              with Session Description Protocol (SDP)", <a href="rfc3264.html">RFC 3264</a>, June
              2002.

   [<a id="ref-RFC3280" name="ref-RFC3280">RFC3280</a>]  Housley, R., Polk, W., Ford, W., and D. Solo, "Internet
              X.509 Public Key Infrastructure Certificate and
              Certificate Revocation List (CRL) Profile", <a href="rfc3280.html">RFC 3280</a>,
              April 2002.

   [<a id="ref-RFC3542" name="ref-RFC3542">RFC3542</a>]  Stevens, W., Thomas, M., Nordmark, E., and T. Jinmei,
              "Advanced Sockets Application Program Interface (API) for
              IPv6", <a href="rfc3542.html">RFC 3542</a>, May 2003.

   [<a id="ref-RFC3828" name="ref-RFC3828">RFC3828</a>]  Larzon, L-A., Degermark, M., Pink, S., Jonsson, L-E., and
              G. Fairhurst, "The Lightweight User Datagram Protocol
              (UDP-Lite)", <a href="rfc3828.html">RFC 3828</a>, July 2004.

   [<a id="ref-RFC4086" name="ref-RFC4086">RFC4086</a>]  Eastlake, D., Schiller, J., and S. Crocker, "Randomness
              Requirements for Security", <a href="https://tools.ietf.org/html/bcp106">BCP 106</a>, <a href="rfc4086.html">RFC 4086</a>, June 2005.

   [<a id="ref-RFC4443" name="ref-RFC4443">RFC4443</a>]  Conta, A., Deering, S., and M. Gupta, "Internet Control
              Message Protocol (ICMPv6) for the Internet Protocol
              Version 6 (IPv6) Specification", <a href="rfc4443.html">RFC 4443</a>, March 2006.

   [<a id="ref-RFC4492" name="ref-RFC4492">RFC4492</a>]  Blake-Wilson, S., Bolyard, N., Gupta, V., Hawk, C., and B.
              Moeller, "Elliptic Curve Cryptography (ECC) Cipher Suites
              for Transport Layer Security (TLS)", <a href="rfc4492.html">RFC 4492</a>, May 2006.



<span class="grey">Shelby, et al.               Standards Track                  [Page 101]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-102" id="page-102" name="page-102"> </a>
<span class="grey"><a href="rfc7252.html">RFC 7252</a>       The Constrained Application Protocol (CoAP)     June 2014</span>


   [<a id="ref-RFC4821" name="ref-RFC4821">RFC4821</a>]  Mathis, M. and J. Heffner, "Packetization Layer Path MTU
              Discovery", <a href="rfc4821.html">RFC 4821</a>, March 2007.

   [<a id="ref-RFC4944" name="ref-RFC4944">RFC4944</a>]  Montenegro, G., Kushalnagar, N., Hui, J., and D. Culler,
              "Transmission of IPv6 Packets over IEEE 802.15.4
              Networks", <a href="rfc4944.html">RFC 4944</a>, September 2007.

   [<a id="ref-RFC5405" name="ref-RFC5405">RFC5405</a>]  Eggert, L. and G. Fairhurst, "Unicast UDP Usage Guidelines
              for Application Designers", <a href="https://tools.ietf.org/html/bcp145">BCP 145</a>, <a href="rfc5405.html">RFC 5405</a>, November
              2008.

   [<a id="ref-RFC5489" name="ref-RFC5489">RFC5489</a>]  Badra, M. and I. Hajjeh, "ECDHE_PSK Cipher Suites for
              Transport Layer Security (TLS)", <a href="rfc5489.html">RFC 5489</a>, March 2009.

   [<a id="ref-RFC6090" name="ref-RFC6090">RFC6090</a>]  McGrew, D., Igoe, K., and M. Salter, "Fundamental Elliptic
              Curve Cryptography Algorithms", <a href="rfc6090.html">RFC 6090</a>, February 2011.

   [<a id="ref-RFC6120" name="ref-RFC6120">RFC6120</a>]  Saint-Andre, P., "Extensible Messaging and Presence
              Protocol (XMPP): Core", <a href="rfc6120.html">RFC 6120</a>, March 2011.

   [<a id="ref-RFC6282" name="ref-RFC6282">RFC6282</a>]  Hui, J. and P. Thubert, "Compression Format for IPv6
              Datagrams over IEEE 802.15.4-Based Networks", <a href="rfc6282.html">RFC 6282</a>,
              September 2011.

   [<a id="ref-RFC6335" name="ref-RFC6335">RFC6335</a>]  Cotton, M., Eggert, L., Touch, J., Westerlund, M., and S.
              Cheshire, "Internet Assigned Numbers Authority (IANA)
              Procedures for the Management of the Service Name and
              Transport Protocol Port Number Registry", <a href="https://tools.ietf.org/html/bcp165">BCP 165</a>, <a href="rfc6335.html">RFC</a>
              <a href="rfc6335.html">6335</a>, August 2011.

   [<a id="ref-RFC6655" name="ref-RFC6655">RFC6655</a>]  McGrew, D. and D. Bailey, "AES-CCM Cipher Suites for
              Transport Layer Security (TLS)", <a href="rfc6655.html">RFC 6655</a>, July 2012.

   [<a id="ref-RFC6936" name="ref-RFC6936">RFC6936</a>]  Fairhurst, G. and M. Westerlund, "Applicability Statement
              for the Use of IPv6 UDP Datagrams with Zero Checksums",
              <a href="rfc6936.html">RFC 6936</a>, April 2013.

   [<a id="ref-RFC6960" name="ref-RFC6960">RFC6960</a>]  Santesson, S., Myers, M., Ankney, R., Malpani, A.,
              Galperin, S., and C. Adams, "X.509 Internet Public Key
              Infrastructure Online Certificate Status Protocol - OCSP",
              <a href="rfc6960.html">RFC 6960</a>, June 2013.

   [<a id="ref-RFC6961" name="ref-RFC6961">RFC6961</a>]  Pettersen, Y., "The Transport Layer Security (TLS)
              Multiple Certificate Status Request Extension", <a href="rfc6961.html">RFC 6961</a>,
              June 2013.

   [<a id="ref-RFC7159" name="ref-RFC7159">RFC7159</a>]  Bray, T., "The JavaScript Object Notation (JSON) Data
              Interchange Format", <a href="rfc7159.html">RFC 7159</a>, March 2014.



<span class="grey">Shelby, et al.               Standards Track                  [Page 102]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-103" id="page-103" name="page-103"> </a>
<span class="grey"><a href="rfc7252.html">RFC 7252</a>       The Constrained Application Protocol (CoAP)     June 2014</span>


   [<a id="ref-RFC7228" name="ref-RFC7228">RFC7228</a>]  Bormann, C., Ersue, M., and A. Keranen, "Terminology for
              Constrained-Node Networks", <a href="rfc7228.html">RFC 7228</a>, May 2014.

   [<a id="ref-RTO-CONSIDER" name="ref-RTO-CONSIDER">RTO-CONSIDER</a>]
              Allman, M., <a href="https://www.google.com/search?sitesearch=tools.ietf.org%2Fhtml%2F&amp;q=inurl:draft-+%22Retransmission+Timeout+Considerations%22" style="text-decoration: none">"Retransmission Timeout Considerations"</a>, Work
              in Progress, May 2012.

   [<a id="ref-W3CXMLSEC" name="ref-W3CXMLSEC">W3CXMLSEC</a>]
              Wenning, R., "Report of the XML Security PAG", W3C XML
              Security PAG, October 2012,
              &lt;<a href="http://www.w3.org/2011/xmlsec-pag/pagreport.html">http://www.w3.org/2011/xmlsec-pag/pagreport.html</a>&gt;.








































<span class="grey">Shelby, et al.               Standards Track                  [Page 103]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-104" id="page-104" name="page-104"> </a>
<span class="grey"><a href="rfc7252.html">RFC 7252</a>       The Constrained Application Protocol (CoAP)     June 2014</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/Appendix%20A.%20%20Examples"></a><a class="selflink" href="#appendix-A" name="appendix-A">Appendix A</a>.  Examples</span>

   This section gives a number of short examples with message flows for
   GET requests.  These examples demonstrate the basic operation, the
   operation in the presence of retransmissions, and multicast.

   Figure 16 shows a basic GET request causing a piggybacked response:
   The client sends a Confirmable GET request for the resource
   coap://server/temperature to the server with a Message ID of 0x7d34.
   The request includes one Uri-Path Option (Delta 0 + 11 = 11, Length
   11, Value "temperature"); the Token is left empty.  This request is a
   total of 16 bytes long.  A 2.05 (Content) response is returned in the
   Acknowledgement message that acknowledges the Confirmable request,
   echoing both the Message ID 0x7d34 and the empty Token value.  The
   response includes a Payload of "22.3 C" and is 11 bytes long.

   Client  Server
      |      |
      |      |
      +-----&gt;|     Header: GET (T=CON, Code=0.01, MID=0x7d34)
      | GET  |   Uri-Path: "temperature"
      |      |
      |      |
      |&lt;-----+     Header: 2.05 Content (T=ACK, Code=2.05, MID=0x7d34)
      | 2.05 |    Payload: "22.3 C"
      |      |


    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   | 1 | 0 |   0   |     GET=1     |          MID=0x7d34           |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  11   |  11   |      "temperature" (11 B) ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   | 1 | 2 |   0   |    2.05=69    |          MID=0x7d34           |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |1 1 1 1 1 1 1 1|      "22.3 C" (6 B) ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

           Figure 16: Confirmable Request; Piggybacked Response






<span class="grey">Shelby, et al.               Standards Track                  [Page 104]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-105" id="page-105" name="page-105"> </a>
<span class="grey"><a href="rfc7252.html">RFC 7252</a>       The Constrained Application Protocol (CoAP)     June 2014</span>


   Figure 17 shows a similar example, but with the inclusion of an non-
   empty Token (Value 0x20) in the request and the response, increasing
   the sizes to 17 and 12 bytes, respectively.

   Client  Server
      |      |
      |      |
      +-----&gt;|     Header: GET (T=CON, Code=0.01, MID=0x7d35)
      | GET  |      Token: 0x20
      |      |   Uri-Path: "temperature"
      |      |
      |      |
      |&lt;-----+     Header: 2.05 Content (T=ACK, Code=2.05, MID=0x7d35)
      | 2.05 |      Token: 0x20
      |      |    Payload: "22.3 C"
      |      |


    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   | 1 | 0 |   1   |     GET=1     |          MID=0x7d35           |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |     0x20      |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  11   |  11   |      "temperature" (11 B) ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+


    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   | 1 | 2 |   1   |    2.05=69    |          MID=0x7d35           |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |     0x20      |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |1 1 1 1 1 1 1 1| "22.3 C" (6 B) ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

           Figure 17: Confirmable Request; Piggybacked Response











<span class="grey">Shelby, et al.               Standards Track                  [Page 105]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-106" id="page-106" name="page-106"> </a>
<span class="grey"><a href="rfc7252.html">RFC 7252</a>       The Constrained Application Protocol (CoAP)     June 2014</span>


   In Figure 18, the Confirmable GET request is lost.  After ACK_TIMEOUT
   seconds, the client retransmits the request, resulting in a
   piggybacked response as in the previous example.

   Client  Server
      |      |
      |      |
      +----X |     Header: GET (T=CON, Code=0.01, MID=0x7d36)
      | GET  |      Token: 0x31
      |      |   Uri-Path: "temperature"
   TIMEOUT   |
      |      |
      +-----&gt;|     Header: GET (T=CON, Code=0.01, MID=0x7d36)
      | GET  |      Token: 0x31
      |      |   Uri-Path: "temperature"
      |      |
      |      |
      |&lt;-----+     Header: 2.05 Content (T=ACK, Code=2.05, MID=0x7d36)
      | 2.05 |      Token: 0x31
      |      |    Payload: "22.3 C"
      |      |

   Figure 18: Confirmable Request (Retransmitted); Piggybacked Response




























<span class="grey">Shelby, et al.               Standards Track                  [Page 106]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-107" id="page-107" name="page-107"> </a>
<span class="grey"><a href="rfc7252.html">RFC 7252</a>       The Constrained Application Protocol (CoAP)     June 2014</span>


   In Figure 19, the first Acknowledgement message from the server to
   the client is lost.  After ACK_TIMEOUT seconds, the client
   retransmits the request.

   Client  Server
      |      |
      |      |
      +-----&gt;|     Header: GET (T=CON, Code=0.01, MID=0x7d37)
      | GET  |      Token: 0x42
      |      |   Uri-Path: "temperature"
      |      |
      |      |
      | X----+     Header: 2.05 Content (T=ACK, Code=2.05, MID=0x7d37)
      | 2.05 |      Token: 0x42
      |      |    Payload: "22.3 C"
   TIMEOUT   |
      |      |
      +-----&gt;|     Header: GET (T=CON, Code=0.01, MID=0x7d37)
      | GET  |      Token: 0x42
      |      |   Uri-Path: "temperature"
      |      |
      |      |
      |&lt;-----+     Header: 2.05 Content (T=ACK, Code=2.05, MID=0x7d37)
      | 2.05 |      Token: 0x42
      |      |    Payload: "22.3 C"
      |      |

   Figure 19: Confirmable Request; Piggybacked Response (Retransmitted)























<span class="grey">Shelby, et al.               Standards Track                  [Page 107]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-108" id="page-108" name="page-108"> </a>
<span class="grey"><a href="rfc7252.html">RFC 7252</a>       The Constrained Application Protocol (CoAP)     June 2014</span>


   In Figure 20, the server acknowledges the Confirmable request and
   sends a 2.05 (Content) response separately in a Confirmable message.
   Note that the Acknowledgement message and the Confirmable response do
   not necessarily arrive in the same order as they were sent.  The
   client acknowledges the Confirmable response.

   Client  Server
      |      |
      |      |
      +-----&gt;|     Header: GET (T=CON, Code=0.01, MID=0x7d38)
      | GET  |      Token: 0x53
      |      |   Uri-Path: "temperature"
      |      |
      |      |
      |&lt;- - -+     Header: (T=ACK, Code=0.00, MID=0x7d38)
      |      |
      |      |
      |&lt;-----+     Header: 2.05 Content (T=CON, Code=2.05, MID=0xad7b)
      | 2.05 |      Token: 0x53
      |      |    Payload: "22.3 C"
      |      |
      |      |
      +- - -&gt;|     Header: (T=ACK, Code=0.00, MID=0xad7b)
      |      |

             Figure 20: Confirmable Request; Separate Response

























<span class="grey">Shelby, et al.               Standards Track                  [Page 108]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-109" id="page-109" name="page-109"> </a>
<span class="grey"><a href="rfc7252.html">RFC 7252</a>       The Constrained Application Protocol (CoAP)     June 2014</span>


   Figure 21 shows an example where the client loses its state (e.g.,
   crashes and is rebooted) right after sending a Confirmable request,
   so the separate response arriving some time later comes unexpected.
   In this case, the client rejects the Confirmable response with a
   Reset message.  Note that the unexpected ACK is silently ignored.

   Client  Server
      |      |
      |      |
      +-----&gt;|     Header: GET (T=CON, Code=0.01, MID=0x7d39)
      | GET  |      Token: 0x64
      |      |   Uri-Path: "temperature"
    CRASH    |
      |      |
      |&lt;- - -+     Header: (T=ACK, Code=0.00, MID=0x7d39)
      |      |
      |      |
      |&lt;-----+     Header: 2.05 Content (T=CON, Code=2.05, MID=0xad7c)
      | 2.05 |      Token: 0x64
      |      |    Payload: "22.3 C"
      |      |
      |      |
      +- - -&gt;|     Header: (T=RST, Code=0.00, MID=0xad7c)
      |      |

      Figure 21: Confirmable Request; Separate Response (Unexpected)

   Figure 22 shows a basic GET request where the request and the
   response are Non-confirmable, so both may be lost without notice.

   Client  Server
      |      |
      |      |
      +-----&gt;|     Header: GET (T=NON, Code=0.01, MID=0x7d40)
      | GET  |      Token: 0x75
      |      |   Uri-Path: "temperature"
      |      |
      |      |
      |&lt;-----+     Header: 2.05 Content (T=NON, Code=2.05, MID=0xad7d)
      | 2.05 |      Token: 0x75
      |      |    Payload: "22.3 C"
      |      |

       Figure 22: Non-confirmable Request; Non-confirmable Response







<span class="grey">Shelby, et al.               Standards Track                  [Page 109]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-110" id="page-110" name="page-110"> </a>
<span class="grey"><a href="rfc7252.html">RFC 7252</a>       The Constrained Application Protocol (CoAP)     June 2014</span>


   In Figure 23, the client sends a Non-confirmable GET request to a
   multicast address: all nodes in link-local scope.  There are 3
   servers on the link: A, B and C.  Servers A and B have a matching
   resource, therefore they send back a Non-confirmable 2.05 (Content)
   response.  The response sent by B is lost.  C does not have matching
   response, therefore it sends a Non-confirmable 4.04 (Not Found)
   response.

   Client  ff02::1  A  B  C
      |       |     |  |  |
      |       |     |  |  |
      +------&gt;|     |  |  |  Header: GET (T=NON, Code=0.01, MID=0x7d41)
      |  GET  |     |  |  |   Token: 0x86
      |             |  |  |   Uri-Path: "temperature"
      |             |  |  |
      |             |  |  |
      |&lt;------------+  |  |  Header: 2.05 (T=NON, Code=2.05, MID=0x60b1)
      |      2.05   |  |  |   Token: 0x86
      |             |  |  |   Payload: "22.3 C"
      |             |  |  |
      |             |  |  |
      |   X------------+  |  Header: 2.05 (T=NON, Code=2.05, MID=0x01a0)
      |      2.05   |  |  |   Token: 0x86
      |             |  |  |   Payload: "20.9 C"
      |             |  |  |
      |             |  |  |
      |&lt;------------------+  Header: 4.04 (T=NON, Code=4.04, MID=0x952a)
      |      4.04   |  |  |   Token: 0x86
      |             |  |  |

      Figure 23: Non-confirmable Request (Multicast); Non-confirmable
                                 Response

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/Appendix%20B.%20%20URI%20Examples"></a><a class="selflink" href="#appendix-B" name="appendix-B">Appendix B</a>.  URI Examples</span>

   The following examples demonstrate different sets of Uri options, and
   the result after constructing an URI from them.  In addition to the
   options, <a href="#section-6.5">Section 6.5</a> refers to the destination IP address and port,
   but not all paths of the algorithm cause the destination IP address
   and port to be included in the URI.

   o  Input:

         Destination IP Address = [2001:db8::2:1]
         Destination UDP Port = 5683






<span class="grey">Shelby, et al.               Standards Track                  [Page 110]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-111" id="page-111" name="page-111"> </a>
<span class="grey"><a href="rfc7252.html">RFC 7252</a>       The Constrained Application Protocol (CoAP)     June 2014</span>


      Output:

         coap://[2001:db8::2:1]/

   o  Input:

         Destination IP Address = [2001:db8::2:1]
         Destination UDP Port = 5683
         Uri-Host = "example.net"

      Output:

         coap://example.net/

   o  Input:

         Destination IP Address = [2001:db8::2:1]
         Destination UDP Port = 5683
         Uri-Host = "example.net"
         Uri-Path = ".well-known"
         Uri-Path = "core"

      Output:

         coap://example.net/.well-known/core

   o  Input:

         Destination IP Address = [2001:db8::2:1]
         Destination UDP Port = 5683
         Uri-Host = "xn--18j4d.example"
         Uri-Path = the string composed of the Unicode characters U+3053
         U+3093 U+306b U+3061 U+306f, usually represented in UTF-8 as
         E38193E38293E381ABE381A1E381AF hexadecimal

      Output:

         coap://xn--18j4d.example/
         %E3%81%93%E3%82%93%E3%81%AB%E3%81%A1%E3%81%AF

         (The line break has been inserted for readability; it is not
         part of the URI.)









<span class="grey">Shelby, et al.               Standards Track                  [Page 111]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-112" id="page-112" name="page-112"> </a>
<span class="grey"><a href="rfc7252.html">RFC 7252</a>       The Constrained Application Protocol (CoAP)     June 2014</span>


   o  Input:

         Destination IP Address = 198.51.100.1
         Destination UDP Port = 61616
         Uri-Path = ""
         Uri-Path = "/"
         Uri-Path = ""
         Uri-Path = ""
         Uri-Query = "//"
         Uri-Query = "?&amp;"

      Output:

         coap://198.51.100.1:61616//%2F//?%2F%2F&amp;?%26

Authors' Addresses

   Zach Shelby
   ARM
   150 Rose Orchard
   San Jose, CA  95134
   USA

   Phone: +1-408-203-9434
   EMail: zach.shelby@arm.com


   Klaus Hartke
   Universitaet Bremen TZI
   Postfach 330440
   Bremen  D-28359
   Germany

   Phone: +49-421-218-63905
   EMail: hartke@tzi.org


   Carsten Bormann
   Universitaet Bremen TZI
   Postfach 330440
   Bremen  D-28359
   Germany

   Phone: +49-421-218-63921
   EMail: cabo@tzi.org






Shelby, et al.               Standards Track                  [Page 112]

</pre><br/>
    <span class="noprint"><small><small>Html markup produced by rfcmarkup 1.126, available from
      <a href="https://tools.ietf.org/tools/rfcmarkup/">https://tools.ietf.org/tools/rfcmarkup/</a>
    </small></small></span>
  </div>




</body><!-- Mirrored from tools.ietf.org/html/rfc7252 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 06 Mar 2018 23:18:23 GMT --></html>