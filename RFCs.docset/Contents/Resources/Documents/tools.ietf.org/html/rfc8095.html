<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml"><!-- Mirrored from tools.ietf.org/html/rfc8095 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 06 Mar 2018 23:18:18 GMT --><!-- Added by HTTrack --><head><meta content="text/html;charset=utf-8" http-equiv="content-type"/><!-- /Added by HTTrack -->

    <meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
    <meta content="index,follow" name="robots"/>
    <meta content="rfcmarkup version 1.126" name="creator"/>
    <link href="http://purl.org/dc/elements/1.1/" rel="schema.DC"/>
<meta content="draft-fairhurst-taps-transports" name="DC.Relation.Replaces"/>
<meta content="urn:ietf:rfc:8095" name="DC.Identifier"/>
<meta content="March, 2017" name="DC.Date.Issued"/>
<meta content="Fairhurst, Gorry" name="DC.Creator"/>
<meta content="Trammell, Brian" name="DC.Creator"/>
<meta content="This document describes, surveys, and classifies the protocol
mechanisms provided by existing IETF protocols, as background for
determining a common set of transport services. It examines the
Transmission Control Protocol (TCP), Multipath TCP, the Stream Control
Transmission Protocol (SCTP), the User Datagram Protocol (UDP), UDP-
Lite, the Datagram Congestion Control Protocol (DCCP), the Internet
Control Message Protocol (ICMP), the Real-Time Transport Protocol
(RTP), File Delivery over Unidirectional Transport / Asynchronous
Layered Coding (FLUTE/ALC) for Reliable Multicast, NACK- Oriented
Reliable Multicast (NORM), Transport Layer Security (TLS), Datagram
TLS (DTLS), and the Hypertext Transport Protocol (HTTP), when HTTP is
used as a pseudotransport. This survey provides background for the
definition of transport services within the TAPS working group." name="DC.Description.Abstract"/>
<meta content="Services Provided by IETF Transport Protocols and Congestion Control Mechanisms" name="DC.Title"/>

    <link href="https://tools.ietf.org/images/rfc.png" rel="icon" type="image/png"/>
    <link href="https://tools.ietf.org/images/rfc.png" rel="shortcut icon" type="image/png"/>
    <title>RFC 8095 - Services Provided by IETF Transport Protocols and Congestion Control Mechanisms</title>
    
    
    <style type="text/css">
	@media only screen 
	  and (min-width: 992px)
	  and (max-width: 1199px) {
	    body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 768px)
	  and (max-width: 991px) {
            body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 480px)
	  and (max-width: 767px) {
            body { font-size: 11pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (max-width: 479px) {
            body { font-size: 8pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-device-width : 375px) 
	  and (max-device-width : 667px) {
            body { font-size: 9.5pt; }
            div.content { width: 96ex; margin: 0 1px; }
        }
	@media only screen 
	  and (min-device-width: 1200px) {
            body { font-size: 10pt; margin: 0 4em; }
            div.content { width: 96ex; margin: 0; }
        }
        h1, h2, h3, h4, h5, h6, .h1, .h2, .h3, .h4, .h5, .h6 {
	    font-weight: bold;
            line-height: 0pt;
            display: inline;
            white-space: pre;
            font-family: monospace;
            font-size: 1em;
	    font-weight: bold;
        }
        pre {
            font-size: 1em;
            margin-top: 0px;
            margin-bottom: 0px;
        }
	.pre {
	    white-space: pre;
	    font-family: monospace;
	}
	.header{
	    font-weight: bold;
	}
        .newpage {
            page-break-before: always;
        }
        .invisible {
            text-decoration: none;
            color: white;
        }
        a.selflink {
          color: black;
          text-decoration: none;
        }
        @media print {
            body {
                font-family: monospace;
                font-size: 10.5pt;
            }
            h1, h2, h3, h4, h5, h6 {
                font-size: 1em;
            }
        
            a:link, a:visited {
                color: inherit;
                text-decoration: none;
            }
            .noprint {
                display: none;
            }
        }
	@media screen {
	    .grey, .grey a:link, .grey a:visited {
		color: #777;
	    }
            .docinfo {
                background-color: #EEE;
            }
            .top {
                border-top: 7px solid #EEE;
            }
            .bgwhite  { background-color: white; }
            .bgred    { background-color: #F44; }
            .bggrey   { background-color: #666; }
            .bgbrown  { background-color: #840; }            
            .bgorange { background-color: #FA0; }
            .bgyellow { background-color: #EE0; }
            .bgmagenta{ background-color: #F4F; }
            .bgblue   { background-color: #66F; }
            .bgcyan   { background-color: #4DD; }
            .bggreen  { background-color: #4F4; }

            .legend   { font-size: 90%; }
            .cplate   { font-size: 70%; border: solid grey 1px; }
	}
    </style>
    <!--[if IE]>
    <style>
    body {
       font-size: 13px;
       margin: 10px 10px;
    }
    </style>
    <![endif]-->

    <script type="text/javascript"><!--
    function addHeaderTags() {
	var spans = document.getElementsByTagName("span");
	for (var i=0; i < spans.length; i++) {
	    var elem = spans[i];
	    if (elem) {
		var level = elem.getAttribute("class");
                if (level == "h1" || level == "h2" || level == "h3" || level == "h4" || level == "h5" || level == "h6") {
                    elem.innerHTML = "<"+level+">"+elem.innerHTML+"</"+level+">";		
                }
	    }
	}
    }
    var legend_html = "Colour legend:<br />      <table>         <tr><td>Unknown:</td>                   <td><span class='cplate bgwhite'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft:</td>                     <td><span class='cplate bgred'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Informational:</td>             <td><span class='cplate bgorange'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Experimental:</td>              <td><span class='cplate bgyellow'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Best Common Practice:</td>      <td><span class='cplate bgmagenta'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Proposed Standard:</td>         <td><span class='cplate bgblue'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft Standard (old designation):</td> <td><span class='cplate bgcyan'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Internet Standard:</td>         <td><span class='cplate bggreen'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Historic:</td>                  <td><span class='cplate bggrey'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Obsolete:</td>                  <td><span class='cplate bgbrown'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>     </table>";
    function showElem(id) {
        var elem = document.getElementById(id);
        elem.innerHTML = eval(id+"_html");
        elem.style.visibility='visible';
    }
    function hideElem(id) {
        var elem = document.getElementById(id);
        elem.style.visibility='hidden';        
        elem.innerHTML = "";
    }
    // -->
    </script>
</head>
<body onload="addHeaderTags()">
  <div class="content">
   <div style="height: 13px;">
      <div class="pre noprint docinfo bgorange" onclick="showElem('legend');" onmouseout="hideElem('legend')" onmouseover="this.style.cursor='pointer';" style="height: 6px; position: absolute;" title="Click for colour legend.">                                                                        </div>
      <div class="docinfo noprint pre legend" id="legend" onmouseout="hideElem('legend');" onmouseover="showElem('legend');" style="position:absolute; top: 4px; left: 4ex; visibility:hidden; background-color: white; padding: 4px 9px 5px 7px; border: solid #345 1px; ">
      </div>
   </div>
<span class="pre noprint docinfo top">[<a href="index.html" title="Document search and retrieval page">Docs</a>] [<a href="https://tools.ietf.org/rfc/rfc8095.txt" title="Plaintext version of this document">txt</a>|<a href="https://tools.ietf.org/pdf/rfc8095" title="PDF version of this document">pdf</a>] [<a href="https://tools.ietf.org/html/draft-ietf-taps-transports" title="draft-ietf-taps-transports">draft-ietf-taps...</a>] [<a href="https://datatracker.ietf.org/doc/rfc8095" title="IESG Datatracker information for this document">Tracker</a>] [<a href="https://tools.ietf.org/rfcdiff?difftype=--hwdiff&amp;url2=rfc8095" title="Inline diff (wdiff)">Diff1</a>] [<a href="https://tools.ietf.org/rfcdiff?url2=rfc8095" title="Side-by-side diff">Diff2</a>]         </span><br/>
<span class="pre noprint docinfo">                                                                        </span><br/>
<span class="pre noprint docinfo">                                                           INFORMATIONAL</span><br/>
<span class="pre noprint docinfo">                                                                        </span><br/>
<pre>Internet Engineering Task Force (IETF)                 G. Fairhurst, Ed.
Request for Comments: 8095                        University of Aberdeen
Category: Informational                                 B. Trammell, Ed.
ISSN: 2070-1721                                       M. Kuehlewind, Ed.
                                                              ETH Zurich
                                                              March 2017


                          <span class="h1">Services Provided by</span>
       <span class="h1">IETF Transport Protocols and Congestion Control Mechanisms</span>

Abstract

   This document describes, surveys, and classifies the protocol
   mechanisms provided by existing IETF protocols, as background for
   determining a common set of transport services.  It examines the
   Transmission Control Protocol (TCP), Multipath TCP, the Stream
   Control Transmission Protocol (SCTP), the User Datagram Protocol
   (UDP), UDP-Lite, the Datagram Congestion Control Protocol (DCCP), the
   Internet Control Message Protocol (ICMP), the Real-Time Transport
   Protocol (RTP), File Delivery over Unidirectional Transport /
   Asynchronous Layered Coding (FLUTE/ALC) for Reliable Multicast, NACK-
   Oriented Reliable Multicast (NORM), Transport Layer Security (TLS),
   Datagram TLS (DTLS), and the Hypertext Transport Protocol (HTTP),
   when HTTP is used as a pseudotransport.  This survey provides
   background for the definition of transport services within the TAPS
   working group.

Status of This Memo

   This document is not an Internet Standards Track specification; it is
   published for informational purposes.

   This document is a product of the Internet Engineering Task Force
   (IETF).  It represents the consensus of the IETF community.  It has
   received public review and has been approved for publication by the
   Internet Engineering Steering Group (IESG).  Not all documents
   approved by the IESG are a candidate for any level of Internet
   Standard; see <a href="rfc7841.html#section-2">Section 2 of RFC 7841</a>.

   Information about the current status of this document, any errata,
   and how to provide feedback on it may be obtained at
   <a href="http://www.rfc-editor.org/info/rfc8095">http://www.rfc-editor.org/info/rfc8095</a>.








<span class="grey">Fairhurst, et al.             Informational                     [Page 1]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-2" id="page-2" name="page-2"> </a>
<span class="grey"><a href="rfc8095.html">RFC 8095</a>                   Transport Services                 March 2017</span>


Copyright Notice

   Copyright (c) 2017 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to <a href="https://tools.ietf.org/html/bcp78">BCP 78</a> and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (<a href="http://trustee.ietf.org/license-info">http://trustee.ietf.org/license-info</a>) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.

Table of Contents

   <a href="#section-1">1</a>. Introduction ....................................................<a href="#page-4">4</a>
      <a href="#section-1.1">1.1</a>. Overview of Transport Features .............................<a href="#page-4">4</a>
   <a href="#section-2">2</a>. Terminology .....................................................<a href="#page-5">5</a>
   <a href="#section-3">3</a>. Existing Transport Protocols ....................................<a href="#page-6">6</a>
      <a href="#section-3.1">3.1</a>. Transport Control Protocol (TCP) ...........................<a href="#page-6">6</a>
           <a href="#section-3.1.1">3.1.1</a>. Protocol Description ................................<a href="#page-6">6</a>
           <a href="#section-3.1.2">3.1.2</a>. Interface Description ...............................<a href="#page-8">8</a>
           <a href="#section-3.1.3">3.1.3</a>. Transport Features ..................................<a href="#page-9">9</a>
      <a href="#section-3.2">3.2</a>. Multipath TCP (MPTCP) .....................................<a href="#page-10">10</a>
           <a href="#section-3.2.1">3.2.1</a>. Protocol Description ...............................<a href="#page-10">10</a>
           <a href="#section-3.2.2">3.2.2</a>. Interface Description ..............................<a href="#page-10">10</a>
           <a href="#section-3.2.3">3.2.3</a>. Transport Features .................................<a href="#page-11">11</a>
      <a href="#section-3.3">3.3</a>. User Datagram Protocol (UDP) ..............................<a href="#page-11">11</a>
           <a href="#section-3.3.1">3.3.1</a>. Protocol Description ...............................<a href="#page-11">11</a>
           <a href="#section-3.3.2">3.3.2</a>. Interface Description ..............................<a href="#page-12">12</a>
           <a href="#section-3.3.3">3.3.3</a>. Transport Features .................................<a href="#page-13">13</a>
      <a href="#section-3.4">3.4</a>. Lightweight User Datagram Protocol (UDP-Lite) .............<a href="#page-13">13</a>
           <a href="#section-3.4.1">3.4.1</a>. Protocol Description ...............................<a href="#page-13">13</a>
           <a href="#section-3.4.2">3.4.2</a>. Interface Description ..............................<a href="#page-14">14</a>
           <a href="#section-3.4.3">3.4.3</a>. Transport Features .................................<a href="#page-14">14</a>
      <a href="#section-3.5">3.5</a>. Stream Control Transmission Protocol (SCTP) ...............<a href="#page-14">14</a>
           <a href="#section-3.5.1">3.5.1</a>. Protocol Description ...............................<a href="#page-15">15</a>
           <a href="#section-3.5.2">3.5.2</a>. Interface Description ..............................<a href="#page-17">17</a>
           <a href="#section-3.5.3">3.5.3</a>. Transport Features .................................<a href="#page-19">19</a>
      <a href="#section-3.6">3.6</a>. Datagram Congestion Control Protocol (DCCP) ...............<a href="#page-20">20</a>
           <a href="#section-3.6.1">3.6.1</a>. Protocol Description ...............................<a href="#page-21">21</a>
           <a href="#section-3.6.2">3.6.2</a>. Interface Description ..............................<a href="#page-22">22</a>
           <a href="#section-3.6.3">3.6.3</a>. Transport Features .................................<a href="#page-22">22</a>






<span class="grey">Fairhurst, et al.             Informational                     [Page 2]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-3" id="page-3" name="page-3"> </a>
<span class="grey"><a href="rfc8095.html">RFC 8095</a>                   Transport Services                 March 2017</span>


      3.7. Transport Layer Security (TLS) and Datagram TLS
           (DTLS) as a Pseudotransport ...............................<a href="#page-23">23</a>
           <a href="#section-3.7.1">3.7.1</a>. Protocol Description ...............................<a href="#page-23">23</a>
           <a href="#section-3.7.2">3.7.2</a>. Interface Description ..............................<a href="#page-24">24</a>
           <a href="#section-3.7.3">3.7.3</a>. Transport Features .................................<a href="#page-25">25</a>
      <a href="#section-3.8">3.8</a>. Real-Time Transport Protocol (RTP) ........................<a href="#page-26">26</a>
           <a href="#section-3.8.1">3.8.1</a>. Protocol Description ...............................<a href="#page-26">26</a>
           <a href="#section-3.8.2">3.8.2</a>. Interface Description ..............................<a href="#page-27">27</a>
           <a href="#section-3.8.3">3.8.3</a>. Transport Features .................................<a href="#page-27">27</a>
      3.9. Hypertext Transport Protocol (HTTP) over TCP as a
           Pseudotransport ...........................................<a href="#page-28">28</a>
           <a href="#section-3.9.1">3.9.1</a>. Protocol Description ...............................<a href="#page-28">28</a>
           <a href="#section-3.9.2">3.9.2</a>. Interface Description ..............................<a href="#page-29">29</a>
           <a href="#section-3.9.3">3.9.3</a>. Transport Features .................................<a href="#page-30">30</a>
      3.10. File Delivery over Unidirectional Transport /
            Asynchronous Layered Coding (FLUTE/ALC) for
            Reliable Multicast .......................................<a href="#page-31">31</a>
           <a href="#section-3.10.1">3.10.1</a>. Protocol Description ..............................<a href="#page-31">31</a>
           <a href="#section-3.10.2">3.10.2</a>. Interface Description .............................<a href="#page-33">33</a>
           <a href="#section-3.10.3">3.10.3</a>. Transport Features ................................<a href="#page-33">33</a>
      <a href="#section-3.11">3.11</a>. NACK-Oriented Reliable Multicast (NORM) ..................<a href="#page-34">34</a>
           <a href="#section-3.11.1">3.11.1</a>. Protocol Description ..............................<a href="#page-34">34</a>
           <a href="#section-3.11.2">3.11.2</a>. Interface Description .............................<a href="#page-35">35</a>
           <a href="#section-3.11.3">3.11.3</a>. Transport Features ................................<a href="#page-36">36</a>
      <a href="#section-3.12">3.12</a>. Internet Control Message Protocol (ICMP) .................<a href="#page-36">36</a>
           <a href="#section-3.12.1">3.12.1</a>. Protocol Description ..............................<a href="#page-37">37</a>
           <a href="#section-3.12.2">3.12.2</a>. Interface Description .............................<a href="#page-37">37</a>
           <a href="#section-3.12.3">3.12.3</a>. Transport Features ................................<a href="#page-38">38</a>
   <a href="#section-4">4</a>. Congestion Control .............................................<a href="#page-38">38</a>
   <a href="#section-5">5</a>. Transport Features .............................................<a href="#page-39">39</a>
   <a href="#section-6">6</a>. IANA Considerations ............................................<a href="#page-42">42</a>
   <a href="#section-7">7</a>. Security Considerations ........................................<a href="#page-42">42</a>
   <a href="#section-8">8</a>. Informative References .........................................<a href="#page-42">42</a>
   Acknowledgments ...................................................<a href="#page-53">53</a>
   Contributors ......................................................<a href="#page-53">53</a>
   Authors' Addresses ................................................<a href="#page-54">54</a>















<span class="grey">Fairhurst, et al.             Informational                     [Page 3]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-4" id="page-4" name="page-4"> </a>
<span class="grey"><a href="rfc8095.html">RFC 8095</a>                   Transport Services                 March 2017</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/1.%20%20Introduction"></a><a class="selflink" href="#section-1" name="section-1">1</a>.  Introduction</span>

   Internet applications make use of the services provided by a
   transport protocol, such as TCP (a reliable, in-order stream
   protocol) or UDP (an unreliable datagram protocol).  We use the term
   "transport service" to mean the end-to-end service provided to an
   application by the transport layer.  That service can only be
   provided correctly if information about the intended usage is
   supplied from the application.  The application may determine this
   information at design time, compile time, or run time, and may
   include guidance on whether a feature is required, a preference by
   the application, or something in between.  Examples of features of
   transport services are reliable delivery, ordered delivery, content
   privacy to in-path devices, and integrity protection.

   The IETF has defined a wide variety of transport protocols beyond TCP
   and UDP, including SCTP, DCCP, MPTCP, and UDP-Lite.  Transport
   services may be provided directly by these transport protocols or
   layered on top of them using protocols such as WebSockets (which runs
   over TCP), RTP (over TCP or UDP) or WebRTC data channels (which run
   over SCTP over DTLS over UDP or TCP).  Services built on top of UDP
   or UDP-Lite typically also need to specify additional mechanisms,
   including a congestion control mechanism (such as NewReno [<a href="rfc6582.html" title="&quot;The NewReno Modification to TCP's Fast Recovery Algorithm&quot;">RFC6582</a>],
   TCP-Friendly Rate Control (TFRC) [<a href="rfc5348.html" title='"TCP Friendly Rate Control (TFRC): Protocol Specification"'>RFC5348</a>], or Low Extra Delay
   Background Transport (LEDBAT) [<a href="rfc6817.html" title='"Low Extra Delay Background Transport (LEDBAT)"'>RFC6817</a>]).  This extends the set of
   available transport services beyond those provided to applications by
   TCP and UDP.

   The transport protocols described in this document provide a basis
   for the definition of transport services provided by common
   protocols, as background for the TAPS working group.  The protocols
   listed here were chosen to help expose as many potential transport
   services as possible and are not meant to be a comprehensive survey
   or classification of all transport protocols.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/1.1.%20%20Overview%20of%20Transport%20Features"></a><a class="selflink" href="#section-1.1" name="section-1.1">1.1</a>.  Overview of Transport Features</span>

   Transport protocols can be differentiated by the features of the
   services they provide.

   Some of these provided features are closely related to basic control
   function that a protocol needs to work over a network path, such as
   addressing.  The number of participants in a given association also
   determines its applicability: a connection can be between endpoints
   (unicast), to one of multiple endpoints (anycast), or simultaneously
   to multiple endpoints (multicast).  Unicast protocols usually support
   bidirectional communication, while multicast is generally




<span class="grey">Fairhurst, et al.             Informational                     [Page 4]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-5" id="page-5" name="page-5"> </a>
<span class="grey"><a href="rfc8095.html">RFC 8095</a>                   Transport Services                 March 2017</span>


   unidirectional.  Another feature is whether a transport requires a
   control exchange across the network at setup (e.g., TCP) or whether
   it is connectionless (e.g., UDP).

   For packet delivery itself, reliability and integrity protection,
   ordering, and framing are basic features.  However, these features
   are implemented with different levels of assurance in different
   protocols.  As an example, a transport service may provide full
   reliability, with detection of loss and retransmission (e.g., TCP).
   SCTP offers a message-based service that can provide full or partial
   reliability and allows the protocol to minimize the head-of-line
   blocking due to the support of ordered and unordered message delivery
   within multiple streams.  UDP-Lite and DCCP can provide partial
   integrity protection to enable corruption tolerance.

   Usually, a protocol has been designed to support one specific type of
   delivery/framing: either data needs to be divided into transmission
   units based on network packets (datagram service) or a data stream is
   segmented and re-combined across multiple packets (stream service).
   Whole objects such as files are handled accordingly.  This decision
   strongly influences the interface that is provided to the upper
   layer.

   In addition, transport protocols offer a certain support for
   transmission control.  For example, a transport service can provide
   flow control to allow a receiver to regulate the transmission rate of
   a sender.  Further, a transport service can provide congestion
   control (see <a href="#section-4">Section 4</a>).  As an example, TCP and SCTP provide
   congestion control for use in the Internet, whereas UDP leaves this
   function to the upper-layer protocol that uses UDP.

   Security features are often provided independently of the transport
   protocol, via Transport Layer Security (TLS) (see <a href="#section-3.7">Section 3.7</a>) or by
   the application-layer protocol itself.  The security properties TLS
   provides to the application (such as confidentiality, integrity, and
   authenticity) are also features of the transport layer, even though
   they are often presently implemented in a separate protocol.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/2.%20%20Terminology"></a><a class="selflink" href="#section-2" name="section-2">2</a>.  Terminology</span>

   The following terms are used throughout this document and in
   subsequent documents produced by the TAPS working group that describe
   the composition and decomposition of transport services.

   Transport Feature:  a specific end-to-end feature that the transport
      layer provides to an application.  Examples include
      confidentiality, reliable delivery, ordered delivery, message-
      versus-stream orientation, etc.



<span class="grey">Fairhurst, et al.             Informational                     [Page 5]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-6" id="page-6" name="page-6"> </a>
<span class="grey"><a href="rfc8095.html">RFC 8095</a>                   Transport Services                 March 2017</span>


   Transport Service:  a set of transport features, without an
      association to any given framing protocol, that provides a
      complete service to an application.

   Transport Protocol:  an implementation that provides one or more
      different transport services using a specific framing and header
      format on the wire.

   Application:  an entity that uses the transport layer for end-to-end
      delivery data across the network (this may also be an upper-layer
      protocol or tunnel encapsulation).

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/3.%20%20Existing%20Transport%20Protocols"></a><a class="selflink" href="#section-3" name="section-3">3</a>.  Existing Transport Protocols</span>

   This section provides a list of known IETF transport protocols and
   transport protocol frameworks.  It does not make an assessment about
   whether specific implementations of protocols are fully compliant to
   current IETF specifications.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.1.%20%20Transport%20Control%20Protocol%20%28TCP%29"></a><a class="selflink" href="#section-3.1" name="section-3.1">3.1</a>.  Transport Control Protocol (TCP)</span>

   TCP is an IETF Standards Track transport protocol.  [<a href="rfc793.html" title='"Transmission Control Protocol"'>RFC793</a>]
   introduces TCP as follows:

      The Transmission Control Protocol (TCP) is intended for use as a
      highly reliable host-to-host protocol between hosts in packet-
      switched computer communication networks, and in interconnected
      systems of such networks.

   Since its introduction, TCP has become the default connection-
   oriented, stream-based transport protocol in the Internet.  It is
   widely implemented by endpoints and widely used by common
   applications.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/3.1.1.%20%20Protocol%20Description"></a><a class="selflink" href="#section-3.1.1" name="section-3.1.1">3.1.1</a>.  Protocol Description</span>

   TCP is a connection-oriented protocol that provides a three-way
   handshake to allow a client and server to set up a connection and
   negotiate features and provides mechanisms for orderly completion and
   immediate teardown of a connection [<a href="rfc793.html" title='"Transmission Control Protocol"'>RFC793</a>] [<a href="#ref-TCP-SPEC" title='"Transmission Control Protocol Specification"'>TCP-SPEC</a>].  TCP is
   defined by a family of RFCs (see [<a href="rfc7414.html" title='"A Roadmap for Transmission Control Protocol (TCP) Specification Documents"'>RFC7414</a>]).

   TCP provides multiplexing to multiple sockets on each host using port
   numbers.  A similar approach is adopted by other IETF-defined
   transports.  An active TCP session is identified by its four-tuple of
   local and remote IP addresses and local and remote port numbers.  The
   destination port during connection setup is often used to indicate
   the requested service.



<span class="grey">Fairhurst, et al.             Informational                     [Page 6]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-7" id="page-7" name="page-7"> </a>
<span class="grey"><a href="rfc8095.html">RFC 8095</a>                   Transport Services                 March 2017</span>


   TCP partitions a continuous stream of bytes into segments, sized to
   fit in IP packets based on a negotiated maximum segment size and
   further constrained by the effective Maximum Transmission Unit (MTU)
   from Path MTU Discovery (PMTUD).  ICMP-based PMTUD [<a href="rfc1191.html" title='"Path MTU discovery"'>RFC1191</a>]
   [<a href="rfc1981.html" title='"Path MTU Discovery for IP version 6"'>RFC1981</a>] as well as Packetization Layer PMTUD (PLPMTUD) [<a href="rfc4821.html" title='"Packetization Layer Path MTU Discovery"'>RFC4821</a>]
   have been defined by the IETF.

   Each byte in the stream is identified by a sequence number.  The
   sequence number is used to order segments on receipt, to identify
   segments in acknowledgments, and to detect unacknowledged segments
   for retransmission.  This is the basis of the reliable, ordered
   delivery of data in a TCP stream.  TCP Selective Acknowledgment
   (SACK) [<a href="rfc2018.html" title='"TCP Selective Acknowledgment Options"'>RFC2018</a>] extends this mechanism by making it possible to
   provide earlier identification of which segments are missing,
   allowing faster retransmission.  SACK-based methods (e.g., Duplicate
   Selective ACK) can also result in less spurious retransmission.

   Receiver flow control is provided by a sliding window, which limits
   the amount of unacknowledged data that can be outstanding at a given
   time.  The window scale option [<a href="rfc7323.html" title='"TCP Extensions for High Performance"'>RFC7323</a>] allows a receiver to use
   windows greater than 64 KB.

   All TCP senders provide congestion control, such as that described in
   [<a href="rfc5681.html" title='"TCP Congestion Control"'>RFC5681</a>].  TCP uses a sequence number with a sliding receiver window
   for flow control.  The TCP congestion control mechanism also utilizes
   this TCP sequence number to manage a separate congestion window
   [<a href="rfc5681.html" title='"TCP Congestion Control"'>RFC5681</a>].  The sending window at a given point in time is the
   minimum of the receiver window and the congestion window.  The
   congestion window is increased in the absence of congestion and
   decreased if congestion is detected.  Often, loss is implicitly
   handled as a congestion indication, which is detected in TCP (also as
   input for retransmission handling) based on two mechanisms: a
   retransmission timer with exponential back-off or the reception of
   three acknowledgments for the same segment, so called "duplicated
   ACKs" (fast retransmit).  In addition, Explicit Congestion
   Notification (ECN) [<a href="rfc3168.html" title='"The Addition of Explicit Congestion Notification (ECN) to IP"'>RFC3168</a>] can be used in TCP and, if supported by
   both endpoints, allows a network node to signal congestion without
   inducing loss.  Alternatively, a delay-based congestion control
   scheme that reacts to changes in delay as an early indication of
   congestion can be used in TCP.  This is further described in
   <a href="#section-4">Section 4</a>.  Examples of different kinds of congestion control schemes
   are provided in <a href="#section-4">Section 4</a>.

   TCP protocol instances can be extended (see [<a href="rfc7414.html" title='"A Roadmap for Transmission Control Protocol (TCP) Specification Documents"'>RFC7414</a>]).  Some
   protocol features may also be tuned to optimize for a specific
   deployment scenario.  Some features are sender-side only, requiring
   no negotiation with the receiver; some are receiver-side only; and
   some are explicitly negotiated during connection setup.



<span class="grey">Fairhurst, et al.             Informational                     [Page 7]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-8" id="page-8" name="page-8"> </a>
<span class="grey"><a href="rfc8095.html">RFC 8095</a>                   Transport Services                 March 2017</span>


   TCP may buffer data, e.g., to optimize processing or capacity usage.
   TCP therefore provides mechanisms to control this, including an
   optional "PUSH" function [<a href="rfc793.html" title='"Transmission Control Protocol"'>RFC793</a>] that explicitly requests the
   transport service not to delay data.  By default, TCP segment
   partitioning uses Nagle's algorithm [<a href="#ref-TCP-SPEC" title='"Transmission Control Protocol Specification"'>TCP-SPEC</a>] to buffer data at the
   sender into large segments, potentially incurring sender-side
   buffering delay; this algorithm can be disabled by the sender to
   transmit more immediately, e.g., to reduce latency for interactive
   sessions.

   TCP provides an "urgent data" function for limited out-of-order
   delivery of the data.  This function is deprecated [<a href="rfc6093.html" title='"On the Implementation of the TCP Urgent Mechanism"'>RFC6093</a>].

   A TCP Reset (RST) control message may be used to force a TCP endpoint
   to close a session [<a href="rfc793.html" title='"Transmission Control Protocol"'>RFC793</a>], aborting the connection.

   A mandatory checksum provides a basic integrity check against
   misdelivery and data corruption over the entire packet.  Applications
   that require end-to-end integrity of data are recommended to include
   a stronger integrity check of their payload data.  The TCP checksum
   [<a href="rfc1071.html" title='"Computing the Internet checksum"'>RFC1071</a>] [<a href="rfc2460.html" title='"Internet Protocol, Version 6 (IPv6) Specification"'>RFC2460</a>] does not support partial payload protection (as
   in DCCP/UDP-Lite).

   TCP supports only unicast connections.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/3.1.2.%20%20Interface%20Description"></a><a class="selflink" href="#section-3.1.2" name="section-3.1.2">3.1.2</a>.  Interface Description</span>

   The User/TCP Interface defined in [<a href="rfc793.html" title='"Transmission Control Protocol"'>RFC793</a>] provides six user
   commands: Open, Send, Receive, Close, Status, and Abort.  This
   interface does not describe configuration of TCP options or
   parameters aside from the use of the PUSH and URGENT flags.

   [<a id="ref-RFC1122" name="ref-RFC1122">RFC1122</a>] describes extensions of the TCP/application-layer interface
   for:

   o  reporting soft errors such as reception of ICMP error messages,
      extensive retransmission, or urgent pointer advance,

   o  providing a possibility to specify the Differentiated Services
      Code Point (DSCP) [<a href="rfc3260.html" title='"New Terminology and Clarifications for Diffserv"'>RFC3260</a>] (formerly, the Type-of-Service (TOS))
      for segments,

   o  providing a flush call to empty the TCP send queue, and

   o  multihoming support.






<span class="grey">Fairhurst, et al.             Informational                     [Page 8]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-9" id="page-9" name="page-9"> </a>
<span class="grey"><a href="rfc8095.html">RFC 8095</a>                   Transport Services                 March 2017</span>


   In API implementations derived from the BSD Sockets API, TCP sockets
   are created using the "SOCK_STREAM" socket type as described in the
   IEEE Portable Operating System Interface (POSIX) Base Specifications
   [<a href="#ref-POSIX" title='"Standard for Information Technology -- Portable Operating System Interface (POSIX(R)) Base Specifications, Issue 7"'>POSIX</a>].  The features used by a protocol instance may be set and
   tuned via this API.  There are currently no documents in the RFC
   Series that describe this interface.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/3.1.3.%20%20Transport%20Features"></a><a class="selflink" href="#section-3.1.3" name="section-3.1.3">3.1.3</a>.  Transport Features</span>

   The transport features provided by TCP are:

   o  connection-oriented transport with feature negotiation and
      application-to-port mapping (implemented using SYN segments and
      the TCP Option field to negotiate features),

   o  unicast transport (though anycast TCP is implemented, at risk of
      instability due to rerouting),

   o  port multiplexing,

   o  unidirectional or bidirectional communication,

   o  stream-oriented delivery in a single stream,

   o  fully reliable delivery (implemented using ACKs sent from the
      receiver to confirm delivery),

   o  error detection (implemented using a segment checksum to verify
      delivery to the correct endpoint and integrity of the data and
      options),

   o  segmentation,

   o  data bundling (optional; uses Nagle's algorithm to coalesce data
      sent within the same RTT into full-sized segments),

   o  flow control (implemented using a window-based mechanism where the
      receiver advertises the window that it is willing to buffer), and

   o  congestion control (usually implemented using a window-based
      mechanism and four algorithms for different phases of the
      transmission: slow start, congestion avoidance, fast retransmit,
      and fast recovery [<a href="rfc5681.html" title='"TCP Congestion Control"'>RFC5681</a>]).








<span class="grey">Fairhurst, et al.             Informational                     [Page 9]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-10" id="page-10" name="page-10"> </a>
<span class="grey"><a href="rfc8095.html">RFC 8095</a>                   Transport Services                 March 2017</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.2.%20%20Multipath%20TCP%20%28MPTCP%29"></a><a class="selflink" href="#section-3.2" name="section-3.2">3.2</a>.  Multipath TCP (MPTCP)</span>

   Multipath TCP [<a href="rfc6824.html" title='"TCP Extensions for Multipath Operation with Multiple Addresses"'>RFC6824</a>] is an extension for TCP to support
   multihoming for resilience, mobility, and load balancing.  It is
   designed to be as indistinguishable to middleboxes from non-multipath
   TCP as possible.  It does so by establishing regular TCP flows
   between a pair of source/destination endpoints and multiplexing the
   application's stream over these flows.  Sub-flows can be started over
   IPv4 or IPv6 for the same session.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/3.2.1.%20%20Protocol%20Description"></a><a class="selflink" href="#section-3.2.1" name="section-3.2.1">3.2.1</a>.  Protocol Description</span>

   MPTCP uses TCP options for its control plane.  They are used to
   signal multipath capabilities, as well as to negotiate data sequence
   numbers, advertise other available IP addresses, and establish new
   sessions between pairs of endpoints.

   By multiplexing one byte stream over separate paths, MPTCP can
   achieve a higher throughput than TCP in certain situations.  However,
   if coupled congestion control [<a href="rfc6356.html" title='"Coupled Congestion Control for Multipath Transport Protocols"'>RFC6356</a>] is used, it might limit this
   benefit to maintain fairness to other flows at the bottleneck.  When
   aggregating capacity over multiple paths, and depending on the way
   packets are scheduled on each TCP subflow, additional delay and
   higher jitter might be observed before in-order delivery of data to
   the applications.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/3.2.2.%20%20Interface%20Description"></a><a class="selflink" href="#section-3.2.2" name="section-3.2.2">3.2.2</a>.  Interface Description</span>

   By default, MPTCP exposes the same interface as TCP to the
   application.  [<a href="rfc6897.html" title='"Multipath TCP (MPTCP) Application Interface Considerations"'>RFC6897</a>], however, describes a richer API for MPTCP-
   aware applications.

   This Basic API describes how an application can:

   o  enable or disable MPTCP.

   o  bind a socket to one or more selected local endpoints.

   o  query local and remote endpoint addresses.

   o  get a unique connection identifier (similar to an address-port
      pair for TCP).

   The document also recommends the use of extensions defined for SCTP
   [<a href="rfc6458.html" title='"Sockets API Extensions for the Stream Control Transmission Protocol (SCTP)"'>RFC6458</a>] (see <a href="#section-3.5">Section 3.5</a>) to support multihoming for resilience and
   mobility.





<span class="grey">Fairhurst, et al.             Informational                    [Page 10]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-11" id="page-11" name="page-11"> </a>
<span class="grey"><a href="rfc8095.html">RFC 8095</a>                   Transport Services                 March 2017</span>


<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/3.2.3.%20%20Transport%20Features"></a><a class="selflink" href="#section-3.2.3" name="section-3.2.3">3.2.3</a>.  Transport Features</span>

   As an extension to TCP, MPTCP provides mostly the same features.  By
   establishing multiple sessions between available endpoints, it can
   additionally provide soft failover solutions in the case that one of
   the paths becomes unusable.

   Therefore, the transport features provided by MPTCP in addition to
   TCP are:

   o  multihoming for load balancing, with endpoint multiplexing of a
      single byte stream, using either coupled congestion control or
      throughput maximization,

   o  address family multiplexing (using IPv4 and IPv6 for the same
      session), and

   o  resilience to network failure and/or handover.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.3.%20%20User%20Datagram%20Protocol%20%28UDP%29"></a><a class="selflink" href="#section-3.3" name="section-3.3">3.3</a>.  User Datagram Protocol (UDP)</span>

   The User Datagram Protocol (UDP) [<a href="rfc768.html" title='"User Datagram Protocol"'>RFC768</a>] [<a href="rfc2460.html" title='"Internet Protocol, Version 6 (IPv6) Specification"'>RFC2460</a>] is an IETF
   Standards Track transport protocol.  It provides a unidirectional
   datagram protocol that preserves message boundaries.  It provides no
   error correction, congestion control, or flow control.  It can be
   used to send broadcast datagrams (IPv4) or multicast datagrams (IPv4
   and IPv6), in addition to unicast and anycast datagrams.  IETF
   guidance on the use of UDP is provided in [<a href="rfc8085.html" title='"UDP Usage Guidelines"'>RFC8085</a>].  UDP is widely
   implemented and widely used by common applications, including DNS.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/3.3.1.%20%20Protocol%20Description"></a><a class="selflink" href="#section-3.3.1" name="section-3.3.1">3.3.1</a>.  Protocol Description</span>

   UDP is a connectionless protocol that maintains message boundaries,
   with no connection setup or feature negotiation.  The protocol uses
   independent messages, ordinarily called "datagrams".  It provides
   detection of payload errors and misdelivery of packets to an
   unintended endpoint, both of which result in discard of received
   datagrams, with no indication to the user of the service.

   It is possible to create IPv4 UDP datagrams with no checksum, and
   while this is generally discouraged [<a href="rfc1122.html" title='"Requirements for Internet Hosts - Communication Layers"'>RFC1122</a>] [<a href="rfc8085.html" title='"UDP Usage Guidelines"'>RFC8085</a>], certain
   special cases permit this use.  These datagrams rely on the IPv4
   header checksum to protect from misdelivery to an unintended
   endpoint.  IPv6 does not permit UDP datagrams with no checksum,
   although in certain cases [<a href="rfc6936.html" title='"Applicability Statement for the Use of IPv6 UDP Datagrams with Zero Checksums"'>RFC6936</a>], this rule may be relaxed
   [<a href="rfc6935.html" title='"IPv6 and UDP Checksums for Tunneled Packets"'>RFC6935</a>].





<span class="grey">Fairhurst, et al.             Informational                    [Page 11]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-12" id="page-12" name="page-12"> </a>
<span class="grey"><a href="rfc8095.html">RFC 8095</a>                   Transport Services                 March 2017</span>


   UDP does not provide reliability and does not provide retransmission.
   Messages may be reordered, lost, or duplicated in transit.  Note that
   due to the relatively weak form of checksum used by UDP, applications
   that require end-to-end integrity of data are recommended to include
   a stronger integrity check of their payload data.

   Because UDP provides no flow control, a receiving application that is
   unable to run sufficiently fast, or frequently, may miss messages.
   The lack of congestion handling implies UDP traffic may experience
   loss when using an overloaded path and may cause the loss of messages
   from other protocols (e.g., TCP) when sharing the same network path.

   On transmission, UDP encapsulates each datagram into a single IP
   packet or several IP packet fragments.  This allows a datagram to be
   larger than the effective path MTU.  Fragments are reassembled before
   delivery to the UDP receiver, making this transparent to the user of
   the transport service.  When jumbograms are supported, larger
   messages may be sent without performing fragmentation.

   UDP on its own does not provide support for segmentation, receiver
   flow control, congestion control, PMTUD/PLPMTUD, or ECN.
   Applications that require these features need to provide them on
   their own or use a protocol over UDP that provides them [<a href="rfc8085.html" title='"UDP Usage Guidelines"'>RFC8085</a>].

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/3.3.2.%20%20Interface%20Description"></a><a class="selflink" href="#section-3.3.2" name="section-3.3.2">3.3.2</a>.  Interface Description</span>

   [<a id="ref-RFC768" name="ref-RFC768">RFC768</a>] describes basic requirements for an API for UDP.  Guidance
   on the use of common APIs is provided in [<a href="rfc8085.html" title='"UDP Usage Guidelines"'>RFC8085</a>].

   A UDP endpoint consists of a tuple of (IP address, port number).
   De-multiplexing using multiple abstract endpoints (sockets) on the
   same IP address is supported.  The same socket may be used by a
   single server to interact with multiple clients.  (Note: This
   behavior differs from TCP, which uses a pair of tuples to identify a
   connection).  Multiple server instances (processes) that bind to the
   same socket can cooperate to service multiple clients.  The socket
   implementation arranges to not duplicate the same received unicast
   message to multiple server processes.

   Many operating systems also allow a UDP socket to be "connected",
   i.e., to bind a UDP socket to a specific (remote) UDP endpoint.
   Unlike TCP's connect primitive, for UDP, this is only a local
   operation that serves to simplify the local send/receive functions
   and to filter the traffic for the specified addresses and ports
   [<a href="rfc8085.html" title='"UDP Usage Guidelines"'>RFC8085</a>].






<span class="grey">Fairhurst, et al.             Informational                    [Page 12]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-13" id="page-13" name="page-13"> </a>
<span class="grey"><a href="rfc8095.html">RFC 8095</a>                   Transport Services                 March 2017</span>


<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/3.3.3.%20%20Transport%20Features"></a><a class="selflink" href="#section-3.3.3" name="section-3.3.3">3.3.3</a>.  Transport Features</span>

   The transport features provided by UDP are:

   o  unicast, multicast, anycast, or IPv4 broadcast transport,

   o  port multiplexing (where a receiving port can be configured to
      receive datagrams from multiple senders),

   o  message-oriented delivery,

   o  unidirectional or bidirectional communication where the
      transmissions in each direction are independent,

   o  non-reliable delivery,

   o  unordered delivery, and

   o  error detection (implemented using a segment checksum to verify
      delivery to the correct endpoint and integrity of the data;
      optional for IPv4 and optional under specific conditions for IPv6
      where all or none of the payload data is protected).

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.4.%20%20Lightweight%20User%20Datagram%20Protocol%20%28UDP-Lite%29"></a><a class="selflink" href="#section-3.4" name="section-3.4">3.4</a>.  Lightweight User Datagram Protocol (UDP-Lite)</span>

   The Lightweight User Datagram Protocol (UDP-Lite) [<a href="rfc3828.html" title='"The Lightweight User Datagram Protocol (UDP-Lite)"'>RFC3828</a>] is an
   IETF Standards Track transport protocol.  It provides a
   unidirectional, datagram protocol that preserves message boundaries.
   IETF guidance on the use of UDP-Lite is provided in [<a href="rfc8085.html" title='"UDP Usage Guidelines"'>RFC8085</a>].  A
   UDP-Lite service may support IPv4 broadcast, multicast, anycast, and
   unicast, as well as IPv6 multicast, anycast, and unicast.

   Examples of use include a class of applications that can derive
   benefit from having partially damaged payloads delivered rather than
   discarded.  One use is to provide header integrity checks but allow
   delivery of corrupted payloads to error-tolerant applications or to
   applications that use some other mechanism to provide payload
   integrity (see [<a href="rfc6936.html" title='"Applicability Statement for the Use of IPv6 UDP Datagrams with Zero Checksums"'>RFC6936</a>]).

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/3.4.1.%20%20Protocol%20Description"></a><a class="selflink" href="#section-3.4.1" name="section-3.4.1">3.4.1</a>.  Protocol Description</span>

   Like UDP, UDP-Lite is a connectionless datagram protocol, with no
   connection setup or feature negotiation.  It changes the semantics of
   the UDP Payload Length field to that of a Checksum Coverage Length
   field and is identified by a different IP protocol/next-header value.
   The Checksum Coverage Length field specifies the intended checksum
   coverage, with the remaining unprotected part of the payload called




<span class="grey">Fairhurst, et al.             Informational                    [Page 13]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-14" id="page-14" name="page-14"> </a>
<span class="grey"><a href="rfc8095.html">RFC 8095</a>                   Transport Services                 March 2017</span>


   the "error-insensitive part".  Therefore, applications using UDP-Lite
   cannot make assumptions regarding the correctness of the data
   received in the insensitive part of the UDP-Lite payload.

   Otherwise, UDP-Lite is semantically identical to UDP.  In the same
   way as for UDP, mechanisms for receiver flow control, congestion
   control, PMTU or PLPMTU discovery, support for ECN, etc., need to be
   provided by upper-layer protocols [<a href="rfc8085.html" title='"UDP Usage Guidelines"'>RFC8085</a>].

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/3.4.2.%20%20Interface%20Description"></a><a class="selflink" href="#section-3.4.2" name="section-3.4.2">3.4.2</a>.  Interface Description</span>

   There is no API currently specified in the RFC Series, but guidance
   on use of common APIs is provided in [<a href="rfc8085.html" title='"UDP Usage Guidelines"'>RFC8085</a>].

   The interface of UDP-Lite differs from that of UDP by the addition of
   a single (socket) option that communicates a checksum coverage length
   value.  The checksum coverage may also be made visible to the
   application via the UDP-Lite MIB module [<a href="rfc5097.html" title='"MIB for the UDP-Lite protocol"'>RFC5097</a>].

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/3.4.3.%20%20Transport%20Features"></a><a class="selflink" href="#section-3.4.3" name="section-3.4.3">3.4.3</a>.  Transport Features</span>

   The transport features provided by UDP-Lite are:

   o  unicast, multicast, anycast, or IPv4 broadcast transport (same as
      for UDP),

   o  port multiplexing (same as for UDP),

   o  message-oriented delivery (same as for UDP),

   o  unidirectional or bidirectional communication where the
      transmissions in each direction are independent (same as for UDP),

   o  non-reliable delivery (same as for UDP),

   o  non-ordered delivery (same as for UDP), and

   o  partial or full payload error detection (where the Checksum
      Coverage field indicates the size of the payload data covered by
      the checksum).

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.5.%20%20Stream%20Control%20Transmission%20Protocol%20%28SCTP%29"></a><a class="selflink" href="#section-3.5" name="section-3.5">3.5</a>.  Stream Control Transmission Protocol (SCTP)</span>

   SCTP is a message-oriented IETF Standards Track transport protocol.
   The base protocol is specified in [<a href="rfc4960.html" title='"Stream Control Transmission Protocol"'>RFC4960</a>].  It supports multihoming
   and path failover to provide resilience to path failures.  An SCTP
   association has multiple streams in each direction, providing
   in-sequence delivery of user messages within each stream.  This



<span class="grey">Fairhurst, et al.             Informational                    [Page 14]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-15" id="page-15" name="page-15"> </a>
<span class="grey"><a href="rfc8095.html">RFC 8095</a>                   Transport Services                 March 2017</span>


   allows it to minimize head-of-line blocking.  SCTP supports multiple
   stream- scheduling schemes controlling stream multiplexing, including
   priority and fair weighting schemes.

   SCTP was originally developed for transporting telephony signaling
   messages and is deployed in telephony signaling networks, especially
   in mobile telephony networks.  It can also be used for other
   services, for example, in the WebRTC framework for data channels.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/3.5.1.%20%20Protocol%20Description"></a><a class="selflink" href="#section-3.5.1" name="section-3.5.1">3.5.1</a>.  Protocol Description</span>

   SCTP is a connection-oriented protocol using a four-way handshake to
   establish an SCTP association and a three-way message exchange to
   gracefully shut it down.  It uses the same port number concept as
   DCCP, TCP, UDP, and UDP-Lite.  SCTP only supports unicast.

   SCTP uses the 32-bit CRC32c for protecting SCTP packets against bit
   errors and misdelivery of packets to an unintended endpoint.  This is
   stronger than the 16-bit checksums used by TCP or UDP.  However,
   partial payload checksum coverage as provided by DCCP or UDP-Lite is
   not supported.

   SCTP has been designed with extensibility in mind.  A common header
   is followed by a sequence of chunks.  [<a href="rfc4960.html" title='"Stream Control Transmission Protocol"'>RFC4960</a>] defines how a
   receiver processes chunks with an unknown chunk type.  The support of
   extensions can be negotiated during the SCTP handshake.  Currently
   defined extensions include mechanisms for dynamic reconfiguration of
   streams [<a href="rfc6525.html" title='"Stream Control Transmission Protocol (SCTP) Stream Reconfiguration"'>RFC6525</a>] and IP addresses [<a href="rfc5061.html" title='"Stream Control Transmission Protocol (SCTP) Dynamic Address Reconfiguration"'>RFC5061</a>].  Furthermore, the
   extension specified in [<a href="rfc3758.html" title='"Stream Control Transmission Protocol (SCTP) Partial Reliability Extension"'>RFC3758</a>] introduces the concept of partial
   reliability for user messages.

   SCTP provides a message-oriented service.  Multiple small user
   messages can be bundled into a single SCTP packet to improve
   efficiency.  For example, this bundling may be done by delaying user
   messages at the sender, similar to Nagle's algorithm used by TCP.
   User messages that would result in IP packets larger than the MTU
   will be fragmented at the sender and reassembled at the receiver.
   There is no protocol limit on the user message size.  For MTU
   discovery, the same mechanism as for TCP can be used [<a href="rfc1981.html" title='"Path MTU Discovery for IP version 6"'>RFC1981</a>]
   [<a href="rfc4821.html" title='"Packetization Layer Path MTU Discovery"'>RFC4821</a>], as well as utilization of probe packets with padding
   chunks, as defined in [<a href="rfc4820.html" title='"Padding Chunk and Parameter for the Stream Control Transmission Protocol (SCTP)"'>RFC4820</a>].

   [<a id="ref-RFC4960" name="ref-RFC4960">RFC4960</a>] specifies TCP-friendly congestion control to protect the
   network against overload.  SCTP also uses sliding window flow control
   to protect receivers against overflow.  Similar to TCP, SCTP also
   supports delaying acknowledgments.  [<a href="rfc7053.html" title='"SACK- IMMEDIATELY Extension for the Stream Control Transmission Protocol"'>RFC7053</a>] provides a way for the
   sender of user messages to request immediate sending of the
   corresponding acknowledgments.



<span class="grey">Fairhurst, et al.             Informational                    [Page 15]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-16" id="page-16" name="page-16"> </a>
<span class="grey"><a href="rfc8095.html">RFC 8095</a>                   Transport Services                 March 2017</span>


   Each SCTP association has between 1 and 65536 unidirectional streams
   in each direction.  The number of streams can be different in each
   direction.  Every user message is sent on a particular stream.  User
   messages can be sent unordered or ordered upon request by the upper
   layer.  Unordered messages can be delivered as soon as they are
   completely received.  For user messages not requiring fragmentation,
   this minimizes head-of-line blocking.  On the other hand, ordered
   messages sent on the same stream are delivered at the receiver in the
   same order as sent by the sender.

   The base protocol defined in [<a href="rfc4960.html" title='"Stream Control Transmission Protocol"'>RFC4960</a>] does not allow interleaving of
   user messages.  Large messages on one stream can therefore block the
   sending of user messages on other streams.  [<a href="#ref-SCTP-NDATA">SCTP-NDATA</a>] describes a
   method to overcome this limitation.  This document also specifies
   multiple algorithms for the sender-side selection of which streams to
   send data from, supporting a variety of scheduling algorithms
   including priority-based methods.  The stream reconfiguration
   extension defined in [<a href="rfc6525.html" title='"Stream Control Transmission Protocol (SCTP) Stream Reconfiguration"'>RFC6525</a>] allows streams to be reset during the
   lifetime of an association and to increase the number of streams, if
   the number of streams negotiated in the SCTP handshake becomes
   insufficient.

   Each user message sent is delivered to the receiver or, in case of
   excessive retransmissions, the association is terminated in a
   non-graceful way [<a href="rfc4960.html" title='"Stream Control Transmission Protocol"'>RFC4960</a>], similar to TCP behavior.  In addition to
   this reliable transfer, the partial reliability extension [<a href="rfc3758.html" title='"Stream Control Transmission Protocol (SCTP) Partial Reliability Extension"'>RFC3758</a>]
   allows a sender to abandon user messages.  The application can
   specify the policy for abandoning user messages.

   SCTP supports multihoming.  Each SCTP endpoint uses a list of IP
   addresses and a single port number.  These addresses can be any
   mixture of IPv4 and IPv6 addresses.  These addresses are negotiated
   during the handshake, and the address reconfiguration extension
   specified in [<a href="rfc5061.html" title='"Stream Control Transmission Protocol (SCTP) Dynamic Address Reconfiguration"'>RFC5061</a>] in combination with [<a href="rfc4895.html" title='"Authenticated Chunks for the Stream Control Transmission Protocol (SCTP)"'>RFC4895</a>] can be used to
   change these addresses in an authenticated way during the lifetime of
   an SCTP association.  This allows for transport-layer mobility.
   Multiple addresses are used for improved resilience.  If a remote
   address becomes unreachable, the traffic is switched over to a
   reachable one, if one exists.

   For securing user messages, the use of TLS over SCTP has been
   specified in [<a href="rfc3436.html" title='"Transport Layer Security over Stream Control Transmission Protocol"'>RFC3436</a>].  However, this solution does not support all
   services provided by SCTP, such as unordered delivery or partial
   reliability.  Therefore, the use of DTLS over SCTP has been specified
   in [<a href="rfc6083.html" title='"Datagram Transport Layer Security (DTLS) for Stream Control Transmission Protocol (SCTP)"'>RFC6083</a>] to overcome these limitations.  When using DTLS over
   SCTP, the application can use almost all services provided by SCTP.





<span class="grey">Fairhurst, et al.             Informational                    [Page 16]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-17" id="page-17" name="page-17"> </a>
<span class="grey"><a href="rfc8095.html">RFC 8095</a>                   Transport Services                 March 2017</span>


   [<a id="ref-NAT-SUPP" name="ref-NAT-SUPP">NAT-SUPP</a>] defines methods for endpoints and middleboxes to provide
   NAT traversal for SCTP over IPv4.  For legacy NAT traversal,
   [<a href="rfc6951.html" title='"UDP Encapsulation of Stream Control Transmission Protocol (SCTP) Packets for End-Host to End-Host Communication"'>RFC6951</a>] defines the UDP encapsulation of SCTP packets.
   Alternatively, SCTP packets can be encapsulated in DTLS packets as
   specified in [<a href="#ref-SCTP-DTLS-ENCAPS">SCTP-DTLS-ENCAPS</a>].  The latter encapsulation is used
   within the WebRTC [<a href="#ref-WEBRTC-TRANS">WEBRTC-TRANS</a>] context.

   An SCTP ABORT chunk may be used to force a SCTP endpoint to close a
   session [<a href="rfc4960.html" title='"Stream Control Transmission Protocol"'>RFC4960</a>], aborting the connection.

   SCTP has a well-defined API, described in the next subsection.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/3.5.2.%20%20Interface%20Description"></a><a class="selflink" href="#section-3.5.2" name="section-3.5.2">3.5.2</a>.  Interface Description</span>

   [<a id="ref-RFC4960" name="ref-RFC4960">RFC4960</a>] defines an abstract API for the base protocol.  This API
   describes the following functions callable by the upper layer of
   SCTP: Initialize, Associate, Send, Receive, Receive Unsent Message,
   Receive Unacknowledged Message, Shutdown, Abort, SetPrimary, Status,
   Change Heartbeat, Request Heartbeat, Get SRTT Report, Set Failure
   Threshold, Set Protocol Parameters, and Destroy.  The following
   notifications are provided by the SCTP stack to the upper layer:
   COMMUNICATION UP, DATA ARRIVE, SHUTDOWN COMPLETE, COMMUNICATION LOST,
   COMMUNICATION ERROR, RESTART, SEND FAILURE, and NETWORK STATUS
   CHANGE.

   An extension to the BSD Sockets API is defined in [<a href="rfc6458.html" title='"Sockets API Extensions for the Stream Control Transmission Protocol (SCTP)"'>RFC6458</a>] and
   covers:

   o  the base protocol defined in [<a href="rfc4960.html" title='"Stream Control Transmission Protocol"'>RFC4960</a>].  The API allows control
      over local addresses and port numbers and the primary path.
      Furthermore, the application has fine control of parameters like
      retransmission thresholds, the path supervision, the delayed
      acknowledgment timeout, and the fragmentation point.  The API
      provides a mechanism to allow the SCTP stack to notify the
      application about events if the application has requested them.
      These notifications provide information about status changes of
      the association and each of the peer addresses.  In case of send
      failures, including drop of messages sent unreliably, the
      application can also be notified, and user messages can be
      returned to the application.  When sending user messages, the
      application can indicate a stream id, a payload protocol
      identifier, and an indication of whether ordered delivery is
      requested.  These parameters can also be provided on message
      reception.  Additionally, a context can be provided when sending,
      which can be used in case of send failures.  The sending of
      arbitrarily large user messages is supported.





<span class="grey">Fairhurst, et al.             Informational                    [Page 17]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-18" id="page-18" name="page-18"> </a>
<span class="grey"><a href="rfc8095.html">RFC 8095</a>                   Transport Services                 March 2017</span>


   o  the SCTP Partial Reliability extension defined in [<a href="rfc3758.html" title='"Stream Control Transmission Protocol (SCTP) Partial Reliability Extension"'>RFC3758</a>] to
      specify for a user message the Partially Reliable SCTP (PR-SCTP)
      policy and the policy-specific parameter.  Examples of these
      policies defined in [<a href="rfc3758.html" title='"Stream Control Transmission Protocol (SCTP) Partial Reliability Extension"'>RFC3758</a>] and [<a href="rfc7496.html" title='"Additional Policies for the Partially Reliable Stream Control Transmission Protocol Extension"'>RFC7496</a>] are:

      *  limiting the time a user message is dealt with by the sender.

      *  limiting the number of retransmissions for each fragment of a
         user message.  If the number of retransmissions is limited to
         0, one gets a service similar to UDP.

      *  abandoning messages of lower priority in case of a send buffer
         shortage.

   o  the SCTP Authentication extension defined in [<a href="rfc4895.html" title='"Authenticated Chunks for the Stream Control Transmission Protocol (SCTP)"'>RFC4895</a>] allowing
      management of the shared keys and allowing the HMAC to use and set
      the chunk types (which are only accepted in an authenticated way)
      and get the list of chunks that are accepted by the local and
      remote endpoints in an authenticated way.

   o  the SCTP Dynamic Address Reconfiguration extension defined in
      [<a href="rfc5061.html" title='"Stream Control Transmission Protocol (SCTP) Dynamic Address Reconfiguration"'>RFC5061</a>].  It allows the manual addition and deletion of local
      addresses for SCTP associations, as well as the enabling of
      automatic address addition and deletion.  Furthermore, the peer
      can be given a hint for choosing its primary path.

   A BSD Sockets API extension has been defined in the documents that
   specify the following SCTP extensions:

   o  the SCTP Stream Reconfiguration extension defined in [<a href="rfc6525.html" title='"Stream Control Transmission Protocol (SCTP) Stream Reconfiguration"'>RFC6525</a>].
      The API allows triggering of the reset operation for incoming and
      outgoing streams and the whole association.  It also provides a
      way to notify the association about the corresponding events.
      Furthermore, the application can increase the number of streams.

   o  the UDP Encapsulation of SCTP packets extension defined in
      [<a href="rfc6951.html" title='"UDP Encapsulation of Stream Control Transmission Protocol (SCTP) Packets for End-Host to End-Host Communication"'>RFC6951</a>].  The API allows the management of the remote UDP
      encapsulation port.

   o  the SCTP SACK-IMMEDIATELY extension defined in [<a href="rfc7053.html" title='"SACK- IMMEDIATELY Extension for the Stream Control Transmission Protocol"'>RFC7053</a>].  The API
      allows the sender of a user message to request the receiver to
      send the corresponding acknowledgment immediately.

   o  the additional PR-SCTP policies defined in [<a href="rfc7496.html" title='"Additional Policies for the Partially Reliable Stream Control Transmission Protocol Extension"'>RFC7496</a>].  The API
      allows enabling/disabling the PR-SCTP extension, choosing the
      PR-SCTP policies defined in the document, and providing
      statistical information about abandoned messages.




<span class="grey">Fairhurst, et al.             Informational                    [Page 18]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-19" id="page-19" name="page-19"> </a>
<span class="grey"><a href="rfc8095.html">RFC 8095</a>                   Transport Services                 March 2017</span>


   Future documents describing SCTP extensions are expected to describe
   the corresponding BSD Sockets API extension in a "Socket API
   Considerations" section.

   The SCTP Socket API supports two kinds of sockets:

   o  one-to-one style sockets (by using the socket type "SOCK_STREAM").

   o  one-to-many style socket (by using the socket type
      "SOCK_SEQPACKET").

   One-to-one style sockets are similar to TCP sockets; there is a 1:1
   relationship between the sockets and the SCTP associations (except
   for listening sockets).  One-to-many style SCTP sockets are similar
   to unconnected UDP sockets, where there is a 1:n relationship between
   the sockets and the SCTP associations.

   The SCTP stack can provide information to the applications about
   state changes of the individual paths and the association whenever
   they occur.  These events are delivered similarly to user messages
   but are specifically marked as notifications.

   New functions have been introduced to support the use of multiple
   local and remote addresses.  Additional SCTP-specific send and
   receive calls have been defined to permit SCTP-specific information
   to be sent without using ancillary data in the form of additional
   Control Message (cmsg) calls.  These functions provide support for
   detecting partial delivery of user messages and notifications.

   The SCTP Socket API allows a fine-grained control of the protocol
   behavior through an extensive set of socket options.

   The SCTP kernel implementations of FreeBSD, Linux, and Solaris follow
   mostly the specified extension to the BSD Sockets API for the base
   protocol and the corresponding supported protocol extensions.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/3.5.3.%20%20Transport%20Features"></a><a class="selflink" href="#section-3.5.3" name="section-3.5.3">3.5.3</a>.  Transport Features</span>

   The transport features provided by SCTP are:

   o  connection-oriented transport with feature negotiation and
      application-to-port mapping,

   o  unicast transport,

   o  port multiplexing,

   o  unidirectional or bidirectional communication,



<span class="grey">Fairhurst, et al.             Informational                    [Page 19]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-20" id="page-20" name="page-20"> </a>
<span class="grey"><a href="rfc8095.html">RFC 8095</a>                   Transport Services                 March 2017</span>


   o  message-oriented delivery with durable message framing supporting
      multiple concurrent streams,

   o  fully reliable, partially reliable, or unreliable delivery (based
      on user-specified policy to handle abandoned user messages) with
      drop notification,

   o  ordered and unordered delivery within a stream,

   o  support for stream scheduling prioritization,

   o  segmentation,

   o  user message bundling,

   o  flow control using a window-based mechanism,

   o  congestion control using methods similar to TCP,

   o  strong error detection (CRC32c), and

   o  transport-layer multihoming for resilience and mobility.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.6.%20%20Datagram%20Congestion%20Control%20Protocol%20%28DCCP%29"></a><a class="selflink" href="#section-3.6" name="section-3.6">3.6</a>.  Datagram Congestion Control Protocol (DCCP)</span>

   The Datagram Congestion Control Protocol (DCCP) [<a href="rfc4340.html" title='"Datagram Congestion Control Protocol (DCCP)"'>RFC4340</a>] is an IETF
   Standards Track bidirectional transport protocol that provides
   unicast connections of congestion-controlled messages without
   providing reliability.

   The DCCP Problem Statement [<a href="rfc4336.html" title='"Problem Statement for the Datagram Congestion Control Protocol (DCCP)"'>RFC4336</a>] describes the goals that DCCP
   sought to address.  It is suitable for applications that transfer
   fairly large amounts of data and that can benefit from control over
   the trade-off between timeliness and reliability [<a href="rfc4336.html" title='"Problem Statement for the Datagram Congestion Control Protocol (DCCP)"'>RFC4336</a>].

   DCCP offers low overhead, and many characteristics common to UDP, but
   can avoid "re-inventing the wheel" each time a new multimedia
   application emerges.  Specifically, it includes core transport
   functions (feature negotiation, path state management, RTT
   calculation, PMTUD, etc.): DCCP applications select how they send
   packets and, where suitable, choose common algorithms to manage their
   functions.  Examples of applications that can benefit from such
   transport services include interactive applications, streaming media,
   or on-line games [<a href="rfc4336.html" title='"Problem Statement for the Datagram Congestion Control Protocol (DCCP)"'>RFC4336</a>].







<span class="grey">Fairhurst, et al.             Informational                    [Page 20]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-21" id="page-21" name="page-21"> </a>
<span class="grey"><a href="rfc8095.html">RFC 8095</a>                   Transport Services                 March 2017</span>


<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/3.6.1.%20%20Protocol%20Description"></a><a class="selflink" href="#section-3.6.1" name="section-3.6.1">3.6.1</a>.  Protocol Description</span>

   DCCP is a connection-oriented datagram protocol that provides a
   three-way handshake to allow a client and server to set up a
   connection and provides mechanisms for orderly completion and
   immediate teardown of a connection.

   A DCCP protocol instance can be extended [<a href="rfc4340.html" title='"Datagram Congestion Control Protocol (DCCP)"'>RFC4340</a>] and tuned using
   additional features.  Some features are sender-side only, requiring
   no negotiation with the receiver; some are receiver-side only; and
   some are explicitly negotiated during connection setup.

   DCCP uses a Connect packet to initiate a session and permits each
   endpoint to choose the features it wishes to support.  Simultaneous
   open [<a href="rfc5596.html" title='"Datagram Congestion Control Protocol (DCCP) Simultaneous-Open Technique to Facilitate NAT/ Middlebox Traversal"'>RFC5596</a>], as in TCP, can enable interoperability in the
   presence of middleboxes.  The Connect packet includes a Service Code
   [<a href="rfc5595.html" title='"The Datagram Congestion Control Protocol (DCCP) Service Codes"'>RFC5595</a>] that identifies the application or protocol using DCCP,
   providing middleboxes with information about the intended use of a
   connection.

   The DCCP service is unicast-only.

   It provides multiplexing to multiple sockets at each endpoint using
   port numbers.  An active DCCP session is identified by its four-tuple
   of local and remote IP addresses and local and remote port numbers.

   The protocol segments data into messages that are typically sized to
   fit in IP packets but may be fragmented if they are smaller than the
   maximum packet size.  A DCCP interface allows applications to request
   fragmentation for packets larger than PMTU, but not larger than the
   maximum packet size allowed by the current congestion control
   mechanism (Congestion Control Maximum Packet Size (CCMPS)) [<a href="rfc4340.html" title='"Datagram Congestion Control Protocol (DCCP)"'>RFC4340</a>].

   Each message is identified by a sequence number.  The sequence number
   is used to identify segments in acknowledgments, to detect
   unacknowledged segments, to measure RTT, etc.  The protocol may
   support unordered delivery of data and does not itself provide
   retransmission.  DCCP supports reduced checksum coverage, a partial
   payload protection mechanism similar to UDP-Lite.  There is also a
   Data Checksum option, which when enabled, contains a strong Cyclic
   Redundancy Check (CRC), to enable endpoints to detect application
   data corruption.

   Receiver flow control is supported, which limits the amount of
   unacknowledged data that can be outstanding at a given time.

   A DCCP Reset packet may be used to force a DCCP endpoint to close a
   session [<a href="rfc4340.html" title='"Datagram Congestion Control Protocol (DCCP)"'>RFC4340</a>], aborting the connection.



<span class="grey">Fairhurst, et al.             Informational                    [Page 21]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-22" id="page-22" name="page-22"> </a>
<span class="grey"><a href="rfc8095.html">RFC 8095</a>                   Transport Services                 March 2017</span>


   DCCP supports negotiation of the congestion control profile between
   endpoints, to provide plug-and-play congestion control mechanisms.
   Examples of specified profiles include "TCP-like" [<a href="rfc4341.html" title='"Profile for Datagram Congestion Control Protocol (DCCP) Congestion Control ID 2: TCP-like Congestion Control"'>RFC4341</a>], "TCP-
   friendly" [<a href="rfc4342.html" title='"Profile for Datagram Congestion Control Protocol (DCCP) Congestion Control ID 3: TCP-Friendly Rate Control (TFRC)"'>RFC4342</a>], and "TCP-friendly for small packets" [<a href="rfc5622.html" title='"Profile for Datagram Congestion Control Protocol (DCCP) Congestion ID 4: TCP-Friendly Rate Control for Small Packets (TFRC-SP)"'>RFC5622</a>].
   Additional mechanisms are recorded in an IANA registry (see
   &lt;<a href="http://www.iana.org/assignments/dccp-parameters">http://www.iana.org/assignments/dccp-parameters</a>&gt;).

   A lightweight UDP-based encapsulation (DCCP-UDP) has been defined
   [<a href="rfc6773.html" title='"DCCP-UDP: A Datagram Congestion Control Protocol UDP Encapsulation for NAT Traversal"'>RFC6773</a>] that permits DCCP to be used over paths where DCCP is not
   natively supported.  Support for DCCP in NAPT/NATs is defined in
   [<a href="rfc4340.html" title='"Datagram Congestion Control Protocol (DCCP)"'>RFC4340</a>] and [<a href="rfc5595.html" title='"The Datagram Congestion Control Protocol (DCCP) Service Codes"'>RFC5595</a>].  Upper-layer protocols specified on top of
   DCCP include DTLS [<a href="rfc5238.html" title='"Datagram Transport Layer Security (DTLS) over the Datagram Congestion Control Protocol (DCCP)"'>RFC5238</a>], RTP [<a href="rfc5762.html" title='"RTP and the Datagram Congestion Control Protocol (DCCP)"'>RFC5762</a>], and Interactive
   Connectivity Establishment / Session Description Protocol (ICE/SDP)
   [<a href="rfc6773.html" title='"DCCP-UDP: A Datagram Congestion Control Protocol UDP Encapsulation for NAT Traversal"'>RFC6773</a>].

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/3.6.2.%20%20Interface%20Description"></a><a class="selflink" href="#section-3.6.2" name="section-3.6.2">3.6.2</a>.  Interface Description</span>

   Functions expected for a DCCP API include: Open, Close, and
   Management of the progress a DCCP connection.  The Open function
   provides feature negotiation, selection of an appropriate Congestion
   Control Identifier (CCID) for congestion control, and other
   parameters associated with the DCCP connection.  A function allows an
   application to send DCCP datagrams, including setting the required
   checksum coverage and any required options.  (DCCP permits sending
   datagrams with a zero-length payload.)  A function allows reception
   of data, including indicating if the data was used or dropped.
   Functions can also make the status of a connection visible to an
   application, including detection of the maximum packet size and the
   ability to perform flow control by detecting a slow receiver at the
   sender.

   There is no API currently specified in the RFC Series.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/3.6.3.%20%20Transport%20Features"></a><a class="selflink" href="#section-3.6.3" name="section-3.6.3">3.6.3</a>.  Transport Features</span>

   The transport features provided by DCCP are:

   o  unicast transport,

   o  connection-oriented communication with feature negotiation and
      application-to-port mapping,

   o  signaling of application class for middlebox support (implemented
      using Service Codes),

   o  port multiplexing,

   o  unidirectional or bidirectional communication,



<span class="grey">Fairhurst, et al.             Informational                    [Page 22]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-23" id="page-23" name="page-23"> </a>
<span class="grey"><a href="rfc8095.html">RFC 8095</a>                   Transport Services                 March 2017</span>


   o  message-oriented delivery,

   o  unreliable delivery with drop notification,

   o  unordered delivery,

   o  flow control (implemented using the slow receiver function), and

   o  partial and full payload error detection (with optional strong
      integrity check).

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.7.%20%20Transport%20Layer%20Security%20%28TLS%29%20and%20Datagram%20TLS%20%28DTLS%29%20as%20a"></a><a class="selflink" href="#section-3.7" name="section-3.7">3.7</a>.  Transport Layer Security (TLS) and Datagram TLS (DTLS) as a</span>
<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/Pseudotransport"></a>      Pseudotransport</span>

   Transport Layer Security (TLS) [<a href="rfc5246.html" title='"The Transport Layer Security (TLS) Protocol Version 1.2"'>RFC5246</a>] and Datagram TLS (DTLS)
   [<a href="rfc6347.html" title='"Datagram Transport Layer Security Version 1.2"'>RFC6347</a>] are IETF protocols that provide several security-related
   features to applications.  TLS is designed to run on top of a
   reliable streaming transport protocol (usually TCP), while DTLS is
   designed to run on top of a best-effort datagram protocol (UDP or
   DCCP [<a href="rfc5238.html" title='"Datagram Transport Layer Security (DTLS) over the Datagram Congestion Control Protocol (DCCP)"'>RFC5238</a>]).  At the time of writing, the current version of TLS
   is 1.2, defined in [<a href="rfc5246.html" title='"The Transport Layer Security (TLS) Protocol Version 1.2"'>RFC5246</a>]; work on TLS version is 1.3 [<a href="#ref-TLS-1.3" title='"The Transport Layer Security (TLS) Protocol Version 1.3"'>TLS-1.3</a>]
   nearing completion.  DTLS provides nearly identical functionality to
   applications; it is defined in [<a href="rfc6347.html" title='"Datagram Transport Layer Security Version 1.2"'>RFC6347</a>] and its current version is
   also 1.2.  The TLS protocol evolved from the Secure Sockets Layer
   (SSL) [<a href="rfc6101.html" title='"The Secure Sockets Layer (SSL) Protocol Version 3.0"'>RFC6101</a>] protocols developed in the mid-1990s to support
   protection of HTTP traffic.

   While older versions of TLS and DTLS are still in use, they provide
   weaker security guarantees.  [<a href="rfc7457.html" title='"Summarizing Known Attacks on Transport Layer Security (TLS) and Datagram TLS (DTLS)"'>RFC7457</a>] outlines important attacks on
   TLS and DTLS.  [<a href="rfc7525.html" title='"Recommendations for Secure Use of Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS)"'>RFC7525</a>] is a Best Current Practices (BCP) document
   that describes secure configurations for TLS and DTLS to counter
   these attacks.  The recommendations are applicable for the vast
   majority of use cases.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/3.7.1.%20%20Protocol%20Description"></a><a class="selflink" href="#section-3.7.1" name="section-3.7.1">3.7.1</a>.  Protocol Description</span>

   Both TLS and DTLS provide the same security features and can thus be
   discussed together.  The features they provide are:

   o  Confidentiality

   o  Data integrity

   o  Peer authentication (optional)

   o  Perfect forward secrecy (optional)





<span class="grey">Fairhurst, et al.             Informational                    [Page 23]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-24" id="page-24" name="page-24"> </a>
<span class="grey"><a href="rfc8095.html">RFC 8095</a>                   Transport Services                 March 2017</span>


   The authentication of the peer entity can be omitted; a common web
   use case is where the server is authenticated and the client is not.
   TLS also provides a completely anonymous operation mode in which
   neither peer's identity is authenticated.  It is important to note
   that TLS itself does not specify how a peering entity's identity
   should be interpreted.  For example, in the common use case of
   authentication by means of an X.509 certificate, it is the
   application's decision whether the certificate of the peering entity
   is acceptable for authorization decisions.

   Perfect forward secrecy, if enabled and supported by the selected
   algorithms, ensures that traffic encrypted and captured during a
   session at time t0 cannot be later decrypted at time t1 (t1 &gt; t0),
   even if the long-term secrets of the communicating peers are later
   compromised.

   As DTLS is generally used over an unreliable datagram transport such
   as UDP, applications will need to tolerate lost, reordered, or
   duplicated datagrams.  Like TLS, DTLS conveys application data in a
   sequence of independent records.  However, because records are mapped
   to unreliable datagrams, there are several features unique to DTLS
   that are not applicable to TLS:

   o  Record replay detection (optional).

   o  Record size negotiation (estimates of PMTU and record size
      expansion factor).

   o  Conveyance of IP don't fragment (DF) bit settings by application.

   o  An anti-DoS stateless cookie mechanism (optional).

   Generally, DTLS follows the TLS design as closely as possible.  To
   operate over datagrams, DTLS includes a sequence number and limited
   forms of retransmission and fragmentation for its internal
   operations.  The sequence number may be used for detecting replayed
   information, according to the windowing procedure described in
   <a href="rfc6347.html#section-4.1.2.6">Section 4.1.2.6 of [RFC6347]</a>.  DTLS forbids the use of stream
   ciphers, which are essentially incompatible when operating on
   independent encrypted records.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/3.7.2.%20%20Interface%20Description"></a><a class="selflink" href="#section-3.7.2" name="section-3.7.2">3.7.2</a>.  Interface Description</span>

   TLS is commonly invoked using an API provided by packages such as
   OpenSSL, wolfSSL, or GnuTLS.  Using such APIs entails the
   manipulation of several important abstractions, which fall into the
   following categories: long-term keys and algorithms, session state,
   and communications/connections.



<span class="grey">Fairhurst, et al.             Informational                    [Page 24]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-25" id="page-25" name="page-25"> </a>
<span class="grey"><a href="rfc8095.html">RFC 8095</a>                   Transport Services                 March 2017</span>


   Considerable care is required in the use of TLS APIs to ensure
   creation of a secure application.  The programmer should have at
   least a basic understanding of encryption and digital signature
   algorithms and their strengths, public key infrastructure (including
   X.509 certificates and certificate revocation), and the Sockets API.
   See [<a href="rfc7525.html" title='"Recommendations for Secure Use of Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS)"'>RFC7525</a>] and [<a href="rfc7457.html" title='"Summarizing Known Attacks on Transport Layer Security (TLS) and Datagram TLS (DTLS)"'>RFC7457</a>], as mentioned above.

   As an example, in the case of OpenSSL, the primary abstractions are
   the library itself, method (protocol), session, context, cipher, and
   connection.  After initializing the library and setting the method, a
   cipher suite is chosen and used to configure a context object.
   Session objects may then be minted according to the parameters
   present in a context object and associated with individual
   connections.  Depending on how precisely the programmer wishes to
   select different algorithmic or protocol options, various levels of
   details may be required.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/3.7.3.%20%20Transport%20Features"></a><a class="selflink" href="#section-3.7.3" name="section-3.7.3">3.7.3</a>.  Transport Features</span>

   Both TLS and DTLS employ a layered architecture.  The lower layer is
   commonly called the "record protocol".  It is responsible for:

   o  message fragmentation,

   o  authentication and integrity via message authentication codes
      (MACs),

   o  data encryption, and

   o  scheduling transmission using the underlying transport protocol.

   DTLS augments the TLS record protocol with:

   o  ordering and replay protection, implemented using sequence
      numbers.

   Several protocols are layered on top of the record protocol.  These
   include the handshake, alert, and change cipher spec protocols.
   There is also the data protocol, used to carry application traffic.
   The handshake protocol is used to establish cryptographic and
   compression parameters when a connection is first set up.  In DTLS,
   this protocol also has a basic fragmentation and retransmission
   capability and a cookie-like mechanism to resist DoS attacks.  (TLS
   compression is not recommended at present).  The alert protocol is
   used to inform the peer of various conditions, most of which are
   terminal for the connection.  The change cipher spec protocol is used
   to synchronize changes in cryptographic parameters for each peer.




<span class="grey">Fairhurst, et al.             Informational                    [Page 25]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-26" id="page-26" name="page-26"> </a>
<span class="grey"><a href="rfc8095.html">RFC 8095</a>                   Transport Services                 March 2017</span>


   The data protocol, when used with an appropriate cipher, provides:

   o  authentication of one end or both ends of a connection,

   o  confidentiality, and

   o  cryptographic integrity protection.

   Both TLS and DTLS are unicast-only.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.8.%20%20Real-Time%20Transport%20Protocol%20%28RTP%29"></a><a class="selflink" href="#section-3.8" name="section-3.8">3.8</a>.  Real-Time Transport Protocol (RTP)</span>

   RTP provides an end-to-end network transport service, suitable for
   applications transmitting real-time data, such as audio, video or
   data, over multicast or unicast transport services, including TCP,
   UDP, UDP-Lite, DCCP, TLS, and DTLS.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/3.8.1.%20%20Protocol%20Description"></a><a class="selflink" href="#section-3.8.1" name="section-3.8.1">3.8.1</a>.  Protocol Description</span>

   The RTP standard [<a href="rfc3550.html" title='"RTP: A Transport Protocol for Real-Time Applications"'>RFC3550</a>] defines a pair of protocols: RTP and the
   RTP Control Protocol (RTCP).  The transport does not provide
   connection setup, instead relying on out-of-band techniques or
   associated control protocols to setup, negotiate parameters, or tear
   down a session.

   An RTP sender encapsulates audio/video data into RTP packets to
   transport media streams.  The RFC Series specifies RTP payload
   formats that allow packets to carry a wide range of media and
   specifies a wide range of multiplexing, error control, and other
   support mechanisms.

   If a frame of media data is large, it will be fragmented into several
   RTP packets.  Likewise, several small frames may be bundled into a
   single RTP packet.

   An RTP receiver collects RTP packets from the network, validates them
   for correctness, and sends them to the media decoder input queue.
   Missing packet detection is performed by the channel decoder.  The
   playout buffer is ordered by time stamp and is used to reorder
   packets.  Damaged frames may be repaired before the media payloads
   are decompressed to display or store the data.  Some uses of RTP are
   able to exploit the partial payload protection features offered by
   DCCP and UDP-Lite.

   RTCP is a control protocol that works alongside an RTP flow.  Both
   the RTP sender and receiver will send RTCP report packets.  This is
   used to periodically send control information and report performance.




<span class="grey">Fairhurst, et al.             Informational                    [Page 26]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-27" id="page-27" name="page-27"> </a>
<span class="grey"><a href="rfc8095.html">RFC 8095</a>                   Transport Services                 March 2017</span>


   Based on received RTCP feedback, an RTP sender can adjust the
   transmission, e.g., perform rate adaptation at the application layer
   in the case of congestion.

   An RTCP receiver report (RTCP RR) is returned to the sender
   periodically to report key parameters (e.g., the fraction of packets
   lost in the last reporting interval, the cumulative number of packets
   lost, the highest sequence number received, and the inter-arrival
   jitter).  The RTCP RR packets also contain timing information that
   allows the sender to estimate the network round-trip time (RTT) to
   the receivers.

   The interval between reports sent from each receiver tends to be on
   the order of a few seconds on average, although this varies with the
   session rate, and sub-second reporting intervals are possible for
   high rate sessions.  The interval is randomized to avoid
   synchronization of reports from multiple receivers.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/3.8.2.%20%20Interface%20Description"></a><a class="selflink" href="#section-3.8.2" name="section-3.8.2">3.8.2</a>.  Interface Description</span>

   There is no standard API defined for RTP or RTCP.  Implementations
   are typically tightly integrated with a particular application and
   closely follow the principles of application-level framing and
   integrated layer processing [<a href="#ref-ClarkArch">ClarkArch</a>] in media processing
   [<a href="rfc2736.html" title='"Guidelines for Writers of RTP Payload Format Specifications"'>RFC2736</a>], error recovery and concealment, rate adaptation, and
   security [<a href="rfc7202.html" title='"Securing the RTP Framework: Why RTP Does Not Mandate a Single Media Security Solution"'>RFC7202</a>].  Accordingly, RTP implementations tend to be
   targeted at particular application domains (e.g., voice-over-IP,
   IPTV, or video conferencing), with a feature set optimized for that
   domain, rather than being general purpose implementations of the
   protocol.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/3.8.3.%20%20Transport%20Features"></a><a class="selflink" href="#section-3.8.3" name="section-3.8.3">3.8.3</a>.  Transport Features</span>

   The transport features provided by RTP are:

   o  unicast, multicast, or IPv4 broadcast (provided by lower-layer
      protocol),

   o  port multiplexing (provided by lower-layer protocol),

   o  unidirectional or bidirectional communication (provided by lower-
      layer protocol),

   o  message-oriented delivery with support for media types and other
      extensions,

   o  reliable delivery when using erasure coding or unreliable delivery
      with drop notification (if supported by lower-layer protocol),



<span class="grey">Fairhurst, et al.             Informational                    [Page 27]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-28" id="page-28" name="page-28"> </a>
<span class="grey"><a href="rfc8095.html">RFC 8095</a>                   Transport Services                 March 2017</span>


   o  connection setup with feature negotiation (using associated
      protocols) and application-to-port mapping (provided by lower-
      layer protocol),

   o  segmentation, and

   o  performance metric reporting (using associated protocols).

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.9.%20%20Hypertext%20Transport%20Protocol%20%28HTTP%29%20over%20TCP%20as%20a%20Pseudotransport"></a><a class="selflink" href="#section-3.9" name="section-3.9">3.9</a>.  Hypertext Transport Protocol (HTTP) over TCP as a Pseudotransport</span>

   The Hypertext Transfer Protocol (HTTP) is an application-level
   protocol widely used on the Internet.  It provides object-oriented
   delivery of discrete data or files.  Version 1.1 of the protocol is
   specified in [<a href="rfc7230.html" title='"Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing"'>RFC7230</a>] [<a href="rfc7231.html" title='"Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content"'>RFC7231</a>] [<a href="rfc7232.html" title='"Hypertext Transfer Protocol (HTTP/1.1): Conditional Requests"'>RFC7232</a>] [<a href="rfc7233.html" title='"Hypertext Transfer Protocol (HTTP/1.1): Range Requests"'>RFC7233</a>] [<a href="rfc7234.html" title='"Hypertext Transfer Protocol (HTTP/1.1): Caching"'>RFC7234</a>]
   [<a href="rfc7235.html" title='"Hypertext Transfer Protocol (HTTP/1.1): Authentication"'>RFC7235</a>], and version 2 is specified in [<a href="rfc7540.html" title='"Hypertext Transfer Protocol Version 2 (HTTP/2)"'>RFC7540</a>].  HTTP is usually
   transported over TCP using ports 80 and 443, although it can be used
   with other transports.  When used over TCP, it inherits TCP's
   properties.

   Application-layer protocols may use HTTP as a substrate with an
   existing method and data formats, or specify new methods and data
   formats.  There are various reasons for this practice listed in
   [<a href="rfc3205.html" title='"On the use of HTTP as a Substrate"'>RFC3205</a>]; these include being a well-known and well-understood
   protocol, reusability of existing servers and client libraries, easy
   use of existing security mechanisms such as HTTP digest
   authentication [<a href="rfc7235.html" title='"Hypertext Transfer Protocol (HTTP/1.1): Authentication"'>RFC7235</a>] and TLS [<a href="rfc5246.html" title='"The Transport Layer Security (TLS) Protocol Version 1.2"'>RFC5246</a>], and the ability of HTTP
   to traverse firewalls, which allows it to work over many types of
   infrastructure and in cases where an application server often needs
   to support HTTP anyway.

   Depending on application need, the use of HTTP as a substrate
   protocol may add complexity and overhead in comparison to a special-
   purpose protocol (e.g., HTTP headers, suitability of the HTTP
   security model, etc.).  [<a href="rfc3205.html" title='"On the use of HTTP as a Substrate"'>RFC3205</a>] addresses this issue, provides some
   guidelines, and identifies concerns about the use of HTTP standard
   ports 80 and 443, the use of the HTTP URL scheme, and interaction
   with existing firewalls, proxies, and NATs.

   Representational State Transfer (REST) [<a href="#ref-REST" title='"Architectural Styles and the Design of Network-based Software Architectures, Chapter 5: Representational State Transfer"'>REST</a>] is another example of
   how applications can use HTTP as a transport protocol.  REST is an
   architecture style that may be used to build applications using HTTP
   as a communication protocol.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/3.9.1.%20%20Protocol%20Description"></a><a class="selflink" href="#section-3.9.1" name="section-3.9.1">3.9.1</a>.  Protocol Description</span>

   The Hypertext Transfer Protocol (HTTP) is a request/response
   protocol.  A client sends a request containing a request method, URI,
   and protocol version followed by message whose design is inspired by



<span class="grey">Fairhurst, et al.             Informational                    [Page 28]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-29" id="page-29" name="page-29"> </a>
<span class="grey"><a href="rfc8095.html">RFC 8095</a>                   Transport Services                 March 2017</span>


   MIME (see [<a href="rfc7231.html" title='"Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content"'>RFC7231</a>] for the differences between an HTTP object and a
   MIME message), containing information about the client and request
   modifiers.  The message can also contain a message body carrying
   application data.  The server responds with a status or error code
   followed by a message containing information about the server and
   information about the data.  This may include a message body.  It is
   possible to specify a data format for the message body using MIME
   media types [<a href="rfc2045.html" title='"Multipurpose Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies"'>RFC2045</a>].  The protocol has additional features; some
   relevant to pseudotransport are described below.

   Content negotiation, specified in [<a href="rfc7231.html" title='"Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content"'>RFC7231</a>], is a mechanism provided
   by HTTP to allow selection of a representation for a requested
   resource.  The client and server negotiate acceptable data formats,
   character sets, and data encoding (e.g., data can be transferred
   compressed using gzip).  HTTP can accommodate exchange of messages as
   well as data streaming (using chunked transfer encoding [<a href="rfc7230.html" title='"Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing"'>RFC7230</a>]).
   It is also possible to request a part of a resource using an object
   range request [<a href="rfc7233.html" title='"Hypertext Transfer Protocol (HTTP/1.1): Range Requests"'>RFC7233</a>].  The protocol provides powerful cache
   control signaling defined in [<a href="rfc7234.html" title='"Hypertext Transfer Protocol (HTTP/1.1): Caching"'>RFC7234</a>].

   The persistent connections of HTTP 1.1 and HTTP 2.0 allow multiple
   request/response transactions (streams) during the lifetime of a
   single HTTP connection.  This reduces overhead during connection
   establishment and mitigates transport-layer slow-start that would
   have otherwise been incurred for each transaction.  HTTP 2.0
   connections can multiplex many request/response pairs in parallel on
   a single transport connection.  Both are important to reduce latency
   for HTTP's primary use case.

   HTTP can be combined with security mechanisms, such as TLS (denoted
   by HTTPS).  This adds protocol properties provided by such a
   mechanism (e.g., authentication and encryption).  The TLS
   Application-Layer Protocol Negotiation (ALPN) extension [<a href="rfc7301.html" title='"Transport Layer Security (TLS) Application-Layer Protocol Negotiation Extension"'>RFC7301</a>] can
   be used to negotiate the HTTP version within the TLS handshake,
   eliminating the latency incurred by additional round-trip exchanges.
   Arbitrary cookie strings, included as part of the request headers,
   are often used as bearer tokens in HTTP.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/3.9.2.%20%20Interface%20Description"></a><a class="selflink" href="#section-3.9.2" name="section-3.9.2">3.9.2</a>.  Interface Description</span>

   There are many HTTP libraries available exposing different APIs.  The
   APIs provide a way to specify a request by providing a URI, a method,
   request modifiers, and, optionally, a request body.  For the
   response, callbacks can be registered that will be invoked when the
   response is received.  If HTTPS is used, the API exposes a
   registration of callbacks when a server requests client
   authentication and when certificate verification is needed.




<span class="grey">Fairhurst, et al.             Informational                    [Page 29]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-30" id="page-30" name="page-30"> </a>
<span class="grey"><a href="rfc8095.html">RFC 8095</a>                   Transport Services                 March 2017</span>


   The World Wide Web Consortium (W3C) has standardized the
   XMLHttpRequest API [<a href="#ref-XHR" title='"XMLHttpRequest Level 1"'>XHR</a>].  This API can be used for sending HTTP/
   HTTPS requests and receiving server responses.  Besides the XML data
   format, the request and response data format can also be JSON, HTML,
   and plain text.  JavaScript and XMLHttpRequest are ubiquitous
   programming models for websites and more general applications where
   native code is less attractive.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/3.9.3.%20%20Transport%20Features"></a><a class="selflink" href="#section-3.9.3" name="section-3.9.3">3.9.3</a>.  Transport Features</span>

   The transport features provided by HTTP, when used as a
   pseudotransport, are:

   o  unicast transport (provided by the lower-layer protocol, usually
      TCP),

   o  unidirectional or bidirectional communication,

   o  transfer of objects in multiple streams with object content type
      negotiation, supporting partial transmission of object ranges,

   o  ordered delivery (provided by the lower-layer protocol, usually
      TCP),

   o  fully reliable delivery (provided by the lower-layer protocol,
      usually TCP),

   o  flow control (provided by the lower-layer protocol, usually TCP),
      and

   o  congestion control (provided by the lower-layer protocol, usually
      TCP).

   HTTPS (HTTP over TLS) additionally provides the following features
   (as provided by TLS):

   o  authentication (of one or both ends of a connection),

   o  confidentiality, and

   o  integrity protection.










<span class="grey">Fairhurst, et al.             Informational                    [Page 30]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-31" id="page-31" name="page-31"> </a>
<span class="grey"><a href="rfc8095.html">RFC 8095</a>                   Transport Services                 March 2017</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.10.%20%20File%20Delivery%20over%20Unidirectional%20Transport%20%2F%20Asynchronous"></a><a class="selflink" href="#section-3.10" name="section-3.10">3.10</a>.  File Delivery over Unidirectional Transport / Asynchronous</span>
<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/Layered%20Coding%20%28FLUTE%2FALC%29%20for%20Reliable%20Multicast"></a>       Layered Coding (FLUTE/ALC) for Reliable Multicast</span>

   FLUTE/ALC is an IETF Standards Track protocol specified in [<a href="rfc6726.html" title='"FLUTE - File Delivery over Unidirectional Transport"'>RFC6726</a>]
   and [<a href="rfc5775.html" title='"Asynchronous Layered Coding (ALC) Protocol Instantiation"'>RFC5775</a>].  It provides object-oriented delivery of discrete data
   or files.  Asynchronous Layer Coding (ALC) provides an underlying
   reliable transport service and FLUTE a file-oriented specialization
   of the ALC service (e.g., to carry associated metadata).  [<a href="rfc6726.html" title='"FLUTE - File Delivery over Unidirectional Transport"'>RFC6726</a>]
   and [<a href="rfc5775.html" title='"Asynchronous Layered Coding (ALC) Protocol Instantiation"'>RFC5775</a>] are non-backward-compatible updates of [<a href="rfc3926.html" title='"FLUTE - File Delivery over Unidirectional Transport"'>RFC3926</a>] and
   [<a href="rfc3450.html" title='"Asynchronous Layered Coding (ALC) Protocol Instantiation"'>RFC3450</a>], which are Experimental protocols; these Experimental
   protocols are currently largely deployed in the 3GPP Multimedia
   Broadcast / Multicast Service (MBMS) (see [<a href="#ref-MBMS" title='"Multimedia Broadcast/Multicast Service (MBMS); Protocols and codecs"'>MBMS</a>], Section 7) and
   similar contexts (e.g., the Japanese ISDB-Tmm standard).

   The FLUTE/ALC protocol has been designed to support massively
   scalable reliable bulk data dissemination to receiver groups of
   arbitrary size using IP Multicast over any type of delivery network,
   including unidirectional networks (e.g., broadcast wireless
   channels).  However, the FLUTE/ALC protocol also supports point-to-
   point unicast transmissions.

   FLUTE/ALC bulk data dissemination has been designed for discrete file
   or memory-based "objects".  Although FLUTE/ALC is not well adapted to
   byte and message streaming, there is an exception: FLUTE/ALC is used
   to carry 3GPP Dynamic Adaptive Streaming over HTTP (DASH) when
   scalability is a requirement (see [<a href="#ref-MBMS" title='"Multimedia Broadcast/Multicast Service (MBMS); Protocols and codecs"'>MBMS</a>], Section 5.6).

   FLUTE/ALC's reliability, delivery mode, congestion control, and flow/
   rate control mechanisms can be separately controlled to meet
   different application needs.  <a href="rfc8085.html#section-4.1">Section 4.1 of [RFC8085]</a> describes
   multicast congestion control requirements for UDP.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/3.10.1.%20%20Protocol%20Description"></a><a class="selflink" href="#section-3.10.1" name="section-3.10.1">3.10.1</a>.  Protocol Description</span>

   The FLUTE/ALC protocol works on top of UDP (though it could work on
   top of any datagram delivery transport protocol), without requiring
   any connectivity from receivers to the sender.  Purely unidirectional
   networks are therefore supported by FLUTE/ALC.  This guarantees
   scalability to an unlimited number of receivers in a session, since
   the sender behaves exactly the same regardless of the number of
   receivers.

   FLUTE/ALC supports the transfer of bulk objects such as file or
   in-memory content, using either a push or an on-demand mode.  In push
   mode, content is sent once to the receivers, while in on-demand mode,
   content is sent continuously during periods of time that can greatly
   exceed the average time required to download the session objects (see
   <a href="rfc5651.html#section-4.2">[RFC5651], Section 4.2</a>).



<span class="grey">Fairhurst, et al.             Informational                    [Page 31]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-32" id="page-32" name="page-32"> </a>
<span class="grey"><a href="rfc8095.html">RFC 8095</a>                   Transport Services                 March 2017</span>


   This enables receivers to join a session asynchronously, at their own
   discretion, receive the content, and leave the session.  In this
   case, data content is typically sent continuously, in loops (also
   known as "carousels").  FLUTE/ALC also supports the transfer of an
   object stream, with loose real-time constraints.  This is
   particularly useful to carry 3GPP DASH when scalability is a
   requirement and unicast transmissions over HTTP cannot be used
   ([<a href="#ref-MBMS" title='"Multimedia Broadcast/Multicast Service (MBMS); Protocols and codecs"'>MBMS</a>], Section 5.6).  In this case, packets are sent in sequence
   using push mode.  FLUTE/ALC is not well adapted to byte and message
   streaming, and other solutions could be preferred (e.g., FECFRAME
   [<a href="rfc6363.html" title='"Forward Error Correction (FEC) Framework"'>RFC6363</a>] with real-time flows).

   The FLUTE file delivery instantiation of ALC provides a metadata
   delivery service.  Each object of the FLUTE/ALC session is described
   in a dedicated entry of a File Delivery Table (FDT), using an XML
   format (see <a href="rfc6726.html#section-3.2">[RFC6726], Section 3.2</a>).  This metadata can include, but
   is not restricted to, a URI attribute (to identify and locate the
   object), a media type attribute, a size attribute, an encoding
   attribute, or a message digest attribute.  Since the set of objects
   sent within a session can be dynamic, with new objects being added
   and old ones removed, several instances of the FDT can be sent, and a
   mechanism is provided to identify a new FDT instance.

   Error detection and verification of the protocol control information
   relies on the underlying transport (e.g., UDP checksum).

   To provide robustness against packet loss and improve the efficiency
   of the on-demand mode, FLUTE/ALC relies on packet erasure coding
   (Application-Layer Forward Error Correction (AL-FEC)).  AL-FEC
   encoding is proactive (since there is no feedback and therefore no
   (N)ACK-based retransmission), and ALC packets containing repair data
   are sent along with ALC packets containing source data.  Several FEC
   Schemes have been standardized; FLUTE/ALC does not mandate the use of
   any particular one.  Several strategies concerning the transmission
   order of ALC source and repair packets are possible, in particular,
   in on-demand mode where it can deeply impact the service provided
   (e.g., to favor the recovery of objects in sequence or, at the other
   extreme, to favor the recovery of all objects in parallel), and
   FLUTE/ALC does not mandate nor recommend the use of any particular
   one.

   A FLUTE/ALC session is composed of one or more channels, associated
   to different destination unicast and/or multicast IP addresses.  ALC
   packets are sent in those channels at a certain transmission rate,
   with a rate that often differs depending on the channel.  FLUTE/ALC
   does not mandate nor recommend any strategy to select which ALC
   packet to send on which channel.  FLUTE/ALC can use a multiple rate
   congestion control building block (e.g., Wave and Equation Based Rate



<span class="grey">Fairhurst, et al.             Informational                    [Page 32]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-33" id="page-33" name="page-33"> </a>
<span class="grey"><a href="rfc8095.html">RFC 8095</a>                   Transport Services                 March 2017</span>


   Control (WEBRC)) to provide congestion control that is feedback free,
   where receivers adjust their reception rates individually by joining
   and leaving channels associated with the session.  To that purpose,
   the ALC header provides a specific field to carry congestion-control-
   specific information.  However, FLUTE/ALC does not mandate the use of
   a particular congestion control mechanism although WEBRC is mandatory
   to support for the Internet (<a href="rfc6726.html#section-1.1.4">[RFC6726], Section 1.1.4</a>).  FLUTE/ALC is
   often used over a network path with pre-provisioned capacity
   [<a href="rfc8085.html" title='"UDP Usage Guidelines"'>RFC8085</a>] where there are no flows competing for capacity.  In this
   case, a sender-based rate control mechanism and a single channel are
   sufficient.

   [<a id="ref-RFC6584" name="ref-RFC6584">RFC6584</a>] provides per-packet authentication, integrity, and anti-
   replay protection in the context of the ALC and NORM protocols.
   Several mechanisms are proposed that seamlessly integrate into these
   protocols using the ALC and NORM header extension mechanisms.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/3.10.2.%20%20Interface%20Description"></a><a class="selflink" href="#section-3.10.2" name="section-3.10.2">3.10.2</a>.  Interface Description</span>

   The FLUTE/ALC specification does not describe a specific API to
   control protocol operation.  Although open source and commercial
   implementations have specified APIs, there is no IETF-specified API
   for FLUTE/ALC.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/3.10.3.%20%20Transport%20Features"></a><a class="selflink" href="#section-3.10.3" name="section-3.10.3">3.10.3</a>.  Transport Features</span>

   The transport features provided by FLUTE/ALC are:

   o  unicast, multicast, anycast, or IPv4 broadcast transmission,

   o  object-oriented delivery of discrete data or files and associated
      metadata,

   o  fully reliable or partially reliable delivery (of file or in-
      memory objects), using proactive packet erasure coding (AL-FEC) to
      recover from packet erasures,

   o  ordered or unordered delivery (of file or in-memory objects),

   o  error detection (based on the UDP checksum),

   o  per-packet authentication,

   o  per-packet integrity,

   o  per-packet replay protection, and

   o  congestion control for layered flows (e.g., with WEBRC).



<span class="grey">Fairhurst, et al.             Informational                    [Page 33]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-34" id="page-34" name="page-34"> </a>
<span class="grey"><a href="rfc8095.html">RFC 8095</a>                   Transport Services                 March 2017</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.11.%20%20NACK-Oriented%20Reliable%20Multicast%20%28NORM%29"></a><a class="selflink" href="#section-3.11" name="section-3.11">3.11</a>.  NACK-Oriented Reliable Multicast (NORM)</span>

   NORM is an IETF Standards Track protocol specified in [<a href="rfc5740.html" title='"NACK-Oriented Reliable Multicast (NORM) Transport Protocol"'>RFC5740</a>].  It
   provides object-oriented delivery of discrete data or files.

   The protocol was designed to support reliable bulk data dissemination
   to receiver groups using IP Multicast but also provides for point-to-
   point unicast operation.  Support for bulk data dissemination
   includes discrete file or computer memory-based "objects" as well as
   byte and message streaming.

   NORM can incorporate packet erasure coding as a part of its selective
   Automatic Repeat reQuest (ARQ) in response to negative
   acknowledgments from the receiver.  The packet erasure coding can
   also be proactively applied for forward protection from packet loss.
   NORM transmissions are governed by TCP-Friendly Multicast Congestion
   Control (TFMCC) [<a href="rfc4654.html" title='"TCP-Friendly Multicast Congestion Control (TFMCC): Protocol Specification"'>RFC4654</a>].  The reliability, congestion control, and
   flow control mechanisms can be separately controlled to meet
   different application needs.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/3.11.1.%20%20Protocol%20Description"></a><a class="selflink" href="#section-3.11.1" name="section-3.11.1">3.11.1</a>.  Protocol Description</span>

   The NORM protocol is encapsulated in UDP datagrams and thus provides
   multiplexing for multiple sockets on hosts using port numbers.  For
   loosely coordinated IP Multicast, NORM is not strictly connection-
   oriented although per-sender state is maintained by receivers for
   protocol operation.  [<a href="rfc5740.html" title='"NACK-Oriented Reliable Multicast (NORM) Transport Protocol"'>RFC5740</a>] does not specify a handshake protocol
   for connection establishment.  Separate session initiation can be
   used to coordinate port numbers.  However, in-band "client-server"
   style connection establishment can be accomplished with the NORM
   congestion control signaling messages using port binding techniques
   like those for TCP client-server connections.

   NORM supports bulk "objects" such as file or in-memory content but
   also can treat a stream of data as a logical bulk object for purposes
   of packet erasure coding.  In the case of stream transport, NORM can
   support either byte streams or message streams where application-
   defined message boundary information is carried in the NORM protocol
   messages.  This allows the receiver(s) to join/rejoin and recover
   message boundaries mid-stream as needed.  Application content is
   carried and identified by the NORM protocol with encoding symbol
   identifiers depending upon the Forward Error Correction (FEC) Scheme
   [<a href="rfc5052.html" title='"Forward Error Correction (FEC) Building Block"'>RFC5052</a>] configured.  NORM uses NACK-based selective ARQ to reliably
   deliver the application content to the receiver(s).  NORM proactively
   measures round-trip timing information to scale ARQ timers
   appropriately and to support congestion control.  For multicast





<span class="grey">Fairhurst, et al.             Informational                    [Page 34]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-35" id="page-35" name="page-35"> </a>
<span class="grey"><a href="rfc8095.html">RFC 8095</a>                   Transport Services                 March 2017</span>


   operation, timer-based feedback suppression is used to achieve group
   size scaling with low feedback traffic levels.  The feedback
   suppression is not applied for unicast operation.

   NORM uses rate-based congestion control based upon the TCP-Friendly
   Rate Control (TFRC) [<a href="rfc5348.html" title='"TCP Friendly Rate Control (TFRC): Protocol Specification"'>RFC5348</a>] principles that are also used in DCCP
   [<a href="rfc4340.html" title='"Datagram Congestion Control Protocol (DCCP)"'>RFC4340</a>].  NORM uses control messages to measure RTT and collect
   congestion event information (e.g., reflecting a loss event or ECN
   event) from the receiver(s) to support dynamic adjustment or the
   rate.  TCP-Friendly Multicast Congestion Control (TFMCC) [<a href="rfc4654.html" title='"TCP-Friendly Multicast Congestion Control (TFMCC): Protocol Specification"'>RFC4654</a>]
   provides extra features to support multicast but is functionally
   equivalent to TFRC for unicast.

   Error detection and verification of the protocol control information
   relies on the on the underlying transport (e.g., UDP checksum).

   The reliability mechanism is decoupled from congestion control.  This
   allows invocation of alternative arrangements of transport services,
   for example, to support, fixed-rate reliable delivery or unreliable
   delivery (that may optionally be "better than best effort" via packet
   erasure coding) using TFRC.  Alternative congestion control
   techniques may be applied, for example, TFRC with congestion event
   detection based on ECN.

   While NORM provides NACK-based reliability, it also supports a
   positive acknowledgment (ACK) mechanism that can be used for receiver
   flow control.  This mechanism is decoupled from the reliability and
   congestion control, supporting applications with different needs.
   One example is use of NORM for quasi-reliable delivery, where timely
   delivery of newer content may be favored over completely reliable
   delivery of older content within buffering and RTT constraints.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/3.11.2.%20%20Interface%20Description"></a><a class="selflink" href="#section-3.11.2" name="section-3.11.2">3.11.2</a>.  Interface Description</span>

   The NORM specification does not describe a specific API to control
   protocol operation.  A freely available, open-source reference
   implementation of NORM is available at
   &lt;<a href="https://www.nrl.navy.mil/itd/ncs/products/norm">https://www.nrl.navy.mil/itd/ncs/products/norm</a>&gt;, and a documented
   API is provided for this implementation.  While a sockets-like API is
   not currently documented, the existing API supports the necessary
   functions for that to be implemented.










<span class="grey">Fairhurst, et al.             Informational                    [Page 35]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-36" id="page-36" name="page-36"> </a>
<span class="grey"><a href="rfc8095.html">RFC 8095</a>                   Transport Services                 March 2017</span>


<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/3.11.3.%20%20Transport%20Features"></a><a class="selflink" href="#section-3.11.3" name="section-3.11.3">3.11.3</a>.  Transport Features</span>

   The transport features provided by NORM are:

   o  unicast or multicast transport,

   o  unidirectional communication,

   o  stream-oriented delivery in a single stream or object-oriented
      delivery of in-memory data or file bulk content objects,

   o  fully reliable (NACK-based) or partially reliable (using erasure
      coding both proactively and as part of ARQ) delivery,

   o  unordered delivery,

   o  error detection (relies on UDP checksum),

   o  segmentation,

   o  data bundling (using Nagle's algorithm),

   o  flow control (timer-based and/or ACK-based), and

   o  congestion control (also supporting fixed-rate reliable or
      unreliable delivery).

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.12.%20%20Internet%20Control%20Message%20Protocol%20%28ICMP%29"></a><a class="selflink" href="#section-3.12" name="section-3.12">3.12</a>.  Internet Control Message Protocol (ICMP)</span>

   The Internet Control Message Protocol (ICMP) [<a href="rfc792.html" title='"Internet Control Message Protocol"'>RFC792</a>] for IPv4 and
   ICMP for IPv6 [<a href="rfc4443.html" title='"Internet Control Message Protocol (ICMPv6) for the Internet Protocol Version 6 (IPv6) Specification"'>RFC4443</a>] are IETF Standards Track protocols.  It is a
   connectionless unidirectional protocol that delivers individual
   messages, without error correction, congestion control, or flow
   control.  Messages may be sent as unicast, IPv4 broadcast, or
   multicast datagrams (IPv4 and IPv6), in addition to anycast
   datagrams.

   While ICMP is not typically described as a transport protocol, it
   does position itself over the network layer, and the operation of
   other transport protocols can be closely linked to the functions
   provided by ICMP.

   Transport protocols and upper-layer protocols can use received ICMP
   messages to help them make appropriate decisions when network or
   endpoint errors are reported, for example, to implement ICMP-based
   Path MTU Discovery (PMTUD) [<a href="rfc1191.html" title='"Path MTU discovery"'>RFC1191</a>] [<a href="rfc1981.html" title='"Path MTU Discovery for IP version 6"'>RFC1981</a>] or assist in
   Packetization Layer PMTUD (PLPMTUD) [<a href="rfc4821.html" title='"Packetization Layer Path MTU Discovery"'>RFC4821</a>].  Such reactions to
   received messages need to protect from off-path data injection



<span class="grey">Fairhurst, et al.             Informational                    [Page 36]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-37" id="page-37" name="page-37"> </a>
<span class="grey"><a href="rfc8095.html">RFC 8095</a>                   Transport Services                 March 2017</span>


   [<a id="ref-RFC8085" name="ref-RFC8085">RFC8085</a>] to avoid an application receiving packets created by an
   unauthorized third party.  An application therefore needs to ensure
   that all messages are appropriately validated by checking the payload
   of the messages to ensure they are received in response to actually
   transmitted traffic (e.g., a reported error condition that
   corresponds to a UDP datagram or TCP segment was actually sent by the
   application).  This requires context [<a href="rfc6056.html" title='"Recommendations for Transport- Protocol Port Randomization"'>RFC6056</a>], such as local state
   about communication instances to each destination (e.g., in TCP,
   DCCP, or SCTP).  This state is not always maintained by UDP-based
   applications [<a href="rfc8085.html" title='"UDP Usage Guidelines"'>RFC8085</a>].

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/3.12.1.%20%20Protocol%20Description"></a><a class="selflink" href="#section-3.12.1" name="section-3.12.1">3.12.1</a>.  Protocol Description</span>

   ICMP is a connectionless unidirectional protocol.  It delivers
   independent messages, called "datagrams".  Each message is required
   to carry a checksum as an integrity check and to protect from
   misdelivery to an unintended endpoint.

   ICMP messages typically relay diagnostic information from an endpoint
   [<a href="rfc1122.html" title='"Requirements for Internet Hosts - Communication Layers"'>RFC1122</a>] or network device [<a href="rfc1812.html" title='"Requirements for IP Version 4 Routers"'>RFC1812</a>] addressed to the sender of a
   flow.  This usually contains the network protocol header of a packet
   that encountered a reported issue.  Some formats of messages can also
   carry other payload data.  Each message carries an integrity check
   calculated in the same way as for UDP; this checksum is not optional.

   The RFC Series defines additional IPv6 message formats to support a
   range of uses.  In the case of IPv6, the protocol incorporates
   neighbor discovery [<a href="rfc4861.html" title='"Neighbor Discovery for IP version 6 (IPv6)"'>RFC4861</a>] [<a href="rfc3971.html" title='"SEcure Neighbor Discovery (SEND)"'>RFC3971</a>] (provided by ARP for IPv4) and
   Multicast Listener Discovery (MLD) [<a href="rfc2710.html" title='"Multicast Listener Discovery (MLD) for IPv6"'>RFC2710</a>] group management
   functions (provided by IGMP for IPv4).

   Reliable transmission cannot be assumed.  A receiving application
   that is unable to run sufficiently fast, or frequently, may miss
   messages since there is no flow or congestion control.  In addition,
   some network devices rate-limit ICMP messages.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/3.12.2.%20%20Interface%20Description"></a><a class="selflink" href="#section-3.12.2" name="section-3.12.2">3.12.2</a>.  Interface Description</span>

   ICMP processing is integrated in many connection-oriented transports
   but, like other functions, needs to be provided by an upper-layer
   protocol when using UDP and UDP-Lite.

   On some stacks, a bound socket also allows a UDP application to be
   notified when ICMP error messages are received for its transmissions
   [<a href="rfc8085.html" title='"UDP Usage Guidelines"'>RFC8085</a>].






<span class="grey">Fairhurst, et al.             Informational                    [Page 37]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-38" id="page-38" name="page-38"> </a>
<span class="grey"><a href="rfc8095.html">RFC 8095</a>                   Transport Services                 March 2017</span>


   Any response to ICMP error messages ought to be robust to temporary
   routing failures (sometimes called "soft errors"), e.g., transient
   ICMP "unreachable" messages ought to not normally cause a
   communication abort [<a href="rfc5461.html" title="&quot;TCP's Reaction to Soft Errors&quot;">RFC5461</a>] [<a href="rfc8085.html" title='"UDP Usage Guidelines"'>RFC8085</a>].

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/3.12.3.%20%20Transport%20Features"></a><a class="selflink" href="#section-3.12.3" name="section-3.12.3">3.12.3</a>.  Transport Features</span>

   ICMP does not provide any transport service directly to applications.
   Used together with other transport protocols, it provides
   transmission of control, error, and measurement data between
   endpoints or from devices along the path to one endpoint.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/4.%20%20Congestion%20Control"></a><a class="selflink" href="#section-4" name="section-4">4</a>.  Congestion Control</span>

   Congestion control is critical to the stable operation of the
   Internet.  A variety of mechanisms are used to provide the congestion
   control needed by many Internet transport protocols.  Congestion is
   detected based on sensing of network conditions, whether through
   explicit or implicit feedback.  The congestion control mechanisms
   that can be applied by different transport protocols are largely
   orthogonal to the choice of transport protocol.  This section
   provides an overview of the congestion control mechanisms available
   to the protocols described in <a href="#section-3">Section 3</a>.

   Many protocols use a separate window to determine the maximum sending
   rate that is allowed by the congestion control.  The used congestion
   control mechanism will increase the congestion window if feedback is
   received that indicates that the currently used network path is not
   congested and will reduce the window otherwise.  Window-based
   mechanisms often increase their window slowing over multiple RTTs,
   while decreasing strongly when the first indication of congestion is
   received.  One example is an Additive Increase Multiplicative
   Decrease (AIMD) scheme, where the window is increased by a certain
   number of packets/bytes for each data segment that has been
   successfully transmitted, while the window decreases multiplicatively
   on the occurrence of a congestion event.  This can lead to a rather
   unstable, oscillating sending rate but will resolve a congestion
   situation quickly.  Examples of window-based AIMD schemes include TCP
   NewReno [<a href="rfc5681.html" title='"TCP Congestion Control"'>RFC5681</a>], TCP Cubic [<a href="#ref-CUBIC" title='"CUBIC for Fast Long-Distance Networks"'>CUBIC</a>] (the default mechanism for TCP
   in Linux), and CCID 2 specified for DCCP [<a href="rfc4341.html" title='"Profile for Datagram Congestion Control Protocol (DCCP) Congestion Control ID 2: TCP-like Congestion Control"'>RFC4341</a>].

   Some classes of applications prefer to use a transport service that
   allows sending at a more stable rate that is slowly varied in
   response to congestion.  Rate-based methods offer this type of
   congestion control and have been defined based on the loss ratio and
   observed round-trip time, such as TFRC [<a href="rfc5348.html" title='"TCP Friendly Rate Control (TFRC): Protocol Specification"'>RFC5348</a>] and TFRC-SP





<span class="grey">Fairhurst, et al.             Informational                    [Page 38]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-39" id="page-39" name="page-39"> </a>
<span class="grey"><a href="rfc8095.html">RFC 8095</a>                   Transport Services                 March 2017</span>


   [<a href="rfc4828.html" title='"TCP Friendly Rate Control (TFRC): The Small-Packet (SP) Variant"'>RFC4828</a>].  These methods utilize a throughput equation to determine
   the maximum acceptable rate.  Such methods are used with DCCP CCID 3
   [<a href="rfc4342.html" title='"Profile for Datagram Congestion Control Protocol (DCCP) Congestion Control ID 3: TCP-Friendly Rate Control (TFRC)"'>RFC4342</a>], CCID 4 [<a href="rfc5622.html" title='"Profile for Datagram Congestion Control Protocol (DCCP) Congestion ID 4: TCP-Friendly Rate Control for Small Packets (TFRC-SP)"'>RFC5622</a>], WEBRC [<a href="rfc3738.html" title='"Wave and Equation Based Rate Control (WEBRC) Building Block"'>RFC3738</a>], and other applications.

   Another class of applications prefers a transport service that yields
   to other (higher-priority) traffic, such as interactive
   transmissions.  While most traffic in the Internet uses loss-based
   congestion control and therefore tends to fill the network buffers
   (to a certain level if Active Queue Management (AQM) is used), low-
   priority congestion control methods often react to changes in delay
   as an earlier indication of congestion.  This approach tends to
   induce less loss than a loss-based method but does generally not
   compete well with loss-based traffic across shared bottleneck links.
   Therefore, methods such as LEDBAT [<a href="rfc6817.html" title='"Low Extra Delay Background Transport (LEDBAT)"'>RFC6817</a>] are deployed in the
   Internet for scavenger traffic that aims to only utilize otherwise
   unused capacity.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/5.%20%20Transport%20Features"></a><a class="selflink" href="#section-5" name="section-5">5</a>.  Transport Features</span>

   The transport protocol features described in this document can be
   used as a basis for defining common transport features.  These are
   listed below with the protocols supporting them:

   o  Control Functions

      *  Addressing

         +  unicast (TCP, MPTCP, UDP, UDP-Lite, SCTP, DCCP, TLS, RTP,
            HTTP, ICMP)

         +  multicast (UDP, UDP-Lite, RTP, ICMP, FLUTE/ALC, NORM).  Note
            that, as TLS and DTLS are unicast-only, there is no widely
            deployed mechanism for supporting the features listed under
            the Security bullet (below) when using multicast addressing.

         +  IPv4 broadcast (UDP, UDP-Lite, ICMP)

         +  anycast (UDP, UDP-Lite).  Connection-oriented protocols such
            as TCP and DCCP have also been deployed using anycast
            addressing, with the risk that routing changes may cause
            connection failure.

      *  Association type

         +  connection-oriented (TCP, MPTCP, DCCP, SCTP, TLS, RTP, HTTP,
            NORM)

         +  connectionless (UDP, UDP-Lite, FLUTE/ALC)



<span class="grey">Fairhurst, et al.             Informational                    [Page 39]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-40" id="page-40" name="page-40"> </a>
<span class="grey"><a href="rfc8095.html">RFC 8095</a>                   Transport Services                 March 2017</span>


      *  Multihoming support

         +  resilience and mobility (MPTCP, SCTP)

         +  load balancing (MPTCP)

         +  address family multiplexing (MPTCP, SCTP)

      *  Middlebox cooperation

         +  application-class signaling to middleboxes (DCCP)

         +  error condition signaling from middleboxes and routers to
            endpoints (ICMP)

      *  Signaling

         +  control information and error signaling (ICMP)

         +  application performance reporting (RTP)

   o  Delivery

      *  Reliability

         +  fully reliable delivery (TCP, MPTCP, SCTP, TLS, HTTP, FLUTE/
            ALC, NORM)

         +  partially reliable delivery (SCTP, NORM)

            -  using packet erasure coding (RTP, FLUTE/ALC, NORM)

            -  with specified policy for dropped messages (SCTP)

         +  unreliable delivery (SCTP, UDP, UDP-Lite, DCCP, RTP)

            -  with drop notification to sender (SCTP, DCCP, RTP)

         +  error detection

            -  checksum for error detection (TCP, MPTCP, UDP, UDP-Lite,
               SCTP, DCCP, TLS, DTLS, FLUTE/ALC, NORM, ICMP)

            -  partial payload checksum protection (UDP-Lite, DCCP).
               Some uses of RTP can exploit partial payload checksum
               protection feature to provide a corruption-tolerant
               transport service.




<span class="grey">Fairhurst, et al.             Informational                    [Page 40]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-41" id="page-41" name="page-41"> </a>
<span class="grey"><a href="rfc8095.html">RFC 8095</a>                   Transport Services                 March 2017</span>


            -  checksum optional (UDP).  Possible with IPv4 and, in
               certain cases, with IPv6.

      *  Ordering

         +  ordered delivery (TCP, MPTCP, SCTP, TLS, RTP, HTTP, FLUTE)

         +  unordered delivery permitted (UDP, UDP-Lite, SCTP, DCCP,
            RTP, NORM)

      *  Type/framing

         +  stream-oriented delivery (TCP, MPTCP, SCTP, TLS, HTTP)

            -  with multiple streams per association (SCTP, HTTP2)

         +  message-oriented delivery (UDP, UDP-Lite, SCTP, DCCP, DTLS,
            RTP)

         +  object-oriented delivery of discrete data or files and
            associated metadata (HTTP, FLUTE/ALC, NORM)

            -  with partial delivery of object ranges (HTTP)

      *  Directionality

         +  unidirectional (UDP, UDP-Lite, DCCP, RTP, FLUTE/ALC, NORM)

         +  bidirectional (TCP, MPTCP, SCTP, TLS, HTTP)

   o  Transmission control

      *  flow control (TCP, MPTCP, SCTP, DCCP, TLS, RTP, HTTP)

      *  congestion control (TCP, MPTCP, SCTP, DCCP, RTP, FLUTE/ALC,
         NORM).  Congestion control can also provided by the transport
         supporting an upper-layer transport (e.g., TLS, RTP, HTTP).

      *  segmentation (TCP, MPTCP, SCTP, TLS, RTP, HTTP, FLUTE/ALC,
         NORM)

      *  data/message bundling (TCP, MPTCP, SCTP, TLS, HTTP)

      *  stream scheduling prioritization (SCTP, HTTP2)

      *  endpoint multiplexing (MPTCP)





<span class="grey">Fairhurst, et al.             Informational                    [Page 41]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-42" id="page-42" name="page-42"> </a>
<span class="grey"><a href="rfc8095.html">RFC 8095</a>                   Transport Services                 March 2017</span>


   o  Security

      *  authentication of one end of a connection (TLS, DTLS, FLUTE/
         ALC)

      *  authentication of both ends of a connection (TLS, DTLS)

      *  confidentiality (TLS, DTLS)

      *  cryptographic integrity protection (TLS, DTLS)

      *  replay protection (TLS, DTLS, FLUTE/ALC)

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/6.%20%20IANA%20Considerations"></a><a class="selflink" href="#section-6" name="section-6">6</a>.  IANA Considerations</span>

   This document does not require any IANA actions.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/7.%20%20Security%20Considerations"></a><a class="selflink" href="#section-7" name="section-7">7</a>.  Security Considerations</span>

   This document surveys existing transport protocols and protocols
   providing transport-like services.  Confidentiality, integrity, and
   authenticity are among the features provided by those services.  This
   document does not specify any new features or mechanisms for
   providing these features.  Each RFC referenced by this document
   discusses the security considerations of the specification it
   contains.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/8.%20%20Informative%20References"></a><a class="selflink" href="#section-8" name="section-8">8</a>.  Informative References</span>

   [<a id="ref-ClarkArch" name="ref-ClarkArch">ClarkArch</a>]
              Clark, D. and D. Tennenhouse, "Architectural
              Considerations for a New Generation of Protocols",
              Proceedings of ACM SIGCOMM, DOI 10.1145/99517.99553, 1990.

   [<a id="ref-CUBIC" name="ref-CUBIC">CUBIC</a>]    Rhee, I., Xu, L., Ha, S., Zimmermann, A., Eggert, L., and
              R. Scheffenegger, "CUBIC for Fast Long-Distance Networks",
              Work in Progress, <a href="https://tools.ietf.org/html/draft-ietf-tcpm-cubic-04">draft-ietf-tcpm-cubic-04</a>, February 2017.

   [<a id="ref-MBMS" name="ref-MBMS">MBMS</a>]     3GPP, "Multimedia Broadcast/Multicast Service (MBMS);
              Protocols and codecs", 3GPP TS 26.346, 2015,
              &lt;<a href="http://www.3gpp.org/DynaReport/26346.htm">http://www.3gpp.org/DynaReport/26346.htm</a>&gt;.

   [<a id="ref-NAT-SUPP" name="ref-NAT-SUPP">NAT-SUPP</a>] Stewart, R., Tuexen, M., and I. Ruengeler, "Stream Control
              Transmission Protocol (SCTP) Network Address Translation
              Support", Work in Progress, <a href="https://tools.ietf.org/html/draft-ietf-tsvwg-natsupp-09">draft-ietf-tsvwg-natsupp-09</a>,
              May 2016.





<span class="grey">Fairhurst, et al.             Informational                    [Page 42]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-43" id="page-43" name="page-43"> </a>
<span class="grey"><a href="rfc8095.html">RFC 8095</a>                   Transport Services                 March 2017</span>


   [<a id="ref-POSIX" name="ref-POSIX">POSIX</a>]    IEEE, "Standard for Information Technology -- Portable
              Operating System Interface (POSIX(R)) Base Specifications,
              Issue 7", IEEE 1003.1, DOI 10.1109/ieeestd.2016.7582338,
              &lt;<a href="http://ieeexplore.ieee.org/document/7582338/">http://ieeexplore.ieee.org/document/7582338/</a>&gt;.

   [<a id="ref-REST" name="ref-REST">REST</a>]     Fielding, R., "Architectural Styles and the Design of
              Network-based Software Architectures, Chapter 5:
              Representational State Transfer", Ph.D.
              Dissertation, University of California, Irvine, 2000.

   [<a id="ref-RFC768" name="ref-RFC768">RFC768</a>]   Postel, J., "User Datagram Protocol", STD 6, <a href="rfc768.html">RFC 768</a>,
              DOI 10.17487/RFC0768, August 1980,
              &lt;<a href="http://www.rfc-editor.org/info/rfc768">http://www.rfc-editor.org/info/rfc768</a>&gt;.

   [<a id="ref-RFC792" name="ref-RFC792">RFC792</a>]   Postel, J., "Internet Control Message Protocol", STD 5,
              <a href="rfc792.html">RFC 792</a>, DOI 10.17487/RFC0792, September 1981,
              &lt;<a href="http://www.rfc-editor.org/info/rfc792">http://www.rfc-editor.org/info/rfc792</a>&gt;.

   [<a id="ref-RFC793" name="ref-RFC793">RFC793</a>]   Postel, J., "Transmission Control Protocol", STD 7,
              <a href="rfc793.html">RFC 793</a>, DOI 10.17487/RFC0793, September 1981,
              &lt;<a href="http://www.rfc-editor.org/info/rfc793">http://www.rfc-editor.org/info/rfc793</a>&gt;.

   [<a id="ref-RFC1071" name="ref-RFC1071">RFC1071</a>]  Braden, R., Borman, D., and C. Partridge, "Computing the
              Internet checksum", <a href="rfc1071.html">RFC 1071</a>, DOI 10.17487/RFC1071,
              September 1988, &lt;<a href="http://www.rfc-editor.org/info/rfc1071">http://www.rfc-editor.org/info/rfc1071</a>&gt;.

   [<a id="ref-RFC1122" name="ref-RFC1122">RFC1122</a>]  Braden, R., Ed., "Requirements for Internet Hosts -
              Communication Layers", STD 3, <a href="rfc1122.html">RFC 1122</a>,
              DOI 10.17487/RFC1122, October 1989,
              &lt;<a href="http://www.rfc-editor.org/info/rfc1122">http://www.rfc-editor.org/info/rfc1122</a>&gt;.

   [<a id="ref-RFC1191" name="ref-RFC1191">RFC1191</a>]  Mogul, J. and S. Deering, "Path MTU discovery", <a href="rfc1191.html">RFC 1191</a>,
              DOI 10.17487/RFC1191, November 1990,
              &lt;<a href="http://www.rfc-editor.org/info/rfc1191">http://www.rfc-editor.org/info/rfc1191</a>&gt;.

   [<a id="ref-RFC1812" name="ref-RFC1812">RFC1812</a>]  Baker, F., Ed., "Requirements for IP Version 4 Routers",
              <a href="rfc1812.html">RFC 1812</a>, DOI 10.17487/RFC1812, June 1995,
              &lt;<a href="http://www.rfc-editor.org/info/rfc1812">http://www.rfc-editor.org/info/rfc1812</a>&gt;.

   [<a id="ref-RFC1981" name="ref-RFC1981">RFC1981</a>]  McCann, J., Deering, S., and J. Mogul, "Path MTU Discovery
              for IP version 6", <a href="rfc1981.html">RFC 1981</a>, DOI 10.17487/RFC1981, August
              1996, &lt;<a href="http://www.rfc-editor.org/info/rfc1981">http://www.rfc-editor.org/info/rfc1981</a>&gt;.

   [<a id="ref-RFC2018" name="ref-RFC2018">RFC2018</a>]  Mathis, M., Mahdavi, J., Floyd, S., and A. Romanow, "TCP
              Selective Acknowledgment Options", <a href="rfc2018.html">RFC 2018</a>,
              DOI 10.17487/RFC2018, October 1996,
              &lt;<a href="http://www.rfc-editor.org/info/rfc2018">http://www.rfc-editor.org/info/rfc2018</a>&gt;.




<span class="grey">Fairhurst, et al.             Informational                    [Page 43]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-44" id="page-44" name="page-44"> </a>
<span class="grey"><a href="rfc8095.html">RFC 8095</a>                   Transport Services                 March 2017</span>


   [<a id="ref-RFC2045" name="ref-RFC2045">RFC2045</a>]  Freed, N. and N. Borenstein, "Multipurpose Internet Mail
              Extensions (MIME) Part One: Format of Internet Message
              Bodies", <a href="rfc2045.html">RFC 2045</a>, DOI 10.17487/RFC2045, November 1996,
              &lt;<a href="http://www.rfc-editor.org/info/rfc2045">http://www.rfc-editor.org/info/rfc2045</a>&gt;.

   [<a id="ref-RFC2460" name="ref-RFC2460">RFC2460</a>]  Deering, S. and R. Hinden, "Internet Protocol, Version 6
              (IPv6) Specification", <a href="rfc2460.html">RFC 2460</a>, DOI 10.17487/RFC2460,
              December 1998, &lt;<a href="http://www.rfc-editor.org/info/rfc2460">http://www.rfc-editor.org/info/rfc2460</a>&gt;.

   [<a id="ref-RFC2710" name="ref-RFC2710">RFC2710</a>]  Deering, S., Fenner, W., and B. Haberman, "Multicast
              Listener Discovery (MLD) for IPv6", <a href="rfc2710.html">RFC 2710</a>,
              DOI 10.17487/RFC2710, October 1999,
              &lt;<a href="http://www.rfc-editor.org/info/rfc2710">http://www.rfc-editor.org/info/rfc2710</a>&gt;.

   [<a id="ref-RFC2736" name="ref-RFC2736">RFC2736</a>]  Handley, M. and C. Perkins, "Guidelines for Writers of RTP
              Payload Format Specifications", <a href="https://tools.ietf.org/html/bcp36">BCP 36</a>, <a href="rfc2736.html">RFC 2736</a>,
              DOI 10.17487/RFC2736, December 1999,
              &lt;<a href="http://www.rfc-editor.org/info/rfc2736">http://www.rfc-editor.org/info/rfc2736</a>&gt;.

   [<a id="ref-RFC3168" name="ref-RFC3168">RFC3168</a>]  Ramakrishnan, K., Floyd, S., and D. Black, "The Addition
              of Explicit Congestion Notification (ECN) to IP",
              <a href="rfc3168.html">RFC 3168</a>, DOI 10.17487/RFC3168, September 2001,
              &lt;<a href="http://www.rfc-editor.org/info/rfc3168">http://www.rfc-editor.org/info/rfc3168</a>&gt;.

   [<a id="ref-RFC3205" name="ref-RFC3205">RFC3205</a>]  Moore, K., "On the use of HTTP as a Substrate", <a href="https://tools.ietf.org/html/bcp56">BCP 56</a>,
              <a href="rfc3205.html">RFC 3205</a>, DOI 10.17487/RFC3205, February 2002,
              &lt;<a href="http://www.rfc-editor.org/info/rfc3205">http://www.rfc-editor.org/info/rfc3205</a>&gt;.

   [<a id="ref-RFC3260" name="ref-RFC3260">RFC3260</a>]  Grossman, D., "New Terminology and Clarifications for
              Diffserv", <a href="rfc3260.html">RFC 3260</a>, DOI 10.17487/RFC3260, April 2002,
              &lt;<a href="http://www.rfc-editor.org/info/rfc3260">http://www.rfc-editor.org/info/rfc3260</a>&gt;.

   [<a id="ref-RFC3436" name="ref-RFC3436">RFC3436</a>]  Jungmaier, A., Rescorla, E., and M. Tuexen, "Transport
              Layer Security over Stream Control Transmission Protocol",
              <a href="rfc3436.html">RFC 3436</a>, DOI 10.17487/RFC3436, December 2002,
              &lt;<a href="http://www.rfc-editor.org/info/rfc3436">http://www.rfc-editor.org/info/rfc3436</a>&gt;.

   [<a id="ref-RFC3450" name="ref-RFC3450">RFC3450</a>]  Luby, M., Gemmell, J., Vicisano, L., Rizzo, L., and J.
              Crowcroft, "Asynchronous Layered Coding (ALC) Protocol
              Instantiation", <a href="rfc3450.html">RFC 3450</a>, DOI 10.17487/RFC3450, December
              2002, &lt;<a href="http://www.rfc-editor.org/info/rfc3450">http://www.rfc-editor.org/info/rfc3450</a>&gt;.

   [<a id="ref-RFC3550" name="ref-RFC3550">RFC3550</a>]  Schulzrinne, H., Casner, S., Frederick, R., and V.
              Jacobson, "RTP: A Transport Protocol for Real-Time
              Applications", STD 64, <a href="rfc3550.html">RFC 3550</a>, DOI 10.17487/RFC3550,
              July 2003, &lt;<a href="http://www.rfc-editor.org/info/rfc3550">http://www.rfc-editor.org/info/rfc3550</a>&gt;.





<span class="grey">Fairhurst, et al.             Informational                    [Page 44]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-45" id="page-45" name="page-45"> </a>
<span class="grey"><a href="rfc8095.html">RFC 8095</a>                   Transport Services                 March 2017</span>


   [<a id="ref-RFC3738" name="ref-RFC3738">RFC3738</a>]  Luby, M. and V. Goyal, "Wave and Equation Based Rate
              Control (WEBRC) Building Block", <a href="rfc3738.html">RFC 3738</a>,
              DOI 10.17487/RFC3738, April 2004,
              &lt;<a href="http://www.rfc-editor.org/info/rfc3738">http://www.rfc-editor.org/info/rfc3738</a>&gt;.

   [<a id="ref-RFC3758" name="ref-RFC3758">RFC3758</a>]  Stewart, R., Ramalho, M., Xie, Q., Tuexen, M., and P.
              Conrad, "Stream Control Transmission Protocol (SCTP)
              Partial Reliability Extension", <a href="rfc3758.html">RFC 3758</a>,
              DOI 10.17487/RFC3758, May 2004,
              &lt;<a href="http://www.rfc-editor.org/info/rfc3758">http://www.rfc-editor.org/info/rfc3758</a>&gt;.

   [<a id="ref-RFC3828" name="ref-RFC3828">RFC3828</a>]  Larzon, L-A., Degermark, M., Pink, S., Jonsson, L-E., Ed.,
              and G. Fairhurst, Ed., "The Lightweight User Datagram
              Protocol (UDP-Lite)", <a href="rfc3828.html">RFC 3828</a>, DOI 10.17487/RFC3828, July
              2004, &lt;<a href="http://www.rfc-editor.org/info/rfc3828">http://www.rfc-editor.org/info/rfc3828</a>&gt;.

   [<a id="ref-RFC3926" name="ref-RFC3926">RFC3926</a>]  Paila, T., Luby, M., Lehtonen, R., Roca, V., and R. Walsh,
              "FLUTE - File Delivery over Unidirectional Transport",
              <a href="rfc3926.html">RFC 3926</a>, DOI 10.17487/RFC3926, October 2004,
              &lt;<a href="http://www.rfc-editor.org/info/rfc3926">http://www.rfc-editor.org/info/rfc3926</a>&gt;.

   [<a id="ref-RFC3971" name="ref-RFC3971">RFC3971</a>]  Arkko, J., Ed., Kempf, J., Zill, B., and P. Nikander,
              "SEcure Neighbor Discovery (SEND)", <a href="rfc3971.html">RFC 3971</a>,
              DOI 10.17487/RFC3971, March 2005,
              &lt;<a href="http://www.rfc-editor.org/info/rfc3971">http://www.rfc-editor.org/info/rfc3971</a>&gt;.

   [<a id="ref-RFC4336" name="ref-RFC4336">RFC4336</a>]  Floyd, S., Handley, M., and E. Kohler, "Problem Statement
              for the Datagram Congestion Control Protocol (DCCP)",
              <a href="rfc4336.html">RFC 4336</a>, DOI 10.17487/RFC4336, March 2006,
              &lt;<a href="http://www.rfc-editor.org/info/rfc4336">http://www.rfc-editor.org/info/rfc4336</a>&gt;.

   [<a id="ref-RFC4340" name="ref-RFC4340">RFC4340</a>]  Kohler, E., Handley, M., and S. Floyd, "Datagram
              Congestion Control Protocol (DCCP)", <a href="rfc4340.html">RFC 4340</a>,
              DOI 10.17487/RFC4340, March 2006,
              &lt;<a href="http://www.rfc-editor.org/info/rfc4340">http://www.rfc-editor.org/info/rfc4340</a>&gt;.

   [<a id="ref-RFC4341" name="ref-RFC4341">RFC4341</a>]  Floyd, S. and E. Kohler, "Profile for Datagram Congestion
              Control Protocol (DCCP) Congestion Control ID 2: TCP-like
              Congestion Control", <a href="rfc4341.html">RFC 4341</a>, DOI 10.17487/RFC4341, March
              2006, &lt;<a href="http://www.rfc-editor.org/info/rfc4341">http://www.rfc-editor.org/info/rfc4341</a>&gt;.

   [<a id="ref-RFC4342" name="ref-RFC4342">RFC4342</a>]  Floyd, S., Kohler, E., and J. Padhye, "Profile for
              Datagram Congestion Control Protocol (DCCP) Congestion
              Control ID 3: TCP-Friendly Rate Control (TFRC)", <a href="rfc4342.html">RFC 4342</a>,
              DOI 10.17487/RFC4342, March 2006,
              &lt;<a href="http://www.rfc-editor.org/info/rfc4342">http://www.rfc-editor.org/info/rfc4342</a>&gt;.





<span class="grey">Fairhurst, et al.             Informational                    [Page 45]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-46" id="page-46" name="page-46"> </a>
<span class="grey"><a href="rfc8095.html">RFC 8095</a>                   Transport Services                 March 2017</span>


   [<a id="ref-RFC4443" name="ref-RFC4443">RFC4443</a>]  Conta, A., Deering, S., and M. Gupta, Ed., "Internet
              Control Message Protocol (ICMPv6) for the Internet
              Protocol Version 6 (IPv6) Specification", <a href="rfc4443.html">RFC 4443</a>,
              DOI 10.17487/RFC4443, March 2006,
              &lt;<a href="http://www.rfc-editor.org/info/rfc4443">http://www.rfc-editor.org/info/rfc4443</a>&gt;.

   [<a id="ref-RFC4654" name="ref-RFC4654">RFC4654</a>]  Widmer, J. and M. Handley, "TCP-Friendly Multicast
              Congestion Control (TFMCC): Protocol Specification",
              <a href="rfc4654.html">RFC 4654</a>, DOI 10.17487/RFC4654, August 2006,
              &lt;<a href="http://www.rfc-editor.org/info/rfc4654">http://www.rfc-editor.org/info/rfc4654</a>&gt;.

   [<a id="ref-RFC4820" name="ref-RFC4820">RFC4820</a>]  Tuexen, M., Stewart, R., and P. Lei, "Padding Chunk and
              Parameter for the Stream Control Transmission Protocol
              (SCTP)", <a href="rfc4820.html">RFC 4820</a>, DOI 10.17487/RFC4820, March 2007,
              &lt;<a href="http://www.rfc-editor.org/info/rfc4820">http://www.rfc-editor.org/info/rfc4820</a>&gt;.

   [<a id="ref-RFC4821" name="ref-RFC4821">RFC4821</a>]  Mathis, M. and J. Heffner, "Packetization Layer Path MTU
              Discovery", <a href="rfc4821.html">RFC 4821</a>, DOI 10.17487/RFC4821, March 2007,
              &lt;<a href="http://www.rfc-editor.org/info/rfc4821">http://www.rfc-editor.org/info/rfc4821</a>&gt;.

   [<a id="ref-RFC4828" name="ref-RFC4828">RFC4828</a>]  Floyd, S. and E. Kohler, "TCP Friendly Rate Control
              (TFRC): The Small-Packet (SP) Variant", <a href="rfc4828.html">RFC 4828</a>,
              DOI 10.17487/RFC4828, April 2007,
              &lt;<a href="http://www.rfc-editor.org/info/rfc4828">http://www.rfc-editor.org/info/rfc4828</a>&gt;.

   [<a id="ref-RFC4861" name="ref-RFC4861">RFC4861</a>]  Narten, T., Nordmark, E., Simpson, W., and H. Soliman,
              "Neighbor Discovery for IP version 6 (IPv6)", <a href="rfc4861.html">RFC 4861</a>,
              DOI 10.17487/RFC4861, September 2007,
              &lt;<a href="http://www.rfc-editor.org/info/rfc4861">http://www.rfc-editor.org/info/rfc4861</a>&gt;.

   [<a id="ref-RFC4895" name="ref-RFC4895">RFC4895</a>]  Tuexen, M., Stewart, R., Lei, P., and E. Rescorla,
              "Authenticated Chunks for the Stream Control Transmission
              Protocol (SCTP)", <a href="rfc4895.html">RFC 4895</a>, DOI 10.17487/RFC4895, August
              2007, &lt;<a href="http://www.rfc-editor.org/info/rfc4895">http://www.rfc-editor.org/info/rfc4895</a>&gt;.

   [<a id="ref-RFC4960" name="ref-RFC4960">RFC4960</a>]  Stewart, R., Ed., "Stream Control Transmission Protocol",
              <a href="rfc4960.html">RFC 4960</a>, DOI 10.17487/RFC4960, September 2007,
              &lt;<a href="http://www.rfc-editor.org/info/rfc4960">http://www.rfc-editor.org/info/rfc4960</a>&gt;.

   [<a id="ref-RFC5052" name="ref-RFC5052">RFC5052</a>]  Watson, M., Luby, M., and L. Vicisano, "Forward Error
              Correction (FEC) Building Block", <a href="rfc5052.html">RFC 5052</a>,
              DOI 10.17487/RFC5052, August 2007,
              &lt;<a href="http://www.rfc-editor.org/info/rfc5052">http://www.rfc-editor.org/info/rfc5052</a>&gt;.








<span class="grey">Fairhurst, et al.             Informational                    [Page 46]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-47" id="page-47" name="page-47"> </a>
<span class="grey"><a href="rfc8095.html">RFC 8095</a>                   Transport Services                 March 2017</span>


   [<a id="ref-RFC5061" name="ref-RFC5061">RFC5061</a>]  Stewart, R., Xie, Q., Tuexen, M., Maruyama, S., and M.
              Kozuka, "Stream Control Transmission Protocol (SCTP)
              Dynamic Address Reconfiguration", <a href="rfc5061.html">RFC 5061</a>,
              DOI 10.17487/RFC5061, September 2007,
              &lt;<a href="http://www.rfc-editor.org/info/rfc5061">http://www.rfc-editor.org/info/rfc5061</a>&gt;.

   [<a id="ref-RFC5097" name="ref-RFC5097">RFC5097</a>]  Renker, G. and G. Fairhurst, "MIB for the UDP-Lite
              protocol", <a href="rfc5097.html">RFC 5097</a>, DOI 10.17487/RFC5097, January 2008,
              &lt;<a href="http://www.rfc-editor.org/info/rfc5097">http://www.rfc-editor.org/info/rfc5097</a>&gt;.

   [<a id="ref-RFC5238" name="ref-RFC5238">RFC5238</a>]  Phelan, T., "Datagram Transport Layer Security (DTLS) over
              the Datagram Congestion Control Protocol (DCCP)",
              <a href="rfc5238.html">RFC 5238</a>, DOI 10.17487/RFC5238, May 2008,
              &lt;<a href="http://www.rfc-editor.org/info/rfc5238">http://www.rfc-editor.org/info/rfc5238</a>&gt;.

   [<a id="ref-RFC5246" name="ref-RFC5246">RFC5246</a>]  Dierks, T. and E. Rescorla, "The Transport Layer Security
              (TLS) Protocol Version 1.2", <a href="rfc5246.html">RFC 5246</a>,
              DOI 10.17487/RFC5246, August 2008,
              &lt;<a href="http://www.rfc-editor.org/info/rfc5246">http://www.rfc-editor.org/info/rfc5246</a>&gt;.

   [<a id="ref-RFC5348" name="ref-RFC5348">RFC5348</a>]  Floyd, S., Handley, M., Padhye, J., and J. Widmer, "TCP
              Friendly Rate Control (TFRC): Protocol Specification",
              <a href="rfc5348.html">RFC 5348</a>, DOI 10.17487/RFC5348, September 2008,
              &lt;<a href="http://www.rfc-editor.org/info/rfc5348">http://www.rfc-editor.org/info/rfc5348</a>&gt;.

   [<a id="ref-RFC5461" name="ref-RFC5461">RFC5461</a>]  Gont, F., "TCP's Reaction to Soft Errors", <a href="rfc5461.html">RFC 5461</a>,
              DOI 10.17487/RFC5461, February 2009,
              &lt;<a href="http://www.rfc-editor.org/info/rfc5461">http://www.rfc-editor.org/info/rfc5461</a>&gt;.

   [<a id="ref-RFC5595" name="ref-RFC5595">RFC5595</a>]  Fairhurst, G., "The Datagram Congestion Control Protocol
              (DCCP) Service Codes", <a href="rfc5595.html">RFC 5595</a>, DOI 10.17487/RFC5595,
              September 2009, &lt;<a href="http://www.rfc-editor.org/info/rfc5595">http://www.rfc-editor.org/info/rfc5595</a>&gt;.

   [<a id="ref-RFC5596" name="ref-RFC5596">RFC5596</a>]  Fairhurst, G., "Datagram Congestion Control Protocol
              (DCCP) Simultaneous-Open Technique to Facilitate NAT/
              Middlebox Traversal", <a href="rfc5596.html">RFC 5596</a>, DOI 10.17487/RFC5596,
              September 2009, &lt;<a href="http://www.rfc-editor.org/info/rfc5596">http://www.rfc-editor.org/info/rfc5596</a>&gt;.

   [<a id="ref-RFC5622" name="ref-RFC5622">RFC5622</a>]  Floyd, S. and E. Kohler, "Profile for Datagram Congestion
              Control Protocol (DCCP) Congestion ID 4: TCP-Friendly Rate
              Control for Small Packets (TFRC-SP)", <a href="rfc5622.html">RFC 5622</a>,
              DOI 10.17487/RFC5622, August 2009,
              &lt;<a href="http://www.rfc-editor.org/info/rfc5622">http://www.rfc-editor.org/info/rfc5622</a>&gt;.

   [<a id="ref-RFC5651" name="ref-RFC5651">RFC5651</a>]  Luby, M., Watson, M., and L. Vicisano, "Layered Coding
              Transport (LCT) Building Block", <a href="rfc5651.html">RFC 5651</a>,
              DOI 10.17487/RFC5651, October 2009,
              &lt;<a href="http://www.rfc-editor.org/info/rfc5651">http://www.rfc-editor.org/info/rfc5651</a>&gt;.



<span class="grey">Fairhurst, et al.             Informational                    [Page 47]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-48" id="page-48" name="page-48"> </a>
<span class="grey"><a href="rfc8095.html">RFC 8095</a>                   Transport Services                 March 2017</span>


   [<a id="ref-RFC5681" name="ref-RFC5681">RFC5681</a>]  Allman, M., Paxson, V., and E. Blanton, "TCP Congestion
              Control", <a href="rfc5681.html">RFC 5681</a>, DOI 10.17487/RFC5681, September 2009,
              &lt;<a href="http://www.rfc-editor.org/info/rfc5681">http://www.rfc-editor.org/info/rfc5681</a>&gt;.

   [<a id="ref-RFC5740" name="ref-RFC5740">RFC5740</a>]  Adamson, B., Bormann, C., Handley, M., and J. Macker,
              "NACK-Oriented Reliable Multicast (NORM) Transport
              Protocol", <a href="rfc5740.html">RFC 5740</a>, DOI 10.17487/RFC5740, November 2009,
              &lt;<a href="http://www.rfc-editor.org/info/rfc5740">http://www.rfc-editor.org/info/rfc5740</a>&gt;.

   [<a id="ref-RFC5762" name="ref-RFC5762">RFC5762</a>]  Perkins, C., "RTP and the Datagram Congestion Control
              Protocol (DCCP)", <a href="rfc5762.html">RFC 5762</a>, DOI 10.17487/RFC5762, April
              2010, &lt;<a href="http://www.rfc-editor.org/info/rfc5762">http://www.rfc-editor.org/info/rfc5762</a>&gt;.

   [<a id="ref-RFC5775" name="ref-RFC5775">RFC5775</a>]  Luby, M., Watson, M., and L. Vicisano, "Asynchronous
              Layered Coding (ALC) Protocol Instantiation", <a href="rfc5775.html">RFC 5775</a>,
              DOI 10.17487/RFC5775, April 2010,
              &lt;<a href="http://www.rfc-editor.org/info/rfc5775">http://www.rfc-editor.org/info/rfc5775</a>&gt;.

   [<a id="ref-RFC6056" name="ref-RFC6056">RFC6056</a>]  Larsen, M. and F. Gont, "Recommendations for Transport-
              Protocol Port Randomization", <a href="https://tools.ietf.org/html/bcp156">BCP 156</a>, <a href="rfc6056.html">RFC 6056</a>,
              DOI 10.17487/RFC6056, January 2011,
              &lt;<a href="http://www.rfc-editor.org/info/rfc6056">http://www.rfc-editor.org/info/rfc6056</a>&gt;.

   [<a id="ref-RFC6083" name="ref-RFC6083">RFC6083</a>]  Tuexen, M., Seggelmann, R., and E. Rescorla, "Datagram
              Transport Layer Security (DTLS) for Stream Control
              Transmission Protocol (SCTP)", <a href="rfc6083.html">RFC 6083</a>,
              DOI 10.17487/RFC6083, January 2011,
              &lt;<a href="http://www.rfc-editor.org/info/rfc6083">http://www.rfc-editor.org/info/rfc6083</a>&gt;.

   [<a id="ref-RFC6093" name="ref-RFC6093">RFC6093</a>]  Gont, F. and A. Yourtchenko, "On the Implementation of the
              TCP Urgent Mechanism", <a href="rfc6093.html">RFC 6093</a>, DOI 10.17487/RFC6093,
              January 2011, &lt;<a href="http://www.rfc-editor.org/info/rfc6093">http://www.rfc-editor.org/info/rfc6093</a>&gt;.

   [<a id="ref-RFC6101" name="ref-RFC6101">RFC6101</a>]  Freier, A., Karlton, P., and P. Kocher, "The Secure
              Sockets Layer (SSL) Protocol Version 3.0", <a href="rfc6101.html">RFC 6101</a>,
              DOI 10.17487/RFC6101, August 2011,
              &lt;<a href="http://www.rfc-editor.org/info/rfc6101">http://www.rfc-editor.org/info/rfc6101</a>&gt;.

   [<a id="ref-RFC6347" name="ref-RFC6347">RFC6347</a>]  Rescorla, E. and N. Modadugu, "Datagram Transport Layer
              Security Version 1.2", <a href="rfc6347.html">RFC 6347</a>, DOI 10.17487/RFC6347,
              January 2012, &lt;<a href="http://www.rfc-editor.org/info/rfc6347">http://www.rfc-editor.org/info/rfc6347</a>&gt;.

   [<a id="ref-RFC6356" name="ref-RFC6356">RFC6356</a>]  Raiciu, C., Handley, M., and D. Wischik, "Coupled
              Congestion Control for Multipath Transport Protocols",
              <a href="rfc6356.html">RFC 6356</a>, DOI 10.17487/RFC6356, October 2011,
              &lt;<a href="http://www.rfc-editor.org/info/rfc6356">http://www.rfc-editor.org/info/rfc6356</a>&gt;.





<span class="grey">Fairhurst, et al.             Informational                    [Page 48]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-49" id="page-49" name="page-49"> </a>
<span class="grey"><a href="rfc8095.html">RFC 8095</a>                   Transport Services                 March 2017</span>


   [<a id="ref-RFC6363" name="ref-RFC6363">RFC6363</a>]  Watson, M., Begen, A., and V. Roca, "Forward Error
              Correction (FEC) Framework", <a href="rfc6363.html">RFC 6363</a>,
              DOI 10.17487/RFC6363, October 2011,
              &lt;<a href="http://www.rfc-editor.org/info/rfc6363">http://www.rfc-editor.org/info/rfc6363</a>&gt;.

   [<a id="ref-RFC6458" name="ref-RFC6458">RFC6458</a>]  Stewart, R., Tuexen, M., Poon, K., Lei, P., and V.
              Yasevich, "Sockets API Extensions for the Stream Control
              Transmission Protocol (SCTP)", <a href="rfc6458.html">RFC 6458</a>,
              DOI 10.17487/RFC6458, December 2011,
              &lt;<a href="http://www.rfc-editor.org/info/rfc6458">http://www.rfc-editor.org/info/rfc6458</a>&gt;.

   [<a id="ref-RFC6525" name="ref-RFC6525">RFC6525</a>]  Stewart, R., Tuexen, M., and P. Lei, "Stream Control
              Transmission Protocol (SCTP) Stream Reconfiguration",
              <a href="rfc6525.html">RFC 6525</a>, DOI 10.17487/RFC6525, February 2012,
              &lt;<a href="http://www.rfc-editor.org/info/rfc6525">http://www.rfc-editor.org/info/rfc6525</a>&gt;.

   [<a id="ref-RFC6582" name="ref-RFC6582">RFC6582</a>]  Henderson, T., Floyd, S., Gurtov, A., and Y. Nishida, "The
              NewReno Modification to TCP's Fast Recovery Algorithm",
              <a href="rfc6582.html">RFC 6582</a>, DOI 10.17487/RFC6582, April 2012,
              &lt;<a href="http://www.rfc-editor.org/info/rfc6582">http://www.rfc-editor.org/info/rfc6582</a>&gt;.

   [<a id="ref-RFC6584" name="ref-RFC6584">RFC6584</a>]  Roca, V., "Simple Authentication Schemes for the
              Asynchronous Layered Coding (ALC) and NACK-Oriented
              Reliable Multicast (NORM) Protocols", <a href="rfc6584.html">RFC 6584</a>,
              DOI 10.17487/RFC6584, April 2012,
              &lt;<a href="http://www.rfc-editor.org/info/rfc6584">http://www.rfc-editor.org/info/rfc6584</a>&gt;.

   [<a id="ref-RFC6726" name="ref-RFC6726">RFC6726</a>]  Paila, T., Walsh, R., Luby, M., Roca, V., and R. Lehtonen,
              "FLUTE - File Delivery over Unidirectional Transport",
              <a href="rfc6726.html">RFC 6726</a>, DOI 10.17487/RFC6726, November 2012,
              &lt;<a href="http://www.rfc-editor.org/info/rfc6726">http://www.rfc-editor.org/info/rfc6726</a>&gt;.

   [<a id="ref-RFC6773" name="ref-RFC6773">RFC6773</a>]  Phelan, T., Fairhurst, G., and C. Perkins, "DCCP-UDP: A
              Datagram Congestion Control Protocol UDP Encapsulation for
              NAT Traversal", <a href="rfc6773.html">RFC 6773</a>, DOI 10.17487/RFC6773, November
              2012, &lt;<a href="http://www.rfc-editor.org/info/rfc6773">http://www.rfc-editor.org/info/rfc6773</a>&gt;.

   [<a id="ref-RFC6817" name="ref-RFC6817">RFC6817</a>]  Shalunov, S., Hazel, G., Iyengar, J., and M. Kuehlewind,
              "Low Extra Delay Background Transport (LEDBAT)", <a href="rfc6817.html">RFC 6817</a>,
              DOI 10.17487/RFC6817, December 2012,
              &lt;<a href="http://www.rfc-editor.org/info/rfc6817">http://www.rfc-editor.org/info/rfc6817</a>&gt;.

   [<a id="ref-RFC6824" name="ref-RFC6824">RFC6824</a>]  Ford, A., Raiciu, C., Handley, M., and O. Bonaventure,
              "TCP Extensions for Multipath Operation with Multiple
              Addresses", <a href="rfc6824.html">RFC 6824</a>, DOI 10.17487/RFC6824, January 2013,
              &lt;<a href="http://www.rfc-editor.org/info/rfc6824">http://www.rfc-editor.org/info/rfc6824</a>&gt;.





<span class="grey">Fairhurst, et al.             Informational                    [Page 49]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-50" id="page-50" name="page-50"> </a>
<span class="grey"><a href="rfc8095.html">RFC 8095</a>                   Transport Services                 March 2017</span>


   [<a id="ref-RFC6897" name="ref-RFC6897">RFC6897</a>]  Scharf, M. and A. Ford, "Multipath TCP (MPTCP) Application
              Interface Considerations", <a href="rfc6897.html">RFC 6897</a>, DOI 10.17487/RFC6897,
              March 2013, &lt;<a href="http://www.rfc-editor.org/info/rfc6897">http://www.rfc-editor.org/info/rfc6897</a>&gt;.

   [<a id="ref-RFC6935" name="ref-RFC6935">RFC6935</a>]  Eubanks, M., Chimento, P., and M. Westerlund, "IPv6 and
              UDP Checksums for Tunneled Packets", <a href="rfc6935.html">RFC 6935</a>,
              DOI 10.17487/RFC6935, April 2013,
              &lt;<a href="http://www.rfc-editor.org/info/rfc6935">http://www.rfc-editor.org/info/rfc6935</a>&gt;.

   [<a id="ref-RFC6936" name="ref-RFC6936">RFC6936</a>]  Fairhurst, G. and M. Westerlund, "Applicability Statement
              for the Use of IPv6 UDP Datagrams with Zero Checksums",
              <a href="rfc6936.html">RFC 6936</a>, DOI 10.17487/RFC6936, April 2013,
              &lt;<a href="http://www.rfc-editor.org/info/rfc6936">http://www.rfc-editor.org/info/rfc6936</a>&gt;.

   [<a id="ref-RFC6951" name="ref-RFC6951">RFC6951</a>]  Tuexen, M. and R. Stewart, "UDP Encapsulation of Stream
              Control Transmission Protocol (SCTP) Packets for End-Host
              to End-Host Communication", <a href="rfc6951.html">RFC 6951</a>,
              DOI 10.17487/RFC6951, May 2013,
              &lt;<a href="http://www.rfc-editor.org/info/rfc6951">http://www.rfc-editor.org/info/rfc6951</a>&gt;.

   [<a id="ref-RFC7053" name="ref-RFC7053">RFC7053</a>]  Tuexen, M., Ruengeler, I., and R. Stewart, "SACK-
              IMMEDIATELY Extension for the Stream Control Transmission
              Protocol", <a href="rfc7053.html">RFC 7053</a>, DOI 10.17487/RFC7053, November 2013,
              &lt;<a href="http://www.rfc-editor.org/info/rfc7053">http://www.rfc-editor.org/info/rfc7053</a>&gt;.

   [<a id="ref-RFC7202" name="ref-RFC7202">RFC7202</a>]  Perkins, C. and M. Westerlund, "Securing the RTP
              Framework: Why RTP Does Not Mandate a Single Media
              Security Solution", <a href="rfc7202.html">RFC 7202</a>, DOI 10.17487/RFC7202, April
              2014, &lt;<a href="http://www.rfc-editor.org/info/rfc7202">http://www.rfc-editor.org/info/rfc7202</a>&gt;.

   [<a id="ref-RFC7230" name="ref-RFC7230">RFC7230</a>]  Fielding, R., Ed. and J. Reschke, Ed., "Hypertext Transfer
              Protocol (HTTP/1.1): Message Syntax and Routing",
              <a href="rfc7230.html">RFC 7230</a>, DOI 10.17487/RFC7230, June 2014,
              &lt;<a href="http://www.rfc-editor.org/info/rfc7230">http://www.rfc-editor.org/info/rfc7230</a>&gt;.

   [<a id="ref-RFC7231" name="ref-RFC7231">RFC7231</a>]  Fielding, R., Ed. and J. Reschke, Ed., "Hypertext Transfer
              Protocol (HTTP/1.1): Semantics and Content", <a href="rfc7231.html">RFC 7231</a>,
              DOI 10.17487/RFC7231, June 2014,
              &lt;<a href="http://www.rfc-editor.org/info/rfc7231">http://www.rfc-editor.org/info/rfc7231</a>&gt;.

   [<a id="ref-RFC7232" name="ref-RFC7232">RFC7232</a>]  Fielding, R., Ed. and J. Reschke, Ed., "Hypertext Transfer
              Protocol (HTTP/1.1): Conditional Requests", <a href="rfc7232.html">RFC 7232</a>,
              DOI 10.17487/RFC7232, June 2014,
              &lt;<a href="http://www.rfc-editor.org/info/rfc7232">http://www.rfc-editor.org/info/rfc7232</a>&gt;.







<span class="grey">Fairhurst, et al.             Informational                    [Page 50]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-51" id="page-51" name="page-51"> </a>
<span class="grey"><a href="rfc8095.html">RFC 8095</a>                   Transport Services                 March 2017</span>


   [<a id="ref-RFC7233" name="ref-RFC7233">RFC7233</a>]  Fielding, R., Ed., Lafon, Y., Ed., and J. Reschke, Ed.,
              "Hypertext Transfer Protocol (HTTP/1.1): Range Requests",
              <a href="rfc7233.html">RFC 7233</a>, DOI 10.17487/RFC7233, June 2014,
              &lt;<a href="http://www.rfc-editor.org/info/rfc7233">http://www.rfc-editor.org/info/rfc7233</a>&gt;.

   [<a id="ref-RFC7234" name="ref-RFC7234">RFC7234</a>]  Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke,
              Ed., "Hypertext Transfer Protocol (HTTP/1.1): Caching",
              <a href="rfc7234.html">RFC 7234</a>, DOI 10.17487/RFC7234, June 2014,
              &lt;<a href="http://www.rfc-editor.org/info/rfc7234">http://www.rfc-editor.org/info/rfc7234</a>&gt;.

   [<a id="ref-RFC7235" name="ref-RFC7235">RFC7235</a>]  Fielding, R., Ed. and J. Reschke, Ed., "Hypertext Transfer
              Protocol (HTTP/1.1): Authentication", <a href="rfc7235.html">RFC 7235</a>,
              DOI 10.17487/RFC7235, June 2014,
              &lt;<a href="http://www.rfc-editor.org/info/rfc7235">http://www.rfc-editor.org/info/rfc7235</a>&gt;.

   [<a id="ref-RFC7301" name="ref-RFC7301">RFC7301</a>]  Friedl, S., Popov, A., Langley, A., and E. Stephan,
              "Transport Layer Security (TLS) Application-Layer Protocol
              Negotiation Extension", <a href="rfc7301.html">RFC 7301</a>, DOI 10.17487/RFC7301,
              July 2014, &lt;<a href="http://www.rfc-editor.org/info/rfc7301">http://www.rfc-editor.org/info/rfc7301</a>&gt;.

   [<a id="ref-RFC7323" name="ref-RFC7323">RFC7323</a>]  Borman, D., Braden, B., Jacobson, V., and R.
              Scheffenegger, Ed., "TCP Extensions for High Performance",
              <a href="rfc7323.html">RFC 7323</a>, DOI 10.17487/RFC7323, September 2014,
              &lt;<a href="http://www.rfc-editor.org/info/rfc7323">http://www.rfc-editor.org/info/rfc7323</a>&gt;.

   [<a id="ref-RFC7414" name="ref-RFC7414">RFC7414</a>]  Duke, M., Braden, R., Eddy, W., Blanton, E., and A.
              Zimmermann, "A Roadmap for Transmission Control Protocol
              (TCP) Specification Documents", <a href="rfc7414.html">RFC 7414</a>,
              DOI 10.17487/RFC7414, February 2015,
              &lt;<a href="http://www.rfc-editor.org/info/rfc7414">http://www.rfc-editor.org/info/rfc7414</a>&gt;.

   [<a id="ref-RFC7457" name="ref-RFC7457">RFC7457</a>]  Sheffer, Y., Holz, R., and P. Saint-Andre, "Summarizing
              Known Attacks on Transport Layer Security (TLS) and
              Datagram TLS (DTLS)", <a href="rfc7457.html">RFC 7457</a>, DOI 10.17487/RFC7457,
              February 2015, &lt;<a href="http://www.rfc-editor.org/info/rfc7457">http://www.rfc-editor.org/info/rfc7457</a>&gt;.

   [<a id="ref-RFC7496" name="ref-RFC7496">RFC7496</a>]  Tuexen, M., Seggelmann, R., Stewart, R., and S. Loreto,
              "Additional Policies for the Partially Reliable Stream
              Control Transmission Protocol Extension", <a href="rfc7496.html">RFC 7496</a>,
              DOI 10.17487/RFC7496, April 2015,
              &lt;<a href="http://www.rfc-editor.org/info/rfc7496">http://www.rfc-editor.org/info/rfc7496</a>&gt;.

   [<a id="ref-RFC7525" name="ref-RFC7525">RFC7525</a>]  Sheffer, Y., Holz, R., and P. Saint-Andre,
              "Recommendations for Secure Use of Transport Layer
              Security (TLS) and Datagram Transport Layer Security
              (DTLS)", <a href="https://tools.ietf.org/html/bcp195">BCP 195</a>, <a href="rfc7525.html">RFC 7525</a>, DOI 10.17487/RFC7525, May
              2015, &lt;<a href="http://www.rfc-editor.org/info/rfc7525">http://www.rfc-editor.org/info/rfc7525</a>&gt;.




<span class="grey">Fairhurst, et al.             Informational                    [Page 51]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-52" id="page-52" name="page-52"> </a>
<span class="grey"><a href="rfc8095.html">RFC 8095</a>                   Transport Services                 March 2017</span>


   [<a id="ref-RFC7540" name="ref-RFC7540">RFC7540</a>]  Belshe, M., Peon, R., and M. Thomson, Ed., "Hypertext
              Transfer Protocol Version 2 (HTTP/2)", <a href="rfc7540.html">RFC 7540</a>,
              DOI 10.17487/RFC7540, May 2015,
              &lt;<a href="http://www.rfc-editor.org/info/rfc7540">http://www.rfc-editor.org/info/rfc7540</a>&gt;.

   [<a id="ref-RFC8085" name="ref-RFC8085">RFC8085</a>]  Eggert, L., Fairhurst, G., and G. Shepherd, "UDP Usage
              Guidelines", <a href="https://tools.ietf.org/html/bcp145">BCP 145</a>, <a href="rfc8085.html">RFC 8085</a>, DOI 10.17487/RFC8085,
              March 2017, &lt;<a href="http://www.rfc-editor.org/info/rfc8085">http://www.rfc-editor.org/info/rfc8085</a>&gt;.

   [<a id="ref-SCTP-DTLS-ENCAPS" name="ref-SCTP-DTLS-ENCAPS">SCTP-DTLS-ENCAPS</a>]
              Tuexen, M., Stewart, R., Jesup, R., and S. Loreto, "DTLS
              Encapsulation of SCTP Packets", Work in Progress,
              <a href="https://tools.ietf.org/html/draft-ietf-tsvwg-sctp-dtls-encaps-09">draft-ietf-tsvwg-sctp-dtls-encaps-09</a>, January 2015.

   [<a id="ref-SCTP-NDATA" name="ref-SCTP-NDATA">SCTP-NDATA</a>]
              Stewart, R., Tuexen, M., Loreto, S., and R. Seggelmann,
              "Stream Schedulers and User Message Interleaving for the
              Stream Control Transmission Protocol", Work in Progress,
              <a href="https://tools.ietf.org/html/draft-ietf-tsvwg-sctp-ndata-08">draft-ietf-tsvwg-sctp-ndata-08</a>, October 2016.

   [<a id="ref-TCP-SPEC" name="ref-TCP-SPEC">TCP-SPEC</a>] Eddy, W., Ed., "Transmission Control Protocol
              Specification", Work in Progress, <a href="https://tools.ietf.org/html/draft-ietf-tcpm-rfc793bis-04">draft-ietf-tcpm-</a>
              <a href="https://tools.ietf.org/html/draft-ietf-tcpm-rfc793bis-04">rfc793bis-04</a>, December 2016.

   [<a id="ref-TLS-1.3" name="ref-TLS-1.3">TLS-1.3</a>]  Rescorla, E., "The Transport Layer Security (TLS) Protocol
              Version 1.3", Work in Progress, <a href="https://tools.ietf.org/html/draft-ietf-tls-tls13-18">draft-ietf-tls-tls13-18</a>,
              October 2016.

   [<a id="ref-WEBRTC-TRANS" name="ref-WEBRTC-TRANS">WEBRTC-TRANS</a>]
              Alvestrand, H., <a href="https://www.google.com/search?sitesearch=tools.ietf.org%2Fhtml%2F&amp;q=inurl:draft-+%22Transports+for+WebRTC%22" style="text-decoration: none">"Transports for WebRTC"</a>, Work in
              Progress, <a href="https://tools.ietf.org/html/draft-ietf-rtcweb-transports-17">draft-ietf-rtcweb-transports-17</a>, October 2016.

   [<a id="ref-XHR" name="ref-XHR">XHR</a>]      van Kesteren, A., Aubourg, J., Song, J., and H. Steen,
              "XMLHttpRequest Level 1", World Wide Web Consortium NOTE-
              XMLHttpRequest-20161006, October 2016,
              &lt;<a href="http://www.w3.org/TR/XMLHttpRequest/">http://www.w3.org/TR/XMLHttpRequest/</a>&gt;.















<span class="grey">Fairhurst, et al.             Informational                    [Page 52]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-53" id="page-53" name="page-53"> </a>
<span class="grey"><a href="rfc8095.html">RFC 8095</a>                   Transport Services                 March 2017</span>


Acknowledgments

   Thanks to Joe Touch, Michael Welzl, Spencer Dawkins, and the TAPS
   working group for the comments, feedback, and discussion.  This work
   is supported by the European Commission under grant agreement No.
   318627 mPlane and from the Horizon 2020 research and innovation
   program under grant agreements No. 644334 (NEAT) and No. 688421
   (MAMI).  This support does not imply endorsement.

Contributors

   In addition to the editors, this document is the work of Brian
   Adamson, Dragana Damjanovic, Kevin Fall, Simone Ferlin-Oliviera,
   Ralph Holz, Olivier Mehani, Karen Nielsen, Colin Perkins, Vincent
   Roca, and Michael Tuexen.

   o  <a href="#section-3.2">Section 3.2</a> on MPTCP was contributed by Simone Ferlin-Oliviera
      (ferlin@simula.no) and Olivier Mehani
      (olivier.mehani@nicta.com.au).

   o  <a href="#section-3.3">Section 3.3</a> on UDP was contributed by Kevin Fall
      (kfall@kfall.com).

   o  <a href="#section-3.5">Section 3.5</a> on SCTP was contributed by Michael Tuexen (tuexen@fh-
      muenster.de) and Karen Nielsen (karen.nielsen@tieto.com).

   o  <a href="#section-3.7">Section 3.7</a> on TLS and DTLS was contributed by Ralph Holz
      (ralph.holz@nicta.com.au) and Olivier Mehani
      (olivier.mehani@nicta.com.au).

   o  <a href="#section-3.8">Section 3.8</a> on RTP contains contributions from Colin Perkins
      (csp@csperkins.org).

   o  <a href="#section-3.9">Section 3.9</a> on HTTP was contributed by Dragana Damjanovic
      (ddamjanovic@mozilla.com).

   o  <a href="#section-3.10">Section 3.10</a> on FLUTE/ALC was contributed by Vincent Roca
      (vincent.roca@inria.fr).

   o  <a href="#section-3.11">Section 3.11</a> on NORM was contributed by Brian Adamson
      (brian.adamson@nrl.navy.mil).










<span class="grey">Fairhurst, et al.             Informational                    [Page 53]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-54" id="page-54" name="page-54"> </a>
<span class="grey"><a href="rfc8095.html">RFC 8095</a>                   Transport Services                 March 2017</span>


Authors' Addresses

   Godred Fairhurst (editor)
   University of Aberdeen
   School of Engineering, Fraser Noble Building
   Aberdeen AB24 3UE

   Email: gorry@erg.abdn.ac.uk


   Brian Trammell (editor)
   ETH Zurich
   Gloriastrasse 35
   8092 Zurich
   Switzerland

   Email: ietf@trammell.ch


   Mirja Kuehlewind (editor)
   ETH Zurich
   Gloriastrasse 35
   8092 Zurich
   Switzerland

   Email: mirja.kuehlewind@tik.ee.ethz.ch

























Fairhurst, et al.             Informational                    [Page 54]

</pre><br/>
    <span class="noprint"><small><small>Html markup produced by rfcmarkup 1.126, available from
      <a href="https://tools.ietf.org/tools/rfcmarkup/">https://tools.ietf.org/tools/rfcmarkup/</a>
    </small></small></span>
  </div>




</body><!-- Mirrored from tools.ietf.org/html/rfc8095 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 06 Mar 2018 23:18:18 GMT --></html>