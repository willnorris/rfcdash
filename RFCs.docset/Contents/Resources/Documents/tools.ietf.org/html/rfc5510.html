<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml"><!-- Mirrored from tools.ietf.org/html/rfc5510 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 06 Mar 2018 23:18:34 GMT --><!-- Added by HTTrack --><head><meta content="text/html;charset=utf-8" http-equiv="content-type"/><!-- /Added by HTTrack -->

    <meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
    <meta content="index,follow" name="robots"/>
    <meta content="rfcmarkup version 1.126" name="creator"/>
    <link href="http://purl.org/dc/elements/1.1/" rel="schema.DC"/>
<meta content="urn:ietf:rfc:5510" name="DC.Identifier"/>
<meta content="This document describes a Fully-Specified Forward Error Correction
(FEC) Scheme for the Reed-Solomon FEC codes over GF(2^^m), where m is
in {2..16}, and its application to the reliable delivery of data
objects on the packet erasure channel (i.e., a communication path
where packets are either received without any corruption or discarded
during transmission). This document also describes a Fully-Specified
FEC Scheme for the special case of Reed-Solomon codes over GF(2^^8)
when there is no encoding symbol group. Finally, in the context of the
Under-Specified Small Block Systematic FEC Scheme (FEC Encoding ID
129), this document assigns an FEC Instance ID to the special case of
Reed-Solomon codes over GF(2^^8).  Reed-Solomon codes belong to the
class of Maximum Distance Separable (MDS) codes, i.e., they enable a
receiver to recover the k source symbols from any set of k received
symbols. The schemes described here are compatible with the
implementation from Luigi Rizzo. [STANDARDS-TRACK]" name="DC.Description.Abstract"/>
<meta content="Peltotalo, Jani" name="DC.Creator"/>
<meta content="Roca, Vincent" name="DC.Creator"/>
<meta content="Peltotalo, Sami" name="DC.Creator"/>
<meta content="Lacan, Jerome" name="DC.Creator"/>
<meta content="April, 2009" name="DC.Date.Issued"/>
<meta content="Reed-Solomon Forward Error Correction (FEC) Schemes" name="DC.Title"/>

    <link href="https://tools.ietf.org/images/rfc.png" rel="icon" type="image/png"/>
    <link href="https://tools.ietf.org/images/rfc.png" rel="shortcut icon" type="image/png"/>
    <title>RFC 5510 - Reed-Solomon Forward Error Correction (FEC) Schemes</title>
    
    
    <style type="text/css">
	@media only screen 
	  and (min-width: 992px)
	  and (max-width: 1199px) {
	    body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 768px)
	  and (max-width: 991px) {
            body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 480px)
	  and (max-width: 767px) {
            body { font-size: 11pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (max-width: 479px) {
            body { font-size: 8pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-device-width : 375px) 
	  and (max-device-width : 667px) {
            body { font-size: 9.5pt; }
            div.content { width: 96ex; margin: 0 1px; }
        }
	@media only screen 
	  and (min-device-width: 1200px) {
            body { font-size: 10pt; margin: 0 4em; }
            div.content { width: 96ex; margin: 0; }
        }
        h1, h2, h3, h4, h5, h6, .h1, .h2, .h3, .h4, .h5, .h6 {
	    font-weight: bold;
            line-height: 0pt;
            display: inline;
            white-space: pre;
            font-family: monospace;
            font-size: 1em;
	    font-weight: bold;
        }
        pre {
            font-size: 1em;
            margin-top: 0px;
            margin-bottom: 0px;
        }
	.pre {
	    white-space: pre;
	    font-family: monospace;
	}
	.header{
	    font-weight: bold;
	}
        .newpage {
            page-break-before: always;
        }
        .invisible {
            text-decoration: none;
            color: white;
        }
        a.selflink {
          color: black;
          text-decoration: none;
        }
        @media print {
            body {
                font-family: monospace;
                font-size: 10.5pt;
            }
            h1, h2, h3, h4, h5, h6 {
                font-size: 1em;
            }
        
            a:link, a:visited {
                color: inherit;
                text-decoration: none;
            }
            .noprint {
                display: none;
            }
        }
	@media screen {
	    .grey, .grey a:link, .grey a:visited {
		color: #777;
	    }
            .docinfo {
                background-color: #EEE;
            }
            .top {
                border-top: 7px solid #EEE;
            }
            .bgwhite  { background-color: white; }
            .bgred    { background-color: #F44; }
            .bggrey   { background-color: #666; }
            .bgbrown  { background-color: #840; }            
            .bgorange { background-color: #FA0; }
            .bgyellow { background-color: #EE0; }
            .bgmagenta{ background-color: #F4F; }
            .bgblue   { background-color: #66F; }
            .bgcyan   { background-color: #4DD; }
            .bggreen  { background-color: #4F4; }

            .legend   { font-size: 90%; }
            .cplate   { font-size: 70%; border: solid grey 1px; }
	}
    </style>
    <!--[if IE]>
    <style>
    body {
       font-size: 13px;
       margin: 10px 10px;
    }
    </style>
    <![endif]-->

    <script type="text/javascript"><!--
    function addHeaderTags() {
	var spans = document.getElementsByTagName("span");
	for (var i=0; i < spans.length; i++) {
	    var elem = spans[i];
	    if (elem) {
		var level = elem.getAttribute("class");
                if (level == "h1" || level == "h2" || level == "h3" || level == "h4" || level == "h5" || level == "h6") {
                    elem.innerHTML = "<"+level+">"+elem.innerHTML+"</"+level+">";		
                }
	    }
	}
    }
    var legend_html = "Colour legend:<br />      <table>         <tr><td>Unknown:</td>                   <td><span class='cplate bgwhite'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft:</td>                     <td><span class='cplate bgred'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Informational:</td>             <td><span class='cplate bgorange'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Experimental:</td>              <td><span class='cplate bgyellow'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Best Common Practice:</td>      <td><span class='cplate bgmagenta'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Proposed Standard:</td>         <td><span class='cplate bgblue'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft Standard (old designation):</td> <td><span class='cplate bgcyan'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Internet Standard:</td>         <td><span class='cplate bggreen'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Historic:</td>                  <td><span class='cplate bggrey'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Obsolete:</td>                  <td><span class='cplate bgbrown'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>     </table>";
    function showElem(id) {
        var elem = document.getElementById(id);
        elem.innerHTML = eval(id+"_html");
        elem.style.visibility='visible';
    }
    function hideElem(id) {
        var elem = document.getElementById(id);
        elem.style.visibility='hidden';        
        elem.innerHTML = "";
    }
    // -->
    </script>
</head>
<body onload="addHeaderTags()">
  <div class="content">
   <div style="height: 13px;">
      <div class="pre noprint docinfo bgblue" onclick="showElem('legend');" onmouseout="hideElem('legend')" onmouseover="this.style.cursor='pointer';" style="height: 6px; position: absolute;" title="Click for colour legend.">                                                                        </div>
      <div class="docinfo noprint pre legend" id="legend" onmouseout="hideElem('legend');" onmouseover="showElem('legend');" style="position:absolute; top: 4px; left: 4ex; visibility:hidden; background-color: white; padding: 4px 9px 5px 7px; border: solid #345 1px; ">
      </div>
   </div>
<span class="pre noprint docinfo top">[<a href="index.html" title="Document search and retrieval page">Docs</a>] [<a href="https://tools.ietf.org/rfc/rfc5510.txt" title="Plaintext version of this document">txt</a>|<a href="https://tools.ietf.org/pdf/rfc5510" title="PDF version of this document">pdf</a>] [<a href="https://tools.ietf.org/html/draft-ietf-rmt-bb-fec-rs" title="draft-ietf-rmt-bb-fec-rs">draft-ietf-rmt-...</a>] [<a href="https://datatracker.ietf.org/doc/rfc5510" title="IESG Datatracker information for this document">Tracker</a>] [<a href="https://tools.ietf.org/rfcdiff?difftype=--hwdiff&amp;url2=rfc5510" title="Inline diff (wdiff)">Diff1</a>] [<a href="https://tools.ietf.org/rfcdiff?url2=rfc5510" title="Side-by-side diff">Diff2</a>]         </span><br/>
<span class="pre noprint docinfo">                                                                        </span><br/>
<span class="pre noprint docinfo">                                                       PROPOSED STANDARD</span><br/>
<span class="pre noprint docinfo">                                                                        </span><br/>
<pre>Network Working Group                                           J. Lacan
Request for Comments: 5510                                ISAE/LAAS-CNRS
Category: Standards Track                                        V. Roca
                                                                   INRIA
                                                            J. Peltotalo
                                                            S. Peltotalo
                                        Tampere University of Technology
                                                              April 2009


          <span class="h1">Reed-Solomon Forward Error Correction (FEC) Schemes</span>

Status of This Memo

   This document specifies an Internet standards track protocol for the
   Internet community, and requests discussion and suggestions for
   improvements.  Please refer to the current edition of the "Internet
   Official Protocol Standards" (STD 1) for the standardization state
   and status of this protocol.  Distribution of this memo is unlimited.

Copyright Notice

   Copyright (c) 2009 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to <a href="https://tools.ietf.org/html/bcp78">BCP 78</a> and the IETF Trust's Legal
   Provisions Relating to IETF Documents in effect on the date of
   publication of this document (<a href="http://trustee.ietf.org/license-info">http://trustee.ietf.org/license-info</a>).
   Please review these documents carefully, as they describe your rights
   and restrictions with respect to this document.

   This document may contain material from IETF Documents or IETF
   Contributions published or made publicly available before November
   10, 2008.  The person(s) controlling the copyright in some of this
   material may not have granted the IETF Trust the right to allow
   modifications of such material outside the IETF Standards Process.
   Without obtaining an adequate license from the person(s) controlling
   the copyright in such materials, this document may not be modified
   outside the IETF Standards Process, and derivative works of it may
   not be created outside the IETF Standards Process, except to format
   it for publication as an RFC or to translate it into languages other
   than English.









<span class="grey">Lacan, et al.               Standards Track                     [Page 1]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-2" id="page-2" name="page-2"> </a>
<span class="grey"><a href="rfc5510.html">RFC 5510</a>         Reed-Solomon Forward Error Correction        April 2009</span>


Abstract

   This document describes a Fully-Specified Forward Error Correction
   (FEC) Scheme for the Reed-Solomon FEC codes over GF(2^^m), where m is
   in {2..16}, and its application to the reliable delivery of data
   objects on the packet erasure channel (i.e., a communication path
   where packets are either received without any corruption or discarded
   during transmission).  This document also describes a Fully-Specified
   FEC Scheme for the special case of Reed-Solomon codes over GF(2^^8)
   when there is no encoding symbol group.  Finally, in the context of
   the Under-Specified Small Block Systematic FEC Scheme (FEC Encoding
   ID 129), this document assigns an FEC Instance ID to the special case
   of Reed-Solomon codes over GF(2^^8).

   Reed-Solomon codes belong to the class of Maximum Distance Separable
   (MDS) codes, i.e., they enable a receiver to recover the k source
   symbols from any set of k received symbols.  The schemes described
   here are compatible with the implementation from Luigi Rizzo.

































<span class="grey">Lacan, et al.               Standards Track                     [Page 2]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-3" id="page-3" name="page-3"> </a>
<span class="grey"><a href="rfc5510.html">RFC 5510</a>         Reed-Solomon Forward Error Correction        April 2009</span>


Table of Contents

   <a href="#section-1">1</a>. Introduction ....................................................<a href="#page-4">4</a>
   <a href="#section-2">2</a>. Terminology .....................................................<a href="#page-5">5</a>
   <a href="#section-3">3</a>. Definitions Notations and Abbreviations .........................<a href="#page-5">5</a>
      <a href="#section-3.1">3.1</a>. Definitions ................................................<a href="#page-5">5</a>
      <a href="#section-3.2">3.2</a>. Notations ..................................................<a href="#page-6">6</a>
      <a href="#section-3.3">3.3</a>. Abbreviations ..............................................<a href="#page-7">7</a>
   <a href="#section-4">4</a>. Formats and Codes with FEC Encoding ID 2 ........................<a href="#page-7">7</a>
      <a href="#section-4.1">4.1</a>. FEC Payload ID .............................................<a href="#page-7">7</a>
      <a href="#section-4.2">4.2</a>. FEC Object Transmission Information ........................<a href="#page-8">8</a>
           <a href="#section-4.2.1">4.2.1</a>. Mandatory Elements ..................................<a href="#page-8">8</a>
           <a href="#section-4.2.2">4.2.2</a>. Common Elements .....................................<a href="#page-8">8</a>
           <a href="#section-4.2.3">4.2.3</a>. Scheme-Specific Elements ............................<a href="#page-9">9</a>
           <a href="#section-4.2.4">4.2.4</a>. Encoding Format .....................................<a href="#page-9">9</a>
   <a href="#section-5">5</a>. Formats and Codes with FEC Encoding ID 5 .......................<a href="#page-11">11</a>
      <a href="#section-5.1">5.1</a>. FEC Payload ID ............................................<a href="#page-11">11</a>
      <a href="#section-5.2">5.2</a>. FEC Object Transmission Information .......................<a href="#page-12">12</a>
           <a href="#section-5.2.1">5.2.1</a>. Mandatory Elements .................................<a href="#page-12">12</a>
           <a href="#section-5.2.2">5.2.2</a>. Common Elements ....................................<a href="#page-12">12</a>
           <a href="#section-5.2.3">5.2.3</a>. Scheme-Specific Elements ...........................<a href="#page-12">12</a>
           <a href="#section-5.2.4">5.2.4</a>. Encoding Format ....................................<a href="#page-12">12</a>
   <a href="#section-6">6</a>. Procedures with FEC Encoding IDs 2 and 5 .......................<a href="#page-13">13</a>
      <a href="#section-6.1">6.1</a>. Determining the Maximum Source Block Length (B) ...........<a href="#page-13">13</a>
      <a href="#section-6.2">6.2</a>. Determining the Number of Encoding Symbols of a Block .....<a href="#page-14">14</a>
   7. Small Block Systematic FEC Scheme (FEC Encoding ID 129)
      and Reed-Solomon Codes over GF(2^^8) ...........................<a href="#page-15">15</a>
   <a href="#section-8">8</a>. Reed-Solomon Codes Specification for the Erasure Channel .......<a href="#page-16">16</a>
      <a href="#section-8.1">8.1</a>. Finite Field ..............................................<a href="#page-16">16</a>
      <a href="#section-8.2">8.2</a>. Reed-Solomon Encoding Algorithm ...........................<a href="#page-17">17</a>
           <a href="#section-8.2.1">8.2.1</a>. Encoding Principles ................................<a href="#page-17">17</a>
           <a href="#section-8.2.2">8.2.2</a>. Encoding Complexity ................................<a href="#page-18">18</a>
      <a href="#section-8.3">8.3</a>. Reed-Solomon Decoding Algorithm ...........................<a href="#page-18">18</a>
           <a href="#section-8.3.1">8.3.1</a>. Decoding Principles ................................<a href="#page-18">18</a>
           <a href="#section-8.3.2">8.3.2</a>. Decoding Complexity ................................<a href="#page-19">19</a>
      <a href="#section-8.4">8.4</a>. Implementation for the Packet Erasure Channel .............<a href="#page-19">19</a>
   <a href="#section-9">9</a>. Security Considerations ........................................<a href="#page-22">22</a>
      <a href="#section-9.1">9.1</a>. Problem Statement .........................................<a href="#page-22">22</a>
      <a href="#section-9.2">9.2</a>. Attacks against the Data Flow .............................<a href="#page-23">23</a>
           <a href="#section-9.2.1">9.2.1</a>. Access to Confidential Objects .....................<a href="#page-23">23</a>
           <a href="#section-9.2.2">9.2.2</a>. Content Corruption .................................<a href="#page-23">23</a>
      <a href="#section-9.3">9.3</a>. Attacks against the FEC Parameters ........................<a href="#page-24">24</a>
   <a href="#section-10">10</a>. IANA Considerations ...........................................<a href="#page-25">25</a>
   <a href="#section-11">11</a>. Acknowledgments ...............................................<a href="#page-25">25</a>
   <a href="#section-12">12</a>. References ....................................................<a href="#page-26">26</a>
      <a href="#section-12.1">12.1</a>. Normative References .....................................<a href="#page-26">26</a>
      <a href="#section-12.2">12.2</a>. Informative References ...................................<a href="#page-26">26</a>




<span class="grey">Lacan, et al.               Standards Track                     [Page 3]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-4" id="page-4" name="page-4"> </a>
<span class="grey"><a href="rfc5510.html">RFC 5510</a>         Reed-Solomon Forward Error Correction        April 2009</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/1.%20%20Introduction"></a><a class="selflink" href="#section-1" name="section-1">1</a>.  Introduction</span>

   The use of Forward Error Correction (FEC) codes is a classical
   solution to improve the reliability of multicast and broadcast
   transmissions.  The [<a href="rfc5052.html" title='"Forward Error Correction (FEC) Building Block"'>RFC5052</a>] document describes a general framework
   to use FEC in Content Delivery Protocols (CDPs).  The companion
   document [<a href="rfc3453.html" title='"The Use of Forward Error Correction (FEC) in Reliable Multicast"'>RFC3453</a>] describes some applications of FEC codes for
   content delivery.

   Recent FEC schemes like [<a href="rfc5053.html" title='"Raptor Forward Error Correction Scheme"'>RFC5053</a>] and [<a href="rfc5170.html" title='"Low Density Parity Check (LDPC) Forward Error Correction"'>RFC5170</a>] proposed erasure
   codes based on sparse graphs/matrices.  These codes are efficient in
   terms of processing but not optimal in terms of correction
   capabilities when dealing with "small" objects.

   The FEC schemes described in this document belongs to the class of
   Maximum Distance Separable codes that are optimal in terms of erasure
   correction capability.  In others words, it enables a receiver to
   recover the k source symbols from any set of exactly k encoding
   symbols.  They are also systematic codes, which means that the k
   source symbols are part of the encoding symbols.  Even if the
   encoding/decoding complexity is larger than that of [<a href="rfc5053.html" title='"Raptor Forward Error Correction Scheme"'>RFC5053</a>] or
   [<a href="rfc5170.html" title='"Low Density Parity Check (LDPC) Forward Error Correction"'>RFC5170</a>], this family of codes is very useful.

   Many applications dealing with content transmission or content
   storage already rely on packet-based Reed-Solomon codes.  In
   particular, many of them use the Reed-Solomon codec of Luigi Rizzo
   [<a href="#ref-RS-codec" title='"Reed-Solomon FEC codec"'>RS-codec</a>] [<a href="#ref-Rizzo97" title='"Effective Erasure Codes for Reliable Computer Communication Protocols"'>Rizzo97</a>].  The goal of the present document is to specify
   an implementation of Reed-Solomon codes that is compatible with this
   codec.

   The present document:

   o  introduces the Fully-Specified FEC Scheme with FEC Encoding ID 2,
      which specifies the use of Reed-Solomon codes over GF(2^^m), where
      m is in {2..16},

   o  introduces the Fully-Specified FEC Scheme with FEC Encoding ID 5,
      which focuses on the special case of Reed-Solomon codes over
      GF(2^^8) and no encoding symbol group (i.e., exactly one symbol
      per packet), and

   o  in the context of the Under-Specified Small Block Systematic FEC
      Scheme (FEC Encoding ID 129) [<a href="rfc5445.html" title='"Basic Forward Error Correction (FEC) Schemes"'>RFC5445</a>], assigns the FEC Instance
      ID 0 to the special case of Reed-Solomon codes over GF(2^^8) and
      no encoding symbol group.

   For a definition of the terms Fully-Specified and Under-Specified FEC
   Schemes, see <a href="rfc5052.html#section-4">[RFC5052], Section 4</a>.



<span class="grey">Lacan, et al.               Standards Track                     [Page 4]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-5" id="page-5" name="page-5"> </a>
<span class="grey"><a href="rfc5510.html">RFC 5510</a>         Reed-Solomon Forward Error Correction        April 2009</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/2.%20%20Terminology"></a><a class="selflink" href="#section-2" name="section-2">2</a>.  Terminology</span>

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in <a href="rfc2119.html">RFC 2119</a> [<a href="rfc2119.html" title='"Key words for use in RFCs to Indicate Requirement Levels"'>RFC2119</a>].

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/3.%20%20Definitions%20Notations%20and%20Abbreviations"></a><a class="selflink" href="#section-3" name="section-3">3</a>.  Definitions Notations and Abbreviations</span>

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.1.%20%20Definitions"></a><a class="selflink" href="#section-3.1" name="section-3.1">3.1</a>.  Definitions</span>

   This document uses the same terms and definitions as those specified
   in [<a href="rfc5052.html" title='"Forward Error Correction (FEC) Building Block"'>RFC5052</a>].  Additionally, it uses the following definitions:

      Source symbol:  unit of data used during the encoding process.

      Encoding symbol:  unit of data generated by the encoding process.

      Repair symbol:  encoding symbol that is not a source symbol.

      Code rate:  the k/n ratio, i.e., the ratio between the number of
         source symbols and the number of encoding symbols.  By
         definition, the code rate is such that: 0 &lt; code rate &lt;= 1.  A
         code rate close to 1 indicates that a small number of repair
         symbols have been produced during the encoding process.

      Systematic code:  FEC code in which the source symbols are part of
         the encoding symbols.

      Source block:  a block of k source symbols that are considered
         together for the encoding.

      Encoding Symbol Group:  a group of encoding symbols that are sent
         together within the same packet, and whose relationships to the
         source block can be derived from a single Encoding Symbol ID.

      Source Packet:  a data packet containing only source symbols.

      Repair Packet:  a data packet containing only repair symbols.

      Packet Erasure Channel:  a communication path where packets are
         either dropped (e.g., by a congested router, or because the
         number of transmission errors exceeds the correction
         capabilities of the physical layer codes) or received.  When a
         packet is received, it is assumed that this packet is not
         corrupted.






<span class="grey">Lacan, et al.               Standards Track                     [Page 5]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-6" id="page-6" name="page-6"> </a>
<span class="grey"><a href="rfc5510.html">RFC 5510</a>         Reed-Solomon Forward Error Correction        April 2009</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.2.%20%20Notations"></a><a class="selflink" href="#section-3.2" name="section-3.2">3.2</a>.  Notations</span>

   This document uses the following notations:

      L      the object transfer length in bytes.

      k      the number of source symbols in a source block.

      n_r    the number of repair symbols generated for a source block.

      n      the encoding block length, i.e., the number of encoding
             symbols generated for a source block.  Therefore: n = k +
             n_r.

      max_n  the maximum number of encoding symbols generated for any
             source block.

      B      the maximum source block length in symbols, i.e., the
             maximum number of source symbols per source block.

      N      the number of source blocks into which the object shall be
             partitioned.

      E      the encoding symbol length in bytes.

      S      the symbol size in units of m-bit elements.  When m = 8,
             then S and E are equal.

      m      the length of the elements in the finite field, in bits.
             In this document, m belongs to {2..16}.

      q      the number of elements in the finite field.  We have: q =
             2^^m in this specification.

      G      the number of encoding symbols per group, i.e., the number
             of symbols sent in the same packet.

      GM     the Generator Matrix of a Reed-Solomon code.

      CR     the "code rate", i.e., the k/n ratio.

      a^^b   a raised to the power b.

      a^^-1  the inverse of a.

      I_k    the k*k identity matrix.





<span class="grey">Lacan, et al.               Standards Track                     [Page 6]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-7" id="page-7" name="page-7"> </a>
<span class="grey"><a href="rfc5510.html">RFC 5510</a>         Reed-Solomon Forward Error Correction        April 2009</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.3.%20%20Abbreviations"></a><a class="selflink" href="#section-3.3" name="section-3.3">3.3</a>.  Abbreviations</span>

   This document uses the following abbreviations:

      ESI      Encoding Symbol ID.

      FEC OTI  FEC Object Transmission Information.

      RS       Reed-Solomon.

      MDS      Maximum Distance Separable code.

      GF(q)    a finite field (also known as Galois Field) with q
               elements.  We assume that q = 2^^m in this document.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/4.%20%20Formats%20and%20Codes%20with%20FEC%20Encoding%20ID%202"></a><a class="selflink" href="#section-4" name="section-4">4</a>.  Formats and Codes with FEC Encoding ID 2</span>

   This section introduces the formats and codes associated with the
   Fully-Specified FEC Scheme with FEC Encoding ID 2, which specifies
   the use of Reed-Solomon codes over GF(2^^m).

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.1.%20%20FEC%20Payload%20ID"></a><a class="selflink" href="#section-4.1" name="section-4.1">4.1</a>.  FEC Payload ID</span>

   The FEC Payload ID is composed of the Source Block Number and the
   Encoding Symbol ID.  The lengths of these two fields depend on the
   parameter m (which is transmitted in the FEC OTI) as follows:

   o  The Source Block Number (field of size 32-m bits) identifies from
      which source block of the object the encoding symbol(s) in the
      payload are generated.  There is a maximum of 2^^(32-m) blocks per
      object.

   o  The Encoding Symbol ID (field of size m bits) identifies which
      specific encoding symbol(s) generated from the source block are
      carried in the packet payload.  There is a maximum of 2^^m
      encoding symbols per block.  The first k values (0 to k - 1)
      identify source symbols, the remaining n-k values identify repair
      symbols.

   There MUST be exactly one FEC Payload ID per source or repair packet.
   In case of an Encoding Symbol Group, when multiple encoding symbols
   are sent in the same packet, the FEC Payload ID refers to the first
   symbol of the packet.  The other symbols can be deduced from the ESI
   of the first symbol by incrementing sequentially the ESI.







<span class="grey">Lacan, et al.               Standards Track                     [Page 7]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-8" id="page-8" name="page-8"> </a>
<span class="grey"><a href="rfc5510.html">RFC 5510</a>         Reed-Solomon Forward Error Correction        April 2009</span>


    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |     Source Block Number (32-8=24 bits)        | Enc. Symb. ID |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

       Figure 1: FEC Payload ID Encoding Format for m = 8 (Default)


    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   | Src Block Nb (32-16=16 bits)  |  Enc. Symbol ID (m=16 bits)   |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

            Figure 2: FEC Payload ID Encoding Format for m = 16

   The formats of the FEC Payload ID for m = 8 and m = 16 are
   illustrated in Figure 1 and Figure 2, respectively.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.2.%20%20FEC%20Object%20Transmission%20Information"></a><a class="selflink" href="#section-4.2" name="section-4.2">4.2</a>.  FEC Object Transmission Information</span>

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/4.2.1.%20%20Mandatory%20Elements"></a><a class="selflink" href="#section-4.2.1" name="section-4.2.1">4.2.1</a>.  Mandatory Elements</span>

   o  FEC Encoding ID: the Fully-Specified FEC Scheme described in this
      section uses FEC Encoding ID 2.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/4.2.2.%20%20Common%20Elements"></a><a class="selflink" href="#section-4.2.2" name="section-4.2.2">4.2.2</a>.  Common Elements</span>

   The following elements MUST be defined with the present FEC scheme.

   o  Transfer-Length (L): a non-negative integer indicating the length
      of the object in bytes.  There are some restrictions on the
      maximum Transfer-Length that can be supported:

         max_transfer_length = 2^^(32-m) * B * E

      For instance, for m = 8, for B = 2^^8 - 1 (because the codec
      operates on a finite field with 2^^8 elements), and if E = 1024
      bytes, then the maximum transfer length is approximately equal to
      2^^42 bytes (i.e., 4 terabytes).  Similarly, for m = 16, for B =
      2^^16 - 1, and if E = 1024 bytes, then the maximum transfer length
      is also approximately equal to 2^^42 bytes.  For larger objects,
      another FEC scheme, with a larger Source Block Number field in the
      FEC Payload ID, could be defined.  Another solution consists in
      fragmenting large objects into smaller objects, each of them
      complying with the above limits.




<span class="grey">Lacan, et al.               Standards Track                     [Page 8]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-9" id="page-9" name="page-9"> </a>
<span class="grey"><a href="rfc5510.html">RFC 5510</a>         Reed-Solomon Forward Error Correction        April 2009</span>


   o  Encoding-Symbol-Length (E): a non-negative integer indicating the
      length of each encoding symbol in bytes.

   o  Maximum-Source-Block-Length (B): a non-negative integer indicating
      the maximum number of source symbols in a source block.

   o  Max-Number-of-Encoding-Symbols (max_n): a non-negative integer
      indicating the maximum number of encoding symbols generated for
      any source block.

   <a href="#section-6">Section 6</a> explains how to derive the values of each of these
   elements.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/4.2.3.%20%20Scheme-Specific%20Elements"></a><a class="selflink" href="#section-4.2.3" name="section-4.2.3">4.2.3</a>.  Scheme-Specific Elements</span>

   The following element MUST be defined with the present FEC scheme.
   It contains two distinct pieces of information:

   o  G: a non-negative integer indicating the number of encoding
      symbols per group used for the object.  The default value is 1,
      meaning that each packet contains exactly one symbol.  When no G
      parameter is communicated to the decoder, then the latter MUST
      assume that G = 1.

   o  m: The m parameter is the length of the finite field elements, in
      bits.  It also characterizes the number of elements in the finite
      field: q = 2^^m elements.  The default value is m = 8.  When no
      finite field size parameter is communicated to the decoder, then
      the latter MUST assume that m = 8.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/4.2.4.%20%20Encoding%20Format"></a><a class="selflink" href="#section-4.2.4" name="section-4.2.4">4.2.4</a>.  Encoding Format</span>

   This section shows the two possible encoding formats of the above FEC
   OTI.  The present document does not specify when one encoding format
   or the other should be used.

<span class="h5"><a class="dashAnchor" name="//apple_ref/Section/4.2.4.1.%20%20Using%20the%20General%20EXT_FTI%20Format"></a><a class="selflink" href="#section-4.2.4.1" name="section-4.2.4.1">4.2.4.1</a>.  Using the General EXT_FTI Format</span>

   The FEC OTI binary format is the following, when the EXT_FTI
   mechanism is used (e.g., within the ALC [<a href="#ref-ALC" title='"Asynchronous Layered Coding (ALC) Protocol Instantiation"'>ALC</a>] or NORM [<a href="#ref-NORM" title='"NACK-Oriented Reliable Multicast Protocol"'>NORM</a>]
   protocols).










<span class="grey">Lacan, et al.               Standards Track                     [Page 9]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-10" id="page-10" name="page-10"> </a>
<span class="grey"><a href="rfc5510.html">RFC 5510</a>         Reed-Solomon Forward Error Correction        April 2009</span>


    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |   HET = 64    |    HEL = 4    |                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                               +
   |                      Transfer Length (L)                      |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |       m       |       G       |   Encoding Symbol Length (E)  |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  Max Source Block Length (B)  |  Max Nb Enc. Symbols (max_n)  |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                      Figure 3: EXT_FTI Header Format

<span class="h5"><a class="dashAnchor" name="//apple_ref/Section/4.2.4.2.%20%20Using%20the%20FDT%20Instance%20%28FLUTE%20specific%29"></a><a class="selflink" href="#section-4.2.4.2" name="section-4.2.4.2">4.2.4.2</a>.  Using the FDT Instance (FLUTE specific)</span>

   When it is desired that the FEC OTI be carried in the FDT (File
   Delivery Table) Instance of a FLUTE session [<a href="#ref-FLUTE" title='"FLUTE - File Delivery over Unidirectional Transport"'>FLUTE</a>], the following
   XML attributes must be described for the associated object:

   o  FEC-OTI-FEC-Encoding-ID

   o  FEC-OTI-Transfer-Length (L)

   o  FEC-OTI-Encoding-Symbol-Length (E)

   o  FEC-OTI-Maximum-Source-Block-Length (B)

   o  FEC-OTI-Max-Number-of-Encoding-Symbols (max_n)

   o  FEC-OTI-Scheme-Specific-Info

   The FEC-OTI-Scheme-Specific-Info contains the string resulting from
   the Base64 encoding (in the XML Schema xs:base64Binary sense) of the
   following value:

    0                   1
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |       m       |       G       |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

    Figure 4: FEC OTI Scheme Specific Information To Be Included in the
                               FDT Instance

   When no m parameter is to be carried in the FEC OTI, the m field is
   set to 0 (which is not a valid seed value).  Otherwise, the m field
   contains a valid value as explained in <a href="#section-4.2.3">Section 4.2.3</a>.  Similarly,



<span class="grey">Lacan, et al.               Standards Track                    [Page 10]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-11" id="page-11" name="page-11"> </a>
<span class="grey"><a href="rfc5510.html">RFC 5510</a>         Reed-Solomon Forward Error Correction        April 2009</span>


   when no G parameter is to be carried in the FEC OTI, the G field is
   set to 0 (which is not a valid seed value).  Otherwise, the G field
   contains a valid value as explained in <a href="#section-4.2.3">Section 4.2.3</a>.  When neither m
   nor G are to be carried in the FEC OTI, then the sender simply omits
   the FEC-OTI-Scheme-Specific-Info attribute.

   During Base64 encoding, the 2 bytes of the FEC OTI Scheme-Specific
   Information are transformed into a string of 4 printable characters
   (in the 64-character alphabet) that is added to the FEC-OTI-Scheme-
   Specific-Info attribute.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/5.%20%20Formats%20and%20Codes%20with%20FEC%20Encoding%20ID%205"></a><a class="selflink" href="#section-5" name="section-5">5</a>.  Formats and Codes with FEC Encoding ID 5</span>

   This section introduces the formats and codes associated with the
   Fully-Specified FEC Scheme with FEC Encoding ID 5, which focuses on
   the special case of Reed-Solomon codes over GF(2^^8) and no encoding
   symbol group.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.1.%20%20FEC%20Payload%20ID"></a><a class="selflink" href="#section-5.1" name="section-5.1">5.1</a>.  FEC Payload ID</span>

   The FEC Payload ID is composed of the Source Block Number and the
   Encoding Symbol ID:

   o  The Source Block Number (24-bit field) identifies from which
      source block of the object the encoding symbol in the payload is
      generated.  There is a maximum of 2^^24 blocks per object.

   o  The Encoding Symbol ID (8-bit field) identifies which specific
      encoding symbol generated from the source block is carried in the
      packet payload.  There is a maximum of 2^^8 encoding symbols per
      block.  The first k values (0 to k - 1) identify source symbols;
      the remaining n-k values identify repair symbols.

   There MUST be exactly one FEC Payload ID per source or repair packet.
   This FEC Payload ID refers to the one and only symbol of the packet.

    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |        Source Block Number (24 bits)          | Enc. Symb. ID |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

      Figure 5: FEC Payload ID Encoding Format with FEC Encoding ID 5








<span class="grey">Lacan, et al.               Standards Track                    [Page 11]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-12" id="page-12" name="page-12"> </a>
<span class="grey"><a href="rfc5510.html">RFC 5510</a>         Reed-Solomon Forward Error Correction        April 2009</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.2.%20%20FEC%20Object%20Transmission%20Information"></a><a class="selflink" href="#section-5.2" name="section-5.2">5.2</a>.  FEC Object Transmission Information</span>

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/5.2.1.%20%20Mandatory%20Elements"></a><a class="selflink" href="#section-5.2.1" name="section-5.2.1">5.2.1</a>.  Mandatory Elements</span>

   o  FEC Encoding ID: the Fully-Specified FEC Scheme described in this
      section uses FEC Encoding ID 5.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/5.2.2.%20%20Common%20Elements"></a><a class="selflink" href="#section-5.2.2" name="section-5.2.2">5.2.2</a>.  Common Elements</span>

   The Common elements are the same as those specified in <a href="#section-4.2.2">Section 4.2.2</a>
   when m = 8 and G = 1.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/5.2.3.%20%20Scheme-Specific%20Elements"></a><a class="selflink" href="#section-5.2.3" name="section-5.2.3">5.2.3</a>.  Scheme-Specific Elements</span>

   No Scheme-Specific elements are defined by this FEC scheme.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/5.2.4.%20%20Encoding%20Format"></a><a class="selflink" href="#section-5.2.4" name="section-5.2.4">5.2.4</a>.  Encoding Format</span>

   This section shows the two possible encoding formats of the above FEC
   OTI.  The present document does not specify when one encoding format
   or the other should be used.

<span class="h5"><a class="dashAnchor" name="//apple_ref/Section/5.2.4.1.%20%20Using%20the%20General%20EXT_FTI%20Format"></a><a class="selflink" href="#section-5.2.4.1" name="section-5.2.4.1">5.2.4.1</a>.  Using the General EXT_FTI Format</span>

   The FEC OTI binary format is the following, when the EXT_FTI
   mechanism is used (e.g., within the ALC [<a href="#ref-ALC" title='"Asynchronous Layered Coding (ALC) Protocol Instantiation"'>ALC</a>] or NORM [<a href="#ref-NORM" title='"NACK-Oriented Reliable Multicast Protocol"'>NORM</a>]
   protocols).

    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |   HET = 64    |    HEL = 3    |                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                               +
   |                      Transfer Length (L)                      |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |   Encoding Symbol Length (E)  | MaxBlkLen (B) |     max_n     |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

          Figure 6: EXT_FTI Header Format with FEC Encoding ID 5

<span class="h5"><a class="dashAnchor" name="//apple_ref/Section/5.2.4.2.%20%20Using%20the%20FDT%20Instance%20%28FLUTE%20specific%29"></a><a class="selflink" href="#section-5.2.4.2" name="section-5.2.4.2">5.2.4.2</a>.  Using the FDT Instance (FLUTE specific)</span>

   When it is desired that the FEC OTI be carried in the FDT Instance of
   a FLUTE session [<a href="#ref-FLUTE" title='"FLUTE - File Delivery over Unidirectional Transport"'>FLUTE</a>], the following XML attributes must be
   described for the associated object:

   o  FEC-OTI-FEC-Encoding-ID




<span class="grey">Lacan, et al.               Standards Track                    [Page 12]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-13" id="page-13" name="page-13"> </a>
<span class="grey"><a href="rfc5510.html">RFC 5510</a>         Reed-Solomon Forward Error Correction        April 2009</span>


   o  FEC-OTI-Transfer-Length (L)

   o  FEC-OTI-Encoding-Symbol-Length (E)

   o  FEC-OTI-Maximum-Source-Block-Length (B)

   o  FEC-OTI-Max-Number-of-Encoding-Symbols (max_n)

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/6.%20%20Procedures%20with%20FEC%20Encoding%20IDs%202%20and%205"></a><a class="selflink" href="#section-6" name="section-6">6</a>.  Procedures with FEC Encoding IDs 2 and 5</span>

   This section defines procedures that are common to FEC Encoding IDs 2
   and 5.  In case of FEC Encoding ID 5, m = 8 and G = 1.  The block
   partitioning algorithm that is defined in <a href="rfc5052.html#section-9.1">Section 9.1 of [RFC5052]</a>
   MUST be used with FEC Encoding IDs 2 and 5.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/6.1.%20%20Determining%20the%20Maximum%20Source%20Block%20Length%20%28B%29"></a><a class="selflink" href="#section-6.1" name="section-6.1">6.1</a>.  Determining the Maximum Source Block Length (B)</span>

   The finite field size parameter, m, defines the number of non-zero
   elements in this field, which is equal to: q - 1 = 2^^m - 1.  Note
   that q - 1 is also the theoretical maximum number of encoding symbols
   that can be produced for a source block.  For instance, when m = 8
   (default) there is a maximum of 2^^8 - 1 = 255 encoding symbols.

   Given the target FEC code rate (e.g., provided by the user when
   starting a FLUTE sending application), the sender calculates:

      max1_B = floor((2^^m - 1) * CR)

   This max1_B value leaves enough room for the sender to produce the
   desired number of parity symbols.

   Additionally, a codec MAY impose other limitations on the maximum
   block size.  Yet it is not expected that such limits exist when using
   the default m = 8 value.  This decision MUST be clarified at
   implementation time, when the target use case is known.  This results
   in a max2_B limitation.

   Then, B is given by:

      B = min(max1_B, max2_B)

   Note that this calculation is only required at the coder, since the B
   parameter is communicated to the decoder through the FEC OTI.








<span class="grey">Lacan, et al.               Standards Track                    [Page 13]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-14" id="page-14" name="page-14"> </a>
<span class="grey"><a href="rfc5510.html">RFC 5510</a>         Reed-Solomon Forward Error Correction        April 2009</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/6.2.%20%20Determining%20the%20Number%20of%20Encoding%20Symbols%20of%20a%20Block"></a><a class="selflink" href="#section-6.2" name="section-6.2">6.2</a>.  Determining the Number of Encoding Symbols of a Block</span>

   The following algorithm, also called "n-algorithm", explains how to
   determine the maximum number of encoding symbols generated for any
   source block (max_n) and the number of encoding symbols for a given
   block (n) as a function of the target code rate.

   AT A SENDER:

   Input:

      B: Maximum source block length, for any source block.  <a href="#section-6.1">Section 6.1</a>
      explains how to determine its value.

      k: Current source block length.  This parameter is given by the
      block partitioning algorithm.

      CR: FEC code rate, which is given by the user (e.g., when starting
      a FLUTE sending application).  It is expressed as a floating point
      value.

   Output:

      max_n: Maximum number of encoding symbols generated for any source
      block.

      n: Number of encoding symbols generated for this source block.

   Algorithm:

      max_n = ceil(B / CR);

      if (max_n &gt; 2^^m - 1), then return an error ("invalid code rate");

      n = floor(k * max_n / B);

   AT A RECEIVER:

   Input:

      B: Extracted from the received FEC OTI.

      max_n: Extracted from the received FEC OTI.

      k: Given by the block partitioning algorithm.






<span class="grey">Lacan, et al.               Standards Track                    [Page 14]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-15" id="page-15" name="page-15"> </a>
<span class="grey"><a href="rfc5510.html">RFC 5510</a>         Reed-Solomon Forward Error Correction        April 2009</span>


   Output:

      n

   Algorithm:

      n = floor(k * max_n / B);

   It is RECOMMENDED that the "n-algorithm" be used by a sender, but
   other algorithms remain possible to determine max_n and/or n.

   At a receiver, the max_n value is extracted from the received FEC
   OTI.  Since the Reed-Solomon decoder does not need to know the actual
   n value, using the receiver part of the "n-algorithm" is not
   necessary from a decoding point of view.

   However, a receiver may want to have an estimate of n for other
   reasons (e.g., for memory management purposes).  In that case, a
   receiver knows that the number of encoding symbols of a block cannot
   exceed max_n.  Additionally, if a receiver believes that a sender
   uses the "n-algorithm", this receiver MAY use the receiver part of
   the "n-algorithm" to get a better estimate of n.  When this is the
   case, a receiver MUST be prepared to handle symbols with an Encoding
   Symbol ID superior or equal to the computed n value (e.g., it can
   choose to simply drop them).

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/7.%20%20Small%20Block%20Systematic%20FEC%20Scheme%20%28FEC%20Encoding%20ID%20129%29%20and%20Reed-"></a><a class="selflink" href="#section-7" name="section-7">7</a>.  Small Block Systematic FEC Scheme (FEC Encoding ID 129) and Reed-</span>
<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/Solomon%20Codes%20over%20GF%282%5E%5E8%29"></a>    Solomon Codes over GF(2^^8)</span>

   In the context of the Under-Specified Small Block Systematic FEC
   Scheme (FEC Encoding ID 129) [<a href="rfc5445.html" title='"Basic Forward Error Correction (FEC) Schemes"'>RFC5445</a>], this document assigns the FEC
   Instance ID 0 to the special case of Reed-Solomon codes over GF(2^^8)
   and no encoding symbol group.

   The FEC Instance ID 0 uses the Formats and Codes specified in
   [<a href="rfc5445.html" title='"Basic Forward Error Correction (FEC) Schemes"'>RFC5445</a>].

   The FEC scheme with FEC Instance ID 0 MAY use the block partitioning
   algorithm defined in <a href="rfc5052.html#section-9.1">Section 9.1 of [RFC5052]</a> to partition the object
   into source blocks.  This FEC scheme MAY also use another algorithm.
   For instance, the CDP sender may change the length of each source
   block dynamically, depending on some external criteria (e.g., to
   adjust the FEC coding rate to the current loss rate experienced by
   NORM receivers) and inform the CDP receivers of the current block
   length by means of the EXT_FTI mechanism.  This choice is out of the
   scope of the current document.





<span class="grey">Lacan, et al.               Standards Track                    [Page 15]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-16" id="page-16" name="page-16"> </a>
<span class="grey"><a href="rfc5510.html">RFC 5510</a>         Reed-Solomon Forward Error Correction        April 2009</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/8.%20%20Reed-Solomon%20Codes%20Specification%20for%20the%20Erasure%20Channel"></a><a class="selflink" href="#section-8" name="section-8">8</a>.  Reed-Solomon Codes Specification for the Erasure Channel</span>

   Reed-Solomon (RS) codes are linear block codes.  They also belong to
   the class of MDS codes.  A [n,k]-RS code encodes a sequence of k
   source elements defined over a finite field GF(q) into a sequence of
   n encoding elements, where n is upper bounded by q - 1.  The
   implementation described in this document is based on a generator
   matrix built from a Vandermonde matrix put into systematic form.

   Sections <a href="#section-8.1">8.1</a> to <a href="#section-8.3">8.3</a> specify the [n,k]-RS codes when applied to m-bit
   elements, and <a href="#section-8.4">Section 8.4</a> specifies the use of [n,k]-RS codes when
   applied to symbols composed of several m-bit elements.  The use
   described in <a href="#section-8.4">Section 8.4</a> is the crux of this specification.

   A reader who wants to understand the underlying theory is invited to
   refer to references [<a href="#ref-Rizzo97" title='"Effective Erasure Codes for Reliable Computer Communication Protocols"'>Rizzo97</a>] and [<a href="#ref-MWS77" title='"The Theory of Error Correcting Codes"'>MWS77</a>].

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/8.1.%20%20Finite%20Field"></a><a class="selflink" href="#section-8.1" name="section-8.1">8.1</a>.  Finite Field</span>

   A finite field GF(q) is defined as a finite set of q elements that
   has a structure of field.  It contains necessarily q = p^^m elements,
   where p is a prime number.  With packet erasure channels, p is always
   set to 2.  The elements of the field GF(2^^m) can be represented by
   polynomials with binary coefficients (i.e., over GF(2)) of degree
   lower or equal to m-1.  The polynomials can be associated with binary
   vectors of length m.  For example, the vector (11001) represents the
   polynomial 1 + x + x^^4.  This representation is often called
   polynomial representation.  The addition between two elements is
   defined as the addition of binary polynomials in GF(2) and the
   multiplication is the multiplication modulo a given irreducible
   polynomial over GF(2) of degree m.  Note that all the roots of this
   polynomial are in GF(2^^m) but not in GF(2).

   The chosen polynomial representation of the finite field GF(2^^m) is
   completely characterized by the irreducible polynomial.  The
   following polynomials are chosen to represent the field GF(2^^m), for
   m varying from 2 to 16:

      m = 2, "111" (1+x+x^^2)

      m = 3, "1101", (1+x+x^^3)

      m = 4, "11001", (1+x+x^^4)

      m = 5, "101001", (1+x^^2+x^^5)

      m = 6, "1100001", (1+x+x^^6)




<span class="grey">Lacan, et al.               Standards Track                    [Page 16]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-17" id="page-17" name="page-17"> </a>
<span class="grey"><a href="rfc5510.html">RFC 5510</a>         Reed-Solomon Forward Error Correction        April 2009</span>


      m = 7, "10010001", (1+x^^3+x^^7)

      m = 8, "101110001", (1+x^^2+x^^3+x^^4+x^^8)

      m = 9, "1000100001", (1+x^^4+x^^9)

      m = 10, "10010000001", (1+x^^3+x^^10)

      m = 11, "101000000001", (1+x^^2+x^^11)

      m = 12, "1100101000001", (1+x+x^^4+x^^6+x^^12)

      m = 13, "11011000000001", (1+x+x^^3+x^^4+x^^13)

      m = 14, "110000100010001", (1+x+x^^6+x^^10+x^^14)

      m = 15, "1100000000000001", (1+x+x^^15)

      m = 16, "11010000000010001", (1+x+x^^3+x^^12+x^^16)

   In order to facilitate the implementation, these polynomials are also
   primitive.  This means that any element of GF(2^^m) can be expressed
   as a power of a given root of this polynomial.  These polynomials are
   also chosen so that they contain the minimum number of monomials.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/8.2.%20%20Reed-Solomon%20Encoding%20Algorithm"></a><a class="selflink" href="#section-8.2" name="section-8.2">8.2</a>.  Reed-Solomon Encoding Algorithm</span>

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/8.2.1.%20%20Encoding%20Principles"></a><a class="selflink" href="#section-8.2.1" name="section-8.2.1">8.2.1</a>.  Encoding Principles</span>

   Let s = (s_0, ..., s_{k-1}) be a source vector of k elements over
   GF(2^^m).  Let e = (e_0, ..., e_{n-1}) be the corresponding encoding
   vector of n elements over GF(2^^m).  Being a linear code, encoding is
   performed by multiplying the source vector by a generator matrix, GM,
   of k rows and n columns over GF(2^^m).  Thus:

      e = s * GM.

   The definition of the generator matrix completely characterizes the
   RS code.

   Let us consider that n = 2^^m - 1 and that 0 &lt; k &lt;= n.  Let us denote
   by alpha the root of the primitive polynomial of degree m chosen in
   the list of <a href="#section-8.1">Section 8.1</a> for the corresponding value of m.  Let us
   consider a Vandermonde matrix of k rows and n columns, denoted by
   V_{k,n}, and built as follows: the {i, j} entry of V_{k,n} is v_{i,j}
   = alpha^^(i*j), where 0 &lt;= i &lt;= k - 1 and 0 &lt;= j &lt;= n - 1.  This
   matrix generates a MDS code.  However, this MDS code is not
   systematic, which is a problem for many networking applications.  To



<span class="grey">Lacan, et al.               Standards Track                    [Page 17]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-18" id="page-18" name="page-18"> </a>
<span class="grey"><a href="rfc5510.html">RFC 5510</a>         Reed-Solomon Forward Error Correction        April 2009</span>


   obtain a systematic matrix (and code), the simplest solution consists
   in considering the matrix V_{k,k} formed by the first k columns of
   V_{k,n}, then to invert it and to multiply this inverse by V_{k,n}.
   Clearly, the product V_{k,k}^^-1 * V_{k,n} contains the identity
   matrix I_k on its first k columns, meaning that the first k encoding
   elements are equal to source elements.  Besides, the associated code
   keeps the MDS property.

   Therefore, the generator matrix of the code considered in this
   document is:

      GM = (V_{k,k}^^-1) * V_{k,n}

   Note that, in practice, the [n,k]-RS code can be shortened to a
   [n',k]-RS code, where k &lt;= n' &lt; n, by considering the sub-matrix
   formed by the n' first columns of GM.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/8.2.2.%20%20Encoding%20Complexity"></a><a class="selflink" href="#section-8.2.2" name="section-8.2.2">8.2.2</a>.  Encoding Complexity</span>

   Encoding can be performed by first pre-computing GM and by
   multiplying the source vector (k elements) by GM (k rows and n
   columns).  The complexity of the pre-computation of the generator
   matrix can be estimated as the complexity of the multiplication of
   the inverse of a Vandermonde matrix by n-k vectors (i.e., the last
   n-k columns of V_{k,n}).  Since the complexity of the inverse of a
   k*k-Vandermonde matrix by a vector is O(k * (log(k))^^2), the
   generator matrix can be computed in 0((n-k)* k * (log(k))^^2))
   operations.  When the generator matrix is pre-computed, the encoding
   needs k operations per repair element (vector-matrix multiplication).

   Encoding can also be performed by first computing the product s *
   V_{k,k}^^-1 and then by multiplying the result with V_{k,n}.  The
   multiplication by the inverse of a square Vandermonde matrix is known
   as the interpolation problem and its complexity is O(k *
   (log(k))^^2).  The multiplication by a Vandermonde matrix, known as
   the multipoint evaluation problem, requires O((n-k) * log(k)) by
   using Fast Fourier Transform, as explained in [<a href="#ref-GO94" title='"Fast algorithms with preprocessing for matrix-vector multiplication problems"'>GO94</a>].  The total
   complexity of this encoding algorithm is then O((k/(n-k)) *
   (log(k))^^2 + log(k)) operations per repair element.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/8.3.%20%20Reed-Solomon%20Decoding%20Algorithm"></a><a class="selflink" href="#section-8.3" name="section-8.3">8.3</a>.  Reed-Solomon Decoding Algorithm</span>

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/8.3.1.%20%20Decoding%20Principles"></a><a class="selflink" href="#section-8.3.1" name="section-8.3.1">8.3.1</a>.  Decoding Principles</span>

   The Reed-Solomon decoding algorithm for the erasure channel allows
   the recovery of the k source elements from any set of k received
   elements.  It is based on the fundamental property of the generator
   matrix, which is such that any k*k-submatrix is invertible (see



<span class="grey">Lacan, et al.               Standards Track                    [Page 18]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-19" id="page-19" name="page-19"> </a>
<span class="grey"><a href="rfc5510.html">RFC 5510</a>         Reed-Solomon Forward Error Correction        April 2009</span>


   [<a href="#ref-MWS77" title='"The Theory of Error Correcting Codes"'>MWS77</a>]).  The first step of the decoding consists in extracting the
   k*k submatrix of the generator matrix obtained by considering the
   columns corresponding to the received elements.  Indeed, since any
   encoding element is obtained by multiplying the source vector by one
   column of the generator matrix, the received vector of k encoding
   elements can be considered as the result of the multiplication of the
   source vector by a k*k submatrix of the generator matrix.  Since this
   submatrix is invertible, the second step of the algorithm is to
   invert this matrix and to multiply the received vector by the
   obtained matrix to recover the source vector.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/8.3.2.%20%20Decoding%20Complexity"></a><a class="selflink" href="#section-8.3.2" name="section-8.3.2">8.3.2</a>.  Decoding Complexity</span>

   The decoding algorithm described previously includes the matrix
   inversion and the vector-matrix multiplication.  With the classical
   Gauss-Jordan algorithm, the matrix inversion requires O(k^^3)
   operations and the vector-matrix multiplication is performed in
   O(k^^2) operations.

   This complexity can be improved by considering that the received
   submatrix of GM is the product between the inverse of a Vandermonde
   matrix (V_(k,k)^^-1) and another Vandermonde matrix (denoted by V',
   which is a submatrix of V_(k,n)).  The decoding can be done by
   multiplying the received vector by V'^^-1 (interpolation problem with
   complexity O( k * (log(k))^^2) ) then by V_{k,k} (multipoint
   evaluation with complexity O(k * log(k))).  The global decoding
   complexity is then O((log(k))^^2) operations per source element.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/8.4.%20%20Implementation%20for%20the%20Packet%20Erasure%20Channel"></a><a class="selflink" href="#section-8.4" name="section-8.4">8.4</a>.  Implementation for the Packet Erasure Channel</span>

   In a packet erasure channel, each packet (including its symbol(s),
   since packets contain G &gt;= 1 symbols) is either correctly received or
   erased.  The location of the erased symbols in the sequence of
   symbols MUST be known.  The following specification describes the use
   of Reed-Solomon codes for generating redundant symbols from the k
   source symbols and for recovering the source symbols from any set of
   k received symbols.

   The k source symbols of a source block are assumed to be composed of
   S m-bit elements.  Each m-bit element corresponds to an element of
   the finite field GF(2^^m) through the polynomial representation
   (<a href="#section-8.1">Section 8.1</a>).  If some of the source symbols contain less than S
   elements, they MUST be virtually padded with zero elements (this can
   be the case for the last symbol of the last block of the object).
   However, this padding does not need to be actually sent with the data
   to the receivers.





<span class="grey">Lacan, et al.               Standards Track                    [Page 19]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-20" id="page-20" name="page-20"> </a>
<span class="grey"><a href="rfc5510.html">RFC 5510</a>         Reed-Solomon Forward Error Correction        April 2009</span>


   The encoding process produces n encoding symbols of size S m-bit
   elements, of which k are source symbols (this is a systematic code)
   and n-k are repair symbols (Figure 7).  The m-bit elements of the
   repair symbols are calculated using the corresponding m-bit elements
   of the source symbol set.  A logical u-th source vector, comprised of
   the u-th elements from the set of source symbols, is used to
   calculate a u-th encoding vector.  This u-th encoding vector then
   provides the u-th elements for the set encoding symbols calculated
   for the block.  As a systematic code, the first k encoding symbols
   are the same as the k source symbols, and the last n-k repair symbols
   are the result of the Reed-Solomon encoding.








































<span class="grey">Lacan, et al.               Standards Track                    [Page 20]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-21" id="page-21" name="page-21"> </a>
<span class="grey"><a href="rfc5510.html">RFC 5510</a>         Reed-Solomon Forward Error Correction        April 2009</span>


          Input:  k source symbols

    0             u                                S-1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |             |X|                                 | source symbol 0
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |             |X|                                 | source symbol 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                . . .
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |             |X|                                 | source symbol k-1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                  *

        +--------------------+
        |  generator matrix  |
        |         GM         |
        |       (k x n)      |
        +--------------------+

                  |
                  V

        Output: n encoding symbols (source + repair)

    0             u                                S-1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |             |X|                                 | enc. symbol 0
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |             |X|                                 | enc. symbol 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                . . .
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |             |Y|                                 | enc. symbol n-1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                     Figure 7: Packet Encoding Scheme

   An asset of this scheme is that the loss of some encoding symbols
   produces the same erasure pattern for each of the S encoding vectors.
   It follows that the matrix inversion must be done only once and will
   be used by all the S encoding vectors.  For large S, this matrix
   inversion cost becomes negligible in front of the S vector-matrix
   multiplications.




<span class="grey">Lacan, et al.               Standards Track                    [Page 21]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-22" id="page-22" name="page-22"> </a>
<span class="grey"><a href="rfc5510.html">RFC 5510</a>         Reed-Solomon Forward Error Correction        April 2009</span>


   Another asset is that the n-k repair symbols can be produced on
   demand.  For instance, a sender can start by producing a limited
   number of repair symbols and later on, depending on the observed
   erasures on the channel, decide to produce additional repair symbols,
   up to the n-k upper limit.  Indeed, to produce the repair symbol e_j,
   where k &lt;= j &lt; n, it is sufficient to multiply the S source vectors
   with column j of GM.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/9.%20%20Security%20Considerations"></a><a class="selflink" href="#section-9" name="section-9">9</a>.  Security Considerations</span>

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/9.1.%20%20Problem%20Statement"></a><a class="selflink" href="#section-9.1" name="section-9.1">9.1</a>.  Problem Statement</span>

   A content delivery system is potentially subject to many attacks:
   some of them target the network (e.g., to compromise the routing
   infrastructure, by compromising the congestion control component),
   others target the Content Delivery Protocol (CDP) (e.g., to
   compromise its normal behavior), and finally some attacks target the
   content itself.  Since this document focuses on a FEC building block
   independently of any particular CDP (even if ALC and NORM are two
   natural candidates), this section only discusses the additional
   threats that an arbitrary CDP may be exposed to when using this
   building block.

   More specifically, several kinds of attacks exist:

   o  those that are meant to give access to confidential content (e.g.,
      in case of non-free content),

   o  those that try to corrupt the object being transmitted (e.g., to
      inject malicious code within an object or to prevent a receiver
      from using an object),

   o  and those that try to compromise the receiver's behavior (e.g., by
      making the decoding of an object computationally expensive).

   These attacks can be launched either against the data flow itself
   (e.g., by sending forged symbols) or against the FEC parameters that
   are sent either in-band (e.g., in an EXT_FTI or FDT Instance) or out-
   of-band (e.g., in a session description).












<span class="grey">Lacan, et al.               Standards Track                    [Page 22]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-23" id="page-23" name="page-23"> </a>
<span class="grey"><a href="rfc5510.html">RFC 5510</a>         Reed-Solomon Forward Error Correction        April 2009</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/9.2.%20%20Attacks%20against%20the%20Data%20Flow"></a><a class="selflink" href="#section-9.2" name="section-9.2">9.2</a>.  Attacks against the Data Flow</span>

   First of all, let us consider the attacks against the data flow.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/9.2.1.%20%20Access%20to%20Confidential%20Objects"></a><a class="selflink" href="#section-9.2.1" name="section-9.2.1">9.2.1</a>.  Access to Confidential Objects</span>

   Access control to the object being transmitted is typically provided
   by means of encryption.  This encryption can be done over the whole
   object (e.g., by the content provider, before the FEC encoding
   process), or be done on a packet per-packet basis (e.g., when IPsec
   Encapsulating Security Payload (ESP) is used [<a href="rfc4303.html" title='"IP Encapsulating Security Payload (ESP)"'>RFC4303</a>]).  If access
   control is a concern, it is RECOMMENDED that one of these solutions
   be used.  Even if we mention these attacks here, they are not related
   nor facilitated by the use of FEC.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/9.2.2.%20%20Content%20Corruption"></a><a class="selflink" href="#section-9.2.2" name="section-9.2.2">9.2.2</a>.  Content Corruption</span>

   Protection against corruptions (e.g., after sending forged packets)
   is achieved by means of a content integrity verification/sender
   authentication scheme.  This service can be provided at the object
   level, but in that case a receiver has no way to identify which
   symbol(s) are corrupted if the object is detected as corrupted.  This
   service can also be provided at the packet level.  In this case,
   after removing all forged packets, the object may be recovered
   sometimes.  Several techniques can provide this source
   authentication/content integrity service:

   o  At the object level, the object MAY be digitally signed (with
      public key cryptography), for instance by using RSASSA-PKCS1-v1_5
      [<a href="rfc3447.html" title='"Public-Key Cryptography Standards (PKCS) #1: RSA Cryptography Specifications Version 2.1"'>RFC3447</a>].  This signature enables a receiver to check the object
      integrity, once the object has been fully decoded.  Even if
      digital signatures are computationally expensive, this calculation
      occurs only once per object, which is usually acceptable.

   o  At the packet level, each packet can be digitally signed.  A major
      limitation is the high computational and transmission overheads
      that this solution requires (unless Elliptic Curve Cryptography
      (ECC) is used).  To avoid this problem, the signature may span a
      set of symbols (instead of a single one) in order to amortize the
      signature calculation.  But if a single symbol is missing, the
      integrity of the whole set cannot be checked.

   o  At the packet level, a Group Message Authentication Code (MAC)
      [<a href="rfc2104.html" title='"HMAC: Keyed-Hashing for Message Authentication"'>RFC2104</a>] scheme can be used; for instance, by using HMAC-SHA-256
      with a secret key shared by all the group members (i.e., the
      sender(s) and receivers).  Thanks to the secret key, this
      technique creates a cryptographically secured digest of a packet
      that is sent along with the packet.  The Group MAC scheme does not



<span class="grey">Lacan, et al.               Standards Track                    [Page 23]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-24" id="page-24" name="page-24"> </a>
<span class="grey"><a href="rfc5510.html">RFC 5510</a>         Reed-Solomon Forward Error Correction        April 2009</span>


      create prohibitive processing load nor transmission overhead, but
      it has a major limitation: it only provides a group
      authentication/integrity service since all group members share the
      same secret group key, which means that each member can send a
      forged packet.  It is therefore restricted to situations where
      group members are fully trusted (or in association with another
      technique as a pre-check).

   o  At the packet level, TESLA [<a href="rfc4082.html" title='"Timed Efficient Stream Loss-Tolerant Authentication (TESLA): Multicast Source Authentication Transform Introduction"'>RFC4082</a>] is a very attractive and
      efficient solution that is robust to losses, provides a true
      authentication/integrity service, and does not create any
      prohibitive processing load or transmission overhead.  Yet
      checking a packet requires a small delay (a second or more) after
      its reception.

   Techniques relying on public key cryptography (digital signatures and
   TESLA during the bootstrap process, when used) require that public
   keys be securely associated to the entities.  This can be achieved by
   a Public Key Infrastructure (PKI), or by a PGP Web of Trust, or by
   pre-distributing the public keys of each group member.

   Techniques relying on symmetric key cryptography (group MAC) require
   that a secret key be shared by all group members.  This can be
   achieved by means of a group key management protocol, or simply by
   pre-distributing the secret key (but this manual solution has many
   limitations).

   It is up to the developer and deployer, who know the security
   requirements and features of the target application area, to define
   which solution is the most appropriate.  Nonetheless, in case there
   is any concern of the threat of object corruption, it is RECOMMENDED
   that at least one of these techniques be used.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/9.3.%20%20Attacks%20against%20the%20FEC%20Parameters"></a><a class="selflink" href="#section-9.3" name="section-9.3">9.3</a>.  Attacks against the FEC Parameters</span>

   Let us now consider attacks against the FEC parameters (or FEC OTI).
   The FEC OTI can either be sent in-band (i.e., in an EXT_FTI or in an
   FDT Instance containing FEC OTI for the object) or out-of-band (e.g.,
   in a session description).  Attacks on these FEC parameters can
   prevent the decoding of the associated object: for instance,
   modifying the B parameter will lead to a different block partitioning
   at a receiver thereby compromising decoding; or setting the m
   parameter to 16 instead of 8 with FEC Encoding ID 2 will increase the
   processing load while compromising decoding.

   It is therefore RECOMMENDED that security measures be taken to
   guarantee the FEC OTI integrity.  To that purpose, the packets
   carrying the FEC parameters sent in-band in an EXT_FTI header



<span class="grey">Lacan, et al.               Standards Track                    [Page 24]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-25" id="page-25" name="page-25"> </a>
<span class="grey"><a href="rfc5510.html">RFC 5510</a>         Reed-Solomon Forward Error Correction        April 2009</span>


   extension SHOULD be protected by one of the per-packet techniques
   described above: digital signature, group MAC, or TESLA.  When FEC
   OTI is contained in an FDT Instance, this FDT Instance object SHOULD
   be protected, for instance, by digitally signing it with XML digital
   signatures [<a href="rfc3275.html" title='"(Extensible Markup Language) XML-Signature Syntax and Processing"'>RFC3275</a>].  Finally, when FEC OTI is sent out-of-band
   (e.g., in a session description), this FEC OTI SHOULD be protected,
   for instance, by digitally signing the object that includes this FEC
   OTI.

   The same considerations concerning the key management aspects apply
   here also.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/10.%20%20IANA%20Considerations"></a><a class="selflink" href="#section-10" name="section-10">10</a>.  IANA Considerations</span>

   Values of FEC Encoding IDs and FEC Instance IDs are subject to IANA
   registration.  For general guidelines on IANA considerations as they
   apply to this document, see [<a href="rfc5052.html" title='"Forward Error Correction (FEC) Building Block"'>RFC5052</a>].

   This document assigns the Fully-Specified FEC Encoding ID 2 under the
   "ietf:rmt:fec:encoding" name-space to "Reed-Solomon Codes over
   GF(2^^m)".

   This document assigns the Fully-Specified FEC Encoding ID 5 under the
   "ietf:rmt:fec:encoding" name-space to "Reed-Solomon Codes over
   GF(2^^8)".

   This document assigns the FEC Instance ID 0 scoped by the Under-
   Specified FEC Encoding ID 129 to "Reed-Solomon Codes over GF(2^^8)".
   More specifically, under the "ietf:rmt:fec:encoding:instance" sub-
   name-space that is scoped by the "ietf:rmt:fec:encoding" called
   "Small Block Systematic FEC Codes", this document assigns FEC
   Instance ID 0 to "Reed-Solomon Codes over GF(2^^8)".

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/11.%20%20Acknowledgments"></a><a class="selflink" href="#section-11" name="section-11">11</a>.  Acknowledgments</span>

   The authors want to thank Brian Adamson, Igor Slepchin, Stephen Kent,
   Francis Dupont, Elwyn Davies, Magnus Westerlund, and Alfred Hoenes
   for their valuable comments.  The authors also want to thank Luigi
   Rizzo for his comments and for the design of the reference Reed-
   Solomon codec.











<span class="grey">Lacan, et al.               Standards Track                    [Page 25]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-26" id="page-26" name="page-26"> </a>
<span class="grey"><a href="rfc5510.html">RFC 5510</a>         Reed-Solomon Forward Error Correction        April 2009</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/12.%20%20References"></a><a class="selflink" href="#section-12" name="section-12">12</a>.  References</span>

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/12.1.%20%20Normative%20References"></a><a class="selflink" href="#section-12.1" name="section-12.1">12.1</a>.  Normative References</span>

   [<a id="ref-RFC2119" name="ref-RFC2119">RFC2119</a>]   Bradner, S., "Key words for use in RFCs to Indicate
               Requirement Levels", <a href="https://tools.ietf.org/html/bcp14">BCP 14</a>, <a href="rfc2119.html">RFC 2119</a>, March 1997.

   [<a id="ref-RFC5052" name="ref-RFC5052">RFC5052</a>]   Watson, M., Luby, M., and L. Vicisano, "Forward Error
               Correction (FEC) Building Block", <a href="rfc5052.html">RFC 5052</a>, August 2007.

   [<a id="ref-RFC5445" name="ref-RFC5445">RFC5445</a>]   Watson, M., "Basic Forward Error Correction (FEC)
               Schemes", <a href="rfc5445.html">RFC 5445</a>, March 2009.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/12.2.%20%20Informative%20References"></a><a class="selflink" href="#section-12.2" name="section-12.2">12.2</a>.  Informative References</span>

   [<a id="ref-RFC3453" name="ref-RFC3453">RFC3453</a>]   Luby, M., Vicisano, L., Gemmell, J., Rizzo, L., Handley,
               M., and J. Crowcroft, "The Use of Forward Error
               Correction (FEC) in Reliable Multicast", <a href="rfc3453.html">RFC 3453</a>,
               December 2002.

   [<a id="ref-RS-codec" name="ref-RS-codec">RS-codec</a>]  Rizzo, L., "Reed-Solomon FEC codec", available at
               <a href="http://info.iet.unipi.it/~luigi/vdm98/vdm980702.tgz">http://info.iet.unipi.it/~luigi/vdm98/vdm980702.tgz</a> and
               mirrored at <a href="http://planete-bcast.inrialpes.fr/">http://planete-bcast.inrialpes.fr/</a>, revised
               version of July 1998.

   [<a id="ref-Rizzo97" name="ref-Rizzo97">Rizzo97</a>]   Rizzo, L., "Effective Erasure Codes for Reliable Computer
               Communication Protocols", ACM SIGCOMM Computer
               Communication Review Vol.27, No.2, pp.24-36, April 1997.

   [<a id="ref-MWS77" name="ref-MWS77">MWS77</a>]     Mac Williams, F. and N. Sloane, "The Theory of Error
               Correcting Codes", North Holland, 1977.

   [<a id="ref-GO94" name="ref-GO94">GO94</a>]      Gohberg, I. and V. Olshevsky, "Fast algorithms with
               preprocessing for matrix-vector multiplication problems",
               Journal of Complexity, pp. 411-427, vol. 10, 1994.

   [<a id="ref-RFC5170" name="ref-RFC5170">RFC5170</a>]   Roca, V., Neumann, C., and D. Furodet, "Low Density
               Parity Check (LDPC) Forward Error Correction", <a href="rfc5170.html">RFC 5170</a>,
               June 2008.

   [<a id="ref-RFC5053" name="ref-RFC5053">RFC5053</a>]   Luby, M., Shokrollahi, A., Watson, M., and T.
               Stockhammer, "Raptor Forward Error Correction Scheme",
               <a href="rfc5053.html">RFC 5053</a>, October 2007.

   [<a id="ref-ALC" name="ref-ALC">ALC</a>]       Luby, M., Watson, M., and L. Vicisano, "Asynchronous
               Layered Coding (ALC) Protocol Instantiation", Work
               in Progress, November 2008.




<span class="grey">Lacan, et al.               Standards Track                    [Page 26]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-27" id="page-27" name="page-27"> </a>
<span class="grey"><a href="rfc5510.html">RFC 5510</a>         Reed-Solomon Forward Error Correction        April 2009</span>


   [<a id="ref-NORM" name="ref-NORM">NORM</a>]      Adamson, B., Bormann, C., Handley, M., and J. Macker,
               "NACK-Oriented Reliable Multicast Protocol", Work
               in Progress, March 2009.

   [<a id="ref-FLUTE" name="ref-FLUTE">FLUTE</a>]     Paila, T., Walsh, R., Luby, M., Lehtonen, R., and V.
               Roca, "FLUTE - File Delivery over Unidirectional
               Transport", Work in Progress, September 2008.

   [<a id="ref-RFC3447" name="ref-RFC3447">RFC3447</a>]   Jonsson, J. and B. Kaliski, "Public-Key Cryptography
               Standards (PKCS) #1: RSA Cryptography Specifications
               Version 2.1", <a href="rfc3447.html">RFC 3447</a>, February 2003.

   [<a id="ref-RFC4303" name="ref-RFC4303">RFC4303</a>]   Kent, S., "IP Encapsulating Security Payload (ESP)",
               <a href="rfc4303.html">RFC 4303</a>, December 2005.

   [<a id="ref-RFC2104" name="ref-RFC2104">RFC2104</a>]   "HMAC: Keyed-Hashing for Message Authentication",
               <a href="rfc2104.html">RFC 2104</a>, February 1997.

   [<a id="ref-RFC4082" name="ref-RFC4082">RFC4082</a>]   "Timed Efficient Stream Loss-Tolerant Authentication
               (TESLA): Multicast Source Authentication Transform
               Introduction", <a href="rfc4082.html">RFC 4082</a>, June 2005.

   [<a id="ref-RFC3275" name="ref-RFC3275">RFC3275</a>]   Eastlake 3rd, D., Reagle, J., and D. Solo, "(Extensible
               Markup Language) XML-Signature Syntax and Processing",
               <a href="rfc3275.html">RFC 3275</a>, March 2002.


























<span class="grey">Lacan, et al.               Standards Track                    [Page 27]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-28" id="page-28" name="page-28"> </a>
<span class="grey"><a href="rfc5510.html">RFC 5510</a>         Reed-Solomon Forward Error Correction        April 2009</span>


Authors' Addresses

   Jerome Lacan
   ISAE/LAAS-CNRS
   1, place Emile Blouin
   Toulouse  31056
   France

   EMail: jerome.lacan@isae.fr
   URI:   <a href="http://pagespro.isae.fr/jerome-lacan/">http://pagespro.isae.fr/jerome-lacan/</a>


   Vincent Roca
   INRIA
   655, av. de l'Europe
   Inovallee; Montbonnot
   ST ISMIER cedex  38334
   France

   EMail: vincent.roca@inria.fr
   URI:   <a href="http://planete.inrialpes.fr/people/roca/">http://planete.inrialpes.fr/people/roca/</a>


   Jani Peltotalo
   Tampere University of Technology
   P.O. Box 553 (Korkeakoulunkatu 1)
   Tampere  FIN-33101
   Finland

   EMail: jani.peltotalo@tut.fi
   URI:   <a href="http://mad.cs.tut.fi/">http://mad.cs.tut.fi/</a>


   Sami Peltotalo
   Tampere University of Technology
   P.O. Box 553 (Korkeakoulunkatu 1)
   Tampere  FIN-33101
   Finland

   EMail: sami.peltotalo@tut.fi
   URI:   <a href="http://mad.cs.tut.fi/">http://mad.cs.tut.fi/</a>










Lacan, et al.               Standards Track                    [Page 28]

</pre><br/>
    <span class="noprint"><small><small>Html markup produced by rfcmarkup 1.126, available from
      <a href="https://tools.ietf.org/tools/rfcmarkup/">https://tools.ietf.org/tools/rfcmarkup/</a>
    </small></small></span>
  </div>




</body><!-- Mirrored from tools.ietf.org/html/rfc5510 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 06 Mar 2018 23:18:34 GMT --></html>