<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml"><!-- Mirrored from tools.ietf.org/html/rfc5746 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 06 Mar 2018 23:18:33 GMT --><!-- Added by HTTrack --><head><meta content="text/html;charset=utf-8" http-equiv="content-type"/><!-- /Added by HTTrack -->

    <meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
    <meta content="index,follow" name="robots"/>
    <meta content="rfcmarkup version 1.126" name="creator"/>
    <link href="http://purl.org/dc/elements/1.1/" rel="schema.DC"/>
<meta content="draft-rescorla-tls-renegotiation" name="DC.Relation.Replaces"/>
<meta content="urn:ietf:rfc:5746" name="DC.Identifier"/>
<meta content="February, 2010" name="DC.Date.Issued"/>
<meta content="Ray, Marsh" name="DC.Creator"/>
<meta content="Dispensa, Steve" name="DC.Creator"/>
<meta content="Rescorla, Eric" name="DC.Creator"/>
<meta content="Microsoft, One" name="DC.Creator"/>
<meta content="SSL and TLS renegotiation are vulnerable to an attack in which the
attacker forms a TLS connection with the target server, injects
content of his choice, and then splices in a new TLS connection from a
client. The server treats the client's initial TLS handshake as a
renegotiation and thus believes that the initial data transmitted by
the attacker is from the same entity as the subsequent client data.
This draft defines a TLS extension to cryptographically tie
renegotiations to the TLS connections they are being performed over,
thus preventing this attack." name="DC.Description.Abstract"/>
<meta content="Transport Layer Security (TLS) Renegotiation Indication Extension" name="DC.Title"/>

    <link href="https://tools.ietf.org/images/rfc.png" rel="icon" type="image/png"/>
    <link href="https://tools.ietf.org/images/rfc.png" rel="shortcut icon" type="image/png"/>
    <title>RFC 5746 - Transport Layer Security (TLS) Renegotiation Indication Extension</title>
    
    
    <style type="text/css">
	@media only screen 
	  and (min-width: 992px)
	  and (max-width: 1199px) {
	    body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 768px)
	  and (max-width: 991px) {
            body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 480px)
	  and (max-width: 767px) {
            body { font-size: 11pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (max-width: 479px) {
            body { font-size: 8pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-device-width : 375px) 
	  and (max-device-width : 667px) {
            body { font-size: 9.5pt; }
            div.content { width: 96ex; margin: 0 1px; }
        }
	@media only screen 
	  and (min-device-width: 1200px) {
            body { font-size: 10pt; margin: 0 4em; }
            div.content { width: 96ex; margin: 0; }
        }
        h1, h2, h3, h4, h5, h6, .h1, .h2, .h3, .h4, .h5, .h6 {
	    font-weight: bold;
            line-height: 0pt;
            display: inline;
            white-space: pre;
            font-family: monospace;
            font-size: 1em;
	    font-weight: bold;
        }
        pre {
            font-size: 1em;
            margin-top: 0px;
            margin-bottom: 0px;
        }
	.pre {
	    white-space: pre;
	    font-family: monospace;
	}
	.header{
	    font-weight: bold;
	}
        .newpage {
            page-break-before: always;
        }
        .invisible {
            text-decoration: none;
            color: white;
        }
        a.selflink {
          color: black;
          text-decoration: none;
        }
        @media print {
            body {
                font-family: monospace;
                font-size: 10.5pt;
            }
            h1, h2, h3, h4, h5, h6 {
                font-size: 1em;
            }
        
            a:link, a:visited {
                color: inherit;
                text-decoration: none;
            }
            .noprint {
                display: none;
            }
        }
	@media screen {
	    .grey, .grey a:link, .grey a:visited {
		color: #777;
	    }
            .docinfo {
                background-color: #EEE;
            }
            .top {
                border-top: 7px solid #EEE;
            }
            .bgwhite  { background-color: white; }
            .bgred    { background-color: #F44; }
            .bggrey   { background-color: #666; }
            .bgbrown  { background-color: #840; }            
            .bgorange { background-color: #FA0; }
            .bgyellow { background-color: #EE0; }
            .bgmagenta{ background-color: #F4F; }
            .bgblue   { background-color: #66F; }
            .bgcyan   { background-color: #4DD; }
            .bggreen  { background-color: #4F4; }

            .legend   { font-size: 90%; }
            .cplate   { font-size: 70%; border: solid grey 1px; }
	}
    </style>
    <!--[if IE]>
    <style>
    body {
       font-size: 13px;
       margin: 10px 10px;
    }
    </style>
    <![endif]-->

    <script type="text/javascript"><!--
    function addHeaderTags() {
	var spans = document.getElementsByTagName("span");
	for (var i=0; i < spans.length; i++) {
	    var elem = spans[i];
	    if (elem) {
		var level = elem.getAttribute("class");
                if (level == "h1" || level == "h2" || level == "h3" || level == "h4" || level == "h5" || level == "h6") {
                    elem.innerHTML = "<"+level+">"+elem.innerHTML+"</"+level+">";		
                }
	    }
	}
    }
    var legend_html = "Colour legend:<br />      <table>         <tr><td>Unknown:</td>                   <td><span class='cplate bgwhite'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft:</td>                     <td><span class='cplate bgred'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Informational:</td>             <td><span class='cplate bgorange'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Experimental:</td>              <td><span class='cplate bgyellow'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Best Common Practice:</td>      <td><span class='cplate bgmagenta'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Proposed Standard:</td>         <td><span class='cplate bgblue'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft Standard (old designation):</td> <td><span class='cplate bgcyan'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Internet Standard:</td>         <td><span class='cplate bggreen'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Historic:</td>                  <td><span class='cplate bggrey'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Obsolete:</td>                  <td><span class='cplate bgbrown'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>     </table>";
    function showElem(id) {
        var elem = document.getElementById(id);
        elem.innerHTML = eval(id+"_html");
        elem.style.visibility='visible';
    }
    function hideElem(id) {
        var elem = document.getElementById(id);
        elem.style.visibility='hidden';        
        elem.innerHTML = "";
    }
    // -->
    </script>
</head>
<body onload="addHeaderTags()">
  <div class="content">
   <div style="height: 13px;">
      <div class="pre noprint docinfo bgblue" onclick="showElem('legend');" onmouseout="hideElem('legend')" onmouseover="this.style.cursor='pointer';" style="height: 6px; position: absolute;" title="Click for colour legend.">                                                                        </div>
      <div class="docinfo noprint pre legend" id="legend" onmouseout="hideElem('legend');" onmouseover="showElem('legend');" style="position:absolute; top: 4px; left: 4ex; visibility:hidden; background-color: white; padding: 4px 9px 5px 7px; border: solid #345 1px; ">
      </div>
   </div>
<span class="pre noprint docinfo top">[<a href="index.html" title="Document search and retrieval page">Docs</a>] [<a href="https://tools.ietf.org/rfc/rfc5746.txt" title="Plaintext version of this document">txt</a>|<a href="https://tools.ietf.org/pdf/rfc5746" title="PDF version of this document">pdf</a>] [<a href="https://tools.ietf.org/html/draft-ietf-tls-renegotiation" title="draft-ietf-tls-renegotiation">draft-ietf-tls-...</a>] [<a href="https://datatracker.ietf.org/doc/rfc5746" title="IESG Datatracker information for this document">Tracker</a>] [<a href="https://tools.ietf.org/rfcdiff?difftype=--hwdiff&amp;url2=rfc5746" title="Inline diff (wdiff)">Diff1</a>] [<a href="https://tools.ietf.org/rfcdiff?url2=rfc5746" title="Side-by-side diff">Diff2</a>]         </span><br/>
<span class="pre noprint docinfo">                                                                        </span><br/>
<span class="pre noprint docinfo">                                                       PROPOSED STANDARD</span><br/>
<span class="pre noprint docinfo">                                                                        </span><br/>
<pre>Internet Engineering Task Force (IETF)                       E. Rescorla
Request for Comments: 5746                                    RTFM, Inc.
Updates: <a href="rfc5246.html">5246</a>, <a href="rfc4366.html">4366</a>, <a href="rfc4347.html">4347</a>, <a href="rfc4346.html">4346</a>, <a href="rfc2246.html">2246</a>                             M. Ray
Category: Standards Track                                    S. Dispensa
ISSN: 2070-1721                                              PhoneFactor
                                                                N. Oskov
                                                               Microsoft
                                                           February 2010


   <span class="h1">Transport Layer Security (TLS) Renegotiation Indication Extension</span>

Abstract

   Secure Socket Layer (SSL) and Transport Layer Security (TLS)
   renegotiation are vulnerable to an attack in which the attacker forms
   a TLS connection with the target server, injects content of his
   choice, and then splices in a new TLS connection from a client.  The
   server treats the client's initial TLS handshake as a renegotiation
   and thus believes that the initial data transmitted by the attacker
   is from the same entity as the subsequent client data.  This
   specification defines a TLS extension to cryptographically tie
   renegotiations to the TLS connections they are being performed over,
   thus preventing this attack.

Status of This Memo

   This is an Internet Standards Track document.

   This document is a product of the Internet Engineering Task Force
   (IETF).  It represents the consensus of the IETF community.  It has
   received public review and has been approved for publication by the
   Internet Engineering Steering Group (IESG).  Further information on
   Internet Standards is available in <a href="rfc5741.html#section-2">Section 2 of RFC 5741</a>.

   Information about the current status of this document, any errata,
   and how to provide feedback on it may be obtained at
   <a href="http://www.rfc-editor.org/info/rfc5746">http://www.rfc-editor.org/info/rfc5746</a>.













<span class="grey">Rescorla, et al.             Standards Track                    [Page 1]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-2" id="page-2" name="page-2"> </a>
<span class="grey"><a href="rfc5746.html">RFC 5746</a>               TLS Renegotiation Extension         February 2010</span>


Copyright Notice

   Copyright (c) 2010 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to <a href="https://tools.ietf.org/html/bcp78">BCP 78</a> and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (<a href="http://trustee.ietf.org/license-info">http://trustee.ietf.org/license-info</a>) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.

Table of Contents

   <a href="#section-1">1</a>. Introduction ....................................................<a href="#page-3">3</a>
   <a href="#section-2">2</a>. Conventions Used in This Document ...............................<a href="#page-4">4</a>
   <a href="#section-3">3</a>. Secure Renegotiation Definition .................................<a href="#page-4">4</a>
      <a href="#section-3.1">3.1</a>. Additional Connection State ................................<a href="#page-4">4</a>
      <a href="#section-3.2">3.2</a>. Extension Definition .......................................<a href="#page-5">5</a>
      3.3. Renegotiation Protection Request Signaling Cipher
           Suite Value ................................................<a href="#page-6">6</a>
      <a href="#section-3.4">3.4</a>. Client Behavior: Initial Handshake .........................<a href="#page-6">6</a>
      <a href="#section-3.5">3.5</a>. Client Behavior: Secure Renegotiation ......................<a href="#page-7">7</a>
      <a href="#section-3.6">3.6</a>. Server Behavior: Initial Handshake .........................<a href="#page-7">7</a>
      <a href="#section-3.7">3.7</a>. Server Behavior: Secure Renegotiation ......................<a href="#page-8">8</a>
   <a href="#section-4">4</a>. Backward Compatibility ..........................................<a href="#page-9">9</a>
      <a href="#section-4.1">4.1</a>. Client Considerations ......................................<a href="#page-9">9</a>
      <a href="#section-4.2">4.2</a>. Client Behavior: Legacy (Insecure) Renegotiation ..........<a href="#page-10">10</a>
      <a href="#section-4.3">4.3</a>. Server Considerations .....................................<a href="#page-10">10</a>
      <a href="#section-4.4">4.4</a>. Server Behavior: Legacy (Insecure) Renegotiation ..........<a href="#page-11">11</a>
      <a href="#section-4.5">4.5</a>. SSLv3 .....................................................<a href="#page-11">11</a>
   <a href="#section-5">5</a>. Security Considerations ........................................<a href="#page-12">12</a>
   <a href="#section-6">6</a>. IANA Considerations ............................................<a href="#page-13">13</a>
   <a href="#section-7">7</a>. Acknowledgements ...............................................<a href="#page-13">13</a>
   <a href="#section-8">8</a>. References .....................................................<a href="#page-13">13</a>
      <a href="#section-8.1">8.1</a>. Normative References ......................................<a href="#page-13">13</a>
      <a href="#section-8.2">8.2</a>. Informative References ....................................<a href="#page-13">13</a>











<span class="grey">Rescorla, et al.             Standards Track                    [Page 2]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-3" id="page-3" name="page-3"> </a>
<span class="grey"><a href="rfc5746.html">RFC 5746</a>               TLS Renegotiation Extension         February 2010</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/1.%20%20Introduction"></a><a class="selflink" href="#section-1" name="section-1">1</a>.  Introduction</span>

   TLS [<a href="rfc5246.html" title='"The Transport Layer Security (TLS) Protocol Version 1.2"'>RFC5246</a>] allows either the client or the server to initiate
   renegotiation -- a new handshake that establishes new cryptographic
   parameters.  Unfortunately, although the new handshake is carried out
   using the cryptographic parameters established by the original
   handshake, there is no cryptographic binding between the two.  This
   creates the opportunity for an attack in which the attacker who can
   intercept a client's transport layer connection can inject traffic of
   his own as a prefix to the client's interaction with the server.  One
   form of this attack [<a href="#ref-Ray09" title='"Authentication Gap in TLS Renegotiation"'>Ray09</a>] proceeds as shown below:

   Client                        Attacker                        Server
   ------                        -------                         ------
                                     &lt;----------- Handshake ----------&gt;
                                     &lt;======= Initial Traffic ========&gt;
   &lt;--------------------------  Handshake ============================&gt;
   &lt;======================== Client Traffic ==========================&gt;

   To start the attack, the attacker forms a TLS connection to the
   server (perhaps in response to an initial intercepted connection from
   the client).  He then sends any traffic of his choice to the server.
   This may involve multiple requests and responses at the application
   layer, or may simply be a partial application layer request intended
   to prefix the client's data.  This traffic is shown with == to
   indicate it is encrypted.  He then allows the client's TLS handshake
   to proceed with the server.  The handshake is in the clear to the
   attacker but encrypted over the attacker's TLS connection to the
   server.  Once the handshake has completed, the client communicates
   with the server over the newly established security parameters with
   the server.  The attacker cannot read this traffic, but the server
   believes that the initial traffic to and from the attacker is the
   same as that to and from the client.

   If certificate-based client authentication is used, the server will
   see a stream of bytes where the initial bytes are protected but
   unauthenticated by TLS and subsequent bytes are authenticated by TLS
   and bound to the client's certificate.  In some protocols (notably
   HTTPS), no distinction is made between pre- and post-authentication
   stages and the bytes are handled uniformly, resulting in the server
   believing that the initial traffic corresponds to the authenticated
   client identity.  Even without certificate-based authentication, a
   variety of attacks may be possible in which the attacker convinces
   the server to accept data from it as data from the client.  For
   instance, if HTTPS [<a href="rfc2818.html" title='"HTTP Over TLS"'>RFC2818</a>] is in use with HTTP cookies [<a href="rfc2965.html" title='"HTTP State Management Mechanism"'>RFC2965</a>],
   the attacker may be able to generate a request of his choice
   validated by the client's cookie.




<span class="grey">Rescorla, et al.             Standards Track                    [Page 3]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-4" id="page-4" name="page-4"> </a>
<span class="grey"><a href="rfc5746.html">RFC 5746</a>               TLS Renegotiation Extension         February 2010</span>


   Some protocols -- such as IMAP or SMTP -- have more explicit
   transitions between authenticated and unauthenticated phases and
   require that the protocol state machine be partly or fully reset at
   such transitions.  If strictly followed, these rules may limit the
   effect of attacks.  Unfortunately, there is no requirement for state
   machine resets at TLS renegotiation, and thus there is still a
   potential window of vulnerability, for instance, by prefixing a
   command that writes to an area visible by the attacker with a command
   by the client that includes his password, thus making the client's
   password visible to the attacker (note that this precise attack does
   not work with challenge-response authentication schemes, but other
   attacks may be possible).  Similar attacks are available with SMTP,
   and in fact do not necessarily require the attacker to have an
   account on the target server.

   It is important to note that in both cases these attacks are possible
   because the client sends unsolicited authentication information
   without requiring any specific data from the server over the TLS
   connection.  Protocols that require a round trip to the server over
   TLS before the client sends sensitive information are likely to be
   less vulnerable.

   These attacks can be prevented by cryptographically binding
   renegotiation handshakes to the enclosing TLS cryptographic
   parameters, thus allowing the server to differentiate renegotiation
   from initial negotiation, as well as preventing renegotiations from
   being spliced in between connections.  An attempt by an attacker to
   inject himself as described above will result in a mismatch of the
   cryptographic binding and can thus be detected.  The data used in the
   extension is similar to, but not the same as, the data used in the
   tls-unique and/or tls-unique-for-telnet channel bindings described in
   [<a href="#ref-TLS-CHANNEL-BINDINGS">TLS-CHANNEL-BINDINGS</a>]; however, this extension is not a general-
   purpose <a href="rfc5056.html">RFC 5056</a> [<a href="rfc5056.html" title='"On the Use of Channel Bindings to Secure Channels"'>RFC5056</a>] channel binding facility.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/2.%20%20Conventions%20Used%20in%20This%20Document"></a><a class="selflink" href="#section-2" name="section-2">2</a>.  Conventions Used in This Document</span>

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in [<a href="rfc2119.html" title='"Key words for use in RFCs to Indicate Requirement Levels"'>RFC2119</a>].

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/3.%20%20Secure%20Renegotiation%20Definition"></a><a class="selflink" href="#section-3" name="section-3">3</a>.  Secure Renegotiation Definition</span>

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.1.%20%20Additional%20Connection%20State"></a><a class="selflink" href="#section-3.1" name="section-3.1">3.1</a>.  Additional Connection State</span>

   Both client and server need to store three additional values for each
   TLS connection state (see <a href="rfc5246.html#section-6.1">RFC 5246, Section 6.1</a>).  Note that these
   values are specific to connection (not a TLS session cache entry).




<span class="grey">Rescorla, et al.             Standards Track                    [Page 4]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-5" id="page-5" name="page-5"> </a>
<span class="grey"><a href="rfc5746.html">RFC 5746</a>               TLS Renegotiation Extension         February 2010</span>


   o  a "secure_renegotiation" flag, indicating whether secure
      renegotiation is in use for this connection.

   o  "client_verify_data":  the verify_data from the Finished message
      sent by the client on the immediately previous handshake.  For
      currently defined TLS versions and cipher suites, this will be a
      12-byte value; for SSLv3, this will be a 36-byte value.

   o  "server_verify_data":  the verify_data from the Finished message
      sent by the server on the immediately previous handshake.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.2.%20%20Extension%20Definition"></a><a class="selflink" href="#section-3.2" name="section-3.2">3.2</a>.  Extension Definition</span>

   This document defines a new TLS extension, "renegotiation_info" (with
   extension type 0xff01), which contains a cryptographic binding to the
   enclosing TLS connection (if any) for which the renegotiation is
   being performed.  The "extension data" field of this extension
   contains a "RenegotiationInfo" structure:

      struct {
          opaque renegotiated_connection&lt;0..255&gt;;
      } RenegotiationInfo;

   The contents of this extension are specified as follows.

   o  If this is the initial handshake for a connection, then the
      "renegotiated_connection" field is of zero length in both the
      ClientHello and the ServerHello.  Thus, the entire encoding of the
      extension is ff 01 00 01 00.  The first two octets represent the
      extension type, the third and fourth octets the length of the
      extension itself, and the final octet the zero length byte for the
      "renegotiated_connection" field.

   o  For ClientHellos that are renegotiating, this field contains the
      "client_verify_data" specified in <a href="#section-3.1">Section 3.1</a>.

   o  For ServerHellos that are renegotiating, this field contains the
      concatenation of client_verify_data and server_verify_data.  For
      current versions of TLS, this will be a 24-byte value (for SSLv3,
      it will be a 72-byte value).

   This extension also can be used with Datagram TLS (DTLS) [<a href="rfc4347.html" title='"Datagram Transport Layer Security"'>RFC4347</a>].
   Although, for editorial simplicity, this document refers to TLS, all
   requirements in this document apply equally to DTLS.







<span class="grey">Rescorla, et al.             Standards Track                    [Page 5]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-6" id="page-6" name="page-6"> </a>
<span class="grey"><a href="rfc5746.html">RFC 5746</a>               TLS Renegotiation Extension         February 2010</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.3.%20%20Renegotiation%20Protection%20Request%20Signaling%20Cipher%20Suite%20Value"></a><a class="selflink" href="#section-3.3" name="section-3.3">3.3</a>.  Renegotiation Protection Request Signaling Cipher Suite Value</span>

   Both the SSLv3 and TLS 1.0/TLS 1.1 specifications require
   implementations to ignore data following the ClientHello (i.e.,
   extensions) if they do not understand it.  However, some SSLv3 and
   TLS 1.0 implementations incorrectly fail the handshake in such a
   case.  This means that clients that offer the "renegotiation_info"
   extension may encounter handshake failures.  In order to enhance
   compatibility with such servers, this document defines a second
   signaling mechanism via a special Signaling Cipher Suite Value (SCSV)
   "TLS_EMPTY_RENEGOTIATION_INFO_SCSV", with code point {0x00, 0xFF}.
   This SCSV is not a true cipher suite (it does not correspond to any
   valid set of algorithms) and cannot be negotiated.  Instead, it has
   the same semantics as an empty "renegotiation_info" extension, as
   described in the following sections.  Because SSLv3 and TLS
   implementations reliably ignore unknown cipher suites, the SCSV may
   be safely sent to any server.  The SCSV can also be included in the
   SSLv2 backward compatible CLIENT-HELLO (see <a href="rfc5246.html#appendix-E.2">Appendix E.2 of
   [RFC5246]</a>).

   Note:  a minimal client that does not support renegotiation at all
   can simply use the SCSV in all initial handshakes.  The rules in the
   following sections will cause any compliant server to abort the
   handshake when it sees an apparent attempt at renegotiation by such a
   client.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.4.%20%20Client%20Behavior%3A%20Initial%20Handshake"></a><a class="selflink" href="#section-3.4" name="section-3.4">3.4</a>.  Client Behavior: Initial Handshake</span>

   Note that this section and <a href="#section-3.5">Section 3.5</a> apply to both full handshakes
   and session resumption handshakes.

   o  The client MUST include either an empty "renegotiation_info"
      extension, or the TLS_EMPTY_RENEGOTIATION_INFO_SCSV signaling
      cipher suite value in the ClientHello.  Including both is NOT
      RECOMMENDED.

   o  When a ServerHello is received, the client MUST check if it
      includes the "renegotiation_info" extension:

      *  If the extension is not present, the server does not support
         secure renegotiation; set secure_renegotiation flag to FALSE.
         In this case, some clients may want to terminate the handshake
         instead of continuing; see <a href="#section-4.1">Section 4.1</a> for discussion.








<span class="grey">Rescorla, et al.             Standards Track                    [Page 6]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-7" id="page-7" name="page-7"> </a>
<span class="grey"><a href="rfc5746.html">RFC 5746</a>               TLS Renegotiation Extension         February 2010</span>


      *  If the extension is present, set the secure_renegotiation flag
         to TRUE.  The client MUST then verify that the length of the
         "renegotiated_connection" field is zero, and if it is not, MUST
         abort the handshake (by sending a fatal handshake_failure
         alert).

         Note: later in <a href="#section-3">Section 3</a>, "abort the handshake" is used as
         shorthand for "send a fatal handshake_failure alert and
         terminate the connection".

   o  When the handshake has completed, the client needs to save the
      client_verify_data and server_verify_data values for future use.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.5.%20%20Client%20Behavior%3A%20Secure%20Renegotiation"></a><a class="selflink" href="#section-3.5" name="section-3.5">3.5</a>.  Client Behavior: Secure Renegotiation</span>

   This text applies if the connection's "secure_renegotiation" flag is
   set to TRUE (if it is set to FALSE, see <a href="#section-4.2">Section 4.2</a>).

   o  The client MUST include the "renegotiation_info" extension in the
      ClientHello, containing the saved client_verify_data.  The SCSV
      MUST NOT be included.

   o  When a ServerHello is received, the client MUST verify that the
      "renegotiation_info" extension is present; if it is not, the
      client MUST abort the handshake.

   o  The client MUST then verify that the first half of the
      "renegotiated_connection" field is equal to the saved
      client_verify_data value, and the second half is equal to the
      saved server_verify_data value.  If they are not, the client MUST
      abort the handshake.

   o  When the handshake has completed, the client needs to save the new
      client_verify_data and server_verify_data values.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.6.%20%20Server%20Behavior%3A%20Initial%20Handshake"></a><a class="selflink" href="#section-3.6" name="section-3.6">3.6</a>.  Server Behavior: Initial Handshake</span>

   Note that this section and <a href="#section-3.7">Section 3.7</a> apply to both full handshakes
   and session-resumption handshakes.

   o  When a ClientHello is received, the server MUST check if it
      includes the TLS_EMPTY_RENEGOTIATION_INFO_SCSV SCSV.  If it does,
      set the secure_renegotiation flag to TRUE.








<span class="grey">Rescorla, et al.             Standards Track                    [Page 7]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-8" id="page-8" name="page-8"> </a>
<span class="grey"><a href="rfc5746.html">RFC 5746</a>               TLS Renegotiation Extension         February 2010</span>


   o  The server MUST check if the "renegotiation_info" extension is
      included in the ClientHello.  If the extension is present, set
      secure_renegotiation flag to TRUE.  The server MUST then verify
      that the length of the "renegotiated_connection" field is zero,
      and if it is not, MUST abort the handshake.

   o  If neither the TLS_EMPTY_RENEGOTIATION_INFO_SCSV SCSV nor the
      "renegotiation_info" extension was included, set the
      secure_renegotiation flag to FALSE.  In this case, some servers
      may want to terminate the handshake instead of continuing; see
      <a href="#section-4.3">Section 4.3</a> for discussion.

   o  If the secure_renegotiation flag is set to TRUE, the server MUST
      include an empty "renegotiation_info" extension in the ServerHello
      message.

   o  When the handshake has completed, the server needs to save the
      client_verify_data and server_verify_data values for future use.

   TLS servers implementing this specification MUST ignore any unknown
   extensions offered by the client and they MUST accept version numbers
   higher than their highest version number and negotiate the highest
   common version.  These two requirements reiterate preexisting
   requirements in <a href="rfc5246.html">RFC 5246</a> and are merely stated here in the interest
   of forward compatibility.

   Note that sending a "renegotiation_info" extension in response to a
   ClientHello containing only the SCSV is an explicit exception to the
   prohibition in <a href="rfc5246.html#section-7.4.1.4">RFC 5246, Section 7.4.1.4</a>, on the server sending
   unsolicited extensions and is only allowed because the client is
   signaling its willingness to receive the extension via the
   TLS_EMPTY_RENEGOTIATION_INFO_SCSV SCSV.  TLS implementations MUST
   continue to comply with <a href="#section-7.4.1.4">Section 7.4.1.4</a> for all other extensions.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.7.%20%20Server%20Behavior%3A%20Secure%20Renegotiation"></a><a class="selflink" href="#section-3.7" name="section-3.7">3.7</a>.  Server Behavior: Secure Renegotiation</span>

   This text applies if the connection's "secure_renegotiation" flag is
   set to TRUE (if it is set to FALSE, see <a href="#section-4.4">Section 4.4</a>).

   o  When a ClientHello is received, the server MUST verify that it
      does not contain the TLS_EMPTY_RENEGOTIATION_INFO_SCSV SCSV.  If
      the SCSV is present, the server MUST abort the handshake.

   o  The server MUST verify that the "renegotiation_info" extension is
      present; if it is not, the server MUST abort the handshake.






<span class="grey">Rescorla, et al.             Standards Track                    [Page 8]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-9" id="page-9" name="page-9"> </a>
<span class="grey"><a href="rfc5746.html">RFC 5746</a>               TLS Renegotiation Extension         February 2010</span>


   o  The server MUST verify that the value of the
      "renegotiated_connection" field is equal to the saved
      client_verify_data value; if it is not, the server MUST abort the
      handshake.

   o  The server MUST include a "renegotiation_info" extension
      containing the saved client_verify_data and server_verify_data in
      the ServerHello.

   o  When the handshake has completed, the server needs to save the new
      client_verify_data and server_verify_data values.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/4.%20%20Backward%20Compatibility"></a><a class="selflink" href="#section-4" name="section-4">4</a>.  Backward Compatibility</span>

   Existing implementations that do not support this extension are
   widely deployed and, in general, must interoperate with newer
   implementations that do support it.  This section describes
   considerations for backward compatible interoperation.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.1.%20%20Client%20Considerations"></a><a class="selflink" href="#section-4.1" name="section-4.1">4.1</a>.  Client Considerations</span>

   If a client offers the "renegotiation_info" extension or the
   TLS_EMPTY_RENEGOTIATION_INFO_SCSV SCSV and the server does not reply
   with "renegotiation_info" in the ServerHello, then this indicates
   that the server does not support secure renegotiation.  Because some
   attacks (see <a href="#section-1">Section 1</a>) look like a single handshake to the client,
   the client cannot determine whether or not the connection is under
   attack.  Note, however, that merely because the server does not
   acknowledge the extension does not mean that it is vulnerable; it
   might choose to reject all renegotiations and simply not signal it.
   However, it is not possible for the client to determine purely via
   TLS mechanisms whether or not this is the case.

   If clients wish to ensure that such attacks are impossible, they need
   to terminate the connection immediately upon failure to receive the
   extension without completing the handshake.  Such clients MUST
   generate a fatal "handshake_failure" alert prior to terminating the
   connection.  However, it is expected that many TLS servers that do
   not support renegotiation (and thus are not vulnerable) will not
   support this extension either, so in general, clients that implement
   this behavior will encounter interoperability problems.  There is no
   set of client behaviors that will guarantee security and achieve
   maximum interoperability during the transition period.  Clients need
   to choose one or the other preference when dealing with potentially
   un-upgraded servers.






<span class="grey">Rescorla, et al.             Standards Track                    [Page 9]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-10" id="page-10" name="page-10"> </a>
<span class="grey"><a href="rfc5746.html">RFC 5746</a>               TLS Renegotiation Extension         February 2010</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.2.%20%20Client%20Behavior%3A%20Legacy%20%28Insecure%29%20Renegotiation"></a><a class="selflink" href="#section-4.2" name="section-4.2">4.2</a>.  Client Behavior: Legacy (Insecure) Renegotiation</span>

   This text applies if the connection's "secure_renegotiation" flag is
   set to FALSE.

   It is possible that un-upgraded servers will request that the client
   renegotiate.  It is RECOMMENDED that clients refuse this
   renegotiation request.  Clients that do so MUST respond to such
   requests with a "no_renegotiation" alert (<a href="rfc5246.html">RFC 5246</a> requires this
   alert to be at the "warning" level).  It is possible that the
   apparently un-upgraded server is in fact an attacker who is then
   allowing the client to renegotiate with a different, legitimate,
   upgraded server.  If clients nevertheless choose to renegotiate, they
   MUST behave as described below.

   Clients that choose to renegotiate MUST provide either the
   TLS_EMPTY_RENEGOTIATION_INFO_SCSV SCSV or "renegotiation_info" in
   their ClientHello.  In a legitimate renegotiation with an un-upgraded
   server, that server should ignore both of these signals.  However, if
   the server (incorrectly) fails to ignore extensions, sending the
   "renegotiation_info" extension may cause a handshake failure.  Thus,
   it is permitted, though NOT RECOMMENDED, for the client to simply
   send the SCSV.  This is the only situation in which clients are
   permitted to not send the "renegotiation_info" extension in a
   ClientHello that is used for renegotiation.

   Note that in the case of a downgrade attack, if this is an initial
   handshake from the server's perspective, then use of the SCSV from
   the client precludes detection of this attack by the server (if this
   is a renegotiation from the server's perspective, then it will detect
   the attack).  However, the attack will be detected by the client when
   the server sends an empty "renegotiation_info" extension and the
   client is expecting one containing the previous verify_data.  By
   contrast, if the client sends the "renegotiation_info" extension,
   then the server will immediately detect the attack.

   When the ServerHello is received, the client MUST verify that it does
   not contain the "renegotiation_info" extension.  If it does, the
   client MUST abort the handshake.  (Because the server has already
   indicated it does not support secure renegotiation, the only way that
   this can happen is if the server is broken or there is an attack.)

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.3.%20%20Server%20Considerations"></a><a class="selflink" href="#section-4.3" name="section-4.3">4.3</a>.  Server Considerations</span>

   If the client does not offer the "renegotiation_info" extension or
   the TLS_EMPTY_RENEGOTIATION_INFO_SCSV SCSV, then this indicates that
   the client does not support secure renegotiation.  Although the
   attack described in <a href="#section-1">Section 1</a> looks like two handshakes to the



<span class="grey">Rescorla, et al.             Standards Track                   [Page 10]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-11" id="page-11" name="page-11"> </a>
<span class="grey"><a href="rfc5746.html">RFC 5746</a>               TLS Renegotiation Extension         February 2010</span>


   server, other attacks may be possible in which the renegotiation is
   seen only by the client.  If servers wish to ensure that such attacks
   are impossible, they need to terminate the connection immediately
   upon failure to negotiate the use of secure renegotiation.  Servers
   that do choose to allow connections from unpatched clients can still
   prevent the attack described in <a href="#section-1">Section 1</a> by refusing to renegotiate
   over those connections.

   In order to enable clients to probe, even servers that do not support
   renegotiation MUST implement the minimal version of the extension
   described in this document for initial handshakes, thus signaling
   that they have been upgraded.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.4.%20%20Server%20Behavior%3A%20Legacy%20%28Insecure%29%20Renegotiation"></a><a class="selflink" href="#section-4.4" name="section-4.4">4.4</a>.  Server Behavior: Legacy (Insecure) Renegotiation</span>

   This text applies if the connection's "secure_renegotiation" flag is
   set to FALSE.

   It is RECOMMENDED that servers not permit legacy renegotiation.  If
   servers nevertheless do permit it, they MUST follow the requirements
   in this section.

   o  When a ClientHello is received, the server MUST verify that it
      does not contain the TLS_EMPTY_RENEGOTIATION_INFO_SCSV SCSV.  If
      the SCSV is present, the server MUST abort the handshake.

   o  The server MUST verify that the "renegotiation_info" extension is
      not present; if it is, the server MUST abort the handshake.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.5.%20%20SSLv3"></a><a class="selflink" href="#section-4.5" name="section-4.5">4.5</a>.  SSLv3</span>

   While SSLv3 is not a protocol under IETF change control (see
   [<a href="#ref-SSLv3" title='"The SSL Protocol Version 3.0"'>SSLv3</a>]), it was the original basis for TLS and most TLS
   implementations also support SSLv3.  The IETF encourages SSLv3
   implementations to adopt the "renegotiation_info" extension and SCSV
   as defined in this document.  The semantics of the SCSV and extension
   are identical to TLS stacks except for the size of the verify_data
   values, which are 36 bytes long each.  Note that this will require
   adding at least minimal extension processing to such stacks.  Clients
   that support SSLv3 and offer secure renegotiation (either via SCSV or
   "renegotiation_info") MUST accept the "renegotiation_info" extension
   from the server, even if the server version is {0x03, 0x00}, and
   behave as described in this specification.  TLS servers that support
   secure renegotiation and support SSLv3 MUST accept SCSV or the
   "renegotiation_info" extension and respond as described in this
   specification even if the offered client version is {0x03, 0x00}.
   SSLv3 does not define the "no_renegotiation" alert (and does




<span class="grey">Rescorla, et al.             Standards Track                   [Page 11]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-12" id="page-12" name="page-12"> </a>
<span class="grey"><a href="rfc5746.html">RFC 5746</a>               TLS Renegotiation Extension         February 2010</span>


   not offer a way to indicate a refusal to renegotiate at a "warning"
   level).  SSLv3 clients that refuse renegotiation SHOULD use a fatal
   handshake_failure alert.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/5.%20%20Security%20Considerations"></a><a class="selflink" href="#section-5" name="section-5">5</a>.  Security Considerations</span>

   The extension described in this document prevents an attack on TLS.
   If this extension is not used, TLS renegotiation is subject to an
   attack in which the attacker can inject their own conversation with
   the TLS server as a prefix to the client's conversation.  This attack
   is invisible to the client and looks like an ordinary renegotiation
   to the server.  The extension defined in this document allows
   renegotiation to be performed safely.  Servers SHOULD NOT allow
   clients to renegotiate without using this extension.  Many servers
   can mitigate this attack simply by refusing to renegotiate at all.

   While this extension mitigates the man-in-the-middle attack described
   in the overview, it does not resolve all possible problems an
   application may face if it is unaware of renegotiation.  For example,
   during renegotiation, either the client or the server can present a
   different certificate than was used earlier.  This may come as a
   surprise to application developers (who might have expected, for
   example, that a "getPeerCertificates()" API call returns the same
   value if called twice), and might be handled in an insecure way.

   TLS implementations SHOULD provide a mechanism to disable and enable
   renegotiation.

   TLS implementers are encouraged to clearly document how renegotiation
   interacts with the APIs offered to applications (for example, which
   API calls might return different values on different calls, or which
   callbacks might get called multiple times).

   To make life simpler for applications that use renegotiation but do
   not expect the certificate to change once it has been authenticated,
   TLS implementations may also wish to offer the applications the
   option to abort the renegotiation if the peer tries to authenticate
   with a different certificate and/or different server name (in the
   server_name extension) than was used earlier.  TLS implementations
   may alternatively offer the option to disable renegotiation once the
   client certificate has been authenticated.  However, enabling these
   options by default for all applications could break existing
   applications that depend on using renegotiation to change from one
   certificate to another.  (For example, long-lived TLS connections
   could change to a renewed certificate; or renegotiation could select
   a different cipher suite that requires using a different
   certificate.)




<span class="grey">Rescorla, et al.             Standards Track                   [Page 12]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-13" id="page-13" name="page-13"> </a>
<span class="grey"><a href="rfc5746.html">RFC 5746</a>               TLS Renegotiation Extension         February 2010</span>


   Finally, designers of applications that depend on renegotiation are
   reminded that many TLS APIs represent application data as a simple
   octet stream; applications may not be able to determine exactly which
   application data octets were received before, during, or after
   renegotiation.  Especially if the peer presents a different
   certificate during renegotiation, care is needed when specifying how
   the application should handle the data.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/6.%20%20IANA%20Considerations"></a><a class="selflink" href="#section-6" name="section-6">6</a>.  IANA Considerations</span>

   IANA has added the extension code point 65281 (0xff01), which has
   been used for prototype implementations, for the "renegotiation_info"
   extension to the TLS ExtensionType values registry.

   IANA has added TLS cipher suite number 0x00,0xFF with name
   TLS_EMPTY_RENEGOTIATION_INFO_SCSV to the TLS Cipher Suite registry.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/7.%20%20Acknowledgements"></a><a class="selflink" href="#section-7" name="section-7">7</a>.  Acknowledgements</span>

   This vulnerability was originally discovered by Marsh Ray and
   independently rediscovered by Martin Rex.  The general concept behind
   the extension described here was independently invented by Steve
   Dispensa, Nasko Oskov, and Eric Rescorla with refinements from Nelson
   Bolyard, Pasi Eronen, Michael D'Errico, Stephen Farrell, Michael
   Gray, David-Sarah Hopwood, Ben Laurie, David Makepeace, Bodo Moeller,
   Martin Rex, Peter Robinson, Jesse Walker, Nico Williams, and other
   members of the Project Mogul team and the TLS WG.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/8.%20%20References"></a><a class="selflink" href="#section-8" name="section-8">8</a>.  References</span>

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/8.1.%20%20Normative%20References"></a><a class="selflink" href="#section-8.1" name="section-8.1">8.1</a>.  Normative References</span>

   [<a id="ref-RFC2119" name="ref-RFC2119">RFC2119</a>]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", <a href="https://tools.ietf.org/html/bcp14">BCP 14</a>, <a href="rfc2119.html">RFC 2119</a>, March 1997.

   [<a id="ref-RFC5246" name="ref-RFC5246">RFC5246</a>]  Dierks, T. and E. Rescorla, "The Transport Layer Security
              (TLS) Protocol Version 1.2", <a href="rfc5246.html">RFC 5246</a>, August 2008.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/8.2.%20%20Informative%20References"></a><a class="selflink" href="#section-8.2" name="section-8.2">8.2</a>.  Informative References</span>

   [<a id="ref-RFC4347" name="ref-RFC4347">RFC4347</a>]  Rescorla, E. and N. Modadugu, "Datagram Transport Layer
              Security", <a href="rfc4347.html">RFC 4347</a>, April 2006.

   [<a id="ref-RFC5056" name="ref-RFC5056">RFC5056</a>]  Williams, N., "On the Use of Channel Bindings to Secure
              Channels", <a href="rfc5056.html">RFC 5056</a>, November 2007.






<span class="grey">Rescorla, et al.             Standards Track                   [Page 13]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-14" id="page-14" name="page-14"> </a>
<span class="grey"><a href="rfc5746.html">RFC 5746</a>               TLS Renegotiation Extension         February 2010</span>


   [<a id="ref-TLS-CHANNEL-BINDINGS" name="ref-TLS-CHANNEL-BINDINGS">TLS-CHANNEL-BINDINGS</a>]
              Altman, J., Williams, N., and L. Zhu, "Channel Bindings
              for TLS", Work in Progress, October 2009.

   [<a id="ref-RFC2818" name="ref-RFC2818">RFC2818</a>]  Rescorla, E., "HTTP Over TLS", <a href="rfc2818.html">RFC 2818</a>, May 2000.

   [<a id="ref-RFC2965" name="ref-RFC2965">RFC2965</a>]  Kristol, D. and L. Montulli, "HTTP State Management
              Mechanism", <a href="rfc2965.html">RFC 2965</a>, October 2000.

   [<a id="ref-Ray09" name="ref-Ray09">Ray09</a>]    Ray, M., "Authentication Gap in TLS Renegotiation",
              November 2009, &lt;<a href="http://extendedsubset.com/?p=8">http://extendedsubset.com/?p=8</a>&gt;.

   [<a id="ref-SSLv3" name="ref-SSLv3">SSLv3</a>]    Freier, A., Karlton, P., and P. Kocher, "The SSL Protocol
              Version 3.0", Work in Progress, November 1996.





































<span class="grey">Rescorla, et al.             Standards Track                   [Page 14]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-15" id="page-15" name="page-15"> </a>
<span class="grey"><a href="rfc5746.html">RFC 5746</a>               TLS Renegotiation Extension         February 2010</span>


Authors' Addresses

   Eric Rescorla
   RTFM, Inc.
   2064 Edgewood Drive
   Palo Alto, CA  94303
   USA

   EMail:  ekr@rtfm.com


   Marsh Ray
   PhoneFactor
   7301 W 129th Street
   Overland Park, KS  66213
   USA

   EMail:  marsh@extendedsubset.com


   Steve Dispensa
   PhoneFactor
   7301 W 129th Street
   Overland Park, KS  66213
   USA

   EMail:  dispensa@phonefactor.com


   Nasko Oskov
   Microsoft
   One Microsoft Way
   Redmond, WA  98052
   USA

   EMail:  nasko.oskov@microsoft.com















Rescorla, et al.             Standards Track                   [Page 15]

</pre><br/>
    <span class="noprint"><small><small>Html markup produced by rfcmarkup 1.126, available from
      <a href="https://tools.ietf.org/tools/rfcmarkup/">https://tools.ietf.org/tools/rfcmarkup/</a>
    </small></small></span>
  </div>




</body><!-- Mirrored from tools.ietf.org/html/rfc5746 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 06 Mar 2018 23:18:33 GMT --></html>