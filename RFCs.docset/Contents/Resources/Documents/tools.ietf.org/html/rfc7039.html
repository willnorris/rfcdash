<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml"><!-- Mirrored from tools.ietf.org/html/rfc7039 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 06 Mar 2018 23:18:25 GMT --><!-- Added by HTTrack --><head><meta content="text/html;charset=utf-8" http-equiv="content-type"/><!-- /Added by HTTrack -->

    <meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
    <meta content="index,follow" name="robots"/>
    <meta content="rfcmarkup version 1.126" name="creator"/>
    <link href="http://purl.org/dc/elements/1.1/" rel="schema.DC"/>
<meta content="draft-vogt-savi-framework" name="DC.Relation.Replaces"/>
<meta content="urn:ietf:rfc:7039" name="DC.Identifier"/>
<meta content="October, 2013" name="DC.Date.Issued"/>
<meta content="Bi, Jun" name="DC.Creator"/>
<meta content="Wu, Jianping" name="DC.Creator"/>
<meta content="Bagnulo, Marcelo" name="DC.Creator"/>
<meta content="Vogt, Christian" name="DC.Creator"/>
<meta content="Baker, Fred" name="DC.Creator"/>
<meta content="Source Address Validation Improvement (SAVI) methods were developed to
prevent nodes attached to the same IP link from spoofing each
other's IP addresses, so as to complement ingress filtering with
finer-grained, standardized IP source address validation. This
document is a framework document that describes and motivates the
design of the SAVI methods. Particular SAVI methods are described in
other documents." name="DC.Description.Abstract"/>
<meta content="Source Address Validation Improvement (SAVI) Framework" name="DC.Title"/>

    <link href="https://tools.ietf.org/images/rfc.png" rel="icon" type="image/png"/>
    <link href="https://tools.ietf.org/images/rfc.png" rel="shortcut icon" type="image/png"/>
    <title>RFC 7039 - Source Address Validation Improvement (SAVI) Framework</title>
    
    
    <style type="text/css">
	@media only screen 
	  and (min-width: 992px)
	  and (max-width: 1199px) {
	    body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 768px)
	  and (max-width: 991px) {
            body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 480px)
	  and (max-width: 767px) {
            body { font-size: 11pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (max-width: 479px) {
            body { font-size: 8pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-device-width : 375px) 
	  and (max-device-width : 667px) {
            body { font-size: 9.5pt; }
            div.content { width: 96ex; margin: 0 1px; }
        }
	@media only screen 
	  and (min-device-width: 1200px) {
            body { font-size: 10pt; margin: 0 4em; }
            div.content { width: 96ex; margin: 0; }
        }
        h1, h2, h3, h4, h5, h6, .h1, .h2, .h3, .h4, .h5, .h6 {
	    font-weight: bold;
            line-height: 0pt;
            display: inline;
            white-space: pre;
            font-family: monospace;
            font-size: 1em;
	    font-weight: bold;
        }
        pre {
            font-size: 1em;
            margin-top: 0px;
            margin-bottom: 0px;
        }
	.pre {
	    white-space: pre;
	    font-family: monospace;
	}
	.header{
	    font-weight: bold;
	}
        .newpage {
            page-break-before: always;
        }
        .invisible {
            text-decoration: none;
            color: white;
        }
        a.selflink {
          color: black;
          text-decoration: none;
        }
        @media print {
            body {
                font-family: monospace;
                font-size: 10.5pt;
            }
            h1, h2, h3, h4, h5, h6 {
                font-size: 1em;
            }
        
            a:link, a:visited {
                color: inherit;
                text-decoration: none;
            }
            .noprint {
                display: none;
            }
        }
	@media screen {
	    .grey, .grey a:link, .grey a:visited {
		color: #777;
	    }
            .docinfo {
                background-color: #EEE;
            }
            .top {
                border-top: 7px solid #EEE;
            }
            .bgwhite  { background-color: white; }
            .bgred    { background-color: #F44; }
            .bggrey   { background-color: #666; }
            .bgbrown  { background-color: #840; }            
            .bgorange { background-color: #FA0; }
            .bgyellow { background-color: #EE0; }
            .bgmagenta{ background-color: #F4F; }
            .bgblue   { background-color: #66F; }
            .bgcyan   { background-color: #4DD; }
            .bggreen  { background-color: #4F4; }

            .legend   { font-size: 90%; }
            .cplate   { font-size: 70%; border: solid grey 1px; }
	}
    </style>
    <!--[if IE]>
    <style>
    body {
       font-size: 13px;
       margin: 10px 10px;
    }
    </style>
    <![endif]-->

    <script type="text/javascript"><!--
    function addHeaderTags() {
	var spans = document.getElementsByTagName("span");
	for (var i=0; i < spans.length; i++) {
	    var elem = spans[i];
	    if (elem) {
		var level = elem.getAttribute("class");
                if (level == "h1" || level == "h2" || level == "h3" || level == "h4" || level == "h5" || level == "h6") {
                    elem.innerHTML = "<"+level+">"+elem.innerHTML+"</"+level+">";		
                }
	    }
	}
    }
    var legend_html = "Colour legend:<br />      <table>         <tr><td>Unknown:</td>                   <td><span class='cplate bgwhite'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft:</td>                     <td><span class='cplate bgred'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Informational:</td>             <td><span class='cplate bgorange'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Experimental:</td>              <td><span class='cplate bgyellow'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Best Common Practice:</td>      <td><span class='cplate bgmagenta'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Proposed Standard:</td>         <td><span class='cplate bgblue'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft Standard (old designation):</td> <td><span class='cplate bgcyan'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Internet Standard:</td>         <td><span class='cplate bggreen'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Historic:</td>                  <td><span class='cplate bggrey'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Obsolete:</td>                  <td><span class='cplate bgbrown'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>     </table>";
    function showElem(id) {
        var elem = document.getElementById(id);
        elem.innerHTML = eval(id+"_html");
        elem.style.visibility='visible';
    }
    function hideElem(id) {
        var elem = document.getElementById(id);
        elem.style.visibility='hidden';        
        elem.innerHTML = "";
    }
    // -->
    </script>
</head>
<body onload="addHeaderTags()">
  <div class="content">
   <div style="height: 13px;">
      <div class="pre noprint docinfo bgorange" onclick="showElem('legend');" onmouseout="hideElem('legend')" onmouseover="this.style.cursor='pointer';" style="height: 6px; position: absolute;" title="Click for colour legend.">                                                                        </div>
      <div class="docinfo noprint pre legend" id="legend" onmouseout="hideElem('legend');" onmouseover="showElem('legend');" style="position:absolute; top: 4px; left: 4ex; visibility:hidden; background-color: white; padding: 4px 9px 5px 7px; border: solid #345 1px; ">
      </div>
   </div>
<span class="pre noprint docinfo top">[<a href="index.html" title="Document search and retrieval page">Docs</a>] [<a href="https://tools.ietf.org/rfc/rfc7039.txt" title="Plaintext version of this document">txt</a>|<a href="https://tools.ietf.org/pdf/rfc7039" title="PDF version of this document">pdf</a>] [<a href="https://tools.ietf.org/html/draft-ietf-savi-framework" title="draft-ietf-savi-framework">draft-ietf-savi...</a>] [<a href="https://datatracker.ietf.org/doc/rfc7039" title="IESG Datatracker information for this document">Tracker</a>] [<a href="https://tools.ietf.org/rfcdiff?difftype=--hwdiff&amp;url2=rfc7039" title="Inline diff (wdiff)">Diff1</a>] [<a href="https://tools.ietf.org/rfcdiff?url2=rfc7039" title="Side-by-side diff">Diff2</a>]         </span><br/>
<span class="pre noprint docinfo">                                                                        </span><br/>
<span class="pre noprint docinfo">                                                           INFORMATIONAL</span><br/>
<span class="pre noprint docinfo">                                                                        </span><br/>
<pre>Internet Engineering Task Force (IETF)                             J. Wu
Request for Comments: 7039                                         J. Bi
Category: Informational                                   Tsinghua Univ.
ISSN: 2070-1721                                               M. Bagnulo
                                                                    UC3M
                                                                F. Baker
                                                                   Cisco
                                                            C. Vogt, Ed.
                                                            October 2013


         <span class="h1">Source Address Validation Improvement (SAVI) Framework</span>

Abstract

   Source Address Validation Improvement (SAVI) methods were developed
   to prevent nodes attached to the same IP link from spoofing each
   other's IP addresses, so as to complement ingress filtering with
   finer-grained, standardized IP source address validation.  This
   document is a framework document that describes and motivates the
   design of the SAVI methods.  Particular SAVI methods are described in
   other documents.

Status of This Memo

   This document is not an Internet Standards Track specification; it is
   published for informational purposes.

   This document is a product of the Internet Engineering Task Force
   (IETF).  It represents the consensus of the IETF community.  It has
   received public review and has been approved for publication by the
   Internet Engineering Steering Group (IESG).  Not all documents
   approved by the IESG are a candidate for any level of Internet
   Standard; see <a href="rfc5741.html#section-2">Section 2 of RFC 5741</a>.

   Information about the current status of this document, any errata,
   and how to provide feedback on it may be obtained at
   <a href="http://www.rfc-editor.org/info/rfc7039">http://www.rfc-editor.org/info/rfc7039</a>.













<span class="grey">Wu, et al.                    Informational                     [Page 1]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-2" id="page-2" name="page-2"> </a>
<span class="grey"><a href="rfc7039.html">RFC 7039</a>                     SAVI Framework                 October 2013</span>


Copyright Notice

   Copyright (c) 2013 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to <a href="https://tools.ietf.org/html/bcp78">BCP 78</a> and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (<a href="http://trustee.ietf.org/license-info">http://trustee.ietf.org/license-info</a>) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.

   This document may contain material from IETF Documents or IETF
   Contributions published or made publicly available before November
   10, 2008.  The person(s) controlling the copyright in some of this
   material may not have granted the IETF Trust the right to allow
   modifications of such material outside the IETF Standards Process.
   Without obtaining an adequate license from the person(s) controlling
   the copyright in such materials, this document may not be modified
   outside the IETF Standards Process, and derivative works of it may
   not be created outside the IETF Standards Process, except to format
   it for publication as an RFC or to translate it into languages other
   than English.

Table of Contents

   <a href="#section-1">1</a>.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   <a href="#page-3">3</a>
   <a href="#section-2">2</a>.  Model . . . . . . . . . . . . . . . . . . . . . . . . . . . .   <a href="#page-4">4</a>
   <a href="#section-3">3</a>.  Deployment Options  . . . . . . . . . . . . . . . . . . . . .   <a href="#page-5">5</a>
     <a href="#section-3.1">3.1</a>.  IP Address Assignment Methods . . . . . . . . . . . . . .   <a href="#page-6">6</a>
     <a href="#section-3.2">3.2</a>.  Binding Anchors . . . . . . . . . . . . . . . . . . . . .   <a href="#page-6">6</a>
   <a href="#section-4">4</a>.  Scalability Optimizations . . . . . . . . . . . . . . . . . .   <a href="#page-7">7</a>
   <a href="#section-5">5</a>.  Reliability Optimizations . . . . . . . . . . . . . . . . . .   <a href="#page-9">9</a>
   <a href="#section-6">6</a>.  Scenario with Multiple Assignment Methods . . . . . . . . . .  <a href="#page-10">10</a>
   <a href="#section-7">7</a>.  Prefix Configuration  . . . . . . . . . . . . . . . . . . . .  <a href="#page-10">10</a>
   <a href="#section-8">8</a>.  Acknowledgments . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-11">11</a>
   <a href="#section-9">9</a>.  Security Considerations . . . . . . . . . . . . . . . . . . .  <a href="#page-11">11</a>
   <a href="#section-10">10</a>. References  . . . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-12">12</a>
     <a href="#section-10.1">10.1</a>.  Normative References . . . . . . . . . . . . . . . . . .  <a href="#page-12">12</a>
     <a href="#section-10.2">10.2</a>.  Informative References . . . . . . . . . . . . . . . . .  <a href="#page-12">12</a>








<span class="grey">Wu, et al.                    Informational                     [Page 2]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-3" id="page-3" name="page-3"> </a>
<span class="grey"><a href="rfc7039.html">RFC 7039</a>                     SAVI Framework                 October 2013</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/1.%20%20Introduction"></a><a class="selflink" href="#section-1" name="section-1">1</a>.  Introduction</span>

   Since IP source addresses are used by hosts and network entities to
   determine the origin of a packet and as a destination for return
   data, spoofing of IP source addresses can enable impersonation,
   concealment, and malicious traffic redirection.  Unfortunately, the
   Internet architecture does not prevent IP source address spoofing
   [<a href="rfc6959.html" title='"Source Address Validation Improvement (SAVI) Threat Scope"'>RFC6959</a>].  Since the IP source address of a packet generally takes
   no role in forwarding the packet, it can be selected arbitrarily by
   the sending host without jeopardizing packet delivery.  Extra methods
   are necessary for IP source address validation to augment packet
   forwarding with an explicit check of whether a given packet's IP
   source address is legitimate.

   IP source address validation can happen at different granularity.
   Ingress filtering [<a href="#ref-BCP38" title='"Network Ingress Filtering: Defeating Denial of Service Attacks which employ IP Source Address Spoofing"'>BCP38</a>] [<a href="#ref-BCP84" title='"Ingress Filtering for Multihomed Networks"'>BCP84</a>], a widely deployed standard for IP
   source address validation, functions at the coarse granularity of
   networks.  It verifies that the prefix of an IP source address routes
   to the network from which the packet was received.  An advantage of
   ingress filtering is simplicity: the decision of whether to accept or
   to reject an IP source address can be made solely based on the
   information available from routing protocols.  However, the
   simplicity comes at the cost of not being able to validate IP source
   addresses at a finer granularity, due to the aggregated nature of the
   information available from routing protocols.  Finer-grained IP
   source address validation would ensure that source address
   information is accurate, reduce the ability to launch denial-of-
   service attacks, and help with localizing hosts and identifying
   misbehaving hosts.  Partial solutions [<a href="#ref-BA2007" title='"Cisco IP Version 4 Source Guard"'>BA2007</a>] exist for finer-
   grained IP source address validation but are proprietary and hence
   often unsuitable for corporate procurement.

   The Source Address Validation Improvement (SAVI) method was developed
   to complement ingress filtering with standardized IP source address
   validation at the maximally fine granularity of individual IP
   addresses.  It prevents hosts attached to the same link from spoofing
   each other's IP addresses.  To facilitate deployment in networks of
   various kinds, the SAVI method was designed to be modular and
   extensible.  This document describes and motivates the design of the
   SAVI method.

   Note that SAVI raises a number of important privacy considerations
   that are discussed more fully in [<a href="rfc6959.html" title='"Source Address Validation Improvement (SAVI) Threat Scope"'>RFC6959</a>].  SAVI implementers must
   take those privacy considerations into account when designing
   solutions that match this framework and follow the recommendations
   given in [<a href="rfc6959.html" title='"Source Address Validation Improvement (SAVI) Threat Scope"'>RFC6959</a>].





<span class="grey">Wu, et al.                    Informational                     [Page 3]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-4" id="page-4" name="page-4"> </a>
<span class="grey"><a href="rfc7039.html">RFC 7039</a>                     SAVI Framework                 October 2013</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/2.%20%20Model"></a><a class="selflink" href="#section-2" name="section-2">2</a>.  Model</span>

   To enable network operators to deploy fine-grained IP source address
   validation without a dependency on supportive functionality on hosts,
   the SAVI method was designed to be purely network based.  A SAVI
   instance enforces the hosts' use of legitimate IP source addresses
   according to the following three-step model:

   1.  Identify which IP source addresses are legitimate for a host,
       based on monitoring packets exchanged by the host.

   2.  Bind a legitimate IP address to a link-layer property of the
       host's network attachment.  This property, called a "binding
       anchor", must be verifiable in every packet that the host sends
       and harder to spoof than the host's IP source address itself.

   3.  Enforce that the IP source addresses in packets match the binding
       anchors to which they were bound.

   This model allows SAVI functionality (a SAVI instance) to be located
   anywhere on the link to which the hosts attach, hence enabling
   different locations for a SAVI instance.  One way to locate a SAVI
   instance is in the hosts' default router.  IP source addresses are
   then validated in packets traversing the default router, yet the IP
   source addresses in packets exchanged locally on the link may bypass
   validation.  Another way to locate a SAVI instance is in a switch
   between the hosts and their default router.  Thus, packets may
   undergo IP source address validation even if exchanged locally on the
   link.

   The closer a SAVI instance is located to the host, the more effective
   the SAVI method is.  This is because each of the three steps of the
   SAVI model can best be accomplished in a position close to the host:

   o  Identifying a host's legitimate IP source addresses is most
      efficient close to the host because the likelihood that the host's
      packets bypass a SAVI instance, and hence cannot be monitored,
      increases with the topological distance between the SAVI instance
      and the host.

   o  Selecting a binding anchor for a host's IP source address is
      easiest close to the host because many link-layer properties are
      unique for a given host only on a link segment directly attached
      to the host.







<span class="grey">Wu, et al.                    Informational                     [Page 4]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-5" id="page-5" name="page-5"> </a>
<span class="grey"><a href="rfc7039.html">RFC 7039</a>                     SAVI Framework                 October 2013</span>


   o  Enforcing a host's use of a legitimate IP source address is most
      reliable when pursued close to the host because the likelihood
      that the host's packets bypass a SAVI instance, and hence do not
      undergo IP source address validation, increases with the
      topological distance between the SAVI instance and the host.

   The preferred location of SAVI instances is therefore close to hosts,
   such as in switches that directly attach to the hosts whose IP source
   addresses are being validated.

   Nevertheless, it is useful for SAVI mechanisms to be able to handle
   situations where hosts are not directly attached to the SAVI-capable
   device.  For instance, deployments with both SAVI-capable and legacy
   switches could be supported.  In general, a SAVI solution needs to
   specify how it deals with a number of deployment scenarios and
   exceptional situations, including interaction with legacy devices,
   hosts moving between wireless attachment points, network partitions,
   and so on.

   Besides, in the case of legacy switches, the security level is lower,
   as there is no full protection for the hosts connected to the legacy
   server.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/3.%20%20Deployment%20Options"></a><a class="selflink" href="#section-3" name="section-3">3</a>.  Deployment Options</span>

   The model of the SAVI method, as explained in <a href="#section-2">Section 2</a>, is
   deployment specific in two ways:

   o  The identification of legitimate IP source addresses is dependent
      on the IP address assignment method in use on a link, since it is
      through assignment that a host becomes the legitimate user of an
      IP source address.

   o  Binding anchors are dependent on the technology used to build the
      link on which they are used, as binding anchors are link-layer
      properties of a host's network attachment.

   To facilitate the deployment of the SAVI method in networks of
   various kinds, the SAVI method is designed to support different IP
   address assignment methods and to function with different binding
   anchors.  Naturally, both the IP address assignment methods in use on
   a link and the available binding anchors have an impact on the
   functioning and the strength of IP source address validation.  The
   following two subsections explain this impact and describe how the
   SAVI method accommodates this.






<span class="grey">Wu, et al.                    Informational                     [Page 5]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-6" id="page-6" name="page-6"> </a>
<span class="grey"><a href="rfc7039.html">RFC 7039</a>                     SAVI Framework                 October 2013</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.1.%20%20IP%20Address%20Assignment%20Methods"></a><a class="selflink" href="#section-3.1" name="section-3.1">3.1</a>.  IP Address Assignment Methods</span>

   Since the SAVI method traces IP address assignment packets, it
   necessarily needs to incorporate logic that is specific to particular
   IP address assignment methods.  However, developing SAVI method
   variants for each IP address assignment method is alone not
   sufficient since multiple IP address assignment methods may coexist
   on a given link.  The SAVI method hence comes in multiple variants,
   e.g., for links with DHCP [<a href="rfc2131.html" title='"Dynamic Host Configuration Protocol"'>RFC2131</a>] [<a href="rfc3315.html" title='"Dynamic Host Configuration Protocol for IPv6 (DHCPv6)"'>RFC3315</a>], Stateless Address
   Autoconfiguration (SLAAC) [<a href="rfc4862.html" title='"IPv6 Stateless Address Autoconfiguration"'>RFC4862</a>] with or without Secure Neighbor
   Discovery (SEND) [<a href="rfc3971.html" title='"SEcure Neighbor Discovery (SEND)"'>RFC3971</a>], Internet Key Exchange Protocol Version 2
   (IKEv2) [<a href="rfc5996.html" title='"Internet Key Exchange Protocol Version 2 (IKEv2)"'>RFC5996</a>] [<a href="rfc5739.html" title='"IPv6 Configuration in Internet Key Exchange Protocol Version 2 (IKEv2)"'>RFC5739</a>] [<a href="rfc5026.html" title='"Mobile IPv6 Bootstrapping in Split Scenario"'>RFC5026</a>], and combinations thereof.

   The reason to develop SAVI method variants for each single IP address
   configuration method, in addition to the variant that handles all IP
   address assignment methods, is to minimize the complexity of the
   common case.  Many link deployments today either are constrained to a
   single IP address assignment method or, equivalently from the
   perspective of the SAVI method, use different IP address assignment
   methods within different IP address prefixes.  The SAVI method for
   such links can be simpler than the SAVI method for links with
   multiple IP address assignment methods per IP address prefix.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.2.%20%20Binding%20Anchors"></a><a class="selflink" href="#section-3.2" name="section-3.2">3.2</a>.  Binding Anchors</span>

   The SAVI method supports a range of binding anchors:

   o  The IEEE extended unique identifier, EUI-48 or EUI-64, of a host's
      interface.

   o  The port on an Ethernet switch to which a host attaches.

   o  The security association between a host and the base station on
      wireless links.

   o  The combination of a host interface's link-layer address and a
      customer relationship in cable modem networks.

   o  An ATM virtual channel, a PPP session identifier, or a Layer 2
      Tunneling Protocol (L2TP) session identifier in a DSL network.

   o  A tunnel that connects to a single host, such as an IP-in-IP
      tunnel, a Generic Routing Encapsulation (GRE) tunnel, or an MPLS
      label-switched path.







<span class="grey">Wu, et al.                    Informational                     [Page 6]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-7" id="page-7" name="page-7"> </a>
<span class="grey"><a href="rfc7039.html">RFC 7039</a>                     SAVI Framework                 October 2013</span>


   The various binding anchors differ significantly in the security they
   provide.  IEEE extended unique identifiers, for example, fail to
   render a secure binding anchor because they can be spoofed with
   little effort.  Switch ports alone may be insufficient because they
   may connect to more than a single host, such as in the case of
   concatenated switches.

   Given this diversity in the security provided, one could define a set
   of possible binding anchors and leave it up to the administrator to
   choose one or more of them.  Such a selection of binding anchors
   would, of course, have to be accompanied by an explanation of the
   pros and cons of the different binding anchors.  In addition, SAVI
   devices may have a default binding anchor depending on the lower
   layers.  Such a default could be to use switch ports when available
   and MAC addresses otherwise or to use MAC addresses and switch ports
   in addition if available.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/4.%20%20Scalability%20Optimizations"></a><a class="selflink" href="#section-4" name="section-4">4</a>.  Scalability Optimizations</span>

   The preference to locate a SAVI instance close to hosts implies that
   multiple SAVI instances must be able to coexist in order to support
   large links.  Although the model of the SAVI method is independent of
   the number of SAVI instances per link, coexistence of multiple SAVI
   instances without further measures can lead to higher-than-necessary
   memory requirements.  Since a SAVI instance creates bindings for the
   IP source addresses of all hosts on a link, bindings are replicated
   if multiple SAVI instances coexist on the link.  High memory
   requirements, in turn, increase the cost of a SAVI instance.  This is
   problematic in particular for SAVI instances that are located on a
   switch since it may significantly increase the cost of such a switch.

   To reduce memory requirements for SAVI instances that are located on
   a switch, the SAVI method enables the suppression of binding
   replication on links with multiple SAVI instances.  This requires
   manual disabling of IP source address validation on switch ports that
   connect to other switches running a SAVI instance.  Each SAVI
   instance is then responsible for validating IP source addresses only
   on those ports to which hosts attach either directly or via switches
   without a SAVI instance.  On ports towards other switches running a
   SAVI instance, IP source addresses are not validated.  The switches
   running SAVI instances thus form a "protection perimeter".  The IP
   source addresses in packets passing the protection perimeter are
   validated by the ingress SAVI instance, but no further validation
   takes place as long as the packets remain within or leave the
   protection perimeter.






<span class="grey">Wu, et al.                    Informational                     [Page 7]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-8" id="page-8" name="page-8"> </a>
<span class="grey"><a href="rfc7039.html">RFC 7039</a>                     SAVI Framework                 October 2013</span>


                                                 ..............
                       protection perimeter --&gt;  : +--------+ :
          +---+  +---+                           : |  SAVI  | :
          | A |  | B |  &lt;-- hosts                : | switch | :
          +---+  +---+                           : +--------+ :
         ...|......|.............................:        |   :
         : +--------+          +--------+          +--------+ :
         : |  SAVI  |----------| legacy |          |  SAVI  | :
         : | switch |          | switch |----------| switch | :
         : +--------+          +--------+          +--------+ :
         :   |        ...............................|........:
         : +--------+ :                            +--------+
         : |  SAVI  | :                            | legacy |
         : | switch | :                            | switch |
         : +--------+ :                            +--------+
         :............:                             |      |
                                                  +---+  +---+
                                       hosts --&gt;  | C |  | D |
                                                  +---+  +---+

                  Figure 1: Protection Perimeter Concept

   Figure 1 illustrates the concept of the protection perimeter.  The
   figure shows a link with six switches, of which four, denoted "SAVI
   switch", run a SAVI instance.  The protection perimeter created by
   the four SAVI instances is shown as a dotted line in the figure.  IP
   source address validation is enabled on all switch ports on the
   protection perimeter, and it is disabled on all other switch ports.
   Four hosts, denoted A through D in the figure, attach to the
   protection perimeter.

   In the example in Figure 1, the protection perimeter encompasses one
   of the legacy switches, located in the middle of the depicted link
   topology.  This enables a single, unpartitioned protection perimeter.
   A single protection perimeter minimizes memory requirements for the
   SAVI instances because every binding is kept only once, namely, by
   the SAVI instance that attaches to the host being validated.
   Excluding the legacy switch from the protection perimeter would
   result in two smaller protection perimeters to the left and to the
   right of the depicted link topology.  The memory requirements for the
   SAVI instances would then be higher: since IP source address
   validation would be activated on the two ports connecting to the
   legacy switch, the SAVI instances adjacent to the legacy switch would
   replicate all bindings from the other protection perimeter,
   respectively.  The reason why it is possible to include the legacy
   switch in the protection perimeter is because the depicted link
   topology guarantees that packets cannot enter the protection
   perimeter via this legacy switch.  Without this guarantee, the legacy



<span class="grey">Wu, et al.                    Informational                     [Page 8]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-9" id="page-9" name="page-9"> </a>
<span class="grey"><a href="rfc7039.html">RFC 7039</a>                     SAVI Framework                 October 2013</span>


   switch would have to be excluded from the protection perimeter in
   order to ensure that packets entering the protection perimeter
   undergo IP source address validation.

   Note that if such configuration is used, care must be taken as any
   hosts on subnets attached to non-enforcing ports will be able to use
   spoofed source addresses.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/5.%20%20Reliability%20Optimizations"></a><a class="selflink" href="#section-5" name="section-5">5</a>.  Reliability Optimizations</span>

   The explicit storage of legitimate IP addresses in the form of
   bindings implies that failure to create a binding, or the premature
   removal of bindings, can lead to loss of legitimate packets.  There
   are three situations in which this can happen:

   o  Legitimate IP address configuration packets, which should trigger
      the creation of a binding in a SAVI instance, are lost before
      reaching the SAVI instance.

   o  A SAVI instance loses a binding, for example, due to a restart.

   o  The link topology changes, resulting in hosts to communicate
      through SAVI instances that do not have a binding for those hosts'
      IP addresses.

   To limit the disruption that missing bindings for legitimate IP
   addresses can have, the SAVI method includes a mechanism for reactive
   binding creation based on regular packets.  This mechanism
   supplements the proactive binding creation based on IP address
   configuration packets.  Reactive binding creation occurs when a SAVI
   instance recognizes excessive drops of regular packets originating
   from the same IP address.  The SAVI instance then verifies whether
   said IP address is unique on the link.  How the verification is
   carried out depends on the IP address configuration method that the
   SAVI instance supports.  The SAVI method variant for Stateless
   Address Autoconfiguration and for Secure Neighbor Discovery verifies
   an IP address through the Duplicate Address Detection procedure.  The
   SAVI method variant for DHCP verifies an IP address through a DHCP
   Lease Query message exchange with the DHCP server.  If verification
   indicates that the IP address is unique on the link, the SAVI
   instance creates a binding for the IP address.  Otherwise, no binding
   is created, and packets sent from the IP address continue to be
   dropped.  These reliability issues should be addressed in all the
   SAVI protocols describing particular SAVI methods.







<span class="grey">Wu, et al.                    Informational                     [Page 9]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-10" id="page-10" name="page-10"> </a>
<span class="grey"><a href="rfc7039.html">RFC 7039</a>                     SAVI Framework                 October 2013</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/6.%20%20Scenario%20with%20Multiple%20Assignment%20Methods"></a><a class="selflink" href="#section-6" name="section-6">6</a>.  Scenario with Multiple Assignment Methods</span>

   While multiple assignment methods can be used on the same link, the
   SAVI device may have to deal with a mix of binding discovery methods.
   If the address prefix used for each assignment method is different,
   the "mix scenario" behaves the same as with the scenario with only
   one assignment method.  If different address assignment methods are
   used to assign addresses from the same prefix, additional
   considerations are needed because one binding mechanism may create a
   binding violating an existing binding from another binding mechanism,
   e.g., binding from First-Come, First-Served (FCFS) SAVI [<a href="rfc6620.html" title='"FCFS SAVI: First-Come, First-Served Source Address Validation Improvement for Locally Assigned IPv6 Addresses"'>RFC6620</a>] may
   violate a binding from SAVI-DHCP [<a href="#ref-SAVI-DHCP" title='"SAVI Solution for DHCP"'>SAVI-DHCP</a>].  Thus, the collision
   between different SAVI mechanisms in the mix scenario must be handled
   in case more than one address assignment method is used to assign
   addresses from the same prefix.

   The prioritization of relationships between different address
   assignment methods is used as the basis to solve possible collisions.
   Current standard documents of address assignment methods (DHCP
   [<a href="rfc2131.html" title='"Dynamic Host Configuration Protocol"'>RFC2131</a>], DHCPv6 [<a href="rfc3315.html" title='"Dynamic Host Configuration Protocol for IPv6 (DHCPv6)"'>RFC3315</a>], SLAAC [<a href="rfc4862.html" title='"IPv6 Stateless Address Autoconfiguration"'>RFC4862</a>], and SEND [<a href="rfc3971.html" title='"SEcure Neighbor Discovery (SEND)"'>RFC3971</a>])
   have implied the prioritization relationship in general cases.
   However, in some scenarios, the default prioritization level may not
   be quite suitable.  A configurable prioritization level should be
   supported in the SAVI solution for the mix scenario [<a href="#ref-SAVI-MIX" title='"SAVI for Mixed Address Assignment Methods Scenario"'>SAVI-MIX</a>].

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/7.%20%20Prefix%20Configuration"></a><a class="selflink" href="#section-7" name="section-7">7</a>.  Prefix Configuration</span>

   Before setting up a host-level granularity binding, it is important
   to configure correct prefixes on the SAVI device.  This document
   suggests a set of 3 prefix configuration mechanisms at a SAVI device:

   o  Manual Prefix Configuration: The allowed prefix scope of IPv4
      addresses, IPv6 static addresses, IPv6 addresses assigned by
      Stateless Address Autoconfiguration (SLAAC), and IPv6 addresses
      assigned by DHCPv6 can be set manually at the SAVI device.
      FE80::/64 is always a feasible prefix in IPv6.

   o  Prefix Configuration by Router Advertisement (RA) Snooping: The
      allowed prefix scope of IPv6 static addresses and IPv6 addresses
      assigned by SLAAC can be set at the SAVI device through snooping
      an RA message at the SAVI device.

   o  Prefix Configuration by DHCP Prefix Delegation (DHCP-PD) Snooping:
      The allowed prefix scope of IPv6 static addresses, IPv6 addresses
      assigned by SLAAC, and IPv6 addresses assigned by DHCPv6 can be
      set through snooping a DHCP-PD message at the SAVI device.





<span class="grey">Wu, et al.                    Informational                    [Page 10]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-11" id="page-11" name="page-11"> </a>
<span class="grey"><a href="rfc7039.html">RFC 7039</a>                     SAVI Framework                 October 2013</span>


   If some of the prefix scopes are set to have no prefix, the
   implication is that the corresponding address assignment method is
   not allowed in the network.

   There is no need to explicitly present these prefix scopes, but these
   restrictions should be used as the premier check in binding setup.

   When SAVI is partially deployed, binding may fail as RA messages and
   DHCP-PD can be spoofed.  So, it is recommended that Manual Prefix
   Configuration be used unless SAVI gets fully deployed.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/8.%20%20Acknowledgments"></a><a class="selflink" href="#section-8" name="section-8">8</a>.  Acknowledgments</span>

   The authors would like to thank the SAVI working group for a thorough
   technical discussion on the design and the framework of the SAVI
   method as captured in this document, in particular Erik Nordmark,
   Guang Yao, Eric Levy-Abegnoli, and Alberto Garcia.  Thanks also to
   Torben Melsen for reviewing this document.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/9.%20%20Security%20Considerations"></a><a class="selflink" href="#section-9" name="section-9">9</a>.  Security Considerations</span>

   This document only discusses the possible methods to mitigate the
   usage of forged IP addresses.  Some such methods may rely on
   cryptographic methods, but not all do.  As a result, it is generally
   not possible to prove address ownership in any strong sense.  If a
   binding anchor is not exclusive for each IP address, or is without
   strong security, addresses can still be forged.  Besides, the binding
   may not accord with the address management requirement, which can be
   more specified for each client.  However, given no new protocol is
   introduced, the improvements are still acceptable.  If strong
   security is required when using IP addresses, then cryptographic-
   based authentication must be used as it is the only way to provide
   strong security.

   <a href="#section-2">Section 2</a> explains how the preferred location of SAVI instances is
   close to hosts.  However, in some cases, this makes the SAVI
   instances themselves vulnerable and may defeat the purpose of
   deploying a SAVI solution.  For instance, deployments should not
   place SAVI functionality in devices that are physically exposed.
   Even if the device correctly monitors the source address usage of
   hosts, an attacker could replace the device with one that does not
   check or hook up to a trusted interface from the device to the rest
   of the network.  Similarly, deployments where SAVI instances are
   distributed across administrative boundaries are not recommended.
   For instance, in most cases, it would be undesirable to deploy a
   distributed SAVI solution on both sides of a customer-provider
   interface if the solution required trusting the correct operation of
   the SAVI devices on the other side of the interface.



<span class="grey">Wu, et al.                    Informational                    [Page 11]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-12" id="page-12" name="page-12"> </a>
<span class="grey"><a href="rfc7039.html">RFC 7039</a>                     SAVI Framework                 October 2013</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/10.%20%20References"></a><a class="selflink" href="#section-10" name="section-10">10</a>.  References</span>

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/10.1.%20%20Normative%20References"></a><a class="selflink" href="#section-10.1" name="section-10.1">10.1</a>.  Normative References</span>

   [<a id="ref-RFC2131" name="ref-RFC2131">RFC2131</a>]   Droms, R., "Dynamic Host Configuration Protocol", <a href="rfc2131.html">RFC</a>
               <a href="rfc2131.html">2131</a>, March 1997.

   [<a id="ref-RFC3315" name="ref-RFC3315">RFC3315</a>]   Droms, R., Bound, J., Volz, B., Lemon, T., Perkins, C.,
               and M. Carney, "Dynamic Host Configuration Protocol for
               IPv6 (DHCPv6)", <a href="rfc3315.html">RFC 3315</a>, July 2003.

   [<a id="ref-RFC3971" name="ref-RFC3971">RFC3971</a>]   Arkko, J., Kempf, J., Zill, B., and P. Nikander, "SEcure
               Neighbor Discovery (SEND)", <a href="rfc3971.html">RFC 3971</a>, March 2005.

   [<a id="ref-RFC4862" name="ref-RFC4862">RFC4862</a>]   Thomson, S., Narten, T., and T. Jinmei, "IPv6 Stateless
               Address Autoconfiguration", <a href="rfc4862.html">RFC 4862</a>, September 2007.

   [<a id="ref-RFC5026" name="ref-RFC5026">RFC5026</a>]   Giaretta, G., Kempf, J., and V. Devarapalli, "Mobile IPv6
               Bootstrapping in Split Scenario", <a href="rfc5026.html">RFC 5026</a>, October 2007.

   [<a id="ref-RFC5739" name="ref-RFC5739">RFC5739</a>]   Eronen, P., Laganier, J., and C. Madson, "IPv6
               Configuration in Internet Key Exchange Protocol Version 2
               (IKEv2)", <a href="rfc5739.html">RFC 5739</a>, February 2010.

   [<a id="ref-RFC5996" name="ref-RFC5996">RFC5996</a>]   Kaufman, C., Hoffman, P., Nir, Y., and P. Eronen,
               "Internet Key Exchange Protocol Version 2 (IKEv2)", <a href="rfc5996.html">RFC</a>
               <a href="rfc5996.html">5996</a>, September 2010.

   [<a id="ref-RFC6620" name="ref-RFC6620">RFC6620</a>]   Nordmark, E., Bagnulo, M., and E. Levy-Abegnoli, "FCFS
               SAVI: First-Come, First-Served Source Address Validation
               Improvement for Locally Assigned IPv6 Addresses", <a href="rfc6620.html">RFC</a>
               <a href="rfc6620.html">6620</a>, May 2012.

   [<a id="ref-RFC6959" name="ref-RFC6959">RFC6959</a>]   McPherson, D., Baker, F., and J. Halpern, "Source Address
               Validation Improvement (SAVI) Threat Scope", <a href="rfc6959.html">RFC 6959</a>,
               May 2013.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/10.2.%20%20Informative%20References"></a><a class="selflink" href="#section-10.2" name="section-10.2">10.2</a>.  Informative References</span>

   [<a id="ref-BA2007" name="ref-BA2007">BA2007</a>]    Baker, F., <a href="https://www.google.com/search?sitesearch=tools.ietf.org%2Fhtml%2F&amp;q=inurl:draft-+%22Cisco+IP+Version+4+Source+Guard%22" style="text-decoration: none">"Cisco IP Version 4 Source Guard"</a>, Work in
               Progress, November 2007.

   [<a id="ref-BCP38" name="ref-BCP38">BCP38</a>]     Ferguson, P. and D. Senie, "Network Ingress Filtering:
               Defeating Denial of Service Attacks which employ IP
               Source Address Spoofing", <a href="https://tools.ietf.org/html/bcp38">BCP 38</a>, <a href="rfc2827.html">RFC 2827</a>, May 2000.

   [<a id="ref-BCP84" name="ref-BCP84">BCP84</a>]     Baker, F. and P. Savola, "Ingress Filtering for
               Multihomed Networks", <a href="https://tools.ietf.org/html/bcp84">BCP 84</a>, <a href="rfc3704.html">RFC 3704</a>, March 2004.



<span class="grey">Wu, et al.                    Informational                    [Page 12]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-13" id="page-13" name="page-13"> </a>
<span class="grey"><a href="rfc7039.html">RFC 7039</a>                     SAVI Framework                 October 2013</span>


   [<a id="ref-SAVI-DHCP" name="ref-SAVI-DHCP">SAVI-DHCP</a>] Bi, J., Wu, J., Yao, G., and F. Baker, "SAVI Solution for
   DHCP", Work in Progress, June 2013.

   [<a id="ref-SAVI-MIX" name="ref-SAVI-MIX">SAVI-MIX</a>]  Bi, J., Yao, G., Halpern, J., and E. Levy-Abegnoli, "SAVI
   for Mixed Address Assignment Methods Scenario", Work in Progress, May
   2013.













































<span class="grey">Wu, et al.                    Informational                    [Page 13]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-14" id="page-14" name="page-14"> </a>
<span class="grey"><a href="rfc7039.html">RFC 7039</a>                     SAVI Framework                 October 2013</span>


Authors' Addresses

   Jianping Wu
   Tsinghua University
   Computer Science, Tsinghua University
   Beijing  100084
   China

   EMail: jianping@cernet.edu.cn


   Jun Bi
   Tsinghua University
   Network Research Center, Tsinghua University
   Beijing  100084
   China

   EMail: junbi@tsinghua.edu.cn


   Marcelo Bagnulo
   Universidad Carlos III de Madrid
   Avenida de la Universidad 30
   Leganes, Madrid  28911
   Spain

   EMail: marcelo@it.uc3m.es


   Fred Baker
   Cisco Systems
   Santa Barbara, CA  93117
   United States

   EMail: fred@cisco.com


   Christian Vogt (editor)
   3507 Palmilla Drive
   San Jose, CA  95134
   United States

   EMail: mail@christianvogt.net








Wu, et al.                    Informational                    [Page 14]

</pre><br/>
    <span class="noprint"><small><small>Html markup produced by rfcmarkup 1.126, available from
      <a href="https://tools.ietf.org/tools/rfcmarkup/">https://tools.ietf.org/tools/rfcmarkup/</a>
    </small></small></span>
  </div>




</body><!-- Mirrored from tools.ietf.org/html/rfc7039 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 06 Mar 2018 23:18:25 GMT --></html>