<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml"><!-- Mirrored from tools.ietf.org/html/rfc3492 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 06 Mar 2018 23:18:47 GMT --><!-- Added by HTTrack --><head><meta content="text/html;charset=utf-8" http-equiv="content-type"/><!-- /Added by HTTrack -->

    <meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
    <meta content="index,follow" name="robots"/>
    <meta content="rfcmarkup version 1.126" name="creator"/>
    <link href="http://purl.org/dc/elements/1.1/" rel="schema.DC"/>
<meta content="urn:ietf:rfc:3492" name="DC.Identifier"/>
<meta content="Punycode is a simple and efficient transfer encoding syntax designed
for use with Internationalized Domain Names in Applications (IDNA). It
uniquely and reversibly transforms a Unicode string into an ASCII
string. ASCII characters in the Unicode string are represented
literally, and non-ASCII characters are represented by ASCII
characters that are allowed in host name labels (letters, digits, and
hyphens). This document defines a general algorithm called Bootstring
that allows a string of basic code points to uniquely represent any
string of code points drawn from a larger set. Punycode is an instance
of Bootstring that uses particular parameter values specified by this
document, appropriate for IDNA. [STANDARDS-TRACK]" name="DC.Description.Abstract"/>
<meta content="Adam M. Costello" name="DC.Creator"/>
<meta content="March, 2003" name="DC.Date.Issued"/>
<meta content="Punycode: A Bootstring encoding of Unicode for Internationalized Domain Names in Applications (IDNA)" name="DC.Title"/>

    <link href="https://tools.ietf.org/images/rfc.png" rel="icon" type="image/png"/>
    <link href="https://tools.ietf.org/images/rfc.png" rel="shortcut icon" type="image/png"/>
    <title>RFC 3492 - Punycode: A Bootstring encoding of Unicode for Internationalized Domain Names in Applications (IDNA)</title>
    
    
    <style type="text/css">
	@media only screen 
	  and (min-width: 992px)
	  and (max-width: 1199px) {
	    body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 768px)
	  and (max-width: 991px) {
            body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 480px)
	  and (max-width: 767px) {
            body { font-size: 11pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (max-width: 479px) {
            body { font-size: 8pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-device-width : 375px) 
	  and (max-device-width : 667px) {
            body { font-size: 9.5pt; }
            div.content { width: 96ex; margin: 0 1px; }
        }
	@media only screen 
	  and (min-device-width: 1200px) {
            body { font-size: 10pt; margin: 0 4em; }
            div.content { width: 96ex; margin: 0; }
        }
        h1, h2, h3, h4, h5, h6, .h1, .h2, .h3, .h4, .h5, .h6 {
	    font-weight: bold;
            line-height: 0pt;
            display: inline;
            white-space: pre;
            font-family: monospace;
            font-size: 1em;
	    font-weight: bold;
        }
        pre {
            font-size: 1em;
            margin-top: 0px;
            margin-bottom: 0px;
        }
	.pre {
	    white-space: pre;
	    font-family: monospace;
	}
	.header{
	    font-weight: bold;
	}
        .newpage {
            page-break-before: always;
        }
        .invisible {
            text-decoration: none;
            color: white;
        }
        a.selflink {
          color: black;
          text-decoration: none;
        }
        @media print {
            body {
                font-family: monospace;
                font-size: 10.5pt;
            }
            h1, h2, h3, h4, h5, h6 {
                font-size: 1em;
            }
        
            a:link, a:visited {
                color: inherit;
                text-decoration: none;
            }
            .noprint {
                display: none;
            }
        }
	@media screen {
	    .grey, .grey a:link, .grey a:visited {
		color: #777;
	    }
            .docinfo {
                background-color: #EEE;
            }
            .top {
                border-top: 7px solid #EEE;
            }
            .bgwhite  { background-color: white; }
            .bgred    { background-color: #F44; }
            .bggrey   { background-color: #666; }
            .bgbrown  { background-color: #840; }            
            .bgorange { background-color: #FA0; }
            .bgyellow { background-color: #EE0; }
            .bgmagenta{ background-color: #F4F; }
            .bgblue   { background-color: #66F; }
            .bgcyan   { background-color: #4DD; }
            .bggreen  { background-color: #4F4; }

            .legend   { font-size: 90%; }
            .cplate   { font-size: 70%; border: solid grey 1px; }
	}
    </style>
    <!--[if IE]>
    <style>
    body {
       font-size: 13px;
       margin: 10px 10px;
    }
    </style>
    <![endif]-->

    <script type="text/javascript"><!--
    function addHeaderTags() {
	var spans = document.getElementsByTagName("span");
	for (var i=0; i < spans.length; i++) {
	    var elem = spans[i];
	    if (elem) {
		var level = elem.getAttribute("class");
                if (level == "h1" || level == "h2" || level == "h3" || level == "h4" || level == "h5" || level == "h6") {
                    elem.innerHTML = "<"+level+">"+elem.innerHTML+"</"+level+">";		
                }
	    }
	}
    }
    var legend_html = "Colour legend:<br />      <table>         <tr><td>Unknown:</td>                   <td><span class='cplate bgwhite'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft:</td>                     <td><span class='cplate bgred'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Informational:</td>             <td><span class='cplate bgorange'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Experimental:</td>              <td><span class='cplate bgyellow'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Best Common Practice:</td>      <td><span class='cplate bgmagenta'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Proposed Standard:</td>         <td><span class='cplate bgblue'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft Standard (old designation):</td> <td><span class='cplate bgcyan'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Internet Standard:</td>         <td><span class='cplate bggreen'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Historic:</td>                  <td><span class='cplate bggrey'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Obsolete:</td>                  <td><span class='cplate bgbrown'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>     </table>";
    function showElem(id) {
        var elem = document.getElementById(id);
        elem.innerHTML = eval(id+"_html");
        elem.style.visibility='visible';
    }
    function hideElem(id) {
        var elem = document.getElementById(id);
        elem.style.visibility='hidden';        
        elem.innerHTML = "";
    }
    // -->
    </script>
</head>
<body onload="addHeaderTags()">
  <div class="content">
   <div style="height: 13px;">
      <div class="pre noprint docinfo bgblue" onclick="showElem('legend');" onmouseout="hideElem('legend')" onmouseover="this.style.cursor='pointer';" style="height: 6px; position: absolute;" title="Click for colour legend.">                                                                        </div>
      <div class="docinfo noprint pre legend" id="legend" onmouseout="hideElem('legend');" onmouseover="showElem('legend');" style="position:absolute; top: 4px; left: 4ex; visibility:hidden; background-color: white; padding: 4px 9px 5px 7px; border: solid #345 1px; ">
      </div>
   </div>
<span class="pre noprint docinfo top">[<a href="index.html" title="Document search and retrieval page">Docs</a>] [<a href="https://tools.ietf.org/rfc/rfc3492.txt" title="Plaintext version of this document">txt</a>|<a href="https://tools.ietf.org/pdf/rfc3492" title="PDF version of this document">pdf</a>] [<a href="https://tools.ietf.org/html/draft-ietf-idn-punycode" title="draft-ietf-idn-punycode">draft-ietf-idn-...</a>] [<a href="https://datatracker.ietf.org/doc/rfc3492" title="IESG Datatracker information for this document">Tracker</a>] [<a href="https://tools.ietf.org/rfcdiff?difftype=--hwdiff&amp;url2=rfc3492" title="Inline diff (wdiff)">Diff1</a>] [<a href="https://tools.ietf.org/rfcdiff?url2=rfc3492" title="Side-by-side diff">Diff2</a>] [<a href="https://www.rfc-editor.org/errata_search.php?rfc=3492">Errata</a>]</span><br/>
<span class="pre noprint docinfo">                                                                        </span><br/>
<span class="pre noprint docinfo">Updated by: <a href="rfc5891.html">5891</a>                                       PROPOSED STANDARD</span><br/>
<span class="pre noprint docinfo">                                                            <span style="color: #C00;">Errata Exist</span></span><br/>
<pre>Network Working Group                                        A. Costello
Request for Comments: 3492                 Univ. of California, Berkeley
Category: Standards Track                                     March 2003


              <span class="h1">Punycode: A Bootstring encoding of Unicode</span>
       <span class="h1">for Internationalized Domain Names in Applications (IDNA)</span>

Status of this Memo

   This document specifies an Internet standards track protocol for the
   Internet community, and requests discussion and suggestions for
   improvements.  Please refer to the current edition of the "Internet
   Official Protocol Standards" (STD 1) for the standardization state
   and status of this protocol.  Distribution of this memo is unlimited.

Copyright Notice

   Copyright (C) The Internet Society (2003).  All Rights Reserved.

Abstract

   Punycode is a simple and efficient transfer encoding syntax designed
   for use with Internationalized Domain Names in Applications (IDNA).
   It uniquely and reversibly transforms a Unicode string into an ASCII
   string.  ASCII characters in the Unicode string are represented
   literally, and non-ASCII characters are represented by ASCII
   characters that are allowed in host name labels (letters, digits, and
   hyphens).  This document defines a general algorithm called
   Bootstring that allows a string of basic code points to uniquely
   represent any string of code points drawn from a larger set.
   Punycode is an instance of Bootstring that uses particular parameter
   values specified by this document, appropriate for IDNA.

Table of Contents

   <a href="#section-1">1</a>. Introduction...............................................<a href="#page-2">2</a>
       <a href="#section-1.1">1.1</a> Features..............................................<a href="#page-2">2</a>
       <a href="#section-1.2">1.2</a> Interaction of protocol parts.........................<a href="#page-3">3</a>
   <a href="#section-2">2</a>. Terminology................................................<a href="#page-3">3</a>
   <a href="#section-3">3</a>. Bootstring description.....................................<a href="#page-4">4</a>
       <a href="#section-3.1">3.1</a> Basic code point segregation..........................<a href="#page-4">4</a>
       <a href="#section-3.2">3.2</a> Insertion unsort coding...............................<a href="#page-4">4</a>
       <a href="#section-3.3">3.3</a> Generalized variable-length integers..................<a href="#page-5">5</a>
       <a href="#section-3.4">3.4</a> Bias adaptation.......................................<a href="#page-7">7</a>
   <a href="#section-4">4</a>. Bootstring parameters......................................<a href="#page-8">8</a>
   <a href="#section-5">5</a>. Parameter values for Punycode..............................<a href="#page-8">8</a>
   <a href="#section-6">6</a>. Bootstring algorithms......................................<a href="#page-9">9</a>



<span class="grey">Costello                    Standards Track                     [Page 1]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-2" id="page-2" name="page-2"> </a>
<span class="grey"><a href="rfc3492.html">RFC 3492</a>                     IDNA Punycode                    March 2003</span>


       <a href="#section-6.1">6.1</a> Bias adaptation function.............................<a href="#page-10">10</a>
       <a href="#section-6.2">6.2</a> Decoding procedure...................................<a href="#page-11">11</a>
       <a href="#section-6.3">6.3</a> Encoding procedure...................................<a href="#page-12">12</a>
       <a href="#section-6.4">6.4</a> Overflow handling....................................<a href="#page-13">13</a>
   <a href="#section-7">7</a>. Punycode examples.........................................<a href="#page-14">14</a>
       <a href="#section-7.1">7.1</a> Sample strings.......................................<a href="#page-14">14</a>
       <a href="#section-7.2">7.2</a> Decoding traces......................................<a href="#page-17">17</a>
       <a href="#section-7.3">7.3</a> Encoding traces......................................<a href="#page-19">19</a>
   <a href="#section-8">8</a>. Security Considerations...................................<a href="#page-20">20</a>
   <a href="#section-9">9</a>. References................................................<a href="#page-21">21</a>
       <a href="#section-9.1">9.1</a> Normative References.................................<a href="#page-21">21</a>
       <a href="#section-9.2">9.2</a> Informative References...............................<a href="#page-21">21</a>
   <a href="#appendix-A">A</a>. Mixed-case annotation.....................................<a href="#page-22">22</a>
   <a href="#appendix-B">B</a>. Disclaimer and license....................................<a href="#page-22">22</a>
   <a href="#appendix-C">C</a>. Punycode sample implementation............................<a href="#page-23">23</a>
   Author's Address.............................................<a href="#page-34">34</a>
   Full Copyright Statement.....................................<a href="#page-35">35</a>

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/1.%20Introduction"></a><a class="selflink" href="#section-1" name="section-1">1</a>. Introduction</span>

   [<a id="ref-IDNA" name="ref-IDNA">IDNA</a>] describes an architecture for supporting internationalized
   domain names.  Labels containing non-ASCII characters can be
   represented by ACE labels, which begin with a special ACE prefix and
   contain only ASCII characters.  The remainder of the label after the
   prefix is a Punycode encoding of a Unicode string satisfying certain
   constraints.  For the details of the prefix and constraints, see
   [<a href="#ref-IDNA" title='"Internationalizing Domain Names in Applications (IDNA)"'>IDNA</a>] and [<a href="#ref-NAMEPREP" title='"Nameprep: A Stringprep Profile for Internationalized Domain Names (IDN)"'>NAMEPREP</a>].

   Punycode is an instance of a more general algorithm called
   Bootstring, which allows strings composed from a small set of "basic"
   code points to uniquely represent any string of code points drawn
   from a larger set.  Punycode is Bootstring with particular parameter
   values appropriate for IDNA.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/1.1%20Features"></a><a class="selflink" href="#section-1.1" name="section-1.1">1.1</a> Features</span>

   Bootstring has been designed to have the following features:

   *  Completeness:  Every extended string (sequence of arbitrary code
      points) can be represented by a basic string (sequence of basic
      code points).  Restrictions on what strings are allowed, and on
      length, can be imposed by higher layers.

   *  Uniqueness:  There is at most one basic string that represents a
      given extended string.

   *  Reversibility:  Any extended string mapped to a basic string can
      be recovered from that basic string.



<span class="grey">Costello                    Standards Track                     [Page 2]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-3" id="page-3" name="page-3"> </a>
<span class="grey"><a href="rfc3492.html">RFC 3492</a>                     IDNA Punycode                    March 2003</span>


   *  Efficient encoding:  The ratio of basic string length to extended
      string length is small.  This is important in the context of
      domain names because <a href="rfc1034.html">RFC 1034</a> [<a href="rfc1034.html" title='"Domain Names - Concepts and Facilities"'>RFC1034</a>] restricts the length of a
      domain label to 63 characters.

   *  Simplicity:  The encoding and decoding algorithms are reasonably
      simple to implement.  The goals of efficiency and simplicity are
      at odds; Bootstring aims at a good balance between them.

   *  Readability:  Basic code points appearing in the extended string
      are represented as themselves in the basic string (although the
      main purpose is to improve efficiency, not readability).

   Punycode can also support an additional feature that is not used by
   the ToASCII and ToUnicode operations of [<a href="#ref-IDNA" title='"Internationalizing Domain Names in Applications (IDNA)"'>IDNA</a>].  When extended
   strings are case-folded prior to encoding, the basic string can use
   mixed case to tell how to convert the folded string into a mixed-case
   string.  See <a href="#appendix-A">appendix A</a> "Mixed-case annotation".

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/1.2%20Interaction%20of%20protocol%20parts"></a><a class="selflink" href="#section-1.2" name="section-1.2">1.2</a> Interaction of protocol parts</span>

   Punycode is used by the IDNA protocol [<a href="#ref-IDNA" title='"Internationalizing Domain Names in Applications (IDNA)"'>IDNA</a>] for converting domain
   labels into ASCII; it is not designed for any other purpose.  It is
   explicitly not designed for processing arbitrary free text.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/2.%20Terminology"></a><a class="selflink" href="#section-2" name="section-2">2</a>. Terminology</span>

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in <a href="https://tools.ietf.org/html/bcp14">BCP 14</a>, <a href="rfc2119.html">RFC 2119</a>
   [<a href="rfc2119.html" title='"Key words for use in RFCs to Indicate Requirement Levels"'>RFC2119</a>].

   A code point is an integral value associated with a character in a
   coded character set.

   As in the Unicode Standard [<a href="#ref-UNICODE" title='"The Unicode Standard"'>UNICODE</a>], Unicode code points are denoted
   by "U+" followed by four to six hexadecimal digits, while a range of
   code points is denoted by two hexadecimal numbers separated by "..",
   with no prefixes.

   The operators div and mod perform integer division; (x div y) is the
   quotient of x divided by y, discarding the remainder, and (x mod y)
   is the remainder, so (x div y) * y + (x mod y) == x.  Bootstring uses
   these operators only with nonnegative operands, so the quotient and
   remainder are always nonnegative.

   The break statement jumps out of the innermost loop (as in C).




<span class="grey">Costello                    Standards Track                     [Page 3]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-4" id="page-4" name="page-4"> </a>
<span class="grey"><a href="rfc3492.html">RFC 3492</a>                     IDNA Punycode                    March 2003</span>


   An overflow is an attempt to compute a value that exceeds the maximum
   value of an integer variable.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/3.%20Bootstring%20description"></a><a class="selflink" href="#section-3" name="section-3">3</a>. Bootstring description</span>

   Bootstring represents an arbitrary sequence of code points (the
   "extended string") as a sequence of basic code points (the "basic
   string").  This section describes the representation.  <a href="#section-6">Section 6</a>
   "Bootstring algorithms" presents the algorithms as pseudocode.
   Sections <a href="#section-7.1">7.1</a> "Decoding traces" and 7.2 "Encoding traces" trace the
   algorithms for sample inputs.

   The following sections describe the four techniques used in
   Bootstring.  "Basic code point segregation" is a very simple and
   efficient encoding for basic code points occurring in the extended
   string: they are simply copied all at once.  "Insertion unsort
   coding" encodes the non-basic code points as deltas, and processes
   the code points in numerical order rather than in order of
   appearance, which typically results in smaller deltas.  The deltas
   are represented as "generalized variable-length integers", which use
   basic code points to represent nonnegative integers.  The parameters
   of this integer representation are dynamically adjusted using "bias
   adaptation", to improve efficiency when consecutive deltas have
   similar magnitudes.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.1%20Basic%20code%20point%20segregation"></a><a class="selflink" href="#section-3.1" name="section-3.1">3.1</a> Basic code point segregation</span>

   All basic code points appearing in the extended string are
   represented literally at the beginning of the basic string, in their
   original order, followed by a delimiter if (and only if) the number
   of basic code points is nonzero.  The delimiter is a particular basic
   code point, which never appears in the remainder of the basic string.
   The decoder can therefore find the end of the literal portion (if
   there is one) by scanning for the last delimiter.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.2%20Insertion%20unsort%20coding"></a><a class="selflink" href="#section-3.2" name="section-3.2">3.2</a> Insertion unsort coding</span>

   The remainder of the basic string (after the last delimiter if there
   is one) represents a sequence of nonnegative integral deltas as
   generalized variable-length integers, described in <a href="#section-3.3">section 3.3</a>.  The
   meaning of the deltas is best understood in terms of the decoder.

   The decoder builds the extended string incrementally.  Initially, the
   extended string is a copy of the literal portion of the basic string
   (excluding the last delimiter).  The decoder inserts non-basic code
   points, one for each delta, into the extended string, ultimately
   arriving at the final decoded string.




<span class="grey">Costello                    Standards Track                     [Page 4]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-5" id="page-5" name="page-5"> </a>
<span class="grey"><a href="rfc3492.html">RFC 3492</a>                     IDNA Punycode                    March 2003</span>


   At the heart of this process is a state machine with two state
   variables: an index i and a counter n.  The index i refers to a
   position in the extended string; it ranges from 0 (the first
   position) to the current length of the extended string (which refers
   to a potential position beyond the current end).  If the current
   state is &lt;n,i&gt;, the next state is &lt;n,i+1&gt; if i is less than the
   length of the extended string, or &lt;n+1,0&gt; if i equals the length of
   the extended string.  In other words, each state change causes i to
   increment, wrapping around to zero if necessary, and n counts the
   number of wrap-arounds.

   Notice that the state always advances monotonically (there is no way
   for the decoder to return to an earlier state).  At each state, an
   insertion is either performed or not performed.  At most one
   insertion is performed in a given state.  An insertion inserts the
   value of n at position i in the extended string.  The deltas are a
   run-length encoding of this sequence of events: they are the lengths
   of the runs of non-insertion states preceeding the insertion states.
   Hence, for each delta, the decoder performs delta state changes, then
   an insertion, and then one more state change.  (An implementation
   need not perform each state change individually, but can instead use
   division and remainder calculations to compute the next insertion
   state directly.)  It is an error if the inserted code point is a
   basic code point (because basic code points were supposed to be
   segregated as described in <a href="#section-3.1">section 3.1</a>).

   The encoder's main task is to derive the sequence of deltas that will
   cause the decoder to construct the desired string.  It can do this by
   repeatedly scanning the extended string for the next code point that
   the decoder would need to insert, and counting the number of state
   changes the decoder would need to perform, mindful of the fact that
   the decoder's extended string will include only those code points
   that have already been inserted.  <a href="#section-6.3">Section 6.3</a> "Encoding procedure"
   gives a precise algorithm.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.3%20Generalized%20variable-length%20integers"></a><a class="selflink" href="#section-3.3" name="section-3.3">3.3</a> Generalized variable-length integers</span>

   In a conventional integer representation the base is the number of
   distinct symbols for digits, whose values are 0 through base-1.  Let
   digit_0 denote the least significant digit, digit_1 the next least
   significant, and so on.  The value represented is the sum over j of
   digit_j * w(j), where w(j) = base^j is the weight (scale factor) for
   position j.  For example, in the base 8 integer 437, the digits are
   7, 3, and 4, and the weights are 1, 8, and 64, so the value is 7 +
   3*8 + 4*64 = 287.  This representation has two disadvantages:  First,
   there are multiple encodings of each value (because there can be
   extra zeros in the most significant positions), which is inconvenient




<span class="grey">Costello                    Standards Track                     [Page 5]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-6" id="page-6" name="page-6"> </a>
<span class="grey"><a href="rfc3492.html">RFC 3492</a>                     IDNA Punycode                    March 2003</span>


   when unique encodings are needed.  Second, the integer is not self-
   delimiting, so if multiple integers are concatenated the boundaries
   between them are lost.

   The generalized variable-length representation solves these two
   problems.  The digit values are still 0 through base-1, but now the
   integer is self-delimiting by means of thresholds t(j), each of which
   is in the range 0 through base-1.  Exactly one digit, the most
   significant, satisfies digit_j &lt; t(j).  Therefore, if several
   integers are concatenated, it is easy to separate them, starting with
   the first if they are little-endian (least significant digit first),
   or starting with the last if they are big-endian (most significant
   digit first).  As before, the value is the sum over j of digit_j *
   w(j), but the weights are different:

      w(0) = 1
      w(j) = w(j-1) * (base - t(j-1)) for j &gt; 0

   For example, consider the little-endian sequence of base 8 digits
   734251...  Suppose the thresholds are 2, 3, 5, 5, 5, 5...  This
   implies that the weights are 1, 1*(8-2) = 6, 6*(8-3) = 30, 30*(8-5) =
   90, 90*(8-5) = 270, and so on.  7 is not less than 2, and 3 is not
   less than 3, but 4 is less than 5, so 4 is the last digit.  The value
   of 734 is 7*1 + 3*6 + 4*30 = 145.  The next integer is 251, with
   value 2*1 + 5*6 + 1*30 = 62.  Decoding this representation is very
   similar to decoding a conventional integer:  Start with a current
   value of N = 0 and a weight w = 1.  Fetch the next digit d and
   increase N by d * w.  If d is less than the current threshold (t)
   then stop, otherwise increase w by a factor of (base - t), update t
   for the next position, and repeat.

   Encoding this representation is similar to encoding a conventional
   integer:  If N &lt; t then output one digit for N and stop, otherwise
   output the digit for t + ((N - t) mod (base - t)), then replace N
   with (N - t) div (base - t), update t for the next position, and
   repeat.

   For any particular set of values of t(j), there is exactly one
   generalized variable-length representation of each nonnegative
   integral value.

   Bootstring uses little-endian ordering so that the deltas can be
   separated starting with the first.  The t(j) values are defined in
   terms of the constants base, tmin, and tmax, and a state variable
   called bias:

      t(j) = base * (j + 1) - bias,
      clamped to the range tmin through tmax



<span class="grey">Costello                    Standards Track                     [Page 6]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-7" id="page-7" name="page-7"> </a>
<span class="grey"><a href="rfc3492.html">RFC 3492</a>                     IDNA Punycode                    March 2003</span>


   The clamping means that if the formula yields a value less than tmin
   or greater than tmax, then t(j) = tmin or tmax, respectively.  (In
   the pseudocode in <a href="#section-6">section 6</a> "Bootstring algorithms", the expression
   base * (j + 1) is denoted by k for performance reasons.)  These t(j)
   values cause the representation to favor integers within a particular
   range determined by the bias.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.4%20Bias%20adaptation"></a><a class="selflink" href="#section-3.4" name="section-3.4">3.4</a> Bias adaptation</span>

   After each delta is encoded or decoded, bias is set for the next
   delta as follows:

   1. Delta is scaled in order to avoid overflow in the next step:

         let delta = delta div 2

      But when this is the very first delta, the divisor is not 2, but
      instead a constant called damp.  This compensates for the fact
      that the second delta is usually much smaller than the first.

   2. Delta is increased to compensate for the fact that the next delta
      will be inserting into a longer string:

         let delta = delta + (delta div numpoints)

      numpoints is the total number of code points encoded/decoded so
      far (including the one corresponding to this delta itself, and
      including the basic code points).

   3. Delta is repeatedly divided until it falls within a threshold, to
      predict the minimum number of digits needed to represent the next
      delta:

         while delta &gt; ((base - tmin) * tmax) div 2
         do let delta = delta div (base - tmin)

   4. The bias is set:

         let bias =
           (base * the number of divisions performed in step 3) +
           (((base - tmin + 1) * delta) div (delta + skew))

      The motivation for this procedure is that the current delta
      provides a hint about the likely size of the next delta, and so
      t(j) is set to tmax for the more significant digits starting with
      the one expected to be last, tmin for the less significant digits
      up through the one expected to be third-last, and somewhere
      between tmin and tmax for the digit expected to be second-last



<span class="grey">Costello                    Standards Track                     [Page 7]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-8" id="page-8" name="page-8"> </a>
<span class="grey"><a href="rfc3492.html">RFC 3492</a>                     IDNA Punycode                    March 2003</span>


      (balancing the hope of the expected-last digit being unnecessary
      against the danger of it being insufficient).

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/4.%20Bootstring%20parameters"></a><a class="selflink" href="#section-4" name="section-4">4</a>. Bootstring parameters</span>

   Given a set of basic code points, one needs to be designated as the
   delimiter.  The base cannot be greater than the number of
   distinguishable basic code points remaining.  The digit-values in the
   range 0 through base-1 need to be associated with distinct non-
   delimiter basic code points.  In some cases multiple code points need
   to have the same digit-value; for example, uppercase and lowercase
   versions of the same letter need to be equivalent if basic strings
   are case-insensitive.

   The initial value of n cannot be greater than the minimum non-basic
   code point that could appear in extended strings.

   The remaining five parameters (tmin, tmax, skew, damp, and the
   initial value of bias) need to satisfy the following constraints:

      0 &lt;= tmin &lt;= tmax &lt;= base-1
      skew &gt;= 1
      damp &gt;= 2
      initial_bias mod base &lt;= base - tmin

   Provided the constraints are satisfied, these five parameters affect
   efficiency but not correctness.  They are best chosen empirically.

   If support for mixed-case annotation is desired (see <a href="#appendix-A">appendix A</a>),
   make sure that the code points corresponding to 0 through tmax-1 all
   have both uppercase and lowercase forms.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/5.%20Parameter%20values%20for%20Punycode"></a><a class="selflink" href="#section-5" name="section-5">5</a>. Parameter values for Punycode</span>

   Punycode uses the following Bootstring parameter values:

      base         = 36
      tmin         = 1
      tmax         = 26
      skew         = 38
      damp         = 700
      initial_bias = 72
      initial_n    = 128 = 0x80

   Although the only restriction Punycode imposes on the input integers
   is that they be nonnegative, these parameters are especially designed
   to work well with Unicode [<a href="#ref-UNICODE" title='"The Unicode Standard"'>UNICODE</a>] code points, which are integers
   in the range 0..10FFFF (but not D800..DFFF, which are reserved for



<span class="grey">Costello                    Standards Track                     [Page 8]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-9" id="page-9" name="page-9"> </a>
<span class="grey"><a href="rfc3492.html">RFC 3492</a>                     IDNA Punycode                    March 2003</span>


   use by the UTF-16 encoding of Unicode).  The basic code points are
   the ASCII [<a href="#ref-ASCII" title='"ASCII format for Network Interchange"'>ASCII</a>] code points (0..7F), of which U+002D (-) is the
   delimiter, and some of the others have digit-values as follows:

      code points    digit-values
      ------------   ----------------------
      41..5A (A-Z) =  0 to 25, respectively
      61..7A (a-z) =  0 to 25, respectively
      30..39 (0-9) = 26 to 35, respectively

   Using hyphen-minus as the delimiter implies that the encoded string
   can end with a hyphen-minus only if the Unicode string consists
   entirely of basic code points, but IDNA forbids such strings from
   being encoded.  The encoded string can begin with a hyphen-minus, but
   IDNA prepends a prefix.  Therefore IDNA using Punycode conforms to
   the <a href="rfc952.html">RFC 952</a> rule that host name labels neither begin nor end with a
   hyphen-minus [<a href="rfc952.html" title='"DOD Internet Host Table Specification"'>RFC952</a>].

   A decoder MUST recognize the letters in both uppercase and lowercase
   forms (including mixtures of both forms).  An encoder SHOULD output
   only uppercase forms or only lowercase forms, unless it uses mixed-
   case annotation (see <a href="#appendix-A">appendix A</a>).

   Presumably most users will not manually write or type encoded strings
   (as opposed to cutting and pasting them), but those who do will need
   to be alert to the potential visual ambiguity between the following
   sets of characters:

      G 6
      I l 1
      O 0
      S 5
      U V
      Z 2

   Such ambiguities are usually resolved by context, but in a Punycode
   encoded string there is no context apparent to humans.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/6.%20Bootstring%20algorithms"></a><a class="selflink" href="#section-6" name="section-6">6</a>. Bootstring algorithms</span>

   Some parts of the pseudocode can be omitted if the parameters satisfy
   certain conditions (for which Punycode qualifies).  These parts are
   enclosed in {braces}, and notes immediately following the pseudocode
   explain the conditions under which they can be omitted.







<span class="grey">Costello                    Standards Track                     [Page 9]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-10" id="page-10" name="page-10"> </a>
<span class="grey"><a href="rfc3492.html">RFC 3492</a>                     IDNA Punycode                    March 2003</span>


   Formally, code points are integers, and hence the pseudocode assumes
   that arithmetic operations can be performed directly on code points.
   In some programming languages, explicit conversion between code
   points and integers might be necessary.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/6.1%20Bias%20adaptation%20function"></a><a class="selflink" href="#section-6.1" name="section-6.1">6.1</a> Bias adaptation function</span>

   function adapt(delta,numpoints,firsttime):
     if firsttime then let delta = delta div damp
     else let delta = delta div 2
     let delta = delta + (delta div numpoints)
     let k = 0
     while delta &gt; ((base - tmin) * tmax) div 2 do begin
       let delta = delta div (base - tmin)
       let k = k + base
     end
     return k + (((base - tmin + 1) * delta) div (delta + skew))

   It does not matter whether the modifications to delta and k inside
   adapt() affect variables of the same name inside the
   encoding/decoding procedures, because after calling adapt() the
   caller does not read those variables before overwriting them.





























<span class="grey">Costello                    Standards Track                    [Page 10]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-11" id="page-11" name="page-11"> </a>
<span class="grey"><a href="rfc3492.html">RFC 3492</a>                     IDNA Punycode                    March 2003</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/6.2%20Decoding%20procedure"></a><a class="selflink" href="#section-6.2" name="section-6.2">6.2</a> Decoding procedure</span>

   let n = initial_n
   let i = 0
   let bias = initial_bias
   let output = an empty string indexed from 0
   consume all code points before the last delimiter (if there is one)
     and copy them to output, fail on any non-basic code point
   if more than zero code points were consumed then consume one more
     (which will be the last delimiter)
   while the input is not exhausted do begin
     let oldi = i
     let w = 1
     for k = base to infinity in steps of base do begin
       consume a code point, or fail if there was none to consume
       let digit = the code point's digit-value, fail if it has none
       let i = i + digit * w, fail on overflow
       let t = tmin if k &lt;= bias {+ tmin}, or
               tmax if k &gt;= bias + tmax, or k - bias otherwise
       if digit &lt; t then break
       let w = w * (base - t), fail on overflow
     end
     let bias = adapt(i - oldi, length(output) + 1, test oldi is 0?)
     let n = n + i div (length(output) + 1), fail on overflow
     let i = i mod (length(output) + 1)
     {if n is a basic code point then fail}
     insert n into output at position i
     increment i
   end

   The full statement enclosed in braces (checking whether n is a basic
   code point) can be omitted if initial_n exceeds all basic code points
   (which is true for Punycode), because n is never less than initial_n.

   In the assignment of t, where t is clamped to the range tmin through
   tmax, "+ tmin" can always be omitted.  This makes the clamping
   calculation incorrect when bias &lt; k &lt; bias + tmin, but that cannot
   happen because of the way bias is computed and because of the
   constraints on the parameters.

   Because the decoder state can only advance monotonically, and there
   is only one representation of any delta, there is therefore only one
   encoded string that can represent a given sequence of integers.  The
   only error conditions are invalid code points, unexpected end-of-
   input, overflow, and basic code points encoded using deltas instead
   of appearing literally.  If the decoder fails on these errors as
   shown above, then it cannot produce the same output for two distinct
   inputs.  Without this property it would have been necessary to re-



<span class="grey">Costello                    Standards Track                    [Page 11]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-12" id="page-12" name="page-12"> </a>
<span class="grey"><a href="rfc3492.html">RFC 3492</a>                     IDNA Punycode                    March 2003</span>


   encode the output and verify that it matches the input in order to
   guarantee the uniqueness of the encoding.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/6.3%20Encoding%20procedure"></a><a class="selflink" href="#section-6.3" name="section-6.3">6.3</a> Encoding procedure</span>

   let n = initial_n
   let delta = 0
   let bias = initial_bias
   let h = b = the number of basic code points in the input
   copy them to the output in order, followed by a delimiter if b &gt; 0
   {if the input contains a non-basic code point &lt; n then fail}
   while h &lt; length(input) do begin
     let m = the minimum {non-basic} code point &gt;= n in the input
     let delta = delta + (m - n) * (h + 1), fail on overflow
     let n = m
     for each code point c in the input (in order) do begin
       if c &lt; n {or c is basic} then increment delta, fail on overflow
       if c == n then begin
         let q = delta
         for k = base to infinity in steps of base do begin
           let t = tmin if k &lt;= bias {+ tmin}, or
                   tmax if k &gt;= bias + tmax, or k - bias otherwise
           if q &lt; t then break
           output the code point for digit t + ((q - t) mod (base - t))
           let q = (q - t) div (base - t)
         end
         output the code point for digit q
         let bias = adapt(delta, h + 1, test h equals b?)
         let delta = 0
         increment h
       end
     end
     increment delta and n
   end

   The full statement enclosed in braces (checking whether the input
   contains a non-basic code point less than n) can be omitted if all
   code points less than initial_n are basic code points (which is true
   for Punycode if code points are unsigned).

   The brace-enclosed conditions "non-basic" and "or c is basic" can be
   omitted if initial_n exceeds all basic code points (which is true for
   Punycode), because the code point being tested is never less than
   initial_n.

   In the assignment of t, where t is clamped to the range tmin through
   tmax, "+ tmin" can always be omitted.  This makes the clamping
   calculation incorrect when bias &lt; k &lt; bias + tmin, but that cannot



<span class="grey">Costello                    Standards Track                    [Page 12]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-13" id="page-13" name="page-13"> </a>
<span class="grey"><a href="rfc3492.html">RFC 3492</a>                     IDNA Punycode                    March 2003</span>


   happen because of the way bias is computed and because of the
   constraints on the parameters.

   The checks for overflow are necessary to avoid producing invalid
   output when the input contains very large values or is very long.

   The increment of delta at the bottom of the outer loop cannot
   overflow because delta &lt; length(input) before the increment, and
   length(input) is already assumed to be representable.  The increment
   of n could overflow, but only if h == length(input), in which case
   the procedure is finished anyway.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/6.4%20Overflow%20handling"></a><a class="selflink" href="#section-6.4" name="section-6.4">6.4</a> Overflow handling</span>

   For IDNA, 26-bit unsigned integers are sufficient to handle all valid
   IDNA labels without overflow, because any string that needed a 27-bit
   delta would have to exceed either the code point limit (0..10FFFF) or
   the label length limit (63 characters).  However, overflow handling
   is necessary because the inputs are not necessarily valid IDNA
   labels.

   If the programming language does not provide overflow detection, the
   following technique can be used.  Suppose A, B, and C are
   representable nonnegative integers and C is nonzero.  Then A + B
   overflows if and only if B &gt; maxint - A, and A + (B * C) overflows if
   and only if B &gt; (maxint - A) div C, where maxint is the greatest
   integer for which maxint + 1 cannot be represented.  Refer to
   <a href="#appendix-C">appendix C</a> "Punycode sample implementation" for demonstrations of
   this technique in the C language.

   The decoding and encoding algorithms shown in sections <a href="#section-6.2">6.2</a> and <a href="#section-6.3">6.3</a>
   handle overflow by detecting it whenever it happens.  Another
   approach is to enforce limits on the inputs that prevent overflow
   from happening.  For example, if the encoder were to verify that no
   input code points exceed M and that the input length does not exceed
   L, then no delta could ever exceed (M - initial_n) * (L + 1), and
   hence no overflow could occur if integer variables were capable of
   representing values that large.  This prevention approach would
   impose more restrictions on the input than the detection approach
   does, but might be considered simpler in some programming languages.

   In theory, the decoder could use an analogous approach, limiting the
   number of digits in a variable-length integer (that is, limiting the
   number of iterations in the innermost loop).  However, the number of
   digits that suffice to represent a given delta can sometimes
   represent much larger deltas (because of the adaptation), and hence
   this approach would probably need integers wider than 32 bits.




<span class="grey">Costello                    Standards Track                    [Page 13]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-14" id="page-14" name="page-14"> </a>
<span class="grey"><a href="rfc3492.html">RFC 3492</a>                     IDNA Punycode                    March 2003</span>


   Yet another approach for the decoder is to allow overflow to occur,
   but to check the final output string by re-encoding it and comparing
   to the decoder input.  If and only if they do not match (using a
   case-insensitive ASCII comparison) overflow has occurred.  This
   delayed-detection approach would not impose any more restrictions on
   the input than the immediate-detection approach does, and might be
   considered simpler in some programming languages.

   In fact, if the decoder is used only inside the IDNA ToUnicode
   operation [<a href="#ref-IDNA" title='"Internationalizing Domain Names in Applications (IDNA)"'>IDNA</a>], then it need not check for overflow at all, because
   ToUnicode performs a higher level re-encoding and comparison, and a
   mismatch has the same consequence as if the Punycode decoder had
   failed.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/7.%20Punycode%20examples"></a><a class="selflink" href="#section-7" name="section-7">7</a>. Punycode examples</span>

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/7.1%20Sample%20strings"></a><a class="selflink" href="#section-7.1" name="section-7.1">7.1</a> Sample strings</span>

   In the Punycode encodings below, the ACE prefix is not shown.
   Backslashes show where line breaks have been inserted in strings too
   long for one line.

   The first several examples are all translations of the sentence "Why
   can't they just speak in &lt;language&gt;?" (courtesy of Michael Kaplan's
   "provincial" page [<a href="#ref-PROVINCIAL" title="&quot;The 'anyone can be provincial!' page&quot;">PROVINCIAL</a>]).  Word breaks and punctuation have
   been removed, as is often done in domain names.

   (A) Arabic (Egyptian):
       u+0644 u+064A u+0647 u+0645 u+0627 u+0628 u+062A u+0643 u+0644
       u+0645 u+0648 u+0634 u+0639 u+0631 u+0628 u+064A u+061F
       Punycode: egbpdaj6bu4bxfgehfvwxn

   (B) Chinese (simplified):
       u+4ED6 u+4EEC u+4E3A u+4EC0 u+4E48 u+4E0D u+8BF4 u+4E2D u+6587
       Punycode: ihqwcrb4cv8a8dqg056pqjye

   (C) Chinese (traditional):
       u+4ED6 u+5011 u+7232 u+4EC0 u+9EBD u+4E0D u+8AAA u+4E2D u+6587
       Punycode: ihqwctvzc91f659drss3x8bo0yb

   (D) Czech: Pro&lt;ccaron&gt;prost&lt;ecaron&gt;nemluv&lt;iacute&gt;&lt;ccaron&gt;esky
       U+0050 u+0072 u+006F u+010D u+0070 u+0072 u+006F u+0073 u+0074
       u+011B u+006E u+0065 u+006D u+006C u+0075 u+0076 u+00ED u+010D
       u+0065 u+0073 u+006B u+0079
       Punycode: Proprostnemluvesky-uyb24dma41a






<span class="grey">Costello                    Standards Track                    [Page 14]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-15" id="page-15" name="page-15"> </a>
<span class="grey"><a href="rfc3492.html">RFC 3492</a>                     IDNA Punycode                    March 2003</span>


   (E) Hebrew:
       u+05DC u+05DE u+05D4 u+05D4 u+05DD u+05E4 u+05E9 u+05D5 u+05D8
       u+05DC u+05D0 u+05DE u+05D3 u+05D1 u+05E8 u+05D9 u+05DD u+05E2
       u+05D1 u+05E8 u+05D9 u+05EA
       Punycode: 4dbcagdahymbxekheh6e0a7fei0b

   (F) Hindi (Devanagari):
       u+092F u+0939 u+0932 u+094B u+0917 u+0939 u+093F u+0928 u+094D
       u+0926 u+0940 u+0915 u+094D u+092F u+094B u+0902 u+0928 u+0939
       u+0940 u+0902 u+092C u+094B u+0932 u+0938 u+0915 u+0924 u+0947
       u+0939 u+0948 u+0902
       Punycode: i1baa7eci9glrd9b2ae1bj0hfcgg6iyaf8o0a1dig0cd

   (G) Japanese (kanji and hiragana):
       u+306A u+305C u+307F u+3093 u+306A u+65E5 u+672C u+8A9E u+3092
       u+8A71 u+3057 u+3066 u+304F u+308C u+306A u+3044 u+306E u+304B
       Punycode: n8jok5ay5dzabd5bym9f0cm5685rrjetr6pdxa

   (H) Korean (Hangul syllables):
       u+C138 u+ACC4 u+C758 u+BAA8 u+B4E0 u+C0AC u+B78C u+B4E4 u+C774
       u+D55C u+AD6D u+C5B4 u+B97C u+C774 u+D574 u+D55C u+B2E4 u+BA74
       u+C5BC u+B9C8 u+B098 u+C88B u+C744 u+AE4C
       Punycode: 989aomsvi5e83db1d2a355cv1e0vak1dwrv93d5xbh15a0dt30a5j\
                 psd879ccm6fea98c

   (I) Russian (Cyrillic):
       U+043F u+043E u+0447 u+0435 u+043C u+0443 u+0436 u+0435 u+043E
       u+043D u+0438 u+043D u+0435 u+0433 u+043E u+0432 u+043E u+0440
       u+044F u+0442 u+043F u+043E u+0440 u+0443 u+0441 u+0441 u+043A
       u+0438
       Punycode: b1abfaaepdrnnbgefbaDotcwatmq2g4l

   (J) Spanish: Porqu&lt;eacute&gt;nopuedensimplementehablarenEspa&lt;ntilde&gt;ol
       U+0050 u+006F u+0072 u+0071 u+0075 u+00E9 u+006E u+006F u+0070
       u+0075 u+0065 u+0064 u+0065 u+006E u+0073 u+0069 u+006D u+0070
       u+006C u+0065 u+006D u+0065 u+006E u+0074 u+0065 u+0068 u+0061
       u+0062 u+006C u+0061 u+0072 u+0065 u+006E U+0045 u+0073 u+0070
       u+0061 u+00F1 u+006F u+006C
       Punycode: PorqunopuedensimplementehablarenEspaol-fmd56a

   (K) Vietnamese:
       T&lt;adotbelow&gt;isaoh&lt;odotbelow&gt;kh&lt;ocirc&gt;ngth&lt;ecirchookabove&gt;ch\
       &lt;ihookabove&gt;n&lt;oacute&gt;iti&lt;ecircacute&gt;ngVi&lt;ecircdotbelow&gt;t
       U+0054 u+1EA1 u+0069 u+0073 u+0061 u+006F u+0068 u+1ECD u+006B
       u+0068 u+00F4 u+006E u+0067 u+0074 u+0068 u+1EC3 u+0063 u+0068
       u+1EC9 u+006E u+00F3 u+0069 u+0074 u+0069 u+1EBF u+006E u+0067
       U+0056 u+0069 u+1EC7 u+0074
       Punycode: TisaohkhngthchnitingVit-kjcr8268qyxafd2f1b9g



<span class="grey">Costello                    Standards Track                    [Page 15]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-16" id="page-16" name="page-16"> </a>
<span class="grey"><a href="rfc3492.html">RFC 3492</a>                     IDNA Punycode                    March 2003</span>


   The next several examples are all names of Japanese music artists,
   song titles, and TV programs, just because the author happens to have
   them handy (but Japanese is useful for providing examples of single-
   row text, two-row text, ideographic text, and various mixtures
   thereof).

   (L) 3&lt;nen&gt;B&lt;gumi&gt;&lt;kinpachi&gt;&lt;sensei&gt;
       u+0033 u+5E74 U+0042 u+7D44 u+91D1 u+516B u+5148 u+751F
       Punycode: 3B-ww4c5e180e575a65lsy2b

   (M) &lt;amuro&gt;&lt;namie&gt;-with-SUPER-MONKEYS
       u+5B89 u+5BA4 u+5948 u+7F8E u+6075 u+002D u+0077 u+0069 u+0074
       u+0068 u+002D U+0053 U+0055 U+0050 U+0045 U+0052 u+002D U+004D
       U+004F U+004E U+004B U+0045 U+0059 U+0053
       Punycode: -with-SUPER-MONKEYS-pc58ag80a8qai00g7n9n

   (N) Hello-Another-Way-&lt;sorezore&gt;&lt;no&gt;&lt;basho&gt;
       U+0048 u+0065 u+006C u+006C u+006F u+002D U+0041 u+006E u+006F
       u+0074 u+0068 u+0065 u+0072 u+002D U+0057 u+0061 u+0079 u+002D
       u+305D u+308C u+305E u+308C u+306E u+5834 u+6240
       Punycode: Hello-Another-Way--fc4qua05auwb3674vfr0b

   (O) &lt;hitotsu&gt;&lt;yane&gt;&lt;no&gt;&lt;shita&gt;2
       u+3072 u+3068 u+3064 u+5C4B u+6839 u+306E u+4E0B u+0032
       Punycode: 2-u9tlzr9756bt3uc0v

   (P) Maji&lt;de&gt;Koi&lt;suru&gt;5&lt;byou&gt;&lt;mae&gt;
       U+004D u+0061 u+006A u+0069 u+3067 U+004B u+006F u+0069 u+3059
       u+308B u+0035 u+79D2 u+524D
       Punycode: MajiKoi5-783gue6qz075azm5e

   (Q) &lt;pafii&gt;de&lt;runba&gt;
       u+30D1 u+30D5 u+30A3 u+30FC u+0064 u+0065 u+30EB u+30F3 u+30D0
       Punycode: de-jg4avhby1noc0d

   (R) &lt;sono&gt;&lt;supiido&gt;&lt;de&gt;
       u+305D u+306E u+30B9 u+30D4 u+30FC u+30C9 u+3067
       Punycode: d9juau41awczczp

   The last example is an ASCII string that breaks the existing rules
   for host name labels.  (It is not a realistic example for IDNA,
   because IDNA never encodes pure ASCII labels.)

   (S) -&gt; $1.00 &lt;-
       u+002D u+003E u+0020 u+0024 u+0031 u+002E u+0030 u+0030 u+0020
       u+003C u+002D
       Punycode: -&gt; $1.00 &lt;--




<span class="grey">Costello                    Standards Track                    [Page 16]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-17" id="page-17" name="page-17"> </a>
<span class="grey"><a href="rfc3492.html">RFC 3492</a>                     IDNA Punycode                    March 2003</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/7.2%20Decoding%20traces"></a><a class="selflink" href="#section-7.2" name="section-7.2">7.2</a> Decoding traces</span>

   In the following traces, the evolving state of the decoder is shown
   as a sequence of hexadecimal values, representing the code points in
   the extended string.  An asterisk appears just after the most
   recently inserted code point, indicating both n (the value preceeding
   the asterisk) and i (the position of the value just after the
   asterisk).  Other numerical values are decimal.

   Decoding trace of example B from <a href="#section-7.1">section 7.1</a>:

   n is 128, i is 0, bias is 72
   input is "ihqwcrb4cv8a8dqg056pqjye"
   there is no delimiter, so extended string starts empty
   delta "ihq" decodes to 19853
   bias becomes 21
   4E0D *
   delta "wc" decodes to 64
   bias becomes 20
   4E0D 4E2D *
   delta "rb" decodes to 37
   bias becomes 13
   4E3A * 4E0D 4E2D
   delta "4c" decodes to 56
   bias becomes 17
   4E3A 4E48 * 4E0D 4E2D
   delta "v8a" decodes to 599
   bias becomes 32
   4E3A 4EC0 * 4E48 4E0D 4E2D
   delta "8d" decodes to 130
   bias becomes 23
   4ED6 * 4E3A 4EC0 4E48 4E0D 4E2D
   delta "qg" decodes to 154
   bias becomes 25
   4ED6 4EEC * 4E3A 4EC0 4E48 4E0D 4E2D
   delta "056p" decodes to 46301
   bias becomes 84
   4ED6 4EEC 4E3A 4EC0 4E48 4E0D 4E2D 6587 *
   delta "qjye" decodes to 88531
   bias becomes 90
   4ED6 4EEC 4E3A 4EC0 4E48 4E0D 8BF4 * 4E2D 6587










<span class="grey">Costello                    Standards Track                    [Page 17]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-18" id="page-18" name="page-18"> </a>
<span class="grey"><a href="rfc3492.html">RFC 3492</a>                     IDNA Punycode                    March 2003</span>


   Decoding trace of example L from <a href="#section-7.1">section 7.1</a>:

   n is 128, i is 0, bias is 72
   input is "3B-ww4c5e180e575a65lsy2b"
   literal portion is "3B-", so extended string starts as:
   0033 0042
   delta "ww4c" decodes to 62042
   bias becomes 27
   0033 0042 5148 *
   delta "5e" decodes to 139
   bias becomes 24
   0033 0042 516B * 5148
   delta "180e" decodes to 16683
   bias becomes 67
   0033 5E74 * 0042 516B 5148
   delta "575a" decodes to 34821
   bias becomes 82
   0033 5E74 0042 516B 5148 751F *
   delta "65l" decodes to 14592
   bias becomes 67
   0033 5E74 0042 7D44 * 516B 5148 751F
   delta "sy2b" decodes to 42088
   bias becomes 84
   0033 5E74 0042 7D44 91D1 * 516B 5148 751F



























<span class="grey">Costello                    Standards Track                    [Page 18]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-19" id="page-19" name="page-19"> </a>
<span class="grey"><a href="rfc3492.html">RFC 3492</a>                     IDNA Punycode                    March 2003</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/7.3%20Encoding%20traces"></a><a class="selflink" href="#section-7.3" name="section-7.3">7.3</a> Encoding traces</span>

   In the following traces, code point values are hexadecimal, while
   other numerical values are decimal.

   Encoding trace of example B from <a href="#section-7.1">section 7.1</a>:

   bias is 72
   input is:
   4ED6 4EEC 4E3A 4EC0 4E48 4E0D 8BF4 4E2D 6587
   there are no basic code points, so no literal portion
   next code point to insert is 4E0D
   needed delta is 19853, encodes as "ihq"
   bias becomes 21
   next code point to insert is 4E2D
   needed delta is 64, encodes as "wc"
   bias becomes 20
   next code point to insert is 4E3A
   needed delta is 37, encodes as "rb"
   bias becomes 13
   next code point to insert is 4E48
   needed delta is 56, encodes as "4c"
   bias becomes 17
   next code point to insert is 4EC0
   needed delta is 599, encodes as "v8a"
   bias becomes 32
   next code point to insert is 4ED6
   needed delta is 130, encodes as "8d"
   bias becomes 23
   next code point to insert is 4EEC
   needed delta is 154, encodes as "qg"
   bias becomes 25
   next code point to insert is 6587
   needed delta is 46301, encodes as "056p"
   bias becomes 84
   next code point to insert is 8BF4
   needed delta is 88531, encodes as "qjye"
   bias becomes 90
   output is "ihqwcrb4cv8a8dqg056pqjye"












<span class="grey">Costello                    Standards Track                    [Page 19]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-20" id="page-20" name="page-20"> </a>
<span class="grey"><a href="rfc3492.html">RFC 3492</a>                     IDNA Punycode                    March 2003</span>


   Encoding trace of example L from <a href="#section-7.1">section 7.1</a>:

   bias is 72
   input is:
   0033 5E74 0042 7D44 91D1 516B 5148 751F
   basic code points (0033, 0042) are copied to literal portion: "3B-"
   next code point to insert is 5148
   needed delta is 62042, encodes as "ww4c"
   bias becomes 27
   next code point to insert is 516B
   needed delta is 139, encodes as "5e"
   bias becomes 24
   next code point to insert is 5E74
   needed delta is 16683, encodes as "180e"
   bias becomes 67
   next code point to insert is 751F
   needed delta is 34821, encodes as "575a"
   bias becomes 82
   next code point to insert is 7D44
   needed delta is 14592, encodes as "65l"
   bias becomes 67
   next code point to insert is 91D1
   needed delta is 42088, encodes as "sy2b"
   bias becomes 84
   output is "3B-ww4c5e180e575a65lsy2b"

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/8.%20Security%20Considerations"></a><a class="selflink" href="#section-8" name="section-8">8</a>. Security Considerations</span>

   Users expect each domain name in DNS to be controlled by a single
   authority.  If a Unicode string intended for use as a domain label
   could map to multiple ACE labels, then an internationalized domain
   name could map to multiple ASCII domain names, each controlled by a
   different authority, some of which could be spoofs that hijack
   service requests intended for another.  Therefore Punycode is
   designed so that each Unicode string has a unique encoding.

   However, there can still be multiple Unicode representations of the
   "same" text, for various definitions of "same".  This problem is
   addressed to some extent by the Unicode standard under the topic of
   canonicalization, and this work is leveraged for domain names by
   Nameprep [<a href="#ref-NAMEPREP" title='"Nameprep: A Stringprep Profile for Internationalized Domain Names (IDN)"'>NAMEPREP</a>].










<span class="grey">Costello                    Standards Track                    [Page 20]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-21" id="page-21" name="page-21"> </a>
<span class="grey"><a href="rfc3492.html">RFC 3492</a>                     IDNA Punycode                    March 2003</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/9.%20References"></a><a class="selflink" href="#section-9" name="section-9">9</a>. References</span>

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/9.1%20Normative%20References"></a><a class="selflink" href="#section-9.1" name="section-9.1">9.1</a> Normative References</span>

   [<a id="ref-RFC2119" name="ref-RFC2119">RFC2119</a>]    Bradner, S., "Key words for use in RFCs to Indicate
                Requirement Levels", <a href="https://tools.ietf.org/html/bcp14">BCP 14</a>, <a href="rfc2119.html">RFC 2119</a>, March 1997.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/9.2%20Informative%20References"></a><a class="selflink" href="#section-9.2" name="section-9.2">9.2</a> Informative References</span>

   [<a id="ref-RFC952" name="ref-RFC952">RFC952</a>]     Harrenstien, K., Stahl, M. and E. Feinler, "DOD Internet
                Host Table Specification", <a href="rfc952.html">RFC 952</a>, October 1985.

   [<a id="ref-RFC1034" name="ref-RFC1034">RFC1034</a>]    Mockapetris, P., "Domain Names - Concepts and
                Facilities", STD 13, <a href="rfc1034.html">RFC 1034</a>, November 1987.

   [<a id="ref-IDNA" name="ref-IDNA">IDNA</a>]       Faltstrom, P., Hoffman, P. and A. Costello,
                "Internationalizing Domain Names in Applications
                (IDNA)", <a href="rfc3490.html">RFC 3490</a>, March 2003.

   [<a id="ref-NAMEPREP" name="ref-NAMEPREP">NAMEPREP</a>]   Hoffman, P. and  M. Blanchet, "Nameprep: A Stringprep
                Profile for Internationalized Domain Names (IDN)", <a href="rfc3491.html">RFC</a>
                <a href="rfc3491.html">3491</a>, March 2003.

   [<a id="ref-ASCII" name="ref-ASCII">ASCII</a>]      Cerf, V., "ASCII format for Network Interchange", <a href="rfc20.html">RFC</a>
                <a href="rfc20.html">20</a>, October 1969.

   [<a id="ref-PROVINCIAL" name="ref-PROVINCIAL">PROVINCIAL</a>] Kaplan, M., "The 'anyone can be provincial!' page",
                <a href="http://www.trigeminal.com/samples/provincial.html">http://www.trigeminal.com/samples/provincial.html</a>.

   [<a id="ref-UNICODE" name="ref-UNICODE">UNICODE</a>]    The Unicode Consortium, "The Unicode Standard",
                <a href="http://www.unicode.org/unicode/standard/standard.html">http://www.unicode.org/unicode/standard/standard.html</a>.




















<span class="grey">Costello                    Standards Track                    [Page 21]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-22" id="page-22" name="page-22"> </a>
<span class="grey"><a href="rfc3492.html">RFC 3492</a>                     IDNA Punycode                    March 2003</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/A.%20Mixed-case%20annotation"></a><a class="selflink" href="#appendix-A" name="appendix-A">A</a>. Mixed-case annotation</span>

   In order to use Punycode to represent case-insensitive strings,
   higher layers need to case-fold the strings prior to Punycode
   encoding.  The encoded string can use mixed case as an annotation
   telling how to convert the folded string into a mixed-case string for
   display purposes.  Note, however, that mixed-case annotation is not
   used by the ToASCII and ToUnicode operations specified in [<a href="#ref-IDNA" title='"Internationalizing Domain Names in Applications (IDNA)"'>IDNA</a>], and
   therefore implementors of IDNA can disregard this appendix.

   Basic code points can use mixed case directly, because the decoder
   copies them verbatim, leaving lowercase code points lowercase, and
   leaving uppercase code points uppercase.  Each non-basic code point
   is represented by a delta, which is represented by a sequence of
   basic code points, the last of which provides the annotation.  If it
   is uppercase, it is a suggestion to map the non-basic code point to
   uppercase (if possible); if it is lowercase, it is a suggestion to
   map the non-basic code point to lowercase (if possible).

   These annotations do not alter the code points returned by decoders;
   the annotations are returned separately, for the caller to use or
   ignore.  Encoders can accept annotations in addition to code points,
   but the annotations do not alter the output, except to influence the
   uppercase/lowercase form of ASCII letters.

   Punycode encoders and decoders need not support these annotations,
   and higher layers need not use them.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/B.%20Disclaimer%20and%20license"></a><a class="selflink" href="#appendix-B" name="appendix-B">B</a>. Disclaimer and license</span>

   Regarding this entire document or any portion of it (including the
   pseudocode and C code), the author makes no guarantees and is not
   responsible for any damage resulting from its use.  The author grants
   irrevocable permission to anyone to use, modify, and distribute it in
   any way that does not diminish the rights of anyone else to use,
   modify, and distribute it, provided that redistributed derivative
   works do not contain misleading author or version information.
   Derivative works need not be licensed under similar terms.













<span class="grey">Costello                    Standards Track                    [Page 22]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-23" id="page-23" name="page-23"> </a>
<span class="grey"><a href="rfc3492.html">RFC 3492</a>                     IDNA Punycode                    March 2003</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/C.%20Punycode%20sample%20implementation"></a><a class="selflink" href="#appendix-C" name="appendix-C">C</a>. Punycode sample implementation</span>

/*
punycode.c from <a href="rfc3492.html">RFC 3492</a>
<a href="http://www.nicemice.net/idn/">http://www.nicemice.net/idn/</a>
Adam M. Costello
<a href="http://www.nicemice.net/amc/">http://www.nicemice.net/amc/</a>

This is ANSI C code (C89) implementing Punycode (<a href="rfc3492.html">RFC 3492</a>).

*/


/************************************************************/
/* Public interface (would normally go in its own .h file): */

#include &lt;limits.h&gt;

enum punycode_status {
  punycode_success,
  punycode_bad_input,   /* Input is invalid.                       */
  punycode_big_output,  /* Output would exceed the space provided. */
  punycode_overflow     /* Input needs wider integers to process.  */
};

#if UINT_MAX &gt;= (1 &lt;&lt; 26) - 1
typedef unsigned int punycode_uint;
#else
typedef unsigned long punycode_uint;
#endif

enum punycode_status punycode_encode(
  punycode_uint input_length,
  const punycode_uint input[],
  const unsigned char case_flags[],
  punycode_uint *output_length,
  char output[] );

    /* punycode_encode() converts Unicode to Punycode.  The input     */
    /* is represented as an array of Unicode code points (not code    */
    /* units; surrogate pairs are not allowed), and the output        */
    /* will be represented as an array of ASCII code points.  The     */
    /* output string is *not* null-terminated; it will contain        */
    /* zeros if and only if the input contains zeros.  (Of course     */
    /* the caller can leave room for a terminator and add one if      */
    /* needed.)  The input_length is the number of code points in     */
    /* the input.  The output_length is an in/out argument: the       */
    /* caller passes in the maximum number of code points that it     */



<span class="grey">Costello                    Standards Track                    [Page 23]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-24" id="page-24" name="page-24"> </a>
<span class="grey"><a href="rfc3492.html">RFC 3492</a>                     IDNA Punycode                    March 2003</span>


    /* can receive, and on successful return it will contain the      */
    /* number of code points actually output.  The case_flags array   */
    /* holds input_length boolean values, where nonzero suggests that */
    /* the corresponding Unicode character be forced to uppercase     */
    /* after being decoded (if possible), and zero suggests that      */
    /* it be forced to lowercase (if possible).  ASCII code points    */
    /* are encoded literally, except that ASCII letters are forced    */
    /* to uppercase or lowercase according to the corresponding       */
    /* uppercase flags.  If case_flags is a null pointer then ASCII   */
    /* letters are left as they are, and other code points are        */
    /* treated as if their uppercase flags were zero.  The return     */
    /* value can be any of the punycode_status values defined above   */
    /* except punycode_bad_input; if not punycode_success, then       */
    /* output_size and output might contain garbage.                  */

enum punycode_status punycode_decode(
  punycode_uint input_length,
  const char input[],
  punycode_uint *output_length,
  punycode_uint output[],
  unsigned char case_flags[] );

    /* punycode_decode() converts Punycode to Unicode.  The input is  */
    /* represented as an array of ASCII code points, and the output   */
    /* will be represented as an array of Unicode code points.  The   */
    /* input_length is the number of code points in the input.  The   */
    /* output_length is an in/out argument: the caller passes in      */
    /* the maximum number of code points that it can receive, and     */
    /* on successful return it will contain the actual number of      */
    /* code points output.  The case_flags array needs room for at    */
    /* least output_length values, or it can be a null pointer if the */
    /* case information is not needed.  A nonzero flag suggests that  */
    /* the corresponding Unicode character be forced to uppercase     */
    /* by the caller (if possible), while zero suggests that it be    */
    /* forced to lowercase (if possible).  ASCII code points are      */
    /* output already in the proper case, but their flags will be set */
    /* appropriately so that applying the flags would be harmless.    */
    /* The return value can be any of the punycode_status values      */
    /* defined above; if not punycode_success, then output_length,    */
    /* output, and case_flags might contain garbage.  On success, the */
    /* decoder will never need to write an output_length greater than */
    /* input_length, because of how the encoding is defined.          */

/**********************************************************/
/* Implementation (would normally go in its own .c file): */

#include &lt;string.h&gt;




<span class="grey">Costello                    Standards Track                    [Page 24]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-25" id="page-25" name="page-25"> </a>
<span class="grey"><a href="rfc3492.html">RFC 3492</a>                     IDNA Punycode                    March 2003</span>


/*** Bootstring parameters for Punycode ***/

enum { base = 36, tmin = 1, tmax = 26, skew = 38, damp = 700,
       initial_bias = 72, initial_n = 0x80, delimiter = 0x2D };

/* basic(cp) tests whether cp is a basic code point: */
#define basic(cp) ((punycode_uint)(cp) &lt; 0x80)

/* delim(cp) tests whether cp is a delimiter: */
#define delim(cp) ((cp) == delimiter)

/* decode_digit(cp) returns the numeric value of a basic code */
/* point (for use in representing integers) in the range 0 to */
/* base-1, or base if cp is does not represent a value.       */

static punycode_uint decode_digit(punycode_uint cp)
{
  return  cp - 48 &lt; 10 ? cp - 22 :  cp - 65 &lt; 26 ? cp - 65 :
          cp - 97 &lt; 26 ? cp - 97 :  base;
}

/* encode_digit(d,flag) returns the basic code point whose value      */
/* (when used for representing integers) is d, which needs to be in   */
/* the range 0 to base-1.  The lowercase form is used unless flag is  */
/* nonzero, in which case the uppercase form is used.  The behavior   */
/* is undefined if flag is nonzero and digit d has no uppercase form. */

static char encode_digit(punycode_uint d, int flag)
{
  return d + 22 + 75 * (d &lt; 26) - ((flag != 0) &lt;&lt; 5);
  /*  0..25 map to ASCII a..z or A..Z */
  /* 26..35 map to ASCII 0..9         */
}

/* flagged(bcp) tests whether a basic code point is flagged */
/* (uppercase).  The behavior is undefined if bcp is not a  */
/* basic code point.                                        */

#define flagged(bcp) ((punycode_uint)(bcp) - 65 &lt; 26)

/* encode_basic(bcp,flag) forces a basic code point to lowercase */
/* if flag is zero, uppercase if flag is nonzero, and returns    */
/* the resulting code point.  The code point is unchanged if it  */
/* is caseless.  The behavior is undefined if bcp is not a basic */
/* code point.                                                   */

static char encode_basic(punycode_uint bcp, int flag)
{



<span class="grey">Costello                    Standards Track                    [Page 25]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-26" id="page-26" name="page-26"> </a>
<span class="grey"><a href="rfc3492.html">RFC 3492</a>                     IDNA Punycode                    March 2003</span>


  bcp -= (bcp - 97 &lt; 26) &lt;&lt; 5;
  return bcp + ((!flag &amp;&amp; (bcp - 65 &lt; 26)) &lt;&lt; 5);
}

/*** Platform-specific constants ***/

/* maxint is the maximum value of a punycode_uint variable: */
static const punycode_uint maxint = -1;
/* Because maxint is unsigned, -1 becomes the maximum value. */

/*** Bias adaptation function ***/

static punycode_uint adapt(
  punycode_uint delta, punycode_uint numpoints, int firsttime )
{
  punycode_uint k;

  delta = firsttime ? delta / damp : delta &gt;&gt; 1;
  /* delta &gt;&gt; 1 is a faster way of doing delta / 2 */
  delta += delta / numpoints;

  for (k = 0;  delta &gt; ((base - tmin) * tmax) / 2;  k += base) {
    delta /= base - tmin;
  }

  return k + (base - tmin + 1) * delta / (delta + skew);
}

/*** Main encode function ***/

enum punycode_status punycode_encode(
  punycode_uint input_length,
  const punycode_uint input[],
  const unsigned char case_flags[],
  punycode_uint *output_length,
  char output[] )
{
  punycode_uint n, delta, h, b, out, max_out, bias, j, m, q, k, t;

  /* Initialize the state: */

  n = initial_n;
  delta = out = 0;
  max_out = *output_length;
  bias = initial_bias;

  /* Handle the basic code points: */




<span class="grey">Costello                    Standards Track                    [Page 26]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-27" id="page-27" name="page-27"> </a>
<span class="grey"><a href="rfc3492.html">RFC 3492</a>                     IDNA Punycode                    March 2003</span>


  for (j = 0;  j &lt; input_length;  ++j) {
    if (basic(input[j])) {
      if (max_out - out &lt; 2) return punycode_big_output;
      output[out++] =
        case_flags ?  encode_basic(input[j], case_flags[j]) : input[j];
    }
    /* else if (input[j] &lt; n) return punycode_bad_input; */
    /* (not needed for Punycode with unsigned code points) */
  }

  h = b = out;

  /* h is the number of code points that have been handled, b is the  */
  /* number of basic code points, and out is the number of characters */
  /* that have been output.                                           */

  if (b &gt; 0) output[out++] = delimiter;

  /* Main encoding loop: */

  while (h &lt; input_length) {
    /* All non-basic code points &lt; n have been     */
    /* handled already.  Find the next larger one: */

    for (m = maxint, j = 0;  j &lt; input_length;  ++j) {
      /* if (basic(input[j])) continue; */
      /* (not needed for Punycode) */
      if (input[j] &gt;= n &amp;&amp; input[j] &lt; m) m = input[j];
    }

    /* Increase delta enough to advance the decoder's    */
    /* &lt;n,i&gt; state to &lt;m,0&gt;, but guard against overflow: */

    if (m - n &gt; (maxint - delta) / (h + 1)) return punycode_overflow;
    delta += (m - n) * (h + 1);
    n = m;

    for (j = 0;  j &lt; input_length;  ++j) {
      /* Punycode does not need to check whether input[j] is basic: */
      if (input[j] &lt; n /* || basic(input[j]) */ ) {
        if (++delta == 0) return punycode_overflow;
      }

      if (input[j] == n) {
        /* Represent delta as a generalized variable-length integer: */

        for (q = delta, k = base;  ;  k += base) {
          if (out &gt;= max_out) return punycode_big_output;



<span class="grey">Costello                    Standards Track                    [Page 27]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-28" id="page-28" name="page-28"> </a>
<span class="grey"><a href="rfc3492.html">RFC 3492</a>                     IDNA Punycode                    March 2003</span>


          t = k &lt;= bias /* + tmin */ ? tmin :     /* +tmin not needed */
              k &gt;= bias + tmax ? tmax : k - bias;
          if (q &lt; t) break;
          output[out++] = encode_digit(t + (q - t) % (base - t), 0);
          q = (q - t) / (base - t);
        }

        output[out++] = encode_digit(q, case_flags &amp;&amp; case_flags[j]);
        bias = adapt(delta, h + 1, h == b);
        delta = 0;
        ++h;
      }
    }

    ++delta, ++n;
  }

  *output_length = out;
  return punycode_success;
}

/*** Main decode function ***/

enum punycode_status punycode_decode(
  punycode_uint input_length,
  const char input[],
  punycode_uint *output_length,
  punycode_uint output[],
  unsigned char case_flags[] )
{
  punycode_uint n, out, i, max_out, bias,
                 b, j, in, oldi, w, k, digit, t;

  /* Initialize the state: */

  n = initial_n;
  out = i = 0;
  max_out = *output_length;
  bias = initial_bias;

  /* Handle the basic code points:  Let b be the number of input code */
  /* points before the last delimiter, or 0 if there is none, then    */
  /* copy the first b code points to the output.                      */

  for (b = j = 0;  j &lt; input_length;  ++j) if (delim(input[j])) b = j;
  if (b &gt; max_out) return punycode_big_output;

  for (j = 0;  j &lt; b;  ++j) {



<span class="grey">Costello                    Standards Track                    [Page 28]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-29" id="page-29" name="page-29"> </a>
<span class="grey"><a href="rfc3492.html">RFC 3492</a>                     IDNA Punycode                    March 2003</span>


    if (case_flags) case_flags[out] = flagged(input[j]);
    if (!basic(input[j])) return punycode_bad_input;
    output[out++] = input[j];
  }

  /* Main decoding loop:  Start just after the last delimiter if any  */
  /* basic code points were copied; start at the beginning otherwise. */

  for (in = b &gt; 0 ? b + 1 : 0;  in &lt; input_length;  ++out) {

    /* in is the index of the next character to be consumed, and */
    /* out is the number of code points in the output array.     */

    /* Decode a generalized variable-length integer into delta,  */
    /* which gets added to i.  The overflow checking is easier   */
    /* if we increase i as we go, then subtract off its starting */
    /* value at the end to obtain delta.                         */

    for (oldi = i, w = 1, k = base;  ;  k += base) {
      if (in &gt;= input_length) return punycode_bad_input;
      digit = decode_digit(input[in++]);
      if (digit &gt;= base) return punycode_bad_input;
      if (digit &gt; (maxint - i) / w) return punycode_overflow;
      i += digit * w;
      t = k &lt;= bias /* + tmin */ ? tmin :     /* +tmin not needed */
          k &gt;= bias + tmax ? tmax : k - bias;
      if (digit &lt; t) break;
      if (w &gt; maxint / (base - t)) return punycode_overflow;
      w *= (base - t);
    }

    bias = adapt(i - oldi, out + 1, oldi == 0);

    /* i was supposed to wrap around from out+1 to 0,   */
    /* incrementing n each time, so we'll fix that now: */

    if (i / (out + 1) &gt; maxint - n) return punycode_overflow;
    n += i / (out + 1);
    i %= (out + 1);

    /* Insert n at position i of the output: */

    /* not needed for Punycode: */
    /* if (decode_digit(n) &lt;= base) return punycode_invalid_input; */
    if (out &gt;= max_out) return punycode_big_output;

    if (case_flags) {
      memmove(case_flags + i + 1, case_flags + i, out - i);



<span class="grey">Costello                    Standards Track                    [Page 29]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-30" id="page-30" name="page-30"> </a>
<span class="grey"><a href="rfc3492.html">RFC 3492</a>                     IDNA Punycode                    March 2003</span>


      /* Case of last character determines uppercase flag: */
      case_flags[i] = flagged(input[in - 1]);
    }

    memmove(output + i + 1, output + i, (out - i) * sizeof *output);
    output[i++] = n;
  }

  *output_length = out;
  return punycode_success;
}

/******************************************************************/
/* Wrapper for testing (would normally go in a separate .c file): */

#include &lt;assert.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

/* For testing, we'll just set some compile-time limits rather than */
/* use malloc(), and set a compile-time option rather than using a  */
/* command-line option.                                             */

enum {
  unicode_max_length = 256,
  ace_max_length = 256
};

static void usage(char **argv)
{
  fprintf(stderr,
    "\n"
    "%s -e reads code points and writes a Punycode string.\n"
    "%s -d reads a Punycode string and writes code points.\n"
    "\n"
    "Input and output are plain text in the native character set.\n"
    "Code points are in the form u+hex separated by whitespace.\n"
    "Although the specification allows Punycode strings to contain\n"
    "any characters from the ASCII repertoire, this test code\n"
    "supports only the printable characters, and needs the Punycode\n"
    "string to be followed by a newline.\n"
    "The case of the u in u+hex is the force-to-uppercase flag.\n"
    , argv[0], argv[0]);
  exit(EXIT_FAILURE);
}

static void fail(const char *msg)



<span class="grey">Costello                    Standards Track                    [Page 30]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-31" id="page-31" name="page-31"> </a>
<span class="grey"><a href="rfc3492.html">RFC 3492</a>                     IDNA Punycode                    March 2003</span>


{
  fputs(msg,stderr);
  exit(EXIT_FAILURE);
}

static const char too_big[] =
  "input or output is too large, recompile with larger limits\n";
static const char invalid_input[] = "invalid input\n";
static const char overflow[] = "arithmetic overflow\n";
static const char io_error[] = "I/O error\n";

/* The following string is used to convert printable */
/* characters between ASCII and the native charset:  */

static const char print_ascii[] =
  "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  " !\"#$%&amp;'()*+,-./"
  "0123456789:;&lt;=&gt;?"
  "@ABCDEFGHIJKLMNO"
  "PQRSTUVWXYZ[\\]^_"
  "`abcdefghijklmno"
  "pqrstuvwxyz{|}~\n";

int main(int argc, char **argv)
{
  enum punycode_status status;
  int r;
  unsigned int input_length, output_length, j;
  unsigned char case_flags[unicode_max_length];

  if (argc != 2) usage(argv);
  if (argv[1][0] != '-') usage(argv);
  if (argv[1][2] != 0) usage(argv);

  if (argv[1][1] == 'e') {
    punycode_uint input[unicode_max_length];
    unsigned long codept;
    char output[ace_max_length+1], uplus[3];
    int c;

    /* Read the input code points: */

    input_length = 0;

    for (;;) {
      r = scanf("%2s%lx", uplus, &amp;codept);
      if (ferror(stdin)) fail(io_error);



<span class="grey">Costello                    Standards Track                    [Page 31]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-32" id="page-32" name="page-32"> </a>
<span class="grey"><a href="rfc3492.html">RFC 3492</a>                     IDNA Punycode                    March 2003</span>


      if (r == EOF || r == 0) break;

      if (r != 2 || uplus[1] != '+' || codept &gt; (punycode_uint)-1) {
        fail(invalid_input);
      }

      if (input_length == unicode_max_length) fail(too_big);

      if (uplus[0] == 'u') case_flags[input_length] = 0;
      else if (uplus[0] == 'U') case_flags[input_length] = 1;
      else fail(invalid_input);

      input[input_length++] = codept;
    }

    /* Encode: */

    output_length = ace_max_length;
    status = punycode_encode(input_length, input, case_flags,
                             &amp;output_length, output);
    if (status == punycode_bad_input) fail(invalid_input);
    if (status == punycode_big_output) fail(too_big);
    if (status == punycode_overflow) fail(overflow);
    assert(status == punycode_success);

    /* Convert to native charset and output: */

    for (j = 0;  j &lt; output_length;  ++j) {
      c = output[j];
      assert(c &gt;= 0 &amp;&amp; c &lt;= 127);
      if (print_ascii[c] == 0) fail(invalid_input);
      output[j] = print_ascii[c];
    }

    output[j] = 0;
    r = puts(output);
    if (r == EOF) fail(io_error);
    return EXIT_SUCCESS;
  }

  if (argv[1][1] == 'd') {
    char input[ace_max_length+2], *p, *pp;
    punycode_uint output[unicode_max_length];

    /* Read the Punycode input string and convert to ASCII: */

    fgets(input, ace_max_length+2, stdin);
    if (ferror(stdin)) fail(io_error);



<span class="grey">Costello                    Standards Track                    [Page 32]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-33" id="page-33" name="page-33"> </a>
<span class="grey"><a href="rfc3492.html">RFC 3492</a>                     IDNA Punycode                    March 2003</span>


    if (feof(stdin)) fail(invalid_input);
    input_length = strlen(input) - 1;
    if (input[input_length] != '\n') fail(too_big);
    input[input_length] = 0;

    for (p = input;  *p != 0;  ++p) {
      pp = strchr(print_ascii, *p);
      if (pp == 0) fail(invalid_input);
      *p = pp - print_ascii;
    }

    /* Decode: */

    output_length = unicode_max_length;
    status = punycode_decode(input_length, input, &amp;output_length,
                             output, case_flags);
    if (status == punycode_bad_input) fail(invalid_input);
    if (status == punycode_big_output) fail(too_big);
    if (status == punycode_overflow) fail(overflow);
    assert(status == punycode_success);

    /* Output the result: */

    for (j = 0;  j &lt; output_length;  ++j) {
      r = printf("%s+%04lX\n",
                 case_flags[j] ? "U" : "u",
                 (unsigned long) output[j] );
      if (r &lt; 0) fail(io_error);
    }

    return EXIT_SUCCESS;
  }

  usage(argv);
  return EXIT_SUCCESS;  /* not reached, but quiets compiler warning */
}















<span class="grey">Costello                    Standards Track                    [Page 33]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-34" id="page-34" name="page-34"> </a>
<span class="grey"><a href="rfc3492.html">RFC 3492</a>                     IDNA Punycode                    March 2003</span>


Author's Address

   Adam M. Costello
   University of California, Berkeley
   <a href="http://www.nicemice.net/amc/">http://www.nicemice.net/amc/</a>














































<span class="grey">Costello                    Standards Track                    [Page 34]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-35" id="page-35" name="page-35"> </a>
<span class="grey"><a href="rfc3492.html">RFC 3492</a>                     IDNA Punycode                    March 2003</span>


Full Copyright Statement

   Copyright (C) The Internet Society (2003).  All Rights Reserved.

   This document and translations of it may be copied and furnished to
   others, and derivative works that comment on or otherwise explain it
   or assist in its implementation may be prepared, copied, published
   and distributed, in whole or in part, without restriction of any
   kind, provided that the above copyright notice and this paragraph are
   included on all such copies and derivative works.  However, this
   document itself may not be modified in any way, such as by removing
   the copyright notice or references to the Internet Society or other
   Internet organizations, except as needed for the purpose of
   developing Internet standards in which case the procedures for
   copyrights defined in the Internet Standards process must be
   followed, or as required to translate it into languages other than
   English.

   The limited permissions granted above are perpetual and will not be
   revoked by the Internet Society or its successors or assigns.

   This document and the information contained herein is provided on an
   "AS IS" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING
   TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING
   BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION
   HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF
   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.

Acknowledgement

   Funding for the RFC Editor function is currently provided by the
   Internet Society.



















Costello                    Standards Track                    [Page 35]

</pre><br/>
    <span class="noprint"><small><small>Html markup produced by rfcmarkup 1.126, available from
      <a href="https://tools.ietf.org/tools/rfcmarkup/">https://tools.ietf.org/tools/rfcmarkup/</a>
    </small></small></span>
  </div>




</body><!-- Mirrored from tools.ietf.org/html/rfc3492 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 06 Mar 2018 23:18:47 GMT --></html>