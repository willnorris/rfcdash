<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml"><!-- Mirrored from tools.ietf.org/html/rfc7806 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 06 Mar 2018 23:18:19 GMT --><!-- Added by HTTrack --><head><meta content="text/html;charset=utf-8" http-equiv="content-type"/><!-- /Added by HTTrack -->

    <meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
    <meta content="index,follow" name="robots"/>
    <meta content="rfcmarkup version 1.126" name="creator"/>
    <link href="http://purl.org/dc/elements/1.1/" rel="schema.DC"/>
<meta content="draft-baker-aqm-sfq-implementation" name="DC.Relation.Replaces"/>
<meta content="urn:ietf:rfc:7806" name="DC.Identifier"/>
<meta content="April, 2016" name="DC.Date.Issued"/>
<meta content="Pan, Rong" name="DC.Creator"/>
<meta content="Baker, Fred" name="DC.Creator"/>
<meta content="This note discusses queuing and marking/dropping algorithms. While
these algorithms may be implemented in a coupled manner, this note
argues that specifications, measurements, and comparisons should
decouple the different algorithms and their contributions to system
behavior." name="DC.Description.Abstract"/>
<meta content="On Queuing, Marking, and Dropping" name="DC.Title"/>

    <link href="https://tools.ietf.org/images/rfc.png" rel="icon" type="image/png"/>
    <link href="https://tools.ietf.org/images/rfc.png" rel="shortcut icon" type="image/png"/>
    <title>RFC 7806 - On Queuing, Marking, and Dropping</title>
    
    
    <style type="text/css">
	@media only screen 
	  and (min-width: 992px)
	  and (max-width: 1199px) {
	    body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 768px)
	  and (max-width: 991px) {
            body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 480px)
	  and (max-width: 767px) {
            body { font-size: 11pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (max-width: 479px) {
            body { font-size: 8pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-device-width : 375px) 
	  and (max-device-width : 667px) {
            body { font-size: 9.5pt; }
            div.content { width: 96ex; margin: 0 1px; }
        }
	@media only screen 
	  and (min-device-width: 1200px) {
            body { font-size: 10pt; margin: 0 4em; }
            div.content { width: 96ex; margin: 0; }
        }
        h1, h2, h3, h4, h5, h6, .h1, .h2, .h3, .h4, .h5, .h6 {
	    font-weight: bold;
            line-height: 0pt;
            display: inline;
            white-space: pre;
            font-family: monospace;
            font-size: 1em;
	    font-weight: bold;
        }
        pre {
            font-size: 1em;
            margin-top: 0px;
            margin-bottom: 0px;
        }
	.pre {
	    white-space: pre;
	    font-family: monospace;
	}
	.header{
	    font-weight: bold;
	}
        .newpage {
            page-break-before: always;
        }
        .invisible {
            text-decoration: none;
            color: white;
        }
        a.selflink {
          color: black;
          text-decoration: none;
        }
        @media print {
            body {
                font-family: monospace;
                font-size: 10.5pt;
            }
            h1, h2, h3, h4, h5, h6 {
                font-size: 1em;
            }
        
            a:link, a:visited {
                color: inherit;
                text-decoration: none;
            }
            .noprint {
                display: none;
            }
        }
	@media screen {
	    .grey, .grey a:link, .grey a:visited {
		color: #777;
	    }
            .docinfo {
                background-color: #EEE;
            }
            .top {
                border-top: 7px solid #EEE;
            }
            .bgwhite  { background-color: white; }
            .bgred    { background-color: #F44; }
            .bggrey   { background-color: #666; }
            .bgbrown  { background-color: #840; }            
            .bgorange { background-color: #FA0; }
            .bgyellow { background-color: #EE0; }
            .bgmagenta{ background-color: #F4F; }
            .bgblue   { background-color: #66F; }
            .bgcyan   { background-color: #4DD; }
            .bggreen  { background-color: #4F4; }

            .legend   { font-size: 90%; }
            .cplate   { font-size: 70%; border: solid grey 1px; }
	}
    </style>
    <!--[if IE]>
    <style>
    body {
       font-size: 13px;
       margin: 10px 10px;
    }
    </style>
    <![endif]-->

    <script type="text/javascript"><!--
    function addHeaderTags() {
	var spans = document.getElementsByTagName("span");
	for (var i=0; i < spans.length; i++) {
	    var elem = spans[i];
	    if (elem) {
		var level = elem.getAttribute("class");
                if (level == "h1" || level == "h2" || level == "h3" || level == "h4" || level == "h5" || level == "h6") {
                    elem.innerHTML = "<"+level+">"+elem.innerHTML+"</"+level+">";		
                }
	    }
	}
    }
    var legend_html = "Colour legend:<br />      <table>         <tr><td>Unknown:</td>                   <td><span class='cplate bgwhite'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft:</td>                     <td><span class='cplate bgred'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Informational:</td>             <td><span class='cplate bgorange'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Experimental:</td>              <td><span class='cplate bgyellow'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Best Common Practice:</td>      <td><span class='cplate bgmagenta'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Proposed Standard:</td>         <td><span class='cplate bgblue'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft Standard (old designation):</td> <td><span class='cplate bgcyan'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Internet Standard:</td>         <td><span class='cplate bggreen'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Historic:</td>                  <td><span class='cplate bggrey'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Obsolete:</td>                  <td><span class='cplate bgbrown'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>     </table>";
    function showElem(id) {
        var elem = document.getElementById(id);
        elem.innerHTML = eval(id+"_html");
        elem.style.visibility='visible';
    }
    function hideElem(id) {
        var elem = document.getElementById(id);
        elem.style.visibility='hidden';        
        elem.innerHTML = "";
    }
    // -->
    </script>
</head>
<body onload="addHeaderTags()">
  <div class="content">
   <div style="height: 13px;">
      <div class="pre noprint docinfo bgorange" onclick="showElem('legend');" onmouseout="hideElem('legend')" onmouseover="this.style.cursor='pointer';" style="height: 6px; position: absolute;" title="Click for colour legend.">                                                                        </div>
      <div class="docinfo noprint pre legend" id="legend" onmouseout="hideElem('legend');" onmouseover="showElem('legend');" style="position:absolute; top: 4px; left: 4ex; visibility:hidden; background-color: white; padding: 4px 9px 5px 7px; border: solid #345 1px; ">
      </div>
   </div>
<span class="pre noprint docinfo top">[<a href="index.html" title="Document search and retrieval page">Docs</a>] [<a href="https://tools.ietf.org/rfc/rfc7806.txt" title="Plaintext version of this document">txt</a>|<a href="https://tools.ietf.org/pdf/rfc7806" title="PDF version of this document">pdf</a>] [<a href="https://tools.ietf.org/html/draft-ietf-aqm-fq-implementation" title="draft-ietf-aqm-fq-implementation">draft-ietf-aqm-...</a>] [<a href="https://datatracker.ietf.org/doc/rfc7806" title="IESG Datatracker information for this document">Tracker</a>] [<a href="https://tools.ietf.org/rfcdiff?difftype=--hwdiff&amp;url2=rfc7806" title="Inline diff (wdiff)">Diff1</a>] [<a href="https://tools.ietf.org/rfcdiff?url2=rfc7806" title="Side-by-side diff">Diff2</a>]         </span><br/>
<span class="pre noprint docinfo">                                                                        </span><br/>
<span class="pre noprint docinfo">                                                           INFORMATIONAL</span><br/>
<span class="pre noprint docinfo">                                                                        </span><br/>
<pre>Internet Engineering Task Force (IETF)                          F. Baker
Request for Comments: 7806                                        R. Pan
Category: Informational                                    Cisco Systems
ISSN: 2070-1721                                               April 2016


                   <span class="h1">On Queuing, Marking, and Dropping</span>

Abstract

   This note discusses queuing and marking/dropping algorithms.  While
   these algorithms may be implemented in a coupled manner, this note
   argues that specifications, measurements, and comparisons should
   decouple the different algorithms and their contributions to system
   behavior.

Status of This Memo

   This document is not an Internet Standards Track specification; it is
   published for informational purposes.

   This document is a product of the Internet Engineering Task Force
   (IETF).  It represents the consensus of the IETF community.  It has
   received public review and has been approved for publication by the
   Internet Engineering Steering Group (IESG).  Not all documents
   approved by the IESG are a candidate for any level of Internet
   Standard; see <a href="rfc5741.html#section-2">Section 2 of RFC 5741</a>.

   Information about the current status of this document, any errata,
   and how to provide feedback on it may be obtained at
   <a href="http://www.rfc-editor.org/info/rfc7806">http://www.rfc-editor.org/info/rfc7806</a>.

Copyright Notice

   Copyright (c) 2016 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to <a href="https://tools.ietf.org/html/bcp78">BCP 78</a> and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (<a href="http://trustee.ietf.org/license-info">http://trustee.ietf.org/license-info</a>) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.





<span class="grey">Baker &amp; Pan                   Informational                     [Page 1]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-2" id="page-2" name="page-2"> </a>
<span class="grey"><a href="rfc7806.html">RFC 7806</a>            On Queuing, Marking, and Dropping         April 2016</span>


Table of Contents

   <a href="#section-1">1</a>.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   <a href="#page-2">2</a>
   <a href="#section-2">2</a>.  Fair Queuing: Algorithms and History  . . . . . . . . . . . .   <a href="#page-3">3</a>
     <a href="#section-2.1">2.1</a>.  Generalized Processor Sharing . . . . . . . . . . . . . .   <a href="#page-3">3</a>
       <a href="#section-2.1.1">2.1.1</a>.  GPS Comparisons: Transmission Quanta  . . . . . . . .   <a href="#page-4">4</a>
       <a href="#section-2.1.2">2.1.2</a>.  GPS Comparisons: Flow Definition  . . . . . . . . . .   <a href="#page-4">4</a>
       <a href="#section-2.1.3">2.1.3</a>.  GPS Comparisons: Unit of Measurement  . . . . . . . .   <a href="#page-5">5</a>
     <a href="#section-2.2">2.2</a>.  GPS Approximations  . . . . . . . . . . . . . . . . . . .   <a href="#page-5">5</a>
       <a href="#section-2.2.1">2.2.1</a>.  Definition of a Queuing Algorithm . . . . . . . . . .   <a href="#page-5">5</a>
       <a href="#section-2.2.2">2.2.2</a>.  Round-Robin Models  . . . . . . . . . . . . . . . . .   <a href="#page-6">6</a>
       <a href="#section-2.2.3">2.2.3</a>.  Calendar Queue Models . . . . . . . . . . . . . . . .   <a href="#page-7">7</a>
       2.2.4.  Work-Conserving Models and Stochastic Fairness
               Queuing . . . . . . . . . . . . . . . . . . . . . . .   <a href="#page-9">9</a>
       <a href="#section-2.2.5">2.2.5</a>.  Non-Work-Conserving Models and Virtual Clock  . . . .   <a href="#page-9">9</a>
   <a href="#section-3">3</a>.  Queuing, Marking, and Dropping  . . . . . . . . . . . . . . .  <a href="#page-10">10</a>
     <a href="#section-3.1">3.1</a>.  Queuing with Tail Mark/Drop . . . . . . . . . . . . . . .  <a href="#page-11">11</a>
     <a href="#section-3.2">3.2</a>.  Queuing with CoDel Mark/Drop  . . . . . . . . . . . . . .  <a href="#page-11">11</a>
     <a href="#section-3.3">3.3</a>.  Queuing with RED or PIE Mark/Drop . . . . . . . . . . . .  <a href="#page-11">11</a>
   <a href="#section-4">4</a>.  Conclusion  . . . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-12">12</a>
   <a href="#section-5">5</a>.  Security Considerations . . . . . . . . . . . . . . . . . . .  <a href="#page-13">13</a>
   <a href="#section-6">6</a>.  References  . . . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-13">13</a>
     <a href="#section-6.1">6.1</a>.  Normative References  . . . . . . . . . . . . . . . . . .  <a href="#page-13">13</a>
     <a href="#section-6.2">6.2</a>.  Informative References  . . . . . . . . . . . . . . . . .  <a href="#page-13">13</a>
   Acknowledgements  . . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-15">15</a>
   Authors' Addresses  . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-16">16</a>

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/1.%20%20Introduction"></a><a class="selflink" href="#section-1" name="section-1">1</a>.  Introduction</span>

   In the discussion of Active Queue Management (AQM), there has been
   discussion of the coupling of queue management algorithms such as
   Stochastic Fairness Queuing [<a href="#ref-SFQ" title='"Stochastic Fairness Queuing"'>SFQ</a>], Virtual Clock [<a href="#ref-VirtualClock">VirtualClock</a>], or
   Deficit Round Robin [<a href="#ref-DRR" title='"Efficient fair queuing using deficit round-robin"'>DRR</a>] with mark/drop algorithms such as
   Controlled Delay (CoDel) [<a href="#ref-DELAY-AQM" title='"Controlled Delay Active Queue Management"'>DELAY-AQM</a>] or Proportional Integral
   controller Enhanced (PIE) [<a href="#ref-AQM-PIE" title='"PIE: A Lightweight Control Scheme To Address the Bufferbloat Problem"'>AQM-PIE</a>].  In the interest of clarifying
   the discussion, we document possible implementation approaches to
   that and analyze the possible effects and side effects.  The language
   and model derive from the Architecture for Differentiated Services
   [<a href="rfc2475.html" title='"An Architecture for Differentiated Services"'>RFC2475</a>].

   This note is informational and is intended to describe reasonable
   possibilities without constraining outcomes.  This is not so much
   about "right" or "wrong" as it is "what might be reasonable" and
   discusses several possible implementation strategies.  Also, while
   queuing might be implemented in almost any layer, the note
   specifically addresses queues that might be used in the
   Differentiated Services Architecture and are therefore at or below
   the IP layer.



<span class="grey">Baker &amp; Pan                   Informational                     [Page 2]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-3" id="page-3" name="page-3"> </a>
<span class="grey"><a href="rfc7806.html">RFC 7806</a>            On Queuing, Marking, and Dropping         April 2016</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/2.%20%20Fair%20Queuing%3A%20Algorithms%20and%20History"></a><a class="selflink" href="#section-2" name="section-2">2</a>.  Fair Queuing: Algorithms and History</span>

   There is extensive history in the set of algorithms collectively
   referred to as "fair queuing".  The model was initially discussed in
   [<a href="rfc970.html" title='"On Packet Switches With Infinite Storage"'>RFC970</a>], which proposed it hypothetically as a solution to the TCP
   Silly Window Syndrome issue in BSD 4.1.  The problem was that, due to
   a TCP implementation bug, some senders would settle into sending a
   long stream of very short segments, which unnecessarily consumed
   bandwidth on TCP and IP headers and occupied short packet buffers,
   thereby disrupting competing sessions.  Nagle suggested that if
   packet streams were sorted by their source address and the sources
   treated in a round-robin fashion, a sender's effect on end-to-end
   latency and increased loss rate would primarily affect only itself.
   This touched off perhaps a decade of work by various researchers on
   what was and is termed "fair queuing", philosophical discussions of
   the meaning of the word "fair", operational reasons that one might
   want a "weighted" or "predictably unfair" queuing algorithm, and so
   on.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/2.1.%20%20Generalized%20Processor%20Sharing"></a><a class="selflink" href="#section-2.1" name="section-2.1">2.1</a>.  Generalized Processor Sharing</span>

   Conceptually, any fair queuing algorithm attempts to implement some
   approximation to the Generalized Processor Sharing [<a href="#ref-GPS" title='"Analysis and Simulation of a Fair Queueing Algorithm"'>GPS</a>] model.

   The GPS model, in its essence, presumes that a set of identified data
   streams, called "flows", pass through an interface.  Each flow has a
   rate when measured over a period of time; a voice session might, for
   example, require 64 kbit/s plus whatever overhead is necessary to
   deliver it, and a TCP session might have variable throughput
   depending on where it is in its evolution.  The premise of
   Generalized Processor Sharing is that on all time scales, the flow
   occupies a predictable bit rate so that if there is enough bandwidth
   for the flow in the long term, it also lacks nothing in the short
   term.  "All time scales" is obviously untenable in a packet network
   -- and even in a traditional Time-Division Multiplexer (TDM) circuit
   switch network -- because a timescale shorter than the duration of a
   packet will only see one packet at a time.  However, it provides an
   ideal for other models to be compared against.

   There are a number of attributes of approximations to the GPS model
   that bear operational consideration, including at least the
   transmission quanta, the definition of a "flow", and the unit of
   measurement.  Implementation approaches have different practical
   impacts as well.







<span class="grey">Baker &amp; Pan                   Informational                     [Page 3]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-4" id="page-4" name="page-4"> </a>
<span class="grey"><a href="rfc7806.html">RFC 7806</a>            On Queuing, Marking, and Dropping         April 2016</span>


<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/2.1.1.%20%20GPS%20Comparisons%3A%20Transmission%20Quanta"></a><a class="selflink" href="#section-2.1.1" name="section-2.1.1">2.1.1</a>.  GPS Comparisons: Transmission Quanta</span>

   The most obvious comparison between the GPS model and common
   approximations to it is that real world data is not delivered
   uniformly, but in some quantum.  The smallest quantum in a packet
   network is a packet.  But quanta can be larger; for example, in video
   applications, it is common to describe data flow in frames per
   second, where a frame describes a picture on a screen or the changes
   made from a previous one.  A single video frame is commonly on the
   order of tens of packets.  If a codec is delivering thirty frames per
   second, it is conceivable that the packets comprising a frame might
   be sent as thirty bursts per second, with each burst sent at the
   interface rate of the camera or other sender.  Similarly, TCP
   exchanges have an initial window (common values of which include 1,
   2, 3, 4 [<a href="rfc3390.html" title="&quot;Increasing TCP's Initial Window&quot;">RFC3390</a>], and 10 [<a href="rfc6928.html" title="&quot;Increasing TCP's Initial Window&quot;">RFC6928</a>]), and there are also reports of
   bursts of 64 KB at the relevant Maximum Segment Size (MSS), which is
   to say about 45 packets in one burst, presumably coming from TCP
   Segment Offload ((TSO) also called TCP Offload Engine (TOE)) engines
   (at least one implementation is known to be able to send a burst of
   256 KB).  After that initial burst, TCP senders commonly send pairs
   of packets but may send either smaller or larger bursts [<a href="rfc5690.html" title='"Adding Acknowledgement Congestion Control to TCP"'>RFC5690</a>].

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/2.1.2.%20%20GPS%20Comparisons%3A%20Flow%20Definition"></a><a class="selflink" href="#section-2.1.2" name="section-2.1.2">2.1.2</a>.  GPS Comparisons: Flow Definition</span>

   An important engineering trade-off relevant to GPS is the definition
   of a "flow".  A flow is, by definition, a defined data stream.
   Common definitions include:

   o  packets in a single transport layer session ("microflow"),
      identified by a five-tuple [<a href="rfc2990.html" title='"Next Steps for the IP QoS Architecture"'>RFC2990</a>];

   o  packets between a single pair of addresses, identified by a source
      and destination address or prefix;

   o  packets from a single source address or prefix [<a href="rfc970.html" title='"On Packet Switches With Infinite Storage"'>RFC970</a>];

   o  packets to a single destination address or prefix; and

   o  packets to or from a single subscriber, customer, or peer
      [<a href="rfc6057.html" title="&quot;Comcast's Protocol-Agnostic Congestion Management System&quot;">RFC6057</a>].  In Service Provider operations, this might be a
      neighboring Autonomous System; in broadband, this might be a
      residential customer.

   The difference should be apparent.  Consider a comparison between
   sorting by source address or destination address, to pick two
   examples, in the case that a given router interface has N application
   sessions going through it between N/2 local destinations and N remote
   sources.  Sorting by source, or in this case by source/destination



<span class="grey">Baker &amp; Pan                   Informational                     [Page 4]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-5" id="page-5" name="page-5"> </a>
<span class="grey"><a href="rfc7806.html">RFC 7806</a>            On Queuing, Marking, and Dropping         April 2016</span>


   pair, would give each remote peer an upper-bound guarantee of 1/N of
   the available capacity, which might be distributed very unevenly
   among the local destinations.  Sorting by destination would give each
   local destination an upper-bound guarantee of 2/N of the available
   capacity, which might be distributed very unevenly among the remote
   systems and correlated sessions.  Who is one fair to?  In both cases,
   they deliver equal service by their definition, but that might not be
   someone else's definition.

   Flow fairness, and the implications of TCP's congestion avoidance
   algorithms, is discussed extensively in [<a href="#ref-NoFair" title='"Flow rate fairness: dismantling a religion"'>NoFair</a>].

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/2.1.3.%20%20GPS%20Comparisons%3A%20Unit%20of%20Measurement"></a><a class="selflink" href="#section-2.1.3" name="section-2.1.3">2.1.3</a>.  GPS Comparisons: Unit of Measurement</span>

   And finally, there is the question of what is measured for rate.  If
   the only objective is to force packet streams to not dominate each
   other, it is sufficient to count packets.  However, if the issue is
   the bit rate of a Service Level Agreement (SLA), one must consider
   the sizes of the packets (the aggregate throughput of a flow measured
   in bits or bytes).  If predictable unfairness is a consideration, the
   value must be weighted accordingly.

   [<a id="ref-RFC7141" name="ref-RFC7141">RFC7141</a>] discusses measurement.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/2.2.%20%20GPS%20Approximations"></a><a class="selflink" href="#section-2.2" name="section-2.2">2.2</a>.  GPS Approximations</span>

   Carrying the matter further, a queuing algorithm may also be termed
   "work conserving" or "non work conserving".  A queue in a work-
   conserving algorithm, by definition, is either empty, in which case
   no attempt is being made to dequeue data from it, or contains
   something, in which case the algorithm continuously tries to empty
   the queue.  A work-conserving queue that contains queued data at an
   interface with a given rate will deliver data at that rate until it
   empties.  A non-work-conserving queue might stop delivering even
   though it still contains data.  A common reason for doing this is to
   impose an artificial upper bound on a class of traffic that is lower
   than the rate of the underlying physical interface.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/2.2.1.%20%20Definition%20of%20a%20Queuing%20Algorithm"></a><a class="selflink" href="#section-2.2.1" name="section-2.2.1">2.2.1</a>.  Definition of a Queuing Algorithm</span>

   In the discussion following, we assume a basic definition of a
   queuing algorithm.  A queuing algorithm has, at minimum:

   o  some form of internal storage for the elements kept in the queue;







<span class="grey">Baker &amp; Pan                   Informational                     [Page 5]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-6" id="page-6" name="page-6"> </a>
<span class="grey"><a href="rfc7806.html">RFC 7806</a>            On Queuing, Marking, and Dropping         April 2016</span>


   o  if it has multiple internal classifications, then it has

      *  a method for classifying elements and

      *  additional storage for the classifier and implied classes;

   o  potentially, a method for creating the queue;

   o  potentially, a method for destroying the queue;

   o  an enqueuing method for placing packets into the queue or queuing
      system; and

   o  a dequeuing method for removing packets from the queue or queuing
      system.

   There may also be other information or methods, such as the ability
   to inspect the queue.  It also often has inspectable external
   attributes, such as the total volume of packets or bytes in queue,
   and may have limit thresholds, such as a maximum number of packets or
   bytes the queue might hold.

   For example, a simple FIFO queue has a linear data structure,
   enqueues packets at the tail, and dequeues packets from the head.  It
   might have a maximum queue depth and a current queue depth maintained
   in packets or bytes.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/2.2.2.%20%20Round-Robin%20Models"></a><a class="selflink" href="#section-2.2.2" name="section-2.2.2">2.2.2</a>.  Round-Robin Models</span>

   One class of implementation approaches, generically referred to as
   "Weighted Round Robin" (WRR), implements the structure of the queue
   as an array or ring of subqueues associated with flows for whatever
   definition of a flow is important.

   The arriving packet must, of course, first be classified.  If a hash
   is used as a classifier, the hash result might be used as an array
   index, selecting the subqueue that the packet will go into.  One can
   imagine other classifiers, such as using a Differentiated Services
   Code Point (DSCP) value as an index into an array containing the
   queue number for a flow, or more complex access list implementations.

   In any event, a subqueue contains the traffic for a flow, and data is
   sent from each subqueue in succession.

   Upon entering the queue, the enqueue method places a classified
   packet into a simple FIFO subqueue.





<span class="grey">Baker &amp; Pan                   Informational                     [Page 6]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-7" id="page-7" name="page-7"> </a>
<span class="grey"><a href="rfc7806.html">RFC 7806</a>            On Queuing, Marking, and Dropping         April 2016</span>


   On dequeue, the subqueues are searched in round-robin order, and when
   a subqueue is identified that contains data, the dequeue method
   removes a specified quantum of data from it.  That quantum is at
   minimum a packet, but it may be more.  If the system is intended to
   maintain a byte rate, there will be memory between searches of the
   excess previously dequeued.

                            +-+
                          +&gt;|1|
                          | +-+
                          |  |
                          | +-+               +-+
                          | |1|             +&gt;|3|
                          | +-+             | +-+
                          |  |              |  |
                          | +-+      +-+    | +-+
                          | |1|    +&gt;|2|    | |3|
                          | +-+    | +-+    | +-+
                          |  A     |  A     |  A
                          |  |     |  |     |  |
                         ++--++   ++--++   ++--++
                      +-&gt;| Q  |--&gt;| Q  |--&gt;| Q  |--+
                      |  +----+   +----+   +----+  |
                      +----------------------------+

                       Figure 1: Round-Robin Queues

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/2.2.3.%20%20Calendar%20Queue%20Models"></a><a class="selflink" href="#section-2.2.3" name="section-2.2.3">2.2.3</a>.  Calendar Queue Models</span>

   Another class of implementation approaches, generically referred to
   as Calendar Queue Implementations [<a href="#ref-CalendarQueue">CalendarQueue</a>], implements the
   structure of the queue as an array or ring of subqueues (often called
   "buckets") associated with time or sequence; each bucket contains the
   set of packets, which may be null, intended to be sent at a certain
   time or following the emptying of the previous bucket.  The queue
   structure includes a look-aside table that indicates the current
   depth (which is to say, the next bucket) of any given class of
   traffic, which might similarly be identified using a hash, a DSCP, an
   access list, or any other classifier.  Conceptually, the queues each
   contain zero or more packets from each class of traffic.  One is the
   queue being emptied "now"; the rest are associated with some time or
   sequence in the future.  The characteristics under "load" have been
   investigated in [<a href="#ref-Deadline" title='"Heavy Traffic Analysis For EDF Queues With Reneging"'>Deadline</a>].

   Upon entering the queue, the enqueue method, considering a classified
   packet, determines the current depth of that class with a view to
   scheduling it for transmission at some time or sequence in the
   future.  If the unit of scheduling is a packet and the queuing



<span class="grey">Baker &amp; Pan                   Informational                     [Page 7]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-8" id="page-8" name="page-8"> </a>
<span class="grey"><a href="rfc7806.html">RFC 7806</a>            On Queuing, Marking, and Dropping         April 2016</span>


   quantum is one packet per subqueue, a burst of packets arrives in a
   given flow, and if at the start the flow has no queued data, the
   first packet goes into the "next" queue, the second into its
   successor, and so on.  If there was some data in the class, the first
   packet in the burst would go into the bucket pointed to by the look-
   aside table.  If the unit of scheduling is time, the explanation in
   <a href="#section-2.2.5">Section 2.2.5</a> might be simplest to follow, but the bucket selected
   will be the bucket corresponding to a given transmission time in the
   future.  A necessary side effect, memory being finite, is that there
   exist a finite number of "future" buckets.  If enough traffic arrives
   to cause a class to wrap, one is forced to drop something (tail
   drop).

   On dequeue, the buckets are searched at their stated times or in
   their stated sequence, and when a bucket is identified that contains
   data, the dequeue method removes a specified quantum of data from it
   and, by extension, from the associated traffic classes.  A single
   bucket might contain data from a number of classes simultaneously.

                             +-+
                           +&gt;|1|
                           | +-+
                           |  |
                           | +-+      +-+
                           | |2|    +&gt;|2|
                           | +-+    | +-+
                           |  |     |  |
                           | +-+    | +-+      +-+
                           | |3|    | |1|    +&gt;|1|
                           | +-+    | +-+    | +-+
                           |  A     |  A     |  A
                           |  |     |  |     |  |
                          ++--++   ++--++   ++--++
                  "now"+-&gt;| Q  |--&gt;| Q  |--&gt;| Q  |--&gt;...
                          +----+   +----+   +----+
                             A       A         A
                             |3      |2        |1
                          +++++++++++++++++++++++
                          ||||     Flow      ||||
                          +++++++++++++++++++++++

                         Figure 2: Calendar Queue

   In any event, a subqueue contains the traffic for a point in time or
   a point in sequence, and data is sent from each subqueue in
   succession.  If subqueues are associated with time, an interesting
   end case develops: if the system is draining a given subqueue and the
   time of the next subqueue arrives, what should the system do?  One



<span class="grey">Baker &amp; Pan                   Informational                     [Page 8]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-9" id="page-9" name="page-9"> </a>
<span class="grey"><a href="rfc7806.html">RFC 7806</a>            On Queuing, Marking, and Dropping         April 2016</span>


   potentially valid line of reasoning would have it continue delivering
   the data in the present queue on the assumption that it will likely
   trade off for time in the next.  Another potentially valid line of
   reasoning would have it discard any waiting data in the present queue
   and move to the next.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/2.2.4.%20%20Work-Conserving%20Models%20and%20Stochastic%20Fairness%20Queuing"></a><a class="selflink" href="#section-2.2.4" name="section-2.2.4">2.2.4</a>.  Work-Conserving Models and Stochastic Fairness Queuing</span>

   Stochastic Fairness Queuing [<a href="#ref-SFQ" title='"Stochastic Fairness Queuing"'>SFQ</a>] is an example of a work-conserving
   algorithm.  This algorithm measures packets and considers a "flow" to
   be an equivalence class of traffic defined by a hashing algorithm
   over the source and destination IPv4 addresses.  As packets arrive,
   the enqueue method performs the indicated hash and places the packet
   into the indicated subqueue.  The dequeue method operates as
   described in <a href="#section-2.2.2">Section 2.2.2</a>; subqueues are inspected in round-robin
   sequence and a packet is removed if they contain one or more packets.

   The Deficit Round Robin [<a href="#ref-DRR" title='"Efficient fair queuing using deficit round-robin"'>DRR</a>] model modifies the quanta to bytes and
   deals with variable length packets.  A subqueue descriptor contains a
   waiting quantum (the amount intended to be dequeued on the previous
   dequeue attempt that was not satisfied), a per-round quantum (the
   subqueue is intended to dequeue a certain number of bytes each
   round), and a maximum to permit (some multiple of the MTU).  In each
   dequeue attempt, the dequeue method sets the waiting quantum to the
   smaller of the maximum quantum and the sum of the waiting and
   incremental quantum.  It then dequeues up to the waiting quantum (in
   bytes) of packets in the queue and reduces the waiting quantum by the
   number of bytes dequeued.  Since packets will not normally be exactly
   the size of the quantum, some dequeue attempts will dequeue more than
   others, but they will over time average the incremental quantum per
   round if there is data present.

   [<a id="ref-SFQ" name="ref-SFQ">SFQ</a>] and [<a href="#ref-DRR" title='"Efficient fair queuing using deficit round-robin"'>DRR</a>] could be implemented as described in <a href="#section-2.2.3">Section 2.2.3</a>.
   The weakness of a classical WRR approach is the search time expended
   inspecting and not choosing sub-queues that contain no data or not
   enough to trigger a transmission from them.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/2.2.5.%20%20Non-Work-Conserving%20Models%20and%20Virtual%20Clock"></a><a class="selflink" href="#section-2.2.5" name="section-2.2.5">2.2.5</a>.  Non-Work-Conserving Models and Virtual Clock</span>

   Virtual Clock [<a href="#ref-VirtualClock">VirtualClock</a>] is an example of a non-work-conserving
   algorithm.  It is trivially implemented as described in
   <a href="#section-2.2.3">Section 2.2.3</a>.  It associates buckets with intervals in time that
   have durations on the order of microseconds to tens of milliseconds.
   Each flow is assigned a rate in bytes per interval.  The flow entry
   maintains a point in time the "next" packet in the flow should be
   scheduled.





<span class="grey">Baker &amp; Pan                   Informational                     [Page 9]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-10" id="page-10" name="page-10"> </a>
<span class="grey"><a href="rfc7806.html">RFC 7806</a>            On Queuing, Marking, and Dropping         April 2016</span>


   On enqueue, the method determines whether the "next schedule" time is
   "in the past"; if so, the packet is scheduled "now", and if not, the
   packet is scheduled at that time.  It then calculates the new "next
   schedule" time as the current "next schedule" time plus the length of
   the packet divided by the rate.  If the resulting time is also in the
   past, the "next schedule" time is set to "now"; otherwise, it is set
   to the calculated time.  As noted in <a href="#section-2.2.3">Section 2.2.3</a>, there is an
   interesting point regarding "too much time in the future"; if a
   packet is scheduled too far into the future, it may be marked or
   dropped in the AQM procedure, and if it runs beyond the end of the
   queuing system, may be defensively tail dropped.

   On dequeue, the bucket associated with the time "now" is inspected.
   If it contains a packet, the packet is dequeued and transmitted.  If
   the bucket is empty and the time for the next bucket has not arrived,
   the system waits, even if there is a packet in the next bucket.  As
   noted in <a href="#section-2.2.3">Section 2.2.3</a>, there is an interesting point regarding the
   queue associated with "now".  If a subsequent bucket, even if it is
   actually empty, would be delayed by the transmission of a packet, one
   could imagine marking the packet Explicit Congestion Notification -
   Congestion Experienced (ECN-CE) [<a href="rfc3168.html" title='"The Addition of Explicit Congestion Notification (ECN) to IP"'>RFC3168</a>] [<a href="rfc6679.html" title='"Explicit Congestion Notification (ECN) for RTP over UDP"'>RFC6679</a>] or dropping the
   packet.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/3.%20%20Queuing%2C%20Marking%2C%20and%20Dropping"></a><a class="selflink" href="#section-3" name="section-3">3</a>.  Queuing, Marking, and Dropping</span>

   Queuing, marking, and dropping are integrated in any system that has
   a queue.  If nothing else, as memory is finite, a system has to drop
   as discussed in Sections <a href="#section-2.2.3">2.2.3</a> and <a href="#section-2.2.5">2.2.5</a> in order to protect itself.
   However, host transports interpret drops as signals, so AQM
   algorithms use that as a mechanism to signal.

   It is useful to think of the effects of queuing as a signal as well.
   The receiver sends acknowledgements as data is received, so the
   arrival of acknowledgements at the sender paces the sender at
   approximately the average rate it is able to achieve through the
   network.  This is true even if the sender keeps an arbitrarily large
   amount of data stored in network queues and is the basis for delay-
   based congestion control algorithms.  So, delaying a packet
   momentarily in order to permit another session to improve its
   operation has the effect of signaling a slightly lower capacity to
   the sender.










<span class="grey">Baker &amp; Pan                   Informational                    [Page 10]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-11" id="page-11" name="page-11"> </a>
<span class="grey"><a href="rfc7806.html">RFC 7806</a>            On Queuing, Marking, and Dropping         April 2016</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.1.%20%20Queuing%20with%20Tail%20Mark%2FDrop"></a><a class="selflink" href="#section-3.1" name="section-3.1">3.1</a>.  Queuing with Tail Mark/Drop</span>

   In the default case in which a FIFO queue is used with defensive tail
   drop only, the effect is to signal to the sender in two ways:

   o  Ack clocking, which involves pacing the sender to send at
      approximately the rate it can deliver data to the receiver; and

   o  Defensive loss, which is when a sender sends faster than available
      capacity (such as by probing network capacity when fully utilizing
      that capacity) and overburdens a queue.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.2.%20%20Queuing%20with%20CoDel%20Mark%2FDrop"></a><a class="selflink" href="#section-3.2" name="section-3.2">3.2</a>.  Queuing with CoDel Mark/Drop</span>

   In any case wherein a queuing algorithm is used along with CoDel
   [<a href="#ref-DELAY-AQM" title='"Controlled Delay Active Queue Management"'>DELAY-AQM</a>], the sequence of events is that a packet is time stamped,
   enqueued, dequeued, compared to a subsequent reading of the clock,
   and then acted on, whether by dropping it, marking and forwarding it,
   or simply forwarding it.  This is to say that the only drop algorithm
   inherent in queuing is the defensive drop when the queue's resources
   are overrun.  However, the intention of marking or dropping is to
   signal to the sender much earlier when a certain amount of delay has
   been observed.  In a FIFO+CoDel, Virtual Clock+CoDel, or FlowQueue-
   Codel [<a href="#ref-FQ-CODEL" title='"The FlowQueue-CoDel Packet Scheduler and Active Queue Management Algorithm"'>FQ-CODEL</a>] implementation, the queuing algorithm is completely
   separate from the AQM algorithm.  Using them in series results in
   four signals to the sender:

   o  Ack clocking, which involves pacing the sender to send at
      approximately the rate it can deliver data to the receiver through
      a queue;

   o  Lossless signaling that a certain delay threshold has been
      reached, if ECN [<a href="rfc3168.html" title='"The Addition of Explicit Congestion Notification (ECN) to IP"'>RFC3168</a>] [<a href="rfc6679.html" title='"Explicit Congestion Notification (ECN) for RTP over UDP"'>RFC6679</a>] is in use;

   o  Intentional signaling via loss that a certain delay threshold has
      been reached, if ECN is not in use; and

   o  Defensive loss, which is when a sender sends faster than available
      capacity (such as by probing network capacity when fully utilizing
      that capacity) and overburdens a queue.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.3.%20%20Queuing%20with%20RED%20or%20PIE%20Mark%2FDrop"></a><a class="selflink" href="#section-3.3" name="section-3.3">3.3</a>.  Queuing with RED or PIE Mark/Drop</span>

   In any case wherein a queuing algorithm is used along with PIE
   [<a href="#ref-AQM-PIE" title='"PIE: A Lightweight Control Scheme To Address the Bufferbloat Problem"'>AQM-PIE</a>], Random Early Detection (RED) [<a href="rfc7567.html" title='"IETF Recommendations Regarding Active Queue Management"'>RFC7567</a>], or other such
   algorithms, the sequence of events is that a queue is inspected, a
   packet is dropped, marked, or left unchanged, enqueued, dequeued,
   compared to a subsequent reading of the clock, and then forwarded on.



<span class="grey">Baker &amp; Pan                   Informational                    [Page 11]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-12" id="page-12" name="page-12"> </a>
<span class="grey"><a href="rfc7806.html">RFC 7806</a>            On Queuing, Marking, and Dropping         April 2016</span>


   This is to say that the AQM Mark/Drop Algorithm precedes enqueue; if
   it has not been effective and as a result the queue is out of
   resources anyway, the defensive drop algorithm steps in, and failing
   that, the queue operates in whatever way it does.  Hence, in a
   FIFO+PIE, SFQ+PIE, or Virtual Clock+PIE implementation, the queuing
   algorithm is again completely separate from the AQM algorithm.  Using
   them in series results in four signals to the sender:

   o  Ack clocking, which involves pacing the sender to send at
      approximately the rate it can deliver data to the receiver through
      a queue;

   o  Lossless signaling that a queue depth that corresponds to a
      certain delay threshold has been reached, if ECN is in use;

   o  Intentional signaling via loss that a queue depth that corresponds
      to a certain delay threshold has been reached, if ECN is not in
      use; and

   o  Defensive loss, which is when a sender sends faster than available
      capacity (such as by probing network capacity when fully utilizing
      that capacity) and overburdens a queue.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/4.%20%20Conclusion"></a><a class="selflink" href="#section-4" name="section-4">4</a>.  Conclusion</span>

   To summarize, in <a href="#section-2">Section 2</a>, implementation approaches for several
   classes of queuing algorithms were explored.  Queuing algorithms such
   as SFQ, Virtual Clock, and FlowQueue-Codel [<a href="#ref-FQ-CODEL" title='"The FlowQueue-CoDel Packet Scheduler and Active Queue Management Algorithm"'>FQ-CODEL</a>] have value in
   the network in that they delay packets to enforce a rate upper bound
   or to permit competing flows to compete more effectively.  ECN
   marking and loss are also useful signals if used in a manner that
   enhances TCP / Steam Control Transmission Protocol (SCTP) operation
   or restrains unmanaged UDP data flows.

   Conceptually, queuing algorithms and mark/drop algorithms operate in
   series (as discussed in <a href="#section-3">Section 3</a>), not as a single algorithm.  The
   observed effects differ: defensive loss protects the intermediate
   system and provides a signal, AQM mark/drop works to reduce mean
   latency, and the scheduling of flows works to modify flow interleave
   and acknowledgement pacing.  Certain features like flow isolation are
   provided by fair-queuing-related designs but are not the effect of
   the mark/drop algorithm.

   There is value in implementing and coupling the operation of both
   queuing algorithms and queue management algorithms, and there is
   definitely interesting research in this area, but specifications,
   measurements, and comparisons should decouple the different
   algorithms and their contributions to system behavior.



<span class="grey">Baker &amp; Pan                   Informational                    [Page 12]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-13" id="page-13" name="page-13"> </a>
<span class="grey"><a href="rfc7806.html">RFC 7806</a>            On Queuing, Marking, and Dropping         April 2016</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/5.%20%20Security%20Considerations"></a><a class="selflink" href="#section-5" name="section-5">5</a>.  Security Considerations</span>

   This memo adds no new security issues; it observes implementation
   strategies for Diffserv implementation.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/6.%20%20References"></a><a class="selflink" href="#section-6" name="section-6">6</a>.  References</span>

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/6.1.%20%20Normative%20References"></a><a class="selflink" href="#section-6.1" name="section-6.1">6.1</a>.  Normative References</span>

   [<a id="ref-RFC2475" name="ref-RFC2475">RFC2475</a>]   Blake, S., Black, D., Carlson, M., Davies, E., Wang, Z.,
               and W. Weiss, "An Architecture for Differentiated
               Services", <a href="rfc2475.html">RFC 2475</a>, DOI 10.17487/RFC2475, December 1998,
               &lt;<a href="http://www.rfc-editor.org/info/rfc2475">http://www.rfc-editor.org/info/rfc2475</a>&gt;.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/6.2.%20%20Informative%20References"></a><a class="selflink" href="#section-6.2" name="section-6.2">6.2</a>.  Informative References</span>

   [<a id="ref-AQM-PIE" name="ref-AQM-PIE">AQM-PIE</a>]   Pan, R., Natarajan, P., and F. Baker, "PIE: A Lightweight
               Control Scheme To Address the Bufferbloat Problem", Work
               in Progress, <a href="https://tools.ietf.org/html/draft-ietf-aqm-pie-06">draft-ietf-aqm-pie-06</a>, April 2016.

   [<a id="ref-CalendarQueue" name="ref-CalendarQueue">CalendarQueue</a>]
               Brown, R., "Calendar queues: a fast 0(1) priority queue
               implementation for the simulation event set problem",
               Communications of the ACM Volume 21, Issue 10, pp.
               1220-1227, DOI 10.1145/63039.63045, October 1988,
               &lt;<a href="http://dl.acm.org/citation.cfm?id=63045">http://dl.acm.org/citation.cfm?id=63045</a>&gt;.

   [<a id="ref-Deadline" name="ref-Deadline">Deadline</a>]  Kruk, L., Lohoczky, J., Ramanan, K., and S. Shreve,
               "Heavy Traffic Analysis For EDF Queues With Reneging",
               The Annals of Applied Probability Volume 21, Issue No. 2,
               pp. 484-545, DOI 10.1214/10-AAP681, 2011,
               &lt;<a href="http://www.math.cmu.edu/users/shreve/Reneging.pdf">http://www.math.cmu.edu/users/shreve/Reneging.pdf</a>&gt;.

   [<a id="ref-DELAY-AQM" name="ref-DELAY-AQM">DELAY-AQM</a>] Nichols, K., Jacobson, V., McGregor, A., and J. Iyengar,
               "Controlled Delay Active Queue Management", Work in
               Progress, <a href="https://tools.ietf.org/html/draft-ietf-aqm-codel-03">draft-ietf-aqm-codel-03</a>, March 2016.

   [<a id="ref-DRR" name="ref-DRR">DRR</a>]       Shreedhar, M. and G. Varghese, "Efficient fair queuing
               using deficit round-robin", IEEE/ACM Transactions on
               Networking Volume 4, Issue 3, pp. 375-385,
               DOI 10.1109/90.502236, June 1996,
               &lt;<a href="http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=502236">http://ieeexplore.ieee.org/stamp/</a>
               <a href="http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=502236">stamp.jsp?tp=&amp;arnumber=502236</a>&gt;.

   [<a id="ref-FQ-CODEL" name="ref-FQ-CODEL">FQ-CODEL</a>]  Hoeiland-Joergensen, T., McKenney, P., Taht, D., Gettys,
               J., and E. Dumazet, "The FlowQueue-CoDel Packet Scheduler
               and Active Queue Management Algorithm", Work in Progress,
               <a href="https://tools.ietf.org/html/draft-ietf-aqm-fq-codel-06">draft-ietf-aqm-fq-codel-06</a>, March 2016.



<span class="grey">Baker &amp; Pan                   Informational                    [Page 13]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-14" id="page-14" name="page-14"> </a>
<span class="grey"><a href="rfc7806.html">RFC 7806</a>            On Queuing, Marking, and Dropping         April 2016</span>


   [<a id="ref-GPS" name="ref-GPS">GPS</a>]       Demers, A., University of California, Berkeley, and Xerox
               PARC, "Analysis and Simulation of a Fair Queueing
               Algorithm", ACM SIGCOMM Computer Communication
               Review, Volume 19, Issue 4, pp. 1-12,
               DOI 10.1145/75247.75248, September 1989,
               &lt;<a href="http://blizzard.cs.uwaterloo.ca/keshav/home/Papers/data/89/fq.pdf">http://blizzard.cs.uwaterloo.ca/keshav/home/Papers/</a>
               <a href="http://blizzard.cs.uwaterloo.ca/keshav/home/Papers/data/89/fq.pdf">data/89/fq.pdf</a>&gt;.

   [<a id="ref-NoFair" name="ref-NoFair">NoFair</a>]    Briscoe, B., "Flow rate fairness: dismantling a
               religion", ACM SIGCOMM Computer Communication
               Review, Volume 37, Issue 2, pp. 63-74,
               DOI 10.1145/1232919.1232926, April 2007,
               &lt;<a href="http://dl.acm.org/citation.cfm?id=1232926">http://dl.acm.org/citation.cfm?id=1232926</a>&gt;.

   [<a id="ref-RFC970" name="ref-RFC970">RFC970</a>]    Nagle, J., "On Packet Switches With Infinite Storage",
               <a href="rfc970.html">RFC 970</a>, DOI 10.17487/RFC0970, December 1985,
               &lt;<a href="http://www.rfc-editor.org/info/rfc970">http://www.rfc-editor.org/info/rfc970</a>&gt;.

   [<a id="ref-RFC2990" name="ref-RFC2990">RFC2990</a>]   Huston, G., "Next Steps for the IP QoS Architecture",
               <a href="rfc2990.html">RFC 2990</a>, DOI 10.17487/RFC2990, November 2000,
               &lt;<a href="http://www.rfc-editor.org/info/rfc2990">http://www.rfc-editor.org/info/rfc2990</a>&gt;.

   [<a id="ref-RFC3168" name="ref-RFC3168">RFC3168</a>]   Ramakrishnan, K., Floyd, S., and D. Black, "The Addition
               of Explicit Congestion Notification (ECN) to IP",
               <a href="rfc3168.html">RFC 3168</a>, DOI 10.17487/RFC3168, September 2001,
               &lt;<a href="http://www.rfc-editor.org/info/rfc3168">http://www.rfc-editor.org/info/rfc3168</a>&gt;.

   [<a id="ref-RFC3390" name="ref-RFC3390">RFC3390</a>]   Allman, M., Floyd, S., and C. Partridge, "Increasing
               TCP's Initial Window", <a href="rfc3390.html">RFC 3390</a>, DOI 10.17487/RFC3390,
               October 2002, &lt;<a href="http://www.rfc-editor.org/info/rfc3390">http://www.rfc-editor.org/info/rfc3390</a>&gt;.

   [<a id="ref-RFC5690" name="ref-RFC5690">RFC5690</a>]   Floyd, S., Arcia, A., Ros, D., and J. Iyengar, "Adding
               Acknowledgement Congestion Control to TCP", <a href="rfc5690.html">RFC 5690</a>,
               DOI 10.17487/RFC5690, February 2010,
               &lt;<a href="http://www.rfc-editor.org/info/rfc5690">http://www.rfc-editor.org/info/rfc5690</a>&gt;.

   [<a id="ref-RFC6057" name="ref-RFC6057">RFC6057</a>]   Bastian, C., Klieber, T., Livingood, J., Mills, J., and
               R.  Woundy, "Comcast's Protocol-Agnostic Congestion
               Management System", <a href="rfc6057.html">RFC 6057</a>, DOI 10.17487/RFC6057,
               December 2010, &lt;<a href="http://www.rfc-editor.org/info/rfc6057">http://www.rfc-editor.org/info/rfc6057</a>&gt;.

   [<a id="ref-RFC6679" name="ref-RFC6679">RFC6679</a>]   Westerlund, M., Johansson, I., Perkins, C., O'Hanlon, P.,
               and K. Carlberg, "Explicit Congestion Notification (ECN)
               for RTP over UDP", <a href="rfc6679.html">RFC 6679</a>, DOI 10.17487/RFC6679, August
               2012, &lt;<a href="http://www.rfc-editor.org/info/rfc6679">http://www.rfc-editor.org/info/rfc6679</a>&gt;.






<span class="grey">Baker &amp; Pan                   Informational                    [Page 14]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-15" id="page-15" name="page-15"> </a>
<span class="grey"><a href="rfc7806.html">RFC 7806</a>            On Queuing, Marking, and Dropping         April 2016</span>


   [<a id="ref-RFC6928" name="ref-RFC6928">RFC6928</a>]   Chu, J., Dukkipati, N., Cheng, Y., and M. Mathis,
               "Increasing TCP's Initial Window", <a href="rfc6928.html">RFC 6928</a>,
               DOI 10.17487/RFC6928, April 2013,
               &lt;<a href="http://www.rfc-editor.org/info/rfc6928">http://www.rfc-editor.org/info/rfc6928</a>&gt;.

   [<a id="ref-RFC7141" name="ref-RFC7141">RFC7141</a>]   Briscoe, B. and J. Manner, "Byte and Packet Congestion
               Notification", <a href="https://tools.ietf.org/html/bcp41">BCP 41</a>, <a href="rfc7141.html">RFC 7141</a>, DOI 10.17487/RFC7141,
               February 2014, &lt;<a href="http://www.rfc-editor.org/info/rfc7141">http://www.rfc-editor.org/info/rfc7141</a>&gt;.

   [<a id="ref-RFC7567" name="ref-RFC7567">RFC7567</a>]   Baker, F., Ed. and G. Fairhurst, Ed., "IETF
               Recommendations Regarding Active Queue Management",
               <a href="https://tools.ietf.org/html/bcp197">BCP 197</a>, <a href="rfc7567.html">RFC 7567</a>, DOI 10.17487/RFC7567, July 2015,
               &lt;<a href="http://www.rfc-editor.org/info/rfc7567">http://www.rfc-editor.org/info/rfc7567</a>&gt;.

   [<a id="ref-SFQ" name="ref-SFQ">SFQ</a>]       Mckenney, P., "Stochastic Fairness Queuing", Proceedings
               of IEEE INFOCOM '90, Volume 2, pp. 733-740,
               DOI 10.1109/INFCOM.1990.91316, June 1990,
               &lt;<a href="http://www2.rdrop.com/~paulmck/scalability/paper/sfq.2002.06.04.pdf">http://www2.rdrop.com/~paulmck/scalability/paper/</a>
               <a href="http://www2.rdrop.com/~paulmck/scalability/paper/sfq.2002.06.04.pdf">sfq.2002.06.04.pdf</a>&gt;.

   [<a id="ref-VirtualClock" name="ref-VirtualClock">VirtualClock</a>]
               Zhang, L., "VirtualClock: A New Traffic Control Algorithm
               for Packet Switching Networks", Proceedings of the ACM
               Symposium on Communications Architectures and
               Protocols, Volume 20, DOI 10.1145/99508.99525, September
               1990, &lt;<a href="http://dl.acm.org/citation.cfm?id=99508.99525">http://dl.acm.org/citation.cfm?id=99508.99525</a>&gt;.

Acknowledgements

   This note grew out of, and is in response to, mailing list
   discussions in AQM, in which some have pushed an algorithm to compare
   to AQM marking and dropping algorithms, but which includes flow
   queuing.


















<span class="grey">Baker &amp; Pan                   Informational                    [Page 15]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-16" id="page-16" name="page-16"> </a>
<span class="grey"><a href="rfc7806.html">RFC 7806</a>            On Queuing, Marking, and Dropping         April 2016</span>


Authors' Addresses

   Fred Baker
   Cisco Systems
   Santa Barbara, California  93117
   United States

   Email: fred@cisco.com


   Rong Pan
   Cisco Systems
   Milpitas, California  95035
   United States

   Email: ropan@cisco.com



































Baker &amp; Pan                   Informational                    [Page 16]

</pre><br/>
    <span class="noprint"><small><small>Html markup produced by rfcmarkup 1.126, available from
      <a href="https://tools.ietf.org/tools/rfcmarkup/">https://tools.ietf.org/tools/rfcmarkup/</a>
    </small></small></span>
  </div>




</body><!-- Mirrored from tools.ietf.org/html/rfc7806 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 06 Mar 2018 23:18:19 GMT --></html>