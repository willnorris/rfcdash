<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml"><!-- Mirrored from tools.ietf.org/html/rfc7556 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 06 Mar 2018 23:18:21 GMT --><!-- Added by HTTrack --><head><meta content="text/html;charset=utf-8" http-equiv="content-type"/><!-- /Added by HTTrack -->

    <meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
    <meta content="index,follow" name="robots"/>
    <meta content="rfcmarkup version 1.126" name="creator"/>
    <link href="http://purl.org/dc/elements/1.1/" rel="schema.DC"/>
<meta content="draft-anipko-mif-mpvd-arch" name="DC.Relation.Replaces"/>
<meta content="urn:ietf:rfc:7556" name="DC.Identifier"/>
<meta content="June, 2015" name="DC.Date.Issued"/>
<meta content="Dmitry Anipko &lt;dmitry.anipko@gmail.com&gt;" name="DC.Creator"/>
<meta content="This document is a product of the work of the Multiple Interfaces
Architecture Design team. It outlines a solution framework for some of
the issues experienced by nodes that can be attached to multiple
networks simultaneously. The framework defines the concept of a
Provisioning Domain (PvD), which is a consistent set of network
configuration information. PvD-aware nodes learn PvD-specific
information from the networks they are attached to and/or other
sources. PvDs are used to enable separation and configuration
consistency in the presence of multiple concurrent connections." name="DC.Description.Abstract"/>
<meta content="Multiple Provisioning Domain Architecture" name="DC.Title"/>

    <link href="https://tools.ietf.org/images/rfc.png" rel="icon" type="image/png"/>
    <link href="https://tools.ietf.org/images/rfc.png" rel="shortcut icon" type="image/png"/>
    <title>RFC 7556 - Multiple Provisioning Domain Architecture</title>
    
    
    <style type="text/css">
	@media only screen 
	  and (min-width: 992px)
	  and (max-width: 1199px) {
	    body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 768px)
	  and (max-width: 991px) {
            body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 480px)
	  and (max-width: 767px) {
            body { font-size: 11pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (max-width: 479px) {
            body { font-size: 8pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-device-width : 375px) 
	  and (max-device-width : 667px) {
            body { font-size: 9.5pt; }
            div.content { width: 96ex; margin: 0 1px; }
        }
	@media only screen 
	  and (min-device-width: 1200px) {
            body { font-size: 10pt; margin: 0 4em; }
            div.content { width: 96ex; margin: 0; }
        }
        h1, h2, h3, h4, h5, h6, .h1, .h2, .h3, .h4, .h5, .h6 {
	    font-weight: bold;
            line-height: 0pt;
            display: inline;
            white-space: pre;
            font-family: monospace;
            font-size: 1em;
	    font-weight: bold;
        }
        pre {
            font-size: 1em;
            margin-top: 0px;
            margin-bottom: 0px;
        }
	.pre {
	    white-space: pre;
	    font-family: monospace;
	}
	.header{
	    font-weight: bold;
	}
        .newpage {
            page-break-before: always;
        }
        .invisible {
            text-decoration: none;
            color: white;
        }
        a.selflink {
          color: black;
          text-decoration: none;
        }
        @media print {
            body {
                font-family: monospace;
                font-size: 10.5pt;
            }
            h1, h2, h3, h4, h5, h6 {
                font-size: 1em;
            }
        
            a:link, a:visited {
                color: inherit;
                text-decoration: none;
            }
            .noprint {
                display: none;
            }
        }
	@media screen {
	    .grey, .grey a:link, .grey a:visited {
		color: #777;
	    }
            .docinfo {
                background-color: #EEE;
            }
            .top {
                border-top: 7px solid #EEE;
            }
            .bgwhite  { background-color: white; }
            .bgred    { background-color: #F44; }
            .bggrey   { background-color: #666; }
            .bgbrown  { background-color: #840; }            
            .bgorange { background-color: #FA0; }
            .bgyellow { background-color: #EE0; }
            .bgmagenta{ background-color: #F4F; }
            .bgblue   { background-color: #66F; }
            .bgcyan   { background-color: #4DD; }
            .bggreen  { background-color: #4F4; }

            .legend   { font-size: 90%; }
            .cplate   { font-size: 70%; border: solid grey 1px; }
	}
    </style>
    <!--[if IE]>
    <style>
    body {
       font-size: 13px;
       margin: 10px 10px;
    }
    </style>
    <![endif]-->

    <script type="text/javascript"><!--
    function addHeaderTags() {
	var spans = document.getElementsByTagName("span");
	for (var i=0; i < spans.length; i++) {
	    var elem = spans[i];
	    if (elem) {
		var level = elem.getAttribute("class");
                if (level == "h1" || level == "h2" || level == "h3" || level == "h4" || level == "h5" || level == "h6") {
                    elem.innerHTML = "<"+level+">"+elem.innerHTML+"</"+level+">";		
                }
	    }
	}
    }
    var legend_html = "Colour legend:<br />      <table>         <tr><td>Unknown:</td>                   <td><span class='cplate bgwhite'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft:</td>                     <td><span class='cplate bgred'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Informational:</td>             <td><span class='cplate bgorange'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Experimental:</td>              <td><span class='cplate bgyellow'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Best Common Practice:</td>      <td><span class='cplate bgmagenta'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Proposed Standard:</td>         <td><span class='cplate bgblue'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft Standard (old designation):</td> <td><span class='cplate bgcyan'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Internet Standard:</td>         <td><span class='cplate bggreen'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Historic:</td>                  <td><span class='cplate bggrey'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Obsolete:</td>                  <td><span class='cplate bgbrown'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>     </table>";
    function showElem(id) {
        var elem = document.getElementById(id);
        elem.innerHTML = eval(id+"_html");
        elem.style.visibility='visible';
    }
    function hideElem(id) {
        var elem = document.getElementById(id);
        elem.style.visibility='hidden';        
        elem.innerHTML = "";
    }
    // -->
    </script>
</head>
<body onload="addHeaderTags()">
  <div class="content">
   <div style="height: 13px;">
      <div class="pre noprint docinfo bgorange" onclick="showElem('legend');" onmouseout="hideElem('legend')" onmouseover="this.style.cursor='pointer';" style="height: 6px; position: absolute;" title="Click for colour legend.">                                                                        </div>
      <div class="docinfo noprint pre legend" id="legend" onmouseout="hideElem('legend');" onmouseover="showElem('legend');" style="position:absolute; top: 4px; left: 4ex; visibility:hidden; background-color: white; padding: 4px 9px 5px 7px; border: solid #345 1px; ">
      </div>
   </div>
<span class="pre noprint docinfo top">[<a href="index.html" title="Document search and retrieval page">Docs</a>] [<a href="https://tools.ietf.org/rfc/rfc7556.txt" title="Plaintext version of this document">txt</a>|<a href="https://tools.ietf.org/pdf/rfc7556" title="PDF version of this document">pdf</a>] [<a href="https://tools.ietf.org/html/draft-ietf-mif-mpvd-arch" title="draft-ietf-mif-mpvd-arch">draft-ietf-mif-...</a>] [<a href="https://datatracker.ietf.org/doc/rfc7556" title="IESG Datatracker information for this document">Tracker</a>] [<a href="https://tools.ietf.org/rfcdiff?difftype=--hwdiff&amp;url2=rfc7556" title="Inline diff (wdiff)">Diff1</a>] [<a href="https://tools.ietf.org/rfcdiff?url2=rfc7556" title="Side-by-side diff">Diff2</a>] [<a href="https://www.rfc-editor.org/errata_search.php?rfc=7556">Errata</a>]</span><br/>
<span class="pre noprint docinfo">                                                                        </span><br/>
<span class="pre noprint docinfo">                                                           INFORMATIONAL</span><br/>
<span class="pre noprint docinfo">                                                            <span style="color: #C00;">Errata Exist</span></span><br/>
<pre>Internet Engineering Task Force (IETF)                    D. Anipko, Ed.
Request for Comments: 7556                                  Unaffiliated
Category: Informational                                        June 2015
ISSN: 2070-1721


               <span class="h1">Multiple Provisioning Domain Architecture</span>

Abstract

   This document is a product of the work of the Multiple Interfaces
   Architecture Design team.  It outlines a solution framework for some
   of the issues experienced by nodes that can be attached to multiple
   networks simultaneously.  The framework defines the concept of a
   Provisioning Domain (PvD), which is a consistent set of network
   configuration information.  PvD-aware nodes learn PvD-specific
   information from the networks they are attached to and/or other
   sources.  PvDs are used to enable separation and configuration
   consistency in the presence of multiple concurrent connections.

Status of This Memo

   This document is not an Internet Standards Track specification; it is
   published for informational purposes.

   This document is a product of the Internet Engineering Task Force
   (IETF).  It represents the consensus of the IETF community.  It has
   received public review and has been approved for publication by the
   Internet Engineering Steering Group (IESG).  Not all documents
   approved by the IESG are a candidate for any level of Internet
   Standard; see <a href="rfc5741.html#section-2">Section 2 of RFC 5741</a>.

   Information about the current status of this document, any errata,
   and how to provide feedback on it may be obtained at
   <a href="http://www.rfc-editor.org/info/rfc7556">http://www.rfc-editor.org/info/rfc7556</a>.
















<span class="grey">Anipko                        Informational                     [Page 1]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-2" id="page-2" name="page-2"> </a>
<span class="grey"><a href="rfc7556.html">RFC 7556</a>                    MPvD Architecture                  June 2015</span>


Copyright Notice

   Copyright (c) 2015 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to <a href="https://tools.ietf.org/html/bcp78">BCP 78</a> and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (<a href="http://trustee.ietf.org/license-info">http://trustee.ietf.org/license-info</a>) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.





































<span class="grey">Anipko                        Informational                     [Page 2]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-3" id="page-3" name="page-3"> </a>
<span class="grey"><a href="rfc7556.html">RFC 7556</a>                    MPvD Architecture                  June 2015</span>


Table of Contents

   <a href="#section-1">1</a>.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   <a href="#page-4">4</a>
   <a href="#section-2">2</a>.  Definitions and Types of PvDs . . . . . . . . . . . . . . . .   <a href="#page-5">5</a>
     <a href="#section-2.1">2.1</a>.  Explicit PvDs . . . . . . . . . . . . . . . . . . . . . .   <a href="#page-5">5</a>
     2.2.  Implicit PvDs and Incremental Adoption of Explicit PvDs .   6
     <a href="#section-2.3">2.3</a>.  Relationship between PvDs and Interfaces  . . . . . . . .   <a href="#page-7">7</a>
     <a href="#section-2.4">2.4</a>.  PvD Identity/Naming . . . . . . . . . . . . . . . . . . .   <a href="#page-8">8</a>
     <a href="#section-2.5">2.5</a>.  The Relationship to Dual-Stack Networks . . . . . . . . .   <a href="#page-8">8</a>
   <a href="#section-3">3</a>.  Conveying PvD Information . . . . . . . . . . . . . . . . . .   <a href="#page-9">9</a>
     <a href="#section-3.1">3.1</a>.  Separate Messages or One Message? . . . . . . . . . . . .   <a href="#page-9">9</a>
     <a href="#section-3.2">3.2</a>.  Securing PvD Information  . . . . . . . . . . . . . . . .  <a href="#page-10">10</a>
     <a href="#section-3.3">3.3</a>.  Backward Compatibility  . . . . . . . . . . . . . . . . .  <a href="#page-10">10</a>
     <a href="#section-3.4">3.4</a>.  Retracting/Updating PvD Information . . . . . . . . . . .  <a href="#page-10">10</a>
     <a href="#section-3.5">3.5</a>.  Conveying Configuration Information Using IKEv2 . . . . .  <a href="#page-10">10</a>
   <a href="#section-4">4</a>.  Example Network Configurations  . . . . . . . . . . . . . . .  <a href="#page-11">11</a>
     <a href="#section-4.1">4.1</a>.  A Mobile Node . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-11">11</a>
     <a href="#section-4.2">4.2</a>.  A Node with a VPN Connection  . . . . . . . . . . . . . .  <a href="#page-12">12</a>
     4.3.  A Home Network and a Network Operator with Multiple PvDs   12
   <a href="#section-5">5</a>.  Reference Model for the PvD-Aware Node  . . . . . . . . . . .  <a href="#page-13">13</a>
     <a href="#section-5.1">5.1</a>.  Constructions and Maintenance of Separate PvDs  . . . . .  <a href="#page-13">13</a>
     <a href="#section-5.2">5.2</a>.  Consistent Use of PvDs for Network Connections  . . . . .  <a href="#page-14">14</a>
       <a href="#section-5.2.1">5.2.1</a>.  Name Resolution . . . . . . . . . . . . . . . . . . .  <a href="#page-14">14</a>
       <a href="#section-5.2.2">5.2.2</a>.  Next-Hop and Source Address Selection . . . . . . . .  <a href="#page-15">15</a>
       <a href="#section-5.2.3">5.2.3</a>.  Listening Applications  . . . . . . . . . . . . . . .  <a href="#page-16">16</a>
         <a href="#section-5.2.3.1">5.2.3.1</a>.  Processing of Incoming Traffic  . . . . . . . . .  <a href="#page-16">16</a>
       <a href="#section-5.2.4">5.2.4</a>.  Enforcement of Security Policies  . . . . . . . . . .  <a href="#page-17">17</a>
     <a href="#section-5.3">5.3</a>.  Connectivity Tests  . . . . . . . . . . . . . . . . . . .  <a href="#page-18">18</a>
     5.4.  Relationship to Interface Management and Connection
           Managers  . . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-18">18</a>
   <a href="#section-6">6</a>.  PvD Support in APIs . . . . . . . . . . . . . . . . . . . . .  <a href="#page-19">19</a>
     <a href="#section-6.1">6.1</a>.  Basic . . . . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-19">19</a>
     <a href="#section-6.2">6.2</a>.  Intermediate  . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-19">19</a>
     <a href="#section-6.3">6.3</a>.  Advanced  . . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-20">20</a>
   <a href="#section-7">7</a>.  PvD Trust for PvD-Aware Node  . . . . . . . . . . . . . . . .  <a href="#page-20">20</a>
     <a href="#section-7.1">7.1</a>.  Untrusted PvDs  . . . . . . . . . . . . . . . . . . . . .  <a href="#page-20">20</a>
     <a href="#section-7.2">7.2</a>.  Trusted PvDs  . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-20">20</a>
       <a href="#section-7.2.1">7.2.1</a>.  Authenticated PvDs  . . . . . . . . . . . . . . . . .  <a href="#page-21">21</a>
       <a href="#section-7.2.2">7.2.2</a>.  PvDs Trusted by Attachment  . . . . . . . . . . . . .  <a href="#page-21">21</a>
   <a href="#section-8">8</a>.  Security Considerations . . . . . . . . . . . . . . . . . . .  <a href="#page-21">21</a>
   <a href="#section-9">9</a>.  Informative References  . . . . . . . . . . . . . . . . . . .  <a href="#page-23">23</a>
   Acknowledgments . . . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-25">25</a>
   Contributors  . . . . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-25">25</a>
   Author's Address  . . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-25">25</a>







<span class="grey">Anipko                        Informational                     [Page 3]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-4" id="page-4" name="page-4"> </a>
<span class="grey"><a href="rfc7556.html">RFC 7556</a>                    MPvD Architecture                  June 2015</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/1.%20%20Introduction"></a><a class="selflink" href="#section-1" name="section-1">1</a>.  Introduction</span>

   Nodes attached to multiple networks may encounter problems from
   conflicting configuration between the networks or attempts to
   simultaneously use more than one network.  While various techniques
   are currently used to tackle these problems [<a href="rfc6419.html" title='"Current Practices for Multiple-Interface Hosts"'>RFC6419</a>], in many cases
   issues may still appear.  The Multiple Interfaces Problem Statement
   document [<a href="rfc6418.html" title='"Multiple Interfaces and Provisioning Domains Problem Statement"'>RFC6418</a>] describes the general landscape and discusses many
   of the specific issues and scenario details.

   Problems, enumerated in [<a href="rfc6418.html" title='"Multiple Interfaces and Provisioning Domains Problem Statement"'>RFC6418</a>], can be grouped into 3 categories:

   1.  Lack of consistent and distinctive management of configuration
       elements associated with different networks.

   2.  Inappropriate mixed use of configuration elements associated with
       different networks during a particular network activity or
       connection.

   3.  Use of a particular network that is not consistent with the
       intended use of the network, or the intent of the communicating
       parties, leading to connectivity failure and/or other undesired
       consequences.

   An example of (1) is a single, node-scoped list of DNS server IP
   addresses learned from different networks leading to failures or
   delays in resolution of names from particular namespaces; an example
   of (2) is an attempt to resolve the name of an HTTP proxy server
   learned from network A using a DNS server learned from network B; and
   an example of (3) is the use of an employer-provided VPN connection
   for peer-to-peer connectivity unrelated to employment activities.

   This architecture provides solutions to these categories of problems,
   respectively, by:

   1.  Introducing the formal notion of PvDs, including identity for
       PvDs, and describing mechanisms for nodes to learn the intended
       associations between acquired network configuration information
       elements.

   2.  Introducing a reference model for PvD-aware nodes that prevents
       the inadvertent mixed use of configuration information that may
       belong to different PvDs.

   3.  Providing recommendations on PvD selection based on PvD identity
       and connectivity tests for common scenarios.





<span class="grey">Anipko                        Informational                     [Page 4]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-5" id="page-5" name="page-5"> </a>
<span class="grey"><a href="rfc7556.html">RFC 7556</a>                    MPvD Architecture                  June 2015</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/2.%20%20Definitions%20and%20Types%20of%20PvDs"></a><a class="selflink" href="#section-2" name="section-2">2</a>.  Definitions and Types of PvDs</span>

   Provisioning Domain:
      A consistent set of network configuration information.
      Classically, all of the configuration information available on a
      single interface is provided by a single source (such as a network
      administrator) and can therefore be treated as a single
      provisioning domain.  In modern IPv6 networks, multihoming can
      result in more than one provisioning domain being present on a
      single link.  In some scenarios, it is also possible for elements
      of the same PvD to be present on multiple links.

      Typical examples of information in a provisioning domain learned
      from the network are:

      *  Source address prefixes for use by connections within the
         provisioning domain

      *  IP address(es) of the DNS server(s)

      *  Name of the HTTP proxy server (if available)

      *  DNS suffixes associated with the network

      *  Default gateway address

   PvD-aware node:
      A node that supports the association of network configuration
      information into PvDs and the use of these PvDs to serve requests
      for network connections in ways consistent with the
      recommendations of this architecture.

   PvD-aware application:
      An application that contains code and/or application-specific
      configuration information explicitly aware of the notion of PvD
      and/or specific types of PvD elements or properties.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/2.1.%20%20Explicit%20PvDs"></a><a class="selflink" href="#section-2.1" name="section-2.1">2.1</a>.  Explicit PvDs</span>

   A node may receive explicit information from the network and/or other
   sources conveying the presence of PvDs and the association of
   particular network information with a particular PvD.  PvDs that are
   constructed based on such information are referred to as "explicit"
   in this document.







<span class="grey">Anipko                        Informational                     [Page 5]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-6" id="page-6" name="page-6"> </a>
<span class="grey"><a href="rfc7556.html">RFC 7556</a>                    MPvD Architecture                  June 2015</span>


   Protocol changes or extensions will likely be required to support
   explicit PvDs through IETF-defined mechanisms.  As an example, one
   could think of one or more DHCP options carrying PvD identity and/or
   its elements.

   A different approach could be the introduction of a DHCP option that
   only carries the identity of a PvD.  Here, the associations between
   network information elements with the identity is implemented by the
   respective protocols, for example, with a Router Discovery [<a href="rfc4861.html" title='"Neighbor Discovery for IP version 6 (IPv6)"'>RFC4861</a>]
   option associating an address range with a PvD.  Additional
   discussion can be found in <a href="#section-3">Section 3</a>.

   Other examples of a delivery mechanism for PvDs are key exchange or
   tunneling protocols, such as the Internet Key Exchange Protocol
   version 2 (IKEv2) [<a href="rfc7296.html" title='"Internet Key Exchange Protocol Version 2 (IKEv2)"'>RFC7296</a>] that allows the transport of host
   configuration information.

   Specific, existing, or new features of networking protocols that
   enable the delivery of PvD identity and association with various
   network information elements will be defined in companion design
   documents.

   Link-specific and/or vendor-proprietary mechanisms for the discovery
   of PvD information (differing from IETF-defined mechanisms) can be
   used by nodes either separate from or in conjunction with IETF-
   defined mechanisms, providing they allow the discovery of the
   necessary elements of the PvD(s).

   In all cases, nodes must by default ensure that the lifetime of all
   dynamically discovered PvD configuration is appropriately limited by
   relevant events.  For example, if an interface media state change is
   indicated, previously discovered information relevant to that
   interface may no longer be valid and thus needs to be confirmed or
   re-discovered.

   It is expected that the way a node makes use of PvD information is
   generally independent of the specific mechanism/protocol that the
   information was received by.

   In some network topologies, network infrastructure elements may need
   to advertise multiple PvDs.  Generally, the details of how this is
   performed will be defined in companion design documents.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/2.2.%20%20Implicit%20PvDs%20and%20Incremental%20Adoption%20of%20Explicit%20PvDs"></a><a class="selflink" href="#section-2.2" name="section-2.2">2.2</a>.  Implicit PvDs and Incremental Adoption of Explicit PvDs</span>

   For the foreseeable future, there will be networks that do not
   advertise explicit PvD information, because deployment of new
   features in networking protocols is a relatively slow process.



<span class="grey">Anipko                        Informational                     [Page 6]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-7" id="page-7" name="page-7"> </a>
<span class="grey"><a href="rfc7556.html">RFC 7556</a>                    MPvD Architecture                  June 2015</span>


   When connected to networks that don't advertise explicit PvD
   information, a PvD-aware node shall automatically create separate
   PvDs for received configuration.  Such PvDs are referred to in this
   document as "implicit".

   Through the use of implicit PvDs, PvD-aware nodes may still provide
   benefits to their users (when compared to non-PvD-aware nodes) by
   following the best practices described in <a href="#section-5">Section 5</a>.

   PvD-aware nodes shall treat network information from different
   interfaces, which is not identified as belonging explicitly to some
   PvD, as belonging to separate PvDs, one per interface.

   Implicit PvDs can also occur in a mixed mode, i.e., where of multiple
   networks that are available on an attached link, only some advertise
   PvD information.  In this case, the PvD-aware node shall create
   explicit PvDs from information explicitly labeled as belonging to
   PvDs.  It shall associate configuration information not labeled with
   an explicit PvD with an implicit PvD(s) created for that interface.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/2.3.%20%20Relationship%20between%20PvDs%20and%20Interfaces"></a><a class="selflink" href="#section-2.3" name="section-2.3">2.3</a>.  Relationship between PvDs and Interfaces</span>

   By default, implicit PvDs are limited to the network configuration
   information received on a single interface, and by default, one such
   PvD is formed for each interface.  If additional information is
   available to the host (through mechanisms out of scope of this
   document), the host may form implicit PvDs with different
   granularity.  For example, PvDs spanning multiple interfaces such as
   a home network with a router that has multiple internal interfaces or
   multiple PvDs on a single interface such as a network that has
   multiple uplink connections.

   In the simplest case, explicit PvDs will be scoped for configuration
   related only to a specific interface.  However, there is no
   requirement in this architecture for such a limitation.  Explicit
   PvDs may include information related to more than one interface if
   the node learns the presence of the same PvD on those interfaces and
   the authentication of the PvD ID meets the level required by the node
   policy (authentication of a PvD ID may be also required in scenarios
   involving only one connected interface and/or PvD; for additional
   discussion of PvD Trust, see <a href="#section-7">Section 7</a>).

   This architecture supports such scenarios.  Hence, no hierarchical
   relationship exists between interfaces and PvDs: it is possible for
   multiple PvDs to be simultaneously accessible over one interface, as
   well as a single PvD to be simultaneously accessible over multiple
   interfaces.




<span class="grey">Anipko                        Informational                     [Page 7]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-8" id="page-8" name="page-8"> </a>
<span class="grey"><a href="rfc7556.html">RFC 7556</a>                    MPvD Architecture                  June 2015</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/2.4.%20%20PvD%20Identity%2FNaming"></a><a class="selflink" href="#section-2.4" name="section-2.4">2.4</a>.  PvD Identity/Naming</span>

   For explicit PvDs, the PvD ID is a value that is or has a high
   probability of being globally unique and is received as part of PvD
   information.  It shall be possible to generate a human-readable form
   of the PvD ID to present to the end user, either based on the PvD ID
   itself or using metadata associated with the ID.  For implicit PvDs,
   the node assigns a locally generated ID with a high probability of
   being globally unique to each implicit PvD.

   We say that a PvD ID should be, or should have a high probability of
   being, globally unique.  The purpose of this is to make it unlikely
   that any individual node will ever accidentally see the same PvD name
   twice if it is not actually referring to the same PvD.  Protection
   against deliberate attacks involving name clashes requires that the
   name be authenticated (see <a href="#section-7.2.1">Section 7.2.1</a>).

   A PvD-aware node may use these IDs to select a PvD with a matching ID
   for special-purpose connection requests in accordance with node
   policy, as chosen by advanced applications, or to present a human-
   readable representation of the IDs to the end user for selection of
   PvDs.

   A single network provider may operate multiple networks, including
   networks at different locations.  In such cases, the provider may
   chose whether to advertise single or multiple PvD identities at all
   or some of those networks as it suits their business needs.  This
   architecture does not impose any specific requirements in this
   regard.

   When multiple nodes are connected to the same link with one or more
   explicit PvDs available, this architecture assumes that the
   information about all available PvDs is made available by the
   networks to all the connected nodes.  At the same time, connected
   nodes may have different heuristics, policies, and/or other settings,
   including their configured sets of trusted PvDs.  This may lead to
   different PvDs actually being used by different nodes for their
   connections.

   Possible extensions whereby networks advertise different sets of PvDs
   to different connected nodes are out of scope of this document.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/2.5.%20%20The%20Relationship%20to%20Dual-Stack%20Networks"></a><a class="selflink" href="#section-2.5" name="section-2.5">2.5</a>.  The Relationship to Dual-Stack Networks</span>

   When applied to dual-stack networks, the PvD definition allows for
   multiple PvDs to be created whereby each PvD contains information
   relevant to only one address family, or for a single PvD containing
   information for multiple address families.  This architecture



<span class="grey">Anipko                        Informational                     [Page 8]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-9" id="page-9" name="page-9"> </a>
<span class="grey"><a href="rfc7556.html">RFC 7556</a>                    MPvD Architecture                  June 2015</span>


   requires that accompanying design documents describing PvD-related
   protocol changes must support PvDs containing information from
   multiple address families.  PvD-aware nodes must be capable of
   creating and using both single-family and multi-family PvDs.

   For explicit PvDs, the choice of either of these approaches is a
   policy decision for the network administrator and/or the node user/
   administrator.  Since some of the IP configuration information that
   can be learned from the network can be applicable to multiple address
   families (for instance, DHCPv6 Address Selection Policy Option
   [<a href="rfc7078.html" title='"Distributing Address Selection Policy Using DHCPv6"'>RFC7078</a>]), it is likely that dual-stack networks will deploy single
   PvDs for both address families.

   By default for implicit PvDs, PvD-aware nodes shall include multiple
   IP families into a single implicit PvD created for an interface.  At
   the time of writing, in dual-stack networks it appears to be common
   practice for the configuration of both address families to be
   provided by a single source.

   A PvD-aware node that provides an API to use, enumerate, and inspect
   PvDs and/or their properties shall provide the ability to filter PvDs
   and/or their properties by address family.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/3.%20%20Conveying%20PvD%20Information"></a><a class="selflink" href="#section-3" name="section-3">3</a>.  Conveying PvD Information</span>

   DHCPv6 and Router Advertisements (RAs) are the two most common
   methods of configuring hosts.  To support the architecture described
   in this document, these protocols would need to be extended to convey
   explicit PvD information.  The following sections describe topics
   that must be considered before finalizing a mechanism to augment
   DHCPv6 and RAs with PvD information.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.1.%20%20Separate%20Messages%20or%20One%20Message%3F"></a><a class="selflink" href="#section-3.1" name="section-3.1">3.1</a>.  Separate Messages or One Message?</span>

   When information related to several PvDs is available from the same
   configuration source, there are two possible ways of distributing
   this information: One way is to send information from each different
   provisioning domain in separate messages.  The second method is
   combining the information from multiple PvDs into a single message.
   The latter method has the advantage of being more efficient but could
   have problems with authentication and authorization, as well as
   potential issues with accommodating information not tagged with any
   PvD information.








<span class="grey">Anipko                        Informational                     [Page 9]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-10" id="page-10" name="page-10"> </a>
<span class="grey"><a href="rfc7556.html">RFC 7556</a>                    MPvD Architecture                  June 2015</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.2.%20%20Securing%20PvD%20Information"></a><a class="selflink" href="#section-3.2" name="section-3.2">3.2</a>.  Securing PvD Information</span>

   DHCPv6 [<a href="rfc3315.html" title='"Dynamic Host Configuration Protocol for IPv6 (DHCPv6)"'>RFC3315</a>] and RAs [<a href="rfc3971.html" title='"SEcure Neighbor Discovery (SEND)"'>RFC3971</a>] both provide some form of
   authentication to ensure the identity of the source as well as the
   integrity of the secured message content.  While this is useful,
   determining authenticity does not tell a node whether the
   configuration source is actually allowed to provide information from
   a given PvD.  To resolve this, there must be a mechanism for the PvD
   owner to attach some form of authorization token or signature to the
   configuration information that is delivered.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.3.%20%20Backward%20Compatibility"></a><a class="selflink" href="#section-3.3" name="section-3.3">3.3</a>.  Backward Compatibility</span>

   The extensions to RAs and DHCPv6 should be defined in such a manner
   that unmodified hosts (i.e., hosts not aware of PvDs) will continue
   to function as well as they did prior to PvD information being added.
   This could imply that some information may need to be duplicated in
   order to be conveyed to legacy hosts.  Similarly, PvD-aware hosts
   need to be able to correctly utilize legacy configuration sources
   that do not provide PvD information.  There are also several
   initiatives that are aimed at adding some form of additional
   information to prefixes [<a href="#ref-DHCPv6-CLASS-BASED-PREFIX">DHCPv6-CLASS-BASED-PREFIX</a>]
   [<a href="#ref-IPv6-PREFIX-PROPERTIES">IPv6-PREFIX-PROPERTIES</a>], and any new mechanism should try to
   consider coexistence with such deployed mechanisms.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.4.%20%20Retracting%2FUpdating%20PvD%20Information"></a><a class="selflink" href="#section-3.4" name="section-3.4">3.4</a>.  Retracting/Updating PvD Information</span>

   After PvD information is provisioned to a host, it may become
   outdated or superseded by updated information before the hosts would
   normally request updates.  To resolve this requires that the
   mechanism be able to update and/or withdraw all (or some subset) of
   the information related to a given PvD.  For efficiency reasons,
   there should be a way to specify that all information from the PvD
   needs to be reconfigured instead of individually updating each item
   associated with the PvD.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.5.%20%20Conveying%20Configuration%20Information%20Using%20IKEv2"></a><a class="selflink" href="#section-3.5" name="section-3.5">3.5</a>.  Conveying Configuration Information Using IKEv2</span>

   IKEv2 [<a href="rfc7296.html" title='"Internet Key Exchange Protocol Version 2 (IKEv2)"'>RFC7296</a>] [<a href="rfc5739.html" title='"IPv6 Configuration in Internet Key Exchange Protocol Version 2 (IKEv2)"'>RFC5739</a>] is another widely used method of
   configuring host IP information.  For IKEv2, the provisioning domain
   could be implicitly learned from the Identification - Responder (IDr)
   payloads that the IKEv2 initiator and responder inject during their
   IKEv2 exchange.  The IP configuration may depend on the named IDr.
   Another possibility could be adding a specific provisioning domain
   identifying payload extensions to IKEv2.  All of the considerations
   for DHCPv6 and the RAs listed above potentially apply to IKEv2 as
   well.




<span class="grey">Anipko                        Informational                    [Page 10]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-11" id="page-11" name="page-11"> </a>
<span class="grey"><a href="rfc7556.html">RFC 7556</a>                    MPvD Architecture                  June 2015</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/4.%20%20Example%20Network%20Configurations"></a><a class="selflink" href="#section-4" name="section-4">4</a>.  Example Network Configurations</span>

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.1.%20%20A%20Mobile%20Node"></a><a class="selflink" href="#section-4.1" name="section-4.1">4.1</a>.  A Mobile Node</span>

   Consider a mobile node with two network interfaces: one to the mobile
   network, the other to the Wi-Fi network.  When the mobile node is
   only connected to the mobile network, it will typically have one PvD,
   implicit or explicit.  When the mobile node discovers and connects to
   a Wi-Fi network, it will have zero or more (typically one) additional
   PvD(s).

   Some existing OS implementations only allow one active network
   connection.  In this case, only the PvD(s) associated with the active
   interface can be used at any given time.

   As an example, the mobile network can explicitly deliver PvD
   information through the Packet Data Protocol (PDP) context activation
   process.  Then, the PvD-aware mobile node will treat the mobile
   network as an explicit PvD.  Conversely, the legacy Wi-Fi network may
   not explicitly communicate PvD information to the mobile node.  The
   PvD-aware mobile node will associate network configuration for the
   Wi-Fi network with an implicit PvD in this case.

   The following diagram illustrates the use of different PvDs in this
   scenario:


                 &lt;----------- Wi-Fi 'Internet' PvD --------&gt;
        +---------+
        | +-----+ |    +-----+         _   __               _  _
        | |Wi-Fi| |    |     |        ( `    )             ( `   )_
        | |-IF  + |----+     |---------------------------(         `)
        | |     | |    |Wi-Fi|      (         )         (  Internet  )
        | +-----+ |    | AP  |     (           )        (            )
        |         |    |     |    (   Service    )      (            )
        |         |    +-----+    (  Provider's   )     (            )
        |         |               (   Networks    -     (            )
        | +----+  |                `_            )      (            )
        | |CELL|  |                 (          )        (            )
        | |-IF +--|-------------------------------------(            )
        | |    |  |                 (_     __)          (_          _)
        | +----+  |                  `- --               `- __  _) -
        +---------+
                 &lt;------- Mobile 'Internet' PvD -----------&gt;

     Figure 1: An Example of PvD Use with Wi-Fi and Mobile Interfaces





<span class="grey">Anipko                        Informational                    [Page 11]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-12" id="page-12" name="page-12"> </a>
<span class="grey"><a href="rfc7556.html">RFC 7556</a>                    MPvD Architecture                  June 2015</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.2.%20%20A%20Node%20with%20a%20VPN%20Connection"></a><a class="selflink" href="#section-4.2" name="section-4.2">4.2</a>.  A Node with a VPN Connection</span>

   If the node has established a VPN connection, zero or more (typically
   one) additional PvD(s) will be created.  These may be implicit or
   explicit.  The routing to IP addresses reachable within this PvD will
   be set up via the VPN connection, and the routing of packets to
   addresses outside the scope of this PvD will remain unaffected.  If a
   node already has N connected PvDs, after the VPN session has been
   established typically there will be N+1 connected PvDs.

   The following diagram illustrates the use of different PvDs in this
   scenario:

             &lt;----------- 'Internet' PvD ------&gt;
    +--------+
    | +----+ |    +----+         _   __        _  _
    | |Phy | |    |    |        ( `    )      ( `   )_
    | |-IF +-|----+    |--------------------(         `)
    | |    | |    |    |      (         )  (_ Internet  _)
    | +----+ |    |    |     (           )   `- __  _) -
    |        |    |Home|    (   Service    )      ||
    |        |    |Gate|    (  Provider's   )     ||
    |        |    |-way|    (   Network     -     ||
    | +----+ |    |    |    `_            )  +---------+  +------------+
    | |VPN | |    |    |      (          )   |   VPN   |  |            |
    | |-IF +-|----+    |---------------------+ Gateway |--+  Private   |
    | |    | |    |    |       (_     __)    |         |  |  Services  |
    | +----+ |    +----+         `- --       +---------+  +------------+
    +--------+
             &lt;-------------- Explicit 'VPN' PvD -----&gt;

                 Figure 2: An Example of PvD Use with VPN

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.3.%20%20A%20Home%20Network%20and%20a%20Network%20Operator%20with%20Multiple%20PvDs"></a><a class="selflink" href="#section-4.3" name="section-4.3">4.3</a>.  A Home Network and a Network Operator with Multiple PvDs</span>

   An operator may use separate PvDs for individual services that they
   offer to their customers.  These may be used so that services can be
   designed and provisioned to be completely independent of each other,
   allowing for complete flexibility in combinations of services that
   are offered to customers.

   From the perspective of the home network and the node, this model is
   functionally very similar to being multihomed to multiple upstream
   operators: Each of the different services offered by the service
   provider is its own PvD with associated PvD information.  In this
   case, the operator may provide a generic/default PvD (explicit or





<span class="grey">Anipko                        Informational                    [Page 12]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-13" id="page-13" name="page-13"> </a>
<span class="grey"><a href="rfc7556.html">RFC 7556</a>                    MPvD Architecture                  June 2015</span>


   implicit), which provides Internet access to the customer.
   Additional services would then be provisioned as explicit PvDs for
   subscribing customers.

   The following diagram illustrates this, using video-on-demand as a
   service-specific PvD:

                &lt;------ Implicit 'Internet' PvD ------&gt;
           +----+     +-----+        _   __              _  _
           |    |     |     |       ( `    )            ( `   )_
           | PC +-----+     |-------------------------(         `)
           |    |     |     |     (         )        (_ Internet  _)
           +----+     |     |    (           )         `- __  _) -
                      |Home |   (   Service    )
                      |Gate-|   (  Provider's   )
                      |way  |   (   Network     -
           +-----+    |     |   `_            )        +-----------+
           | Set-|    |     |     (          )         |ISP Video- |
           | Top +----+     |--------------------------+on-Demand  |
           | Box |    |     |      (_     __)          | Service   |
           +-----+    +-----+        `- --             +-----------+
                 &lt;-- Explicit 'Video-on-Demand' PvD --&gt;

     Figure 3: An Example of PvD Use with Wi-Fi and Mobile Interfaces

   In this case, the number of PvDs that a single operator could
   provision is based on the number of independently provisioned
   services that they offer.  Some examples may include:

   o  Real-time packet voice

   o  Streaming video

   o  Interactive video (n-way video conferencing)

   o  Interactive gaming

   o  Best effort / Internet access

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/5.%20%20Reference%20Model%20for%20the%20PvD-Aware%20Node"></a><a class="selflink" href="#section-5" name="section-5">5</a>.  Reference Model for the PvD-Aware Node</span>

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.1.%20%20Constructions%20and%20Maintenance%20of%20Separate%20PvDs"></a><a class="selflink" href="#section-5.1" name="section-5.1">5.1</a>.  Constructions and Maintenance of Separate PvDs</span>

   It is assumed that normally, the configuration information contained
   in a single PvD shall be sufficient for a node to fulfill a network
   connection request by an application, and hence there should be no
   need to attempt to merge information across different PvDs.




<span class="grey">Anipko                        Informational                    [Page 13]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-14" id="page-14" name="page-14"> </a>
<span class="grey"><a href="rfc7556.html">RFC 7556</a>                    MPvD Architecture                  June 2015</span>


   Nevertheless, even when a PvD lacks some necessary configuration
   information, merging of information associated with a different
   PvD(s) shall not be done automatically as this will typically lead to
   the issues described in [<a href="rfc6418.html" title='"Multiple Interfaces and Provisioning Domains Problem Statement"'>RFC6418</a>].

   A node may use other sources, for example: node local policy, user
   input, or other mechanisms not defined by the IETF for any of the
   following:

   o  Construction of a PvD in its entirety (analogous to statically
      configuring IP on an interface)

   o  Supplementing some or all learned PvDs with particular
      configuration elements

   o  Merging of information from different PvDs (if this is explicitly
      allowed by policy)

   As an example, a node administrator could configure the node to use a
   specific DNS resolver on a particular interface, or for a particular
   named PvD.  In the case of a per-interface DNS resolver, this might
   override or augment the DNS resolver configuration for PvDs that are
   discovered on that interface.  Such creation/augmentation of a PvD(s)
   could be static or dynamic.  The specific mechanism(s) for
   implementing this is outside the scope of this document.  Such a
   merging or overriding of DNS resolver configuration might be contrary
   to the policy that applies to a special-purpose connection, such as,
   for example, those discussed in Sections <a href="#section-5.2.1">5.2.1</a> and <a href="#section-5.2.4">5.2.4</a>.  In such
   cases, either the special-purpose connection should not be used or
   the merging/overriding should not be performed.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.2.%20%20Consistent%20Use%20of%20PvDs%20for%20Network%20Connections"></a><a class="selflink" href="#section-5.2" name="section-5.2">5.2</a>.  Consistent Use of PvDs for Network Connections</span>

   PvDs enable PvD-aware nodes to consistently use the correct set of
   configuration elements to serve specific network requests from
   beginning to end.  This section provides examples of such use.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/5.2.1.%20%20Name%20Resolution"></a><a class="selflink" href="#section-5.2.1" name="section-5.2.1">5.2.1</a>.  Name Resolution</span>

   When a PvD-aware node needs to resolve the name of the destination
   for use by a connection request, the node could use one or multiple
   PvDs for a given name lookup.

   The node shall choose a single PvD if, for example, the node policy
   required the use of a particular PvD for a specific purpose (e.g., to
   download a Multimedia Messaging Service (MMS) message using a
   specific Access Point Name (APN) over a cellular connection or to
   direct traffic of enterprise applications to a VPN connection to the



<span class="grey">Anipko                        Informational                    [Page 14]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-15" id="page-15" name="page-15"> </a>
<span class="grey"><a href="rfc7556.html">RFC 7556</a>                    MPvD Architecture                  June 2015</span>


   enterprise network).  To make this selection, the node could use a
   match between the PvD DNS suffix and a Fully Qualified Domain Name
   (FQDN) that is being resolved or a match of the PvD ID, as determined
   by the node policy.

   The node may pick multiple PvDs if, for example, the PvDs are for
   general purpose Internet connectivity, and the node is attempting to
   maximize the probability of connectivity similar to the Happy
   Eyeballs [<a href="rfc6555.html" title='"Happy Eyeballs: Success with Dual-Stack Hosts"'>RFC6555</a>] approach.  In this case, the node could perform
   DNS lookups in parallel, or in sequence.  Alternatively, the node may
   use only one PvD for the lookup, based on the PvD connectivity
   properties, user configuration of preferred Internet PvD, etc.

   If an application implements an API that provides a way of explicitly
   specifying the desired interface or PvD, that interface or PvD should
   be used for name resolution (and the subsequent connection attempt),
   provided that the host's configuration permits this.

   In either case, by default a node uses information obtained via a
   name service lookup to establish connections only within the same PvD
   as the lookup results were obtained.

   For clarification, when it is written that the name service lookup
   results were obtained "from a PvD", it should be understood to mean
   that the name service query was issued against a name service that is
   configured for use in a particular PvD.  In that sense, the results
   are "from" that particular PvD.

   Some nodes may support transports and/or APIs that provide an
   abstraction of a single connection, aggregating multiple underlying
   connections.  Multipath TCP (MPTCP) [<a href="rfc6182.html" title='"Architectural Guidelines for Multipath TCP Development"'>RFC6182</a>] is an example of such a
   transport protocol.  For connections provided by such transports/
   APIs, a PvD-aware node may use different PvDs for servicing that
   logical connection, provided that all operations on the underlying
   connections are performed consistently within their corresponding
   PvD(s).

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/5.2.2.%20%20Next-Hop%20and%20Source%20Address%20Selection"></a><a class="selflink" href="#section-5.2.2" name="section-5.2.2">5.2.2</a>.  Next-Hop and Source Address Selection</span>

   For the purpose of this example, let us assume that the preceding
   name lookup succeeded in a particular PvD.  For each obtained
   destination address, the node shall perform a next-hop lookup among
   routers associated with that PvD.  As an example, the node could
   determine such associations via matching the source address prefixes
   / specific routes advertised by the router against known PvDs or by
   receiving an explicit PvD affiliation advertised through a new Router
   Discovery [<a href="rfc4861.html" title='"Neighbor Discovery for IP version 6 (IPv6)"'>RFC4861</a>] option.




<span class="grey">Anipko                        Informational                    [Page 15]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-16" id="page-16" name="page-16"> </a>
<span class="grey"><a href="rfc7556.html">RFC 7556</a>                    MPvD Architecture                  June 2015</span>


   For each destination, once the best next hop is found, the node
   selects the best source address according to rules defined in
   [<a href="rfc6724.html" title='"Default Address Selection for Internet Protocol Version 6 (IPv6)"'>RFC6724</a>], but with the constraint that the source address must
   belong to a range associated with the used PvD.  If needed, the node
   would use the prefix policy from the same PvD for selecting the best
   source address from multiple candidates.

   When destination/source pairs are identified, they are sorted using
   the [<a href="rfc6724.html" title='"Default Address Selection for Internet Protocol Version 6 (IPv6)"'>RFC6724</a>] destination sorting rules and prefix policy table from
   the used PvD.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/5.2.3.%20%20Listening%20Applications"></a><a class="selflink" href="#section-5.2.3" name="section-5.2.3">5.2.3</a>.  Listening Applications</span>

   Consider a host connected to several PvDs, running an application
   that opens a listening socket / transport API object.  The
   application is authorized by the host policy to use a subset of
   connected PvDs that may or may not be equal to the complete set of
   the connected PvDs.  As an example, in the case where there are
   different PvDs on the Wi-Fi and cellular interfaces, for general
   Internet traffic the host could use only one, preferred PvD at a time
   (and accordingly, advertise to remote peers the host name and
   addresses associated with that PvD), or it could use one PvD as the
   default for outgoing connections, while still allowing use of the
   other PvDs simultaneously.

   Another example is a host with an established VPN connection.  Here,
   security policy could be used to permit or deny an application's
   access to the VPN PvD and other PvDs.

   For non-PvD-aware applications, the operating system has policies
   that determine the authorized set of PvDs and the preferred outgoing
   PvD.  For PvD-aware applications, both the authorized set of PvDs and
   the default outgoing PvD can be determined as the common subset
   produced between the OS policies and the set of PvD IDs or
   characteristics provided by the application.

   Application input could be provided on a per-application, per-
   transport-API-object, or per-transport-API-call basis.  The API for
   application input may have an option for specifying whether the input
   should be treated as a preference instead of a requirement.

<span class="h5"><a class="dashAnchor" name="//apple_ref/Section/5.2.3.1.%20%20Processing%20of%20Incoming%20Traffic"></a><a class="selflink" href="#section-5.2.3.1" name="section-5.2.3.1">5.2.3.1</a>.  Processing of Incoming Traffic</span>

   Unicast IP packets are received on a specific IP address associated
   with a PvD.  For multicast packets, the host can derive the PvD
   association from other configuration information, such as an explicit
   PvD property or local policy.




<span class="grey">Anipko                        Informational                    [Page 16]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-17" id="page-17" name="page-17"> </a>
<span class="grey"><a href="rfc7556.html">RFC 7556</a>                    MPvD Architecture                  June 2015</span>


   The node OS or middleware may apply more advanced techniques for
   determining the resultant PvD and/or authorization of the incoming
   traffic.  Those techniques are outside the scope of this document.

   If the determined receiving PvD of a packet is not in the allowed
   subset of PvDs for the particular application/transport API object,
   the packet should be handled in the same way as if there were no
   listener.

<span class="h6"><a class="dashAnchor" name="//apple_ref/Section/5.2.3.1.1.%20%20Connection-Oriented%20APIs"></a><a class="selflink" href="#section-5.2.3.1.1" name="section-5.2.3.1.1">5.2.3.1.1</a>.  Connection-Oriented APIs</span>

   For connection-oriented APIs, when the initial incoming packet is
   received, the packet PvD is remembered for the established connection
   and used for the handling of outgoing traffic for that connection.
   While typically connection-oriented APIs use a connection-oriented
   transport protocol, such as TCP, it is possible to have a connection-
   oriented API that uses a generally connectionless transport protocol,
   such as UDP.

   For APIs/protocols that support multiple IP traffic flows associated
   with a single transport API connection object (for example, Multipath
   TCP), the processing rules may be adjusted accordingly.

<span class="h6"><a class="dashAnchor" name="//apple_ref/Section/5.2.3.1.2.%20%20Connectionless%20APIs"></a><a class="selflink" href="#section-5.2.3.1.2" name="section-5.2.3.1.2">5.2.3.1.2</a>.  Connectionless APIs</span>

   For connectionless APIs, the host should provide an API that
   PvD-aware applications can use to query the PvD associated with the
   packet.  For outgoing traffic on this transport API object, the OS
   should use the selected outgoing PvDs, determined as described in
   Sections <a href="#section-5.2.1">5.2.1</a> and <a href="#section-5.2.2">5.2.2</a>.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/5.2.4.%20%20Enforcement%20of%20Security%20Policies"></a><a class="selflink" href="#section-5.2.4" name="section-5.2.4">5.2.4</a>.  Enforcement of Security Policies</span>

   By themselves, PvDs do not define, and cannot be used for
   communication of, security policies.  When implemented in a network,
   this architecture provides the host with information about connected
   networks.  The actual behavior of the host then depends on the host's
   policies (provisioned through mechanisms out of scope of this
   document), applied by taking received PvD information into account.
   In some scenarios, e.g., a VPN, such policies could require the host
   to use only a particular VPN PvD for some/all of the application's
   traffic (VPN 'disable split tunneling' also known as 'force
   tunneling' behavior) or apply such restrictions only to selected
   applications and allow the simultaneous use of the VPN PvD together
   with the other connected PvDs by the other or all applications (VPN
   'split tunneling' behavior).





<span class="grey">Anipko                        Informational                    [Page 17]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-18" id="page-18" name="page-18"> </a>
<span class="grey"><a href="rfc7556.html">RFC 7556</a>                    MPvD Architecture                  June 2015</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.3.%20%20Connectivity%20Tests"></a><a class="selflink" href="#section-5.3" name="section-5.3">5.3</a>.  Connectivity Tests</span>

   Although some PvDs may appear as valid candidates for PvD selection
   (e.g., good link quality, consistent connection parameters, etc.),
   they may provide limited or no connectivity to the desired network or
   the Internet.  For example, some PvDs provide limited IP connectivity
   (e.g., scoped to the link or to the access network) but require the
   node to authenticate through a web portal to get full access to the
   Internet.  This may be more likely to happen for PvDs that are not
   trusted by a given PvD-aware node.

   An attempt to use such a PvD may lead to limited network connectivity
   or application connection failures.  To prevent the latter, a PvD-
   aware node may perform a connectivity test for the PvD before using
   it to serve application network connection requests.  In current
   implementations, some nodes already implement this, e.g., by trying
   to reach a dedicated web server (see [<a href="rfc6419.html" title='"Current Practices for Multiple-Interface Hosts"'>RFC6419</a>]).

   <a href="#section-5.2">Section 5.2</a> describes how a PvD-aware node shall maintain and use
   multiple PvDs separately.  The PvD-aware node shall perform a
   connectivity test and, only after validation of the PvD, consider
   using it to serve application connections requests.  Ongoing
   connectivity tests are also required, since during the IP session,
   the end-to-end connectivity could be disrupted for various reasons
   (e.g., L2 problems and IP QoS issues); hence, a connectivity
   monitoring function is needed to check the connectivity status and
   remove the PvD from the set of usable PvDs if necessary.

   There may be cases where a connectivity test for PvD selection may
   not be appropriate and should be complemented, or replaced, by PvD
   selection based on other factors.  For example, this could be
   realized by leveraging some 3GPP and IEEE mechanisms, which would
   allow the exposure of some PvD characteristics to the node (e.g.,
   3GPP Access Network Discovery and Selection Function (ANDSF)
   [<a href="#ref-TS23402" title='"Technical Specification Group Services and System Aspects; Architecture enhancements for non-3GPP accesses"'>TS23402</a>], Access Network Query Protocol (ANQP) [<a href="#ref-IEEE802.11u">IEEE802.11u</a>]).

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.4.%20%20Relationship%20to%20Interface%20Management%20and%20Connection%20Managers"></a><a class="selflink" href="#section-5.4" name="section-5.4">5.4</a>.  Relationship to Interface Management and Connection Managers</span>

   Current devices such as mobile handsets make use of proprietary
   mechanisms and custom applications to manage connectivity in
   environments with multiple interfaces and multiple sets of network
   configuration.  These mechanisms or applications are commonly known
   as connection managers [<a href="rfc6419.html" title='"Current Practices for Multiple-Interface Hosts"'>RFC6419</a>].

   Connection managers sometimes rely on policy servers to allow a node
   that is connected to multiple networks to perform network selection.
   They can also make use of routing guidance from the network (e.g.,
   3GPP ANDSF [<a href="#ref-TS23402" title='"Technical Specification Group Services and System Aspects; Architecture enhancements for non-3GPP accesses"'>TS23402</a>]).  Although connection managers solve some



<span class="grey">Anipko                        Informational                    [Page 18]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-19" id="page-19" name="page-19"> </a>
<span class="grey"><a href="rfc7556.html">RFC 7556</a>                    MPvD Architecture                  June 2015</span>


   connectivity problems, they rarely address network selection problems
   in a comprehensive manner.  With proprietary solutions, it is
   challenging to present coherent behavior to the end user of the
   device, as different platforms present different behaviors even when
   connected to the same network, with the same type of interface, and
   for the same purpose.  The architecture described in this document
   should improve the host's behavior by providing the hosts with tools
   and guidance to make informed network selection decisions.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/6.%20%20PvD%20Support%20in%20APIs"></a><a class="selflink" href="#section-6" name="section-6">6</a>.  PvD Support in APIs</span>

   For all levels of PvD support in APIs described in this chapter, it
   is expected that the notifications about changes in the set of
   available PvDs are exposed as part of the API surface.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/6.1.%20%20Basic"></a><a class="selflink" href="#section-6.1" name="section-6.1">6.1</a>.  Basic</span>

   Applications are not PvD aware in any manner and only submit
   connection requests.  The node performs PvD selection implicitly,
   without any application participation, based purely on node-specific
   administrative policies and/or choices made by the user from a user
   interface provided by the operating environment, not by the
   application.

   As an example, PvD selection can be done at the name service lookup
   step by using the relevant configuration elements, such as those
   described in [<a href="rfc6731.html" title='"Improved Recursive DNS Server Selection for Multi-Interfaced Nodes"'>RFC6731</a>].  As another example, PvD selection could be
   made based on application identity or type (i.e., a node could always
   use a particular PvD for a Voice over IP (VoIP) application).

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/6.2.%20%20Intermediate"></a><a class="selflink" href="#section-6.2" name="section-6.2">6.2</a>.  Intermediate</span>

   Applications indirectly participate in PvD selection by specifying
   hard requirements and soft preferences.  As an example, a real-time
   communication application intending to use the connection for the
   exchange of real-time audio/video data may indicate a preference or a
   requirement for connection quality, which could affect PvD selection
   (different PvDs could correspond to Internet connections with
   different loss rates and latencies).

   Another example is the connection of an infrequently executed
   background activity, which checks for application updates and
   performs large downloads when updates are available.  For such
   connections, a cheaper or zero-cost PvD may be preferable, even if
   such a connection has a higher relative loss rate or lower bandwidth.
   The node performs PvD selection based on applications' inputs and
   policies and/or user preferences.  Some/all properties of the
   resultant PvD may be exposed to applications.



<span class="grey">Anipko                        Informational                    [Page 19]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-20" id="page-20" name="page-20"> </a>
<span class="grey"><a href="rfc7556.html">RFC 7556</a>                    MPvD Architecture                  June 2015</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/6.3.%20%20Advanced"></a><a class="selflink" href="#section-6.3" name="section-6.3">6.3</a>.  Advanced</span>

   PvDs are directly exposed to applications for enumeration and
   selection.  Node polices and/or user choices may still override the
   applications' preferences and limit which PvD(s) can be enumerated
   and/or used by the application, irrespective of any preferences that
   the application may have specified.  Depending on the implementation,
   such restrictions (imposed by node policy and/or user choice) may or
   may not be visible to the application.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/7.%20%20PvD%20Trust%20for%20PvD-Aware%20Node"></a><a class="selflink" href="#section-7" name="section-7">7</a>.  PvD Trust for PvD-Aware Node</span>

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/7.1.%20%20Untrusted%20PvDs"></a><a class="selflink" href="#section-7.1" name="section-7.1">7.1</a>.  Untrusted PvDs</span>

   Implicit and explicit PvDs for which no trust relationship exists are
   considered untrusted.  Only PvDs that meet the requirements in
   <a href="#section-7.2">Section 7.2</a> are trusted; any other PvD is untrusted.

   In order to avoid the various forms of misinformation that could
   occur when PvDs are untrusted, nodes that implement PvD separation
   cannot assume that two explicit PvDs with the same identifier are
   actually the same PvD.  A node that makes this assumption will be
   vulnerable to attacks where, for example, an open Wi-Fi hotspot might
   assert that it was part of another PvD and thereby attempt to draw
   traffic intended for that PvD onto its own network.

   Since implicit PvD identifiers are synthesized by the node, this
   issue cannot arise with implicit PvDs.

   Mechanisms exist (for example, [<a href="rfc6731.html" title='"Improved Recursive DNS Server Selection for Multi-Interfaced Nodes"'>RFC6731</a>]) whereby a PvD can provide
   configuration information that asserts special knowledge about the
   reachability of resources through that PvD.  Such assertions cannot
   be validated unless the node has a trust relationship with the PvD;
   therefore, assertions of this type must be ignored by nodes that
   receive them from untrusted PvDs.  Failure to ignore such assertions
   could result in traffic being diverted from legitimate destinations
   to spoofed destinations.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/7.2.%20%20Trusted%20PvDs"></a><a class="selflink" href="#section-7.2" name="section-7.2">7.2</a>.  Trusted PvDs</span>

   Trusted PvDs are PvDs for which two conditions apply: First, a trust
   relationship must exist between the node that is using the PvD
   configuration and the source that provided that configuration; this
   is the authorization portion of the trust relationship.  Second,
   there must be some way to validate the trust relationship.  This is
   the authentication portion of the trust relationship.  Two mechanisms
   for validating the trust relationship are defined.




<span class="grey">Anipko                        Informational                    [Page 20]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-21" id="page-21" name="page-21"> </a>
<span class="grey"><a href="rfc7556.html">RFC 7556</a>                    MPvD Architecture                  June 2015</span>


   It shall be possible to validate the trust relationship for all
   advertised elements of a trusted PvD, irrespective of whether the PvD
   elements are communicated as a whole, e.g., in a single DHCP option,
   or separately, e.g., in supplementary RA options.  The feasibility of
   mechanisms to implement a trust relationship for all PvD elements
   will be determined in the respective companion design documents.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/7.2.1.%20%20Authenticated%20PvDs"></a><a class="selflink" href="#section-7.2.1" name="section-7.2.1">7.2.1</a>.  Authenticated PvDs</span>

   One way to validate the trust relationship between a node and the
   source of a PvD is through the combination of cryptographic
   authentication and an identifier configured on the node.

   If authentication is done using a public key mechanism such as PKI
   certificate chain validation or DNS-Based Authentication of Named
   Entities (DANE), authentication by itself is not enough since
   theoretically any PvD could be authenticated in this way.  In
   addition to authentication, the node would need configuration to
   trust the identifier being authenticated.  Validating the
   authenticated PvD name against a list of PvD names configured as
   trusted on the node would constitute the authorization step in this
   case.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/7.2.2.%20%20PvDs%20Trusted%20by%20Attachment"></a><a class="selflink" href="#section-7.2.2" name="section-7.2.2">7.2.2</a>.  PvDs Trusted by Attachment</span>

   In some cases, a trust relationship may be validated by some means
   other than those described in <a href="#section-7.2.1">Section 7.2.1</a> simply by virtue of the
   connection through which the PvD was obtained.  For instance, a
   handset connected to a mobile network may know through the mobile
   network infrastructure that it is connected to a trusted PvD.
   Whatever mechanism was used to validate that connection constitutes
   the authentication portion of the PvD trust relationship.
   Presumably, such a handset would be configured from the factory (or
   else through mobile operator or user preference settings) to trust
   the PvD, and this would constitute the authorization portion of this
   type of trust relationship.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/8.%20%20Security%20Considerations"></a><a class="selflink" href="#section-8" name="section-8">8</a>.  Security Considerations</span>

   There are at least three different forms of attacks that can be
   performed using configuration sources that support multiple
   provisioning domains.

   Tampering with provided configuration information:  An attacker may
      attempt to modify information provided inside the PvD container
      option.  These attacks can easily be prevented by using message
      integrity features provided by the underlying protocol used to
      carry the configuration information.  For example, SEcure Neighbor



<span class="grey">Anipko                        Informational                    [Page 21]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-22" id="page-22" name="page-22"> </a>
<span class="grey"><a href="rfc7556.html">RFC 7556</a>                    MPvD Architecture                  June 2015</span>


      Discovery (SEND) [<a href="rfc3971.html" title='"SEcure Neighbor Discovery (SEND)"'>RFC3971</a>] would detect any form of tampering with
      the RA contents and the DHCPv6 [<a href="rfc3315.html" title='"Dynamic Host Configuration Protocol for IPv6 (DHCPv6)"'>RFC3315</a>] AUTH option that would
      detect any form of tampering with the DHCPv6 message contents.
      This attack can also be performed by a compromised configuration
      source by modifying information inside a specific PvD, in which
      case the mitigations proposed in the next subsection may be
      helpful.

   Rogue configuration source:  A compromised configuration source, such
      as a router or a DHCPv6 server, may advertise information about
      PvDs that it is not authorized to advertise.  For example, a
      coffee shop WLAN may advertise configuration information
      purporting to be from an enterprise and may try to attract
      enterprise-related traffic.  This may also occur accidentally if
      two sites choose the same identifier (e.g., "linsky").

      In order to detect and prevent this, the client must be able to
      authenticate the identifier provided by the network.  This means
      that the client must have configuration information that maps the
      PvD identifier to an identity and must be able to authenticate
      that identity.

      In addition, the network must provide information the client can
      use to authenticate the identity.  This could take the form of a
      PKI-based or DNSSEC-based trust anchor, or a key remembered from a
      previous leap-of-faith authentication of the identifier.

      Because the PvD-specific information may come to the network
      infrastructure with which the client is actually communicating
      from some upstream provider, it is necessary in this case that the
      PvD container and its contents be relayed to the client unchanged,
      leaving the upstream provider's signature intact.

   Replay attacks:  A compromised configuration source or an on-link
      attacker may try to capture advertised configuration information
      and replay it on a different link, or at a future point in time.
      This can be avoided by including a replay protection mechanism
      such as a timestamp or a nonce inside the PvD container to ensure
      the validity of the provided information.












<span class="grey">Anipko                        Informational                    [Page 22]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-23" id="page-23" name="page-23"> </a>
<span class="grey"><a href="rfc7556.html">RFC 7556</a>                    MPvD Architecture                  June 2015</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/9.%20%20Informative%20References"></a><a class="selflink" href="#section-9" name="section-9">9</a>.  Informative References</span>

   [<a id="ref-DHCPv6-CLASS-BASED-PREFIX" name="ref-DHCPv6-CLASS-BASED-PREFIX">DHCPv6-CLASS-BASED-PREFIX</a>]
              Systems, C., Halwasia, G., Gundavelli, S., Deng, H.,
              Thiebaut, L., Korhonen, J., and I. Farrer, "DHCPv6 class
              based prefix", Work in Progress, <a href="https://tools.ietf.org/html/draft-bhandari-dhc-class-based-prefix-05">draft-bhandari-dhc-class-</a>
              <a href="https://tools.ietf.org/html/draft-bhandari-dhc-class-based-prefix-05">based-prefix-05</a>, July 2013.

   [<a id="ref-IEEE802.11u" name="ref-IEEE802.11u">IEEE802.11u</a>]
              IEEE, "Local and Metropolitan networks - specific
              requirements - Part II: Wireless LAN Medium Access Control
              (MAC) and Physical Layer (PHY) specifications: Amendment
              9: Interworking with External Networks", IEEE Std 802.11u,
              &lt;<a href="http://standards.ieee.org/findstds/standard/802.11u-2011.html">http://standards.ieee.org/findstds/</a>
              <a href="http://standards.ieee.org/findstds/standard/802.11u-2011.html">standard/802.11u-2011.html</a>&gt;.

   [<a id="ref-IPv6-PREFIX-PROPERTIES" name="ref-IPv6-PREFIX-PROPERTIES">IPv6-PREFIX-PROPERTIES</a>]
              Korhonen, J., Patil, B., Gundavelli, S., Seite, P., and D.
              Liu, "IPv6 Prefix Mobility Management Properties", Work in
              Progress, <a href="https://tools.ietf.org/html/draft-korhonen-dmm-prefix-properties-03">draft-korhonen-dmm-prefix-properties-03</a>, October
              2012.

   [<a id="ref-RFC3315" name="ref-RFC3315">RFC3315</a>]  Droms, R., Ed., Bound, J., Volz, B., Lemon, T., Perkins,
              C., and M. Carney, "Dynamic Host Configuration Protocol
              for IPv6 (DHCPv6)", <a href="rfc3315.html">RFC 3315</a>, DOI 10.17487/RFC3315, July
              2003, &lt;<a href="http://www.rfc-editor.org/info/rfc3315">http://www.rfc-editor.org/info/rfc3315</a>&gt;.

   [<a id="ref-RFC3971" name="ref-RFC3971">RFC3971</a>]  Arkko, J., Ed., Kempf, J., Zill, B., and P. Nikander,
              "SEcure Neighbor Discovery (SEND)", <a href="rfc3971.html">RFC 3971</a>,
              DOI 10.17487/RFC3971, March 2005,
              &lt;<a href="http://www.rfc-editor.org/info/rfc3971">http://www.rfc-editor.org/info/rfc3971</a>&gt;.

   [<a id="ref-RFC4861" name="ref-RFC4861">RFC4861</a>]  Narten, T., Nordmark, E., Simpson, W., and H. Soliman,
              "Neighbor Discovery for IP version 6 (IPv6)", <a href="rfc4861.html">RFC 4861</a>,
              DOI 10.17487/RFC4861, September 2007,
              &lt;<a href="http://www.rfc-editor.org/info/rfc4861">http://www.rfc-editor.org/info/rfc4861</a>&gt;.

   [<a id="ref-RFC5739" name="ref-RFC5739">RFC5739</a>]  Eronen, P., Laganier, J., and C. Madson, "IPv6
              Configuration in Internet Key Exchange Protocol Version 2
              (IKEv2)", <a href="rfc5739.html">RFC 5739</a>, DOI 10.17487/RFC5739, February 2010,
              &lt;<a href="http://www.rfc-editor.org/info/rfc5739">http://www.rfc-editor.org/info/rfc5739</a>&gt;.

   [<a id="ref-RFC6182" name="ref-RFC6182">RFC6182</a>]  Ford, A., Raiciu, C., Handley, M., Barre, S., and J.
              Iyengar, "Architectural Guidelines for Multipath TCP
              Development", <a href="rfc6182.html">RFC 6182</a>, DOI 10.17487/RFC6182, March 2011,
              &lt;<a href="http://www.rfc-editor.org/info/rfc6182">http://www.rfc-editor.org/info/rfc6182</a>&gt;.





<span class="grey">Anipko                        Informational                    [Page 23]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-24" id="page-24" name="page-24"> </a>
<span class="grey"><a href="rfc7556.html">RFC 7556</a>                    MPvD Architecture                  June 2015</span>


   [<a id="ref-RFC6418" name="ref-RFC6418">RFC6418</a>]  Blanchet, M. and P. Seite, "Multiple Interfaces and
              Provisioning Domains Problem Statement", <a href="rfc6418.html">RFC 6418</a>,
              DOI 10.17487/RFC6418, November 2011,
              &lt;<a href="http://www.rfc-editor.org/info/rfc6418">http://www.rfc-editor.org/info/rfc6418</a>&gt;.

   [<a id="ref-RFC6419" name="ref-RFC6419">RFC6419</a>]  Wasserman, M. and P. Seite, "Current Practices for
              Multiple-Interface Hosts", <a href="rfc6419.html">RFC 6419</a>, DOI 10.17487/RFC6419,
              November 2011, &lt;<a href="http://www.rfc-editor.org/info/rfc6419">http://www.rfc-editor.org/info/rfc6419</a>&gt;.

   [<a id="ref-RFC6555" name="ref-RFC6555">RFC6555</a>]  Wing, D. and A. Yourtchenko, "Happy Eyeballs: Success with
              Dual-Stack Hosts", <a href="rfc6555.html">RFC 6555</a>, DOI 10.17487/RFC6555, April
              2012, &lt;<a href="http://www.rfc-editor.org/info/rfc6555">http://www.rfc-editor.org/info/rfc6555</a>&gt;.

   [<a id="ref-RFC6724" name="ref-RFC6724">RFC6724</a>]  Thaler, D., Ed., Draves, R., Matsumoto, A., and T. Chown,
              "Default Address Selection for Internet Protocol Version 6
              (IPv6)", <a href="rfc6724.html">RFC 6724</a>, DOI 10.17487/RFC6724, September 2012,
              &lt;<a href="http://www.rfc-editor.org/info/rfc6724">http://www.rfc-editor.org/info/rfc6724</a>&gt;.

   [<a id="ref-RFC6731" name="ref-RFC6731">RFC6731</a>]  Savolainen, T., Kato, J., and T. Lemon, "Improved
              Recursive DNS Server Selection for Multi-Interfaced
              Nodes", <a href="rfc6731.html">RFC 6731</a>, DOI 10.17487/RFC6731, December 2012,
              &lt;<a href="http://www.rfc-editor.org/info/rfc6731">http://www.rfc-editor.org/info/rfc6731</a>&gt;.

   [<a id="ref-RFC7078" name="ref-RFC7078">RFC7078</a>]  Matsumoto, A., Fujisaki, T., and T. Chown, "Distributing
              Address Selection Policy Using DHCPv6", <a href="rfc7078.html">RFC 7078</a>,
              DOI 10.17487/RFC7078, January 2014,
              &lt;<a href="http://www.rfc-editor.org/info/rfc7078">http://www.rfc-editor.org/info/rfc7078</a>&gt;.

   [<a id="ref-RFC7296" name="ref-RFC7296">RFC7296</a>]  Kaufman, C., Hoffman, P., Nir, Y., Eronen, P., and T.
              Kivinen, "Internet Key Exchange Protocol Version 2
              (IKEv2)", STD 79, <a href="rfc7296.html">RFC 7296</a>, DOI 10.17487/RFC7296, October
              2014, &lt;<a href="http://www.rfc-editor.org/info/rfc7296">http://www.rfc-editor.org/info/rfc7296</a>&gt;.

   [<a id="ref-TS23402" name="ref-TS23402">TS23402</a>]  3GPP, "Technical Specification Group Services and System
              Aspects; Architecture enhancements for non-3GPP accesses",
              Release 12, 3GPP TS 23.402, 2014.















<span class="grey">Anipko                        Informational                    [Page 24]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-25" id="page-25" name="page-25"> </a>
<span class="grey"><a href="rfc7556.html">RFC 7556</a>                    MPvD Architecture                  June 2015</span>


Acknowledgments

   The authors would like to thank (in no specific order) Ian Farrer,
   Markus Stenberg, and Mikael Abrahamsson for their review and
   comments.

Contributors

   The following individuals contributed to this document (listed in no
   specific order): Alper Yegin (alper.yegin@yegin.org), Aaron Yi Ding
   (yding@cs.helsinki.fi), Zhen Cao (caozhenpku@gmail.com), Dapeng Liu
   (liudapeng@chinamobile.com), Dave Thaler (dthaler@microsoft.com),
   Dmitry Anipko (dmitry.anipko@gmail.com), Hui Deng
   (denghui@chinamobile.com), Jouni Korhonen (jouni.nospam@gmail.com),
   Juan Carlos Zuniga (JuanCarlos.Zuniga@InterDigital.com), Konstantinos
   Pentikousis (k.pentikousis@huawei.com), Marc Blanchet
   (marc.blanchet@viagenie.ca), Margaret Wasserman
   (margaretw42@gmail.com), Pierrick Seite (pierrick.seite@orange.com),
   Suresh Krishnan (suresh.krishnan@ericsson.com), Teemu Savolainen
   (teemu.savolainen@nokia.com), Ted Lemon (ted.lemon@nominum.com), and
   Tim Chown (tjc@ecs.soton.ac.uk).

Author's Address

   Dmitry Anipko (editor)
   Unaffiliated

   Phone: +1 425 442 6356
   EMail: dmitry.anipko@gmail.com






















Anipko                        Informational                    [Page 25]

</pre><br/>
    <span class="noprint"><small><small>Html markup produced by rfcmarkup 1.126, available from
      <a href="https://tools.ietf.org/tools/rfcmarkup/">https://tools.ietf.org/tools/rfcmarkup/</a>
    </small></small></span>
  </div>




</body><!-- Mirrored from tools.ietf.org/html/rfc7556 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 06 Mar 2018 23:18:21 GMT --></html>