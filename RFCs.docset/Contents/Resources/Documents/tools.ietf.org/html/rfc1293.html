<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

<!-- Mirrored from tools.ietf.org/html/rfc1293 by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 28 Jul 2019 13:17:29 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head profile="http://dublincore.org/documents/2008/08/04/dc-html/">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="robots" content="index,follow" />
    <meta name="creator" content="rfcmarkup version 1.129c" />
    <link rel="schema.DC" href="http://purl.org/dc/elements/1.1/" />
<meta name="DC.Identifier" content="urn:ietf:rfc:1293" />
<meta name="DC.Description.Abstract" content="This memo describes additions to ARP that will allow a station to
request a protocol address corresponding to a given hardware address.
[STANDARDS-TRACK]" />
<meta name="DC.Creator" content="Bradley, T." />
<meta name="DC.Creator" content="Brown, C." />
<meta name="DC.Date.Issued" content="January, 1992" />
<meta name="DC.Title" content="Inverse Address Resolution Protocol" />

    <link rel="icon" href="https://tools.ietf.org/images/rfc.png" type="image/png" />
    <link rel="shortcut icon" href="https://tools.ietf.org/images/rfc.png" type="image/png" />
    <title>RFC 1293 - Inverse Address Resolution Protocol</title>
    
    
    <style type="text/css">
	@media only screen 
	  and (min-width: 992px)
	  and (max-width: 1199px) {
	    body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 768px)
	  and (max-width: 991px) {
            body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 480px)
	  and (max-width: 767px) {
            body { font-size: 11pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (max-width: 479px) {
            body { font-size: 8pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-device-width : 375px) 
	  and (max-device-width : 667px) {
            body { font-size: 9.5pt; }
            div.content { width: 96ex; margin: 0; }
        }
	@media only screen 
	  and (min-device-width: 1200px) {
            body { font-size: 10pt; margin: 0 4em; }
            div.content { width: 96ex; margin: 0; }
        }
        h1, h2, h3, h4, h5, h6, .h1, .h2, .h3, .h4, .h5, .h6 {
	    font-weight: bold;
            line-height: 0pt;
            display: inline;
            white-space: pre;
            font-family: monospace;
            font-size: 1em;
	    font-weight: bold;
        }
        pre {
            font-size: 1em;
            margin-top: 0px;
            margin-bottom: 0px;
        }
	.pre {
	    white-space: pre;
	    font-family: monospace;
	}
	.header{
	    font-weight: bold;
	}
        .newpage {
            page-break-before: always;
        }
        .invisible {
            text-decoration: none;
            color: white;
        }
        a.selflink {
          color: black;
          text-decoration: none;
        }
        @media print {
            body {
                font-family: monospace;
                font-size: 10.5pt;
            }
            h1, h2, h3, h4, h5, h6 {
                font-size: 1em;
            }
        
            a:link, a:visited {
                color: inherit;
                text-decoration: none;
            }
            .noprint {
                display: none;
            }
        }
	@media screen {
	    .grey, .grey a:link, .grey a:visited {
		color: #777;
	    }
            .docinfo {
                background-color: #EEE;
            }
            .top {
                border-top: 7px solid #EEE;
            }
            .bgwhite  { background-color: white; }
            .bgred    { background-color: #F44; }
            .bggrey   { background-color: #666; }
            .bgbrown  { background-color: #840; }            
            .bgorange { background-color: #FA0; }
            .bgyellow { background-color: #EE0; }
            .bgmagenta{ background-color: #F4F; }
            .bgblue   { background-color: #66F; }
            .bgcyan   { background-color: #4DD; }
            .bggreen  { background-color: #4F4; }

            .legend   { font-size: 90%; }
            .cplate   { font-size: 70%; border: solid grey 1px; }
	}
    </style>
    <!--[if IE]>
    <style>
    body {
       font-size: 13px;
       margin: 10px 10px;
    }
    </style>
    <![endif]-->

    <script type="text/javascript"><!--
    function addHeaderTags() {
	var spans = document.getElementsByTagName("span");
	for (var i=0; i < spans.length; i++) {
	    var elem = spans[i];
	    if (elem) {
		var level = elem.getAttribute("class");
                if (level == "h1" || level == "h2" || level == "h3" || level == "h4" || level == "h5" || level == "h6") {
                    elem.innerHTML = "<"+level+">"+elem.innerHTML+"</"+level+">";		
                }
	    }
	}
    }
    var legend_html = "Colour legend:<br />      <table>         <tr><td>Unknown:</td>                   <td><span class='cplate bgwhite'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft:</td>                     <td><span class='cplate bgred'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Informational:</td>             <td><span class='cplate bgorange'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Experimental:</td>              <td><span class='cplate bgyellow'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Best Common Practice:</td>      <td><span class='cplate bgmagenta'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Proposed Standard:</td>         <td><span class='cplate bgblue'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft Standard (old designation):</td> <td><span class='cplate bgcyan'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Internet Standard:</td>         <td><span class='cplate bggreen'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Historic:</td>                  <td><span class='cplate bggrey'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Obsolete:</td>                  <td><span class='cplate bgbrown'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>     </table>";
    function showElem(id) {
        var elem = document.getElementById(id);
        elem.innerHTML = eval(id+"_html");
        elem.style.visibility='visible';
    }
    function hideElem(id) {
        var elem = document.getElementById(id);
        elem.style.visibility='hidden';        
        elem.innerHTML = "";
    }
    // -->
    </script>
</head>
<body onload="addHeaderTags()">
  <div class="content">
   <div style="height: 13px;">
      <div onmouseover="this.style.cursor='pointer';"
         onclick="showElem('legend');"
         onmouseout="hideElem('legend')"
	 style="height: 6px; position: absolute;"
         class="pre noprint docinfo bgbrown"
         title="Click for colour legend." >                                                                        </div>
      <div id="legend"
           class="docinfo noprint pre legend"
           style="position:absolute; top: 4px; left: 4ex; visibility:hidden; background-color: white; padding: 4px 9px 5px 7px; border: solid #345 1px; "
           onmouseover="showElem('legend');"
           onmouseout="hideElem('legend');">
      </div>
   </div>
<span class="pre noprint docinfo top">[<a href="index.html" title="Document search and retrieval page">Docs</a>] [<a href="https://tools.ietf.org/rfc/rfc1293.txt" title="Plaintext version of this document">txt</a>|<a href="https://tools.ietf.org/pdf/rfc1293" title="PDF version of this document">pdf</a>] [<a href="https://tools.ietf.org/html/draft-ietf-iplpdn-inarp" title="draft-ietf-iplpdn-inarp">draft-ietf-iplp...</a>] [<a href='https://datatracker.ietf.org/doc/rfc1293' title='IESG Datatracker information for this document'>Tracker</a>] [<a href="https://tools.ietf.org/rfcdiff?difftype=--hwdiff&amp;url2=rfc1293" title="Inline diff (wdiff)">Diff1</a>] [<a href="https://tools.ietf.org/rfcdiff?url2=rfc1293" title="Side-by-side diff">Diff2</a>]         </span><br />
<span class="pre noprint docinfo">                                                                        </span><br />
<span class="pre noprint docinfo">Obsoleted by: <a href="rfc2390.html">2390</a>                                     PROPOSED STANDARD</span><br />
<span class="pre noprint docinfo">                                                                        </span><br />
<pre>
Network Working Group                                         T. Bradley
Request for Comments: 1293                                      C. Brown
                                          Wellfleet Communications, Inc.
                                                            January 1992

                  <span class="h1">Inverse Address Resolution Protocol</span>

<span class="h2"><a class="selflink" name="section-1" href="#section-1">1</a>.  Status of this Memo</span>

   This RFC specifies an IAB standards track protocol for the Internet
   community, and requests discussion and suggestions for improvements.
   Please refer to the current edition of the "IAB Official Protocol
   Standards" for the standardization state and status of this protocol.
   Distribution of this memo is unlimited.

<span class="h2"><a class="selflink" name="section-2" href="#section-2">2</a>.  Abstract</span>

   This memo describes additions to ARP that will allow a station to
   request a protocol address corresponding to a given hardware address.
   Specifically, this applies to Frame Relay stations that may have a
   Data Link Connection Identifier (DLCI), the Frame Relay equivalent of
   a hardware address, associated with an established Permanent Virtual
   Circuit (PVC), but do not know the protocol address of the station on
   the other side of this connection.  It will also apply to other
   networks with similar circumstances.

<span class="h2"><a class="selflink" name="section-3" href="#section-3">3</a>.  Conventions</span>

   The following language conventions are used in the items of
   specification in this document:

     o Must, Will, Shall or Mandatory -- the item is an absolute
       requirement of the specification.

     o Should or Recommended -- the item should generally be
       followed for all but exceptional circumstances.

     o May or Optional -- the item is truly optional and may be
       followed or ignored according to the needs of the
       implementor.

<span class="h2"><a class="selflink" name="section-4" href="#section-4">4</a>.  Introduction</span>

   This document will rely heavily on Frame Relay as an example of how
   the Inverse Address Resolution Protocol (InARP) can be useful. It is
   not, however, intended that InARP be used exclusively with Frame
   Relay.  InARP may be used in any network that provides destination
   hardware addresses without indicating corresponding protocol



<span class="grey">Bradley, Brown                                                  [Page 1]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-2" id="page-2" href="#page-2" class="invisible"> </a>
<span class="grey"><a href="rfc1293.html">RFC 1293</a>                      Inverse ARP                   January 1992</span>


   addresses.

<span class="h2"><a class="selflink" name="section-5" href="#section-5">5</a>.  Motivation</span>

   The motivation for the development of Inverse ARP is a result of the
   desire to make dynamic address resolution within Frame Relay both
   possible and efficient.  Permanent virtual circuits (PVCs) and
   eventually switched virtual circuits (SVCs) are identified by a Data
   Link Connection Identifier (DLCI).  These DLCIs define a single
   virtual connection through the wide area network (WAN) and are the
   Frame Relay equivalent to a hardware address.  Periodically, through
   the exchange of signalling messages, a network may announce a new
   virtual circuit with its corresponding DLCI.  Unfortunately, protocol
   addressing is not included in the announcement.  The station
   receiving such an indication will learn of the new connection, but
   will not be able to address the other side.  Without a new
   configuration or mechanism for discovering the protocol address of
   the other side, this new virtual circuit is unusable.

   Other resolution methods were considered to solve the problems, but
   were rejected.  Reverse ARP [<a href="#ref-4" title="&quot;A Reverse Address Resolution Protocol&quot;">4</a>], for example, seemed like a good
   candidate, but the response to a request is the protocol address of
   the requesting station not the station receiving the request as we
   wanted.  IP specific mechanisms were limiting since we wished to
   allow protocol address resolution of many protocols.  For this
   reason, we expanded the ARP protocol.

   Inverse Address Resolution Protocol (InARP) will allow a Frame Relay
   station to discover the protocol address of a station associated with
   the virtual circuit.  It is more efficiently than simulating a
   broadcast with multiple copies of the same message and it is more
   flexible than relying on static configuration.

<span class="h2"><a class="selflink" name="section-6" href="#section-6">6</a>.  Packet Format</span>

   Inverse ARP is an extension of the existing ARP.  Therefore, it has
   the same format as standard ARP.

      ar$hrd   16 bits         Hardware type
      ar$pro   16 bits         Protocol type
      ar$hln    8 bits         Byte length of each hardware address (n)
      ar$pln    8 bits         Byte length of each protocol address (m)
      ar$op    16 bits         Operation code
      ar$sha    nbytes         source hardware address
      ar$spa    mbytes         source protocol address
      ar$tha    nbytes         target hardware address
      ar$tpa    mbytes         target protocol address




<span class="grey">Bradley, Brown                                                  [Page 2]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-3" id="page-3" href="#page-3" class="invisible"> </a>
<span class="grey"><a href="rfc1293.html">RFC 1293</a>                      Inverse ARP                   January 1992</span>


   Possible values for hardware and protocol types are the same as those
   for ARP and may be found in the current Assigned Numbers RFC [<a href="#ref-2" title="&quot;Assigned Numbers&quot;">2</a>].

   Length of the hardware and protocol address are dependent on the
   environment in which InARP is running.  For example, if IP is running
   over Frame Relay, the hardware address length is between 2 and 4, and
   the protocol address length is 4.

   The operation code indicates the type of message, request or reply.

      InARP request  = 8
      InARP reply = 9

   These values were chosen so as not to conflict with other ARP
   extensions.

<span class="h2"><a class="selflink" name="section-7" href="#section-7">7</a>.  Protocol Operation</span>

   Basic InARP operates essentially the same as ARP with the exception
   that InARP does not broadcast requests.  This is because the hardware
   address of the destination station is already known. A requesting
   station simply formats a request by inserting its source hardware and
   protocol addresses and the known target hardware address.  It then
   zero fills the target protocol address field.  Finally, it will
   encapsulate the packet for the specific network and send it directly
   to the target station.

   Upon receiving an InARP request, a station may put the requester's
   protocol address/hardware address mapping into its ARP cache as it
   would any ARP request.  Unlike other ARP requests, however, the
   receiving station may assume that any InARP request it receives is
   destined for it. For every InARP request, the receiving station may
   format a proper reply using the source addresses from the request as
   the target addresses of the reply.  If the station is unable or
   unwilling to reply, it ignores the request.

   When the requesting station receives the InARP reply, it may complete
   the ARP table entry and use the provided address information.  Note:
   as with ARP, information learned via InARP may be aged or invalidated
   under certain circumstances.

<span class="h3"><a class="selflink" name="section-7.1" href="#section-7.1">7.1</a>.  Operation with Multi-Addressed Hosts</span>

   In the context of this discussion, a Multi-Addressed host will refer
   to a host that has multiple protocol addresses assigned to a single
   interface.  If such a station receives an InARP request, it must
   choose one address with which to respond. To make such a selection,
   the receiving station must first look at the protocol address of the



<span class="grey">Bradley, Brown                                                  [Page 3]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-4" id="page-4" href="#page-4" class="invisible"> </a>
<span class="grey"><a href="rfc1293.html">RFC 1293</a>                      Inverse ARP                   January 1992</span>


   requesting station, and then respond with the protocol address
   corresponding to the network of the requester.  For example, if the
   requesting station is probing for an IP address, the responding
   multi-addressed station should respond with an IP address which
   corresponds to the same subnet as the requesting station.  If the
   station does not have an address that is appropriate for the request
   it should not respond.  In the IP example, if the receiving station
   does not have an IP address assigned to the interface that is a part
   of the requested subnet, the receiving station would not respond.

   A multi-addressed host may choose to send an InARP request for each
   of the addresses defined for the given interface.  It should be
   noted, however, that the receiving side may answer some or none of
   the requests depending on its configuration.

<span class="h3"><a class="selflink" name="section-7.2" href="#section-7.2">7.2</a>.  Protocol Operation Within Frame Relay</span>

   One case where Inverse ARP can be used is when a new virtual circuit
   is signalled.  The Frame Relay station may format an InARP request
   addressed to the new virtual circuit.  If the other side supports
   InARP, it may return a reply indicating the protocol address
   requested.

   The format for an InARP request is a follows:

      ar$hrd - 0x000F the value assigned to Frame Relay
      ar$pro - protocol type for which you are searching
                  (i.e.  IP = 0x0800)
      ar$hln - 2,3, or 4 byte addressing length
      ar$pln - byte length of protocol address for which you
                  are searching (for IP = 4)
      ar$op  - 8; InARP request
      ar$sha - Q.922 address of requesting station
      ar$spa - protocol address of requesting station
      ar$tha - Q.922 addressed of newly announced virtual circuit
      ar$tpa - 0; This is what we're looking for















<span class="grey">Bradley, Brown                                                  [Page 4]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-5" id="page-5" href="#page-5" class="invisible"> </a>
<span class="grey"><a href="rfc1293.html">RFC 1293</a>                      Inverse ARP                   January 1992</span>


   The InARP response will be completed similarly.

      ar$hrd - 0x000F the value assigned to Frame Relay
      ar$pro - protocol type for which you are searching
                 (i.e.  IP = 0x0800)
      ar$hln - 2,3, or 4 byte addressing length
      ar$pln - byte length of protocol address for which you
                 are searching (for IP = 4)
      ar$op  - 9; InARP response
      ar$sha - Q.922 address of responding station
      ar$spa - protocol address requested
      ar$tha - Q.922 address of requesting station
      ar$tpa - protocol address of requesting station

   Note that the Q.922 addresses specified have the C/R, FECN, BECN, and
   DE bits set to zero.

   Procedures for using InARP over a Frame Relay network are identical
   to those for using ARP and RARP discussed in <a href="#section-10">section 10</a> of the
   Multiprotocol Interconnect over Frame Relay Networks document [<a href="#ref-3" title="&quot;Multiprotocol Interconnect over Frame Relay Networks&quot;">3</a>].

<span class="h2"><a class="selflink" name="section-8" href="#section-8">8</a>.  References</span>

   [<a name="ref-1" id="ref-1">1</a>]  Plummer, David C., "An Ethernet Address Resolution Protocol",
        <a href="rfc826.html">RFC-826</a>, November 1982.

   [<a name="ref-2" id="ref-2">2</a>]   Reynolds, J. and Postel, J., "Assigned Numbers", <a href="rfc1060.html">RFC-1060</a>, ISI,
        March 1990.

   [<a name="ref-3" id="ref-3">3</a>]  Bradley, T., Brown, C., Malis, A.,   "Multiprotocol Interconnect
        over Frame Relay Networks", <a href="rfc1294.html">RFC-1294</a>, January 1992.

   [<a name="ref-4" id="ref-4">4</a>]  Finlayson, Mann, Mogul, Theimer, "A Reverse Address Resolution
        Protocol", <a href="rfc903.html">RFC-903</a>, Stanford University, June 1984.


<span class="h2"><a class="selflink" name="section-9" href="#section-9">9</a>.  Security Considerations</span>

   Security issues are not addressed in this memo.












<span class="grey">Bradley, Brown                                                  [Page 5]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-6" id="page-6" href="#page-6" class="invisible"> </a>
<span class="grey"><a href="rfc1293.html">RFC 1293</a>                      Inverse ARP                   January 1992</span>


<span class="h2"><a class="selflink" name="section-10" href="#section-10">10</a>.  Authors' Addresses</span>

      Terry Bradley
      Wellfleet Communications, Inc.
      15 Crosby Drive
      Bedford, MA  01730

      Phone:  (617) 275-2400

      Email:  tbradley@wellfleet.com


      Caralyn Brown
      Wellfleet Communications, Inc.
      15 Crosby Drive
      Bedford, MA  01730

      Phone:  (617) 275-2400

      Email:  cbrown@wellfleet.com































Bradley, Brown                                                  [Page 6]

</pre><br />
    <span class="noprint"><small><small>Html markup produced by rfcmarkup 1.129c, available from
      <a href="https://tools.ietf.org/tools/rfcmarkup/">https://tools.ietf.org/tools/rfcmarkup/</a>
    </small></small></span>
  </div>
</body>

<!-- Mirrored from tools.ietf.org/html/rfc1293 by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 28 Jul 2019 13:17:29 GMT -->
</html>
