<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml"><!-- Mirrored from tools.ietf.org/html/rfc3470 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 06 Mar 2018 23:18:47 GMT --><!-- Added by HTTrack --><head><meta content="text/html;charset=utf-8" http-equiv="content-type"/><!-- /Added by HTTrack -->

    <meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
    <meta content="index,follow" name="robots"/>
    <meta content="rfcmarkup version 1.126" name="creator"/>
    <link href="http://purl.org/dc/elements/1.1/" rel="schema.DC"/>
<meta content="urn:ietf:rfc:3470" name="DC.Identifier"/>
<meta content='The Extensible Markup Language (XML) is a framework for structuring
data. While it evolved from SGML -- a markup language primarily
focused on structuring documents -- XML has evolved to be a widely-
used mechanism for representing structured data.  There are a wide
variety of Internet protocols being developed; many have need for a
representation for structured data relevant to their application.
There has been much interest in the use of XML as a representation
method. This document describes basic XML concepts, analyzes various
alternatives in the use of XML, and provides guidelines for the use of
XML within IETF standards-track protocols.  Intended Publication
Status  It is the goal of the authors that this draft (when completed
and then approved by the IESG) be published as a Best Current Practice
(BCP).  Conventions Used In This Document  This document recommends,
as policy, what specifications for Internet protocols -- and, in
particular, IETF standards track protocol documents -- should include
as normative language within them. The capitalized keywords "SHOULD",
"MUST", "REQUIRED", etc. are used in the sense of how they would be
used within other documents with the meanings as specified in RFC 2119
[1].  Discussion Venue  The authors welcome discussion and comments
relating to the topics presented in this document. Though direct
comments to the authors are welcome, public discussion is taking place
on the "ietf-xml- use@imc.org" mailing list. To join the list, send a
message to "ietf-xml-use-request@imc.org" with the word "subscribe" in
the body of the message. List archives [50] are available on the World
Wide Web.' name="DC.Description.Abstract"/>
<meta content="Masinter, Larry" name="DC.Creator"/>
<meta content="Hollenbeck, Scott" name="DC.Creator"/>
<meta content="Rose, Marshall T." name="DC.Creator"/>
<meta content="January, 2003" name="DC.Date.Issued"/>
<meta content="Guidelines for the Use of XML within IETF Protocols" name="DC.Title"/>

    <link href="https://tools.ietf.org/images/rfc.png" rel="icon" type="image/png"/>
    <link href="https://tools.ietf.org/images/rfc.png" rel="shortcut icon" type="image/png"/>
    <title>RFC 3470 - Guidelines for the Use of XML within IETF Protocols</title>
    
    
    <style type="text/css">
	@media only screen 
	  and (min-width: 992px)
	  and (max-width: 1199px) {
	    body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 768px)
	  and (max-width: 991px) {
            body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 480px)
	  and (max-width: 767px) {
            body { font-size: 11pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (max-width: 479px) {
            body { font-size: 8pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-device-width : 375px) 
	  and (max-device-width : 667px) {
            body { font-size: 9.5pt; }
            div.content { width: 96ex; margin: 0 1px; }
        }
	@media only screen 
	  and (min-device-width: 1200px) {
            body { font-size: 10pt; margin: 0 4em; }
            div.content { width: 96ex; margin: 0; }
        }
        h1, h2, h3, h4, h5, h6, .h1, .h2, .h3, .h4, .h5, .h6 {
	    font-weight: bold;
            line-height: 0pt;
            display: inline;
            white-space: pre;
            font-family: monospace;
            font-size: 1em;
	    font-weight: bold;
        }
        pre {
            font-size: 1em;
            margin-top: 0px;
            margin-bottom: 0px;
        }
	.pre {
	    white-space: pre;
	    font-family: monospace;
	}
	.header{
	    font-weight: bold;
	}
        .newpage {
            page-break-before: always;
        }
        .invisible {
            text-decoration: none;
            color: white;
        }
        a.selflink {
          color: black;
          text-decoration: none;
        }
        @media print {
            body {
                font-family: monospace;
                font-size: 10.5pt;
            }
            h1, h2, h3, h4, h5, h6 {
                font-size: 1em;
            }
        
            a:link, a:visited {
                color: inherit;
                text-decoration: none;
            }
            .noprint {
                display: none;
            }
        }
	@media screen {
	    .grey, .grey a:link, .grey a:visited {
		color: #777;
	    }
            .docinfo {
                background-color: #EEE;
            }
            .top {
                border-top: 7px solid #EEE;
            }
            .bgwhite  { background-color: white; }
            .bgred    { background-color: #F44; }
            .bggrey   { background-color: #666; }
            .bgbrown  { background-color: #840; }            
            .bgorange { background-color: #FA0; }
            .bgyellow { background-color: #EE0; }
            .bgmagenta{ background-color: #F4F; }
            .bgblue   { background-color: #66F; }
            .bgcyan   { background-color: #4DD; }
            .bggreen  { background-color: #4F4; }

            .legend   { font-size: 90%; }
            .cplate   { font-size: 70%; border: solid grey 1px; }
	}
    </style>
    <!--[if IE]>
    <style>
    body {
       font-size: 13px;
       margin: 10px 10px;
    }
    </style>
    <![endif]-->

    <script type="text/javascript"><!--
    function addHeaderTags() {
	var spans = document.getElementsByTagName("span");
	for (var i=0; i < spans.length; i++) {
	    var elem = spans[i];
	    if (elem) {
		var level = elem.getAttribute("class");
                if (level == "h1" || level == "h2" || level == "h3" || level == "h4" || level == "h5" || level == "h6") {
                    elem.innerHTML = "<"+level+">"+elem.innerHTML+"</"+level+">";		
                }
	    }
	}
    }
    var legend_html = "Colour legend:<br />      <table>         <tr><td>Unknown:</td>                   <td><span class='cplate bgwhite'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft:</td>                     <td><span class='cplate bgred'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Informational:</td>             <td><span class='cplate bgorange'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Experimental:</td>              <td><span class='cplate bgyellow'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Best Common Practice:</td>      <td><span class='cplate bgmagenta'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Proposed Standard:</td>         <td><span class='cplate bgblue'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft Standard (old designation):</td> <td><span class='cplate bgcyan'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Internet Standard:</td>         <td><span class='cplate bggreen'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Historic:</td>                  <td><span class='cplate bggrey'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Obsolete:</td>                  <td><span class='cplate bgbrown'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>     </table>";
    function showElem(id) {
        var elem = document.getElementById(id);
        elem.innerHTML = eval(id+"_html");
        elem.style.visibility='visible';
    }
    function hideElem(id) {
        var elem = document.getElementById(id);
        elem.style.visibility='hidden';        
        elem.innerHTML = "";
    }
    // -->
    </script>
</head>
<body onload="addHeaderTags()">
  <div class="content">
   <div style="height: 13px;">
      <div class="pre noprint docinfo bgmagenta" onclick="showElem('legend');" onmouseout="hideElem('legend')" onmouseover="this.style.cursor='pointer';" style="height: 6px; position: absolute;" title="Click for colour legend.">                                                                        </div>
      <div class="docinfo noprint pre legend" id="legend" onmouseout="hideElem('legend');" onmouseover="showElem('legend');" style="position:absolute; top: 4px; left: 4ex; visibility:hidden; background-color: white; padding: 4px 9px 5px 7px; border: solid #345 1px; ">
      </div>
   </div>
<span class="pre noprint docinfo top">[<a href="index.html" title="Document search and retrieval page">Docs</a>] [<a href="https://tools.ietf.org/rfc/rfc3470.txt" title="Plaintext version of this document">txt</a>|<a href="https://tools.ietf.org/pdf/rfc3470" title="PDF version of this document">pdf</a>] [<a href="https://tools.ietf.org/html/draft-hollenbeck-ietf-xml-guidelines" title="draft-hollenbeck-ietf-xml-guidelines">draft-hollenbec...</a>] [<a href="https://datatracker.ietf.org/doc/rfc3470" title="IESG Datatracker information for this document">Tracker</a>] [<a href="https://tools.ietf.org/rfcdiff?difftype=--hwdiff&amp;url2=rfc3470" title="Inline diff (wdiff)">Diff1</a>] [<a href="https://tools.ietf.org/rfcdiff?url2=rfc3470" title="Side-by-side diff">Diff2</a>] [<a href="https://www.rfc-editor.org/errata_search.php?rfc=3470">Errata</a>]</span><br/>
<span class="pre noprint docinfo">                                                                        </span><br/>
<span class="pre noprint docinfo">                                                   BEST CURRENT PRACTICE</span><br/>
<span class="pre noprint docinfo">                                                            <span style="color: #C00;">Errata Exist</span></span><br/>
<pre>Network Working Group                                      S. Hollenbeck
Request for Comments: 3470                                VeriSign, Inc.
BCP: 70                                                          M. Rose
Category: Best Current Practice             Dover Beach Consulting, Inc.
                                                             L. Masinter
                                              Adobe Systems Incorporated
                                                            January 2003


       <span class="h1">Guidelines for the Use of Extensible Markup Language (XML)</span>
                         <span class="h1">within IETF Protocols</span>

Status of this Memo

   This document specifies an Internet Best Current Practices for the
   Internet Community, and requests discussion and suggestions for
   improvements.  Distribution of this memo is unlimited.

Copyright Notice

   Copyright (C) The Internet Society (2003).  All Rights Reserved.

Abstract

   The Extensible Markup Language (XML) is a framework for structuring
   data.  While it evolved from Standard Generalized Markup Language
   (SGML) -- a markup language primarily focused on structuring
   documents -- XML has evolved to be a widely-used mechanism for
   representing structured data.

   There are a wide variety of Internet protocols being developed; many
   have need for a representation for structured data relevant to their
   application.  There has been much interest in the use of XML as a
   representation method.  This document describes basic XML concepts,
   analyzes various alternatives in the use of XML, and provides
   guidelines for the use of XML within IETF standards-track protocols.

Table of Contents

   Conventions Used In This Document  . . . . . . . . . . . . . . . .  <a href="#page-2">2</a>
   <a href="#section-1">1</a>.    Introduction and Overview  . . . . . . . . . . . . . . . . .  <a href="#page-2">2</a>
         <a href="#section-1.1">1.1</a>   Intended Audience. . . . . . . . . . . . . . . . . . .  <a href="#page-3">3</a>
         <a href="#section-1.2">1.2</a>   Scope  . . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-3">3</a>
         <a href="#section-1.3">1.3</a>   XML Evolution  . . . . . . . . . . . . . . . . . . . .  <a href="#page-3">3</a>
         1.4   XML Users, Support Groups, and Additional
               Information. . . . . . . . . . . . . . . . . . . . . .  <a href="#page-4">4</a>
   <a href="#section-2">2</a>.    XML Selection Considerations . . . . . . . . . . . . . . . .  <a href="#page-4">4</a>
   <a href="#section-3">3</a>.    XML Alternatives . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-5">5</a>



<span class="grey">Hollenbeck, et al.       Best Current Practice                  [Page 1]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-2" id="page-2" name="page-2"> </a>
<span class="grey"><a href="rfc3470.html">RFC 3470</a>               XML within IETF Protocols            January 2003</span>


   <a href="#section-4">4</a>.    XML Use Considerations and Recommendations . . . . . . . . .  <a href="#page-7">7</a>
         <a href="#section-4.1">4.1</a>   XML Syntax and Well-Formedness . . . . . . . . . . . .  <a href="#page-7">7</a>
         <a href="#section-4.2">4.2</a>   XML Information Set  . . . . . . . . . . . . . . . . .  <a href="#page-7">7</a>
         <a href="#section-4.3">4.3</a>   Syntactic Restrictions . . . . . . . . . . . . . . . .  <a href="#page-8">8</a>
         <a href="#section-4.4">4.4</a>   XML Declarations . . . . . . . . . . . . . . . . . . .  <a href="#page-9">9</a>
         <a href="#section-4.5">4.5</a>   XML Processing Instructions  . . . . . . . . . . . . .  <a href="#page-9">9</a>
         <a href="#section-4.6">4.6</a>   XML Comments . . . . . . . . . . . . . . . . . . . . . <a href="#page-10">10</a>
         <a href="#section-4.7">4.7</a>   Validity and Extensibility . . . . . . . . . . . . . . <a href="#page-10">10</a>
         <a href="#section-4.8">4.8</a>   Semantics as Well as Syntax. . . . . . . . . . . . . . <a href="#page-12">12</a>
         <a href="#section-4.9">4.9</a>   Namespaces . . . . . . . . . . . . . . . . . . . . . . <a href="#page-12">12</a>
               <a href="#section-4.9.1">4.9.1</a> Namespaces and Attributes. . . . . . . . . . . . <a href="#page-13">13</a>
         <a href="#section-4.10">4.10</a>  Element and Attribute Design Considerations. . . . . . <a href="#page-14">14</a>
         <a href="#section-4.11">4.11</a>  Binary Data and Text with Control Characters . . . . . <a href="#page-16">16</a>
         <a href="#section-4.12">4.12</a>  Incremental Processing . . . . . . . . . . . . . . . . <a href="#page-16">16</a>
         <a href="#section-4.13">4.13</a>  Entity Declarations and Entity References  . . . . . . <a href="#page-16">16</a>
         <a href="#section-4.14">4.14</a>  External References  . . . . . . . . . . . . . . . . . <a href="#page-17">17</a>
         <a href="#section-4.15">4.15</a>  URI Processing . . . . . . . . . . . . . . . . . . . . <a href="#page-17">17</a>
         <a href="#section-4.16">4.16</a>  White Space  . . . . . . . . . . . . . . . . . . . . . <a href="#page-18">18</a>
         <a href="#section-4.17">4.17</a>  Interaction with the IANA  . . . . . . . . . . . . . . <a href="#page-19">19</a>
   <a href="#section-5">5</a>.    Internationalization Considerations  . . . . . . . . . . . . <a href="#page-19">19</a>
         <a href="#section-5.1">5.1</a>   Character Sets and Encodings . . . . . . . . . . . . . <a href="#page-19">19</a>
         <a href="#section-5.2">5.2</a>   Language Declaration . . . . . . . . . . . . . . . . . <a href="#page-20">20</a>
         <a href="#section-5.3">5.3</a>   Other Internationalization Considerations  . . . . . . <a href="#page-20">20</a>
   <a href="#section-6">6</a>.    IANA Considerations  . . . . . . . . . . . . . . . . . . . . <a href="#page-21">21</a>
   <a href="#section-7">7</a>.    Security Considerations  . . . . . . . . . . . . . . . . . . <a href="#page-21">21</a>
   <a href="#section-8">8</a>.    Acknowledgements . . . . . . . . . . . . . . . . . . . . . . <a href="#page-22">22</a>
   <a href="#section-9">9</a>.    Normative References . . . . . . . . . . . . . . . . . . . . <a href="#page-22">22</a>
   <a href="#section-10">10</a>.   Informative References . . . . . . . . . . . . . . . . . . . <a href="#page-23">23</a>
   <a href="#section-11">11</a>.   Authors' Addresses . . . . . . . . . . . . . . . . . . . . . <a href="#page-27">27</a>
   <a href="#section-12">12</a>.   Full Copyright Statement . . . . . . . . . . . . . . . . . . <a href="#page-28">28</a>

Conventions Used In This Document

   This document recommends, as policy, what specifications for Internet
   protocols -- and, in particular, IETF standards track protocol
   documents -- should include as normative language within them.  The
   capitalized keywords "SHOULD", "MUST", "REQUIRED", etc. are used in
   the sense of how they would be used within other documents with the
   meanings as specified in <a href="https://tools.ietf.org/html/bcp14">BCP 14</a>, <a href="rfc2119.html">RFC 2119</a> [<a href="#ref-1" title='"Key words for use in RFCs to Indicate Requirement Levels"'>1</a>].

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/1.%20Introduction%20and%20Overview"></a><a class="selflink" href="#section-1" name="section-1">1</a>. Introduction and Overview</span>

   The Extensible Markup Language (XML, [<a href="#ref-8" title='"Extensible Markup Language (XML) 1.0 (2nd ed)"'>8</a>]) is a framework for
   structuring data.  While it evolved from the Standard Generalized
   Markup Language (SGML, [<a href="#ref-30" title='"Information processing - Text and office systems - Standard Generalized Markup Language (SGML)"'>30</a>]) -- a markup language primarily focused
   on structuring documents -- XML has evolved to be a widely-used
   mechanism for representing structured data in protocol exchanges.
   See "XML in 10 points" [<a href="#ref-47" title='"XML in 10 points"'>47</a>] for an introduction to XML.



<span class="grey">Hollenbeck, et al.       Best Current Practice                  [Page 2]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-3" id="page-3" name="page-3"> </a>
<span class="grey"><a href="rfc3470.html">RFC 3470</a>               XML within IETF Protocols            January 2003</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/1.1%20Intended%20Audience"></a><a class="selflink" href="#section-1.1" name="section-1.1">1.1</a> Intended Audience</span>

   Many Internet protocol designers are considering using XML and XML
   fragments within the context of existing and new Internet protocols.
   This document is intended as a guide to XML usage and as IETF policy
   for standards track documents.  Experienced XML practitioners will
   likely already be familiar with the background material here, but the
   guidelines are intended to be appropriate for those readers as well.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/1.2%20Scope"></a><a class="selflink" href="#section-1.2" name="section-1.2">1.2</a> Scope</span>

   This document is intended to give guidelines for the use of XML
   content within a larger protocol.  The goal is not to suggest that
   XML is the "best" or "preferred" way to represent data; rather, the
   goal is to lay out the context for the use of XML within a protocol
   once other factors point to XML as a possible data representation
   solution.  The Common Name Resolution Protocol (CNRP, [<a href="#ref-24" title='"Common Name Resolution Protocol (CNRP)"'>24</a>]) is an
   example of a protocol that would be addressed by these guidelines if
   it were being newly defined.  This document does not address the use
   of protocols like SMTP or HTTP to send XML documents as ordinary
   email or web content.

   There are a number of protocol frameworks already in use or under
   development which focus entirely on "XML protocol" -- the exclusive
   use of XML as the data representation in the protocol.  For example,
   the World Wide Web Consortium (W3C) is developing an XML Protocol
   framework based on SOAP ([<a href="#ref-45" title='"SOAP Version 1.2 Part 1: Messaging Framework"'>45</a>] and [<a href="#ref-46" title='"SOAP Version 1.2 Part 2: Adjuncts"'>46</a>]).  The applicability of such
   protocols is not part of the scope of this document.

   In addition, there are higher-level representation frameworks, based
   on XML, that have been designed as carriers of certain classes of
   information; for example, the Resource Description Framework (RDF,
   [<a href="#ref-38" title='"Resource Description Framework (RDF) Model and Syntax Specification"'>38</a>]) is an XML-based representation for logical assertions.  This
   document does not provide guidelines for the use of such frameworks.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/1.3%20XML%20Evolution"></a><a class="selflink" href="#section-1.3" name="section-1.3">1.3</a> XML Evolution</span>

   XML 1.0 was originally published as a W3C recommendation in February
   1998 [<a href="#ref-35" title='"Extensible Markup Language (XML) 1.0"'>35</a>], and was revised in a 2nd edition [<a href="#ref-8" title='"Extensible Markup Language (XML) 1.0 (2nd ed)"'>8</a>] in October 2000.
   Several additional facilities have also been defined that layer on
   the base specification.  Although these additions are designed to be
   consistent with XML 1.0, they have varying levels of stability,
   consensus, and implementation.  Accordingly, this document identifies
   the major evolutionary features of XML and makes suggestions as to
   the circumstances in which each feature should be used.






<span class="grey">Hollenbeck, et al.       Best Current Practice                  [Page 3]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-4" id="page-4" name="page-4"> </a>
<span class="grey"><a href="rfc3470.html">RFC 3470</a>               XML within IETF Protocols            January 2003</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/1.4%20XML%20Users%2C%20Support%20Groups%2C%20and%20Additional%20Information"></a><a class="selflink" href="#section-1.4" name="section-1.4">1.4</a> XML Users, Support Groups, and Additional Information</span>

   There are many XML support groups, with some devoted to the entire
   XML industry [<a href="#ref-51">51</a>], some devoted to developers [<a href="#ref-52">52</a>], some devoted to
   the business applications of XML [<a href="#ref-53">53</a>], and many, many groups devoted
   to the use of XML in a particular context.

   It is beyond the scope of this document to provide a comprehensive
   list of referrals.  Interested readers are directed to the three
   references above as starting points, as well as their favorite
   Internet search engine.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/2.%20XML%20Selection%20Considerations"></a><a class="selflink" href="#section-2" name="section-2">2</a>. XML Selection Considerations</span>

   XML is a tool that provides a means towards an end.  Choosing the
   right tool for a given task is an essential part of ensuring that the
   task can be completed in a satisfactory manner.  This section
   describes factors to be aware of when considering XML as a tool for
   use in IETF protocols:

   1.  XML is a meta-markup language that can be used to define markup
       languages for specific domains and problem spaces.

   2.  XML provides both logical structure and physical structure to
       describe data.  Data framing is built-in.

   3.  XML instances can be validated against the formal definition of a
       protocol specification.

   4.  XML supports internationalization.

   5.  XML is extensible.  Unlike some other markup languages (such as
       HTML), new tags (and thus new protocol elements) can be defined
       without requiring changes to XML itself.

   6.  XML is still evolving.  The formal specifications are still being
       influenced and updated as use experience is gained and applied.

   7.  XML does not provide native mechanisms to support detailed data
       typing.  Additional mechanisms  (such as those described in
       <a href="#section-4.7">Section 4.7</a>) are required to specify abstract protocol data
       types.

   8.  XML is text-based, so XML fragments are easily created, edited,
       and managed using common utilities.  Further, being text-based
       means it more readily supports incremental development,





<span class="grey">Hollenbeck, et al.       Best Current Practice                  [Page 4]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-5" id="page-5" name="page-5"> </a>
<span class="grey"><a href="rfc3470.html">RFC 3470</a>               XML within IETF Protocols            January 2003</span>


       debugging, and logging.  A simple "canned" XML fragment can be
       embedded within a program as a string constant, rather than
       having to be constructed.

   9.  Binary data has to be encoded into a text-based form to be
       represented in XML.

   10. XML is verbose when compared with many other structured data
       representation languages.  A representation with element
       extensibility and human readability typically requires more bits
       when compared to one optimized for efficient machine processing.

   11. XML implementations are still relatively new.  As designers and
       implementers gain experience, it is not uncommon to find defects
       in early and current products.

   12. XML support is available in a large number of software
       development utilities, available in both open source and
       proprietary products.

   13. XML processing speed can be an issue in some environments.  XML
       processing can be slower because XML data streams may be larger
       than other representations, and the use of general purpose XML
       parsers will add a software layer with its own performance costs
       (though these costs can be reduced through consistent use of an
       optimized parser).  In some situations, processing XML requires
       examining every byte of the entire XML data stream, with higher
       overhead than with representations where uninteresting segments
       can be skipped.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/3.%20XML%20Alternatives"></a><a class="selflink" href="#section-3" name="section-3">3</a>. XML Alternatives</span>

   This document focuses on guidelines for the use of XML.  It is useful
   to consider why one might use XML as opposed to some other mechanism.
   This section considers some other commonly used representation
   mechanisms and compares XML to those alternatives.

   For many fundamental protocols, the extensibility requirements are
   modest, and the performance requirements are high enough that fixed
   binary data blocks are the appropriate representation; mechanisms
   such as XML merely add bloat.  <a href="rfc3252.html">RFC 3252</a> [<a href="#ref-23" title='"Binary Lexical Octet Ad-hoc Transport"'>23</a>] describes a humorous
   example of XML as protocol bloat.

   In addition, there are other representation and extensibility
   frameworks that have been used successfully within communication
   protocols.  For example, Abstract Syntax Notation 1 (ASN.1) [<a href="#ref-28" title='"Information Processing Systems - Open Systems Interconnection - Specification of Abstract Syntax Notation One (ASN.1)"'>28</a>]
   along with the corresponding Basic Encoding Rules (BER, [<a href="#ref-29" title='"Information Processing Systems - Open Systems Interconnection - Specification of Basic Encoding Rules for Abstract Syntax Notation One (ASN.1)"'>29</a>]) are
   part of the OSI communication protocol suite, and have been used in



<span class="grey">Hollenbeck, et al.       Best Current Practice                  [Page 5]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-6" id="page-6" name="page-6"> </a>
<span class="grey"><a href="rfc3470.html">RFC 3470</a>               XML within IETF Protocols            January 2003</span>


   many subsequent communications standards (e.g., the ANSI Information
   Retrieval protocol [<a href="#ref-27" title='"Information Retrieval: Application Service Definition and Protocol Specification"'>27</a>] and the Simple Network Management Protocol
   (SNMP, [<a href="#ref-13" title='"Simple Network Management Protocol (SNMP)"'>13</a>]).  The External Data Representation (XDR, [<a href="#ref-14" title='"XDR: External Data Representation Standard"'>14</a>]) and
   variations of it have been used in many other distributed network
   applications (e.g., the Network File System (NFS) protocol [<a href="#ref-22" title='"NFS version 4 Protocol"'>22</a>]).
   With some ASN.1 encoding types, data types are explicit in the
   representation, while with XDR, the data types of components are
   described externally as part of an interface specification.

   Many other protocols use data structures directly (without data
   encapsulation) by describing the data structure with Backus Normal
   Form (BNF, [<a href="#ref-25" title='"The syntax and semantics of the proposed international algebraic language of the Zurich ACM-GAMM conference"'>25</a>]); many IETF protocols use an Augmented Backus-Naur
   Form (ABNF, [<a href="#ref-16" title='"Augmented BNF for Syntax Specifications: ABNF"'>16</a>]).  The Simple Mail Transfer Protocol (SMTP, [<a href="#ref-21" title='"Simple Mail Transfer Protocol"'>21</a>]) is
   an example of a protocol specified using ABNF.

   ASN.1, XDR, and BNF are described here as examples of alternatives to
   XML for use in IETF protocols.  There are other alternatives, but a
   complete enumeration of all possible alternatives is beyond the scope
   of this document.

   Other representation methods may differ from XML in several important
   ways:

   Text Encoding and character sets: the character encoding used to
   represent a formal specification.  XML defines a consistent character
   model based on the Universal Character Set (UCS, [<a href="#ref-31" title='"Information Technology - Universal Multiple-octet coded Character Set (UCS) - Part 1: Architecture and Basic Multilingual Plane"'>31</a>] and [<a href="#ref-33" title='"The Unicode Standard, as it may from time to time be revised or amended"'>33</a>]), and
   requires that XML parsers accept at least UTF-8 [<a href="#ref-4" title='"UTF-8, a transformation format of ISO 10646"'>4</a>] and UTF-16 [<a href="#ref-20" title='"UTF-16, an encoding of ISO 10646"'>20</a>],
   and allows for other encodings.  While ASN.1 and XDR may carry
   strings in any encoding, there is no common mechanism for defining
   character encodings within them.  Typically, ABNF definitions tend to
   be defined in terms of octets or characters in ASCII.

   Data Encoding: XML is defined as a sequence of characters, rather
   than a sequence of bytes.  XML Schema [<a href="#ref-42" title='"XML Schema Part 2: Datatypes"'>42</a>] includes mechanisms for
   representing some data types (integer, date, array, etc.) but many
   binary data types are encoded in Base64 [<a href="#ref-15" title='"Multipurpose Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies"'>15</a>] or hexadecimal.  ASN.1
   and XDR have rich mechanisms for encoding a wide variety of data
   types.

   Extensibility: XML has a rich extensibility model such that XML
   specifications can frequently be versioned independently.
   Specifications can be extended by adding new element names and
   attributes (if done compatibly); other extensions can be added by
   defining new XML namespaces [<a href="#ref-9" title='"Namespaces in XML"'>9</a>], though there is no standard
   mechanism in XML to indicating whether or not new extensions are
   mandatory to recognize.  Similarly, there are several techniques
   available to extend ASN.1 specifications.  XDR specifications tend to
   not be independently extensible by different parties because the



<span class="grey">Hollenbeck, et al.       Best Current Practice                  [Page 6]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-7" id="page-7" name="page-7"> </a>
<span class="grey"><a href="rfc3470.html">RFC 3470</a>               XML within IETF Protocols            January 2003</span>


   framing and data types are implicit and not self-describing.  The
   extensibility of BNF-based protocol elements needs to be explicitly
   planned.

   Legibility of protocol elements: As noted above, XML is text-based,
   and thus carries the advantages (and disadvantages) of text-based
   protocol elements.  Typically this is shared with (A)BNF-defined
   protocol elements.  ASN.1 and XDR use binary encodings which are not
   easily human readable.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/4.%20XML%20Use%20Considerations%20and%20Recommendations"></a><a class="selflink" href="#section-4" name="section-4">4</a>. XML Use Considerations and Recommendations</span>

   This section notes several aspects of XML and makes recommendations
   for use.  Since the 1998 publication of XML version 1 [<a href="#ref-35" title='"Extensible Markup Language (XML) 1.0"'>35</a>], an
   editorial second edition [<a href="#ref-8" title='"Extensible Markup Language (XML) 1.0 (2nd ed)"'>8</a>] was published in 2000; this section
   refers to the second edition.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.1%20XML%20Syntax%20and%20Well-Formedness"></a><a class="selflink" href="#section-4.1" name="section-4.1">4.1</a> XML Syntax and Well-Formedness</span>

   XML [<a href="#ref-8" title='"Extensible Markup Language (XML) 1.0 (2nd ed)"'>8</a>] is defined in terms of a concrete syntax: a sequence of
   characters, using the characters "&lt;", "=", "&amp;", etc. as delimiters.
   An instance is XML if and only if it is well-formed, i.e., all
   character and markup data conforms to the structural rules defined in
   section 2.1 of [<a href="#ref-8" title='"Extensible Markup Language (XML) 1.0 (2nd ed)"'>8</a>].

   Character and markup data that is not well-formed is not XML; well-
   formedness is the basis for syntactic compatibility with XML.
   Without well-formedness, all of the advantages of using XML
   disappear.  For this reason, it is recommended that protocol
   specifications explicitly require XML well-formedness ("MUST be
   well-formed").

   The IETF has a long-standing tradition of "be liberal in what you
   accept" that might seem to be at odds with this recommendation.
   Given that XML requires well-formedness, conforming XML parsers are
   intolerant of well-formedness errors.  When specifying the handing of
   erroneous XML protocol elements, a protocol design must never
   recommend attempting to partially interpret non-well-formed instances
   of an element which is required to be XML.  Reasonable behaviors in
   such a scenario could include attempting retransmission or aborting
   an in-progress session.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.2%20XML%20Information%20Set"></a><a class="selflink" href="#section-4.2" name="section-4.2">4.2</a> XML Information Set</span>

   In addition to the concrete syntax of XML, there is an abstract model
   of XML content known as the "Information Set" (infoset) [<a href="#ref-37" title='"XML Information Set"'>37</a>].  One
   might think of an XML parser as consuming the concrete syntax and
   producing an XML Information Set for further processing.



<span class="grey">Hollenbeck, et al.       Best Current Practice                  [Page 7]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-8" id="page-8" name="page-8"> </a>
<span class="grey"><a href="rfc3470.html">RFC 3470</a>               XML within IETF Protocols            January 2003</span>


   In typical use of XML, the definition of allowable XML documents is
   often defined in terms of the Information Set of the XML and not the
   concrete syntax.  The notion is that any syntactic representation
   which yielded the same information set would be treated equivalently.

   It some cases, protocols have been defined solely in terms of the XML
   Information Set, or by allowing other concrete syntax
   representations.  However, since the context of XML embedded within
   other Internet protocols requires an unambiguous definition of the
   concrete syntax, defining an XML protocol element in terms of its XML
   Information Set alone and allowing other concrete syntax
   representations is out of scope for this document.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.3%20Syntactic%20Restrictions"></a><a class="selflink" href="#section-4.3" name="section-4.3">4.3</a> Syntactic Restrictions</span>

   In some circumstances a protocol designer may be tempted to define an
   XML-based protocol element as "XML", but at the same time imposing
   additional restrictions beyond those imposed by the XML
   recommendation itself -- for example, restricting the document
   character encoding, or avoiding CDATA sections, character entity
   references, imposing additional restrictions on use of white space,
   etc.  The general category of restrictions addressed by this section
   are ones that would allow some but not other of the set of syntactic
   representations which have the same canonical representation
   according to canonical XML described in <a href="rfc3076.html">RFC 3076</a> [<a href="#ref-6" title='"Canonical XML Version 1.0"'>6</a>].

   Making these kinds of restrictions in a protocol definition may have
   the disadvantage that an implementer of the protocol may not be able
   to use an otherwise conforming XML processor to parse the XML-based
   protocol elements.  In some cases, the motivation for subsetting XML
   is to allow implementers to build special-purpose processors that are
   lighter weight than a full-scale conforming XML processor.  There are
   a number of good, conforming XML parsers that are small, fast, and
   free, while special-purpose processors have frequently been known to
   fail to handle some cases of legal XML syntax.

   In general, such syntactic restrictions should be avoided.  In
   circumstances where restrictions on the variability of the syntactic
   representation of XML is necessary for one reason or another,
   designers should consider using "Canonical XML" [<a href="#ref-6" title='"Canonical XML Version 1.0"'>6</a>] as the definition
   of the protocol element, since all such variability has been removed.
   Some specific issues are discussed in <a href="#section-4.4">Section 4.4</a>, <a href="#section-4.13">Section 4.13</a>, and
   <a href="#section-5.1">Section 5.1</a> below.








<span class="grey">Hollenbeck, et al.       Best Current Practice                  [Page 8]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-9" id="page-9" name="page-9"> </a>
<span class="grey"><a href="rfc3470.html">RFC 3470</a>               XML within IETF Protocols            January 2003</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.4%20XML%20Declarations"></a><a class="selflink" href="#section-4.4" name="section-4.4">4.4</a> XML Declarations</span>

   An XML declaration (defined in section 2.8 of [<a href="#ref-8" title='"Extensible Markup Language (XML) 1.0 (2nd ed)"'>8</a>]) is a small header
   at the beginning of an XML data stream that indicates the XML version
   and the character encoding used.  For example,

   &lt;?xml version="1.0" encoding="UTF-8"?&gt;

   specifies the use of XML version 1 and UTF-8 character encoding.

   In some uses of XML as an embedded protocol element, the XML used is
   a small fragment in a larger context, where the XML version is fixed
   at "1.0" and the character encoding is known to be "UTF-8".  In those
   cases, an XML declaration might add extra overhead.  In cases where
   the XML is a larger component which may find its way alone as an
   external entity body (transported as a MIME message, for example),
   the XML declaration is an important marker and is useful for
   reliability and extensibility.  The XML declaration is also an
   important marker for character set/encoding (see <a href="#section-5.1">Section 5.1</a>), if any
   encoding other than UTF-8 or UTF-16 is used.  Note that in the case
   of UTF-16, XML requires that the entity starts with a Byte Order Mark
   (BOM), which is not part of the character data.  Note that the XML
   Declaration itself is not part of the XML document's Information Set.

   Protocol specifications must be clear about use of XML declarations.
   XML [<a href="#ref-8" title='"Extensible Markup Language (XML) 1.0 (2nd ed)"'>8</a>] notes that "XML documents should begin with an XML
   declaration which specifies the version of XML being used."  In
   general, an XML declaration should be encouraged ("SHOULD be
   present") and must always be allowed ("MAY be sent").  An XML
   declaration should be required in cases where, if allowed, the
   character encoding is anything other than UTF-8 or UTF-16.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.5%20XML%20Processing%20Instructions"></a><a class="selflink" href="#section-4.5" name="section-4.5">4.5</a> XML Processing Instructions</span>

   An XML processing instruction (defined in section 2.6 of [<a href="#ref-8" title='"Extensible Markup Language (XML) 1.0 (2nd ed)"'>8</a>]) is a
   component of an XML document that signals extra "out of band"
   information to the receiver; a common use of XML processing
   instructions are for document applications.  For example, the XML2RFC
   application used to generate this document and described in <a href="rfc2629.html">RFC 2629</a>
   [<a href="#ref-19" title='"Writing I-Ds and RFCs using XML"'>19</a>] supports a "table of contents" processing instruction:

   &lt;?rfc toc="yes"?&gt;

   As described in section 2.6 of [<a href="#ref-8" title='"Extensible Markup Language (XML) 1.0 (2nd ed)"'>8</a>], processing instructions are not
   part of the document's character data, but must be passed through to
   the application.  As a consequence, it is recommended that processing
   instructions be ignored when encountered in normal protocol
   processing.  It is thus also recommended that processing instructions



<span class="grey">Hollenbeck, et al.       Best Current Practice                  [Page 9]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-10" id="page-10" name="page-10"> </a>
<span class="grey"><a href="rfc3470.html">RFC 3470</a>               XML within IETF Protocols            January 2003</span>


   not be used to define normative protocol data structures or
   extensions for the following reasons:

   o  Processing instructions are not namespace aware; there is no way
      to qualify a processing instruction target with a namespace.

   o  Processing instruction use can not be constrained by most schema
      languages,

   o  Character references are not recognized within a processing
      instruction.

   o  Processing instructions don't have any XML-defined structure
      beyond the division between the target and everything else.  This
      means that applications typically have to parse the content of the
      processing instruction in a system-dependent way; if the content
      was provided within an element instead, the structure could be
      expressed in the XML and the parsing could be done by the XML
      parser.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.6%20XML%20Comments"></a><a class="selflink" href="#section-4.6" name="section-4.6">4.6</a> XML Comments</span>

   An XML comment (defined in section 2.5 of [<a href="#ref-8" title='"Extensible Markup Language (XML) 1.0 (2nd ed)"'>8</a>]) is a component of an
   XML document that provides descriptive information that is not part
   of the document's character data.  XML comments, like comments used
   in programming languages, are often used to provide explanatory
   information in human-understandable terms.  An example:

   &lt;!-- This is a example comment.  --&gt;

   XML comments can be ignored by conformant processors.  As a
   consequence, it is strongly recommended that comments not be used to
   define normative protocol data structures or extensions.  It is thus
   also strongly recommended that comments be ignored if encountered in
   normal protocol processing.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.7%20Validity%20and%20Extensibility"></a><a class="selflink" href="#section-4.7" name="section-4.7">4.7</a> Validity and Extensibility</span>

   One important value of XML is that there are formal mechanisms for
   defining structural and data content constraints; these constrain the
   identity of elements or attributes or the values contained within
   them.  There is more than one such formalism:

   o  A "Document Type Definition" (DTD) is defined in section 2.8 of
      [<a href="#ref-8" title='"Extensible Markup Language (XML) 1.0 (2nd ed)"'>8</a>]; the concept came from a similar mechanism for SGML.  There is
      significant experience with using DTDs, including in IETF
      protocols.




<span class="grey">Hollenbeck, et al.       Best Current Practice                 [Page 10]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-11" id="page-11" name="page-11"> </a>
<span class="grey"><a href="rfc3470.html">RFC 3470</a>               XML within IETF Protocols            January 2003</span>


   o  XML Schema (defined in [<a href="#ref-41" title='"XML Schema Part 1: Structures"'>41</a>] and [<a href="#ref-42" title='"XML Schema Part 2: Datatypes"'>42</a>]) provides additional features
      to allow a tighter and more precise specification of allowable
      protocol syntax and data type specifications.

   o  There are also a number of other mechanisms for describing XML
      instance validity; these include, for example, Schematron [<a href="#ref-49" title='"The Schematron"'>49</a>] and
      RELAX NG [<a href="#ref-48" title='"RELAX NG Specification"'>48</a>].  Part 2 of the ISO/IEC Document Schema Definition
      Language (DSDL, [<a href="#ref-32" title='"DSDL Part 0 - Overview"'>32</a>]) standard is based on RELAX NG.

   There is ongoing discussion (and controversy) within the XML
   community on the use and applicability of various validity constraint
   mechanisms.  The choice of tool depends on the needs for
   extensibility or for a formal language and mechanism for constraining
   permissible values and validating adherence to the constraints.

   There are cases where protocols have defined validity using one or
   another validity mechanism, but the protocol definitions have not
   insisted that all corresponding protocol elements be "valid".  The
   decision depends in part on the design for protocol extensibility.
   Each formalism has different ways of allowing for future extensions;
   in addition, a protocol design may have its own versioning mechanism,
   way of updating the schema, or pointing to a new one.  For example,
   the use of XML namespaces (<a href="#section-4.9">Section 4.9</a>) with XML Schema allows other
   kinds of extensibility without compromising schema validity.

   No matter what formalism is chosen, there are usually additional
   syntactic constraints, and inevitably additional semantic
   constraints, on the validity of XML elements that cannot be expressed
   in the formalism.

   This document makes the following recommendations for the definition
   of protocols using XML:

   o  Protocols should use an appropriate formalism for defining
      validity of XML protocol elements.

   o  Protocols may or may not insist that all corresponding protocol
      elements be valid, according to the validity mechanism chosen; in
      either case, the extensibility design should be clear.  What
      happens if the data is not valid?

   o  As described in <a href="#section-3">Section 3</a> there is no standard mechanism in XML
      for indicating whether or not new extensions are mandatory to
      recognize.  XML-based protocol specifications should thus
      explicitly describe extension mechanisms and requirements to
      recognize or ignore extensions.





<span class="grey">Hollenbeck, et al.       Best Current Practice                 [Page 11]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-12" id="page-12" name="page-12"> </a>
<span class="grey"><a href="rfc3470.html">RFC 3470</a>               XML within IETF Protocols            January 2003</span>


   An idealized model for XML processing might first check for well-
   formedness; if OK, apply the primary formalism and, if the instances
   "passes", apply the other constraints so that the entire set (or as
   much as is machine processable) can be checked at the same time.

   However, it is reasonable to allow conforming implementations to
   avoid doing validation at run-time and rely instead on ad-hoc code to
   avoid the higher expense, for example, of schema validation,
   especially given that there will likely be additional hand-crafted
   semantic validation.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.8%20Semantics%20as%20Well%20as%20Syntax"></a><a class="selflink" href="#section-4.8" name="section-4.8">4.8</a> Semantics as Well as Syntax</span>

   While the definition of an XML protocol element using a validity
   formalism is useful, it is not sufficient.  XML by itself does not
   supply semantics.  Any document defining a protocol element with XML
   MUST also have sufficient prose in the document describing the
   semantics of whatever XML the document has elected to define.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.9%20Namespaces"></a><a class="selflink" href="#section-4.9" name="section-4.9">4.9</a> Namespaces</span>

   XML namespaces, defined in [<a href="#ref-9" title='"Namespaces in XML"'>9</a>], provide a means of assigning markup
   to a specific vocabulary.  If two elements or attributes from
   different vocabularies have the same name, they can be distinguished
   unambiguously if they belong to different namespaces.  Additionally,
   namespaces provide significant support for protocol extensibility as
   they can be defined, reused, and processed dynamically.

   Markup vocabulary collisions are very possible when namespaces are
   not used to separate and uniquely identify vocabularies.  Protocol
   definitions should use existing XML namespaces where appropriate.
   When a new namespace is needed, the "namespace name" is a URI that is
   used to identify the namespace; it's also useful for that URI to
   point to a description of the namespace.  Typically (and recommended
   practice in W3C) is to assign namespace names using persistent http
   URIs.

   In the case of namespaces in IETF standards-track documents, it would
   be useful if there were some permanent part of the IETF's own web
   space that could be used for this purpose.  In lieu of such, other
   permanent URIs can be used, e.g., URNs in the IETF URN namespace (see
   [<a href="#ref-11" title='"An IETF URN Sub-namespace for Registered Protocol Parameters"'>11</a>] and [<a href="#ref-12" title='"The IETF XML Registry"'>12</a>]).  Although there are instances of IETF specifications
   creating new URI schemes to define XML namespaces, this practice is
   strongly discouraged.







<span class="grey">Hollenbeck, et al.       Best Current Practice                 [Page 12]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-13" id="page-13" name="page-13"> </a>
<span class="grey"><a href="rfc3470.html">RFC 3470</a>               XML within IETF Protocols            January 2003</span>


<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/4.9.1%20Namespaces%20and%20Attributes"></a><a class="selflink" href="#section-4.9.1" name="section-4.9.1">4.9.1</a> Namespaces and Attributes</span>

   There is a frequently misunderstood aspect of the relationship
   between unprefixed attributes and the default XML namespace - the
   natural assumption is that an unprefixed attribute is qualified by
   the default namespace, but this is not true.  Rather, the unprefixed
   attribute belongs to no namespace at all.  Thus, in the following
   example:

   &lt;ns1:fox a="xxx" ns1:b="qqq"
    xmlns="http://example.org"/&gt;
   &lt;fox a="xxx" ns1:b="qqq"
    xmlns="http://example.org" xmlns:ns1="http://example.org"/&gt;

   the attribute "a" is in no namespace, while "ns1:b" is the same
   namespace as the containing element.  A specific description of the
   relationship between default namespaces and attributes can be found
   in section 5.2 of [<a href="#ref-9" title='"Namespaces in XML"'>9</a>].  The practical implication of the relationship
   between namespaces and attributes is that care must be taken to
   ensure that no element contains multiple attributes that have
   identical names or have qualified names with the same local part and
   with prefixes which have been bound to namespace names that are
   identical.

   In XML applications, the choice between prefixed and non-prefixed
   attributes frequently is based on whether they always appear inside
   elements of the same namespace (in which case non-prefixed and
   thereby non-namespaced names are used) or whether it's required that
   they can be applied to elements in other arbitrary namespaces (in
   which case a prefixed name is used).  Both situations occur in the
   XSLT [<a href="#ref-43" title='"XSL Transformations (XSLT) Version 1.0"'>43</a>] language: while attributes are unprefixed when they occur
   inside elements in the XSLT namespace, such as:

   &lt;xsl:value-of select="."/&gt;

















<span class="grey">Hollenbeck, et al.       Best Current Practice                 [Page 13]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-14" id="page-14" name="page-14"> </a>
<span class="grey"><a href="rfc3470.html">RFC 3470</a>               XML within IETF Protocols            January 2003</span>


   they are prefixed when they appear in non-XSLT elements, such as the
   "xsl:version" attribute when using "literal result element
   stylesheets":

   &lt;html xsl:version="1.0"
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns="http://www.w3.org/TR/xhtml1/strict"&gt;
     &lt;head&gt;
       &lt;title&gt;Expense Report Summary&lt;/title&gt;
     &lt;/head&gt;
     &lt;body&gt;
       &lt;p&gt;Total: &lt;xsl:value-of select="exp-rep/total"/&gt;&lt;/p&gt;
     &lt;/body&gt;
   &lt;/html&gt;

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.10%20Element%20and%20Attribute%20Design%20Considerations"></a><a class="selflink" href="#section-4.10" name="section-4.10">4.10</a> Element and Attribute Design Considerations</span>

   XML provides much flexibility in allowing a designer to use either
   elements, attributes, or element content to carry data.  This section
   gives a flavor of the design considerations; there is much written
   about this in the XML literature.  Consistent use of elements,
   attributes, and values is an important characteristic of a sound
   design.

   Attributes are generally intended to contain meta-data that describes
   the element, and as such they are subject to the following
   restrictions:

   o  Attributes are unordered,

   o  There can be no more than one instance of a given attribute within
      a given element, though an attribute may contain several values
      separated by white space ([<a href="#ref-8" title='"Extensible Markup Language (XML) 1.0 (2nd ed)"'>8</a>], section 2.3 and 3.3.1),

   o  Attribute values can have no internal XML markup for providing
      internal structure, and

   o  Attribute values are normalized ([<a href="#ref-8" title='"Extensible Markup Language (XML) 1.0 (2nd ed)"'>8</a>], section 3.3) before
      processing

   Consider the following example that describes an IP address using an
   attribute to describe the address value:

   &lt;address addrType="ipv4"&gt;10.1.2.3&lt;/address&gt;







<span class="grey">Hollenbeck, et al.       Best Current Practice                 [Page 14]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-15" id="page-15" name="page-15"> </a>
<span class="grey"><a href="rfc3470.html">RFC 3470</a>               XML within IETF Protocols            January 2003</span>


   One might encode the same information using an &lt;addrType&gt; element
   instead of an "addrType" attribute:

   &lt;address&gt;
     &lt;addrType&gt;ipv4&lt;/addrType&gt;
     &lt;value&gt;10.1.2.3&lt;/value&gt;
   &lt;/address&gt;

   Another way of encoding the same information would be to use markup
   for the "addrType":

   &lt;address&gt;
     &lt;addrType&gt;&lt;ipv4/&gt;&lt;/addrType&gt;
     &lt;value&gt;10.1.2.3&lt;/value&gt;
   &lt;/address&gt;

   Choosing between these designs involves tradeoffs concerning, among
   other considerations, the likely extensibility patterns and the
   ability of the formalism to constrain the values appropriately.  In
   the first example, the attribute can be thought of as meta-data to
   the element which it modifies, and provides for a kind of "element
   extensibility".  The third example allows for a different kind of
   extensibility: the "ipv4" space can be extended using other
   namespaces, and the &lt;ipv4&gt; element can include additional markup.

   Many protocols include parameters that are selected from an
   enumerated set of values.  Such enumerated values can be encoded as
   elements, attributes, or strings within element values.  Any protocol
   design should consider how the set of enumerated values is to be
   extended: by revising the protocol, by including different values in
   different XML namespaces, or by establishing an IANA registry (as per
   <a href="rfc2434.html">RFC 2434</a> [<a href="#ref-18" title='"Guidelines for Writing an IANA Considerations Section in RFCs"'>18</a>]).  In addition, a common practice in XML is to use a
   URI as an XML attribute value or content.

   Languages that describe syntactic validity (including XML Schema and
   DTDs) often provide a mechanism for specifying "default" values for
   an attribute.  If an element does not specify a value for the
   attribute, then the "default" value is used.  The use of default
   values for attributes is discouraged by this document.  Although the
   use of this feature can reduce both the size and clutter of XML
   documents, it has a negative impact on software which doesn't know
   the document's validity constraints (e.g., for packet tracing or
   digital signature).








<span class="grey">Hollenbeck, et al.       Best Current Practice                 [Page 15]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-16" id="page-16" name="page-16"> </a>
<span class="grey"><a href="rfc3470.html">RFC 3470</a>               XML within IETF Protocols            January 2003</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.11%20Binary%20Data%20and%20Text%20with%20Control%20Characters"></a><a class="selflink" href="#section-4.11" name="section-4.11">4.11</a> Binary Data and Text with Control Characters</span>

   XML is defined as a character stream rather than a stream of octets.
   There is no way to embed raw binary data directly within an XML data
   stream; all binary data must be encoded as characters.  There are a
   number of possible encodings; for example, XML Schema [<a href="#ref-42" title='"XML Schema Part 2: Datatypes"'>42</a>] defines
   encodings using decimal digits for integers, Base64 [<a href="#ref-15" title='"Multipurpose Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies"'>15</a>], or
   hexadecimal digits.  In addition, binary data might be transmitted
   using some other communication channel, and referenced within the XML
   data itself using a URI.

   Protocols that need a container that can hold both structural data
   and large quantities of binary data should consider carefully whether
   XML is appropriate, since the Base64 and hex encodings are
   inefficient.  Otherwise, protocols should use the mechanisms of XML
   Schema to represent binary data; the Base64 encoding is best for
   larger quantities of data.

   XML does not allow "control" characters (0x00-0x1F) except for TAB
   (0x09), CR (0x0A), and LF (0x0D).  They can not be specified even
   using character entity references.  There is currently no common way
   of encoding them within what is otherwise ordinary text.  This means
   that strings that might be considered "text" within an ABNF-defined
   protocol element may need to be treated as binary data within an XML
   representation, or some other encoding mechanism might need to be
   invented.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.12%20Incremental%20Processing"></a><a class="selflink" href="#section-4.12" name="section-4.12">4.12</a> Incremental Processing</span>

   In some situations, it is possible to incrementally process an XML
   document as each tag is received; this is analogous to the process by
   which browsers incrementally render HTML pages as they are received.
   Note that incremental processing is difficult to implement if
   interspersed across multiple interactions.  In other words, if a
   protocol requires incremental processing across both directions of a
   bidirectional stream, then it may place an unusual burden on protocol
   implementers.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.13%20Entity%20Declarations%20and%20Entity%20References"></a><a class="selflink" href="#section-4.13" name="section-4.13">4.13</a> Entity Declarations and Entity References</span>

   In addition to its role as a validity mechanism, an XML DTD provides
   a facility for "entity declarations" ([<a href="#ref-8" title='"Extensible Markup Language (XML) 1.0 (2nd ed)"'>8</a>], section 4.2).  An entity
   declaration defines, in the DTD, a kind of macro capability where an
   "entity reference" may be used to call up and include the content of
   the entity declaration.






<span class="grey">Hollenbeck, et al.       Best Current Practice                 [Page 16]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-17" id="page-17" name="page-17"> </a>
<span class="grey"><a href="rfc3470.html">RFC 3470</a>               XML within IETF Protocols            January 2003</span>


   This feature adds complexity to XML processing, and seems more
   appropriate for use of XML in document processing than in data
   representation.  As such, this document recommends avoiding entity
   declarations in protocol specifications.

   On the other hand, there are five standard entity references built
   into XML: "&amp;amp;", "&amp;lt;", "&amp;gt;", "&amp;apos;", and "&amp;quot;".  XML also
   has the ability to write character data using numeric entity
   references (using the Unicode [<a href="#ref-33" title='"The Unicode Standard, as it may from time to time be revised or amended"'>33</a>] value for the character).  Entity
   references are normally expanded before the XML Information Set is
   computed.  Restricting the use of these entity references would
   introduce an additional syntactic restriction (see <a href="#section-4.3">Section 4.3</a>)
   unnecessarily; these entity references should be allowed.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.14%20External%20References"></a><a class="selflink" href="#section-4.14" name="section-4.14">4.14</a> External References</span>

   When using XML in the context of a stateless protocol, be it the
   protocol itself (e.g., SOAP), or simply as content transferred by an
   existing protocol (e.g., XML/HTTP), care must be taken to not make
   the meaning of a message depend on information outside the message
   itself.  XML provides external entities (see <a href="#section-4.13">Section 4.13</a>), which are
   an easy way to make the meaning of a message depend on something
   external.  Using schema languages that can change the Infoset, like
   XML Schema, is another way.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.15%20URI%20Processing"></a><a class="selflink" href="#section-4.15" name="section-4.15">4.15</a> URI Processing</span>

   The XML Base specification [<a href="#ref-36" title='"XML Base"'>36</a>] defines an attribute "xml:base" in
   the XML namespace that is intended to affect the "base" to be used
   for relative URI processing described in <a href="rfc2396.html">RFC 2396</a> [<a href="#ref-17" title='"Uniform Resource Identifiers (URI): Generic Syntax"'>17</a>].  The
   facilities of xml:base for controlling URI processing may be useful
   to protocol designers, but if xml:base is allowed the interaction
   with any other protocol facilities for establishing URI context must
   be specified clearly.  Note that use of relative URIs in namespace
   declarations has been deprecated by the W3C; some specific issues
   with relative URIs in namespace declarations and canonical XML can be
   found in <a href="rfc3076.html#section-1.3">section 1.3 of RFC 3076</a> [<a href="#ref-6" title='"Canonical XML Version 1.0"'>6</a>].

   Note also that, in many cases, the term "URI" and the syntactic use
   of URIs within XML allows non-ASCII characters within URIs.  For
   example, the XML Schema "anyURI" datatype ([<a href="#ref-42" title='"XML Schema Part 2: Datatypes"'>42</a>] <a href="#section-3.2.17">section 3.2.17</a>)
   allows for direct encoding of characters outside of the US-ASCII
   range.  Most current IETF protocols and specifications do not allow
   this syntax.  Protocol specifications should be clear about the range
   of characters specified, e.g., by adding a restriction to the range
   of characters allowed in the anyURI schema datatype, or by specifying
   that characters outside the US-ASCII range should be escaped when
   passed to older protocols or APIs.



<span class="grey">Hollenbeck, et al.       Best Current Practice                 [Page 17]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-18" id="page-18" name="page-18"> </a>
<span class="grey"><a href="rfc3470.html">RFC 3470</a>               XML within IETF Protocols            January 2003</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.16%20White%20Space"></a><a class="selflink" href="#section-4.16" name="section-4.16">4.16</a> White Space</span>

   XML's prescribed white space handling behavior can be a source of
   confusion between protocol designers and implementers.  In XML
   instances all white space is considered significant and is by default
   visible to processing applications.  Consider this example from
   <a href="#section-4.10">Section 4.10</a>:

   &lt;address&gt;
     &lt;addrType&gt;&lt;ipv4/&gt;&lt;/addrType&gt;
     &lt;value&gt;10.1.2.3&lt;/value&gt;
   &lt;/address&gt;

   This fragment contains an &lt;address&gt; element and two child elements.
   It also contains white space for pretty-printing purposes:

   o  at least three line separators, which will be converted by the XML
      processor to newline (U+000A) characters (see section 2.11 of
      [<a href="#ref-8" title='"Extensible Markup Language (XML) 1.0 (2nd ed)"'>8</a>]), and

   o  one or more white space characters prefixing the &lt;addrType&gt; and
      &lt;value&gt; elements, which an XML processor will make visible to
      software reading the instance.

   Implementers might safely assume that they can ignore the white space
   in the example above, but white space used for pretty-printing can be
   a source of confusion in other situations.  Consider a minor change
   to the &lt;value&gt; element:

   &lt;value&gt;
     10.1.2.3
   &lt;/value&gt;

   where white space is found on both sides of the IP address.  XML
   processors treat the white space surrounding "10.1.2.3" as an
   integral part of the &lt;value&gt; element.  A failure to recognize this
   behavior can lead to confusion and errors in both design and
   implementation.

   All white space is considered significant in XML instances.  As a
   consequence, it is recommended that protocol designers provide
   specific guidelines to address white space handling within protocols
   that use XML.








<span class="grey">Hollenbeck, et al.       Best Current Practice                 [Page 18]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-19" id="page-19" name="page-19"> </a>
<span class="grey"><a href="rfc3470.html">RFC 3470</a>               XML within IETF Protocols            January 2003</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.17%20Interaction%20with%20the%20IANA"></a><a class="selflink" href="#section-4.17" name="section-4.17">4.17</a> Interaction with the IANA</span>

   When XML is used in an IETF protocol there are multiple factors that
   might require IANA action, including:

   o  XML media types.  A piece of XML in a protocol element is
      sometimes intrinsically bound to the protocol context in which it
      appears, and in particular might be directly derived from and/or
      input to protocol state-machine implementations.  In cases where
      the XML content has no relevant meaning outside it's original
      protocol context, there is no reason to register a MIME type.
      When it is possible that XML content can be interpreted outside of
      its original context (such as when that XML content is being
      stored in a file system or tunneled over another protocol), then a
      MIME type can be registered to specify the specific format for the
      data and to provide a hint as to how it might be processed.

      If MIME labeling is needed, then the advice of <a href="rfc3023.html">RFC 3023</a> [<a href="#ref-5" title='"XML Media Types"'>5</a>]
      applies.  In particular, if the XML represents a new language or
      document type, a new MIME media type should be registered for the
      reasons described in <a href="rfc3023.html">RFC 3023</a> sections <a href="#section-7">7</a> and A.1.  In situations
      where XML is used to encode generic structured data (e.g., a
      document-oriented application that involves combining XML with a
      stylesheet), "application/xml" might be appropriate ("MAY be
      used").  The "text/xml" media type is not recommended ("SHOULD NOT
      be used") because of issues involving display behavior and default
      charsets.

   o  URI registration.  There is an ongoing effort ([<a href="#ref-11" title='"An IETF URN Sub-namespace for Registered Protocol Parameters"'>11</a>], [<a href="#ref-12" title='"The IETF XML Registry"'>12</a>]) to
      create a URN namespace explicitly for defining URIs for namespace
      names and other URI-designated protocol elements for use within
      IETF standards track documents; it might also establish IETF
      policy for such use.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/5.%20Internationalization%20Considerations"></a><a class="selflink" href="#section-5" name="section-5">5</a>. Internationalization Considerations</span>

   This section describes internationalization considerations for the
   use of XML to represent data in IETF protocols.  In addition to the
   recommendations here, IETF policy on the use of character sets and
   languages described in <a href="rfc2277.html">RFC 2277</a> [<a href="#ref-3" title='"IETF Policy on Character Sets and Languages"'>3</a>] also applies.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.1%20Character%20Sets%20and%20Encodings"></a><a class="selflink" href="#section-5.1" name="section-5.1">5.1</a> Character Sets and Encodings</span>

   IETF protocols frequently speak of the "character set" or "charset"
   of a string, which is used to denote both the character repertoire
   and the encoding used to represent sequences of characters as
   sequences of bytes.




<span class="grey">Hollenbeck, et al.       Best Current Practice                 [Page 19]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-20" id="page-20" name="page-20"> </a>
<span class="grey"><a href="rfc3470.html">RFC 3470</a>               XML within IETF Protocols            January 2003</span>


   XML performs all character processing in terms of the Universal
   Character Set (UCS, [<a href="#ref-31" title='"Information Technology - Universal Multiple-octet coded Character Set (UCS) - Part 1: Architecture and Basic Multilingual Plane"'>31</a>] and [<a href="#ref-33" title='"The Unicode Standard, as it may from time to time be revised or amended"'>33</a>]).  XML requires all XML processors
   to support both the UTF-8 [<a href="#ref-4" title='"UTF-8, a transformation format of ISO 10646"'>4</a>] and UTF-16 [<a href="#ref-20" title='"UTF-16, an encoding of ISO 10646"'>20</a>] encodings of UCS,
   although other encodings (charsets) compatible with UCS may be
   allowed.  Documents and external parsed entities encoded in UTF-16
   are required to begin with a Byte Order Mark ([<a href="#ref-8" title='"Extensible Markup Language (XML) 1.0 (2nd ed)"'>8</a>] <a href="#section-4.3.3">section 4.3.3</a>).

   IETF policy [<a href="#ref-3" title='"IETF Policy on Character Sets and Languages"'>3</a>] requires that the UTF-8 charset be allowed for all
   text.

   This document requires that IETF protocols using XML allow for the
   UTF-8 encoding of XML data.  Since conforming XML processors are
   mandated to also accept UTF-16 encoding, also allowing for UTF-16
   encoding (with the mandated Byte Order Mark) is recommended.  Some
   XML applications are using a Byte Order Mark with UTF-8 encoding, but
   this use should not be encouraged and isn't appropriate for XML
   embedded in other protocols.

   Restricting XML data to only be expressed in UTF-8 is an additional
   syntactic restriction (see <a href="#section-4.3">Section 4.3</a>) which, depending on
   circumstances, might add additional implementation complexity.  When
   encodings other than UTF-8 or UTF-16 are used, the encoding must be
   specified using an "encoding" attribute in the XML declaration (see
   <a href="#section-4.4">Section 4.4</a>), even if there might be other protocol mechanisms for
   designating the encoding.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.2%20Language%20Declaration"></a><a class="selflink" href="#section-5.2" name="section-5.2">5.2</a> Language Declaration</span>

   Text encapsulated in XML can be represented in many different human
   languages, and it is often useful to explicitly identify the language
   used to present the text.  XML defines a special attribute in the
   "xml" namespace, xml:lang, that can be used to specify the language
   used to represent data in an XML document.  The xml:lang attribute
   (which has to be explicitly declared for use within a DTD or XML
   Schema) and the values it can assume are defined in section 2.12 of
   [<a href="#ref-8" title='"Extensible Markup Language (XML) 1.0 (2nd ed)"'>8</a>].

   It is strongly recommended that protocols representing data in a
   human language mandate use of an xml:lang attribute if the XML
   instance might be interpreted in language-dependent contexts.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.3%20Other%20Internationalization%20Considerations"></a><a class="selflink" href="#section-5.3" name="section-5.3">5.3</a> Other Internationalization Considerations</span>

   There are standard mechanisms in the typography of some human
   languages that can be difficult to represent using merely XML
   character string data types.  For example, pronunciation clues can be
   provided using Ruby annotation [<a href="#ref-39" title='"Ruby Annotation"'>39</a>], and embedding controls (such as
   those described in section 3.4 of [<a href="#ref-34" title='"Unicode in XML and other Markup Languages"'>34</a>]) or an XHTML [<a href="#ref-40" title='"XHTML 1.0: The Extensible HyperText Markup Language"'>40</a>] "dir"



<span class="grey">Hollenbeck, et al.       Best Current Practice                 [Page 20]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-21" id="page-21" name="page-21"> </a>
<span class="grey"><a href="rfc3470.html">RFC 3470</a>               XML within IETF Protocols            January 2003</span>


   attribute can be used to note the proper display direction for
   bidirectional text.

   There are a number of tricky issues that can arise when using
   extended character sets with XML document formats.  For example:

   o  There are different ways of representing characters consisting of
      combining characters, and

   o  There has been some debate about whether URIs should be
      represented using a restricted US-ASCII subset or arbitrary
      Unicode (e.g., "URI character sequence" vs "original character
      sequence" in <a href="rfc2396.html">RFC 2396</a> [<a href="#ref-17" title='"Uniform Resource Identifiers (URI): Generic Syntax"'>17</a>]).

   Some of these issues are discussed, with recommendations, in the
   W3C's "Character Model for the World Wide Web" document [<a href="#ref-44" title='"Character Model for the World Wide Web 1.0"'>44</a>].

   It is strongly recommended that protocols representing data in a
   human language reuse existing mechanisms as needed to ensure proper
   display of human-legible text.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/6.%20IANA%20Considerations"></a><a class="selflink" href="#section-6" name="section-6">6</a>. IANA Considerations</span>

   This memo, per se, has no impact on the IANA.  <a href="#section-4.17">Section 4.17</a> notes
   some factors that might require IANA action when protocols using XML
   are defined.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/7.%20Security%20Considerations"></a><a class="selflink" href="#section-7" name="section-7">7</a>. Security Considerations</span>

   Network protocols face many different kinds of threats, including
   unintended disclosure, modification, and replay.  Passive attacks,
   such as packet sniffing, allow an attacker to capture and view
   information intended for someone else.  Captured data can be modified
   and replayed to the original intended recipient, with the recipient
   having no way to know that the information has been compromised,
   detect modifications, be assured of the sender's identity, or to
   confirm which protocol instance is legitimate.

   Several security service options for XML are available to help
   mitigate these risks.  Though XML does not include any built-in
   security services, other protocols and protocol layers provide
   services that can be used to protect XML protocols.  XML encryption
   [<a href="#ref-10" title='"XML Encryption Syntax and Processing"'>10</a>] provides privacy services to prevent unintended disclosure.
   Canonical XML [<a href="#ref-6" title='"Canonical XML Version 1.0"'>6</a>] and XML digital signatures [<a href="#ref-7" title='"(Extensible Markup Language) XML-Signature Syntax and Processing"'>7</a>] provide integrity
   services to detect modification and authentication services to
   confirm the identity of the data source.  Other IETF security
   protocols (e.g., the Transport Layer Security (TLS) protocol [<a href="#ref-2" title='"The TLS Protocol Version 1.0"'>2</a>]) are
   also available to protect data and service endpoints as appropriate.



<span class="grey">Hollenbeck, et al.       Best Current Practice                 [Page 21]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-22" id="page-22" name="page-22"> </a>
<span class="grey"><a href="rfc3470.html">RFC 3470</a>               XML within IETF Protocols            January 2003</span>


   Given the lack of security services in XML, it is imperative that
   protocol specifications mandate additional security services to
   counter common threats and attacks; the specific required services
   will depend on the protocol's threat model.

   Experience has shown that code that parses network traffic is often a
   "soft target" for blackhats.  Accordingly, implementers MUST take
   great care to ensure that their XML handling code is robust with
   respect to malformed XML, buffer overruns, misuse of entity
   declarations, and so on.

   XML mechanisms that follow external references (<a href="#section-4.14">Section 4.14</a>) may
   also expose an implementation to various threats by causing the
   implementation to access external resources automatically.  It is
   important to disallow arbitrary access to such external references
   within XML data from untrusted sources.  Many XML grammars define
   constructs using URIs for external references; in such cases, the
   same precautions must be taken.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/8.%20Acknowledgements"></a><a class="selflink" href="#section-8" name="section-8">8</a>. Acknowledgements</span>

   The authors would like to thank the following people who have
   provided significant contributions to the development of this
   document:

   Mark Baker, Tim Berners-Lee, Tim Bray, James Clark, Josh Cohen, John
   Cowan, Alan Crouch, Martin Duerst, Jun Fujisawa, Christian Geuer-
   Pollmann, Yaron Goland, Graham Klyne, Dan Kohn, Rick Jeliffe, Chris
   Lilley, Murata Makoto, Michael Mealling, Jean-Jacques Moreau, Andrew
   Newton, Julian Reschke, Jonathan Rosenberg, Miles Sabin, Rich Salz,
   Peter Saint-Andre, Simon St Laurent, Margaret Wasserman, and Daniel
   Veillard.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/9.%20Normative%20References"></a><a class="selflink" href="#section-9" name="section-9">9</a>. Normative References</span>

   [<a id="ref-1" name="ref-1">1</a>]   Bradner, S., "Key words for use in RFCs to Indicate Requirement
         Levels", <a href="https://tools.ietf.org/html/bcp14">BCP 14</a>, <a href="rfc2119.html">RFC 2119</a>, March 1997.

   [<a id="ref-2" name="ref-2">2</a>]   Dierks, T. and C. Allen, "The TLS Protocol Version 1.0", <a href="rfc2246.html">RFC</a>
         <a href="rfc2246.html">2246</a>, January 1999.

   [<a id="ref-3" name="ref-3">3</a>]   Alvestrand, H., "IETF Policy on Character Sets and Languages",
         <a href="https://tools.ietf.org/html/bcp18">BCP 18</a>, <a href="rfc2277.html">RFC 2277</a>, January 1998.

   [<a id="ref-4" name="ref-4">4</a>]   Yergeau, F., "UTF-8, a transformation format of ISO 10646", <a href="rfc2279.html">RFC</a>
         <a href="rfc2279.html">2279</a>, January 1998.





<span class="grey">Hollenbeck, et al.       Best Current Practice                 [Page 22]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-23" id="page-23" name="page-23"> </a>
<span class="grey"><a href="rfc3470.html">RFC 3470</a>               XML within IETF Protocols            January 2003</span>


   [<a id="ref-5" name="ref-5">5</a>]   Murata, M., St. Laurent, S. and D. Kohn, "XML Media Types", <a href="rfc3023.html">RFC</a>
         <a href="rfc3023.html">3023</a>, January 2001.

   [<a id="ref-6" name="ref-6">6</a>]   Boyer, J., "Canonical XML Version 1.0", <a href="rfc3076.html">RFC 3076</a>, March 2001.

   [<a id="ref-7" name="ref-7">7</a>]   Eastlake, D., Reagle, J. and D. Solo, "(Extensible Markup
         Language) XML-Signature Syntax and Processing", <a href="rfc3275.html">RFC 3275</a>, March
         2002.

   [<a id="ref-8" name="ref-8">8</a>]   Bray, T., Paoli, J., Sperberg-McQueen, C. and E. Maler,
         "Extensible Markup Language (XML) 1.0 (2nd ed)", W3C REC-xml,
         October 2000, &lt;<a href="http://www.w3.org/TR/REC-xml">http://www.w3.org/TR/REC-xml</a>&gt;.

   [<a id="ref-9" name="ref-9">9</a>]   Bray, T., Hollander, D. and A. Layman, "Namespaces in XML", W3C
         REC-xml-names, January 1999, &lt;<a href="http://www.w3.org/TR/REC-xml-names">http://www.w3.org/TR/REC-xml-</a>
         <a href="http://www.w3.org/TR/REC-xml-names">names</a>&gt;.

   [<a id="ref-10" name="ref-10">10</a>]  Imamura, T., Dillaway, B., Schaad, J. and E. Simon, "XML
         Encryption Syntax and Processing", W3C REC-xmlenc-core, October
         2001, &lt;<a href="http://www.w3.org/TR/xmlenc-core/">http://www.w3.org/TR/xmlenc-core/</a>&gt;.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/10.%20Informative%20References"></a><a class="selflink" href="#section-10" name="section-10">10</a>. Informative References</span>

   [<a id="ref-11" name="ref-11">11</a>]  Masinter, L., Mealling, M., Klyne, G. and T. Hardie, "An IETF
         URN Sub-namespace for Registered Protocol Parameters", Work in
         Progress.

   [<a id="ref-12" name="ref-12">12</a>]  Mealling, M., <a href="https://www.google.com/search?sitesearch=tools.ietf.org%2Fhtml%2F&amp;q=inurl:draft-+%22The+IETF+XML+Registry%22" style="text-decoration: none">"The IETF XML Registry"</a>, Work in Progress.

   [<a id="ref-13" name="ref-13">13</a>]  Case, J., Fedor, M., Schoffstall, M. and C. Davin, "Simple
         Network Management Protocol (SNMP)", STD 15, <a href="rfc1157.html">RFC 1157</a>, May
         1990.

   [<a id="ref-14" name="ref-14">14</a>]  Srinivasan, R., "XDR: External Data Representation Standard",
         <a href="rfc1832.html">RFC 1832</a>, August 1995.

   [<a id="ref-15" name="ref-15">15</a>]  Freed, N. and N. Borenstein, "Multipurpose Internet Mail
         Extensions (MIME) Part One: Format of Internet Message Bodies",
         <a href="rfc2045.html">RFC 2045</a>, November 1996.

   [<a id="ref-16" name="ref-16">16</a>]  Crocker, D. (Ed.) and P. Overell, "Augmented BNF for Syntax
         Specifications: ABNF", <a href="rfc2234.html">RFC 2234</a>, November 1997.

   [<a id="ref-17" name="ref-17">17</a>]  Berners-Lee, T., Fielding, R. and L. Masinter, "Uniform
         Resource Identifiers (URI): Generic Syntax", <a href="rfc2396.html">RFC 2396</a>, August
         1998.





<span class="grey">Hollenbeck, et al.       Best Current Practice                 [Page 23]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-24" id="page-24" name="page-24"> </a>
<span class="grey"><a href="rfc3470.html">RFC 3470</a>               XML within IETF Protocols            January 2003</span>


   [<a id="ref-18" name="ref-18">18</a>]  Narten, T. and H. Alvestrand, "Guidelines for Writing an IANA
         Considerations Section in RFCs", <a href="https://tools.ietf.org/html/bcp26">BCP 26</a>, <a href="rfc2434.html">RFC 2434</a>, October
         1998.

   [<a id="ref-19" name="ref-19">19</a>]  Rose, M., "Writing I-Ds and RFCs using XML", <a href="rfc2629.html">RFC 2629</a>, June
         1999.

   [<a id="ref-20" name="ref-20">20</a>]  Hoffman, P. and F. Yergeau, "UTF-16, an encoding of ISO 10646",
         <a href="rfc2781.html">RFC 2781</a>, February 2000.

   [<a id="ref-21" name="ref-21">21</a>]  Klensin, J. (Ed.), "Simple Mail Transfer Protocol", <a href="rfc2821.html">RFC 2821</a>,
         April 2001.

   [<a id="ref-22" name="ref-22">22</a>]  Shepler, S., Callaghan, B., Robinson, D., Thurlow, R., Beame,
         C., Eisler, M. and D. Noveck, "NFS version 4 Protocol", <a href="rfc3010.html">RFC</a>
         <a href="rfc3010.html">3010</a>, December 2000.

   [<a id="ref-23" name="ref-23">23</a>]  Kennedy, H., "Binary Lexical Octet Ad-hoc Transport", <a href="rfc3252.html">RFC 3252</a>,
         April 2002.

   [<a id="ref-24" name="ref-24">24</a>]  Popp, N., Mealling, M. and M. Moseley, "Common Name Resolution
         Protocol (CNRP)", <a href="rfc3367.html">RFC 3367</a>, August 2002.

   [<a id="ref-25" name="ref-25">25</a>]  Backus, J., "The syntax and semantics of the proposed
         international algebraic language of the Zurich ACM-GAMM
         conference", June 1959.

   [<a id="ref-26" name="ref-26">26</a>]  American National Standards Institute, "Code Extension
         Techniques for Use with the 7-bit Coded Character Set of
         American National Standard Code (ASCII) for Information
         Interchange", ANSI X3.41, FIPS PUB 35, 1974.

   [<a id="ref-27" name="ref-27">27</a>]  American National Standards Institute, "Information Retrieval:
         Application Service Definition and Protocol Specification",
         ANSI Z39.50, ISO Standard 23950, 1995.

   [<a id="ref-28" name="ref-28">28</a>]  International Organization for Standardization, "Information
         Processing Systems - Open Systems Interconnection -
         Specification of Abstract Syntax Notation One (ASN.1)", ISO
         Standard 8824, December 1990.

   [<a id="ref-29" name="ref-29">29</a>]  International Organization for Standardization, "Information
         Processing Systems - Open Systems Interconnection -
         Specification of Basic Encoding Rules for Abstract Syntax
         Notation One (ASN.1)", ISO Standard 8825, December 1990.






<span class="grey">Hollenbeck, et al.       Best Current Practice                 [Page 24]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-25" id="page-25" name="page-25"> </a>
<span class="grey"><a href="rfc3470.html">RFC 3470</a>               XML within IETF Protocols            January 2003</span>


   [<a id="ref-30" name="ref-30">30</a>]  International Organization for Standardization, "Information
         processing - Text and office systems - Standard Generalized
         Markup Language (SGML)", ISO Standard 8879, 1988.

   [<a id="ref-31" name="ref-31">31</a>]  International Organization for Standardization, "Information
         Technology - Universal Multiple-octet coded Character Set (UCS)
         - Part 1: Architecture and Basic Multilingual Plane", ISO
         Standard 10646-1, May 1993.

   [<a id="ref-32" name="ref-32">32</a>]  International Organization for Standardization, "DSDL Part 0 -
         Overview", December 2001, &lt;<a href="http://www.jtc1.org/FTP/Public/SC34/DOCREG/0275.htm">http://www.jtc1.org/FTP/Public/SC34/</a>
         <a href="http://www.jtc1.org/FTP/Public/SC34/DOCREG/0275.htm">DOCREG/0275.htm</a>&gt;.

   [<a id="ref-33" name="ref-33">33</a>]  Unicode Consortium, "The Unicode Standard, as it may from time
         to time be revised or amended", March 2002, &lt;<a href="http://www.unicode.org/unicode/standard/standard.html">http://</a>
         <a href="http://www.unicode.org/unicode/standard/standard.html">www.unicode.org/unicode/standard/standard.html</a>&gt;.

   [<a id="ref-34" name="ref-34">34</a>]  Duerst, M. and A. Freytag, "Unicode in XML and other Markup
         Languages", February 2002, &lt;<a href="http://www.w3.org/TR/unicode-xml/">http://www.w3.org/TR/unicode-xml/</a>&gt;.

   [<a id="ref-35" name="ref-35">35</a>]  Bray, T., Paoli, J. and C. Sperberg-McQueen, "Extensible Markup
         Language (XML) 1.0", W3C REC-xml-1998, February 1998, &lt;<a href="http://www.w3.org/TR/1998/REC-xml-19980210/">http://</a>
         <a href="http://www.w3.org/TR/1998/REC-xml-19980210/">www.w3.org/TR/1998/REC-xml-19980210/</a>&gt;.

   [<a id="ref-36" name="ref-36">36</a>]  Marsh, J., "XML Base", W3C REC-xmlbase, June 2001, &lt;<a href="http://www.w3.org/TR/xmlbase/">http://</a>
         <a href="http://www.w3.org/TR/xmlbase/">www.w3.org/TR/xmlbase/</a>&gt;.

   [<a id="ref-37" name="ref-37">37</a>]  Cowan, J. and R. Tobin, "XML Information Set", W3C REC-infoset,
         October 2001, &lt;<a href="http://www.w3.org/TR/xml-infoset/">http://www.w3.org/TR/xml-infoset/</a>&gt;.

   [<a id="ref-38" name="ref-38">38</a>]  Lassila, O. and R. Swick, "Resource Description Framework (RDF)
         Model and Syntax Specification", W3C REC-rdf-syntax, February
         1999, &lt;<a href="http://www.w3.org/TR/REC-rdf-syntax">http://www.w3.org/TR/REC-rdf-syntax</a>&gt;.

   [<a id="ref-39" name="ref-39">39</a>]  Suignard, M., Ishikawa, M., Duerst, M. and T. Texin, "Ruby
         Annotation", W3C REC-RUBY, May 2001, &lt;<a href="http://www.w3.org/TR/ruby/">http://www.w3.org/TR/</a>
         <a href="http://www.w3.org/TR/ruby/">ruby/</a>&gt;.

   [<a id="ref-40" name="ref-40">40</a>]  Pemberton, S., "XHTML 1.0: The Extensible HyperText Markup
         Language", W3C REC-XHTML, January 2000, &lt;<a href="http://www.w3.org/TR/xhtml1/">http://www.w3.org/TR/</a>
         <a href="http://www.w3.org/TR/xhtml1/">xhtml1/</a>&gt;.

   [<a id="ref-41" name="ref-41">41</a>]  Thompson, H., Beech, D., Maloney, M. and N. Mendelsohn, "XML
         Schema Part 1: Structures", W3C REC-xmlschema-1, May 2001,
         &lt;<a href="http://www.w3.org/TR/xmlschema-1/">http://www.w3.org/TR/xmlschema-1/</a>&gt;.

   [<a id="ref-42" name="ref-42">42</a>]  Biron, P. and A. Malhotra, "XML Schema Part 2: Datatypes", W3C
         REC-xmlschema-2, May 2001, &lt;<a href="http://www.w3.org/TR/xmlschema-2/">http://www.w3.org/TR/xmlschema-2/</a>&gt;.



<span class="grey">Hollenbeck, et al.       Best Current Practice                 [Page 25]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-26" id="page-26" name="page-26"> </a>
<span class="grey"><a href="rfc3470.html">RFC 3470</a>               XML within IETF Protocols            January 2003</span>


   [<a id="ref-43" name="ref-43">43</a>]  Clark, J., "XSL Transformations (XSLT) Version 1.0", W3C REC-
         xslt, November 1999, &lt;<a href="http://www.w3.org/TR/xslt">http://www.w3.org/TR/xslt</a>&gt;.

   [<a id="ref-44" name="ref-44">44</a>]  Duerst, M., Yergeau, F., Ishida, R., Wolf, M., Freytag, A. and
         T. Texin, "Character Model for the World Wide Web 1.0", April
         2002, &lt;<a href="http://www.w3.org/TR/charmod/">http://www.w3.org/TR/charmod/</a>&gt;.

   [<a id="ref-45" name="ref-45">45</a>]  Gudgin, M., Hadley, M., Moreau, JJ. and H. Nielsen, "SOAP
         Version 1.2 Part 1: Messaging Framework", June 2002,
         &lt;<a href="http://www.w3.org/TR/soap12-part1/">http://www.w3.org/TR/soap12-part1/</a>&gt;.

   [<a id="ref-46" name="ref-46">46</a>]  Gudgin, M., Hadley, M., Moreau, JJ. and H. Nielsen, "SOAP
         Version 1.2 Part 2: Adjuncts", June 2002,
         &lt;<a href="http://www.w3.org/TR/soap12-part2/">http://www.w3.org/TR/soap12-part2/</a>&gt;.

   [<a id="ref-47" name="ref-47">47</a>]  W3C Communications Team, "XML in 10 points", November 2001,
         &lt;<a href="http://www.w3.org/XML/1999/XML-in-10-points">http://www.w3.org/XML/1999/XML-in-10-points</a>&gt;.

   [<a id="ref-48" name="ref-48">48</a>]  OASIS Technical Committee: RELAX NG, "RELAX NG Specification",
         December 2001, &lt;<a href="http://www.oasis-open.org/committees/relax-ng/spec-20011203.html">http://www.oasis-open.org/committees/relax-ng/</a>
         <a href="http://www.oasis-open.org/committees/relax-ng/spec-20011203.html">spec-20011203.html</a>&gt;.

   [<a id="ref-49" name="ref-49">49</a>]  Jelliffe, R., "The Schematron", November 2001, &lt;<a href="http://www.ascc.net/xml/schematron/">http://</a>
         <a href="http://www.ascc.net/xml/schematron/">www.ascc.net/xml/schematron/</a>&gt;.

URIs

   [<a id="ref-50" name="ref-50">50</a>]  &lt;<a href="http://www.imc.org/ietf-xml-use/">http://www.imc.org/ietf-xml-use/</a>&gt;

   [<a id="ref-51" name="ref-51">51</a>]  &lt;<a href="http://xml.org/">http://xml.org/</a>&gt;

   [<a id="ref-52" name="ref-52">52</a>]  &lt;<a href="http://xmlhack.com/">http://xmlhack.com/</a>&gt;

   [<a id="ref-53" name="ref-53">53</a>]  &lt;<a href="http://oasis-open.org/">http://oasis-open.org/</a>&gt;

















<span class="grey">Hollenbeck, et al.       Best Current Practice                 [Page 26]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-27" id="page-27" name="page-27"> </a>
<span class="grey"><a href="rfc3470.html">RFC 3470</a>               XML within IETF Protocols            January 2003</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/11.%20Authors%27%20Addresses"></a><a class="selflink" href="#section-11" name="section-11">11</a>. Authors' Addresses</span>

   Scott Hollenbeck
   VeriSign, Inc.
   21345 Ridgetop Circle
   Dulles, VA  20166-6503
   US

   Phone: +1 703 948 3257
   EMail: shollenbeck@verisign.com


   Marshall T. Rose
   Dover Beach Consulting, Inc.
   POB 255268
   Sacramento, CA  95865-5268
   US

   Phone: +1 916 483 8878
   EMail: mrose@dbc.mtview.ca.us


   Larry Masinter
   Adobe Systems Incorporated
   Mail Stop W14
   345 Park Ave.
   San Jose, CA  95110
   US

   Phone: +1 408 536 3024
   EMail: LMM@acm.org
   URI:   <a href="http://larry.masinter.net/">http://larry.masinter.net</a>



















<span class="grey">Hollenbeck, et al.       Best Current Practice                 [Page 27]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-28" id="page-28" name="page-28"> </a>
<span class="grey"><a href="rfc3470.html">RFC 3470</a>               XML within IETF Protocols            January 2003</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/12.%20%20Full%20Copyright%20Statement"></a><a class="selflink" href="#section-12" name="section-12">12</a>.  Full Copyright Statement</span>

   Copyright (C) The Internet Society (2003).  All Rights Reserved.

   This document and translations of it may be copied and furnished to
   others, and derivative works that comment on or otherwise explain it
   or assist in its implementation may be prepared, copied, published
   and distributed, in whole or in part, without restriction of any
   kind, provided that the above copyright notice and this paragraph are
   included on all such copies and derivative works.  However, this
   document itself may not be modified in any way, such as by removing
   the copyright notice or references to the Internet Society or other
   Internet organizations, except as needed for the purpose of
   developing Internet standards in which case the procedures for
   copyrights defined in the Internet Standards process must be
   followed, or as required to translate it into languages other than
   English.

   The limited permissions granted above are perpetual and will not be
   revoked by the Internet Society or its successors or assigns.

   This document and the information contained herein is provided on an
   "AS IS" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING
   TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING
   BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION
   HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF
   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.

Acknowledgement

   Funding for the RFC Editor function is currently provided by the
   Internet Society.



















Hollenbeck, et al.       Best Current Practice                 [Page 28]

</pre><br/>
    <span class="noprint"><small><small>Html markup produced by rfcmarkup 1.126, available from
      <a href="https://tools.ietf.org/tools/rfcmarkup/">https://tools.ietf.org/tools/rfcmarkup/</a>
    </small></small></span>
  </div>




</body><!-- Mirrored from tools.ietf.org/html/rfc3470 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 06 Mar 2018 23:18:47 GMT --></html>