<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml"><!-- Mirrored from tools.ietf.org/html/rfc5961 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 06 Mar 2018 23:18:32 GMT --><!-- Added by HTTrack --><head><meta content="text/html;charset=utf-8" http-equiv="content-type"/><!-- /Added by HTTrack -->

    <meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
    <meta content="index,follow" name="robots"/>
    <meta content="rfcmarkup version 1.126" name="creator"/>
    <link href="http://purl.org/dc/elements/1.1/" rel="schema.DC"/>
<meta content="urn:ietf:rfc:5961" name="DC.Identifier"/>
<meta content="TCP has historically been considered protected against spoofed off-
path packet injection attacks by relying on the fact that it is
difficult to guess the 4-tuple (the source and destination IP
addresses and the source and destination ports) in combination with
the 32 bit sequence number(s). A combination of increasing window
sizes and applications using longer term connections (e.g. H-323 or
Border Gateway Protocol [RFC4271]) have left modern TCP
implementations more vulnerable to these types of spoofed packet
injection attacks.  Many of these long term TCP applications tend to
have predictable IP addresses and ports which makes it far easier for
the 4-tuple to be guessed. Having guessed the 4-tuple correctly, an
attacker can inject a RST, SYN or DATA segment into a TCP connection
by systematically guessing the sequence number of the spoofed segment
to be in the current receive window. This can cause the connection to
either abort or possibly cause data corruption. This document
specifies small modifications to the way TCP handles inbound segments
that can reduce the chances of a successful attack." name="DC.Description.Abstract"/>
<meta content="Dalal, Mitesh" name="DC.Creator"/>
<meta content="Stewart, Randall R." name="DC.Creator"/>
<meta content="Ramaiah, Anantha" name="DC.Creator"/>
<meta content="August, 2010" name="DC.Date.Issued"/>
<meta content="Improving TCP's Robustness to Blind In-Window Attacks" name="DC.Title"/>

    <link href="https://tools.ietf.org/images/rfc.png" rel="icon" type="image/png"/>
    <link href="https://tools.ietf.org/images/rfc.png" rel="shortcut icon" type="image/png"/>
    <title>RFC 5961 - Improving TCP's Robustness to Blind In-Window Attacks</title>
    
    
    <style type="text/css">
	@media only screen 
	  and (min-width: 992px)
	  and (max-width: 1199px) {
	    body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 768px)
	  and (max-width: 991px) {
            body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 480px)
	  and (max-width: 767px) {
            body { font-size: 11pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (max-width: 479px) {
            body { font-size: 8pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-device-width : 375px) 
	  and (max-device-width : 667px) {
            body { font-size: 9.5pt; }
            div.content { width: 96ex; margin: 0 1px; }
        }
	@media only screen 
	  and (min-device-width: 1200px) {
            body { font-size: 10pt; margin: 0 4em; }
            div.content { width: 96ex; margin: 0; }
        }
        h1, h2, h3, h4, h5, h6, .h1, .h2, .h3, .h4, .h5, .h6 {
	    font-weight: bold;
            line-height: 0pt;
            display: inline;
            white-space: pre;
            font-family: monospace;
            font-size: 1em;
	    font-weight: bold;
        }
        pre {
            font-size: 1em;
            margin-top: 0px;
            margin-bottom: 0px;
        }
	.pre {
	    white-space: pre;
	    font-family: monospace;
	}
	.header{
	    font-weight: bold;
	}
        .newpage {
            page-break-before: always;
        }
        .invisible {
            text-decoration: none;
            color: white;
        }
        a.selflink {
          color: black;
          text-decoration: none;
        }
        @media print {
            body {
                font-family: monospace;
                font-size: 10.5pt;
            }
            h1, h2, h3, h4, h5, h6 {
                font-size: 1em;
            }
        
            a:link, a:visited {
                color: inherit;
                text-decoration: none;
            }
            .noprint {
                display: none;
            }
        }
	@media screen {
	    .grey, .grey a:link, .grey a:visited {
		color: #777;
	    }
            .docinfo {
                background-color: #EEE;
            }
            .top {
                border-top: 7px solid #EEE;
            }
            .bgwhite  { background-color: white; }
            .bgred    { background-color: #F44; }
            .bggrey   { background-color: #666; }
            .bgbrown  { background-color: #840; }            
            .bgorange { background-color: #FA0; }
            .bgyellow { background-color: #EE0; }
            .bgmagenta{ background-color: #F4F; }
            .bgblue   { background-color: #66F; }
            .bgcyan   { background-color: #4DD; }
            .bggreen  { background-color: #4F4; }

            .legend   { font-size: 90%; }
            .cplate   { font-size: 70%; border: solid grey 1px; }
	}
    </style>
    <!--[if IE]>
    <style>
    body {
       font-size: 13px;
       margin: 10px 10px;
    }
    </style>
    <![endif]-->

    <script type="text/javascript"><!--
    function addHeaderTags() {
	var spans = document.getElementsByTagName("span");
	for (var i=0; i < spans.length; i++) {
	    var elem = spans[i];
	    if (elem) {
		var level = elem.getAttribute("class");
                if (level == "h1" || level == "h2" || level == "h3" || level == "h4" || level == "h5" || level == "h6") {
                    elem.innerHTML = "<"+level+">"+elem.innerHTML+"</"+level+">";		
                }
	    }
	}
    }
    var legend_html = "Colour legend:<br />      <table>         <tr><td>Unknown:</td>                   <td><span class='cplate bgwhite'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft:</td>                     <td><span class='cplate bgred'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Informational:</td>             <td><span class='cplate bgorange'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Experimental:</td>              <td><span class='cplate bgyellow'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Best Common Practice:</td>      <td><span class='cplate bgmagenta'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Proposed Standard:</td>         <td><span class='cplate bgblue'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft Standard (old designation):</td> <td><span class='cplate bgcyan'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Internet Standard:</td>         <td><span class='cplate bggreen'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Historic:</td>                  <td><span class='cplate bggrey'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Obsolete:</td>                  <td><span class='cplate bgbrown'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>     </table>";
    function showElem(id) {
        var elem = document.getElementById(id);
        elem.innerHTML = eval(id+"_html");
        elem.style.visibility='visible';
    }
    function hideElem(id) {
        var elem = document.getElementById(id);
        elem.style.visibility='hidden';        
        elem.innerHTML = "";
    }
    // -->
    </script>
</head>
<body onload="addHeaderTags()">
  <div class="content">
   <div style="height: 13px;">
      <div class="pre noprint docinfo bgblue" onclick="showElem('legend');" onmouseout="hideElem('legend')" onmouseover="this.style.cursor='pointer';" style="height: 6px; position: absolute;" title="Click for colour legend.">                                                                        </div>
      <div class="docinfo noprint pre legend" id="legend" onmouseout="hideElem('legend');" onmouseover="showElem('legend');" style="position:absolute; top: 4px; left: 4ex; visibility:hidden; background-color: white; padding: 4px 9px 5px 7px; border: solid #345 1px; ">
      </div>
   </div>
<span class="pre noprint docinfo top">[<a href="index.html" title="Document search and retrieval page">Docs</a>] [<a href="https://tools.ietf.org/rfc/rfc5961.txt" title="Plaintext version of this document">txt</a>|<a href="https://tools.ietf.org/pdf/rfc5961" title="PDF version of this document">pdf</a>] [<a href="https://tools.ietf.org/html/draft-ietf-tcpm-tcpsecure" title="draft-ietf-tcpm-tcpsecure">draft-ietf-tcpm...</a>] [<a href="https://datatracker.ietf.org/doc/rfc5961" title="IESG Datatracker information for this document">Tracker</a>] [<a href="https://tools.ietf.org/rfcdiff?difftype=--hwdiff&amp;url2=rfc5961" title="Inline diff (wdiff)">Diff1</a>] [<a href="https://tools.ietf.org/rfcdiff?url2=rfc5961" title="Side-by-side diff">Diff2</a>] [<a href="https://datatracker.ietf.org/ipr/search/?rfc=5961&amp;submit=rfc" title="IPR disclosures related to this document">IPR</a>] [<a href="https://www.rfc-editor.org/errata_search.php?rfc=5961">Errata</a>]</span><br/>
<span class="pre noprint docinfo">                                                                        </span><br/>
<span class="pre noprint docinfo">                                                       PROPOSED STANDARD</span><br/>
<span class="pre noprint docinfo">                                                            <span style="color: #C00;">Errata Exist</span></span><br/>
<pre>Internet Engineering Task Force (IETF)                        A. Ramaiah
Request for Comments: 5961                                         Cisco
Category: Standards Track                                     R. Stewart
ISSN: 2070-1721                                                   Huawei
                                                                M. Dalal
                                                                   Cisco
                                                             August 2010


         <span class="h1">Improving TCP's Robustness to Blind In-Window Attacks</span>

Abstract

   TCP has historically been considered to be protected against spoofed
   off-path packet injection attacks by relying on the fact that it is
   difficult to guess the 4-tuple (the source and destination IP
   addresses and the source and destination ports) in combination with
   the 32-bit sequence number(s).  A combination of increasing window
   sizes and applications using longer-term connections (e.g., H-323 or
   Border Gateway Protocol (BGP) [<a href="rfc4271.html" title='"A Border Gateway Protocol 4 (BGP-4)"'>RFC4271</a>]) have left modern TCP
   implementations more vulnerable to these types of spoofed packet
   injection attacks.

   Many of these long-term TCP applications tend to have predictable IP
   addresses and ports that makes it far easier for the 4-tuple (4-tuple
   is the same as the socket pair mentioned in <a href="rfc793.html">RFC 793</a>) to be guessed.
   Having guessed the 4-tuple correctly, an attacker can inject a TCP
   segment with the RST bit set, the SYN bit set or data into a TCP
   connection by systematically guessing the sequence number of the
   spoofed segment to be in the current receive window.  This can cause
   the connection to abort or cause data corruption.  This document
   specifies small modifications to the way TCP handles inbound segments
   that can reduce the chances of a successful attack.

Status of This Memo

   This is an Internet Standards Track document.

   This document is a product of the Internet Engineering Task Force
   (IETF).  It represents the consensus of the IETF community.  It has
   received public review and has been approved for publication by the
   Internet Engineering Steering Group (IESG).  Further information on
   Internet Standards is available in <a href="rfc5741.html#section-2">Section 2 of RFC 5741</a>.

   Information about the current status of this document, any errata,
   and how to provide feedback on it may be obtained at
   <a href="http://www.rfc-editor.org/info/rfc5961">http://www.rfc-editor.org/info/rfc5961</a>.




<span class="grey">Ramaiah, et al.              Standards Track                    [Page 1]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-2" id="page-2" name="page-2"> </a>
<span class="grey"><a href="rfc5961.html">RFC 5961</a>                      TCP Security                   August 2010</span>


Copyright Notice

   Copyright (c) 2010 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to <a href="https://tools.ietf.org/html/bcp78">BCP 78</a> and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (<a href="http://trustee.ietf.org/license-info">http://trustee.ietf.org/license-info</a>) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.

Table of Contents

   <a href="#section-1">1</a>. Introduction ....................................................<a href="#page-3">3</a>
      <a href="#section-1.1">1.1</a>. Applicability Statement ....................................<a href="#page-3">3</a>
      <a href="#section-1.2">1.2</a>. Basic Attack Methodology ...................................<a href="#page-4">4</a>
      <a href="#section-1.3">1.3</a>. Attack probabilities .......................................<a href="#page-5">5</a>
   <a href="#section-2">2</a>. Terminology .....................................................<a href="#page-7">7</a>
   <a href="#section-3">3</a>. Blind Reset Attack Using the RST Bit ............................<a href="#page-7">7</a>
      <a href="#section-3.1">3.1</a>. Description of the Attack ..................................<a href="#page-7">7</a>
      <a href="#section-3.2">3.2</a>. Mitigation .................................................<a href="#page-7">7</a>
   <a href="#section-4">4</a>. Blind Reset Attack Using the SYN Bit ............................<a href="#page-9">9</a>
      <a href="#section-4.1">4.1</a>. Description of the Attack ..................................<a href="#page-9">9</a>
      <a href="#section-4.2">4.2</a>. Mitigation .................................................<a href="#page-9">9</a>
   <a href="#section-5">5</a>. Blind Data Injection Attack ....................................<a href="#page-10">10</a>
      <a href="#section-5.1">5.1</a>. Description of the Attack .................................<a href="#page-10">10</a>
      <a href="#section-5.2">5.2</a>. Mitigation ................................................<a href="#page-11">11</a>
   <a href="#section-6">6</a>. Suggested Mitigation Strengths .................................<a href="#page-12">12</a>
   <a href="#section-7">7</a>. ACK Throttling .................................................<a href="#page-12">12</a>
   <a href="#section-8">8</a>. Backward Compatibility and Other Considerations ................<a href="#page-13">13</a>
   <a href="#section-9">9</a>. Middlebox Considerations .......................................<a href="#page-14">14</a>
      <a href="#section-9.1">9.1</a>. Middlebox That Resend RSTs ................................<a href="#page-14">14</a>
      <a href="#section-9.2">9.2</a>. Middleboxes That Advance Sequence Numbers .................<a href="#page-15">15</a>
      <a href="#section-9.3">9.3</a>. Middleboxes That Drop the Challenge ACK ...................<a href="#page-15">15</a>
   <a href="#section-10">10</a>. Security Considerations .......................................<a href="#page-16">16</a>
   <a href="#section-11">11</a>. Contributors ..................................................<a href="#page-17">17</a>
   <a href="#section-12">12</a>. Acknowledgments ...............................................<a href="#page-17">17</a>
   <a href="#section-13">13</a>. References ....................................................<a href="#page-17">17</a>
      <a href="#section-13.1">13.1</a>. Normative References .....................................<a href="#page-17">17</a>
      <a href="#section-13.2">13.2</a>. Informative References ...................................<a href="#page-17">17</a>







<span class="grey">Ramaiah, et al.              Standards Track                    [Page 2]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-3" id="page-3" name="page-3"> </a>
<span class="grey"><a href="rfc5961.html">RFC 5961</a>                      TCP Security                   August 2010</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/1.%20%20Introduction"></a><a class="selflink" href="#section-1" name="section-1">1</a>.  Introduction</span>

   TCP [<a href="https://tools.ietf.org/html/rfc0793" title='"Transmission Control Protocol"'>RFC0793</a>] is widely deployed and the most common reliable end-to-
   end transport protocol used for data communication in today's
   Internet.  Yet, when it was standardized over 20 years ago, the
   Internet was a different place, lacking many of the threats that are
   now common.  The off-path TCP spoofing attacks, which are seen in the
   Internet today, fall into this category.

   In a TCP spoofing attack, an off-path attacker crafts TCP packets by
   forging the IP source and destination addresses as well as the source
   and destination ports (referred to as a 4-tuple value in this
   document).  The targeted TCP endpoint will then associate such a
   packet with an existing TCP connection.  It needs to be noted that,
   guessing this 4-tuple value is not always easy for an attacker.  But
   there are some applications (e.g., BGP [<a href="rfc4271.html" title='"A Border Gateway Protocol 4 (BGP-4)"'>RFC4271</a>]) that have a
   tendency to use the same set(s) of ports on either endpoint, making
   the odds of correctly guessing the 4-tuple value much easier.  When
   an attacker is successful in guessing the 4-tuple value, one of three
   types of injection attacks may be waged against a long-lived
   connection.
   RST -  Where an attacker injects a RST segment hoping to cause the
      connection to be torn down.  "RST segment" here refers to a TCP
      segment with the RST bit set.
   SYN -  Where an attacker injects a SYN hoping to cause the receiver
      to believe the peer has restarted and therefore tear down the
      connection state.  "SYN segment" here refers to a TCP segment with
      SYN bit set.
   DATA -  Where an attacker tries to inject a DATA segment to corrupt
      the contents of the transmission.  "DATA segment" here refers to
      any TCP segment containing data.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/1.1.%20%20Applicability%20Statement"></a><a class="selflink" href="#section-1.1" name="section-1.1">1.1</a>.  Applicability Statement</span>

   This document talks about some known in-window attacks and suitable
   defenses against these.  The mitigations suggested in this document
   SHOULD be implemented in devices that regularly need to maintain TCP
   connections of the kind most vulnerable to the attacks described in
   this document.  Examples of such TCP connections are the ones that
   tend to be long-lived and where the connection endpoints can be
   determined, in cases where no auxiliary anti-spoofing protection
   mechanisms like TCP MD5 [<a href="rfc2385.html" title='"Protection of BGP Sessions via the TCP MD5 Signature Option"'>RFC2385</a>] can be deployed.  These mitigations
   MAY be implemented in other cases.








<span class="grey">Ramaiah, et al.              Standards Track                    [Page 3]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-4" id="page-4" name="page-4"> </a>
<span class="grey"><a href="rfc5961.html">RFC 5961</a>                      TCP Security                   August 2010</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/1.2.%20%20Basic%20Attack%20Methodology"></a><a class="selflink" href="#section-1.2" name="section-1.2">1.2</a>.  Basic Attack Methodology</span>

   Focusing upon the RST attack, we examine this attack in more detail
   to get an overview as to how it works and how this document addresses
   the issue.  For this attack, the goal is for the attacker to cause
   one of the two endpoints of the connection to incorrectly tear down
   the connection state, effectively aborting the connection.  One of
   the important things to note is that for the attack to succeed the
   RST needs to be in the valid receive window.  It also needs to be
   emphasized that the receive window is independent of the current
   congestion window of the TCP connection.  The attacker would try to
   forge many RST segments to try to cover the space of possible windows
   by putting out a packet in each potential window.  To do this, the
   attacker needs to have or guess several pieces of information namely:

   1) The 4-tuple value containing the IP address and TCP port number of
      both ends of the connection.  For one side (usually the server),
      guessing the port number is a trivial exercise.  The client side
      may or may not be easy for an attacker to guess depending on a
      number of factors, most notably the operating system and
      application involved.

   2) A sequence number that will be used in the RST.  This sequence
      number will be a starting point for a series of guesses to attempt
      to present a RST segment to a connection endpoint that would be
      acceptable to it.  Any random value may be used to guess the
      starting sequence number.

   3) The window size that the two endpoints are using.  This value does
      NOT have to be the exact window size since a smaller value used in
      lieu of the correct one will just cause the attacker to generate
      more segments before succeeding in his mischief.  Most modern
      operating systems have a default window size that usually is
      applied to most connections.  Some applications however may change
      the window size to better suit the needs of the application.  So
      often times the attacker, with a fair degree of certainty (knowing
      the application that is under attack), can come up with a very
      close approximation as to the actual window size in use on the
      connection.

   After assembling the above set of information, the attacker begins
   sending spoofed TCP segments with the RST bit set and a guessed TCP
   sequence number.  Each time a new RST segment is sent, the sequence
   number guess is incremented by the window size.  The feasibility of
   this methodology (without mitigations) was first shown in [<a href="#ref-SITW" title='"Slipping in the Window: TCP Reset attacks"'>SITW</a>].
   This is because [<a href="https://tools.ietf.org/html/rfc0793" title='"Transmission Control Protocol"'>RFC0793</a>] specifies that any RST within the current
   window is acceptable.  Also, [<a href="rfc4953.html" title='"Defending TCP Against Spoofing Attacks"'>RFC4953</a>] talks about the probability of
   a successful attack with varying window sizes and bandwidth.



<span class="grey">Ramaiah, et al.              Standards Track                    [Page 4]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-5" id="page-5" name="page-5"> </a>
<span class="grey"><a href="rfc5961.html">RFC 5961</a>                      TCP Security                   August 2010</span>


   A slight enhancement to TCP's segment processing rules can be made,
   which makes such an attack much more difficult to accomplish.  If the
   receiver examines the incoming RST segment and validates that the
   sequence number exactly matches the sequence number that is next
   expected, then such an attack becomes much more difficult than
   outlined in [<a href="#ref-SITW" title='"Slipping in the Window: TCP Reset attacks"'>SITW</a>] (i.e., the attacker would have to generate 1/2 the
   entire sequence space, on average).  This document will discuss the
   exact details of what needs to be changed within TCP's segment
   processing rules to mitigate all three types of attacks (RST, SYN,
   and DATA).

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/1.3.%20%20Attack%20probabilities"></a><a class="selflink" href="#section-1.3" name="section-1.3">1.3</a>.  Attack probabilities</span>

   Every application has control of a number of factors that drastically
   affect the probability of a successful spoofing attack.  These
   factors include such things as:

   Window Size  - Normally settable by the application but often times
      defaulting to 32,768 or 65,535 depending upon the operating system
      (see Figure 6 of [<a href="#ref-Medina05" title='"Measuring the Evolution of Transport Protocols in the Internet"'>Medina05</a>]).

   Server Port number  - This value is normally a fixed value so that a
      client will know where to connect to the peer.  Thus, this value
      normally provides no additional protection.

   Client Port number  - This value may be a random ephemeral value, if
      so, this makes a spoofing attack more difficult.  There are some
      clients, however, that for whatever reason either pick a fixed
      client port or have a very guessable one (due to the range of
      ephemeral ports available with their operating system or other
      application considerations) for such applications a spoofing
      attack becomes less difficult.

   For the purposes of the rest of this discussion we will assume that
   the attacker knows the 4-tuple values.  This assumption will help us
   focus on the effects of the window size versus the number of TCP
   packets an attacker must generate.  This assumption will rarely be
   true in the real Internet since at least the client port number will
   provide us with some amount of randomness (depending on the operating
   system).

   To successfully inject a spoofed packet (RST, SYN, or DATA), in the
   past, the entire sequence space (i.e., 2^32) was often considered
   available to make such an attack unlikely.  [<a href="#ref-SITW" title='"Slipping in the Window: TCP Reset attacks"'>SITW</a>] demonstrated that
   this assumption was incorrect and that instead of (1/2 * 2^32)
   packets (assuming a random distribution), (1/2 * (2^32/window))





<span class="grey">Ramaiah, et al.              Standards Track                    [Page 5]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-6" id="page-6" name="page-6"> </a>
<span class="grey"><a href="rfc5961.html">RFC 5961</a>                      TCP Security                   August 2010</span>


   packets are required.  In other words, the mean number of tries
   needed to inject a RST segment is (2^31/window) rather than the 2^31
   assumed before.

   Substituting numbers into this formula, we see that for a window size
   of 32,768, an average of 65,536 packets would need to be transmitted
   in order to "spoof" a TCP segment that would be acceptable to a TCP
   receiver.  A window size of 65,535 reduces this even further to
   32,768 packets.  At today's access bandwidths, an attack of that size
   is feasible.

   With rises in bandwidth to both the home and office, it can only be
   expected that the values for default window sizes will continue to
   rise in order to better take advantage of the newly available
   bandwidth.  It also needs to be noted that this attack can be
   performed in a distributed fashion in order potentially gain access
   to more bandwidth.

   As we can see from the above discussion this weakness lowers the bar
   quite considerably for likely attacks.  But there is one additional
   dependency that is the duration of the TCP connection.  A TCP
   connection that lasts only a few brief packets, as often is the case
   for web traffic, would not be subject to such an attack since the
   connection may not be established long enough for an attacker to
   generate enough traffic.  However, there is a set of applications,
   such as BGP [<a href="rfc4271.html" title='"A Border Gateway Protocol 4 (BGP-4)"'>RFC4271</a>], that is judged to be potentially most affected
   by this vulnerability.  BGP relies on a persistent TCP session
   between BGP peers.  Resetting the connection can result in term-
   medium unavailability due to the need to rebuild routing tables and
   route flapping; see [<a href="#ref-NISCC" title='"NISCC Vulnerability Advisory 236929 - Vulnerability Issues in TCP"'>NISCC</a>] for further details.

   For applications that can use the TCP MD5 option [<a href="rfc2385.html" title='"Protection of BGP Sessions via the TCP MD5 Signature Option"'>RFC2385</a>], such as
   BGP, that option makes the attacks described in this specification
   effectively impossible.  However, some applications or
   implementations may find that option expensive to implement.

   There are alternative protections against the threats that this
   document addresses.  For further details regarding the attacks and
   the existing techniques, please refer to [<a href="rfc4953.html" title='"Defending TCP Against Spoofing Attacks"'>RFC4953</a>].  It also needs to
   be emphasized that, as suggested in [<a href="#ref-TSVWG-PORT" title='"Transport Protocol Port Randomization Recommendations"'>TSVWG-PORT</a>] and [<a href="rfc1948.html" title='"Defending Against Sequence Number Attacks"'>RFC1948</a>], port
   randomization and initial sequence number (ISN) randomization would
   help improve the robustness of the TCP connection against off-path
   attacks.








<span class="grey">Ramaiah, et al.              Standards Track                    [Page 6]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-7" id="page-7" name="page-7"> </a>
<span class="grey"><a href="rfc5961.html">RFC 5961</a>                      TCP Security                   August 2010</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/2.%20%20Terminology"></a><a class="selflink" href="#section-2" name="section-2">2</a>.  Terminology</span>

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in [<a href="rfc2119.html" title='"Key words for use in RFCs to Indicate Requirement Levels"'>RFC2119</a>].  TCP
   terminology should be interpreted as described in [<a href="https://tools.ietf.org/html/rfc0793" title='"Transmission Control Protocol"'>RFC0793</a>].

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/3.%20%20Blind%20Reset%20Attack%20Using%20the%20RST%20Bit"></a><a class="selflink" href="#section-3" name="section-3">3</a>.  Blind Reset Attack Using the RST Bit</span>

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.1.%20%20Description%20of%20the%20Attack"></a><a class="selflink" href="#section-3.1" name="section-3.1">3.1</a>.  Description of the Attack</span>

   As described in the introduction, it is possible for an attacker to
   generate a RST segment that would be acceptable to a TCP receiver by
   guessing in-window sequence numbers.  In particular [<a href="https://tools.ietf.org/html/rfc0793" title='"Transmission Control Protocol"'>RFC0793</a>], page
   37, states the following:

      In all states except SYN-SENT, all reset (RST) segments are
      validated by checking their SEQ-fields [sequence numbers].  A
      reset is valid if its sequence number is in the window.  In the
      SYN-SENT state (a RST received in response to an initial SYN), the
      RST is acceptable if the ACK field acknowledges the SYN.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.2.%20%20Mitigation"></a><a class="selflink" href="#section-3.2" name="section-3.2">3.2</a>.  Mitigation</span>

   [<a id="ref-RFC0793" name="ref-RFC0793">RFC0793</a>] currently requires handling of a segment with the RST bit
   when in a synchronized state to be processed as follows:

   1) If the RST bit is set and the sequence number is outside the
      current receive window (SEG.SEQ &lt;= RCV.NXT || SEG.SEQ &gt; RCV.NXT+
      RCV.WND), silently drop the segment.

   2) If the RST bit is set and the sequence number is acceptable, i.e.,
      (RCV.NXT &lt;= SEG.SEQ &lt; RCV.NXT+RCV.WND), then reset the connection.

   Instead, implementations SHOULD implement the following steps in
   place of those specified in [<a href="https://tools.ietf.org/html/rfc0793" title='"Transmission Control Protocol"'>RFC0793</a>] (as listed above).

   1) If the RST bit is set and the sequence number is outside the
      current receive window, silently drop the segment.

   2) If the RST bit is set and the sequence number exactly matches the
      next expected sequence number (RCV.NXT), then TCP MUST reset the
      connection.








<span class="grey">Ramaiah, et al.              Standards Track                    [Page 7]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-8" id="page-8" name="page-8"> </a>
<span class="grey"><a href="rfc5961.html">RFC 5961</a>                      TCP Security                   August 2010</span>


   3) If the RST bit is set and the sequence number does not exactly
      match the next expected sequence value, yet is within the current
      receive window (RCV.NXT &lt; SEG.SEQ &lt; RCV.NXT+RCV.WND), TCP MUST
      send an acknowledgment (challenge ACK):

      &lt;SEQ=SND.NXT&gt;&lt;ACK=RCV.NXT&gt;&lt;CTL=ACK&gt;

      After sending the challenge ACK, TCP MUST drop the unacceptable
      segment and stop processing the incoming packet further.  Further
      segments destined to this connection will be processed as normal.

   The modified RST segment processing would thus become:

   In all states except SYN-SENT, all reset (RST) segments are validated
   by checking their SEQ-fields [sequence numbers].  A reset is valid if
   its sequence number exactly matches the next expected sequence
   number.  If the RST arrives and its sequence number field does NOT
   match the next expected sequence number but is within the window,
   then the receiver should generate an ACK.  In all other cases, where
   the SEQ-field does not match and is outside the window, the receiver
   MUST silently discard the segment.

   In the SYN-SENT state (a RST received in response to an initial SYN),
   the RST is acceptable if the ACK field acknowledges the SYN.  In all
   other cases the receiver MUST silently discard the segment.

   With the above slight change to the TCP state machine, it becomes
   much harder for an attacker to generate an acceptable reset segment.

   In cases where the remote peer did generate a RST, but it fails to
   meet the above criteria (the RST sequence number was within the
   window but NOT the exact expected sequence number), when the
   challenge ACK is sent back, it will no longer have the transmission
   control block (TCB) related to this connection and hence as per
   [<a href="https://tools.ietf.org/html/rfc0793" title='"Transmission Control Protocol"'>RFC0793</a>], the remote peer will send a second RST back.  The sequence
   number of the second RST is derived from the acknowledgment number of
   the incoming ACK.  This second RST, if it reaches the sender, will
   cause the connection to be aborted since the sequence number would
   now be an exact match.

   A valid RST received out of order would still generate a challenge
   ACK in response.  If this RST happens to be a genuine one, the other
   end would send an RST with an exact sequence number match that would
   cause the connection to be dropped.

   Note that the above mitigation may cause a non-amplification ACK
   exchange.  This concern is discussed in <a href="#section-10">Section 10</a>.




<span class="grey">Ramaiah, et al.              Standards Track                    [Page 8]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-9" id="page-9" name="page-9"> </a>
<span class="grey"><a href="rfc5961.html">RFC 5961</a>                      TCP Security                   August 2010</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/4.%20%20Blind%20Reset%20Attack%20Using%20the%20SYN%20Bit"></a><a class="selflink" href="#section-4" name="section-4">4</a>.  Blind Reset Attack Using the SYN Bit</span>

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.1.%20%20Description%20of%20the%20Attack"></a><a class="selflink" href="#section-4.1" name="section-4.1">4.1</a>.  Description of the Attack</span>

   The analysis of the reset attack using the RST bit highlights another
   possible avenue for a blind attacker using a similar set of sequence
   number guessing.  Instead of using the RST bit, an attacker can use
   the SYN bit with the exact same semantics to tear down a connection.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.2.%20%20Mitigation"></a><a class="selflink" href="#section-4.2" name="section-4.2">4.2</a>.  Mitigation</span>

   [<a id="ref-RFC0793" name="ref-RFC0793">RFC0793</a>] currently requires handling of a segment with the SYN bit
   set in the synchronized state to be as follows:

   1) If the SYN bit is set and the sequence number is outside the
      expected window, send an ACK back to the sender.

   2) If the SYN bit is set and the sequence number is acceptable, i.e.,
      (RCV.NXT &lt;= SEG.SEQ &lt; RCV.NXT+RCV.WND), then send a RST segment to
      the sender.

   Instead, the handling of the SYN in the synchronized state SHOULD be
   performed as follows:

   1) If the SYN bit is set, irrespective of the sequence number, TCP
      MUST send an ACK (also referred to as challenge ACK) to the remote
      peer:

      &lt;SEQ=SND.NXT&gt;&lt;ACK=RCV.NXT&gt;&lt;CTL=ACK&gt;

      After sending the acknowledgment, TCP MUST drop the unacceptable
      segment and stop processing further.

   By sending an ACK, the remote peer is challenged to confirm the loss
   of the previous connection and the request to start a new connection.
   A legitimate peer, after restart, would not have a TCB in the
   synchronized state.  Thus, when the ACK arrives, the peer should send
   a RST segment back with the sequence number derived from the ACK
   field that caused the RST.

   This RST will confirm that the remote peer has indeed closed the
   previous connection.  Upon receipt of a valid RST, the local TCP
   endpoint MUST terminate its connection.  The local TCP endpoint
   should then rely on SYN retransmission from the remote end to
   re-establish the connection.






<span class="grey">Ramaiah, et al.              Standards Track                    [Page 9]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-10" id="page-10" name="page-10"> </a>
<span class="grey"><a href="rfc5961.html">RFC 5961</a>                      TCP Security                   August 2010</span>


   A spoofed SYN, on the other hand, will then have generated an
   additional ACK that the peer will discard as a duplicate ACK and will
   not affect the established connection.

   Note that this mitigation does leave one corner case un-handled,
   which will prevent the reset of a connection when it should be reset
   (i.e., it is a non-spoofed SYN wherein a peer really did restart).
   This problem occurs when the restarting host chooses the exact same
   IP address and port number that it was using prior to its restart.
   By chance, the restarted host must also choose an initial sequence
   number of exactly (RCV.NXT - 1) of the remote peer that is still in
   the established state.  Such a case would cause the receiver to
   generate a "challenge" ACK as described above.  But since the ACK
   would be within the outgoing connections window, the inbound ACK
   would be acceptable, and the sender of the SYN will do nothing with
   the response ACK.  This sequence will continue as the SYN sender
   continually times out and retransmits the SYN until such time as the
   connection attempt fails.

   This corner case is a result of the [<a href="https://tools.ietf.org/html/rfc0793" title='"Transmission Control Protocol"'>RFC0793</a>] specification and is
   not introduced by these new requirements.

   Note that the above mitigation may cause a non-amplification ACK
   exchange.  This concern is discussed in <a href="#section-10">Section 10</a>.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/5.%20%20Blind%20Data%20Injection%20Attack"></a><a class="selflink" href="#section-5" name="section-5">5</a>.  Blind Data Injection Attack</span>

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.1.%20%20Description%20of%20the%20Attack"></a><a class="selflink" href="#section-5.1" name="section-5.1">5.1</a>.  Description of the Attack</span>

   A third type of attack is also highlighted by both the RST and SYN
   attacks.  It is also possible to inject data into a TCP connection by
   simply guessing a sequence number within the current receive window
   of the victim.  The ACK value of any data segment is considered valid
   as long as it does not acknowledge data ahead of the next segment to
   send.  In other words, an ACK value is acceptable if it is
   ((SND.UNA-(2^31-1)) &lt;= SEG.ACK &lt;= SND.NXT).  The (2^31 - 1) in the
   above inequality takes into account the fact that comparisons on TCP
   sequence and acknowledgment numbers is done using the modulo 32-bit
   arithmetic to accommodate the number wraparound.  This means that an
   attacker has to guess two ACK values with every guessed sequence
   number so that the chances of successfully injecting data into a
   connection are 1 in ( 1/2 (2^32 / RCV.WND) * 2).  Thus, the mean
   number of tries needed to inject data successfully is
   1/2 (2*2^32/RWND) = 2^32/RCV.WND.







<span class="grey">Ramaiah, et al.              Standards Track                   [Page 10]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-11" id="page-11" name="page-11"> </a>
<span class="grey"><a href="rfc5961.html">RFC 5961</a>                      TCP Security                   August 2010</span>


   When an attacker successfully injects data into a connection, the
   data will sit in the receiver's re-assembly queue until the peer
   sends enough data to bridge the gap between the RCV.NXT value and the
   injected data.  At that point, one of two things will occur:

   1) A packet war will ensue with the receiver indicating that it has
      received data up until RCV.NXT (which includes the attacker's
      data) and the sender sending an ACK with an acknowledgment number
      less than RCV.NXT.

   2) The sender will send enough data to the peer that will move
      RCV.NXT even further along past the injected data.

   Depending upon the TCP implementation in question and the TCP traffic
   characteristics at that time, data corruption may result.  In case
   (a), the connection will eventually be reset by one of the sides
   unless the sender produces more data that will transform the ACK war
   into case (b).  The reset will usually occur via User Time Out (UTO)
   (see <a href="rfc1122.html#section-4.2.3.5">section 4.2.3.5 of [RFC1122]</a>).

   Note that the protections illustrated in this section neither cause
   an ACK war nor prevent one from occurring if data is actually
   injected into a connection.  The ACK war is a product of the attack
   itself and cannot be prevented (other than by preventing the data
   from being injected).

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.2.%20%20Mitigation"></a><a class="selflink" href="#section-5.2" name="section-5.2">5.2</a>.  Mitigation</span>

   All TCP stacks MAY implement the following mitigation.  TCP stacks
   that implement this mitigation MUST add an additional input check to
   any incoming segment.  The ACK value is considered acceptable only if
   it is in the range of ((SND.UNA - MAX.SND.WND) &lt;= SEG.ACK &lt;=
   SND.NXT).  All incoming segments whose ACK value doesn't satisfy the
   above condition MUST be discarded and an ACK sent back.  It needs to
   be noted that <a href="rfc793.html">RFC 793</a> on page 72 (fifth check) says: "If the ACK is a
   duplicate (SEG.ACK &lt; SND.UNA), it can be ignored.  If the ACK
   acknowledges something not yet sent (SEG.ACK &gt; SND.NXT) then send an
   ACK, drop the segment, and return".  The "ignored" above implies that
   the processing of the incoming data segment continues, which means
   the ACK value is treated as acceptable.  This mitigation makes the
   ACK check more stringent since any ACK &lt; SND.UNA wouldn't be
   accepted, instead only ACKs that are in the range ((SND.UNA -
   MAX.SND.WND) &lt;= SEG.ACK &lt;= SND.NXT) get through.

   A new state variable MAX.SND.WND is defined as the largest window
   that the local sender has ever received from its peer.  This window
   may be scaled to a value larger than 65,535 bytes ([<a href="rfc1323.html" title='"TCP Extensions for High Performance"'>RFC1323</a>]).  This
   small check will reduce the vulnerability to an attacker guessing a



<span class="grey">Ramaiah, et al.              Standards Track                   [Page 11]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-12" id="page-12" name="page-12"> </a>
<span class="grey"><a href="rfc5961.html">RFC 5961</a>                      TCP Security                   August 2010</span>


   valid sequence number, since, not only one must guess the in-window
   sequence number, but also guess a proper ACK value within a scoped
   range.  This mitigation reduces, but does not eliminate, the ability
   to generate false segments.  It does however reduce the probability
   that invalid data will be injected.

   Implementations can also chose to hard code the MAX.SND.WND value to
   the maximum permissible window size, i.e., 65535 in the absence of
   window scaling.  In the presence of the window scaling option, the
   value becomes (MAX.SND.WND &lt;&lt; Snd.Wind.Scale).

   This mitigation also helps in improving robustness on accepting
   spoofed FIN segments (FIN attacks).  Among other things, this
   mitigation requires that the attacker also needs to get the
   acknowledgment number to fall in the range mentioned above in order
   to successfully spoof a FIN segment leading to the closure of the
   connection.  Thus, this mitigation greatly improves the robustness to
   spoofed FIN segments.

   Note that the above mitigation may cause a non-amplification ACK
   exchange.  This concern is discussed in <a href="#section-10">Section 10</a>.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/6.%20%20Suggested%20Mitigation%20Strengths"></a><a class="selflink" href="#section-6" name="section-6">6</a>.  Suggested Mitigation Strengths</span>

   As described in the above sections, recommendation levels for RST,
   SYN, and DATA are tagged as SHOULD, SHOULD, and MAY, respectively.
   The reason that DATA mitigation is tagged as MAY, even though it
   increased the TCP robustness in general is because, the DATA
   injection is perceived to be more difficult (twice as unlikely) when
   compared to RST and SYN counterparts.  However, it needs to be noted
   that all the suggested mitigations improve TCP's robustness in
   general and hence the choice of implementing some or all mitigations
   recommended in the document is purely left to the implementer.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/7.%20%20ACK%20Throttling"></a><a class="selflink" href="#section-7" name="section-7">7</a>.  ACK Throttling</span>

   In order to alleviate multiple RSTs/SYNs from triggering multiple
   challenge ACKs, an ACK throttling mechanism is suggested as follows:

   1) The system administrator can configure the number of challenge
      ACKs that can be sent out in a given interval.  For example, in
      any 5 second window, no more than 10 challenge ACKs should be
      sent.

   2) The values for both the time and number of ACKs SHOULD be tunable
      by the system administrator to accommodate different perceived
      levels of threat and/or system resources.




<span class="grey">Ramaiah, et al.              Standards Track                   [Page 12]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-13" id="page-13" name="page-13"> </a>
<span class="grey"><a href="rfc5961.html">RFC 5961</a>                      TCP Security                   August 2010</span>


   It should be noted that these numbers are empirical in nature and
   have been obtained from the RST throttling mechanisms existing in
   some implementations.  Also, note that no timer is needed to
   implement the above mechanism, instead a timestamp and a counter can
   be used.

   An implementation SHOULD include an ACK throttling mechanism to be
   conservative.  While we have not encountered a case where the lack of
   ACK throttling can be exploited, as a fail-safe mechanism we
   recommend its use.  An implementation may take an excessive number of
   invocations of the throttling mechanism as an indication that network
   conditions are unusual or hostile.

   An administrator who is more concerned about protecting his bandwidth
   and CPU utilization may set smaller ACK throttling values whereas an
   administrator who is more interested in faster cleanup of stale
   connections (i.e., concerned about excess TCP state) may decide to
   set a higher value thus allowing more RST's to be processed in any
   given time period.

   The time limit SHOULD be tunable to help timeout brute force attacks
   faster than a potential legitimate flood of RSTs.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/8.%20%20Backward%20Compatibility%20and%20Other%20Considerations"></a><a class="selflink" href="#section-8" name="section-8">8</a>.  Backward Compatibility and Other Considerations</span>

   All of the new required mitigation techniques in this document are
   totally compatible with existing ([<a href="https://tools.ietf.org/html/rfc0793" title='"Transmission Control Protocol"'>RFC0793</a>]) compliant TCP
   implementations as this document introduces no new assumptions or
   conditions.

   There is a corner scenario in the above mitigations that will require
   more than one round-trip time to successfully abort the connection as
   per the figure below.  This scenario is similar to the one in which
   the original RST was lost in the network.

















<span class="grey">Ramaiah, et al.              Standards Track                   [Page 13]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-14" id="page-14" name="page-14"> </a>
<span class="grey"><a href="rfc5961.html">RFC 5961</a>                      TCP Security                   August 2010</span>


          TCP A                                                 TCP B
   1.a. ESTAB        &lt;-- &lt;SEQ=300&gt;&lt;ACK=101&gt;&lt;CTL=ACK&gt;&lt;DATA&gt; &lt;--  ESTAB
     b. (delayed)    ... &lt;SEQ=400&gt;&lt;ACK=101&gt;&lt;CTL=ACK&gt;&lt;DATA&gt; &lt;--  ESTAB
     c. (in flight)  ... &lt;SEQ=500&gt;&lt;ACK=101&gt;&lt;CTL=RST&gt;       &lt;--  CLOSED
   2.   ESTAB        --&gt; &lt;SEQ=101&gt;&lt;ACK=400&gt;&lt;CTL=ACK&gt;       --&gt;  CLOSED
       (ACK for 1.a)
                     ... &lt;SEQ=400&gt;&lt;ACK=0&gt;&lt;CTL=RST&gt;         &lt;--  CLOSED
   3.   CHALLENGE    --&gt; &lt;SEQ=101&gt;&lt;ACK=400&gt;&lt;CTL=ACK&gt;       --&gt;  CLOSED
        (for 1.c)
                     ... &lt;SEQ=400&gt;&lt;ACK=0&gt;&lt;CTL=RST&gt;         &lt;--  RESPONSE
   4.a. ESTAB        &lt;-- &lt;SEQ=400&gt;&lt;ACK=101&gt;&lt;CTL=ACK&gt;&lt;DATA&gt; 1.b reaches A
     b. ESTAB        --&gt; &lt;SEQ=101&gt;&lt;ACK=500&gt;&lt;CTL=ACK&gt;
     c. (in flight)  ... &lt;SEQ=500&gt;&lt;ACK=0&gt;&lt;CTL=RST&gt;         &lt;--  CLOSED
   5.   RESPONSE arrives at A, but dropped since its outside of window.
   6.   ESTAB        &lt;-- &lt;SEQ=500&gt;&lt;ACK=0&gt;&lt;CTL=RST&gt;         4.c reaches A
   7.   CLOSED                                                   CLOSED

   For the mitigation to be maximally effective against the
   vulnerabilities discussed in this document, both ends of the TCP
   connection need to have the fix.  Although, having the mitigations at
   one end might prevent that end from being exposed to the attack, the
   connection is still vulnerable at the other end.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/9.%20%20Middlebox%20Considerations"></a><a class="selflink" href="#section-9" name="section-9">9</a>.  Middlebox Considerations</span>

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/9.1.%20%20Middlebox%20That%20Resend%20RSTs"></a><a class="selflink" href="#section-9.1" name="section-9.1">9.1</a>.  Middlebox That Resend RSTs</span>

   Consider a middlebox M-B tracking connections between two TCP end
   hosts E-A and E-C.  If E-C sends a RST with a sequence number that is
   within the window but not an exact match to reset the connection and
   M-B does not have the fix recommended in this document, it may clear
   the connection and forward the RST to E-A saving an incorrect
   sequence number.  If E-A does not have the fix, the connection would
   get cleared as required.  However, if E-A does have the required fix,
   it will send a challenge ACK to E-C.  M-B, being a middlebox, may
   intercept this ACK and resend the RST on behalf of E-C with the old
   sequence number.  This RST will, again, not be acceptable and may
   trigger a challenge ACK.

   The above situation may result in a RST/ACK war.  However, we believe
   that if such a case exists in the Internet, the middlebox is
   generating packets a conformant TCP endpoint would not generate.
   [<a href="https://tools.ietf.org/html/rfc0793" title='"Transmission Control Protocol"'>RFC0793</a>] dictates that the sequence number of a RST has to be
   derived from the acknowledgment number of the incoming ACK segment.
   It is outside the scope of this document to suggest mitigations to
   the ill-behaved middleboxes.





<span class="grey">Ramaiah, et al.              Standards Track                   [Page 14]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-15" id="page-15" name="page-15"> </a>
<span class="grey"><a href="rfc5961.html">RFC 5961</a>                      TCP Security                   August 2010</span>


   Consider a similar scenario where the RST from M-B to E-A gets lost,
   E-A will continue to hold the connection and E-A might send an ACK an
   arbitrary time later after the connection state was destroyed at M-B.
   For this case, M-B will have to cache the RST for an arbitrary amount
   of time until it is confirmed that the connection has been cleared at
   E-A.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/9.2.%20%20Middleboxes%20That%20Advance%20Sequence%20Numbers"></a><a class="selflink" href="#section-9.2" name="section-9.2">9.2</a>.  Middleboxes That Advance Sequence Numbers</span>

   Some middleboxes may compute RST sequence numbers at the higher end
   of the acceptable window.  The scenario is the same as the earlier
   case, but in this case instead of sending the cached RST, the
   middlebox (M-B) sends a RST that computes its sequence number as the
   sum of the acknowledgment field in the ACK and the window advertised
   by the ACK that was sent by E-A to challenge the RST as depicted
   below.  The difference in the sequence numbers between step 1 and 2
   below is due to data lost in the network.

      TCP A                                                   Middlebox

   1. ESTABLISHED  &lt;-- &lt;SEQ=500&gt;&lt;ACK=100&gt;&lt;CTL=RST&gt;          &lt;--  CLOSED

   2. ESTABLISHED  --&gt; &lt;SEQ=100&gt;&lt;ACK=300&gt;&lt;WND=500&gt;&lt;CTL=ACK&gt; --&gt;  CLOSED

   3. ESTABLISHED  &lt;-- &lt;SEQ=800&gt;&lt;ACK=100&gt;&lt;CTL=RST&gt;          &lt;--  CLOSED

   4. ESTABLISHED  --&gt; &lt;SEQ=100&gt;&lt;ACK=300&gt;&lt;WND=500&gt;&lt;CTL=ACK&gt; --&gt;  CLOSED

   5. ESTABLISHED  &lt;-- &lt;SEQ=800&gt;&lt;ACK=100&gt;&lt;CTL=RST&gt;          &lt;--  CLOSED

   Although the authors are not aware of an implementation that does the
   above, it could be mitigated by implementing the ACK throttling
   mechanism described earlier.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/9.3.%20%20Middleboxes%20That%20Drop%20the%20Challenge%20ACK"></a><a class="selflink" href="#section-9.3" name="section-9.3">9.3</a>.  Middleboxes That Drop the Challenge ACK</span>

   It also needs to be noted that, some middleboxes (Firewalls/NATs)
   that don't have the fix recommended in the document, may drop the
   challenge ACK.  This can happen because, the original RST segment
   that was in window had already cleared the flow state pertaining to
   the TCP connection in the middlebox.  In such cases, the end hosts
   that have implemented the RST mitigation described in this document,
   will have the TCP connection left open.  This is a corner case and
   can go away if the middlebox is conformant with the changes proposed
   in this document.






<span class="grey">Ramaiah, et al.              Standards Track                   [Page 15]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-16" id="page-16" name="page-16"> </a>
<span class="grey"><a href="rfc5961.html">RFC 5961</a>                      TCP Security                   August 2010</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/10.%20%20Security%20Considerations"></a><a class="selflink" href="#section-10" name="section-10">10</a>.  Security Considerations</span>

   These changes to the TCP state machine do NOT protect an
   implementation from on-path attacks.  It also needs to be emphasized
   that while mitigations within this document make it harder for off-
   path attackers to inject segments, it does NOT make it impossible.
   The only way to fully protect a TCP connection from both on- and off-
   path attacks is by using either IPsec Authentication Header (AH)
   [<a href="rfc4302.html" title='"IP Authentication Header"'>RFC4302</a>] or IPsec Encapsulating Security Payload (ESP) [<a href="rfc4303.html" title='"IP Encapsulating Security Payload (ESP)"'>RFC4303</a>].

   Implementers also should be aware that the attacks detailed in this
   specification are not the only attacks available to an off-path
   attacker and that the counter measures described herein are not a
   comprehensive defense against such attacks.

   In particular, administrators should be aware that forged ICMP
   messages provide off-path attackers the opportunity to disrupt
   connections or degrade service.  Such attacks may be subject to even
   less scrutiny than the TCP attacks addressed here, especially in
   stacks not tuned for hostile environments.  It is important to note
   that some ICMP messages, validated or not, are key to the proper
   function of TCP.  Those ICMP messages used to properly set the path
   maximum transmission unit are the most obvious example.  There are a
   variety of ways to choose which, if any, ICMP messages to trust in
   the presence of off-path attackers and choosing between them depends
   on the assumptions and guarantees developers and administrators can
   make about their network.  This specification does not attempt to do
   more than note this and related issues.  Unless implementers address
   spoofed ICMP messages [<a href="rfc5927.html" title='"ICMP Attacks against TCP"'>RFC5927</a>], the mitigations specified in this
   document may not provide the desired protection level.

   In any case, this RFC details only part of a complete strategy to
   prevent off-path attackers from disrupting services that use TCP.
   Administrators and implementers should consider the other attack
   vectors and determine appropriate mitigations in securing their
   systems.

   Another notable consideration is that a reflector attack is possible
   with the required RST/SYN mitigation techniques.  In this attack, an
   off-path attacker can cause a victim to send an ACK segment for each
   spoofed RST/SYN segment that lies within the current receive window
   of the victim.  It should be noted, however, that this does not cause
   any amplification since the attacker must generate a segment for each
   one that the victim will generate.







<span class="grey">Ramaiah, et al.              Standards Track                   [Page 16]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-17" id="page-17" name="page-17"> </a>
<span class="grey"><a href="rfc5961.html">RFC 5961</a>                      TCP Security                   August 2010</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/11.%20%20Contributors"></a><a class="selflink" href="#section-11" name="section-11">11</a>.  Contributors</span>

   Mitesh Dalal and Amol Khare of Cisco Systems came up with the
   solution for the RST/SYN attacks.  Anantha Ramaiah and Randall
   Stewart of Cisco Systems discovered the data injection vulnerability
   and together with Patrick Mahan and Peter Lei of Cisco Systems found
   solutions for the same.  Paul Goyette, Mark Baushke, Frank
   Kastenholz, Art Stine, and David Wang of Juniper Networks provided
   the insight that apart from RSTs, SYNs could also result in
   formidable attacks.  Shrirang Bage of Cisco Systems, Qing Li and
   Preety Puri of Wind River Systems, and Xiaodan Tang of QNX Software
   along with the folks above helped in ratifying and testing the
   interoperability of the suggested solutions.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/12.%20%20Acknowledgments"></a><a class="selflink" href="#section-12" name="section-12">12</a>.  Acknowledgments</span>

   Special thanks to Mark Allman, Ted Faber, Steve Bellovin, Vern
   Paxson, Allison Mankin, Sharad Ahlawat, Damir Rajnovic, John Wong,
   Joe Touch, Alfred Hoenes, Andre Oppermann, Fernando Gont, Sandra
   Murphy, Brian Carpenter, Cullen Jennings, and other members of the
   tcpm WG for suggestions and comments.  ACK throttling was introduced
   to this document by combining the suggestions from the tcpm working
   group.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/13.%20%20References"></a><a class="selflink" href="#section-13" name="section-13">13</a>.  References</span>

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/13.1.%20%20Normative%20References"></a><a class="selflink" href="#section-13.1" name="section-13.1">13.1</a>.  Normative References</span>

   [<a id="ref-RFC0793" name="ref-RFC0793">RFC0793</a>]     Postel, J., "Transmission Control Protocol", STD 7,
                 <a href="rfc793.html">RFC 793</a>, September 1981.

   [<a id="ref-RFC2119" name="ref-RFC2119">RFC2119</a>]     Bradner, S., "Key words for use in RFCs to Indicate
                 Requirement Levels", <a href="https://tools.ietf.org/html/bcp14">BCP 14</a>, <a href="rfc2119.html">RFC 2119</a>, March 1997.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/13.2.%20%20Informative%20References"></a><a class="selflink" href="#section-13.2" name="section-13.2">13.2</a>.  Informative References</span>

   [<a id="ref-Medina05" name="ref-Medina05">Medina05</a>]    Medina, A., Allman, M., and S. Floyd, "Measuring the
                 Evolution of Transport Protocols in the Internet", ACM
                 Computer Communication Review, 35(2), April 2005,
                 &lt;<a href="http://www.icir.org/mallman/papers/tcp-evo-ccr05.ps">http://www.icir.org/mallman/papers/tcp-evo-ccr05.ps</a>&gt;.

   [<a id="ref-NISCC" name="ref-NISCC">NISCC</a>]       NISCC, "NISCC Vulnerability Advisory 236929 -
                 Vulnerability Issues in TCP".

   [<a id="ref-RFC1122" name="ref-RFC1122">RFC1122</a>]     Braden, R., "Requirements for Internet Hosts -
                 Communication Layers", STD 3, <a href="rfc1122.html">RFC 1122</a>, October 1989.





<span class="grey">Ramaiah, et al.              Standards Track                   [Page 17]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-18" id="page-18" name="page-18"> </a>
<span class="grey"><a href="rfc5961.html">RFC 5961</a>                      TCP Security                   August 2010</span>


   [<a id="ref-RFC1323" name="ref-RFC1323">RFC1323</a>]     Jacobson, V., Braden, B., and D. Borman, "TCP
                 Extensions for High Performance", <a href="rfc1323.html">RFC 1323</a>, May 1992.

   [<a id="ref-RFC1948" name="ref-RFC1948">RFC1948</a>]     Bellovin, S., "Defending Against Sequence Number
                 Attacks", <a href="rfc1948.html">RFC 1948</a>, May 1996.

   [<a id="ref-RFC2385" name="ref-RFC2385">RFC2385</a>]     Heffernan, A., "Protection of BGP Sessions via the TCP
                 MD5 Signature Option", <a href="rfc2385.html">RFC 2385</a>, August 1998.

   [<a id="ref-RFC4271" name="ref-RFC4271">RFC4271</a>]     Rekhter, Y., Li, T., and S. Hares, "A Border Gateway
                 Protocol 4 (BGP-4)", <a href="rfc4271.html">RFC 4271</a>, January 2006.

   [<a id="ref-RFC4302" name="ref-RFC4302">RFC4302</a>]     Kent, S., "IP Authentication Header", <a href="rfc4302.html">RFC 4302</a>,
                 December 2005.

   [<a id="ref-RFC4303" name="ref-RFC4303">RFC4303</a>]     Kent, S., "IP Encapsulating Security Payload (ESP)",
                 <a href="rfc4303.html">RFC 4303</a>, December 2005.

   [<a id="ref-RFC4953" name="ref-RFC4953">RFC4953</a>]     Touch, J., "Defending TCP Against Spoofing Attacks",
                 <a href="rfc4953.html">RFC 4953</a>, July 2007.

   [<a id="ref-RFC5927" name="ref-RFC5927">RFC5927</a>]     Gont, F., "ICMP Attacks against TCP", <a href="rfc5927.html">RFC 5927</a>,
                 July 2010.

   [<a id="ref-SITW" name="ref-SITW">SITW</a>]        Watson, P., "Slipping in the Window: TCP Reset
                 attacks", Presentation at 2004 CanSecWest,
                 &lt;<a href="http://cansecwest.com/csw04archive.html">http://cansecwest.com/csw04archive.html</a>&gt;.

   [<a id="ref-TSVWG-PORT" name="ref-TSVWG-PORT">TSVWG-PORT</a>]  Larsen, M. and F. Gont, "Transport Protocol Port
                 Randomization Recommendations", Work in Progress,
                 August 2010.




















<span class="grey">Ramaiah, et al.              Standards Track                   [Page 18]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-19" id="page-19" name="page-19"> </a>
<span class="grey"><a href="rfc5961.html">RFC 5961</a>                      TCP Security                   August 2010</span>


Authors' Addresses

   Anantha Ramaiah
   Cisco Systems
   170 Tasman Drive
   San Jose, CA  95134
   USA

   Phone: +1 (408) 525-6486
   EMail: ananth@cisco.com


   Randall R. Stewart
   Huawei
   148 Crystal Cove Ct
   Chapin, SC  29036
   USA

   Phone: +1 (803) 345-0369
   EMail: rstewart@huawei.com


   Mitesh Dalal
   Cisco Systems
   170 Tasman Drive
   San Jose, CA  95134
   USA

   Phone: +1 (408) 853-5257
   EMail: mdalal@cisco.com





















Ramaiah, et al.              Standards Track                   [Page 19]

</pre><br/>
    <span class="noprint"><small><small>Html markup produced by rfcmarkup 1.126, available from
      <a href="https://tools.ietf.org/tools/rfcmarkup/">https://tools.ietf.org/tools/rfcmarkup/</a>
    </small></small></span>
  </div>




</body><!-- Mirrored from tools.ietf.org/html/rfc5961 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 06 Mar 2018 23:18:32 GMT --></html>