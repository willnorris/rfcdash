<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

<!-- Mirrored from tools.ietf.org/html/rfc8075 by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 28 Jul 2019 12:20:01 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head profile="http://dublincore.org/documents/2008/08/04/dc-html/">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="robots" content="index,follow" />
    <meta name="creator" content="rfcmarkup version 1.129c" />
    <link rel="schema.DC" href="http://purl.org/dc/elements/1.1/" />
<meta name="DC.Relation.Replaces" content="draft-castellani-core-http-mapping" />
<meta name="DC.Identifier" content="urn:ietf:rfc:8075" />
<meta name="DC.Date.Issued" content="February, 2017" />
<meta name="DC.Creator" content="Dijk, Esko" />
<meta name="DC.Creator" content="Rahman, Akbar" />
<meta name="DC.Creator" content="Fossati, Thomas" />
<meta name="DC.Creator" content="Loreto, Salvatore" />
<meta name="DC.Creator" content="Castellani, Angelo" />
<meta name="DC.Description.Abstract" content="This document provides reference information for implementing a cross-
protocol network proxy that performs translation from the HTTP
protocol to the Constrained Application Protocol (CoAP). This will
enable an HTTP client to access resources on a CoAP server through the
proxy. This document describes how an HTTP request is mapped to a CoAP
request and how a CoAP response is mapped back to an HTTP response.
This includes guidelines for status code, URI, and media type
mappings, as well as additional interworking advice." />
<meta name="DC.Title" content="Guidelines for Mapping Implementations: HTTP to the Constrained Application Protocol (CoAP)" />

    <link rel="icon" href="https://tools.ietf.org/images/rfc.png" type="image/png" />
    <link rel="shortcut icon" href="https://tools.ietf.org/images/rfc.png" type="image/png" />
    <title>RFC 8075 - Guidelines for Mapping Implementations: HTTP to the Constrained Application Protocol (CoAP)</title>
    
    
    <style type="text/css">
	@media only screen 
	  and (min-width: 992px)
	  and (max-width: 1199px) {
	    body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 768px)
	  and (max-width: 991px) {
            body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 480px)
	  and (max-width: 767px) {
            body { font-size: 11pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (max-width: 479px) {
            body { font-size: 8pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-device-width : 375px) 
	  and (max-device-width : 667px) {
            body { font-size: 9.5pt; }
            div.content { width: 96ex; margin: 0; }
        }
	@media only screen 
	  and (min-device-width: 1200px) {
            body { font-size: 10pt; margin: 0 4em; }
            div.content { width: 96ex; margin: 0; }
        }
        h1, h2, h3, h4, h5, h6, .h1, .h2, .h3, .h4, .h5, .h6 {
	    font-weight: bold;
            line-height: 0pt;
            display: inline;
            white-space: pre;
            font-family: monospace;
            font-size: 1em;
	    font-weight: bold;
        }
        pre {
            font-size: 1em;
            margin-top: 0px;
            margin-bottom: 0px;
        }
	.pre {
	    white-space: pre;
	    font-family: monospace;
	}
	.header{
	    font-weight: bold;
	}
        .newpage {
            page-break-before: always;
        }
        .invisible {
            text-decoration: none;
            color: white;
        }
        a.selflink {
          color: black;
          text-decoration: none;
        }
        @media print {
            body {
                font-family: monospace;
                font-size: 10.5pt;
            }
            h1, h2, h3, h4, h5, h6 {
                font-size: 1em;
            }
        
            a:link, a:visited {
                color: inherit;
                text-decoration: none;
            }
            .noprint {
                display: none;
            }
        }
	@media screen {
	    .grey, .grey a:link, .grey a:visited {
		color: #777;
	    }
            .docinfo {
                background-color: #EEE;
            }
            .top {
                border-top: 7px solid #EEE;
            }
            .bgwhite  { background-color: white; }
            .bgred    { background-color: #F44; }
            .bggrey   { background-color: #666; }
            .bgbrown  { background-color: #840; }            
            .bgorange { background-color: #FA0; }
            .bgyellow { background-color: #EE0; }
            .bgmagenta{ background-color: #F4F; }
            .bgblue   { background-color: #66F; }
            .bgcyan   { background-color: #4DD; }
            .bggreen  { background-color: #4F4; }

            .legend   { font-size: 90%; }
            .cplate   { font-size: 70%; border: solid grey 1px; }
	}
    </style>
    <!--[if IE]>
    <style>
    body {
       font-size: 13px;
       margin: 10px 10px;
    }
    </style>
    <![endif]-->

    <script type="text/javascript"><!--
    function addHeaderTags() {
	var spans = document.getElementsByTagName("span");
	for (var i=0; i < spans.length; i++) {
	    var elem = spans[i];
	    if (elem) {
		var level = elem.getAttribute("class");
                if (level == "h1" || level == "h2" || level == "h3" || level == "h4" || level == "h5" || level == "h6") {
                    elem.innerHTML = "<"+level+">"+elem.innerHTML+"</"+level+">";		
                }
	    }
	}
    }
    var legend_html = "Colour legend:<br />      <table>         <tr><td>Unknown:</td>                   <td><span class='cplate bgwhite'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft:</td>                     <td><span class='cplate bgred'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Informational:</td>             <td><span class='cplate bgorange'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Experimental:</td>              <td><span class='cplate bgyellow'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Best Common Practice:</td>      <td><span class='cplate bgmagenta'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Proposed Standard:</td>         <td><span class='cplate bgblue'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft Standard (old designation):</td> <td><span class='cplate bgcyan'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Internet Standard:</td>         <td><span class='cplate bggreen'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Historic:</td>                  <td><span class='cplate bggrey'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Obsolete:</td>                  <td><span class='cplate bgbrown'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>     </table>";
    function showElem(id) {
        var elem = document.getElementById(id);
        elem.innerHTML = eval(id+"_html");
        elem.style.visibility='visible';
    }
    function hideElem(id) {
        var elem = document.getElementById(id);
        elem.style.visibility='hidden';        
        elem.innerHTML = "";
    }
    // -->
    </script>
</head>
<body onload="addHeaderTags()">
  <div class="content">
   <div style="height: 13px;">
      <div onmouseover="this.style.cursor='pointer';"
         onclick="showElem('legend');"
         onmouseout="hideElem('legend')"
	 style="height: 6px; position: absolute;"
         class="pre noprint docinfo bgblue"
         title="Click for colour legend." >                                                                        </div>
      <div id="legend"
           class="docinfo noprint pre legend"
           style="position:absolute; top: 4px; left: 4ex; visibility:hidden; background-color: white; padding: 4px 9px 5px 7px; border: solid #345 1px; "
           onmouseover="showElem('legend');"
           onmouseout="hideElem('legend');">
      </div>
   </div>
<span class="pre noprint docinfo top">[<a href="index.html" title="Document search and retrieval page">Docs</a>] [<a href="https://tools.ietf.org/rfc/rfc8075.txt" title="Plaintext version of this document">txt</a>|<a href="https://tools.ietf.org/pdf/rfc8075" title="PDF version of this document">pdf</a>] [<a href="https://tools.ietf.org/html/draft-ietf-core-http-mapping" title="draft-ietf-core-http-mapping">draft-ietf-core...</a>] [<a href='https://datatracker.ietf.org/doc/rfc8075' title='IESG Datatracker information for this document'>Tracker</a>] [<a href="https://tools.ietf.org/rfcdiff?difftype=--hwdiff&amp;url2=rfc8075" title="Inline diff (wdiff)">Diff1</a>] [<a href="https://tools.ietf.org/rfcdiff?url2=rfc8075" title="Side-by-side diff">Diff2</a>]         </span><br />
<span class="pre noprint docinfo">                                                                        </span><br />
<span class="pre noprint docinfo">                                                       PROPOSED STANDARD</span><br />
<span class="pre noprint docinfo">                                                                        </span><br />
<pre>
Internet Engineering Task Force (IETF)                     A. Castellani
Request for Comments: 8075                          University of Padova
Category: Standards Track                                      S. Loreto
ISSN: 2070-1721                                                 Ericsson
                                                               A. Rahman
                                        InterDigital Communications, LLC
                                                              T. Fossati
                                                                   Nokia
                                                                 E. Dijk
                                                        Philips Lighting
                                                           February 2017


                <span class="h1">Guidelines for Mapping Implementations:</span>
          <span class="h1">HTTP to the Constrained Application Protocol (CoAP)</span>

Abstract

   This document provides reference information for implementing a
   cross-protocol network proxy that performs translation from the HTTP
   protocol to the Constrained Application Protocol (CoAP).  This will
   enable an HTTP client to access resources on a CoAP server through
   the proxy.  This document describes how an HTTP request is mapped to
   a CoAP request and how a CoAP response is mapped back to an HTTP
   response.  This includes guidelines for status code, URI, and media
   type mappings, as well as additional interworking advice.

Status of This Memo

   This is an Internet Standards Track document.

   This document is a product of the Internet Engineering Task Force
   (IETF).  It represents the consensus of the IETF community.  It has
   received public review and has been approved for publication by the
   Internet Engineering Steering Group (IESG).  Further information on
   Internet Standards is available in <a href="rfc7841.html#section-2">Section&nbsp;2 of RFC 7841</a>.

   Information about the current status of this document, any errata,
   and how to provide feedback on it may be obtained at
   <a href="http://www.rfc-editor.org/info/rfc8075">http://www.rfc-editor.org/info/rfc8075</a>.











<span class="grey">Castellani, et al.           Standards Track                    [Page 1]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-2" id="page-2" href="#page-2" class="invisible"> </a>
<span class="grey"><a href="rfc8075.html">RFC 8075</a>                  HTTP-to-CoAP Mapping             February 2017</span>


Copyright Notice

   Copyright (c) 2017 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to <a href="https://tools.ietf.org/html/bcp78">BCP 78</a> and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (<a href="http://trustee.ietf.org/license-info">http://trustee.ietf.org/license-info</a>) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.





































<span class="grey">Castellani, et al.           Standards Track                    [Page 2]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-3" id="page-3" href="#page-3" class="invisible"> </a>
<span class="grey"><a href="rfc8075.html">RFC 8075</a>                  HTTP-to-CoAP Mapping             February 2017</span>


Table of Contents

   <a href="#section-1">1</a>.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   <a href="#page-4">4</a>
   <a href="#section-2">2</a>.  Terminology . . . . . . . . . . . . . . . . . . . . . . . . .   <a href="#page-5">5</a>
   <a href="#section-3">3</a>.  HTTP-to-CoAP Proxy  . . . . . . . . . . . . . . . . . . . . .   <a href="#page-6">6</a>
   <a href="#section-4">4</a>.  Use Cases . . . . . . . . . . . . . . . . . . . . . . . . . .   <a href="#page-7">7</a>
   <a href="#section-5">5</a>.  URI Mapping . . . . . . . . . . . . . . . . . . . . . . . . .   <a href="#page-7">7</a>
     <a href="#section-5.1">5.1</a>.  URI Terminology . . . . . . . . . . . . . . . . . . . . .   <a href="#page-8">8</a>
     <a href="#section-5.2">5.2</a>.  Null Mapping  . . . . . . . . . . . . . . . . . . . . . .   <a href="#page-9">9</a>
     <a href="#section-5.3">5.3</a>.  Default Mapping . . . . . . . . . . . . . . . . . . . . .   <a href="#page-9">9</a>
       <a href="#section-5.3.1">5.3.1</a>.  Optional Scheme Omission  . . . . . . . . . . . . . .   <a href="#page-9">9</a>
       <a href="#section-5.3.2">5.3.2</a>.  Encoding Caveats  . . . . . . . . . . . . . . . . . .  <a href="#page-10">10</a>
     <a href="#section-5.4">5.4</a>.  URI Mapping Template  . . . . . . . . . . . . . . . . . .  <a href="#page-10">10</a>
       <a href="#section-5.4.1">5.4.1</a>.  Simple Form . . . . . . . . . . . . . . . . . . . . .  <a href="#page-10">10</a>
       <a href="#section-5.4.2">5.4.2</a>.  Enhanced Form . . . . . . . . . . . . . . . . . . . .  <a href="#page-12">12</a>
     <a href="#section-5.5">5.5</a>.  Discovery . . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-13">13</a>
       <a href="#section-5.5.1">5.5.1</a>.  Examples  . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-14">14</a>
   <a href="#section-6">6</a>.  Media Type Mapping  . . . . . . . . . . . . . . . . . . . . .  <a href="#page-15">15</a>
     <a href="#section-6.1">6.1</a>.  Overview  . . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-15">15</a>
     <a href="#section-6.2">6.2</a>.  'application/coap-payload' Media Type . . . . . . . . . .  <a href="#page-16">16</a>
     <a href="#section-6.3">6.3</a>.  Loose Media Type Mapping  . . . . . . . . . . . . . . . .  <a href="#page-17">17</a>
     <a href="#section-6.4">6.4</a>.  Media Type to Content-Format Mapping Algorithm  . . . . .  <a href="#page-18">18</a>
     <a href="#section-6.5">6.5</a>.  Content Transcoding . . . . . . . . . . . . . . . . . . .  <a href="#page-19">19</a>
       <a href="#section-6.5.1">6.5.1</a>.  General . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-19">19</a>
       <a href="#section-6.5.2">6.5.2</a>.  CoRE Link Format  . . . . . . . . . . . . . . . . . .  <a href="#page-20">20</a>
     <a href="#section-6.6">6.6</a>.  Diagnostic Payloads . . . . . . . . . . . . . . . . . . .  <a href="#page-20">20</a>
   <a href="#section-7">7</a>.  Response Code Mapping . . . . . . . . . . . . . . . . . . . .  <a href="#page-21">21</a>
   <a href="#section-8">8</a>.  Additional Mapping Guidelines . . . . . . . . . . . . . . . .  <a href="#page-23">23</a>
     <a href="#section-8.1">8.1</a>.  Caching and Congestion Control  . . . . . . . . . . . . .  <a href="#page-23">23</a>
     <a href="#section-8.2">8.2</a>.  Cache Refresh via Observe . . . . . . . . . . . . . . . .  <a href="#page-24">24</a>
     <a href="#section-8.3">8.3</a>.  Use of CoAP Block-Wise Transfer . . . . . . . . . . . . .  <a href="#page-24">24</a>
     <a href="#section-8.4">8.4</a>.  CoAP Multicast  . . . . . . . . . . . . . . . . . . . . .  <a href="#page-25">25</a>
     <a href="#section-8.5">8.5</a>.  Timeouts  . . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-26">26</a>
   <a href="#section-9">9</a>.  IANA Considerations . . . . . . . . . . . . . . . . . . . . .  <a href="#page-26">26</a>
     <a href="#section-9.1">9.1</a>.  New 'core.hc' Resource Type . . . . . . . . . . . . . . .  <a href="#page-26">26</a>
     <a href="#section-9.2">9.2</a>.  New 'coap-payload' Internet Media Type  . . . . . . . . .  <a href="#page-26">26</a>
   <a href="#section-10">10</a>. Security Considerations . . . . . . . . . . . . . . . . . . .  <a href="#page-28">28</a>
     <a href="#section-10.1">10.1</a>.  Multicast  . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-29">29</a>
     <a href="#section-10.2">10.2</a>.  Traffic Overflow . . . . . . . . . . . . . . . . . . . .  <a href="#page-29">29</a>
     <a href="#section-10.3">10.3</a>.  Handling Secured Exchanges . . . . . . . . . . . . . . .  <a href="#page-30">30</a>
     <a href="#section-10.4">10.4</a>.  URI Mapping  . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-30">30</a>
   <a href="#section-11">11</a>. References  . . . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-31">31</a>
     <a href="#section-11.1">11.1</a>.  Normative References . . . . . . . . . . . . . . . . . .  <a href="#page-31">31</a>
     <a href="#section-11.2">11.2</a>.  Informative References . . . . . . . . . . . . . . . . .  <a href="#page-32">32</a>
   <a href="#appendix-A">Appendix A</a>.  Media Type Mapping Source Code . . . . . . . . . . .  <a href="#page-35">35</a>
   Acknowledgments . . . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-39">39</a>
   Authors' Addresses  . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-40">40</a>




<span class="grey">Castellani, et al.           Standards Track                    [Page 3]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-4" id="page-4" href="#page-4" class="invisible"> </a>
<span class="grey"><a href="rfc8075.html">RFC 8075</a>                  HTTP-to-CoAP Mapping             February 2017</span>


<span class="h2"><a class="selflink" name="section-1" href="#section-1">1</a>.  Introduction</span>

   The Constrained Application Protocol (CoAP) [<a href="rfc7252.html" title="&quot;The Constrained Application Protocol (CoAP)&quot;">RFC7252</a>] has been
   designed with a twofold aim: it's an application protocol specialized
   for constrained environments and it's easily used in architectures
   based on Representational State Transfer (REST) [<a href="#ref-Fielding" title="&quot;Architectural Styles and the Design of Network-based Software Architectures&quot;">Fielding</a>], such as
   the web.  The latter goal has led to defining CoAP to easily
   interoperate with HTTP [<a href="rfc7230.html" title="&quot;Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing&quot;">RFC7230</a>] through an intermediary proxy that
   performs cross-protocol conversion.

   <a href="rfc7252.html#section-10">Section&nbsp;10 of [RFC7252]</a> describes the fundamentals of the
   CoAP-to-HTTP and the HTTP-to-CoAP cross-protocol mapping process.
   However, [<a href="rfc7252.html" title="&quot;The Constrained Application Protocol (CoAP)&quot;">RFC7252</a>] focuses on the basic mapping of request methods
   and simple response code mapping between HTTP and CoAP, while leaving
   many details of the cross-protocol proxy for future definition.
   Therefore, a primary goal of this document is to define a consistent
   set of guidelines that an HTTP-to-CoAP proxy implementation should
   adhere to.  The key benefit to adhering to such guidelines is to
   reduce variation between proxy implementations, thereby increasing
   interoperability between an HTTP client and a CoAP server independent
   of the proxy that implements the cross-protocol mapping.  (For
   example, a proxy conforming to these guidelines made by vendor A can
   be easily replaced by a proxy from vendor B that also conforms to the
   guidelines without breaking API semantics.)

   This document describes HTTP mappings that apply to protocol elements
   defined in the base CoAP specification [<a href="rfc7252.html" title="&quot;The Constrained Application Protocol (CoAP)&quot;">RFC7252</a>] and in the CoAP
   block-wise transfer specification [<a href="rfc7959.html" title="&quot;Block-Wise Transfers in the Constrained Application Protocol (CoAP)&quot;">RFC7959</a>].  It is up to CoAP
   protocol extensions (new methods, response codes, options, content-
   formats) to describe their own HTTP mappings, if applicable.

   The rest of this document is organized as follows:

   o  <a href="#section-2">Section 2</a> defines proxy terminology;

   o  <a href="#section-3">Section 3</a> introduces the HTTP-to-CoAP proxy;

   o  <a href="#section-4">Section 4</a> lists use cases in which HTTP clients need to contact
      CoAP servers;

   o  <a href="#section-5">Section 5</a> introduces a null, default, and advanced HTTP-to-CoAP
      URI mapping syntax;

   o  <a href="#section-6">Section 6</a> describes how to map HTTP media types to CoAP content-
      formats, and vice versa;

   o  <a href="#section-7">Section 7</a> describes how to map CoAP responses to HTTP responses;




<span class="grey">Castellani, et al.           Standards Track                    [Page 4]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-5" id="page-5" href="#page-5" class="invisible"> </a>
<span class="grey"><a href="rfc8075.html">RFC 8075</a>                  HTTP-to-CoAP Mapping             February 2017</span>


   o  <a href="#section-8">Section 8</a> describes additional mapping guidelines related to
      caching, congestion, multicast, timeouts, etc.; and

   o  <a href="#section-10">Section 10</a> discusses the possible security impact of HTTP-to-CoAP
      protocol mapping.

<span class="h2"><a class="selflink" name="section-2" href="#section-2">2</a>.  Terminology</span>

   The keywords "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
   "OPTIONAL" in this document are to be interpreted as described in
   [<a href="rfc2119.html" title="&quot;Key words for use in RFCs to Indicate Requirement Levels&quot;">RFC2119</a>].

   This specification requires readers to be familiar with the
   vocabulary and concepts discussed in [<a href="rfc7228.html" title="&quot;Terminology for Constrained-Node Networks&quot;">RFC7228</a>], in particular, the
   terms "constrained nodes" and "constrained networks".  Readers must
   also be familiar with all of the terminology of the normative
   references listed in this document, in particular [<a href="rfc7252.html" title="&quot;The Constrained Application Protocol (CoAP)&quot;">RFC7252</a>] (CoAP)
   and [<a href="rfc7230.html" title="&quot;Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing&quot;">RFC7230</a>] (HTTP).  In addition, this specification makes use of
   the following terms:

   HC Proxy
       A proxy performing a cross-protocol mapping, in the context of
       this document an HTTP-to-CoAP (HC) mapping.  Specifically, the HC
       Proxy acts as an HTTP server and a CoAP client.  The HC Proxy can
       take on the role of a forward, reverse, or interception Proxy.

   Application Level Gateway (ALG)
       An application-specific translation agent that allows an
       application on a host in one address realm to connect to its
       counterpart running on a host in a different realm transparently.
       See <a href="rfc2663.html#section-2.9">Section&nbsp;2.9 of [RFC2663]</a>.

   forward-proxy
       A message-forwarding agent that is selected by the HTTP client,
       usually via local configuration rules, to receive requests for
       some type(s) of absolute URI and to attempt to satisfy those
       requests via translation to the protocol indicated by the
       absolute URI.  The user agent decides (is willing) to use the
       proxy as the forwarding/dereferencing agent for a predefined
       subset of the URI space.  In [<a href="rfc7230.html" title="&quot;Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing&quot;">RFC7230</a>], this is called a "proxy".
       [<a href="rfc7252.html" title="&quot;The Constrained Application Protocol (CoAP)&quot;">RFC7252</a>] defines forward-proxy similarly.

   reverse-proxy
       As in [<a href="rfc7230.html" title="&quot;Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing&quot;">RFC7230</a>], a receiving agent that acts as a layer above
       some other server(s) and translates the received requests to the
       underlying server's protocol.  A reverse-proxy behaves as an
       origin (HTTP) server on its connection from the HTTP client.  The



<span class="grey">Castellani, et al.           Standards Track                    [Page 5]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-6" id="page-6" href="#page-6" class="invisible"> </a>
<span class="grey"><a href="rfc8075.html">RFC 8075</a>                  HTTP-to-CoAP Mapping             February 2017</span>


       HTTP client uses the "origin-form" (<a href="rfc7230.html#section-5.3.1">Section&nbsp;5.3.1 of [RFC7230]</a>)
       as a request-target URI.  (Note that a reverse-proxy appears to
       an HTTP client as an origin server while a forward-proxy does
       not.  So, when communicating with a reverse-proxy, a client may
       be unaware it is communicating with a proxy at all.)

   interception proxy
       As in [<a href="rfc3040.html" title="&quot;Internet Web Replication and Caching Taxonomy&quot;">RFC3040</a>], a proxy that receives inbound HTTP traffic flows
       through the process of traffic redirection, transparent to the
       HTTP client.

<span class="h2"><a class="selflink" name="section-3" href="#section-3">3</a>.  HTTP-to-CoAP Proxy</span>

   An HC Proxy is accessed by an HTTP client that needs to fetch a
   resource on a CoAP server.  The HC Proxy handles the HTTP request by
   mapping it to the equivalent CoAP request, which is then forwarded to
   the appropriate CoAP server.  The received CoAP response is then
   mapped to an appropriate HTTP response and finally sent back to the
   originating HTTP client.

   <a href="rfc7252.html#section-10.2">Section&nbsp;10.2 of [RFC7252]</a> defines basic normative requirements on
   HTTP-to-CoAP mapping.  This document provides additional details and
   guidelines for the implementation of an HC Proxy.

                                               Constrained Network
                                              .-------------------.
                                             /      .------.       \
                                            /       | CoAP |        \
                                           /        |server|         \
                                          ||        '------'         ||
                                          ||                         ||
     .--------.  HTTP Request   .------------.  CoAP Req  .------.   ||
     |  HTTP  |----------------&gt;|HTTP-to-CoAP|-----------&gt;| CoAP |   ||
     | Client |&lt;----------------|   Proxy    |&lt;-----------|server|   ||
     '--------'  HTTP Response  '------------'  CoAP Resp '------'   ||
                                          ||                         ||
                                          ||   .------.              ||
                                          ||   | CoAP |              ||
                                           \   |server|  .------.    /
                                            \  '------'  | CoAP |   /
                                             \           |server|  /
                                              \          '------' /
                                               '-----------------'

             Figure 1: HTTP-To-CoAP Proxy Deployment Scenario






<span class="grey">Castellani, et al.           Standards Track                    [Page 6]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-7" id="page-7" href="#page-7" class="invisible"> </a>
<span class="grey"><a href="rfc8075.html">RFC 8075</a>                  HTTP-to-CoAP Mapping             February 2017</span>


   Figure 1 illustrates an example deployment scenario.  There, an HC
   Proxy is located at the boundary of the constrained network domain
   and acts as an ALG that allows only a very specific type of traffic
   (i.e., authorized inbound HTTP requests and their associated outbound
   CoAP responses) to pass through.  All other kinds of traffic are
   segregated within the respective network segments.

<span class="h2"><a class="selflink" name="section-4" href="#section-4">4</a>.  Use Cases</span>

   To illustrate a few situations in which HTTP-to-CoAP protocol
   translation may be used, three use cases are described below.

   1.  Legacy building control application without CoAP: A building
       control application that uses HTTP but not CoAP can check the
       status of CoAP sensors and/or control actuators via an HC Proxy.

   2.  Making sensor data available to third parties on the web: For
       demonstration or public interest purposes, an HC Proxy may be
       configured to expose the contents of a CoAP sensor to the world
       via the web (HTTP and/or HTTPS).  Some sensors may only accept
       secure 'coaps' requests; therefore, the proxy is configured to
       translate requests to those devices accordingly.  The HC Proxy is
       furthermore configured to only pass through GET requests in order
       to protect the constrained network.

   3.  Smartphone and home sensor: A smartphone can access directly a
       CoAP home sensor using a mutually authenticated 'https' request,
       provided its home router runs an HC Proxy and is configured with
       the appropriate certificate.  An HTML5 [<a href="#ref-W3C.REC-html5-20141028" title="&quot;HTML5&quot;">W3C.REC-html5-20141028</a>]
       application on the smartphone can provide a friendly UI using the
       standard (HTTP) networking functions of HTML5.

   A key point in the above use cases is the expected nature of the URI
   to be used by the HTTP client initiating the HTTP request to the HC
   Proxy.  Specifically, in use case #1, there will be no information
   related to 'coap' or 'coaps' embedded in the HTTP URI as it is a
   legacy HTTP client sending the request.  Use case #2 is also expected
   to be similar.  In contrast, in use case #3, it is likely that the
   HTTP client will specifically embed information related to 'coap' or
   'coaps' in the HTTP URI of the HTTP request to the HC Proxy.

<span class="h2"><a class="selflink" name="section-5" href="#section-5">5</a>.  URI Mapping</span>

   Though, in principle, a CoAP URI could be directly used by an HTTP
   client to dereference a CoAP resource through an HC Proxy; the
   reality is that all major web browsers, networking libraries, and
   command-line tools do not allow making HTTP requests using URIs with
   a scheme 'coap' or 'coaps'.



<span class="grey">Castellani, et al.           Standards Track                    [Page 7]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-8" id="page-8" href="#page-8" class="invisible"> </a>
<span class="grey"><a href="rfc8075.html">RFC 8075</a>                  HTTP-to-CoAP Mapping             February 2017</span>


   Thus, there is a need for web applications to embed or "pack" a CoAP
   URI into an HTTP URI so that it can be (non-destructively)
   transported from the HTTP client to the HC Proxy.  The HC Proxy can
   then "unpack" the CoAP URI and finally dereference it via a CoAP
   request to the target server.

   URI mapping is the term used in this document to describe the process
   through which the URI of a CoAP resource is transformed into an HTTP
   URI so that:

   o  The requesting HTTP client can handle it; and

   o  The receiving HC Proxy can extract the intended CoAP URI
      unambiguously.

   To this end, the remainder of this section will identify:

   o  The default mechanism to map a CoAP URI into an HTTP URI;

   o  The URI Template format to express a class of CoAP-HTTP URI
      mapping functions; and

   o  The discovery mechanism based on "Constrained RESTful Environments
      (CoRE) Link Format" [<a href="rfc6690.html" title="&quot;Constrained RESTful Environments (CoRE) Link Format&quot;">RFC6690</a>] through which clients of an HC Proxy
      can dynamically learn about the supported URI mapping template(s),
      as well as the URI where the HC Proxy function is anchored.

<span class="h3"><a class="selflink" name="section-5.1" href="#section-5.1">5.1</a>.  URI Terminology</span>

   In the remainder of this section, the following terms will be used
   with a distinctive meaning:

   HC Proxy URI:
           URI that refers to the HC Proxy function.  It conforms to
           syntax defined in <a href="rfc7230.html#section-2.7">Section&nbsp;2.7 of [RFC7230]</a>.

   Target CoAP URI:
           URI that refers to the (final) CoAP resource that has to be
           dereferenced.  It conforms to syntax defined in <a href="rfc7252.html#section-6">Section&nbsp;6 of
           [RFC7252]</a>.  Specifically, its scheme is either 'coap' or
           'coaps'.

   Hosting HTTP URI:
           URI that conforms to syntax in <a href="rfc7230.html#section-2.7">Section&nbsp;2.7 of [RFC7230]</a>.  Its
           authority component refers to an HC Proxy, whereas a path
           and/or query component(s) embed the information used by an HC
           Proxy to extract the Target CoAP URI.




<span class="grey">Castellani, et al.           Standards Track                    [Page 8]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-9" id="page-9" href="#page-9" class="invisible"> </a>
<span class="grey"><a href="rfc8075.html">RFC 8075</a>                  HTTP-to-CoAP Mapping             February 2017</span>


<span class="h3"><a class="selflink" name="section-5.2" href="#section-5.2">5.2</a>.  Null Mapping</span>

   The null mapping is the case where there is no Target CoAP URI
   appended to the HC Proxy URI.  In other words, it is a "pure" HTTP
   URI that is sent to the HC Proxy.  This would typically occur in
   situations like use case #1 described in <a href="#section-4">Section 4</a>, and the proxy
   would typically be a reverse-proxy.  In this scenario, the HC Proxy
   will determine through its own private algorithms what the Target
   CoAP URI should be.

<span class="h3"><a class="selflink" name="section-5.3" href="#section-5.3">5.3</a>.  Default Mapping</span>

   The default mapping is for the Target CoAP URI to be appended as is
   (with the only caveat discussed in <a href="#section-5.3.2">Section 5.3.2</a>) to the HC Proxy
   URI, to form the Hosting HTTP URI.  This is the effective request URI
   (see <a href="rfc7230.html#section-5.5">Section&nbsp;5.5 of [RFC7230]</a>) that will then be sent by the HTTP
   client in the HTTP request to the HC Proxy.

   For example: given an HC Proxy URI https://p.example.com/hc/ and a
   Target CoAP URI coap://s.example.com/light, the resulting Hosting
   HTTP URI would be https://p.example.com/hc/coap://s.example.com/
   light.

   Provided a correct Target CoAP URI, the Hosting HTTP URI resulting
   from the default mapping will be a syntactically valid HTTP URI.
   Furthermore, the Target CoAP URI can always be extracted
   unambiguously from the Hosting HTTP URI.

   There is no default for the HC Proxy URI.  Therefore, it is either
   known in advance, e.g., as a configuration preset, or dynamically
   discovered using the mechanism described in <a href="#section-5.5">Section 5.5</a>.

   The default URI mapping function SHOULD be implemented and SHOULD be
   activated by default in an HC Proxy, unless there are valid reasons
   (e.g., application specific) to use a different mapping function.

<span class="h4"><a class="selflink" name="section-5.3.1" href="#section-5.3.1">5.3.1</a>.  Optional Scheme Omission</span>

   When constructing a Hosting HTTP URI by embedding a Target CoAP URI,
   the scheme (i.e., 'coap' or 'coaps'), the scheme component delimiter
   (":"), and the double slash ("//") preceding the authority MAY be
   omitted if a local default -- not defined by this document --
   applies.  If no prior mutual agreement exists between the client and
   the HC Proxy, then a Target CoAP URI without the scheme component is
   syntactically incorrect, and therefore:

   o  It MUST NOT be emitted by clients; and




<span class="grey">Castellani, et al.           Standards Track                    [Page 9]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-10" id="page-10" href="#page-10" class="invisible"> </a>
<span class="grey"><a href="rfc8075.html">RFC 8075</a>                  HTTP-to-CoAP Mapping             February 2017</span>


   o  It MUST elicit a suitable client error status (i.e., 4xx) by the
      HC Proxy.

<span class="h4"><a class="selflink" name="section-5.3.2" href="#section-5.3.2">5.3.2</a>.  Encoding Caveats</span>

   When the authority of the Target CoAP URI is given as an IPv6address,
   then the surrounding square brackets must be percent-encoded in the
   Hosting HTTP URI, in order to comply with the syntax defined in
   <a href="rfc3986.html#section-3.3">Section&nbsp;3.3. of [RFC3986]</a> for a URI path segment.  For example:
   coap://[2001:db8::1]/light?on becomes
   https://p.example.com/hc/coap://%5B2001:db8::1%5D/light?on.  (Note
   that the percent-encoded square brackets shall be reverted to their
   non-percent-encoded form when the HC Proxy unpacks the Target CoAP
   URI.)

   Everything else can be safely copied verbatim from the Target CoAP
   URI to the Hosting HTTP URI.

<span class="h3"><a class="selflink" name="section-5.4" href="#section-5.4">5.4</a>.  URI Mapping Template</span>

   This section defines a format for the URI Template [<a href="rfc6570.html" title="&quot;URI Template&quot;">RFC6570</a>] used by
   an HC Proxy to inform its clients about the expected syntax for the
   Hosting HTTP URI.  This can then be used by the HTTP client to
   construct the effective request URI to be sent in the HTTP request to
   the HC Proxy.

   When instantiated, a URI mapping template is always concatenated to
   an HC Proxy URI provided by the HC Proxy via discovery (see
   <a href="#section-5.5">Section 5.5</a>), or by other means.

   A simple form (<a href="#section-5.4.1">Section 5.4.1</a>) and an enhanced form (<a href="#section-5.4.2">Section 5.4.2</a>)
   are provided to fit different users' requirements.

   Both forms are expressed as Level 2 URI Templates [<a href="rfc6570.html" title="&quot;URI Template&quot;">RFC6570</a>] to take
   care of the expansion of values that are allowed to include reserved
   URI characters.  The syntax of all URI formats is specified in this
   section in Augmented Backus-Naur Form (ABNF) [<a href="rfc5234.html" title="&quot;Augmented BNF for Syntax Specifications: ABNF&quot;">RFC5234</a>].

<span class="h4"><a class="selflink" name="section-5.4.1" href="#section-5.4.1">5.4.1</a>.  Simple Form</span>

   The simple form MUST be used for mappings where the Target CoAP URI
   is going to be copied (using rules of <a href="#section-5.3.2">Section 5.3.2</a>) at some fixed
   position into the Hosting HTTP URI.








<span class="grey">Castellani, et al.           Standards Track                   [Page 10]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-11" id="page-11" href="#page-11" class="invisible"> </a>
<span class="grey"><a href="rfc8075.html">RFC 8075</a>                  HTTP-to-CoAP Mapping             February 2017</span>


   The "tu" template variable is defined below using the ABNF rules from
   [<a href="rfc3986.html" title="&quot;Uniform Resource Identifier (URI): Generic Syntax&quot;">RFC3986</a>], Sections <a href="#section-3.2.2">3.2.2</a>, <a href="#section-3.2.3">3.2.3</a>, <a href="#section-3.3">3.3</a>, and <a href="#section-3.4">3.4</a>.  It is intended to be
   used in a template definition to represent a Target CoAP URI:

     tu = [ ( "coap:" / "coaps:" ) "//" ] host [ ":" port ] path-abempty
          [ "?" query ]

   Note that the same considerations as in <a href="#section-5.3.1">Section 5.3.1</a> apply, in that
   the CoAP scheme may be omitted from the Hosting HTTP URI.

<span class="h5"><a class="selflink" name="section-5.4.1.1" href="#section-5.4.1.1">5.4.1.1</a>.  Examples</span>

   All the following examples (given as a specific URI mapping template,
   a Target CoAP URI, and the produced Hosting HTTP URI) use
   https://p.example.com/hc/ as the HC Proxy URI.  Note that these
   examples all define mapping templates that deviate from the default
   template of <a href="#section-5.3">Section 5.3</a> in order to illustrate the use of the above
   template variables.

   1.  Target CoAP URI is a query argument of the Hosting HTTP URI:

   ?target_uri={+tu}

   coap://s.example.com/light

   =&gt; https://p.example.com/hc/?target_uri=coap://s.example.com/light

   whereas

   coaps://s.example.com/light

   =&gt; https://p.example.com/hc/?target_uri=coaps://s.example.com/light

   2.  Target CoAP URI in the path component of the Hosting HTTP URI:

   forward/{+tu}

   coap://s.example.com/light

   =&gt; https://p.example.com/hc/forward/coap://s.example.com/light

   whereas

   coaps://s.example.com/light

   =&gt; https://p.example.com/hc/forward/coaps://s.example.com/light





<span class="grey">Castellani, et al.           Standards Track                   [Page 11]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-12" id="page-12" href="#page-12" class="invisible"> </a>
<span class="grey"><a href="rfc8075.html">RFC 8075</a>                  HTTP-to-CoAP Mapping             February 2017</span>


   3.  Target CoAP URI is a query argument of the Hosting HTTP URI;
       client decides to omit the scheme because a default is agreed
       beforehand between client and proxy:

   ?coap_uri={+tu}

   coap://s.example.com/light

   =&gt; https://p.example.com/hc/?coap_uri=s.example.com/light

<span class="h4"><a class="selflink" name="section-5.4.2" href="#section-5.4.2">5.4.2</a>.  Enhanced Form</span>

   The enhanced form can be used to express more sophisticated mappings
   of the Target CoAP URI into the Hosting HTTP URI, i.e., mappings that
   do not fit into the simple form.

   There MUST be at most one instance of each of the following template
   variables in a URI mapping template definition:

     s  = "coap" / "coaps" ; from [<a href="rfc7252.html" title="&quot;The Constrained Application Protocol (CoAP)&quot;">RFC7252</a>], Sections <a href="#section-6.1">6.1</a> and <a href="#section-6.2">6.2</a>
     hp = host [":" port]  ; from [<a href="rfc3986.html" title="&quot;Uniform Resource Identifier (URI): Generic Syntax&quot;">RFC3986</a>], Sections <a href="#section-3.2.2">3.2.2</a> and <a href="#section-3.2.3">3.2.3</a>
     p  = path-abempty     ; from <a href="rfc3986.html#section-3.3">[RFC3986], Section&nbsp;3.3</a>
     q  = query            ; from <a href="rfc3986.html#section-3.4">[RFC3986], Section&nbsp;3.4</a>
     qq = [ "?" query ]    ; qq is empty if and only if 'query' is empty

   The qq form is used when the path and the (optional) query components
   are to be copied verbatim from the Target CoAP URI into the Hosting
   HTTP URI, i.e., as "{+p}{+qq}".  Instead, the q form is used when the
   query and path are mapped as separate entities, e.g., as in
   "coap_path={+p}&amp;coap_query={+q}".  So q and qq MUST be used in mutual
   exclusion in a template definition.

<span class="h5"><a class="selflink" name="section-5.4.2.1" href="#section-5.4.2.1">5.4.2.1</a>.  Examples</span>

   All the following examples (given as a specific URI mapping template,
   a Target CoAP URI, and the produced Hosting HTTP URI) use
   https://p.example.com/hc/ as the HC Proxy URI.

   1.  Target CoAP URI components in path segments and optional query in
       query component:

       {+s}/{+hp}{+p}{+qq}

       coap://s.example.com/light

       =&gt; https://p.example.com/hc/coap/s.example.com/light





<span class="grey">Castellani, et al.           Standards Track                   [Page 12]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-13" id="page-13" href="#page-13" class="invisible"> </a>
<span class="grey"><a href="rfc8075.html">RFC 8075</a>                  HTTP-to-CoAP Mapping             February 2017</span>


       whereas

       coap://s.example.com/light?on

       =&gt; https://p.example.com/hc/coap/s.example.com/light?on

   2.  Target CoAP URI components split in individual query arguments:

     ?s={+s}&amp;hp={+hp}&amp;p={+p}&amp;q={+q}

     coap://s.example.com/light

     =&gt; https://p.example.com/hc/?s=coap&amp;hp=s.example.com&amp;p=/light&amp;q=

     whereas

     coaps://s.example.com/light?on

     =&gt; https://p.example.com/hc/?s=coaps&amp;hp=s.example.com&amp;p=/light&amp;q=on

<span class="h3"><a class="selflink" name="section-5.5" href="#section-5.5">5.5</a>.  Discovery</span>

   In order to accommodate site-specific needs while allowing third
   parties to discover the proxy function, the HC Proxy SHOULD publish
   information related to the location and syntax of the HC Proxy
   function using the CoRE Link Format [<a href="rfc6690.html" title="&quot;Constrained RESTful Environments (CoRE) Link Format&quot;">RFC6690</a>] interface.

   To this aim, a new Resource Type, "core.hc", is defined in this
   document.  It can be used as the value for the "rt" attribute in a
   query to the "/.well-known/core" resource in order to locate the URI
   where the HC Proxy function is anchored, i.e., the HC Proxy URI.

   Along with it, the new target attribute "hct" is defined in this
   document.  This attribute MAY be returned in a "core.hc" link to
   provide the URI mapping template associated with the mapping
   resource.  The default template given in <a href="#section-5.3">Section 5.3</a>, i.e., {+tu},
   MUST be assumed if no "hct" attribute is found in a returned link.
   If a "hct" attribute is present in a returned link, the client MUST
   use it to create a Hosting HTTP URI.

   The URI mapping SHOULD be discoverable (as specified in [<a href="rfc6690.html" title="&quot;Constrained RESTful Environments (CoRE) Link Format&quot;">RFC6690</a>]) on
   both the HTTP and the CoAP side of the HC Proxy, with one important
   difference: on the CoAP side, the link associated with the "core.hc"
   resource always needs an explicit anchor parameter referring to the
   HTTP origin [<a href="rfc6454.html" title="&quot;The Web Origin Concept&quot;">RFC6454</a>], while on the HTTP interface, the context URI
   of the link may be equal to the HTTP origin of the discovery request:
   in that case, the anchor parameter is not needed.




<span class="grey">Castellani, et al.           Standards Track                   [Page 13]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-14" id="page-14" href="#page-14" class="invisible"> </a>
<span class="grey"><a href="rfc8075.html">RFC 8075</a>                  HTTP-to-CoAP Mapping             February 2017</span>


<span class="h4"><a class="selflink" name="section-5.5.1" href="#section-5.5.1">5.5.1</a>.  Examples</span>

   o  The first example exercises the CoAP interface and assumes that
      the default template, {+tu}, is used.  For example, a smartphone
      may discover the public HC Proxy before leaving the home network.
      Then, when outside the home network, the smartphone will be able
      to query the appropriate home sensor.

       Req:  GET coap://[ff02::fd]/.well-known/core?rt=core.hc

       Res:  2.05 Content
             &lt;/hc/&gt;;anchor="https://p.example.com";rt="core.hc"

   o  The second example -- also on the CoAP side of the HC Proxy --
      uses a custom template, i.e., one where the CoAP URI is carried
      inside the query component, thus the returned link carries the URI
      Template to be used in an explicit "hct" attribute:

       Req:  GET coap://[ff02::fd]/.well-known/core?rt=core.hc

       Res:  2.05 Content
             &lt;/hc/&gt;;anchor="https://p.example.com";
             rt="core.hc";hct="?uri={+tu}"

   On the HTTP side, link information can be serialized in more than one
   way:

   o  using the 'application/link-format' content type:

       Req:  GET /.well-known/core?rt=core.hc HTTP/1.1
             Host: p.example.com

       Res:  HTTP/1.1 200 OK
             Content-Type: application/link-format
             Content-Length: 19

             &lt;/hc/&gt;;rt="core.hc"














<span class="grey">Castellani, et al.           Standards Track                   [Page 14]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-15" id="page-15" href="#page-15" class="invisible"> </a>
<span class="grey"><a href="rfc8075.html">RFC 8075</a>                  HTTP-to-CoAP Mapping             February 2017</span>


   o  using the 'application/link-format+json' content type as defined
      in [<a href="#ref-CoRE-JSON-CBOR" title="&quot;Representing CoRE Formats in JSON and CBOR&quot;">CoRE-JSON-CBOR</a>]:

       Req:  GET /.well-known/core?rt=core.hc HTTP/1.1
             Host: p.example.com

       Res:  HTTP/1.1 200 OK
             Content-Type: application/link-format+json
             Content-Length: 32

             [{"href":"/hc/","rt":"core.hc"}]

<span class="h2"><a class="selflink" name="section-6" href="#section-6">6</a>.  Media Type Mapping</span>

<span class="h3"><a class="selflink" name="section-6.1" href="#section-6.1">6.1</a>.  Overview</span>

   An HC Proxy needs to translate HTTP media types (<a href="rfc7231.html#section-3.1.1.1">Section&nbsp;3.1.1.1 of
   [RFC7231]</a>) and content codings (<a href="rfc7231.html#section-3.1.2.2">Section&nbsp;3.1.2.2 of [RFC7231]</a>) into
   CoAP content-formats (<a href="rfc7252.html#section-12.3">Section&nbsp;12.3 of [RFC7252]</a>), and vice versa.

   Media type translation can happen in GET, PUT, or POST requests going
   from HTTP to CoAP, in 2.xx (i.e., successful) responses going from
   CoAP to HTTP, and in 4.xx/5.xx error responses with a diagnostic
   payload.  Specifically, PUT and POST need to map both the Content-
   Type and Content-Encoding HTTP headers into a single CoAP Content-
   Format option, whereas GET needs to map Accept and Accept-Encoding
   HTTP headers into a single CoAP Accept option.  To generate the HTTP
   response, the CoAP Content-Format option is mapped back to a suitable
   HTTP Content-Type and Content-Encoding combination.

   An HTTP request carrying a Content-Type and Content-Encoding
   combination that the HC Proxy is unable to map to an equivalent CoAP
   Content-Format SHALL elicit a 415 (Unsupported Media Type) response
   by the HC Proxy.

   On the content negotiation side, failure to map Accept and Accept-*
   headers SHOULD be silently ignored: the HC Proxy SHOULD therefore
   forward as a CoAP request with no Accept option.  The HC Proxy thus
   disregards the Accept/Accept-* header fields by treating the response
   as if it is not subject to content negotiation, as mentioned in
   <a href="rfc7231.html#section-5.3">Section&nbsp;5.3 of [RFC7231]</a>.  However, an HC Proxy implementation is
   free to attempt mapping a single Accept header in a GET request to
   multiple CoAP GET requests, each with a single Accept option, which
   are then tried in sequence until one succeeds.  Note that an HTTP
   Accept */* MUST be mapped to a CoAP request without an Accept option.

   While the CoAP-to-HTTP direction always has a well-defined mapping
   (with the exception examined in <a href="#section-6.2">Section 6.2</a>), the HTTP-to-CoAP



<span class="grey">Castellani, et al.           Standards Track                   [Page 15]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-16" id="page-16" href="#page-16" class="invisible"> </a>
<span class="grey"><a href="rfc8075.html">RFC 8075</a>                  HTTP-to-CoAP Mapping             February 2017</span>


   direction is more problematic because the source set, i.e.,
   potentially 1000+ IANA-registered media types, is much bigger than
   the destination set, i.e., the mere six values initially defined in
   <a href="rfc7252.html#section-12.3">Section&nbsp;12.3 of [RFC7252]</a>.

   Depending on the tight/loose coupling with the application(s) for
   which it proxies, the HC Proxy could implement different media type
   mappings.

   When tightly coupled, the HC Proxy knows exactly which content-
   formats are supported by the applications and can be strict when
   enforcing its forwarding policies in general, and the media type
   mapping in particular.

   On the other hand, when the HC Proxy is a general purpose ALG, being
   too strict could significantly reduce the amount of traffic that it
   would be able to successfully forward.  In this case, the "loose"
   media type mapping detailed in <a href="#section-6.3">Section 6.3</a> MAY be implemented.

   The latter grants more evolution of the surrounding ecosystem, at the
   cost of allowing more attack surface.  In fact, as a result of such
   strategy, payloads would be forwarded more liberally across the
   unconstrained/constrained network boundary of the communication path.

<span class="h3"><a class="selflink" name="section-6.2" href="#section-6.2">6.2</a>.  'application/coap-payload' Media Type</span>

   If the HC Proxy receives a CoAP response with a Content-Format that
   it does not recognize (e.g., because the value has been registered
   after the proxy has been deployed, or the CoAP server uses an
   experimental value that is not registered), then the HC Proxy SHALL
   return a generic "application/coap-payload" media type with numeric
   parameter "cf" as defined in <a href="#section-9.2">Section 9.2</a>.

   For example, the CoAP content-format '60' ("application/cbor") would
   be represented by "application/coap-payload;cf=60", if the HC Proxy
   doesn't recognize the content-format '60'.

   An HTTP client may use the media type "application/coap-payload" as a
   means to send a specific content-format to a CoAP server via an HC
   Proxy if the client has determined that the HC Proxy does not
   directly support the type mapping it needs.  This case may happen
   when dealing, for example, with newly registered, yet to be
   registered, or experimental CoAP content-formats.  However, unless
   explicitly configured to allow pass-through of unknown content-
   formats, the HC Proxy SHOULD NOT forward requests carrying a Content-
   Type or Accept header with an "application/coap-payload", and return
   an appropriate client error instead.




<span class="grey">Castellani, et al.           Standards Track                   [Page 16]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-17" id="page-17" href="#page-17" class="invisible"> </a>
<span class="grey"><a href="rfc8075.html">RFC 8075</a>                  HTTP-to-CoAP Mapping             February 2017</span>


<span class="h3"><a class="selflink" name="section-6.3" href="#section-6.3">6.3</a>.  Loose Media Type Mapping</span>

   By structuring the type information in a super-class (e.g., "text")
   followed by a finer-grained sub-class (e.g., "html"), and optional
   parameters (e.g., "charset=utf-8"), Internet media types provide a
   rich and scalable framework for encoding the type of any given
   entity.

   This approach is not applicable to CoAP, where content-formats
   conflate an Internet media type (potentially with specific
   parameters) and a content coding into one small integer value.

   To remedy this loss of flexibility, we introduce the concept of a
   "loose" media type mapping, where media types that are
   specializations of a more generic media type can be aliased to their
   super-class and then mapped (if possible) to one of the CoAP content-
   formats.  For example, "application/soap+xml" can be aliased to
   "application/xml", which has a known conversion to CoAP.  In the
   context of this "loose" media type mapping, "application/
   octet-stream" can be used as a fallback when no better alias is found
   for a specific media type.

   Table 1 defines the default lookup table for the "loose" media type
   mapping.  It is expected that an implementation can refine it because
   either application-specific knowledge is given or new Content-Formats
   are defined.  Given an input media type, the table returns its best
   generalized media type using the most specific match, i.e., the table
   entries are compared to the input in top to bottom order until an
   entry matches.

        +-----------------------------+--------------------------+
        | Internet media type pattern | Generalized media type   |
        +-----------------------------+--------------------------+
        | application/*+xml           | application/xml          |
        | application/*+json          | application/json         |
        | application/*+cbor          | application/cbor         |
        | text/xml                    | application/xml          |
        | text/*                      | text/plain               |
        | */*                         | application/octet-stream |
        +-----------------------------+--------------------------+

              Table 1: Media Type Generalization Lookup Table

   The "loose" media type mapping is an OPTIONAL feature.
   Implementations supporting this kind of mapping should provide a
   flexible way to define the set of media type generalizations allowed.





<span class="grey">Castellani, et al.           Standards Track                   [Page 17]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-18" id="page-18" href="#page-18" class="invisible"> </a>
<span class="grey"><a href="rfc8075.html">RFC 8075</a>                  HTTP-to-CoAP Mapping             February 2017</span>


<span class="h3"><a class="selflink" name="section-6.4" href="#section-6.4">6.4</a>.  Media Type to Content-Format Mapping Algorithm</span>

   This section defines the algorithm used to map an HTTP Internet media
   type to its correspondent CoAP content-format; it can be used as a
   building block for translating HTTP Content-Type and Accept headers
   into CoAP Content-Format and Accept Options.

   The algorithm uses an IANA-maintained table, "CoAP Content-Formats",
   as established by <a href="rfc7252.html#section-12.3">Section&nbsp;12.3 of [RFC7252]</a> plus, possibly, any
   locally defined extension of it.  Optionally, the table and lookup
   mechanism described in <a href="#section-6.3">Section 6.3</a> can be used if the implementation
   chooses so.

   Note that the algorithm assumes an "identity" Content-Encoding and
   expects the resource body has been already successfully content
   decoded or transcoded to the desired format.

   In the following (Figure 2):

   o  media_type is the media type to translate;

   o  coap_cf_registry is a lookup table matching the "CoAP Content-
      Formats" registry; and

   o  loose_mapper is an optional lookup table describing the loose
      media type mappings (e.g., the one defined in Table 1).

   The full source code is provided in <a href="#appendix-A">Appendix A</a>.























<span class="grey">Castellani, et al.           Standards Track                   [Page 18]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-19" id="page-19" href="#page-19" class="invisible"> </a>
<span class="grey"><a href="rfc8075.html">RFC 8075</a>                  HTTP-to-CoAP Mapping             February 2017</span>


 def mt2cf(media_type, encoding=None,
           coap_cf_registry=CoAPContentFormatRegistry(),
           loose_mapper=None):
     """Return a CoAP Content-Format given an Internet media type and
        its optional encoding.  The current (as of 2016/10/24) "CoAP
        Content-Formats" registry is supplied by default.  An optional
        'loose-mapping' implementation can be supplied by the caller."""
     assert media_type is not None
     assert coap_cf_registry is not None

     # Lookup the "CoAP Content-Formats" registry
     content_format = coap_cf_registry.lookup(media_type, encoding)

     # If an exact match is not found and a loose mapper has been
     # supplied, try to use it to get a media type with which to
     # retry the "CoAP Content-Formats" registry lookup.
     if content_format is None and loose_mapper is not None:
         content_format = coap_cf_registry.lookup(
             loose_mapper.lookup(media_type), encoding)

     return content_format

                                 Figure 2

<span class="h3"><a class="selflink" name="section-6.5" href="#section-6.5">6.5</a>.  Content Transcoding</span>

<span class="h4"><a class="selflink" name="section-6.5.1" href="#section-6.5.1">6.5.1</a>.  General</span>

   Payload content transcoding is an OPTIONAL feature.  Implementations
   supporting this feature should provide a flexible way to define the
   set of transcodings allowed.

   The HC Proxy might decide to transcode the received representation to
   a different (compatible) format when an optimized version of a
   specific format exists.  For example, an XML-encoded resource could
   be transcoded to Efficient XML Interchange (EXI) format, or a JSON-
   encoded resource into Concise Binary Object Representation (CBOR)
   [<a href="rfc7049.html" title="&quot;Concise Binary Object Representation (CBOR)&quot;">RFC7049</a>], effectively achieving compression without losing any
   information.

   However, there are a few important factors to keep in mind when
   enabling a transcoding function:

   1.  Maliciously crafted inputs coming from the HTTP side might
       inflate in size (see, for example, <a href="rfc7049.html#section-4.2">Section&nbsp;4.2 of [RFC7049]</a>),
       therefore creating a security threat for both the HC Proxy and
       the target resource.




<span class="grey">Castellani, et al.           Standards Track                   [Page 19]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-20" id="page-20" href="#page-20" class="invisible"> </a>
<span class="grey"><a href="rfc8075.html">RFC 8075</a>                  HTTP-to-CoAP Mapping             February 2017</span>


   2.  Transcoding can lose information in non-obvious ways.  For
       example, encoding an XML document using schema-informed EXI
       encoding leads to a loss of information when the destination does
       not know the exact schema version used by the encoder.  That
       means that whenever the HC Proxy transcodes "application/xml" to
       "application/exi", in-band metadata could be lost.

   3.  When the Content-Type is mapped, there is a risk that the content
       with the destination type would have malware not active in the
       source type.

   It is crucial that these risks are well understood and carefully
   weighed against the actual benefits before deploying the transcoding
   function.

<span class="h4"><a class="selflink" name="section-6.5.2" href="#section-6.5.2">6.5.2</a>.  CoRE Link Format</span>

   The CoRE Link Format [<a href="rfc6690.html" title="&quot;Constrained RESTful Environments (CoRE) Link Format&quot;">RFC6690</a>] is a set of links (i.e., URIs and
   their formal relationships) that is carried as content payload in a
   CoAP response.  These links usually include CoAP URIs that might be
   translated by the HC Proxy to the correspondent HTTP URIs using the
   implemented URI mapping function (see <a href="#section-5">Section 5</a>).  Such a translation
   process would inspect the forwarded traffic and attempt to rewrite
   the body of resources with an application/link-format media type,
   mapping the embedded CoAP URIs to their HTTP counterparts.  Some
   potential issues with this approach are:

   1.  The client may be interested in retrieving original (unaltered)
       CoAP payloads through the HC Proxy, not modified versions.

   2.  Tampering with payloads is incompatible with resources that are
       integrity protected (although this is a problem with transcoding
       in general).

   3.  The HC Proxy needs to fully understand syntax and semantics
       defined in [<a href="rfc6690.html" title="&quot;Constrained RESTful Environments (CoRE) Link Format&quot;">RFC6690</a>], otherwise there is an inherent risk to
       corrupt the payloads.

   Therefore, CoRE Link Format payload should only be transcoded at the
   risk and discretion of the proxy implementer.

<span class="h3"><a class="selflink" name="section-6.6" href="#section-6.6">6.6</a>.  Diagnostic Payloads</span>

   CoAP responses may, in certain error cases, contain a diagnostic
   message in the payload explaining the error situation, as described
   in <a href="rfc7252.html#section-5.5.2">Section&nbsp;5.5.2 of [RFC7252]</a>.  If present, the CoAP diagnostic
   payload SHOULD be copied into the HTTP response body with the media
   type of the response set to "text/plain;charset=utf-8".  The CoAP



<span class="grey">Castellani, et al.           Standards Track                   [Page 20]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-21" id="page-21" href="#page-21" class="invisible"> </a>
<span class="grey"><a href="rfc8075.html">RFC 8075</a>                  HTTP-to-CoAP Mapping             February 2017</span>


   diagnostic payload MUST NOT be copied into the HTTP reason-phrase,
   since it potentially contains CR-LF characters that are incompatible
   with HTTP reason-phrase syntax.

<span class="h2"><a class="selflink" name="section-7" href="#section-7">7</a>.  Response Code Mapping</span>

   Table 2 defines the HTTP response status codes to which each CoAP
   response code SHOULD be mapped.  Multiple HTTP status codes in the
   second column for a given CoAP response code indicates that multiple
   HTTP responses are possible for the same CoAP response code,
   depending on the conditions cited in the Notes (see the third column
   and text below the table).

   +-------------------------------+----------------------------+------+
   | CoAP Response Code            | HTTP Status Code           | Note |
   +-------------------------------+----------------------------+------+
   | 2.01 Created                  | 201 Created                | 1    |
   | 2.02 Deleted                  | 200 OK                     | 2    |
   |                               | 204 No Content             | 2    |
   | 2.03 Valid                    | 304 Not Modified           | 3    |
   |                               | 200 OK                     | 4    |
   | 2.04 Changed                  | 200 OK                     | 2    |
   |                               | 204 No Content             | 2    |
   | 2.05 Content                  | 200 OK                     |      |
   | 2.31 Continue                 | N/A                        | 10   |
   | 4.00 Bad Request              | 400 Bad Request            |      |
   | 4.01 Unauthorized             | 403 Forbidden              | 5    |
   | 4.02 Bad Option               | 400 Bad Request            | 6    |
   |                               | 500 Internal Server Error  | 6    |
   | 4.03 Forbidden                | 403 Forbidden              |      |
   | 4.04 Not Found                | 404 Not Found              |      |
   | 4.05 Method Not Allowed       | 400 Bad Request            | 7    |
   |                               | 405 Method Not Allowed     | 7    |
   | 4.06 Not Acceptable           | 406 Not Acceptable         |      |
   | 4.08 Request Entity Incomplt. | N/A                        | 10   |
   | 4.12 Precondition Failed      | 412 Precondition Failed    |      |
   | 4.13 Request Ent. Too Large   | 413 Payload Too Large      | 11   |
   | 4.15 Unsupported Content-Fmt. | 415 Unsupported Media Type |      |
   | 5.00 Internal Server Error    | 500 Internal Server Error  |      |
   | 5.01 Not Implemented          | 501 Not Implemented        |      |
   | 5.02 Bad Gateway              | 502 Bad Gateway            |      |
   | 5.03 Service Unavailable      | 503 Service Unavailable    | 8    |
   | 5.04 Gateway Timeout          | 504 Gateway Timeout        |      |
   | 5.05 Proxying Not Supported   | 502 Bad Gateway            | 9    |
   +-------------------------------+----------------------------+------+

                 Table 2: CoAP-HTTP Response Code Mappings




<span class="grey">Castellani, et al.           Standards Track                   [Page 21]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-22" id="page-22" href="#page-22" class="invisible"> </a>
<span class="grey"><a href="rfc8075.html">RFC 8075</a>                  HTTP-to-CoAP Mapping             February 2017</span>


   Notes:

   1.   A CoAP server may return an arbitrary format payload along with
        this response.  If present, this payload MUST be returned as an
        entity in the HTTP 201 response.  <a href="rfc7231.html#section-6.3.2">Section&nbsp;6.3.2 of [RFC7231]</a>
        does not put any requirement on the format of the entity.  (In
        the past, [<a href="rfc2616.html" title="&quot;Hypertext Transfer Protocol -- HTTP/1.1&quot;">RFC2616</a>] did.  Note that [<a href="rfc2616.html" title="&quot;Hypertext Transfer Protocol -- HTTP/1.1&quot;">RFC2616</a>] has been obsoleted
        by [<a href="rfc7230.html" title="&quot;Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing&quot;">RFC7230</a>].)

   2.   The HTTP code is 200 or 204, respectively, for the case where a
        CoAP server returns a payload or not.  <a href="rfc7231.html#section-6.3">[RFC7231], Section&nbsp;6.3</a>
        requires code 200 in case a representation of the action result
        is returned for DELETE/POST/PUT, and code 204 if not.  Hence, a
        proxy MUST transfer any CoAP payload contained in a CoAP 2.02
        response to the HTTP client using a 200 OK response.

   3.   HTTP code 304 (Not Modified) is sent if the HTTP client
        performed a conditional HTTP request and the CoAP server
        responded with 2.03 (Valid) to the corresponding CoAP validation
        request.  Note that <a href="rfc7232.html#section-4.1">Section&nbsp;4.1 of [RFC7232]</a> puts some
        requirements on header fields that must be present in the HTTP
        304 response.

   4.   A 200 response to a CoAP 2.03 occurs only when the HC Proxy, for
        efficiency reasons, is running a local cache.  An unconditional
        HTTP GET that produces a cache-hit could trigger a revalidation
        (i.e., a conditional GET) on the CoAP side.  The proxy receiving
        2.03 updates the freshness of its cached representation and
        returns it to the HTTP client.

   5.   An HTTP 401 Unauthorized (<a href="rfc7235.html#section-3.1">Section&nbsp;3.1 of [RFC7235]</a>) response is
        not applicable because there is no equivalent of
        WWW-Authenticate in CoAP, which is mandatory in an HTTP 401
        response.

   6.   If the proxy has a way to determine that the Bad Option is due
        to the straightforward mapping of a client request header into a
        CoAP option, then returning HTTP 400 (Bad Request) is
        appropriate.  In all other cases, the proxy MUST return HTTP 500
        (Internal Server Error) stating its inability to provide a
        suitable translation to the client's request.

   7.   A CoAP 4.05 (Method Not Allowed) response SHOULD normally be
        mapped to an HTTP 400 (Bad Request) code, because the HTTP 405
        response would require specifying the supported methods -- which
        are generally unknown.  In this case, the HC Proxy SHOULD also
        return an HTTP reason-phrase in the HTTP status line that starts
        with the string "CoAP server returned 4.05" in order to



<span class="grey">Castellani, et al.           Standards Track                   [Page 22]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-23" id="page-23" href="#page-23" class="invisible"> </a>
<span class="grey"><a href="rfc8075.html">RFC 8075</a>                  HTTP-to-CoAP Mapping             February 2017</span>


        facilitate troubleshooting.  However, if the HC Proxy has more
        granular information about the supported methods for the
        requested resource (e.g., via a Resource Directory ([<a href="#ref-CoRE-RD" title="&quot;CoRE Resource Directory&quot;">CoRE-RD</a>])),
        then it MAY send back an HTTP 405 (Method Not Allowed) with a
        properly filled in "Allow" response-header field (<a href="rfc7231.html#section-7.4.1">Section&nbsp;7.4.1
        of [RFC7231]</a>).

   8.   The value of the HTTP "Retry-After" response-header field is
        taken from the value of the CoAP Max-Age Option, if present.

   9.   This CoAP response can only happen if the proxy itself is
        configured to use a CoAP forward-proxy (<a href="rfc7252.html#section-5.7">Section&nbsp;5.7 of
        [RFC7252]</a>) to execute some, or all, of its CoAP requests.

   10.  Only used in CoAP block-wise transfer [<a href="rfc7959.html" title="&quot;Block-Wise Transfers in the Constrained Application Protocol (CoAP)&quot;">RFC7959</a>] between HC Proxy
        and CoAP server; never translated into an HTTP response.

   11.  Only returned to the HTTP client if the HC Proxy was unable to
        successfully complete the request by retrying it with CoAP
        block-wise transfer; see <a href="#section-8.3">Section 8.3</a>.

<span class="h2"><a class="selflink" name="section-8" href="#section-8">8</a>.  Additional Mapping Guidelines</span>

<span class="h3"><a class="selflink" name="section-8.1" href="#section-8.1">8.1</a>.  Caching and Congestion Control</span>

   An HC Proxy should cache CoAP responses and reply whenever applicable
   with a cached representation of the requested resource.

   If the HTTP client drops the connection after the HTTP request was
   made, an HC Proxy should wait for the associated CoAP response and
   cache it if possible.  Subsequent requests to the HC Proxy for the
   same resource can use the result present in cache, or, if a response
   has still to come, the HTTP requests will wait on the open CoAP
   request.

   According to [<a href="rfc7252.html" title="&quot;The Constrained Application Protocol (CoAP)&quot;">RFC7252</a>], a proxy must limit the number of outstanding
   requests to a given CoAP server to NSTART.  To limit the amount of
   aggregate traffic to a constrained network, the HC Proxy should also
   put a limit on the number of concurrent CoAP requests pending on the
   same constrained network; further incoming requests may either be
   queued or be dropped (returning 503 Service Unavailable).  This limit
   and the proxy queueing/dropping behavior should be configurable.

   Highly volatile resources that are being frequently requested may be
   observed [<a href="rfc7641.html" title="&quot;Observing Resources in the Constrained Application Protocol (CoAP)&quot;">RFC7641</a>] by the HC Proxy to keep their cached
   representation fresh while minimizing the amount of CoAP traffic in
   the constrained network (see <a href="#section-8.2">Section 8.2</a>).




<span class="grey">Castellani, et al.           Standards Track                   [Page 23]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-24" id="page-24" href="#page-24" class="invisible"> </a>
<span class="grey"><a href="rfc8075.html">RFC 8075</a>                  HTTP-to-CoAP Mapping             February 2017</span>


<span class="h3"><a class="selflink" name="section-8.2" href="#section-8.2">8.2</a>.  Cache Refresh via Observe</span>

   There are cases where using the CoAP observe protocol [<a href="rfc7641.html" title="&quot;Observing Resources in the Constrained Application Protocol (CoAP)&quot;">RFC7641</a>] to
   handle proxy cache refresh is preferable to the validation mechanism
   based on the entity-tag (ETag) as defined in [<a href="rfc7252.html" title="&quot;The Constrained Application Protocol (CoAP)&quot;">RFC7252</a>].  Such
   scenarios include sleepy CoAP nodes -- with possibly high variance in
   requests' distribution -- which would greatly benefit from a server-
   driven cache update mechanism.  Ideal candidates for CoAP observe are
   also crowded or very low throughput networks, where reduction of the
   total number of exchanged messages is an important requirement.

   This subsection aims at providing a practical evaluation method to
   decide whether refreshing a cached resource R is more efficiently
   handled via ETag validation or by establishing an observation on R.
   The idea being that the HC Proxy proactively installs an observation
   on a "popular enough" resource and actively monitors:

   a.  Its update pattern on the CoAP side

   b.  The request pattern on the HTTP side

   and uses the formula below to determine whether the observation
   should be kept alive or shut down.

   Let T_R be the mean time between two client requests to resource R,
   let T_C be the mean time between two representation changes of R, and
   let M_R be the mean number of CoAP messages per second exchanged to
   and from resource R.  If we assume that the initial cost for
   establishing the observation is negligible, an observation on R
   reduces M_R if and only if T_R &lt; 2*T_C with respect to using ETag
   validation, that is, if and only if the mean arrival rate of requests
   for resource R is greater than half the change rate of R.

   When observing the resource R, M_R is always upper bounded by 2/T_C.

<span class="h3"><a class="selflink" name="section-8.3" href="#section-8.3">8.3</a>.  Use of CoAP Block-Wise Transfer</span>

   An HC Proxy SHOULD support CoAP block-wise transfers [<a href="rfc7959.html" title="&quot;Block-Wise Transfers in the Constrained Application Protocol (CoAP)&quot;">RFC7959</a>] to
   allow transport of large CoAP payloads while avoiding excessive link-
   layer fragmentation in constrained networks and to cope with small
   datagram buffers in CoAP endpoints as described in <a href="rfc7252.html#section-4.6">[RFC7252],
   Section&nbsp;4.6</a>.

   An HC Proxy SHOULD attempt to retry a payload-carrying CoAP PUT or
   POST request with block-wise transfer if the destination CoAP server
   responded with 4.13 (Request Entity Too Large) to the original
   request.  An HC Proxy SHOULD attempt to use block-wise transfer when
   sending a CoAP PUT or POST request message that is larger than



<span class="grey">Castellani, et al.           Standards Track                   [Page 24]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-25" id="page-25" href="#page-25" class="invisible"> </a>
<span class="grey"><a href="rfc8075.html">RFC 8075</a>                  HTTP-to-CoAP Mapping             February 2017</span>


   BLOCKWISE_THRESHOLD bytes.  The value of BLOCKWISE_THRESHOLD is
   implementation specific; for example, it can be:

   o  Calculated based on a known or typical UDP datagram buffer size
      for CoAP endpoints, or

   o  Set to N times the known size of a link-layer frame in a
      constrained network where, e.g., N=5, or

   o  Preset to a known IP MTU value, or

   o  Set to a known Path MTU value.

   The value BLOCKWISE_THRESHOLD, or the parameters from which it is
   calculated, should be configurable in a proxy implementation.  The
   maximum block size the proxy will attempt to use in CoAP requests
   should also be configurable.

   The HC Proxy SHOULD detect CoAP endpoints not supporting block-wise
   transfers.  This can be done by checking for a 4.02 (Bad Option)
   response returned by an endpoint in response to a CoAP request with a
   Block* Option, and subsequent absence of the 4.02 in response to the
   same request without Block* Options.  This allows the HC Proxy to be
   more efficient, not attempting repeated block-wise transfers to CoAP
   servers that do not support it.

<span class="h3"><a class="selflink" name="section-8.4" href="#section-8.4">8.4</a>.  CoAP Multicast</span>

   An HC Proxy MAY support CoAP multicast.  If it does, the HC Proxy
   sends out a multicast CoAP request if the Target CoAP URI's authority
   is a multicast IP literal or resolves to a multicast IP address.  If
   the HC Proxy does not support CoAP multicast, it SHOULD respond 403
   (Forbidden) to any valid HTTP request that maps to a CoAP multicast
   request.

   Details related to supporting CoAP multicast are currently out of
   scope of this document since in a proxy scenario, an HTTP client
   typically expects to receive a single response, not multiple.
   However, an HC Proxy that implements CoAP multicast may include
   application-specific functions to aggregate multiple CoAP responses
   into a single HTTP response.  We suggest using the "application/http"
   Internet media type (<a href="rfc7230.html#section-8.3.2">Section&nbsp;8.3.2 of [RFC7230]</a>) to enclose a set of
   one or more HTTP response messages, each representing the mapping of
   one CoAP response.

   For further considerations related to the handling of multicast
   requests, see <a href="#section-10.1">Section 10.1</a>.




<span class="grey">Castellani, et al.           Standards Track                   [Page 25]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-26" id="page-26" href="#page-26" class="invisible"> </a>
<span class="grey"><a href="rfc8075.html">RFC 8075</a>                  HTTP-to-CoAP Mapping             February 2017</span>


<span class="h3"><a class="selflink" name="section-8.5" href="#section-8.5">8.5</a>.  Timeouts</span>

   If the CoAP server takes a long time in responding, the HTTP client
   or any other proxy in between may timeout.  Further discussion of
   timeouts in HTTP is available in <a href="rfc7230.html#section-6.5">Section&nbsp;6.5 of [RFC7230]</a>.

   An HC Proxy MUST define an internal timeout for each pending CoAP
   request, because the CoAP server may silently die before completing
   the request.  Assuming the proxy uses confirmable CoAP requests, such
   timeout value T SHOULD be

   T = MAX_RTT + MAX_SERVER_RESPONSE_DELAY

   where MAX_RTT is defined in [<a href="rfc7252.html" title="&quot;The Constrained Application Protocol (CoAP)&quot;">RFC7252</a>] and MAX_SERVER_RESPONSE_DELAY
   is defined as the worst-case expected response delay of the CoAP
   server.  If unknown, a default value of 250 seconds can be used for
   MAX_SERVER_RESPONSE_DELAY as in <a href="rfc7390.html#section-2.5">Section&nbsp;2.5 of [RFC7390]</a>.

<span class="h2"><a class="selflink" name="section-9" href="#section-9">9</a>.  IANA Considerations</span>

<span class="h3"><a class="selflink" name="section-9.1" href="#section-9.1">9.1</a>.  New 'core.hc' Resource Type</span>

   This document registers a new Resource Type (rt=) Link Target
   Attribute, 'core.hc', in the "Resource Type (rt=) Link Target
   Attribute Values" subregistry under the "Constrained RESTful
   Environments (CoRE) Parameters" registry.

   Attribute Value: core.hc

   Description: HTTP-to-CoAP mapping base resource.

   Reference: See <a href="rfc8075.html#section-5.5">Section&nbsp;5.5 of RFC 8075</a>.

<span class="h3"><a class="selflink" name="section-9.2" href="#section-9.2">9.2</a>.  New 'coap-payload' Internet Media Type</span>

   This document defines the "application/coap-payload" media type with
   a single parameter "cf".  This media type represents any payload that
   a CoAP message can carry, having a content-format that can be
   identified by an integer in range 0-65535 corresponding to a CoAP
   Content-Format parameter (<a href="rfc7252.html#section-12.3">[RFC7252], Section&nbsp;12.3</a>).  The parameter
   "cf" is the integer defining the CoAP content-format.

   Type name: application

   Subtype name: coap-payload

   Required parameters: "cf" (CoAP Content-Format integer in range
   0-65535 denoting the content-format of the CoAP payload carried, as



<span class="grey">Castellani, et al.           Standards Track                   [Page 26]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-27" id="page-27" href="#page-27" class="invisible"> </a>
<span class="grey"><a href="rfc8075.html">RFC 8075</a>                  HTTP-to-CoAP Mapping             February 2017</span>


   defined by the "CoAP Content-Formats" subregistry that is part of the
   "Constrained RESTful Environments (CoRE) Parameters" registry).

   Optional parameters: None

   Encoding considerations: Common use is BINARY.  The specific CoAP
   content-format encoding considerations for the selected Content-
   Format ("cf" parameter) apply.  The encoding can vary based on the
   value of the "cf" parameter.

   Security considerations: The specific CoAP content-format security
   considerations for the selected Content-Format ("cf" parameter)
   apply.

   Interoperability considerations: This media type can never be used
   directly in CoAP messages because there are no means available to
   encode the mandatory "cf" parameter in CoAP.

   Published specification: <a href="rfc8075.html">RFC 8075</a>

   Applications that use this media type: HTTP-to-CoAP proxies.

   Fragment identifier considerations: CoAP does not support URI
   fragments; therefore, a CoAP payload fragment cannot be identified.
   Fragments are not applicable for this media type.

   Additional information:

      Deprecated alias names for this type: N/A

      Magic number(s): N/A

      File extension(s): N/A

      Macintosh file type code(s): N/A

   Person and email address to contact for further information:

      Esko Dijk ("esko@ieee.org")

   Intended usage: COMMON

   Restrictions on usage:

   An application (or user) can only use this media type if it has to
   represent a CoAP payload of which the specified CoAP Content-Format
   is an unrecognized number, such that a proper translation directly to
   the equivalent HTTP media type is not possible.



<span class="grey">Castellani, et al.           Standards Track                   [Page 27]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-28" id="page-28" href="#page-28" class="invisible"> </a>
<span class="grey"><a href="rfc8075.html">RFC 8075</a>                  HTTP-to-CoAP Mapping             February 2017</span>


   Author: CoRE WG

   Change controller: IETF

   Provisional registration: No

<span class="h2"><a class="selflink" name="section-10" href="#section-10">10</a>.  Security Considerations</span>

   The security considerations in <a href="rfc7230.html#section-9.2">Section&nbsp;9.2 of [RFC7230]</a> apply in full
   to the HC Proxy.  This section discusses security aspects and
   requirements that are specific to the deployment and operation of an
   HC Proxy.

   An HC Proxy located at the boundary of a constrained network is an
   easy single point of failure for reducing availability.  As such,
   special care should be taken in designing, developing, and operating
   it, keeping in mind that, in most cases, it has fewer limitations
   than the constrained devices it is serving.  In particular, its
   quality of implementation and operation -- i.e., use of current
   software development practices, careful selection of third-party
   libraries, sane configuration defaults, and an expedited way to
   upgrade a running instance -- are all essential attributes of the HC
   Proxy.

   The correctness of request parsing in general (including any content
   transcoding), and of URI translation in particular, is essential to
   the security of the HC Proxy function.  This is especially true when
   the constrained network hosts devices with genuinely limited
   capabilities.  For this purpose, see also Sections <a href="#section-9.3">9.3</a>, <a href="#section-9.4">9.4</a>, <a href="#section-9.5">9.5</a> and
   9.6 of [<a href="rfc7230.html" title="&quot;Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing&quot;">RFC7230</a>] for well-known issues related to HTTP request
   parsing and <a href="rfc7252.html#section-11.1">Section&nbsp;11.1 of [RFC7252]</a> for an overview of CoAP-
   specific concerns related to URI processing -- in particular, the
   potential impact on access control mechanisms that are based on URIs.

   An HC Proxy MUST implement Transport Layer Security (TLS) with a Pre-
   Shared Key (PSK) [<a href="rfc4279.html" title="&quot;Pre-Shared Key Ciphersuites for Transport Layer Security (TLS)&quot;">RFC4279</a>] and SHOULD implement TLS [<a href="rfc5246.html" title="&quot;The Transport Layer Security (TLS) Protocol Version 1.2&quot;">RFC5246</a>] with
   support for client authentication using X.509 certificates.  A
   prerequisite of the latter is the availability of a Certification
   Authority (CA) to issue suitable certificates.  Although this can be
   a challenging requirement in certain application scenarios, it is
   worth noting that there exist open-source tools (e.g., [<a href="#ref-OpenSSL" title="&quot;ca - sample minimal CA application&quot;">OpenSSL</a>])
   that can be used to set up and operate an application-specific CA.

   By default, the HC Proxy MUST authenticate all incoming requests
   prior to forwarding them to the CoAP server.  This default behavior
   MAY be explicitly disabled by an administrator.





<span class="grey">Castellani, et al.           Standards Track                   [Page 28]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-29" id="page-29" href="#page-29" class="invisible"> </a>
<span class="grey"><a href="rfc8075.html">RFC 8075</a>                  HTTP-to-CoAP Mapping             February 2017</span>


   The following subparagraphs categorize and discuss a set of specific
   security issues related to the translation, caching, and forwarding
   functionality exposed by an HC Proxy.

<span class="h3"><a class="selflink" name="section-10.1" href="#section-10.1">10.1</a>.  Multicast</span>

   Multicast requests impose a non-trivial cost on the constrained
   network and endpoints and might be exploited as a DoS attack vector
   (see also <a href="#section-10.2">Section 10.2</a>).  From a privacy perspective, they can be
   used to gather detailed information about the resources hosted in the
   constrained network.  For example, an outsider that is able to
   successfully query the "/.well-known/core" resource could obtain a
   comprehensive list of the target's home appliances and devices.  From
   a security perspective, they can be used to carry out a network
   reconnaissance attack to gather information about possible
   vulnerabilities that could be exploited at a later point in time.
   For these reasons, it is RECOMMENDED that requests to multicast
   resources are access controlled with a default-deny policy.  It is
   RECOMMENDED that the requestor of a multicast resource be strongly
   authenticated.  If privacy and/or security are first class
   requirements, for example, whenever the HTTP request transits through
   the public Internet, the request SHOULD be transported over a
   mutually authenticated and encrypted TLS connection.

<span class="h3"><a class="selflink" name="section-10.2" href="#section-10.2">10.2</a>.  Traffic Overflow</span>

   Due to the typically constrained nature of CoAP nodes, particular
   attention should be given to the implementation of traffic reduction
   mechanisms (see <a href="#section-8.1">Section 8.1</a>), because an inefficient proxy
   implementation can be targeted by unconstrained Internet attackers.
   Bandwidth or complexity involved in such attacks is very low.

   An amplification attack to the constrained network may be triggered
   by a multicast request generated by a single HTTP request that is
   mapped to a CoAP multicast resource, as discussed in <a href="rfc7252.html#section-11.3">Section&nbsp;11.3 of
   [RFC7252]</a>.

   The risk likelihood of this amplification technique is higher than an
   amplification attack carried out by a malicious constrained device
   (e.g., ICMPv6 flooding, like Packet Too Big, or Parameter Problem on
   a multicast destination [<a href="rfc4732.html" title="&quot;Internet Denial-of-Service Considerations&quot;">RFC4732</a>]) since it does not require direct
   access to the constrained network.

   The feasibility of this attack, which disrupts availability of the
   targeted CoAP server, can be limited by access controlling the
   exposed multicast resources, so that only known/authorized users can
   access such URIs.




<span class="grey">Castellani, et al.           Standards Track                   [Page 29]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-30" id="page-30" href="#page-30" class="invisible"> </a>
<span class="grey"><a href="rfc8075.html">RFC 8075</a>                  HTTP-to-CoAP Mapping             February 2017</span>


<span class="h3"><a class="selflink" name="section-10.3" href="#section-10.3">10.3</a>.  Handling Secured Exchanges</span>

   An HTTP request can be sent to the HC Proxy over a secured
   connection.  However, there may not always exist a secure connection
   mapping to CoAP.  For example, a secure distribution method for
   multicast traffic is complex and may not be implemented (see
   [<a href="rfc7390.html" title="&quot;Group Communication for the Constrained Application Protocol (CoAP)&quot;">RFC7390</a>]).

   An HC Proxy should implement rules for security context translations.
   For example, all 'https' unicast requests are translated to 'coaps'
   requests, or 'https' requests are translated to unsecured 'coap'
   requests.  Another rule could specify the security policy and
   parameters used for Datagram Transport Layer Security (DTLS) sessions
   [<a href="rfc7925.html" title="&quot;Transport Layer Security (TLS) / Datagram Transport Layer Security (DTLS) Profiles for the Internet of Things&quot;">RFC7925</a>].  Such rules will largely depend on the application and
   network context in which the HC Proxy operates.  These rules should
   be configurable.

   It is RECOMMENDED that, by default, accessing a 'coaps' URI is only
   allowed from a corresponding 'https' URI.

   By default, an HC Proxy SHOULD reject any secured CoAP client request
   (i.e., one with a 'coaps' scheme) if there is no configured security
   policy mapping.  This recommendation may be relaxed in case the
   destination network is believed to be secured by other means.
   Assuming that CoAP nodes are isolated behind a firewall as in the HC
   Proxy deployment shown in Figure 1, the HC Proxy may be configured to
   translate the incoming HTTPS request using plain CoAP (NoSec mode).

<span class="h3"><a class="selflink" name="section-10.4" href="#section-10.4">10.4</a>.  URI Mapping</span>

   The following risks related to the URI mapping described in <a href="#section-5">Section 5</a>
   and its use by an HC Proxy have been identified:

   DoS attack on the constrained/CoAP network.
      Mitigation: by default, deny any Target CoAP URI whose authority
      is (or maps to) a multicast address.  Then explicitly whitelist
      multicast resources/authorities that are allowed to be
      dereferenced.  See also <a href="#section-8.4">Section 8.4</a>.

   Leaking information on the constrained/CoAP network resources and
      topology.
      Mitigation: by default, deny any Target CoAP URI (especially
      "/.well-known/core" is a resource to be protected), and then
      explicitly whitelist resources that are allowed to be seen by
      clients outside the constrained network.






<span class="grey">Castellani, et al.           Standards Track                   [Page 30]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-31" id="page-31" href="#page-31" class="invisible"> </a>
<span class="grey"><a href="rfc8075.html">RFC 8075</a>                  HTTP-to-CoAP Mapping             February 2017</span>


   The CoAP target resource is totally transparent from outside the
      constrained network.
      Mitigation: implement an HTTPS-only interface, which makes the
      Target CoAP URI totally opaque to a passive attacker outside the
      constrained network.

<span class="h2"><a class="selflink" name="section-11" href="#section-11">11</a>.  References</span>

<span class="h3"><a class="selflink" name="section-11.1" href="#section-11.1">11.1</a>.  Normative References</span>

   [<a name="ref-RFC2119" id="ref-RFC2119">RFC2119</a>]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", <a href="https://tools.ietf.org/html/bcp14">BCP 14</a>, <a href="rfc2119.html">RFC 2119</a>,
              DOI 10.17487/RFC2119, March 1997,
              &lt;<a href="http://www.rfc-editor.org/info/rfc2119">http://www.rfc-editor.org/info/rfc2119</a>&gt;.

   [<a name="ref-RFC3986" id="ref-RFC3986">RFC3986</a>]  Berners-Lee, T., Fielding, R., and L. Masinter, "Uniform
              Resource Identifier (URI): Generic Syntax", STD 66,
              <a href="rfc3986.html">RFC 3986</a>, DOI 10.17487/RFC3986, January 2005,
              &lt;<a href="http://www.rfc-editor.org/info/rfc3986">http://www.rfc-editor.org/info/rfc3986</a>&gt;.

   [<a name="ref-RFC4279" id="ref-RFC4279">RFC4279</a>]  Eronen, P., Ed. and H. Tschofenig, Ed., "Pre-Shared Key
              Ciphersuites for Transport Layer Security (TLS)",
              <a href="rfc4279.html">RFC 4279</a>, DOI 10.17487/RFC4279, December 2005,
              &lt;<a href="http://www.rfc-editor.org/info/rfc4279">http://www.rfc-editor.org/info/rfc4279</a>&gt;.

   [<a name="ref-RFC5234" id="ref-RFC5234">RFC5234</a>]  Crocker, D., Ed. and P. Overell, "Augmented BNF for Syntax
              Specifications: ABNF", STD 68, <a href="rfc5234.html">RFC 5234</a>,
              DOI 10.17487/RFC5234, January 2008,
              &lt;<a href="http://www.rfc-editor.org/info/rfc5234">http://www.rfc-editor.org/info/rfc5234</a>&gt;.

   [<a name="ref-RFC5246" id="ref-RFC5246">RFC5246</a>]  Dierks, T. and E. Rescorla, "The Transport Layer Security
              (TLS) Protocol Version 1.2", <a href="rfc5246.html">RFC 5246</a>,
              DOI 10.17487/RFC5246, August 2008,
              &lt;<a href="http://www.rfc-editor.org/info/rfc5246">http://www.rfc-editor.org/info/rfc5246</a>&gt;.

   [<a name="ref-RFC6570" id="ref-RFC6570">RFC6570</a>]  Gregorio, J., Fielding, R., Hadley, M., Nottingham, M.,
              and D. Orchard, "URI Template", <a href="rfc6570.html">RFC 6570</a>,
              DOI 10.17487/RFC6570, March 2012,
              &lt;<a href="http://www.rfc-editor.org/info/rfc6570">http://www.rfc-editor.org/info/rfc6570</a>&gt;.

   [<a name="ref-RFC6690" id="ref-RFC6690">RFC6690</a>]  Shelby, Z., "Constrained RESTful Environments (CoRE) Link
              Format", <a href="rfc6690.html">RFC 6690</a>, DOI 10.17487/RFC6690, August 2012,
              &lt;<a href="http://www.rfc-editor.org/info/rfc6690">http://www.rfc-editor.org/info/rfc6690</a>&gt;.

   [<a name="ref-RFC7230" id="ref-RFC7230">RFC7230</a>]  Fielding, R., Ed. and J. Reschke, Ed., "Hypertext Transfer
              Protocol (HTTP/1.1): Message Syntax and Routing",
              <a href="rfc7230.html">RFC 7230</a>, DOI 10.17487/RFC7230, June 2014,
              &lt;<a href="http://www.rfc-editor.org/info/rfc7230">http://www.rfc-editor.org/info/rfc7230</a>&gt;.



<span class="grey">Castellani, et al.           Standards Track                   [Page 31]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-32" id="page-32" href="#page-32" class="invisible"> </a>
<span class="grey"><a href="rfc8075.html">RFC 8075</a>                  HTTP-to-CoAP Mapping             February 2017</span>


   [<a name="ref-RFC7231" id="ref-RFC7231">RFC7231</a>]  Fielding, R., Ed. and J. Reschke, Ed., "Hypertext Transfer
              Protocol (HTTP/1.1): Semantics and Content", <a href="rfc7231.html">RFC 7231</a>,
              DOI 10.17487/RFC7231, June 2014,
              &lt;<a href="http://www.rfc-editor.org/info/rfc7231">http://www.rfc-editor.org/info/rfc7231</a>&gt;.

   [<a name="ref-RFC7232" id="ref-RFC7232">RFC7232</a>]  Fielding, R., Ed. and J. Reschke, Ed., "Hypertext Transfer
              Protocol (HTTP/1.1): Conditional Requests", <a href="rfc7232.html">RFC 7232</a>,
              DOI 10.17487/RFC7232, June 2014,
              &lt;<a href="http://www.rfc-editor.org/info/rfc7232">http://www.rfc-editor.org/info/rfc7232</a>&gt;.

   [<a name="ref-RFC7235" id="ref-RFC7235">RFC7235</a>]  Fielding, R., Ed. and J. Reschke, Ed., "Hypertext Transfer
              Protocol (HTTP/1.1): Authentication", <a href="rfc7235.html">RFC 7235</a>,
              DOI 10.17487/RFC7235, June 2014,
              &lt;<a href="http://www.rfc-editor.org/info/rfc7235">http://www.rfc-editor.org/info/rfc7235</a>&gt;.

   [<a name="ref-RFC7252" id="ref-RFC7252">RFC7252</a>]  Shelby, Z., Hartke, K., and C. Bormann, "The Constrained
              Application Protocol (CoAP)", <a href="rfc7252.html">RFC 7252</a>,
              DOI 10.17487/RFC7252, June 2014,
              &lt;<a href="http://www.rfc-editor.org/info/rfc7252">http://www.rfc-editor.org/info/rfc7252</a>&gt;.

   [<a name="ref-RFC7641" id="ref-RFC7641">RFC7641</a>]  Hartke, K., "Observing Resources in the Constrained
              Application Protocol (CoAP)", <a href="rfc7641.html">RFC 7641</a>,
              DOI 10.17487/RFC7641, September 2015,
              &lt;<a href="http://www.rfc-editor.org/info/rfc7641">http://www.rfc-editor.org/info/rfc7641</a>&gt;.

   [<a name="ref-RFC7959" id="ref-RFC7959">RFC7959</a>]  Bormann, C. and Z. Shelby, Ed., "Block-Wise Transfers in
              the Constrained Application Protocol (CoAP)", <a href="rfc7959.html">RFC 7959</a>,
              DOI 10.17487/RFC7959, August 2016,
              &lt;<a href="http://www.rfc-editor.org/info/rfc7959">http://www.rfc-editor.org/info/rfc7959</a>&gt;.

<span class="h3"><a class="selflink" name="section-11.2" href="#section-11.2">11.2</a>.  Informative References</span>

   [<a name="ref-CoRE-JSON-CBOR" id="ref-CoRE-JSON-CBOR">CoRE-JSON-CBOR</a>]
              Li, K., Rahman, A., and C. Bormann, "Representing CoRE
              Formats in JSON and CBOR", Work in Progress, <a href="https://tools.ietf.org/html/draft-ietf-core-links-json-06">draft-ietf-</a>
              <a href="https://tools.ietf.org/html/draft-ietf-core-links-json-06">core-links-json-06</a>, July 2016.

   [<a name="ref-CoRE-RD" id="ref-CoRE-RD">CoRE-RD</a>]  Shelby, Z., Koster, M., Bormann, C., and P. Stok, "CoRE
              Resource Directory", Work in Progress, <a href="https://tools.ietf.org/html/draft-ietf-core-resource-directory-09">draft-ietf-core-</a>
              <a href="https://tools.ietf.org/html/draft-ietf-core-resource-directory-09">resource-directory-09</a>, October 2016.

   [<a name="ref-Fielding" id="ref-Fielding">Fielding</a>] Fielding, R., "Architectural Styles and the Design of
              Network-based Software Architectures", PhD
              Dissertation, University of California, Irvine,
              ISBN 0-599-87118-0, 2000.






<span class="grey">Castellani, et al.           Standards Track                   [Page 32]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-33" id="page-33" href="#page-33" class="invisible"> </a>
<span class="grey"><a href="rfc8075.html">RFC 8075</a>                  HTTP-to-CoAP Mapping             February 2017</span>


   [<a name="ref-OpenSSL" id="ref-OpenSSL">OpenSSL</a>]  The OpenSSL Project, , "ca - sample minimal CA
              application", 2000-2016,
              &lt;<a href="https://www.openssl.org/docs/manmaster/man1/ca.html">https://www.openssl.org/docs/manmaster/man1/ca.html</a>&gt;.

   [<a name="ref-RFC2616" id="ref-RFC2616">RFC2616</a>]  Fielding, R., Gettys, J., Mogul, J., Frystyk, H.,
              Masinter, L., Leach, P., and T. Berners-Lee, "Hypertext
              Transfer Protocol -- HTTP/1.1", <a href="rfc2616.html">RFC 2616</a>,
              DOI 10.17487/RFC2616, June 1999,
              &lt;<a href="http://www.rfc-editor.org/info/rfc2616">http://www.rfc-editor.org/info/rfc2616</a>&gt;.

   [<a name="ref-RFC2663" id="ref-RFC2663">RFC2663</a>]  Srisuresh, P. and M. Holdrege, "IP Network Address
              Translator (NAT) Terminology and Considerations",
              <a href="rfc2663.html">RFC 2663</a>, DOI 10.17487/RFC2663, August 1999,
              &lt;<a href="http://www.rfc-editor.org/info/rfc2663">http://www.rfc-editor.org/info/rfc2663</a>&gt;.

   [<a name="ref-RFC3040" id="ref-RFC3040">RFC3040</a>]  Cooper, I., Melve, I., and G. Tomlinson, "Internet Web
              Replication and Caching Taxonomy", <a href="rfc3040.html">RFC 3040</a>,
              DOI 10.17487/RFC3040, January 2001,
              &lt;<a href="http://www.rfc-editor.org/info/rfc3040">http://www.rfc-editor.org/info/rfc3040</a>&gt;.

   [<a name="ref-RFC4732" id="ref-RFC4732">RFC4732</a>]  Handley, M., Ed., Rescorla, E., Ed., and IAB, "Internet
              Denial-of-Service Considerations", <a href="rfc4732.html">RFC 4732</a>,
              DOI 10.17487/RFC4732, December 2006,
              &lt;<a href="http://www.rfc-editor.org/info/rfc4732">http://www.rfc-editor.org/info/rfc4732</a>&gt;.

   [<a name="ref-RFC6454" id="ref-RFC6454">RFC6454</a>]  Barth, A., "The Web Origin Concept", <a href="rfc6454.html">RFC 6454</a>,
              DOI 10.17487/RFC6454, December 2011,
              &lt;<a href="http://www.rfc-editor.org/info/rfc6454">http://www.rfc-editor.org/info/rfc6454</a>&gt;.

   [<a name="ref-RFC7049" id="ref-RFC7049">RFC7049</a>]  Bormann, C. and P. Hoffman, "Concise Binary Object
              Representation (CBOR)", <a href="rfc7049.html">RFC 7049</a>, DOI 10.17487/RFC7049,
              October 2013, &lt;<a href="http://www.rfc-editor.org/info/rfc7049">http://www.rfc-editor.org/info/rfc7049</a>&gt;.

   [<a name="ref-RFC7228" id="ref-RFC7228">RFC7228</a>]  Bormann, C., Ersue, M., and A. Keranen, "Terminology for
              Constrained-Node Networks", <a href="rfc7228.html">RFC 7228</a>,
              DOI 10.17487/RFC7228, May 2014,
              &lt;<a href="http://www.rfc-editor.org/info/rfc7228">http://www.rfc-editor.org/info/rfc7228</a>&gt;.

   [<a name="ref-RFC7390" id="ref-RFC7390">RFC7390</a>]  Rahman, A., Ed. and E. Dijk, Ed., "Group Communication for
              the Constrained Application Protocol (CoAP)", <a href="rfc7390.html">RFC 7390</a>,
              DOI 10.17487/RFC7390, October 2014,
              &lt;<a href="http://www.rfc-editor.org/info/rfc7390">http://www.rfc-editor.org/info/rfc7390</a>&gt;.

   [<a name="ref-RFC7925" id="ref-RFC7925">RFC7925</a>]  Tschofenig, H., Ed. and T. Fossati, "Transport Layer
              Security (TLS) / Datagram Transport Layer Security (DTLS)
              Profiles for the Internet of Things", <a href="rfc7925.html">RFC 7925</a>,
              DOI 10.17487/RFC7925, July 2016,
              &lt;<a href="http://www.rfc-editor.org/info/rfc7925">http://www.rfc-editor.org/info/rfc7925</a>&gt;.



<span class="grey">Castellani, et al.           Standards Track                   [Page 33]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-34" id="page-34" href="#page-34" class="invisible"> </a>
<span class="grey"><a href="rfc8075.html">RFC 8075</a>                  HTTP-to-CoAP Mapping             February 2017</span>


   [<a name="ref-W3C.REC-html5-20141028" id="ref-W3C.REC-html5-20141028">W3C.REC-html5-20141028</a>]
              Hickson, I., Berjon, R., Faulkner, S., Leithead, T.,
              Navara, E., O'Connor, E., and S. Pfeiffer, "HTML5", World
              Wide Web Consortium Recommendation REC-html5-20141028,
              October 2014,
              &lt;<a href="http://www.w3.org/TR/2014/REC-html5-20141028">http://www.w3.org/TR/2014/REC-html5-20141028</a>&gt;.













































<span class="grey">Castellani, et al.           Standards Track                   [Page 34]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-35" id="page-35" href="#page-35" class="invisible"> </a>
<span class="grey"><a href="rfc8075.html">RFC 8075</a>                  HTTP-to-CoAP Mapping             February 2017</span>


<span class="h2"><a class="selflink" name="appendix-A" href="#appendix-A">Appendix A</a>.  Media Type Mapping Source Code</span>

#!/usr/bin/env python

import unittest
import re

class CoAPContentFormatRegistry(object):
    """Map an Internet media type (and optional inherent encoding) to a
       CoAP Content-Format.
    """
    TEXT_PLAIN = 0
    LINK_FORMAT = 40
    XML = 41
    OCTET_STREAM = 42
    EXI = 47
    JSON = 50
    CBOR = 60
    GROUP_JSON = 256

# <a href="http://www.iana.org/assignments/core-parameters">http://www.iana.org/assignments/core-parameters</a>
# as of 2016/10/24.
    LOOKUP_TABLE = {
        ("text/plain;charset=utf-8", None): TEXT_PLAIN,
        ("application/link-format", None): LINK_FORMAT,
        ("application/xml", None): XML,
        ("application/octet-stream", None): OCTET_STREAM,
        ("application/exi", None): EXI,
        ("application/json", None): JSON,
        ("application/cbor", None): CBOR,
        ("application/coap-group+json", "utf-8"): GROUP_JSON,
    }

    def lookup(self, media_type, encoding):
        """Return the CoAP Content-Format matching the supplied
           media type (and optional encoding), or None if no
           match can be found."""
        return CoAPContentFormatRegistry.LOOKUP_TABLE.get(
            (media_type, encoding), None)












<span class="grey">Castellani, et al.           Standards Track                   [Page 35]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-36" id="page-36" href="#page-36" class="invisible"> </a>
<span class="grey"><a href="rfc8075.html">RFC 8075</a>                  HTTP-to-CoAP Mapping             February 2017</span>


class LooseMediaTypeMapper(object):
    # Order matters in this table: more specific types have higher rank
    # compared to less specific types.
    # This code only performs a shallow validation of acceptable
    # characters and assumes overall validation of the media type and
    # subtype has been done beforehand.
    LOOKUP_TABLE = [
        (re.compile("application/.+\+xml$"), "application/xml"),
        (re.compile("application/.+\+json$"), "application/json"),
        (re.compile("application/.+\+cbor$"), "application/cbor"),
        (re.compile("text/xml$"), "application/xml"),
        (re.compile("text/[a-z\.\-\+]+$"), "text/plain;charset=utf-8"),
        (re.compile("[a-z]+/[a-z\.\-\+]+$"), "application/octet-stream")
    ]

    def lookup(self, media_type):
        """Return the best loose media type match available using
           the contents of LOOKUP_TABLE."""
        for entry in LooseMediaTypeMapper.LOOKUP_TABLE:
            if entry[0].match(media_type) is not None:
                return entry[1]
        return None


def mt2cf(media_type, encoding=None,
          coap_cf_registry=CoAPContentFormatRegistry(),
          loose_mapper=None):
    """Return a CoAP Content-Format given an Internet media type and
       its optional encoding.  The current (as of 2016/10/24) "CoAP
       Content-Formats" registry is supplied by default.  An optional
       'loose-mapping' implementation can be supplied by the caller."""
    assert media_type is not None
    assert coap_cf_registry is not None

    # Lookup the "CoAP Content-Formats" registry
    content_format = coap_cf_registry.lookup(media_type, encoding)

    # If an exact match is not found and a loose mapper has been
    # supplied, try to use it to get a media type with which to
    # retry the "CoAP Content-Formats" registry lookup.
    if content_format is None and loose_mapper is not None:
        content_format = coap_cf_registry.lookup(
            loose_mapper.lookup(media_type), encoding)

    return content_format






<span class="grey">Castellani, et al.           Standards Track                   [Page 36]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-37" id="page-37" href="#page-37" class="invisible"> </a>
<span class="grey"><a href="rfc8075.html">RFC 8075</a>                  HTTP-to-CoAP Mapping             February 2017</span>


class TestMT2CF(unittest.TestCase):

    def testMissingContentType(self):
        with self.assertRaises(AssertionError):
            mt2cf(None)

    def testMissingContentFormatRegistry(self):
        with self.assertRaises(AssertionError):
            mt2cf(None, coap_cf_registry=None)

    def testTextPlain(self):
        self.assertEqual(mt2cf("text/plain;charset=utf-8"),
                         CoAPContentFormatRegistry.TEXT_PLAIN)

    def testLinkFormat(self):
        self.assertEqual(mt2cf("application/link-format"),
                         CoAPContentFormatRegistry.LINK_FORMAT)

    def testXML(self):
        self.assertEqual(mt2cf("application/xml"),
                         CoAPContentFormatRegistry.XML)

    def testOctetStream(self):
        self.assertEqual(mt2cf("application/octet-stream"),
                         CoAPContentFormatRegistry.OCTET_STREAM)

    def testEXI(self):
        self.assertEqual(mt2cf("application/exi"),
                         CoAPContentFormatRegistry.EXI)

    def testJSON(self):
        self.assertEqual(mt2cf("application/json"),
                         CoAPContentFormatRegistry.JSON)

    def testCBOR(self):
        self.assertEqual(mt2cf("application/cbor"),
                         CoAPContentFormatRegistry.CBOR)

    def testCoAPGroupJSON(self):
        self.assertEqual(mt2cf("application/coap-group+json",
                               "utf-8"),
                         CoAPContentFormatRegistry.GROUP_JSON)

    def testUnknownMediaType(self):
        self.assertFalse(mt2cf("unknown/media-type"))






<span class="grey">Castellani, et al.           Standards Track                   [Page 37]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-38" id="page-38" href="#page-38" class="invisible"> </a>
<span class="grey"><a href="rfc8075.html">RFC 8075</a>                  HTTP-to-CoAP Mapping             February 2017</span>


    def testLooseXML1(self):
        self.assertEqual(
            mt2cf(
                "application/somesubtype+xml",
                loose_mapper=LooseMediaTypeMapper()),
            CoAPContentFormatRegistry.XML)

    def testLooseXML2(self):
        self.assertEqual(
            mt2cf(
                "text/xml",
                loose_mapper=LooseMediaTypeMapper()),
            CoAPContentFormatRegistry.XML)

    def testLooseJSON(self):
        self.assertEqual(
            mt2cf(
                "application/somesubtype+json",
                loose_mapper=LooseMediaTypeMapper()),
            CoAPContentFormatRegistry.JSON)

    def testLooseCBOR(self):
        self.assertEqual(
            mt2cf(
                "application/somesubtype+cbor",
                loose_mapper=LooseMediaTypeMapper()),
            CoAPContentFormatRegistry.CBOR)

    def testLooseText(self):
        self.assertEqual(
            mt2cf(
                "text/somesubtype",
                loose_mapper=LooseMediaTypeMapper()),
            CoAPContentFormatRegistry.TEXT_PLAIN)

    def testLooseUnknown(self):
        self.assertEqual(
            mt2cf(
                "application/somesubtype-of-some-sort+format",
                loose_mapper=LooseMediaTypeMapper()),
            CoAPContentFormatRegistry.OCTET_STREAM)

    def testLooseInvalidStartsWithNonAlpha(self):
        self.assertFalse(
            mt2cf(
                " application/somesubtype",
                loose_mapper=LooseMediaTypeMapper()))




<span class="grey">Castellani, et al.           Standards Track                   [Page 38]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-39" id="page-39" href="#page-39" class="invisible"> </a>
<span class="grey"><a href="rfc8075.html">RFC 8075</a>                  HTTP-to-CoAP Mapping             February 2017</span>


    def testLooseInvalidEndsWithUnexpectedChar(self):
        self.assertFalse(
            mt2cf(
                "application/somesubtype ",
                loose_mapper=LooseMediaTypeMapper()))

    def testLooseInvalidUnexpectedCharInTheMiddle(self):
        self.assertFalse(
            mt2cf(
                "application /somesubtype",
                loose_mapper=LooseMediaTypeMapper()))

    def testLooseInvalidNoSubType1(self):
        self.assertFalse(
            mt2cf(
                "application",
                loose_mapper=LooseMediaTypeMapper()))

    def testLooseInvalidNoSubType2(self):
        self.assertFalse(
            mt2cf(
                "application/",
                loose_mapper=LooseMediaTypeMapper()))

if __name__ == "__main__":
    unittest.main(verbosity=2)

Acknowledgments

   An initial version of Table 2 in <a href="#section-7">Section 7</a> has been provided in
   revision -05 of the CoRE CoAP I-D.  Special thanks to Peter van der
   Stok for countless comments and discussions on this document that
   contributed to its current structure and text.

   Thanks to Abhijan Bhattacharyya, Alexey Melnikov, Brian Frank,
   Carsten Bormann, Christian Amsuess, Christian Groves, Cullen
   Jennings, Dorothy Gellert, Francesco Corazza, Francis Dupont, Hannes
   Tschofenig, Jaime Jimenez, Kathleen Moriarty, Kepeng Li, Kerry Lynn,
   Klaus Hartke, Larry Masinter, Linyi Tian, Michele Rossi, Michele
   Zorzi, Nicola Bui, Peter Saint-Andre, Sean Leonard, Spencer Dawkins,
   Stephen Farrell, Suresh Krishnan, and Zach Shelby for helpful
   comments and discussions that have shaped the document.

   The research leading to these results has received funding from the
   European Community's Seventh Framework Programme [FP7/2007-2013]
   under grant agreement n.251557.





<span class="grey">Castellani, et al.           Standards Track                   [Page 39]</span></pre>
<hr class='noprint' style='width: 96ex;' align='left'/><!--NewPage--><pre class='newpage'><a name="page-40" id="page-40" href="#page-40" class="invisible"> </a>
<span class="grey"><a href="rfc8075.html">RFC 8075</a>                  HTTP-to-CoAP Mapping             February 2017</span>


Authors' Addresses

   Angelo P. Castellani
   University of Padova
   Via Gradenigo 6/B
   Padova  35131
   Italy

   Email: angelo@castellani.net


   Salvatore Loreto
   Ericsson
   Hirsalantie 11
   Jorvas  02420
   Finland

   Email: salvatore.loreto@ericsson.com


   Akbar Rahman
   InterDigital Communications, LLC
   1000 Sherbrooke Street West
   Montreal  H3A 3G4
   Canada

   Phone: +1 514 585 0761
   Email: Akbar.Rahman@InterDigital.com


   Thomas Fossati
   Nokia
   3 Ely Road
   Milton, Cambridge  CB24 6DD
   United Kingdom

   Email: thomas.fossati@nokia.com


   Esko Dijk
   Philips Lighting
   High Tech Campus 7
   Eindhoven  5656 AE
   The Netherlands

   Email: esko.dijk@philips.com





Castellani, et al.           Standards Track                   [Page 40]

</pre><br />
    <span class="noprint"><small><small>Html markup produced by rfcmarkup 1.129c, available from
      <a href="https://tools.ietf.org/tools/rfcmarkup/">https://tools.ietf.org/tools/rfcmarkup/</a>
    </small></small></span>
  </div>
</body>

<!-- Mirrored from tools.ietf.org/html/rfc8075 by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 28 Jul 2019 12:20:01 GMT -->
</html>
