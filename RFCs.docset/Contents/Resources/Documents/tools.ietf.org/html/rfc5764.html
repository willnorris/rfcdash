<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml"><!-- Mirrored from tools.ietf.org/html/rfc5764 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 14 Aug 2018 14:27:31 GMT --><!-- Added by HTTrack --><head><meta content="text/html;charset=utf-8" http-equiv="content-type"/><!-- /Added by HTTrack -->

    <meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
    <meta content="index,follow" name="robots"/>
    <meta content="rfcmarkup version 1.127" name="creator"/>
    <link href="http://purl.org/dc/elements/1.1/" rel="schema.DC"/>
<meta content="draft-mcgrew-tls-srtp" name="DC.Relation.Replaces"/>
<meta content="urn:ietf:rfc:5764" name="DC.Identifier"/>
<meta content="May, 2010" name="DC.Date.Issued"/>
<meta content="McGrew, David" name="DC.Creator"/>
<meta content="Rescorla, Eric" name="DC.Creator"/>
<meta content="This document describes a Datagram Transport Layer Security (DTLS)
extension to establish keys for Secure RTP (SRTP) and Secure RTP
Control Protocol (SRTCP) flows. DTLS keying happens on the media path,
independent of any out-of-band signalling channel present. [STANDARDS-
TRACK]" name="DC.Description.Abstract"/>
<meta content="Datagram Transport Layer Security (DTLS) Extension to Establish Keys for the Secure Real-time Transport Protocol (SRTP)" name="DC.Title"/>

    <link href="https://tools.ietf.org/images/rfc.png" rel="icon" type="image/png"/>
    <link href="https://tools.ietf.org/images/rfc.png" rel="shortcut icon" type="image/png"/>
    <title>RFC 5764 - Datagram Transport Layer Security (DTLS) Extension to Establish Keys for the Secure Real-time Transport Protocol (SRTP)</title>
    
    
    <style type="text/css">
	@media only screen 
	  and (min-width: 992px)
	  and (max-width: 1199px) {
	    body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 768px)
	  and (max-width: 991px) {
            body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 480px)
	  and (max-width: 767px) {
            body { font-size: 11pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (max-width: 479px) {
            body { font-size: 8pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-device-width : 375px) 
	  and (max-device-width : 667px) {
            body { font-size: 9.5pt; }
            div.content { width: 96ex; margin: 0 1px; }
        }
	@media only screen 
	  and (min-device-width: 1200px) {
            body { font-size: 10pt; margin: 0 4em; }
            div.content { width: 96ex; margin: 0; }
        }
        h1, h2, h3, h4, h5, h6, .h1, .h2, .h3, .h4, .h5, .h6 {
	    font-weight: bold;
            line-height: 0pt;
            display: inline;
            white-space: pre;
            font-family: monospace;
            font-size: 1em;
	    font-weight: bold;
        }
        pre {
            font-size: 1em;
            margin-top: 0px;
            margin-bottom: 0px;
        }
	.pre {
	    white-space: pre;
	    font-family: monospace;
	}
	.header{
	    font-weight: bold;
	}
        .newpage {
            page-break-before: always;
        }
        .invisible {
            text-decoration: none;
            color: white;
        }
        a.selflink {
          color: black;
          text-decoration: none;
        }
        @media print {
            body {
                font-family: monospace;
                font-size: 10.5pt;
            }
            h1, h2, h3, h4, h5, h6 {
                font-size: 1em;
            }
        
            a:link, a:visited {
                color: inherit;
                text-decoration: none;
            }
            .noprint {
                display: none;
            }
        }
	@media screen {
	    .grey, .grey a:link, .grey a:visited {
		color: #777;
	    }
            .docinfo {
                background-color: #EEE;
            }
            .top {
                border-top: 7px solid #EEE;
            }
            .bgwhite  { background-color: white; }
            .bgred    { background-color: #F44; }
            .bggrey   { background-color: #666; }
            .bgbrown  { background-color: #840; }            
            .bgorange { background-color: #FA0; }
            .bgyellow { background-color: #EE0; }
            .bgmagenta{ background-color: #F4F; }
            .bgblue   { background-color: #66F; }
            .bgcyan   { background-color: #4DD; }
            .bggreen  { background-color: #4F4; }

            .legend   { font-size: 90%; }
            .cplate   { font-size: 70%; border: solid grey 1px; }
	}
    </style>
    <!--[if IE]>
    <style>
    body {
       font-size: 13px;
       margin: 10px 10px;
    }
    </style>
    <![endif]-->

    <script type="text/javascript"><!--
    function addHeaderTags() {
	var spans = document.getElementsByTagName("span");
	for (var i=0; i < spans.length; i++) {
	    var elem = spans[i];
	    if (elem) {
		var level = elem.getAttribute("class");
                if (level == "h1" || level == "h2" || level == "h3" || level == "h4" || level == "h5" || level == "h6") {
                    elem.innerHTML = "<"+level+">"+elem.innerHTML+"</"+level+">";		
                }
	    }
	}
    }
    var legend_html = "Colour legend:<br />      <table>         <tr><td>Unknown:</td>                   <td><span class='cplate bgwhite'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft:</td>                     <td><span class='cplate bgred'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Informational:</td>             <td><span class='cplate bgorange'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Experimental:</td>              <td><span class='cplate bgyellow'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Best Common Practice:</td>      <td><span class='cplate bgmagenta'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Proposed Standard:</td>         <td><span class='cplate bgblue'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft Standard (old designation):</td> <td><span class='cplate bgcyan'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Internet Standard:</td>         <td><span class='cplate bggreen'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Historic:</td>                  <td><span class='cplate bggrey'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Obsolete:</td>                  <td><span class='cplate bgbrown'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>     </table>";
    function showElem(id) {
        var elem = document.getElementById(id);
        elem.innerHTML = eval(id+"_html");
        elem.style.visibility='visible';
    }
    function hideElem(id) {
        var elem = document.getElementById(id);
        elem.style.visibility='hidden';        
        elem.innerHTML = "";
    }
    // -->
    </script>
</head>
<body onload="addHeaderTags()">
  <div class="content">
   <div style="height: 13px;">
      <div class="pre noprint docinfo bgblue" onclick="showElem('legend');" onmouseout="hideElem('legend')" onmouseover="this.style.cursor='pointer';" style="height: 6px; position: absolute;" title="Click for colour legend.">                                                                        </div>
      <div class="docinfo noprint pre legend" id="legend" onmouseout="hideElem('legend');" onmouseover="showElem('legend');" style="position:absolute; top: 4px; left: 4ex; visibility:hidden; background-color: white; padding: 4px 9px 5px 7px; border: solid #345 1px; ">
      </div>
   </div>
<span class="pre noprint docinfo top">[<a href="index.html" title="Document search and retrieval page">Docs</a>] [<a href="https://tools.ietf.org/rfc/rfc5764.txt" title="Plaintext version of this document">txt</a>|<a href="https://tools.ietf.org/pdf/rfc5764" title="PDF version of this document">pdf</a>] [<a href="https://tools.ietf.org/html/draft-ietf-avt-dtls-srtp" title="draft-ietf-avt-dtls-srtp">draft-ietf-avt-...</a>] [<a href="https://datatracker.ietf.org/doc/rfc5764" title="IESG Datatracker information for this document">Tracker</a>] [<a href="https://tools.ietf.org/rfcdiff?difftype=--hwdiff&amp;url2=rfc5764" title="Inline diff (wdiff)">Diff1</a>] [<a href="https://tools.ietf.org/rfcdiff?url2=rfc5764" title="Side-by-side diff">Diff2</a>] [<a href="https://datatracker.ietf.org/ipr/search/?rfc=5764&amp;submit=rfc" title="IPR disclosures related to this document">IPR</a>] [<a href="https://www.rfc-editor.org/errata_search.php?rfc=5764">Errata</a>]</span><br/>
<span class="pre noprint docinfo">                                                                        </span><br/>
<span class="pre noprint docinfo">Updated by: <a href="rfc7983.html">7983</a>                                       PROPOSED STANDARD</span><br/>
<span class="pre noprint docinfo">                                                            <span style="color: #C00;">Errata Exist</span></span><br/>
<pre>Internet Engineering Task Force (IETF)                         D. McGrew
Request for Comments: 5764                                 Cisco Systems
Category: Standards Track                                    E. Rescorla
ISSN: 2070-1721                                               RTFM, Inc.
                                                                May 2010


  <span class="h1">Datagram Transport Layer Security (DTLS) Extension to Establish Keys</span>
           <span class="h1">for the Secure Real-time Transport Protocol (SRTP)</span>

Abstract

   This document describes a Datagram Transport Layer Security (DTLS)
   extension to establish keys for Secure RTP (SRTP) and Secure RTP
   Control Protocol (SRTCP) flows.  DTLS keying happens on the media
   path, independent of any out-of-band signalling channel present.

Status of This Memo

   This is an Internet Standards Track document.

   This document is a product of the Internet Engineering Task Force
   (IETF).  It represents the consensus of the IETF community.  It has
   received public review and has been approved for publication by the
   Internet Engineering Steering Group (IESG).  Further information on
   Internet Standards is available in <a href="rfc5741.html#section-2">Section 2 of RFC 5741</a>.

   Information about the current status of this document, any errata,
   and how to provide feedback on it may be obtained at
   <a href="http://www.rfc-editor.org/info/rfc5764">http://www.rfc-editor.org/info/rfc5764</a>.

Copyright Notice

   Copyright (c) 2010 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to <a href="https://tools.ietf.org/html/bcp78">BCP 78</a> and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (<a href="http://trustee.ietf.org/license-info">http://trustee.ietf.org/license-info</a>) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.






<span class="grey">McGrew &amp; Rescorla            Standards Track                    [Page 1]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-2" id="page-2" name="page-2"> </a>
<span class="grey"><a href="rfc5764.html">RFC 5764</a>                 SRTP Extension for DTLS                May 2010</span>


   This document may contain material from IETF Documents or IETF
   Contributions published or made publicly available before November
   10, 2008.  The person(s) controlling the copyright in some of this
   material may not have granted the IETF Trust the right to allow
   modifications of such material outside the IETF Standards Process.
   Without obtaining an adequate license from the person(s) controlling
   the copyright in such materials, this document may not be modified
   outside the IETF Standards Process, and derivative works of it may
   not be created outside the IETF Standards Process, except to format
   it for publication as an RFC or to translate it into languages other
   than English.

Table of Contents

   <a href="#section-1">1</a>.  Introduction . . . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-3">3</a>
   <a href="#section-2">2</a>.  Conventions Used In This Document  . . . . . . . . . . . . . .  <a href="#page-3">3</a>
   <a href="#section-3">3</a>.  Overview of DTLS-SRTP Operation  . . . . . . . . . . . . . . .  <a href="#page-4">4</a>
   <a href="#section-4">4</a>.  DTLS Extensions for SRTP Key Establishment . . . . . . . . . .  <a href="#page-5">5</a>
     <a href="#section-4.1">4.1</a>.  The use_srtp Extension . . . . . . . . . . . . . . . . . .  <a href="#page-5">5</a>
       <a href="#section-4.1.1">4.1.1</a>.  use_srtp Extension Definition  . . . . . . . . . . . .  <a href="#page-7">7</a>
       <a href="#section-4.1.2">4.1.2</a>.  SRTP Protection Profiles . . . . . . . . . . . . . . .  <a href="#page-8">8</a>
       <a href="#section-4.1.3">4.1.3</a>.  srtp_mki value . . . . . . . . . . . . . . . . . . . .  <a href="#page-9">9</a>
     <a href="#section-4.2">4.2</a>.  Key Derivation . . . . . . . . . . . . . . . . . . . . . . <a href="#page-10">10</a>
     <a href="#section-4.3">4.3</a>.  Key Scope  . . . . . . . . . . . . . . . . . . . . . . . . <a href="#page-12">12</a>
     <a href="#section-4.4">4.4</a>.  Key Usage Limitations  . . . . . . . . . . . . . . . . . . <a href="#page-12">12</a>
   <a href="#section-5">5</a>.  Use of RTP and RTCP over a DTLS-SRTP Channel . . . . . . . . . <a href="#page-13">13</a>
     <a href="#section-5.1">5.1</a>.  Data Protection  . . . . . . . . . . . . . . . . . . . . . <a href="#page-13">13</a>
       <a href="#section-5.1.1">5.1.1</a>.  Transmission . . . . . . . . . . . . . . . . . . . . . <a href="#page-13">13</a>
       <a href="#section-5.1.2">5.1.2</a>.  Reception  . . . . . . . . . . . . . . . . . . . . . . <a href="#page-13">13</a>
     <a href="#section-5.2">5.2</a>.  Rehandshake and Rekey  . . . . . . . . . . . . . . . . . . <a href="#page-16">16</a>
   <a href="#section-6">6</a>.  Multi-Party RTP Sessions . . . . . . . . . . . . . . . . . . . <a href="#page-17">17</a>
   <a href="#section-7">7</a>.  Security Considerations  . . . . . . . . . . . . . . . . . . . <a href="#page-17">17</a>
     <a href="#section-7.1">7.1</a>.  Security of Negotiation  . . . . . . . . . . . . . . . . . <a href="#page-17">17</a>
     <a href="#section-7.2">7.2</a>.  Framing Confusion  . . . . . . . . . . . . . . . . . . . . <a href="#page-17">17</a>
     <a href="#section-7.3">7.3</a>.  Sequence Number Interactions . . . . . . . . . . . . . . . <a href="#page-18">18</a>
       <a href="#section-7.3.1">7.3.1</a>.  Alerts . . . . . . . . . . . . . . . . . . . . . . . . <a href="#page-18">18</a>
       <a href="#section-7.3.2">7.3.2</a>.  Renegotiation  . . . . . . . . . . . . . . . . . . . . <a href="#page-18">18</a>
     <a href="#section-7.4">7.4</a>.  Decryption Cost  . . . . . . . . . . . . . . . . . . . . . <a href="#page-19">19</a>
   <a href="#section-8">8</a>.  Session Description for RTP/SAVP over DTLS . . . . . . . . . . <a href="#page-19">19</a>
   <a href="#section-9">9</a>.  IANA Considerations  . . . . . . . . . . . . . . . . . . . . . <a href="#page-20">20</a>
   <a href="#section-10">10</a>. Acknowledgments  . . . . . . . . . . . . . . . . . . . . . . . <a href="#page-20">20</a>
   <a href="#section-11">11</a>. References . . . . . . . . . . . . . . . . . . . . . . . . . . <a href="#page-21">21</a>
     <a href="#section-11.1">11.1</a>. Normative References . . . . . . . . . . . . . . . . . . . <a href="#page-21">21</a>
     <a href="#section-11.2">11.2</a>. Informative References . . . . . . . . . . . . . . . . . . <a href="#page-21">21</a>
   <a href="#appendix-A">Appendix A</a>.  Overview of DTLS  . . . . . . . . . . . . . . . . . . <a href="#page-23">23</a>
   <a href="#appendix-B">Appendix B</a>.  Performance of Multiple DTLS Handshakes . . . . . . . <a href="#page-24">24</a>





<span class="grey">McGrew &amp; Rescorla            Standards Track                    [Page 2]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-3" id="page-3" name="page-3"> </a>
<span class="grey"><a href="rfc5764.html">RFC 5764</a>                 SRTP Extension for DTLS                May 2010</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/1.%20%20Introduction"></a><a class="selflink" href="#section-1" name="section-1">1</a>.  Introduction</span>

   The Secure RTP (SRTP) profile [<a href="rfc3711.html" title='"The Secure Real-time Transport Protocol (SRTP)"'>RFC3711</a>] can provide confidentiality,
   message authentication, and replay protection to RTP data and RTP
   Control (RTCP) traffic.  SRTP does not provide key management
   functionality, but instead depends on external key management to
   exchange secret master keys, and to negotiate the algorithms and
   parameters for use with those keys.

   Datagram Transport Layer Security (DTLS) [<a href="rfc4347.html" title='"Datagram Transport Layer Security"'>RFC4347</a>] is a channel
   security protocol that offers integrated key management, parameter
   negotiation, and secure data transfer.  Because DTLS data transfer
   protocol is generic, it is less highly optimized for use with RTP
   than is SRTP, which has been specifically tuned for that purpose.

   This document describes DTLS-SRTP, a SRTP extension for DTLS that
   combines the performance and encryption flexibility benefits of SRTP
   with the flexibility and convenience of DTLS-integrated key and
   association management.  DTLS-SRTP can be viewed in two equivalent
   ways: as a new key management method for SRTP, and a new RTP-specific
   data format for DTLS.

   The key points of DTLS-SRTP are that:

   o  application data is protected using SRTP,

   o  the DTLS handshake is used to establish keying material,
      algorithms, and parameters for SRTP,

   o  a DTLS extension is used to negotiate SRTP algorithms, and

   o  other DTLS record-layer content types are protected using the
      ordinary DTLS record format.

   The remainder of this memo is structured as follows.  <a href="#section-2">Section 2</a>
   describes conventions used to indicate normative requirements.
   <a href="#section-3">Section 3</a> provides an overview of DTLS-SRTP operation.  <a href="#section-4">Section 4</a>
   specifies the DTLS extensions, while <a href="#section-5">Section 5</a> discusses how RTP and
   RTCP are transported over a DTLS-SRTP channel.  <a href="#section-6">Section 6</a> describes
   use with multi-party sessions.  <a href="#section-7">Section 7</a> and <a href="#section-9">Section 9</a> describe
   Security and IANA considerations.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/2.%20%20Conventions%20Used%20In%20This%20Document"></a><a class="selflink" href="#section-2" name="section-2">2</a>.  Conventions Used In This Document</span>

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in [<a href="rfc2119.html" title='"Key words for use in RFCs to Indicate Requirement Levels"'>RFC2119</a>].




<span class="grey">McGrew &amp; Rescorla            Standards Track                    [Page 3]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-4" id="page-4" name="page-4"> </a>
<span class="grey"><a href="rfc5764.html">RFC 5764</a>                 SRTP Extension for DTLS                May 2010</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/3.%20%20Overview%20of%20DTLS-SRTP%20Operation"></a><a class="selflink" href="#section-3" name="section-3">3</a>.  Overview of DTLS-SRTP Operation</span>

   DTLS-SRTP is defined for point-to-point media sessions, in which
   there are exactly two participants.  Each DTLS-SRTP session contains
   a single DTLS association (called a "connection" in TLS jargon), and
   either two SRTP contexts (if media traffic is flowing in both
   directions on the same host/port quartet) or one SRTP context (if
   media traffic is only flowing in one direction).  All SRTP traffic
   flowing over that pair in a given direction uses a single SRTP
   context.  A single DTLS-SRTP session only protects data carried over
   a single UDP source and destination port pair.

   The general pattern of DTLS-SRTP is as follows.  For each RTP or RTCP
   flow the peers do a DTLS handshake on the same source and destination
   port pair to establish a DTLS association.  Which side is the DTLS
   client and which side is the DTLS server must be established via some
   out-of-band mechanism such as SDP.  The keying material from that
   handshake is fed into the SRTP stack.  Once that association is
   established, RTP packets are protected (becoming SRTP) using that
   keying material.

   RTP and RTCP traffic is usually sent on two separate UDP ports.  When
   symmetric RTP [<a href="rfc4961.html" title='"Symmetric RTP / RTP Control Protocol (RTCP)"'>RFC4961</a>] is used, two bidirectional DTLS-SRTP sessions
   are needed, one for the RTP port, one for the RTCP port.  When RTP
   flows are not symmetric, four unidirectional DTLS-SRTP sessions are
   needed (for inbound and outbound RTP, and inbound and outbound RTCP).

   Symmetric RTP [<a href="rfc4961.html" title='"Symmetric RTP / RTP Control Protocol (RTCP)"'>RFC4961</a>] is the case in which there are two RTP
   sessions that have their source and destination ports and addresses
   reversed, in a manner similar to the way that a TCP connection uses
   its ports.  Each participant has an inbound RTP session and an
   outbound RTP session.  When symmetric RTP is used, a single DTLS-SRTP
   session can protect both of the RTP sessions.  It is RECOMMENDED that
   symmetric RTP be used with DTLS-SRTP.

   RTP and RTCP traffic MAY be multiplexed on a single UDP port
   [<a href="rfc5761.html" title='"Multiplexing RTP Data and Control Packets on a Single Port"'>RFC5761</a>].  In this case, both RTP and RTCP packets may be sent over
   the same DTLS-SRTP session, halving the number of DTLS-SRTP sessions
   needed.  This improves the cryptographic performance of DTLS, but may
   cause problems when RTCP and RTP are subject to different network
   treatment (e.g., for bandwidth reservation or scheduling reasons).

   Between a single pair of participants, there may be multiple media
   sessions.  There MUST be a separate DTLS-SRTP session for each
   distinct pair of source and destination ports used by a media session
   (though the sessions can share a single DTLS session and hence
   amortize the initial public key handshake!).




<span class="grey">McGrew &amp; Rescorla            Standards Track                    [Page 4]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-5" id="page-5" name="page-5"> </a>
<span class="grey"><a href="rfc5764.html">RFC 5764</a>                 SRTP Extension for DTLS                May 2010</span>


   A DTLS-SRTP session may be indicated by an external signaling
   protocol like SIP.  When the signaling exchange is integrity-
   protected (e.g., when SIP Identity protection via digital signatures
   is used), DTLS-SRTP can leverage this integrity guarantee to provide
   complete security of the media stream.  A description of how to
   indicate DTLS-SRTP sessions in SIP and SDP [<a href="rfc4566.html" title='"SDP: Session Description Protocol"'>RFC4566</a>], and how to
   authenticate the endpoints using fingerprints can be found in
   [<a href="rfc5763.html" title='"Framework for Establishing a Secure Real-time Transport Protocol (SRTP) Security Context Using Datagram Transport Layer Security (DTLS)"'>RFC5763</a>].

   In a naive implementation, when there are multiple media sessions,
   there is a new DTLS session establishment (complete with public key
   cryptography) for each media channel.  For example, a videophone may
   be sending both an audio stream and a video stream, each of which
   would use a separate DTLS session establishment exchange, which would
   proceed in parallel.  As an optimization, the DTLS-SRTP
   implementation SHOULD use the following strategy: a single DTLS
   association is established, and all other DTLS associations wait
   until that connection is established before proceeding with their
   handshakes.  This strategy allows the later sessions to use DTLS
   session resumption, which allows the amortization of the expensive
   public key cryptography operations over multiple DTLS handshakes.

   The SRTP keys used to protect packets originated by the client are
   distinct from the SRTP keys used to protect packets originated by the
   server.  All of the RTP sources originating on the client for the
   same channel use the same SRTP keys, and similarly, all of the RTP
   sources originating on the server for the same channel use the same
   SRTP keys.  The SRTP implementation MUST ensure that all of the
   synchronization source (SSRC) values for all of the RTP sources
   originating from the same device over the same channel are distinct,
   in order to avoid the "two-time pad" problem (as described in <a href="rfc3711.html#section-9.1">Section</a>
   <a href="rfc3711.html#section-9.1">9.1 of RFC 3711</a>).  Note that this is not an issue for separate media
   streams (on different host/port quartets) that use independent keying
   material even if an SSRC collision occurs.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/4.%20%20DTLS%20Extensions%20for%20SRTP%20Key%20Establishment"></a><a class="selflink" href="#section-4" name="section-4">4</a>.  DTLS Extensions for SRTP Key Establishment</span>

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.1.%20%20The%20use_srtp%20Extension"></a><a class="selflink" href="#section-4.1" name="section-4.1">4.1</a>.  The use_srtp Extension</span>

   In order to negotiate the use of SRTP data protection, clients
   include an extension of type "use_srtp" in the DTLS extended client
   hello.  This extension MUST only be used when the data being
   transported is RTP or RTCP [<a href="rfc3550.html" title='"RTP: A Transport Protocol for Real-Time Applications"'>RFC3550</a>].  The "extension_data" field of
   this extension contains the list of acceptable SRTP protection
   profiles, as indicated below.






<span class="grey">McGrew &amp; Rescorla            Standards Track                    [Page 5]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-6" id="page-6" name="page-6"> </a>
<span class="grey"><a href="rfc5764.html">RFC 5764</a>                 SRTP Extension for DTLS                May 2010</span>


   Servers that receive an extended hello containing a "use_srtp"
   extension can agree to use SRTP by including an extension of type
   "use_srtp", with the chosen protection profile in the extended server
   hello.  This process is shown below.

         Client                                               Server

         ClientHello + use_srtp       --------&gt;
                                              ServerHello + use_srtp
                                                        Certificate*
                                                  ServerKeyExchange*
                                                 CertificateRequest*
                                      &lt;--------      ServerHelloDone
         Certificate*
         ClientKeyExchange
         CertificateVerify*
         [ChangeCipherSpec]
         Finished                     --------&gt;
                                                  [ChangeCipherSpec]
                                      &lt;--------             Finished
         SRTP packets                 &lt;-------&gt;      SRTP packets

   Note that '*' indicates messages that are not always sent in DTLS.
   The CertificateRequest, client and server Certificates, and
   CertificateVerify will be sent in DTLS-SRTP.

   Once the "use_srtp" extension is negotiated, the RTP or RTCP
   application data is protected solely using SRTP.  Application data is
   never sent in DTLS record-layer "application_data" packets.  Rather,
   complete RTP or RTCP packets are passed to the DTLS stack, which
   passes them to the SRTP stack, which protects them appropriately.
   Note that if RTP/RTCP multiplexing [<a href="rfc5761.html" title='"Multiplexing RTP Data and Control Packets on a Single Port"'>RFC5761</a>] is in use, this means
   that RTP and RTCP packets may both be passed to the DTLS stack.
   Because the DTLS layer does not process the packets, it does not need
   to distinguish them.  The SRTP stack can use the procedures of
   [<a href="rfc5761.html" title='"Multiplexing RTP Data and Control Packets on a Single Port"'>RFC5761</a>] to distinguish RTP from RTCP.

   When the "use_srtp" extension is in effect, implementations must not
   place more than one application data "record" per datagram.  (This is
   only meaningful from the perspective of DTLS because SRTP is
   inherently oriented towards one payload per packet, but this is
   stated purely for clarification.)

   Data other than RTP/RTCP (i.e., TLS control messages) MUST use
   ordinary DTLS framing and MUST be placed in separate datagrams from
   SRTP data.





<span class="grey">McGrew &amp; Rescorla            Standards Track                    [Page 6]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-7" id="page-7" name="page-7"> </a>
<span class="grey"><a href="rfc5764.html">RFC 5764</a>                 SRTP Extension for DTLS                May 2010</span>


   A DTLS-SRTP handshake establishes one or more SRTP crypto contexts;
   however, they all have the same SRTP Protection Profile and Master
   Key Identifier (MKI), if any.  MKIs are used solely to distinguish
   the keying material and protection profiles between distinct
   handshakes, for instance, due to rekeying.  When an MKI is
   established in a DTLS-SRTP session, it MUST apply for all of the
   SSRCs within that session -- though a single endpoint may negotiate
   multiple DTLS-SRTP sessions due, for instance, to forking.  (Note
   that <a href="rfc3711.html">RFC 3711</a> allows packets within the same session but with
   different SSRCs to use MKIs differently; in contrast, DTLS-SRTP
   requires that MKIs and the keys that they are associated with have
   the same meaning and are uniform across the entire SRTP session.)

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/4.1.1.%20%20use_srtp%20Extension%20Definition"></a><a class="selflink" href="#section-4.1.1" name="section-4.1.1">4.1.1</a>.  use_srtp Extension Definition</span>

   The client MUST fill the extension_data field of the "use_srtp"
   extension with an UseSRTPData value (see <a href="#section-9">Section 9</a> for the
   registration):

      uint8 SRTPProtectionProfile[2];

      struct {
         SRTPProtectionProfiles SRTPProtectionProfiles;
         opaque srtp_mki&lt;0..255&gt;;
      } UseSRTPData;

      SRTPProtectionProfile SRTPProtectionProfiles&lt;2..2^16-1&gt;;

   The SRTPProtectionProfiles list indicates the SRTP protection
   profiles that the client is willing to support, listed in descending
   order of preference.  The srtp_mki value contains the SRTP Master Key
   Identifier (MKI) value (if any) that the client will use for his SRTP
   packets.  If this field is of zero length, then no MKI will be used.

   Note: for those unfamiliar with TLS syntax, "srtp_mki&lt;0..255&gt;"
   indicates a variable-length value with a length between 0 and 255
   (inclusive).  Thus, the MKI may be up to 255 bytes long.

   If the server is willing to accept the use_srtp extension, it MUST
   respond with its own "use_srtp" extension in the ExtendedServerHello.
   The extension_data field MUST contain a UseSRTPData value with a
   single SRTPProtectionProfile value that the server has chosen for use
   with this connection.  The server MUST NOT select a value that the
   client has not offered.  If there is no shared profile, the server
   SHOULD NOT return the use_srtp extension at which point the
   connection falls back to the negotiated DTLS cipher suite.  If that
   is not acceptable, the server SHOULD return an appropriate DTLS
   alert.



<span class="grey">McGrew &amp; Rescorla            Standards Track                    [Page 7]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-8" id="page-8" name="page-8"> </a>
<span class="grey"><a href="rfc5764.html">RFC 5764</a>                 SRTP Extension for DTLS                May 2010</span>


<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/4.1.2.%20%20SRTP%20Protection%20Profiles"></a><a class="selflink" href="#section-4.1.2" name="section-4.1.2">4.1.2</a>.  SRTP Protection Profiles</span>

   A DTLS-SRTP SRTP Protection Profile defines the parameters and
   options that are in effect for the SRTP processing.  This document
   defines the following SRTP protection profiles.

      SRTPProtectionProfile SRTP_AES128_CM_HMAC_SHA1_80 = {0x00, 0x01};
      SRTPProtectionProfile SRTP_AES128_CM_HMAC_SHA1_32 = {0x00, 0x02};
      SRTPProtectionProfile SRTP_NULL_HMAC_SHA1_80      = {0x00, 0x05};
      SRTPProtectionProfile SRTP_NULL_HMAC_SHA1_32      = {0x00, 0x06};

   The following list indicates the SRTP transform parameters for each
   protection profile.  The parameters cipher_key_length,
   cipher_salt_length, auth_key_length, and auth_tag_length express the
   number of bits in the values to which they refer.  The
   maximum_lifetime parameter indicates the maximum number of packets
   that can be protected with each single set of keys when the parameter
   profile is in use.  All of these parameters apply to both RTP and
   RTCP, unless the RTCP parameters are separately specified.

   All of the crypto algorithms in these profiles are from [<a href="rfc3711.html" title='"The Secure Real-time Transport Protocol (SRTP)"'>RFC3711</a>].

   SRTP_AES128_CM_HMAC_SHA1_80
         cipher: AES_128_CM
         cipher_key_length: 128
         cipher_salt_length: 112
         maximum_lifetime: 2^31
         auth_function: HMAC-SHA1
         auth_key_length: 160
         auth_tag_length: 80
   SRTP_AES128_CM_HMAC_SHA1_32
         cipher: AES_128_CM
         cipher_key_length: 128
         cipher_salt_length: 112
         maximum_lifetime: 2^31
         auth_function: HMAC-SHA1
         auth_key_length: 160
         auth_tag_length: 32
         RTCP auth_tag_length: 80
   SRTP_NULL_HMAC_SHA1_80
         cipher: NULL
         cipher_key_length: 0
         cipher_salt_length: 0
         maximum_lifetime: 2^31
         auth_function: HMAC-SHA1
         auth_key_length: 160
         auth_tag_length: 80




<span class="grey">McGrew &amp; Rescorla            Standards Track                    [Page 8]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-9" id="page-9" name="page-9"> </a>
<span class="grey"><a href="rfc5764.html">RFC 5764</a>                 SRTP Extension for DTLS                May 2010</span>


   SRTP_NULL_HMAC_SHA1_32
         cipher: NULL
         cipher_key_length: 0
         cipher_salt_length: 0
         maximum_lifetime: 2^31
         auth_function: HMAC-SHA1
         auth_key_length: 160
         auth_tag_length: 32
         RTCP auth_tag_length: 80

   With all of these SRTP Parameter profiles, the following SRTP options
   are in effect:

   o  The TLS PseudoRandom Function (PRF) is used to generate keys to
      feed into the SRTP Key Derivation Function (KDF).  When DTLS 1.2
      [<a href="#ref-DTLS1.2" title='"Datagram Transport Layer Security version 1.2"'>DTLS1.2</a>] is in use, the PRF is the one associated with the cipher
      suite.  Note that this specification is compatible with DTLS 1.0
      or DTLS 1.2

   o  The Key Derivation Rate (KDR) is equal to zero.  Thus, keys are
      not re-derived based on the SRTP sequence number.

   o  The key derivation procedures from <a href="#section-4.3">Section 4.3</a> with the AES-CM PRF
      from <a href="rfc3711.html">RFC 3711</a> are used.

   o  For all other parameters (in particular, SRTP replay window size
      and FEC order), the default values are used.

   If values other than the defaults for these parameters are required,
   they can be enabled by writing a separate specification specifying
   SDP syntax to signal them.

   Applications using DTLS-SRTP SHOULD coordinate the SRTP Protection
   Profiles between the DTLS-SRTP session that protects an RTP flow and
   the DTLS-SRTP session that protects the associated RTCP flow (in
   those cases in which the RTP and RTCP are not multiplexed over a
   common port).  In particular, identical ciphers SHOULD be used.

   New SRTPProtectionProfile values must be defined according to the
   "Specification Required" policy as defined by <a href="rfc5226.html">RFC 5226</a> [<a href="rfc5226.html" title='"Guidelines for Writing an IANA Considerations Section in RFCs"'>RFC5226</a>].
   See <a href="#section-9">Section 9</a> for IANA Considerations.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/4.1.3.%20%20srtp_mki%20value"></a><a class="selflink" href="#section-4.1.3" name="section-4.1.3">4.1.3</a>.  srtp_mki value</span>

   The srtp_mki value MAY be used to indicate the capability and desire
   to use the SRTP Master Key Identifier (MKI) field in the SRTP and
   SRTCP packets.  The MKI field indicates to an SRTP receiver which key
   was used to protect the packet that contains that field.  The



<span class="grey">McGrew &amp; Rescorla            Standards Track                    [Page 9]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-10" id="page-10" name="page-10"> </a>
<span class="grey"><a href="rfc5764.html">RFC 5764</a>                 SRTP Extension for DTLS                May 2010</span>


   srtp_mki field contains the value of the SRTP MKI which is associated
   with the SRTP master keys derived from this handshake.  Each SRTP
   session MUST have exactly one master key that is used to protect
   packets at any given time.  The client MUST choose the MKI value so
   that it is distinct from the last MKI value that was used, and it
   SHOULD make these values unique for the duration of the TLS session.

   Upon receipt of a "use_srtp" extension containing a "srtp_mki" field,
   the server MUST either (assuming it accepts the extension at all):

   1.  include a matching "srtp_mki" value in its "use_srtp" extension
       to indicate that it will make use of the MKI, or
   2.  return an empty "srtp_mki" value to indicate that it cannot make
       use of the MKI.

   If the client detects a nonzero-length MKI in the server's response
   that is different than the one the client offered, then the client
   MUST abort the handshake and SHOULD send an invalid_parameter alert.
   If the client and server agree on an MKI, all SRTP packets protected
   under the new security parameters MUST contain that MKI.

   Note that any given DTLS-SRTP session only has a single active MKI
   (if any).  Thus, at any given time, a set of endpoints will generally
   only be using one MKI (the major exception is during rehandshakes).

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.2.%20%20Key%20Derivation"></a><a class="selflink" href="#section-4.2" name="section-4.2">4.2</a>.  Key Derivation</span>

   When SRTP mode is in effect, different keys are used for ordinary
   DTLS record protection and SRTP packet protection.  These keys are
   generated using a TLS exporter [<a href="rfc5705.html" title='"Keying Material Exporters for Transport Layer Security (TLS)"'>RFC5705</a>] to generate

   2 * (SRTPSecurityParams.master_key_len +
        SRTPSecurityParams.master_salt_len) bytes of data

   which are assigned as shown below.  The per-association context value
   is empty.

   client_write_SRTP_master_key[SRTPSecurityParams.master_key_len];
   server_write_SRTP_master_key[SRTPSecurityParams.master_key_len];
   client_write_SRTP_master_salt[SRTPSecurityParams.master_salt_len];
   server_write_SRTP_master_salt[SRTPSecurityParams.master_salt_len];

   The exporter label for this usage is "EXTRACTOR-dtls_srtp".  (The
   "EXTRACTOR" prefix is for historical compatibility.)

   The four keying material values (the master key and master salt for
   each direction) are provided as inputs to the SRTP key derivation
   mechanism, as shown in Figure 1 and detailed below.  By default, the



<span class="grey">McGrew &amp; Rescorla            Standards Track                   [Page 10]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-11" id="page-11" name="page-11"> </a>
<span class="grey"><a href="rfc5764.html">RFC 5764</a>                 SRTP Extension for DTLS                May 2010</span>


   mechanism defined in <a href="rfc3711.html#section-4.3">Section 4.3 of [RFC3711]</a> is used, unless another
   key derivation mechanism is specified as part of an SRTP Protection
   Profile.

   The client_write_SRTP_master_key and client_write_SRTP_master_salt
   are provided to one invocation of the SRTP key derivation function,
   to generate the SRTP keys used to encrypt and authenticate packets
   sent by the client.  The server MUST only use these keys to decrypt
   and to check the authenticity of inbound packets.

   The server_write_SRTP_master_key and server_write_SRTP_master_salt
   are provided to one invocation of the SRTP key derivation function,
   to generate the SRTP keys used to encrypt and authenticate packets
   sent by the server.  The client MUST only use these keys to decrypt
   and to check the authenticity of inbound packets.

   TLS master
     secret   label
      |         |
      v         v
   +---------------+
   | TLS extractor |
   +---------------+
          |                                         +------+   SRTP
          +-&gt; client_write_SRTP_master_key ----+---&gt;| SRTP |-&gt; client
          |                                    | +-&gt;| KDF  |   write
          |                                    | |  +------+   keys
          |                                    | |
          +-&gt; server_write_SRTP_master_key --  | |  +------+   SRTCP
          |                                  \ \---&gt;|SRTCP |-&gt; client
          |                                   \  +-&gt;| KDF  |   write
          |                                    | |  +------+   keys
          +-&gt; client_write_SRTP_master_salt ---|-+
          |                                    |
          |                                    |    +------+   SRTP
          |                                    +---&gt;| SRTP |-&gt; server
          +-&gt; server_write_SRTP_master_salt -+-|---&gt;| KDF  |   write
                                             | |    +------+   keys
                                             | |
                                             | |    +------+   SRTCP
                                             | +---&gt;|SRTCP |-&gt; server
                                             +-----&gt;| KDF  |   write
                                                    +------+   keys

                Figure 1: The derivation of the SRTP keys.






<span class="grey">McGrew &amp; Rescorla            Standards Track                   [Page 11]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-12" id="page-12" name="page-12"> </a>
<span class="grey"><a href="rfc5764.html">RFC 5764</a>                 SRTP Extension for DTLS                May 2010</span>


   When both RTCP and RTP use the same source and destination ports,
   then both the SRTP and SRTCP keys are needed.  Otherwise, there are
   two DTLS-SRTP sessions, one of which protects the RTP packets and one
   of which protects the RTCP packets; each DTLS-SRTP session protects
   the part of an SRTP session that passes over a single source/
   destination transport address pair, as shown in Figure 2, independent
   of which SSRCs are used on that pair.  When a DTLS-SRTP session is
   protecting RTP, the SRTCP keys derived from the DTLS handshake are
   not needed and are discarded.  When a DTLS-SRTP session is protecting
   RTCP, the SRTP keys derived from the DTLS handshake are not needed
   and are discarded.

      Client            Server
     (Sender)         (Receiver)
   (1)   &lt;----- DTLS ------&gt;    src/dst = a/b and b/a
         ------ SRTP ------&gt;    src/dst = a/b, uses client write keys

   (2)   &lt;----- DTLS ------&gt;    src/dst = c/d and d/c
         ------ SRTCP -----&gt;    src/dst = c/d, uses client write keys
         &lt;----- SRTCP ------    src/dst = d/c, uses server write keys

     Figure 2: A DTLS-SRTP session protecting RTP (1) and another one
    protecting RTCP (2), showing the transport addresses and keys used.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.3.%20%20Key%20Scope"></a><a class="selflink" href="#section-4.3" name="section-4.3">4.3</a>.  Key Scope</span>

   Because of the possibility of packet reordering, DTLS-SRTP
   implementations SHOULD store multiple SRTP keys sets during a rekey
   in order to avoid the need for receivers to drop packets for which
   they lack a key.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.4.%20%20Key%20Usage%20Limitations"></a><a class="selflink" href="#section-4.4" name="section-4.4">4.4</a>.  Key Usage Limitations</span>

   The maximum_lifetime parameter in the SRTP protection profile
   indicates the maximum number of packets that can be protected with
   each single encryption and authentication key.  (Note that, since RTP
   and RTCP are protected with independent keys, those protocols are
   counted separately for the purposes of determining when a key has
   reached the end of its lifetime.)  Each profile defines its own
   limit.  When this limit is reached, a new DTLS session SHOULD be used
   to establish replacement keys, and SRTP implementations MUST NOT use
   the existing keys for the processing of either outbound or inbound
   traffic.








<span class="grey">McGrew &amp; Rescorla            Standards Track                   [Page 12]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-13" id="page-13" name="page-13"> </a>
<span class="grey"><a href="rfc5764.html">RFC 5764</a>                 SRTP Extension for DTLS                May 2010</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/5.%20%20Use%20of%20RTP%20and%20RTCP%20over%20a%20DTLS-SRTP%20Channel"></a><a class="selflink" href="#section-5" name="section-5">5</a>.  Use of RTP and RTCP over a DTLS-SRTP Channel</span>

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.1.%20%20Data%20Protection"></a><a class="selflink" href="#section-5.1" name="section-5.1">5.1</a>.  Data Protection</span>

   Once the DTLS handshake has completed, the peers can send RTP or RTCP
   over the newly created channel.  We describe the transmission process
   first followed by the reception process.

   Within each RTP session, SRTP processing MUST NOT take place before
   the DTLS handshake completes.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/5.1.1.%20%20Transmission"></a><a class="selflink" href="#section-5.1.1" name="section-5.1.1">5.1.1</a>.  Transmission</span>

   DTLS and TLS define a number of record content types.  In ordinary
   TLS/DTLS, all data is protected using the same record encoding and
   mechanisms.  When the mechanism described in this document is in
   effect, this is modified so that data written by upper-level protocol
   clients of DTLS is assumed to be RTP/RTP and is encrypted using SRTP
   rather than the standard TLS record encoding.

   When a user of DTLS wishes to send an RTP packet in SRTP mode, it
   delivers it to the DTLS implementation as an ordinary application
   data write (e.g., SSL_write()).  The DTLS implementation then invokes
   the processing described in <a href="rfc3711.html">RFC 3711</a>, Sections <a href="#section-3">3</a> and <a href="#section-4">4</a>.  The
   resulting SRTP packet is then sent directly on the wire as a single
   datagram with no DTLS framing.  This provides an encapsulation of the
   data that conforms to and interoperates with SRTP.  Note that the RTP
   sequence number rather than the DTLS sequence number is used for
   these packets.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/5.1.2.%20%20Reception"></a><a class="selflink" href="#section-5.1.2" name="section-5.1.2">5.1.2</a>.  Reception</span>

   When DTLS-SRTP is used to protect an RTP session, the RTP receiver
   needs to demultiplex packets that are arriving on the RTP port.
   Arriving packets may be of types RTP, DTLS, or STUN [<a href="rfc5389.html" title='"Session Traversal Utilities for NAT (STUN)"'>RFC5389</a>].  If
   these are the only types of packets present, the type of a packet can
   be determined by looking at its first byte.

   The process for demultiplexing a packet is as follows.  The receiver
   looks at the first byte of the packet.  If the value of this byte is
   0 or 1, then the packet is STUN.  If the value is in between 128 and
   191 (inclusive), then the packet is RTP (or RTCP, if both RTCP and
   RTP are being multiplexed over the same destination port).  If the
   value is between 20 and 63 (inclusive), the packet is DTLS.  This
   process is summarized in Figure 3.






<span class="grey">McGrew &amp; Rescorla            Standards Track                   [Page 13]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-14" id="page-14" name="page-14"> </a>
<span class="grey"><a href="rfc5764.html">RFC 5764</a>                 SRTP Extension for DTLS                May 2010</span>


                   +----------------+
                   | 127 &lt; B &lt; 192 -+--&gt; forward to RTP
                   |                |
       packet --&gt;  |  19 &lt; B &lt; 64  -+--&gt; forward to DTLS
                   |                |
                   |       B &lt; 2   -+--&gt; forward to STUN
                   +----------------+

    Figure 3: The DTLS-SRTP receiver's packet demultiplexing algorithm.
         Here the field B denotes the leading byte of the packet.

   If other packet types are to be multiplexed as well, implementors
   and/or designers SHOULD ensure that they can be demultiplexed from
   these three packet types.

   In some cases, there will be multiple DTLS-SRTP associations for a
   given SRTP endpoint.  For instance, if Alice makes a call that is SIP
   forked to both Bob and Charlie, she will use the same local host/port
   pair for both of them, as shown in Figure 4, where XXX and YYY
   represent different DTLS-SRTP associations.  (The SSRCs shown are the
   ones for data flowing to Alice.)

                                          Bob (192.0.2.1:6666)
                                         /
                                        /
                                       / SSRC=1
                                      /  DTLS-SRTP=XXX
                                     /
                                    v
               Alice (192.0.2.0:5555)
                                    ^
                                     \
                                      \  SSRC=2
                                       \ DTLS-SRTP=YYY
                                        \
                                         \
                                          Charlie (192.0.2.2:6666)

                 Figure 4: RTP sessions with SIP forking.

   Because DTLS operates on the host/port quartet, the DTLS association
   will still complete correctly, with the foreign host/port pair being
   used, to distinguish the associations.  However, in RTP the source
   host/port is not used and sessions are identified by the destination
   host/port and the SSRC.  Thus, some mechanism is needed to determine
   which SSRCs correspond to which DTLS associations.  The following
   method SHOULD be used.




<span class="grey">McGrew &amp; Rescorla            Standards Track                   [Page 14]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-15" id="page-15" name="page-15"> </a>
<span class="grey"><a href="rfc5764.html">RFC 5764</a>                 SRTP Extension for DTLS                May 2010</span>


   For each local host/port pair, the DTLS-SRTP implementation maintains
   a table listing all the SSRCs it knows about and the DTLS-SRTP
   associations they correspond to.  Initially, this table is empty.
   When an SRTP packet is received for a given RTP endpoint (destination
   IP/port pair), the following procedure is used:

   1.  If the SSRC is already known for that endpoint, then the
       corresponding DTLS-SRTP association and its keying material is
       used to decrypt and verify the packet.
   2.  If the SSRC is not known, then the receiver tries to decrypt it
       with the keying material corresponding to each DTLS-SRTP
       association for that endpoint.
   3.  If the decryption and verification succeeds (the authentication
       tag verifies), then an entry is placed in the table mapping the
       SSRC to that association.
   4.  If the decryption and verification fails, then the packet is
       silently discarded.
   5.  When a DTLS-SRTP association is closed (for instance, because the
       fork is abandoned), its entries MUST be removed from the mapping
       table.

   The average cost of this algorithm for a single SSRC is the
   decryption and verification time of a single packet times the number
   of valid DTLS-SRTP associations corresponding to a single receiving
   port on the host.  In practice, this means the number of forks; so in
   the case shown in Figure 4, that would be two.  This cost is only
   incurred once for any given SSRC, since afterwards that SSRC is
   placed in the map table and looked up immediately.  As with normal
   RTP, this algorithm allows new SSRCs to be introduced by the source
   at any time.  They will automatically be mapped to the correct DTLS
   association.

   Note that this algorithm explicitly allows multiple SSRCs to be sent
   from the same address/port pair.  One way in which this can happen is
   an RTP translator.  This algorithm will automatically assign the
   SSRCs to the correct associations.  Note that because the SRTP
   packets are cryptographically protected, such a translator must
   either share keying material with one endpoint or refrain from
   modifying the packets in a way which would cause the integrity check
   to fail.  This is a general property of SRTP and is not specific to
   DTLS-SRTP.

   There are two error cases that should be considered.  First, if an
   SSRC collision occurs, then only the packets from the first source
   will be processed.  When the packets from the second source arrive,
   the DTLS association with the first source will be used for
   decryption and verification, which will fail, and the packet will be
   discarded.  This is consistent with [<a href="rfc3550.html" title='"RTP: A Transport Protocol for Real-Time Applications"'>RFC3550</a>], which permits the



<span class="grey">McGrew &amp; Rescorla            Standards Track                   [Page 15]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-16" id="page-16" name="page-16"> </a>
<span class="grey"><a href="rfc5764.html">RFC 5764</a>                 SRTP Extension for DTLS                May 2010</span>


   receiver to keep the packets from one source and discard those from
   the other.  Of course the <a href="rfc3550.html">RFC 3550</a> SSRC collision detection and
   handling procedures MUST also be followed.

   Second, there may be cases where a malfunctioning source is sending
   corrupt packets that cannot be decrypted and verified.  In this case,
   the SSRC will never be entered into the mapping table because the
   decryption and verification always fails.  Receivers MAY keep records
   of unmapped SSRCs that consistently fail decryption and verification
   and abandon attempts to process them once they reach some limit.
   That limit MUST be large enough to account for the effects of
   transmission errors.  Entries MUST be pruned from this table when the
   relevant SRTP endpoint is deleted (e.g., the call ends) and SHOULD
   time out faster than that (we do not offer a hard recommendation but
   10 to 30 seconds seems appropriate) in order to allow for the
   possibility that the peer implementation has been corrected.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.2.%20%20Rehandshake%20and%20Rekey"></a><a class="selflink" href="#section-5.2" name="section-5.2">5.2</a>.  Rehandshake and Rekey</span>

   Rekeying in DTLS is accomplished by performing a new handshake over
   the existing DTLS channel.  That is, the handshake messages are
   protected by the existing DTLS cipher suite.  This handshake can be
   performed in parallel with data transport, so no interruption of the
   data flow is required.  Once the handshake is finished, the newly
   derived set of keys is used to protect all outbound packets, both
   DTLS and SRTP.

   Because of packet reordering, packets protected by the previous set
   of keys can appear on the wire after the handshake has completed.  To
   compensate for this fact, receivers SHOULD maintain both sets of keys
   for some time in order to be able to decrypt and verify older
   packets.  The keys should be maintained for the duration of the
   maximum segment lifetime (MSL).

   If an MKI is used, then the receiver should use the corresponding set
   of keys to process an incoming packet.  If no matching MKI is
   present, the packet MUST be rejected.  Otherwise, when a packet
   arrives after the handshake completed, a receiver SHOULD use the
   newly derived set of keys to process that packet unless there is an
   MKI.  (If the packet was protected with the older set of keys, this
   fact will become apparent to the receiver as an authentication
   failure will occur.)  If the authentication check on the packet fails
   and no MKI is being used, then the receiver MAY process the packet
   with the older set of keys.  If that authentication check indicates
   that the packet is valid, the packet should be accepted; otherwise,
   the packet MUST be discarded and rejected.





<span class="grey">McGrew &amp; Rescorla            Standards Track                   [Page 16]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-17" id="page-17" name="page-17"> </a>
<span class="grey"><a href="rfc5764.html">RFC 5764</a>                 SRTP Extension for DTLS                May 2010</span>


   Receivers MAY use the SRTP packet sequence number to aid in the
   selection of keys.  After a packet has been received and
   authenticated with the new key set, any packets with sequence numbers
   that are greater will also have been protected with the new key set.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/6.%20%20Multi-Party%20RTP%20Sessions"></a><a class="selflink" href="#section-6" name="section-6">6</a>.  Multi-Party RTP Sessions</span>

   Since DTLS is a point-to-point protocol, DTLS-SRTP is intended only
   to protect unicast RTP sessions.  This does not preclude its use with
   RTP mixers.  For example, a conference bridge may use DTLS-SRTP to
   secure the communication to and from each of the participants in a
   conference.  However, because each flow between an endpoint and a
   mixer has its own key, the mixer has to decrypt and then reencrypt
   the traffic for each recipient.

   A future specification may describe methods for sharing a single key
   between multiple DTLS-SRTP associations thus allowing conferencing
   systems to avoid the decrypt/reencrypt stage.  However, any system in
   which the media is modified (e.g., for level balancing or
   transcoding) will generally need to be performed on the plaintext and
   will certainly break the authentication tag, and therefore will
   require a decrypt/reencrypt stage.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/7.%20%20Security%20Considerations"></a><a class="selflink" href="#section-7" name="section-7">7</a>.  Security Considerations</span>

   The use of multiple data protection framings negotiated in the same
   handshake creates some complexities, which are discussed here.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/7.1.%20%20Security%20of%20Negotiation"></a><a class="selflink" href="#section-7.1" name="section-7.1">7.1</a>.  Security of Negotiation</span>

   One concern here is that attackers might be able to implement a bid-
   down attack forcing the peers to use ordinary DTLS rather than SRTP.
   However, because the negotiation of this extension is performed in
   the DTLS handshake, it is protected by the Finished messages.
   Therefore, any bid-down attack is automatically detected, which
   reduces this to a denial-of-service attack -- which can be mounted by
   any attacker who can control the channel.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/7.2.%20%20Framing%20Confusion"></a><a class="selflink" href="#section-7.2" name="section-7.2">7.2</a>.  Framing Confusion</span>

   Because two different framing formats are used, there is concern that
   an attacker could convince the receiver to treat an SRTP-framed RTP
   packet as a DTLS record (e.g., a handshake message) or vice versa.
   This attack is prevented by using different keys for Message
   Authentication Code (MAC) verification for each type of data.
   Therefore, this type of attack reduces to being able to forge a
   packet with a valid MAC, which violates a basic security invariant of
   both DTLS and SRTP.



<span class="grey">McGrew &amp; Rescorla            Standards Track                   [Page 17]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-18" id="page-18" name="page-18"> </a>
<span class="grey"><a href="rfc5764.html">RFC 5764</a>                 SRTP Extension for DTLS                May 2010</span>


   As an additional defense against injection into the DTLS handshake
   channel, the DTLS record type is included in the MAC.  Therefore, an
   SRTP record would be treated as an unknown type and ignored.  (See
   <a href="rfc5246.html#section-6">Section 6 of [RFC5246]</a>.)

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/7.3.%20%20Sequence%20Number%20Interactions"></a><a class="selflink" href="#section-7.3" name="section-7.3">7.3</a>.  Sequence Number Interactions</span>

   As described in <a href="#section-5.1.1">Section 5.1.1</a>, the SRTP and DTLS sequence number
   spaces are distinct.  This means that it is not possible to
   unambiguously order a given DTLS control record with respect to an
   SRTP packet.  In general, this is relevant in two situations: alerts
   and rehandshake.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/7.3.1.%20%20Alerts"></a><a class="selflink" href="#section-7.3.1" name="section-7.3.1">7.3.1</a>.  Alerts</span>

   Because DTLS handshake and change_cipher_spec messages share the same
   sequence number space as alerts, they can be ordered correctly.
   Because DTLS alerts are inherently unreliable and SHOULD NOT be
   generated as a response to data packets, reliable sequencing between
   SRTP packets and DTLS alerts is not an important feature.  However,
   implementations that wish to use DTLS alerts to signal problems with
   the SRTP encoding SHOULD simply act on alerts as soon as they are
   received and assume that they refer to the temporally contiguous
   stream.  Such implementations MUST check for alert retransmission and
   discard retransmitted alerts to avoid overreacting to replay attacks.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/7.3.2.%20%20Renegotiation"></a><a class="selflink" href="#section-7.3.2" name="section-7.3.2">7.3.2</a>.  Renegotiation</span>

   Because the rehandshake transition algorithm specified in <a href="#section-5.2">Section 5.2</a>
   requires trying multiple sets of keys if no MKI is used, it slightly
   weakens the authentication.  For instance, if an n-bit MAC is used
   and k different sets of keys are present, then the MAC is weakened by
   log_2(k) bits to n - log_2(k).  In practice, since the number of keys
   used will be very small and the MACs in use are typically strong (the
   default for SRTP is 80 bits), the decrease in security involved here
   is minimal.

   Another concern here is that this algorithm slightly increases the
   work factor on the receiver because it needs to attempt multiple
   validations.  However, again, the number of potential keys will be
   very small (and the attacker cannot force it to be larger) and this
   technique is already used for rollover counter management, so the
   authors do not consider this to be a serious flaw.








<span class="grey">McGrew &amp; Rescorla            Standards Track                   [Page 18]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-19" id="page-19" name="page-19"> </a>
<span class="grey"><a href="rfc5764.html">RFC 5764</a>                 SRTP Extension for DTLS                May 2010</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/7.4.%20%20Decryption%20Cost"></a><a class="selflink" href="#section-7.4" name="section-7.4">7.4</a>.  Decryption Cost</span>

   An attacker can impose computational costs on the receiver by sending
   superficially valid SRTP packets that do not decrypt correctly.  In
   general, encryption algorithms are so fast that this cost is
   extremely small compared to the bandwidth consumed.  The SSRC-DTLS
   mapping algorithm described in <a href="#section-5.1.2">Section 5.1.2</a> gives the attacker a
   slight advantage here because he can force the receiver to do more
   then one decryption per packet.  However, this advantage is modest
   because the number of decryptions that the receiver does is limited
   by the number of associations he has corresponding to a given
   destination host/port, which is typically quite small.  For
   comparison, a single 1024-bit RSA private key operation (the typical
   minimum cost to establish a DTLS-SRTP association) is hundreds of
   times as expensive as decrypting an SRTP packet.

   Implementations can detect this form of attack by keeping track of
   the number of SRTP packets that are observed with unknown SSRCs and
   that fail the authentication tag check.  If under such attack,
   implementations SHOULD prioritize decryption and verification of
   packets that either have known SSRCs or come from source addresses
   that match those of peers with which it has DTLS-SRTP associations.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/8.%20%20Session%20Description%20for%20RTP%2FSAVP%20over%20DTLS"></a><a class="selflink" href="#section-8" name="section-8">8</a>.  Session Description for RTP/SAVP over DTLS</span>

   This specification defines new tokens to describe the protocol used
   in SDP media descriptions ("m=" lines and their associated
   parameters).  The new values defined for the proto field are:

   o  When a RTP/SAVP or RTP/SAVPF [<a href="rfc5124.html" title='"Extended Secure RTP Profile for Real-time Transport Control Protocol (RTCP)- Based Feedback (RTP/SAVPF)"'>RFC5124</a>] stream is transported over
      DTLS with the Datagram Congestion Control Protocol (DCCP), then
      the token SHALL be DCCP/TLS/RTP/SAVP or DCCP/TLS/RTP/SAVPF
      respectively.

   o  When a RTP/SAVP or RTP/SAVPF stream is transported over DTLS with
      UDP, the token SHALL be UDP/TLS/RTP/SAVP or UDP/TLS/RTP/SAVPF
      respectively.

   The "fmt" parameter SHALL be as defined for RTP/SAVP.

   See [<a href="rfc5763.html" title='"Framework for Establishing a Secure Real-time Transport Protocol (SRTP) Security Context Using Datagram Transport Layer Security (DTLS)"'>RFC5763</a>] for how to use offer/answer with DTLS-SRTP.

   This document does not specify how to protect RTP data transported
   over TCP.  Potential approaches include carrying the RTP over TLS
   over TCP (see [<a href="#ref-SRTP-NOT-MAND" title='"Why RTP Does Not Mandate a Single Security Mechanism"'>SRTP-NOT-MAND</a>]) or using a mechanism similar to that
   in this document over TCP, either via TLS or DTLS, with DTLS being
   used for consistency between reliable and unreliable transports.  In




<span class="grey">McGrew &amp; Rescorla            Standards Track                   [Page 19]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-20" id="page-20" name="page-20"> </a>
<span class="grey"><a href="rfc5764.html">RFC 5764</a>                 SRTP Extension for DTLS                May 2010</span>


   the latter case, it would be necessary to profile DTLS so that
   fragmentation and retransmissions no longer occurred.  In either
   case, a new document would be required.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/9.%20%20IANA%20Considerations"></a><a class="selflink" href="#section-9" name="section-9">9</a>.  IANA Considerations</span>

   This document adds a new extension for DTLS, in accordance with
   [<a href="rfc5246.html" title='"The Transport Layer Security (TLS) Protocol Version 1.2"'>RFC5246</a>]:
        enum { use_srtp (14) } ExtensionType;

   This extension MUST only be used with DTLS, and not with TLS
   [<a href="rfc4572.html" title='"Connection-Oriented Media Transport over the Transport Layer Security (TLS) Protocol in the Session Description Protocol (SDP)"'>RFC4572</a>], which specifies that TLS can be used over TCP but does not
   address TCP for RTP/SAVP.

   <a href="#section-4.1.2">Section 4.1.2</a> requires that all SRTPProtectionProfile values be
   defined by <a href="rfc5226.html">RFC 5226</a> "Specification Required".  IANA has created a
   DTLS SRTPProtectionProfile registry initially populated with values
   from <a href="#section-4.1.2">Section 4.1.2</a> of this document.  Future values MUST be allocated
   via the "Specification Required" profile of [<a href="rfc5226.html" title='"Guidelines for Writing an IANA Considerations Section in RFCs"'>RFC5226</a>].

   This specification updates the "Session Description Protocol (SDP)
   Parameters" registry as defined in <a href="rfc4566.html#section-8.2.2">Section 8.2.2 of [RFC4566]</a>.
   Specifically, it adds the following values to the table for the
   "proto" field.

           Type            SDP Name                     Reference
           ----            ------------------           ---------
           proto           UDP/TLS/RTP/SAVP             [<a href="rfc5764.html">RFC5764</a>]
           proto           DCCP/TLS/RTP/SAVP            [<a href="rfc5764.html">RFC5764</a>]

           proto           UDP/TLS/RTP/SAVPF            [<a href="rfc5764.html">RFC5764</a>]
           proto           DCCP/TLS/RTP/SAVPF           [<a href="rfc5764.html">RFC5764</a>]

   IANA has registered the "EXTRACTOR-dtls_srtp" value in the TLS
   Extractor Label Registry to correspond to this specification.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/10.%20%20Acknowledgments"></a><a class="selflink" href="#section-10" name="section-10">10</a>.  Acknowledgments</span>

   Special thanks to Flemming Andreasen, Francois Audet, Pasi Eronen,
   Roni Even, Jason Fischl, Cullen Jennings, Colin Perkins, Dan Wing,
   and Ben Campbell for input, discussions, and guidance.  Pasi Eronen
   provided Figure 1.









<span class="grey">McGrew &amp; Rescorla            Standards Track                   [Page 20]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-21" id="page-21" name="page-21"> </a>
<span class="grey"><a href="rfc5764.html">RFC 5764</a>                 SRTP Extension for DTLS                May 2010</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/11.%20%20References"></a><a class="selflink" href="#section-11" name="section-11">11</a>.  References</span>

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/11.1.%20%20Normative%20References"></a><a class="selflink" href="#section-11.1" name="section-11.1">11.1</a>.  Normative References</span>

   [<a id="ref-RFC2119" name="ref-RFC2119">RFC2119</a>]        Bradner, S., "Key words for use in RFCs to Indicate
                    Requirement Levels", <a href="https://tools.ietf.org/html/bcp14">BCP 14</a>, <a href="rfc2119.html">RFC 2119</a>, March 1997.

   [<a id="ref-RFC3711" name="ref-RFC3711">RFC3711</a>]        Baugher, M., McGrew, D., Naslund, M., Carrara, E.,
                    and K. Norrman, "The Secure Real-time Transport
                    Protocol (SRTP)", <a href="rfc3711.html">RFC 3711</a>, March 2004.

   [<a id="ref-RFC4347" name="ref-RFC4347">RFC4347</a>]        Rescorla, E. and N. Modadugu, "Datagram Transport
                    Layer Security", <a href="rfc4347.html">RFC 4347</a>, April 2006.

   [<a id="ref-RFC4961" name="ref-RFC4961">RFC4961</a>]        Wing, D., "Symmetric RTP / RTP Control Protocol
                    (RTCP)", <a href="https://tools.ietf.org/html/bcp131">BCP 131</a>, <a href="rfc4961.html">RFC 4961</a>, July 2007.

   [<a id="ref-RFC5246" name="ref-RFC5246">RFC5246</a>]        Dierks, T. and E. Rescorla, "The Transport Layer
                    Security (TLS) Protocol Version 1.2", <a href="rfc5246.html">RFC 5246</a>,
                    August 2008.

   [<a id="ref-RFC5705" name="ref-RFC5705">RFC5705</a>]        Rescorla, E., "Keying Material Exporters for
                    Transport Layer Security (TLS)", <a href="rfc5705.html">RFC 5705</a>,
                    March 2010.

   [<a id="ref-RFC5761" name="ref-RFC5761">RFC5761</a>]        Perkins, C. and M. Westerlund, "Multiplexing RTP
                    Data and Control Packets on a Single Port",
                    <a href="rfc5761.html">RFC 5761</a>, April 2010.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/11.2.%20%20Informative%20References"></a><a class="selflink" href="#section-11.2" name="section-11.2">11.2</a>.  Informative References</span>

   [<a id="ref-DTLS1.2" name="ref-DTLS1.2">DTLS1.2</a>]        Rescorla, E. and N. Modadugu, "Datagram Transport
                    Layer Security version 1.2", Work in Progress,
                    October 2009.

   [<a id="ref-RFC3550" name="ref-RFC3550">RFC3550</a>]        Schulzrinne, H., Casner, S., Frederick, R., and V.
                    Jacobson, "RTP: A Transport Protocol for Real-Time
                    Applications", STD 64, <a href="rfc3550.html">RFC 3550</a>, July 2003.

   [<a id="ref-RFC4566" name="ref-RFC4566">RFC4566</a>]        Handley, M., Jacobson, V., and C. Perkins, "SDP:
                    Session Description Protocol", <a href="rfc4566.html">RFC 4566</a>, July 2006.

   [<a id="ref-RFC4572" name="ref-RFC4572">RFC4572</a>]        Lennox, J., "Connection-Oriented Media Transport
                    over the Transport Layer Security (TLS) Protocol in
                    the Session Description Protocol (SDP)", <a href="rfc4572.html">RFC 4572</a>,
                    July 2006.





<span class="grey">McGrew &amp; Rescorla            Standards Track                   [Page 21]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-22" id="page-22" name="page-22"> </a>
<span class="grey"><a href="rfc5764.html">RFC 5764</a>                 SRTP Extension for DTLS                May 2010</span>


   [<a id="ref-RFC5124" name="ref-RFC5124">RFC5124</a>]        Ott, J. and E. Carrara, "Extended Secure RTP Profile
                    for Real-time Transport Control Protocol (RTCP)-
                    Based Feedback (RTP/SAVPF)", <a href="rfc5124.html">RFC 5124</a>,
                    February 2008.

   [<a id="ref-RFC5226" name="ref-RFC5226">RFC5226</a>]        Narten, T. and H. Alvestrand, "Guidelines for
                    Writing an IANA Considerations Section in RFCs",
                    <a href="https://tools.ietf.org/html/bcp26">BCP 26</a>, <a href="rfc5226.html">RFC 5226</a>, May 2008.

   [<a id="ref-RFC5389" name="ref-RFC5389">RFC5389</a>]        Rosenberg, J., Mahy, R., Matthews, P., and D. Wing,
                    "Session Traversal Utilities for NAT (STUN)",
                    <a href="rfc5389.html">RFC 5389</a>, October 2008.

   [<a id="ref-RFC5763" name="ref-RFC5763">RFC5763</a>]        Fischl, J., Tschofenig, H., and E. Rescorla,
                    "Framework for Establishing a Secure Real-time
                    Transport Protocol (SRTP) Security Context Using
                    Datagram Transport Layer Security (DTLS)", <a href="rfc5763.html">RFC 5763</a>,
                    May 2010.

   [<a id="ref-SRTP-NOT-MAND" name="ref-SRTP-NOT-MAND">SRTP-NOT-MAND</a>]  Perkins, C. and M. Westerlund, "Why RTP Does Not
                    Mandate a Single Security Mechanism", Work in
                    Progress, January 2010.





























<span class="grey">McGrew &amp; Rescorla            Standards Track                   [Page 22]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-23" id="page-23" name="page-23"> </a>
<span class="grey"><a href="rfc5764.html">RFC 5764</a>                 SRTP Extension for DTLS                May 2010</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/Appendix%20A.%20%20Overview%20of%20DTLS"></a><a class="selflink" href="#appendix-A" name="appendix-A">Appendix A</a>.  Overview of DTLS</span>

   This section provides a brief overview of Datagram TLS (DTLS) for
   those who are not familiar with it.  DTLS is a channel security
   protocol based on the well-known Transport Layer Security (TLS)
   [<a href="rfc5246.html" title='"The Transport Layer Security (TLS) Protocol Version 1.2"'>RFC5246</a>] protocol.  Where TLS depends on a reliable transport
   channel (typically TCP), DTLS has been adapted to support unreliable
   transports such as UDP.  Otherwise, DTLS is nearly identical to TLS
   and generally supports the same cryptographic mechanisms.

   Each DTLS association begins with a handshake exchange (shown below)
   during which the peers authenticate each other and negotiate
   algorithms, modes, and other parameters and establish shared keying
   material, as shown below.  In order to support unreliable transport,
   each side maintains retransmission timers to provide reliable
   delivery of these messages.  Once the handshake is completed,
   encrypted data may be sent.

         Client                                               Server

         ClientHello                  --------&gt;
                                                         ServerHello
                                                        Certificate*
                                                  ServerKeyExchange*
                                                 CertificateRequest*
                                      &lt;--------      ServerHelloDone
         Certificate*
         ClientKeyExchange
         CertificateVerify*
         [ChangeCipherSpec]
         Finished                     --------&gt;
                                                  [ChangeCipherSpec]
                                      &lt;--------             Finished
         Application Data             &lt;-------&gt;     Application Data

               '*' indicates messages that are not always sent.

        Figure 5: Basic DTLS Handshake Exchange (after [<a href="rfc4347.html" title='"Datagram Transport Layer Security"'>RFC4347</a>]).

   Application data is protected by being sent as a series of DTLS
   "records".  These records are independent and can be processed
   correctly even in the face of loss or reordering.  In DTLS-SRTP, this
   record protocol is replaced with SRTP [<a href="rfc3711.html" title='"The Secure Real-time Transport Protocol (SRTP)"'>RFC3711</a>]








<span class="grey">McGrew &amp; Rescorla            Standards Track                   [Page 23]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-24" id="page-24" name="page-24"> </a>
<span class="grey"><a href="rfc5764.html">RFC 5764</a>                 SRTP Extension for DTLS                May 2010</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/Appendix%20B.%20%20Performance%20of%20Multiple%20DTLS%20Handshakes"></a><a class="selflink" href="#appendix-B" name="appendix-B">Appendix B</a>.  Performance of Multiple DTLS Handshakes</span>

   Standard practice for security protocols such as TLS, DTLS, and SSH,
   which do inline key management, is to create a separate security
   association for each underlying network channel (TCP connection, UDP
   host/port quartet, etc.).  This has dual advantages of simplicity and
   independence of the security contexts for each channel.

   Three concerns have been raised about the overhead of this strategy
   in the context of RTP security.  The first concern is the additional
   performance overhead of doing a separate public key operation for
   each channel.  The conventional procedure here (used in TLS and DTLS)
   is to establish a master context that can then be used to derive
   fresh traffic keys for new associations.  In TLS/DTLS, this is called
   "session resumption" and can be transparently negotiated between the
   peers.

   The second concern is network bandwidth overhead for the
   establishment of subsequent connections and for rehandshake (for
   rekeying) for existing connections.  In particular, there is a
   concern that the channels will have very narrow capacity requirements
   allocated entirely to media that will be overflowed by the
   rehandshake.  Measurements of the size of the rehandshake (with
   resumption) in TLS indicate that it is about 300-400 bytes if a full
   selection of cipher suites is offered.  (The size of a full handshake
   is approximately 1-2 kilobytes larger because of the certificate and
   keying material exchange.)

   The third concern is the additional round-trips associated with
   establishing the second, third, ... channels.  In TLS/DTLS, these can
   all be done in parallel, but in order to take advantage of session
   resumption they should be done after the first channel is
   established.  For two channels, this provides a ladder diagram
   something like this (parenthetical numbers are media channel numbers)

















<span class="grey">McGrew &amp; Rescorla            Standards Track                   [Page 24]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-25" id="page-25" name="page-25"> </a>
<span class="grey"><a href="rfc5764.html">RFC 5764</a>                 SRTP Extension for DTLS                May 2010</span>


   Alice                                   Bob
   -------------------------------------------
                      &lt;-       ClientHello (1)
   ServerHello (1)    -&gt;
   Certificate (1)
   ServerHelloDone (1)
                      &lt;- ClientKeyExchange (1)
                          ChangeCipherSpec (1)
                                  Finished (1)
   ChangeCipherSpec (1)-&gt;
   Finished         (1)-&gt;
                                                &lt;--- Channel 1 ready

                      &lt;-       ClientHello (2)
   ServerHello (2)    -&gt;
   ChangeCipherSpec(2)-&gt;
   Finished(2)        -&gt;
                      &lt;-  ChangeCipherSpec (2)
                                  Finished (2)
                                                &lt;--- Channel 2 ready

                Figure 6: Parallel DTLS-SRTP negotiations.

   So, there is an additional 1 RTT (round-trip time) after Channel 1 is
   ready before Channel 2 is ready.  If the peers are potentially
   willing to forego resumption, they can interlace the handshakes, like
   so:
























<span class="grey">McGrew &amp; Rescorla            Standards Track                   [Page 25]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-26" id="page-26" name="page-26"> </a>
<span class="grey"><a href="rfc5764.html">RFC 5764</a>                 SRTP Extension for DTLS                May 2010</span>


   Alice                                   Bob
   -------------------------------------------
                      &lt;-       ClientHello (1)
   ServerHello (1)    -&gt;
   Certificate (1)
   ServerHelloDone (1)
                      &lt;- ClientKeyExchange (1)
                          ChangeCipherSpec (1)
                                  Finished (1)
                      &lt;-       ClientHello (2)
   ChangeCipherSpec (1)-&gt;
   Finished         (1)-&gt;
                                                &lt;--- Channel 1 ready
   ServerHello (2)    -&gt;
   ChangeCipherSpec(2)-&gt;
   Finished(2)        -&gt;
                      &lt;-  ChangeCipherSpec (2)
                                  Finished (2)
                                                &lt;--- Channel 2 ready

               Figure 7: Interlaced DTLS-SRTP negotiations.

   In this case, the channels are ready contemporaneously, but if a
   message in handshake (1) is lost, then handshake (2) requires either
   a full rehandshake or that Alice be clever and queue the resumption
   attempt until the first handshake completes.  Note that just dropping
   the packet works as well, since Bob will retransmit.

Authors' Addresses

   David McGrew
   Cisco Systems
   510 McCarthy Blvd.
   Milpitas, CA  95305
   USA

   EMail: mcgrew@cisco.com


   Eric Rescorla
   RTFM, Inc.
   2064 Edgewood Drive
   Palo Alto, CA  94303
   USA

   EMail: ekr@rtfm.com





McGrew &amp; Rescorla            Standards Track                   [Page 26]

</pre><br/>
    <span class="noprint"><small><small>Html markup produced by rfcmarkup 1.127, available from
      <a href="https://tools.ietf.org/tools/rfcmarkup/">https://tools.ietf.org/tools/rfcmarkup/</a>
    </small></small></span>
  </div>




</body><!-- Mirrored from tools.ietf.org/html/rfc5764 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 14 Aug 2018 14:27:31 GMT --></html>