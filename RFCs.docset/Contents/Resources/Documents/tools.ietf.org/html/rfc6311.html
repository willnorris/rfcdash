<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml"><!-- Mirrored from tools.ietf.org/html/rfc6311 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 06 Mar 2018 23:18:30 GMT --><!-- Added by HTTrack --><head><meta content="text/html;charset=utf-8" http-equiv="content-type"/><!-- /Added by HTTrack -->

    <meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
    <meta content="index,follow" name="robots"/>
    <meta content="rfcmarkup version 1.126" name="creator"/>
    <link href="http://purl.org/dc/elements/1.1/" rel="schema.DC"/>
<meta content="urn:ietf:rfc:6311" name="DC.Identifier"/>
<meta content='The IPsec protocol suite is widely used for the deployment of virtual
private networks (VPNs). In order to make such VPNs highly available,
more scalable and failure-resistant, these VPNs are implemented as
IPsec High Availability (HA) clusters. However there are many issues
in IPsec HA clustering, and in particular in IKEv2 clustering. An
earlier document, "IPsec Cluster Problem Statement", enumerates the
issues encountered in the IKEv2/IPsec HA cluster environment. This
document attempts to resolve these issues with the least possible
change to the protocol.  This document proposes an extension to the
IKEv2 protocol to solve the main issues of "IPsec Cluster Problem
Statement" in the commonly deployed hot-standby cluster, and provides
implementation advice for other issues. The main issues to be solved
are the synchronization of IKEv2 Message ID counters, and of IPsec
Replay Counters.' name="DC.Description.Abstract"/>
<meta content="Nir, Yoav" name="DC.Creator"/>
<meta content="Singh, Raj" name="DC.Creator"/>
<meta content="Garigipati, Kalyani" name="DC.Creator"/>
<meta content="Zhang, Dacheng" name="DC.Creator"/>
<meta content="July, 2011" name="DC.Date.Issued"/>
<meta content="Protocol Support for High Availability of IKEv2/IPsec" name="DC.Title"/>

    <link href="https://tools.ietf.org/images/rfc.png" rel="icon" type="image/png"/>
    <link href="https://tools.ietf.org/images/rfc.png" rel="shortcut icon" type="image/png"/>
    <title>RFC 6311 - Protocol Support for High Availability of IKEv2/IPsec</title>
    
    
    <style type="text/css">
	@media only screen 
	  and (min-width: 992px)
	  and (max-width: 1199px) {
	    body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 768px)
	  and (max-width: 991px) {
            body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 480px)
	  and (max-width: 767px) {
            body { font-size: 11pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (max-width: 479px) {
            body { font-size: 8pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-device-width : 375px) 
	  and (max-device-width : 667px) {
            body { font-size: 9.5pt; }
            div.content { width: 96ex; margin: 0 1px; }
        }
	@media only screen 
	  and (min-device-width: 1200px) {
            body { font-size: 10pt; margin: 0 4em; }
            div.content { width: 96ex; margin: 0; }
        }
        h1, h2, h3, h4, h5, h6, .h1, .h2, .h3, .h4, .h5, .h6 {
	    font-weight: bold;
            line-height: 0pt;
            display: inline;
            white-space: pre;
            font-family: monospace;
            font-size: 1em;
	    font-weight: bold;
        }
        pre {
            font-size: 1em;
            margin-top: 0px;
            margin-bottom: 0px;
        }
	.pre {
	    white-space: pre;
	    font-family: monospace;
	}
	.header{
	    font-weight: bold;
	}
        .newpage {
            page-break-before: always;
        }
        .invisible {
            text-decoration: none;
            color: white;
        }
        a.selflink {
          color: black;
          text-decoration: none;
        }
        @media print {
            body {
                font-family: monospace;
                font-size: 10.5pt;
            }
            h1, h2, h3, h4, h5, h6 {
                font-size: 1em;
            }
        
            a:link, a:visited {
                color: inherit;
                text-decoration: none;
            }
            .noprint {
                display: none;
            }
        }
	@media screen {
	    .grey, .grey a:link, .grey a:visited {
		color: #777;
	    }
            .docinfo {
                background-color: #EEE;
            }
            .top {
                border-top: 7px solid #EEE;
            }
            .bgwhite  { background-color: white; }
            .bgred    { background-color: #F44; }
            .bggrey   { background-color: #666; }
            .bgbrown  { background-color: #840; }            
            .bgorange { background-color: #FA0; }
            .bgyellow { background-color: #EE0; }
            .bgmagenta{ background-color: #F4F; }
            .bgblue   { background-color: #66F; }
            .bgcyan   { background-color: #4DD; }
            .bggreen  { background-color: #4F4; }

            .legend   { font-size: 90%; }
            .cplate   { font-size: 70%; border: solid grey 1px; }
	}
    </style>
    <!--[if IE]>
    <style>
    body {
       font-size: 13px;
       margin: 10px 10px;
    }
    </style>
    <![endif]-->

    <script type="text/javascript"><!--
    function addHeaderTags() {
	var spans = document.getElementsByTagName("span");
	for (var i=0; i < spans.length; i++) {
	    var elem = spans[i];
	    if (elem) {
		var level = elem.getAttribute("class");
                if (level == "h1" || level == "h2" || level == "h3" || level == "h4" || level == "h5" || level == "h6") {
                    elem.innerHTML = "<"+level+">"+elem.innerHTML+"</"+level+">";		
                }
	    }
	}
    }
    var legend_html = "Colour legend:<br />      <table>         <tr><td>Unknown:</td>                   <td><span class='cplate bgwhite'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft:</td>                     <td><span class='cplate bgred'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Informational:</td>             <td><span class='cplate bgorange'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Experimental:</td>              <td><span class='cplate bgyellow'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Best Common Practice:</td>      <td><span class='cplate bgmagenta'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Proposed Standard:</td>         <td><span class='cplate bgblue'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft Standard (old designation):</td> <td><span class='cplate bgcyan'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Internet Standard:</td>         <td><span class='cplate bggreen'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Historic:</td>                  <td><span class='cplate bggrey'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Obsolete:</td>                  <td><span class='cplate bgbrown'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>     </table>";
    function showElem(id) {
        var elem = document.getElementById(id);
        elem.innerHTML = eval(id+"_html");
        elem.style.visibility='visible';
    }
    function hideElem(id) {
        var elem = document.getElementById(id);
        elem.style.visibility='hidden';        
        elem.innerHTML = "";
    }
    // -->
    </script>
</head>
<body onload="addHeaderTags()">
  <div class="content">
   <div style="height: 13px;">
      <div class="pre noprint docinfo bgblue" onclick="showElem('legend');" onmouseout="hideElem('legend')" onmouseover="this.style.cursor='pointer';" style="height: 6px; position: absolute;" title="Click for colour legend.">                                                                        </div>
      <div class="docinfo noprint pre legend" id="legend" onmouseout="hideElem('legend');" onmouseover="showElem('legend');" style="position:absolute; top: 4px; left: 4ex; visibility:hidden; background-color: white; padding: 4px 9px 5px 7px; border: solid #345 1px; ">
      </div>
   </div>
<span class="pre noprint docinfo top">[<a href="index.html" title="Document search and retrieval page">Docs</a>] [<a href="https://tools.ietf.org/rfc/rfc6311.txt" title="Plaintext version of this document">txt</a>|<a href="https://tools.ietf.org/pdf/rfc6311" title="PDF version of this document">pdf</a>] [<a href="https://tools.ietf.org/html/draft-ietf-ipsecme-ipsecha-protocol" title="draft-ietf-ipsecme-ipsecha-protocol">draft-ietf-ipse...</a>] [<a href="https://datatracker.ietf.org/doc/rfc6311" title="IESG Datatracker information for this document">Tracker</a>] [<a href="https://tools.ietf.org/rfcdiff?difftype=--hwdiff&amp;url2=rfc6311" title="Inline diff (wdiff)">Diff1</a>] [<a href="https://tools.ietf.org/rfcdiff?url2=rfc6311" title="Side-by-side diff">Diff2</a>] [<a href="https://datatracker.ietf.org/ipr/search/?rfc=6311&amp;submit=rfc" title="IPR disclosures related to this document">IPR</a>] [<a href="https://www.rfc-editor.org/errata_search.php?rfc=6311">Errata</a>]</span><br/>
<span class="pre noprint docinfo">                                                                        </span><br/>
<span class="pre noprint docinfo">                                                       PROPOSED STANDARD</span><br/>
<span class="pre noprint docinfo">                                                            <span style="color: #C00;">Errata Exist</span></span><br/>
<pre>Internet Engineering Task Force (IETF)                     R. Singh, Ed.
Request for Comments: 6311                                    G. Kalyani
Category: Standards Track                                          Cisco
ISSN: 2070-1721                                                   Y. Nir
                                                             Check Point
                                                              Y. Sheffer
                                                                Porticor
                                                                D. Zhang
                                                                  Huawei
                                                               July 2011


         <span class="h1">Protocol Support for High Availability of IKEv2/IPsec</span>

Abstract

   The IPsec protocol suite is widely used for business-critical network
   traffic.  In order to make IPsec deployments highly available, more
   scalable, and failure-resistant, they are often implemented as IPsec
   High Availability (HA) clusters.  However, there are many issues in
   IPsec HA clustering, and in particular in Internet Key Exchange
   Protocol version 2 (IKEv2) clustering.  An earlier document, "IPsec
   Cluster Problem Statement", enumerates the issues encountered in the
   IKEv2/IPsec HA cluster environment.  This document resolves these
   issues with the least possible change to the protocol.

   This document defines an extension to the IKEv2 protocol to solve the
   main issues of "IPsec Cluster Problem Statement" in the commonly
   deployed hot standby cluster, and provides implementation advice for
   other issues.  The main issues solved are the synchronization of
   IKEv2 Message ID counters, and of IPsec replay counters.

Status of This Memo

   This is an Internet Standards Track document.

   This document is a product of the Internet Engineering Task Force
   (IETF).  It represents the consensus of the IETF community.  It has
   received public review and has been approved for publication by the
   Internet Engineering Steering Group (IESG).  Further information on
   Internet Standards is available in <a href="rfc5741.html#section-2">Section 2 of RFC 5741</a>.

   Information about the current status of this document, any errata,
   and how to provide feedback on it may be obtained at
   <a href="http://www.rfc-editor.org/info/rfc6311">http://www.rfc-editor.org/info/rfc6311</a>.






<span class="grey">Singh, et al.                Standards Track                    [Page 1]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-2" id="page-2" name="page-2"> </a>
<span class="grey"><a href="rfc6311.html">RFC 6311</a>            High Availability in IKEv2/IPsec           July 2011</span>


Copyright Notice

   Copyright (c) 2011 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to <a href="https://tools.ietf.org/html/bcp78">BCP 78</a> and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (<a href="http://trustee.ietf.org/license-info">http://trustee.ietf.org/license-info</a>) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.





































<span class="grey">Singh, et al.                Standards Track                    [Page 2]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-3" id="page-3" name="page-3"> </a>
<span class="grey"><a href="rfc6311.html">RFC 6311</a>            High Availability in IKEv2/IPsec           July 2011</span>


Table of Contents

   <a href="#section-1">1</a>. Introduction ....................................................<a href="#page-3">3</a>
   <a href="#section-2">2</a>. Terminology .....................................................<a href="#page-5">5</a>
   <a href="#section-3">3</a>. Issues Resolved from IPsec Cluster Problem Statement ............<a href="#page-7">7</a>
      <a href="#section-3.1">3.1</a>. Large Amount of State ......................................<a href="#page-8">8</a>
      <a href="#section-3.2">3.2</a>. Multiple Members Using the Same SA .........................<a href="#page-9">9</a>
      <a href="#section-3.3">3.3</a>. Avoiding Collisions in SPI Number Allocation ...............<a href="#page-9">9</a>
      <a href="#section-3.4">3.4</a>. Interaction with Counter Modes .............................<a href="#page-9">9</a>
   <a href="#section-4">4</a>. The IKEv2/IPsec SA Counter Synchronization Problem .............<a href="#page-10">10</a>
   <a href="#section-5">5</a>. SA Counter Synchronization Solution ............................<a href="#page-11">11</a>
      <a href="#section-5.1">5.1</a>. Processing Rules for IKE Message ID Synchronization .......<a href="#page-13">13</a>
      5.2. Processing Rules for IPsec Replay Counter
           Synchronization ...........................................<a href="#page-14">14</a>
   <a href="#section-6">6</a>. IKEv2/IPsec Synchronization Notification Payloads ..............<a href="#page-14">14</a>
      <a href="#section-6.1">6.1</a>. The IKEV2_MESSAGE_ID_SYNC_SUPPORTED Notification ..........<a href="#page-15">15</a>
      <a href="#section-6.2">6.2</a>. The IPSEC_REPLAY_COUNTER_SYNC_SUPPORTED Notification ......<a href="#page-15">15</a>
      <a href="#section-6.3">6.3</a>. The IKEV2_MESSAGE_ID_SYNC Notification ....................<a href="#page-16">16</a>
      <a href="#section-6.4">6.4</a>. The IPSEC_REPLAY_COUNTER_SYNC Notification ................<a href="#page-16">16</a>
   <a href="#section-7">7</a>. Implementation Details .........................................<a href="#page-17">17</a>
   <a href="#section-8">8</a>. IKE SA and IPsec SA Message Sequencing .........................<a href="#page-18">18</a>
      <a href="#section-8.1">8.1</a>. Handling of Pending IKE Messages ..........................<a href="#page-18">18</a>
      <a href="#section-8.2">8.2</a>. Handling of Pending IPsec Messages ........................<a href="#page-18">18</a>
      <a href="#section-8.3">8.3</a>. IKE SA Inconsistencies ....................................<a href="#page-19">19</a>
   <a href="#section-9">9</a>. Step-by-Step Details ...........................................<a href="#page-19">19</a>
   <a href="#section-10">10</a>. Interaction with Other Specifications .........................<a href="#page-20">20</a>
   <a href="#section-11">11</a>. Security Considerations .......................................<a href="#page-21">21</a>
   <a href="#section-12">12</a>. IANA Considerations ...........................................<a href="#page-21">21</a>
   <a href="#section-13">13</a>. Acknowledgements ..............................................<a href="#page-22">22</a>
   <a href="#section-14">14</a>. References ....................................................<a href="#page-22">22</a>
      <a href="#section-14.1">14.1</a>. Normative References .....................................<a href="#page-22">22</a>
      <a href="#section-14.2">14.2</a>. Informative References ...................................<a href="#page-22">22</a>
   <a href="#appendix-A">Appendix A</a>. IKEv2 Message ID Sync Examples ........................<a href="#page-24">24</a>
     <a href="#appendix-A.1">A.1</a>. Normal Failover -- Example 1 ...............................<a href="#page-24">24</a>
     <a href="#appendix-A.2">A.2</a>. Normal Failover -- Example 2 ...............................<a href="#page-24">24</a>
     <a href="#appendix-A.3">A.3</a>. Normal Failover -- Example 3 ...............................<a href="#page-25">25</a>
     <a href="#appendix-A.4">A.4</a>. Simultaneous Failover ......................................<a href="#page-25">25</a>

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/1.%20%20Introduction"></a><a class="selflink" href="#section-1" name="section-1">1</a>.  Introduction</span>

   The IPsec protocol suite, including the Internet Key Exchange
   Protocol version 2 (IKEv2), is a major building block of virtual
   private networks (VPNs).  In order to make such VPNs highly
   available, more scalable, and failure-resistant, these VPNs are
   implemented as IKEv2/IPsec Highly Available (HA) clusters.  However,






<span class="grey">Singh, et al.                Standards Track                    [Page 3]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-4" id="page-4" name="page-4"> </a>
<span class="grey"><a href="rfc6311.html">RFC 6311</a>            High Availability in IKEv2/IPsec           July 2011</span>


   there are many issues with the IKEv2/IPsec HA cluster.  Sections <a href="#section-3">3</a>
   and 4 below expand on the issues around the IKEv2/IPsec HA cluster
   solution, issues which were first described in the problem
   statement [<a href="#ref-6" title='"IPsec Cluster Problem Statement"'>6</a>].

   In the case of a hot standby cluster implementation of IKEv2/
   IPsec-based VPNs, the IKEv2/IPsec session is first established
   between the peer and the active member of the cluster.  Later, the
   active member continuously syncs/updates the IKE/IPsec security
   association (SA) state to the standby member of the cluster.  This
   primary SA state sync-up takes place upon each SA bring-up and/or
   rekey.  Performing the SA state synchronization/update for every
   single IKE and IPsec message is very costly, so normally it is done
   periodically.  As a result, when the failover event happens, this is
   first detected by the standby member and, possibly after a
   considerable amount of time, it becomes the active member.  During
   this failover process, the peer is unaware of the failover event, and
   keeps sending IKE requests and IPsec packets to the cluster, as in
   fact it is allowed to do because of the IKEv2 windowing feature.
   After the newly active member starts, it detects the mismatch in IKE
   Message ID values and IPsec replay counters and needs to resolve this
   situation.  Please see <a href="#section-4">Section 4</a> for more details of the problem.

   This document defines an extension to the IKEv2 protocol to solve the
   main issues of IKE Message ID synchronization and IPsec SA replay
   counter synchronization, and gives implementation advice to address
   other issues.  Following is a summary of the solutions provided in
   this document:

   o  IKEv2 Message ID synchronization: This is done by syncing up the
      expected send and receive Message ID values with the peer, and
      updating the values at the newly active cluster member.

   o  IPsec replay counter synchronization: This is done by incrementing
      the cluster's outgoing SA replay counter values by a "large"
      number; in addition, the newly active member requests the peer to
      increment the replay counter values it is using for the peer's
      outgoing traffic.

   Although this document describes the IKEv2 Message ID and IPsec
   replay counter synchronization in the context of an IPsec HA cluster,
   the solution provided is generic and can be used in other scenarios
   where IKEv2 Message ID or IPsec SA replay counter synchronization may
   be required.







<span class="grey">Singh, et al.                Standards Track                    [Page 4]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-5" id="page-5" name="page-5"> </a>
<span class="grey"><a href="rfc6311.html">RFC 6311</a>            High Availability in IKEv2/IPsec           July 2011</span>


   Implementations differ on the need to synchronize the IKEv2 Message
   ID and/or IPsec replay counters.  Both of these problems are handled
   separately, using a separate notification for each capability.  This
   provides the flexibility of implementing either or both of these
   solutions.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/2.%20%20Terminology"></a><a class="selflink" href="#section-2" name="section-2">2</a>.  Terminology</span>

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in [<a href="#ref-1" title='"Key words for use in RFCs to Indicate Requirement Levels"'>1</a>].

   "SA Counter Synchronization" is the informational exchange defined in
   this document to synchronize the IKEv2/IPsec SA counter information
   between one member of the cluster and the peer.

   Some of the terms listed below are reused from [<a href="#ref-6" title='"IPsec Cluster Problem Statement"'>6</a>] with further
   clarification in the context of the current document.

   o  "Hot Standby Cluster", or "HS Cluster", is a cluster where only
      one of the members is active at any one time.  This member is also
      referred to as the "active" member, whereas the other(s) are
      referred to as "standby" members.  The Virtual Router Redundancy
      Protocol (VRRP) [<a href="#ref-7" title='"Virtual Router Redundancy Protocol (VRRP) Version 3 for IPv4 and IPv6"'>7</a>] is one method of building such a cluster.  The
      goal of the hot standby cluster is to create the illusion of a
      single virtual gateway to the peer(s).

   o  "Active Member" is the primary member in the hot standby cluster.
      It is responsible for forwarding packets on behalf of the virtual
      gateway.

   o  "Standby Member" is the primary backup member.  This member takes
      control, i.e., becomes the active member, after the failover
      event.

   o  "Peer" is an IKEv2/IPsec endpoint that maintains an IPsec
      connection with the hot standby cluster.  The peer identifies the
      cluster by the cluster's (single) IP address.  If a failover event
      occurs, the standby member of the cluster becomes active, and the
      peer normally doesn't notice that failover has taken place.
      Although we treat the peer as a single entity, it may also be a
      cluster.









<span class="grey">Singh, et al.                Standards Track                    [Page 5]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-6" id="page-6" name="page-6"> </a>
<span class="grey"><a href="rfc6311.html">RFC 6311</a>            High Availability in IKEv2/IPsec           July 2011</span>


   o  "Multiple failover" is the situation where, in a cluster with
      three or more members, multiple failover events happen in rapid
      succession, e.g., from M1 to M2, and then to M3.  It is our goal
      that the implementation should be able to handle this situation,
      i.e., to handle the new failover event even if it is still
      processing the old failover.

   o  "Simultaneous failover" is the situation where two clusters have
      an IPsec connection between them, and failover happens at both
      ends at the same time.  It is our goal that implementations should
      be able to handle simultaneous failover.

   o  "IPsec replay counter" is the Encapsulating Security Payload (ESP)
      Sequence Number or Extended Sequence Number (Section 2.2 of [<a href="#ref-2" title='"IP Encapsulating Security Payload (ESP)"'>2</a>]),
      or the respective field in the Authentication Header (AH) protocol
      (Section 2.5 of [<a href="#ref-3" title='"IP Authentication Header"'>3</a>]).

   The generic term "IKEv2/IPsec SA Counters" is used throughout this
   document.  This term refers to both IKEv2 Message ID counters and
   IPsec replay counters.  According to the IPsec standards, the IKEv2
   Message ID counter is mandatory, and used to ensure reliable delivery
   as well as to protect against message replay in IKEv2; the IPsec SA
   replay counters are optional, and are used to provide the IPsec anti-
   replay feature.



























<span class="grey">Singh, et al.                Standards Track                    [Page 6]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-7" id="page-7" name="page-7"> </a>
<span class="grey"><a href="rfc6311.html">RFC 6311</a>            High Availability in IKEv2/IPsec           July 2011</span>


   Some of these terms are used in the following architectural diagram.

                                                   +---------------+
                                                   |               |
                                                   | Hot Standby   |
                                                   |   Cluster     |
                                                   |               |
                                                   |   +---------+ |
                                                   |   |         | |
                                                   |   | Active  | |
                                                   |   |         | |
                                                   |   | Member  | |
                                                   |   |         | |
                                                   |   +---------+ |
                                                   |          ^    |
       +---------+                                 |  Synch   |    |
       |         |                                 |  Channel |    |
       |  IPsec  |       IKE/IPsec Traffic         |          |    |
       |         | &lt;=============================&gt; |          |    |
       |   Peer  |                                 |          |    |
       |         |                                 |          |    |
       +---------+                                 |          |    |
                                                   |          v    |
                                                   |   +---------+ |
                                                   |   |         | |
                                                   |   | Standby | |
                                                   |   |         | |
                                                   |   | Member  | |
                                                   |   |         | |
                                                   |   +---------+ |
                                                   +---------------+

                       An IPsec Hot Standby Cluster

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/3.%20%20Issues%20Resolved%20from%20IPsec%20Cluster%20Problem%20Statement"></a><a class="selflink" href="#section-3" name="section-3">3</a>.  Issues Resolved from IPsec Cluster Problem Statement</span>

   "IPsec Cluster Problem Statement" [<a href="#ref-6" title='"IPsec Cluster Problem Statement"'>6</a>] enumerates the problems raised
   by IPsec clusters.  The following table lists the problem statement's
   sections that are resolved by this document.

   o  3.2.  A Lot of Long-Lived State
   o  3.3.  IKE Counters
   o  3.4.  Outbound SA Counters
   o  3.5.  Inbound SA Counters
   o  3.6.  Missing Synch Messages






<span class="grey">Singh, et al.                Standards Track                    [Page 7]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-8" id="page-8" name="page-8"> </a>
<span class="grey"><a href="rfc6311.html">RFC 6311</a>            High Availability in IKEv2/IPsec           July 2011</span>


   o  3.7.  Simultaneous Use of IKE and IPsec SAs by Different Members
      *  3.7.1.  Outbound SAs Using Counter Modes
   o  3.8.  Different IP Addresses for IKE and IPsec
   o  3.9.  Allocation of SPIs

   The main problem areas are solved using the protocol extension
   defined below, starting with <a href="#section-5">Section 5</a>; additionally, this section
   provides implementation advice for other issues in the following
   subsections.  Implementers should note that these subsections include
   a number of new security-critical requirements.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.1.%20%20Large%20Amount%20of%20State"></a><a class="selflink" href="#section-3.1" name="section-3.1">3.1</a>.  Large Amount of State</span>

   <a href="#section-3.2">Section 3.2</a> of the problem statement [<a href="#ref-6" title='"IPsec Cluster Problem Statement"'>6</a>] mentions that a lot of state
   needs to be synchronized for a cluster to be transparent.  The actual
   volume of that data is very much implementation-dependent, and even
   for the same implementation, the amounts of data may vary wildly.  An
   IPsec gateway used for inter-domain VPN with a dozen other gateways,
   and having SAs that are rekeyed every 8 hours, will need a lot less
   synchronization traffic than a similar gateway used for remote
   access, and supporting 10,000 clients.  This is because counter
   synchronization is proportional to the number of SAs and requires
   little data, and the setting up of an SA requires a lot of data.
   Additionally, remote access IKE and IPsec SA setup tend to happen at
   a particular time of day, so the example gateway with the 10,000
   clients may see 30-50 IKE SA setups per second at 9:00 AM.  This
   would require very heavy synchronization traffic over that short
   period of time.

   If a large volume of traffic is necessary, it may be advisable to use
   a dedicated high-speed network interface for synch traffic.  When
   packet loss can be made extremely low, it may be advisable to use a
   stateless transport such as UDP, to minimize network overhead.

   If these methods are insufficient, it may be prudent that for some
   SAs the entire state is not synchronized.  Instead, only an
   indication of the SA's existence is synchronized.  This, in
   combination with a sticky solution (as described in <a href="#section-3.7">Section 3.7</a> of
   the problem statement [<a href="#ref-6" title='"IPsec Cluster Problem Statement"'>6</a>]) ensures that the traffic from a particular
   peer does not reach a different member before an actual failover
   happens.  When that happens, the method described in [<a href="#ref-8" title='"A Quick Crash Detection Method for the Internet Key Exchange Protocol (IKE)"'>8</a>] can be used
   to quickly force the peer to set up a new SA.









<span class="grey">Singh, et al.                Standards Track                    [Page 8]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-9" id="page-9" name="page-9"> </a>
<span class="grey"><a href="rfc6311.html">RFC 6311</a>            High Availability in IKEv2/IPsec           July 2011</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.2.%20%20Multiple%20Members%20Using%20the%20Same%20SA"></a><a class="selflink" href="#section-3.2" name="section-3.2">3.2</a>.  Multiple Members Using the Same SA</span>

   In a load-sharing cluster of the "duplicate" variety (see <a href="#section-3.7">Section 3.7</a>
   of the problem statement [<a href="#ref-6" title='"IPsec Cluster Problem Statement"'>6</a>]), multiple members may need to send
   traffic with the same selectors.  To actually use the same SA, the
   cluster would have to synchronize the replay counter after every
   packet, and that would impose unreasonable requirements on the synch
   connection.

   A far better solution would be to not synchronize the outbound SA,
   and create multiple outbound SAs, one for each member.  The problem
   with this option is that the peer might view these multiple parallel
   SAs as redundant, and tear down all but one of them.

   Section 2.8 of [<a href="#ref-4" title='"Internet Key Exchange Protocol Version 2 (IKEv2)"'>4</a>] specifically allows multiple parallel SAs, but the
   reason given for this is to have multiple SAs with different Quality
   of Service (QoS) attributes.  So while this is not a new requirement
   of IKEv2 implementations working with QoS, we re-iterate here that
   IPsec peers MUST accept the long-term existence of multiple parallel
   SAs, even when QoS mechanisms are not in use.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.3.%20%20Avoiding%20Collisions%20in%20SPI%20Number%20Allocation"></a><a class="selflink" href="#section-3.3" name="section-3.3">3.3</a>.  Avoiding Collisions in SPI Number Allocation</span>

   <a href="#section-3.9">Section 3.9</a> of the problem statement [<a href="#ref-6" title='"IPsec Cluster Problem Statement"'>6</a>] describes the problem of two
   cluster members allocating the same Security Parameter Index (SPI)
   number for two different SAs.  This behavior would violate
   Section 4.4.2.1 of [<a href="#ref-5" title='"Security Architecture for the Internet Protocol"'>5</a>].  There are several schemes to allow
   implementations to avoid such collisions, such as partitioning the
   SPI space, a request-response over the synch channel, and locking
   mechanisms.  We believe that these are sufficiently robust and
   available so that we don't need to make an exception to the rules in
   <a href="rfc4301.html#section-4.4.2.1">Section 4.4.2.1 of RFC 4301</a> [<a href="#ref-5" title='"Security Architecture for the Internet Protocol"'>5</a>], and we can leave this problem for
   the implementations to solve.  Cluster members must not generate
   multiple inbound SAs with the same SPI.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.4.%20%20Interaction%20with%20Counter%20Modes"></a><a class="selflink" href="#section-3.4" name="section-3.4">3.4</a>.  Interaction with Counter Modes</span>

   For SAs involving counter mode ciphers such as Counter Mode (CTR) [<a href="#ref-9" title='"Using Advanced Encryption Standard (AES) Counter Mode With IPsec Encapsulating Security Payload (ESP)"'>9</a>]
   or Galois/Counter Mode (GCM) [<a href="#ref-10" title='"The Use of Galois/Counter Mode (GCM) in IPsec Encapsulating Security Payload (ESP)"'>10</a>], there is yet another complication.
   The initial vector for such modes MUST NOT be repeated, and senders
   may use methods such as counters or linear feedback shift registers
   (LFSRs) to ensure this property.  For an SA shared between multiple
   active members (load-sharing cases), implementations MUST ensure that
   no initial vector is ever repeated.  Similar concerns apply to an SA
   failing over from one member to another.  See [<a href="#ref-11" title='"Using Counter Modes with Encapsulating Security Payload (ESP) and Authentication Header (AH) to Protect Group Traffic"'>11</a>] for a discussion
   of this problem in another context.





<span class="grey">Singh, et al.                Standards Track                    [Page 9]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-10" id="page-10" name="page-10"> </a>
<span class="grey"><a href="rfc6311.html">RFC 6311</a>            High Availability in IKEv2/IPsec           July 2011</span>


   Just as in the SPI collision problem, there are ways to avoid a
   collision of initial vectors, and this is left up to implementations.
   In the context of load sharing, parallel SAs are a simple solution to
   this problem as well.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/4.%20%20The%20IKEv2%2FIPsec%20SA%20Counter%20Synchronization%20Problem"></a><a class="selflink" href="#section-4" name="section-4">4</a>.  The IKEv2/IPsec SA Counter Synchronization Problem</span>

   The IKEv2 protocol [<a href="#ref-4" title='"Internet Key Exchange Protocol Version 2 (IKEv2)"'>4</a>] states that "An IKE endpoint MUST NOT exceed
   the peer's stated window size for transmitted IKE requests".

   All IKEv2 messages are required to follow a request-response
   paradigm.  The initiator of an IKEv2 request MUST retransmit the
   request, until it has received a response from the peer.  IKEv2
   introduces a windowing mechanism that allows multiple requests to be
   outstanding at a given point of time, but mandates that the sender's
   window should not move until the oldest message it has sent is
   acknowledged.  Loss of even a single message leads to repeated
   retransmissions followed by an IKEv2 SA teardown if the
   retransmissions remain unacknowledged.

   An IPsec hot standby cluster is required to ensure that in the case
   of failover, the standby member becomes active immediately.  The
   standby member is expected to have the exact value of the Message ID
   counter as the active member had before failover.  Even assuming the
   best effort to update the Message ID values from active to standby
   member, the values at the standby member can still be stale due to
   the following reasons:

   o  The standby member is unaware of the last message that was
      received and acknowledged by the previously active member, as the
      failover event could have happened before the standby member could
      be updated.

   o  The standby member does not have information about on-going
      unacknowledged requests sent by the previously active member.  As
      a result, after the failover event, the newly active member cannot
      retransmit those requests.

   When a standby member takes over as the active member, it can only
   initialize the Message ID values from the previously updated values.
   This would make it reject requests from the peer when these values
   are stale.  Conversely, the standby member may end up reusing a stale
   Message ID value, which would cause the peer to drop the request.
   Eventually, there is a high probability of the IKEv2 and
   corresponding IPsec SAs getting torn down simply because of a
   transitory Message ID mismatch and retransmission of requests,
   negating the benefits of the high-availability cluster despite the
   periodic update between the cluster members.



<span class="grey">Singh, et al.                Standards Track                   [Page 10]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-11" id="page-11" name="page-11"> </a>
<span class="grey"><a href="rfc6311.html">RFC 6311</a>            High Availability in IKEv2/IPsec           July 2011</span>


   A similar issue is also observed with IPsec anti-replay counters if
   anti-replay protection is enabled, which is commonly the case.
   Regardless of how well the ESP and AH SA counters are synchronized
   from the active to the standby member, there is a chance that the
   standby member would end up with stale counter values.  The standby
   member would then use those stale counter values when sending IPsec
   packets.  The peer would drop such packets, since when the anti-
   replay protection feature is enabled, duplicate use of counters is
   not allowed.  Note that IPsec allows the sender to skip some counter
   values and continue sending with higher counter values.

   We conclude that a mechanism is required to ensure that the standby
   member has correct Message ID and IPsec counter values when it
   becomes active, so that sessions are not torn down as a result of
   mismatched counters.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/5.%20%20SA%20Counter%20Synchronization%20Solution"></a><a class="selflink" href="#section-5" name="section-5">5</a>.  SA Counter Synchronization Solution</span>

   This document defines two separate approaches to resolving the issues
   of mismatched IKE Message ID values and IPsec counter values.

   o  In the case of IKE Message ID values, the newly active cluster
      member and the peer negotiate a pair of new values so that future
      IKE messages will not be dropped.

   o  For IPsec counter values, the newly active member and the peer
      both increment their respective counter values, "skipping forward"
      by a large number, to ensure that no IPsec counters are ever
      reused.

   Although conceptually separate, the two synchronization processes
   would typically take place simultaneously.

   First, the peer and the active member of the cluster negotiate their
   ability to support IKEv2 Message ID synchronization and/or IPsec
   replay counter synchronization.  This is done by exchanging one or
   both of the IKEV2_MESSAGE_ID_SYNC_SUPPORTED and
   IPSEC_REPLAY_COUNTER_SYNC_SUPPORTED notifications during the IKE_AUTH
   exchange.  When negotiating these capabilities, the responder MUST
   NOT assert support of a capability unless such support was asserted
   by the initiator.  Only a capability whose support was asserted by
   both parties can be used during the lifetime of the SA.  The peer's
   capabilities with regard to this extension are part of the IKEv2 SA
   state, and thus MUST be shared between the cluster members.

   This per-IKE SA information is shared with the other cluster members.





<span class="grey">Singh, et al.                Standards Track                   [Page 11]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-12" id="page-12" name="page-12"> </a>
<span class="grey"><a href="rfc6311.html">RFC 6311</a>            High Availability in IKEv2/IPsec           July 2011</span>


   Peer                                                  Active Member
   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
   HDR, SK {IDi, [CERT], [CERTREQ], [IDr], AUTH,
        [N(IKEV2_MESSAGE_ID_SYNC_SUPPORTED),]
        [N(IPSEC_REPLAY_COUNTER_SYNC_SUPPORTED),]
        SAi2, TSi, TSr} ----------&gt;

   &lt;-------- HDR, SK {IDr, [CERT+], [CERTREQ+], AUTH,
                  [N(IKEV2_MESSAGE_ID_SYNC_SUPPORTED),]
                  [N(IPSEC_REPLAY_COUNTER_SYNC_SUPPORTED),]
                  SAr2, TSi, TSr}

   After a failover event, the standby member MAY use the IKE Message ID
   and/or IPsec replay counter synchronization capability when it
   becomes the active member, and provided support for the capabilities
   used has been negotiated.  Following that, the peer MUST respond to
   any synchronization message it receives from the newly active cluster
   member, subject to the rules noted below.

   After the failover event, when the standby member becomes active, it
   has to synchronize its SA counters with the peer.  There are now four
   possible cases:

   1.  The cluster member wishes to only perform IKE Message ID value
       synchronization.  In this case, it initiates an Informational
       exchange, with Message ID zero and the sole notification
       IKEV2_MESSAGE_ID_SYNC.

   2.  If the newly active member wishes to perform only IPsec replay
       counter synchronization, it generates a regular IKEv2
       Informational exchange using the current Message ID values, and
       containing the IPSEC_REPLAY_COUNTER_SYNC notification.

   3.  If synchronization of both counters is needed, the cluster member
       generates a zero-Message ID message as in case #1, and includes
       both notifications in this message.

   4.  Lastly, the peer may not support this extension.  This is known
       to the newly active member (because the cluster members must
       share this information, as noted earlier).  This case is the
       existing IKEv2 behavior, and the IKE and IPsec SAs may or may not
       survive the failover, depending on the exact state on the peer
       and the cluster member.

   This figure contains the IKE message exchange used for SA counter
   synchronization.  The following subsections describe the details of
   the sender and receiver processing of each message.




<span class="grey">Singh, et al.                Standards Track                   [Page 12]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-13" id="page-13" name="page-13"> </a>
<span class="grey"><a href="rfc6311.html">RFC 6311</a>            High Availability in IKEv2/IPsec           July 2011</span>


   Standby [Newly Active] Member                            Peer
   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
   HDR, SK {N(IKEV2_MESSAGE_ID_SYNC),
        [N(IPSEC_REPLAY_COUNTER_SYNC)]} --------&gt;

                &lt;--------- HDR, SK {N(IKEV2_MESSAGE_ID_SYNC)}

   Alternatively, if only IPsec replay counter synchronization is
   desired, a normal Informational exchange is used, where the Message
   ID is non-zero:

   Standby [Newly Active] Member                            Peer
   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
   HDR, SK{N(IPSEC_REPLAY_COUNTER_SYNC)} --------&gt;

                &lt;--------- HDR

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.1.%20%20Processing%20Rules%20for%20IKE%20Message%20ID%20Synchronization"></a><a class="selflink" href="#section-5.1" name="section-5.1">5.1</a>.  Processing Rules for IKE Message ID Synchronization</span>

   The newly active member sends a request containing two counter
   values, one for the member (itself) and another for the peer, as well
   as a random nonce.  We denote the values M1 and P1.  The peer
   responds with a message containing two counter values, M2 and P2
   (note that the values appear in the opposite order in the
   notification's payload).  The goal of the rules below is to prevent
   an attacker from replaying a synchronization message and thereby
   invalidating IKE messages that are currently in process.

   o  M1 is the next sender's Message ID to be used by the member.  M1
      MUST be chosen so that it is larger than any value known to have
      been used.  It is RECOMMENDED to increment the known value at
      least by the size of the IKE sender window.

   o  P1 SHOULD be 1 more than the last Message ID value received from
      the peer, but may be any higher value.

   o  The member SHOULD communicate the sent values to the other cluster
      members, so that if a second failover event takes place, the
      synchronization message is not replayed.  Such a replay would
      result in the eventual deletion of the IKE SA (see below).

   o  The peer MUST silently drop any received synchronization message
      if M1 is lower than or equal to the highest value it has seen from
      the cluster.  This includes any previous received synchronization
      messages.






<span class="grey">Singh, et al.                Standards Track                   [Page 13]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-14" id="page-14" name="page-14"> </a>
<span class="grey"><a href="rfc6311.html">RFC 6311</a>            High Availability in IKEv2/IPsec           July 2011</span>


   o  M2 MUST be at least the higher of the received M1, and one more
      than the highest sender value received from the cluster.  This
      includes any previous received synchronization messages.

   o  P2 MUST be the higher of the received P1 value, and one more than
      the highest sender value used by the peer.

   o  The request contains a Nonce field.  This field MUST be returned
      in the response, unchanged.  A response MUST be silently dropped
      if the received nonce does not match the one that was sent.

   o  Both the request and the response MUST NOT contain any additional
      payloads, other than an optional IPSEC_REPLAY_COUNTER_SYNC
      notification in the request.

   o  The request and the response MUST both be sent with a Message ID
      value of zero.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.2.%20%20Processing%20Rules%20for%20IPsec%20Replay%20Counter%20Synchronization"></a><a class="selflink" href="#section-5.2" name="section-5.2">5.2</a>.  Processing Rules for IPsec Replay Counter Synchronization</span>

   Upon failover, the newly active member MUST increment its own replay
   counter (the counter used for outgoing traffic), so as to prevent the
   case of its traffic being dropped by the peer as replay.  We note
   that IPsec allows the replay counter to skip forward by any amount.
   The estimate is based on the outgoing IPsec bandwidth and the
   frequency of synchronization between cluster members.  In those
   implementations where it is difficult to estimate this value, the
   counter can be incremented by a very large number, e.g., 2**30.  In
   the latter case, a rekey SHOULD follow shortly afterwards, to ensure
   that the counter never wraps around.

   Next, the cluster member estimates the number of incoming messages it
   might have missed, using similar logic.  The member sends out an
   IPSEC_REPLAY_COUNTER_SYNC notification, either stand-alone or
   together with an IKEV2_MESSAGE_ID_SYNC notification.

   If the IPSEC_REPLAY_COUNTER_SYNC is included in the same message as
   IKEV2_MESSAGE_ID_SYNC, the peer MUST process the Message ID
   notification first (which might cause the entire message to be
   dropped as a replay).  Then, it MUST increment the replay counters
   for all Child SAs associated with the current IKE SA by the amount
   requested by the cluster member.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/6.%20%20IKEv2%2FIPsec%20Synchronization%20Notification%20Payloads"></a><a class="selflink" href="#section-6" name="section-6">6</a>.  IKEv2/IPsec Synchronization Notification Payloads</span>

   This section lists the new notification payload types defined by this
   extension.




<span class="grey">Singh, et al.                Standards Track                   [Page 14]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-15" id="page-15" name="page-15"> </a>
<span class="grey"><a href="rfc6311.html">RFC 6311</a>            High Availability in IKEv2/IPsec           July 2011</span>


   All multi-octet fields representing integers are laid out in big
   endian order (also known as "most significant byte first", or
   "network byte order").

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/6.1.%20%20The%20IKEV2_MESSAGE_ID_SYNC_SUPPORTED%20Notification"></a><a class="selflink" href="#section-6.1" name="section-6.1">6.1</a>.  The IKEV2_MESSAGE_ID_SYNC_SUPPORTED Notification</span>

   This notification payload is included in the IKE_AUTH request/
   response to indicate support of the IKEv2 Message ID synchronization
   mechanism described in this document.

                        1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   | Next Payload  |C|  RESERVED   |         Payload Length        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |Protocol ID(=0)| SPI Size (=0) |      Notify Message Type      |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

   The 'Next Payload', 'Payload Length', 'Protocol ID', 'SPI Size', and
   'Notify Message Type' fields are the same as described in Section 3
   of [<a href="#ref-4" title='"Internet Key Exchange Protocol Version 2 (IKEv2)"'>4</a>].  The 'SPI Size' field MUST be set to 0 to indicate that the
   SPI is not present in this message.  The 'Protocol ID' MUST be set to
   0, since the notification is not specific to a particular security
   association.  The 'Payload Length' field is set to the length in
   octets of the entire payload, including the generic payload header.
   The 'Notify Message Type' field is set to indicate
   IKEV2_MESSAGE_ID_SYNC_SUPPORTED (16420).  There is no data associated
   with this notification.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/6.2.%20%20The%20IPSEC_REPLAY_COUNTER_SYNC_SUPPORTED%20Notification"></a><a class="selflink" href="#section-6.2" name="section-6.2">6.2</a>.  The IPSEC_REPLAY_COUNTER_SYNC_SUPPORTED Notification</span>

   This notification payload is included in the IKE_AUTH request/
   response to indicate support for the IPsec SA replay counter
   synchronization mechanism described in this document.

                        1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   | Next Payload  |C|  RESERVED   |         Payload Length        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |Protocol ID(=0)| SPI Size (=0) |      Notify Message Type      |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

   The 'Next Payload', 'Payload Length', 'Protocol ID', 'SPI Size', and
   'Notify Message Type' fields are the same as described in Section 3
   of [<a href="#ref-4" title='"Internet Key Exchange Protocol Version 2 (IKEv2)"'>4</a>] .  The 'SPI Size' field MUST be set to 0 to indicate that the
   SPI is not present in this message.  The 'Protocol ID' MUST be set to
   0, since the notification is not specific to a particular security



<span class="grey">Singh, et al.                Standards Track                   [Page 15]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-16" id="page-16" name="page-16"> </a>
<span class="grey"><a href="rfc6311.html">RFC 6311</a>            High Availability in IKEv2/IPsec           July 2011</span>


   association.  The 'Payload Length' field is set to the length in
   octets of the entire payload, including the generic payload header.
   The 'Notify Message Type' field is set to indicate
   IPSEC_REPLAY_COUNTER_SYNC_SUPPORTED (16421).  There is no data
   associated with this notification.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/6.3.%20%20The%20IKEV2_MESSAGE_ID_SYNC%20Notification"></a><a class="selflink" href="#section-6.3" name="section-6.3">6.3</a>.  The IKEV2_MESSAGE_ID_SYNC Notification</span>

   This notification payload type (16422) is defined to synchronize the
   IKEv2 Message ID values between the newly active (formerly standby)
   cluster member and the peer.

                        1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   | Next Payload  |C|  RESERVED   |         Payload Length        |

   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |Protocol ID(=0)| SPI Size (=0) |      Notify Message Type      |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

   |             Nonce Data                                        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |             EXPECTED_SEND_REQ_MESSAGE_ID                      |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |             EXPECTED_RECV_REQ_MESSAGE_ID                      |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

   It contains the following data.

   o  Nonce Data (4 octets): The random nonce data.  The data should be
      identical in the synchronization request and response.

   o  EXPECTED_SEND_REQ_MESSAGE_ID (4 octets): This field is used by the
      sender of this notification payload to indicate the Message ID it
      will use in the next request that it will send to the other
      protocol peer.

   o  EXPECTED_RECV_REQ_MESSAGE_ID (4 octets): This field is used by the
      sender of this notification payload to indicate the Message ID it
      is expecting in the next request to be received from the other
      protocol peer.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/6.4.%20%20The%20IPSEC_REPLAY_COUNTER_SYNC%20Notification"></a><a class="selflink" href="#section-6.4" name="section-6.4">6.4</a>.  The IPSEC_REPLAY_COUNTER_SYNC Notification</span>

   This notification payload type (16423) is defined to synchronize the
   IPsec SA replay counters between the newly active (formerly standby)
   cluster member and the peer.  Since there may be numerous IPsec SAs



<span class="grey">Singh, et al.                Standards Track                   [Page 16]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-17" id="page-17" name="page-17"> </a>
<span class="grey"><a href="rfc6311.html">RFC 6311</a>            High Availability in IKEv2/IPsec           July 2011</span>


   established under a single IKE SA, we do not directly synchronize the
   value of each one.  Instead, a delta value is sent, and all replay
   counters for Child SAs of this IKE SA are incremented by the same
   value.  Note that this solution requires that either all Child SAs
   use Extended Sequence Numbers (ESNs) or else that no Child SA uses
   ESNs.  This notification is only sent by the cluster.

                        1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   | Next Payload  |C|  RESERVED   |         Payload Length        |

   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |Protocol ID(=0)| SPI Size (=0) |      Notify Message Type      |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                 Incoming IPsec SA delta value                 |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

   The notification payload contains the following data.

   o  Incoming IPsec SA delta value (4 or 8 octets): The sender requests
      that the peer should increment all the Child SA replay counters
      for the sender's incoming (the peer's outgoing) traffic by this
      value.  The size of this field depends on the ESN bit associated
      with the Child SAs: if the ESN bit is 1, the field's size is 8
      octets; otherwise, it is 4 octets.  We note that this constrains
      the Child SAs of each IKE SA to either all have the ESN bit on
      or off.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/7.%20%20Implementation%20Details"></a><a class="selflink" href="#section-7" name="section-7">7</a>.  Implementation Details</span>

   This protocol does not change any of the existing IKEv2 rules
   regarding Message ID values.

   The standby member can initiate the synchronization of IKEv2 Message
   IDs under different circumstances.

   o  When it receives a problematic IKEv2/IPsec packet, i.e., a packet
      outside its expected receive window.

   o  When it has to send the first IKEv2/IPsec packet after a failover
      event.

   o  When it has just received control from the active member and
      wishes to update the values proactively, so that it need not start
      this exchange later, when sending or receiving the request.





<span class="grey">Singh, et al.                Standards Track                   [Page 17]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-18" id="page-18" name="page-18"> </a>
<span class="grey"><a href="rfc6311.html">RFC 6311</a>            High Availability in IKEv2/IPsec           July 2011</span>


   To clarify the first alternative: the normal IKE behavior of
   rejecting out-of-window messages is not changed, but such messages
   can still be a valid trigger for the exchange defined in this
   document.  To avoid denial-of-service (DoS) attacks resulting from
   replayed messages, the peer MUST NOT initiate counter synchronization
   for any particular IKE SA more than once per failover event.

   The standby member can initiate the synchronization of IPsec SA
   replay counters:

   o  If there has been traffic using the IPsec SA in the recent past
      and the standby member suspects that its replay counter may be
      stale.

   Since there can be a large number of sessions at the standby member,
   and sending synchronization exchanges for all of them may result in
   overload, the standby member can choose to initiate the exchange in a
   "lazy" fashion: only when it has to send or expects to receive
   traffic from each peer.  In general, the standby member is free to
   initiate this exchange at its discretion.  Implementation
   considerations include the ability to survive a certain amount of
   traffic loss, and the capacity of a cluster member to initiate
   counter synchronization simultaneously with a large number of peers.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/8.%20%20IKE%20SA%20and%20IPsec%20SA%20Message%20Sequencing"></a><a class="selflink" href="#section-8" name="section-8">8</a>.  IKE SA and IPsec SA Message Sequencing</span>

   The straightforward definitions of message sequence numbers,
   retransmissions, and replay protection in IPsec and IKEv2 are
   strained by the failover scenarios described in this document.  This
   section describes some policy choices that need to be made by
   implementations in this setting.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/8.1.%20%20Handling%20of%20Pending%20IKE%20Messages"></a><a class="selflink" href="#section-8.1" name="section-8.1">8.1</a>.  Handling of Pending IKE Messages</span>

   After sending its "receive" counter, the cluster member MUST reject
   (silently drop) any incoming IKE messages that are outside its
   declared window.  A similar rule applies to the peer.  Local policies
   vary, and strict implementations will reject any incoming IKE message
   arriving before Message ID synchronization is complete.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/8.2.%20%20Handling%20of%20Pending%20IPsec%20Messages"></a><a class="selflink" href="#section-8.2" name="section-8.2">8.2</a>.  Handling of Pending IPsec Messages</span>

   For IPsec, there is often a trade-off between security and
   reliability of the protected protocols.  Here again, there is some
   leeway for local policy.  Some implementations might accept incoming






<span class="grey">Singh, et al.                Standards Track                   [Page 18]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-19" id="page-19" name="page-19"> </a>
<span class="grey"><a href="rfc6311.html">RFC 6311</a>            High Availability in IKEv2/IPsec           July 2011</span>


   traffic that is outside the replay window for some time after the
   failover event, and until the counters had been synchronized.  Strict
   implementations will only accept traffic that's inside the "safe"
   window.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/8.3.%20%20IKE%20SA%20Inconsistencies"></a><a class="selflink" href="#section-8.3" name="section-8.3">8.3</a>.  IKE SA Inconsistencies</span>

   IKEv2 is normally a reliable protocol.  As long as an IKE SA is
   valid, both peers share a single, consistent view of the IKE SA and
   all associated Child SAs.  Failover situations as described in this
   document may involve forced deletion of IKE messages, resulting in
   inconsistencies, such as Child SAs that exist on only one of the
   peers.  Such SAs might cause an INVALID_SPI to be returned when used
   by that peer.  Note that Section 1.5 of [<a href="#ref-4" title='"Internet Key Exchange Protocol Version 2 (IKEv2)"'>4</a>] allows but does not
   mandate sending an INVALID_SPI notification in this case.

   The IPsecME Working Group discussed at some point a proposed set of
   rules for dealing with such situations.  However, we believe that
   these situations should be rare in practice; as a result, the
   "default" behavior of tearing down the entire IKE SA is to be
   preferred over the complexity of dealing with a multitude of edge
   cases.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/9.%20%20Step-by-Step%20Details"></a><a class="selflink" href="#section-9" name="section-9">9</a>.  Step-by-Step Details</span>

   This section goes through the sequence of steps of a typical failover
   event, looking at a case where the IKEv2 Message ID values are
   synchronized.

   o  The active cluster member and the peer device establish the
      session.  They both announce the capability to synchronize counter
      information by sending the IKEV2_MESSAGE_ID_SYNC_SUPPORTED
      notification in the IKE_AUTH exchange.

   o  Some time later, the active member dies, and a standby member
      takes over.  The standby member sends its own idea of the IKE
      Message IDs (both incoming and outgoing) to the peer in an
      Informational message exchange with Message ID zero.

   o  The peer first authenticates the message.  The peer compares the
      received values with the values available locally and picks the
      higher value.  It then updates its Message IDs with the higher
      values and also proposes the same values in its response.

   o  The peer should not wait for any pending responses while
      responding with the new Message ID values.  For example, if the
      window size is 5 and the peer's window is 3-7, and if the peer has
      sent requests 3, 4, 5, 6, and 7 and received responses only for 4,



<span class="grey">Singh, et al.                Standards Track                   [Page 19]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-20" id="page-20" name="page-20"> </a>
<span class="grey"><a href="rfc6311.html">RFC 6311</a>            High Availability in IKEv2/IPsec           July 2011</span>


      5, 6, and 7 but not for 3, then it should include the value 8 in
      its EXPECTED_SEND_REQ_MESSAGE_ID payload and should not wait for a
      response to message 3 any more.

   o  Similarly, the peer should also not wait for pending (incoming)
      requests.  For example, if the window size is 5 and the peer's
      window is 3-7, and if the peer has received requests 4, 5, 6, and
      7 but not 3, then it should send the value 8 in the
      EXPECTED_RECV_REQ_MESSAGE_ID payload, and should not expect to
      receive message 3 any more.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/10.%20%20Interaction%20with%20Other%20Specifications"></a><a class="selflink" href="#section-10" name="section-10">10</a>.  Interaction with Other Specifications</span>

   The usage scenario of this IKEv2/IPsec SA counter synchronization
   solution is that an IKEv2 SA has been established between the active
   member of a hot standby cluster and a peer, followed by a failover
   event occurring and the standby member becoming active.  The solution
   further assumes that the IKEv2 SA state was continuously synchronized
   between the active and standby members of the cluster before the
   failover event.

   o  Session resumption [<a href="#ref-12" title='"Internet Key Exchange Protocol Version 2 (IKEv2) Session Resumption"'>12</a>] assumes that a peer (client or initiator)
      detects the need to re-establish the session.  In IKEv2/IPsec SA
      counter synchronization, it is the newly active member (a gateway
      or responder) that detects the need to synchronize the SA counter
      after the failover event.  Also, in a hot standby cluster, the
      peer establishes the IKEv2/IPsec session with a single IP address
      that represents the whole cluster, so the peer normally does not
      detect the event of failover in the cluster unless the standby
      member takes too long to become active and the IKEv2 SA times out
      by use of the IKEv2 liveness check mechanism.  To conclude,
      session resumption and SA counter synchronization after failover
      are mutually exclusive: they are not expected to be used together,
      and both features can coexist within the same implementation
      without affecting each other.

   o  The IKEv2 Redirect mechanism for load balancing [<a href="#ref-13" title='"Redirect Mechanism for the Internet Key Exchange Protocol Version 2 (IKEv2)"'>13</a>] can be used
      either during the initial stages of SA setup (the IKE_SA_INIT and
      IKE_AUTH exchanges) or after session establishment.  SA counter
      synchronization is only useful after the IKE SA has been
      established and a failover event has occurred.  So, unlike
      Redirect, it is irrelevant during the first two exchanges.
      Redirect after the session has been established is mostly useful








<span class="grey">Singh, et al.                Standards Track                   [Page 20]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-21" id="page-21" name="page-21"> </a>
<span class="grey"><a href="rfc6311.html">RFC 6311</a>            High Availability in IKEv2/IPsec           July 2011</span>


      for timed or planned shutdown/maintenance.  A real failover event
      cannot be detected by the active member ahead of time, and so
      using Redirect after session establishment is not possible in the
      case of failover.  So, Redirect and SA counter synchronization
      after failover are mutually exclusive, in the sense described
      above.

   o  IKEv2 Failure Detection [<a href="#ref-8" title='"A Quick Crash Detection Method for the Internet Key Exchange Protocol (IKE)"'>8</a>] solves a similar problem where the
      peer can rapidly detect that a cluster member has crashed based on
      a token.  It is unrelated to the current scenario, because the
      goal in failover is for the peer not to notice that a failure has
      occurred.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/11.%20%20Security%20Considerations"></a><a class="selflink" href="#section-11" name="section-11">11</a>.  Security Considerations</span>

   Since Message ID synchronization messages need to be sent with
   Message ID zero, they are potentially vulnerable to replay attacks.
   Because of the semantics of this protocol, these can only be denial-
   of-service (DoS) attacks, and we are aware of two variants.

   o  Replay of Message ID synchronization request: This is countered by
      the requirement that the Send counter sent by the cluster member
      should always be monotonically increasing, a rule that the peer
      enforces by silently dropping messages that contradict it.

   o  Replay of the Message ID synchronization response: This is
      countered by sending the nonce data along with the synchronization
      payload.  The same nonce data has to be returned in the response.
      Thus, the standby member will accept a reply only for the current
      request.  After it receives a valid response, it MUST NOT process
      the same response again and MUST discard any additional responses.

   As mentioned in <a href="#section-7">Section 7</a>, triggering counter synchronization by out-
   of-window, potentially replayed messages could open a DoS
   vulnerability.  This risk is mitigated by the solution described in
   that section.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/12.%20%20IANA%20Considerations"></a><a class="selflink" href="#section-12" name="section-12">12</a>.  IANA Considerations</span>

   This document introduces four new IKEv2 Notification Message types as
   described in <a href="#section-6">Section 6</a>.  The new Notify Message Types have been
   assigned values as follows.









<span class="grey">Singh, et al.                Standards Track                   [Page 21]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-22" id="page-22" name="page-22"> </a>
<span class="grey"><a href="rfc6311.html">RFC 6311</a>            High Availability in IKEv2/IPsec           July 2011</span>


              +-------------------------------------+-------+
              | Name                                | Value |
              +-------------------------------------+-------+
              | IKEV2_MESSAGE_ID_SYNC_SUPPORTED     | 16420 |
              | IPSEC_REPLAY_COUNTER_SYNC_SUPPORTED | 16421 |
              | IKEV2_MESSAGE_ID_SYNC               | 16422 |
              | IPSEC_REPLAY_COUNTER_SYNC           | 16423 |
              +-------------------------------------+-------+

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/13.%20%20Acknowledgements"></a><a class="selflink" href="#section-13" name="section-13">13</a>.  Acknowledgements</span>

   We would like to thank Pratima Sethi and Frederic Detienne for their
   review comments and valuable suggestions for the initial version of
   the document.

   We would also like to thank the following people (in alphabetical
   order) for their review comments and valuable suggestions: Dan
   Harkins, Paul Hoffman, Steve Kent, Tero Kivinen, David McGrew, and
   Pekka Riikonen.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/14.%20%20References"></a><a class="selflink" href="#section-14" name="section-14">14</a>.  References</span>

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/14.1.%20%20Normative%20References"></a><a class="selflink" href="#section-14.1" name="section-14.1">14.1</a>.  Normative References</span>

   [<a id="ref-1" name="ref-1">1</a>]   Bradner, S., "Key words for use in RFCs to Indicate Requirement
         Levels", <a href="https://tools.ietf.org/html/bcp14">BCP 14</a>, <a href="rfc2119.html">RFC 2119</a>, March 1997.

   [<a id="ref-2" name="ref-2">2</a>]   Kent, S., "IP Encapsulating Security Payload (ESP)", <a href="rfc4303.html">RFC 4303</a>,
         December 2005.

   [<a id="ref-3" name="ref-3">3</a>]   Kent, S., "IP Authentication Header", <a href="rfc4302.html">RFC 4302</a>, December 2005.

   [<a id="ref-4" name="ref-4">4</a>]   Kaufman, C., Hoffman, P., Nir, Y., and P. Eronen, "Internet Key
         Exchange Protocol Version 2 (IKEv2)", <a href="rfc5996.html">RFC 5996</a>, September 2010.

   [<a id="ref-5" name="ref-5">5</a>]   Kent, S. and K. Seo, "Security Architecture for the Internet
         Protocol", <a href="rfc4301.html">RFC 4301</a>, December 2005.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/14.2.%20%20Informative%20References"></a><a class="selflink" href="#section-14.2" name="section-14.2">14.2</a>.  Informative References</span>

   [<a id="ref-6" name="ref-6">6</a>]   Nir, Y., "IPsec Cluster Problem Statement", <a href="rfc6027.html">RFC 6027</a>,
         October 2010.

   [<a id="ref-7" name="ref-7">7</a>]   Nadas, S., Ed., "Virtual Router Redundancy Protocol (VRRP)
         Version 3 for IPv4 and IPv6", <a href="rfc5798.html">RFC 5798</a>, March 2010.






<span class="grey">Singh, et al.                Standards Track                   [Page 22]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-23" id="page-23" name="page-23"> </a>
<span class="grey"><a href="rfc6311.html">RFC 6311</a>            High Availability in IKEv2/IPsec           July 2011</span>


   [<a id="ref-8" name="ref-8">8</a>]   Nir, Y., Ed., Wierbowski, D., Detienne, F., and P. Sethi, "A
         Quick Crash Detection Method for the Internet Key Exchange
         Protocol (IKE)", <a href="rfc6290.html">RFC 6290</a>, June 2011.

   [<a id="ref-9" name="ref-9">9</a>]   Housley, R., "Using Advanced Encryption Standard (AES) Counter
         Mode With IPsec Encapsulating Security Payload (ESP)",
         <a href="rfc3686.html">RFC 3686</a>, January 2004.

   [<a id="ref-10" name="ref-10">10</a>]  Viega, J. and D. McGrew, "The Use of Galois/Counter Mode (GCM)
         in IPsec Encapsulating Security Payload (ESP)", <a href="rfc4106.html">RFC 4106</a>,
         June 2005.

   [<a id="ref-11" name="ref-11">11</a>]  McGrew, D. and B. Weis, "Using Counter Modes with Encapsulating
         Security Payload (ESP) and Authentication Header (AH) to
         Protect Group Traffic", <a href="rfc6054.html">RFC 6054</a>, November 2010.

   [<a id="ref-12" name="ref-12">12</a>]  Sheffer, Y. and H. Tschofenig, "Internet Key Exchange Protocol
         Version 2 (IKEv2) Session Resumption", <a href="rfc5723.html">RFC 5723</a>, January 2010.

   [<a id="ref-13" name="ref-13">13</a>]  Devarapalli, V. and K. Weniger, "Redirect Mechanism for the
         Internet Key Exchange Protocol Version 2 (IKEv2)", <a href="rfc5685.html">RFC 5685</a>,
         November 2009.





























<span class="grey">Singh, et al.                Standards Track                   [Page 23]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-24" id="page-24" name="page-24"> </a>
<span class="grey"><a href="rfc6311.html">RFC 6311</a>            High Availability in IKEv2/IPsec           July 2011</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/Appendix%20A.%20%20IKEv2%20Message%20ID%20Sync%20Examples"></a><a class="selflink" href="#appendix-A" name="appendix-A">Appendix A</a>.  IKEv2 Message ID Sync Examples</span>

   This (non-normative) section presents some examples that illustrate
   how the IKEv2 Message ID values are synchronized.  We use a tuple
   notation, denoting the two counters EXPECTED_SEND_REQ_MESSAGE_ID and
   EXPECTED_RECV_REQ_MESSAGE_ID on each protocol party as
   (EXPECTED_SEND_REQ_MESSAGE_ID, EXPECTED_RECV_REQ_MESSAGE_ID).

   Note that if the IKE message counters are already synchronized (as in
   the first example), we expect the numbers to be reversed between the
   two sides.  If one protocol party intends to send the next request as
   4, then the other expects the next received request to be 4.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/A.1.%20%20Normal%20Failover%20--%20Example%201"></a><a class="selflink" href="#appendix-A.1" name="appendix-A.1">A.1</a>.  Normal Failover -- Example 1</span>

   Standby (Newly Active) Member                            Peer
   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
   Sync Request (0, 5) --------&gt;

                             Peer has the values (5, 0), so it sends
                &lt;------------- (5, 0) as the Sync Response

   In this example, the peer has most recently sent an IKE request with
   Message ID 4, and has never received a request.  So the peer's
   expected values for the next pair of messages are (5, 0).  These are
   the same values as received from the member, and therefore they are
   sent as-is.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/A.2.%20%20Normal%20Failover%20--%20Example%202"></a><a class="selflink" href="#appendix-A.2" name="appendix-A.2">A.2</a>.  Normal Failover -- Example 2</span>

   Standby (Newly Active) Member                            Peer
   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
   Sync Request (2, 3) --------&gt;

                             Peer has the values (4, 5), so it sends
                &lt;------------- (4, 5) as the Sync Response

   In this example, the peer has most recently sent an IKE message with
   the Message ID 3, and received one with ID 4.  So the peer's expected
   values for the next pair of messages are (4, 5).  These are both
   higher than the corresponding values just received from the member
   (the order of tuple members is reversed when doing this comparison!),
   and therefore they are sent as-is.








<span class="grey">Singh, et al.                Standards Track                   [Page 24]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-25" id="page-25" name="page-25"> </a>
<span class="grey"><a href="rfc6311.html">RFC 6311</a>            High Availability in IKEv2/IPsec           July 2011</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/A.3.%20%20Normal%20Failover%20--%20Example%203"></a><a class="selflink" href="#appendix-A.3" name="appendix-A.3">A.3</a>.  Normal Failover -- Example 3</span>

   Standby (Newly Active) Member                            Peer
   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
   Sync Request (2, 5) --------&gt;

                             Peer has the values (2, 4), so it sends
                &lt;-------------(5, 4) as the Sync Response

   In this example, the newly active member expects to send the next IKE
   message with ID 2.  It sends an expected receive value of 5, which is
   higher than the last ID value it has seen from the peer, because it
   believes some incoming messages may have been lost.  The peer has
   last sent a message with ID 1, and received one with ID 3, indicating
   that a couple of messages sent by the previously active member had
   not been synchronized into the other member.  So the peer's next
   expected (send, receive) values are (2, 4).  The peer replies with
   the maximum of the received and the expected value for both send and
   receive counters: (max(2, 5), max(4, 2)) = (5, 4).

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/A.4.%20%20Simultaneous%20Failover"></a><a class="selflink" href="#appendix-A.4" name="appendix-A.4">A.4</a>.  Simultaneous Failover</span>

   In the case of simultaneous failover, both sides send their
   synchronization requests simultaneously.  The eventual outcome of
   synchronization consists of the higher counter values.  This is
   demonstrated in the following figure.

   Standby (Newly Active) Member                            Peer
   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

   Sync Request (4,4)     -----&gt;

                    &lt;-------------- Sync Request (5,5)

   Sync Response (5,5)    ----&gt;

                        &lt;--------  Sync Response (5,5)














<span class="grey">Singh, et al.                Standards Track                   [Page 25]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-26" id="page-26" name="page-26"> </a>
<span class="grey"><a href="rfc6311.html">RFC 6311</a>            High Availability in IKEv2/IPsec           July 2011</span>


Authors' Addresses

   Raj Singh (editor)
   Cisco Systems, Inc.
   Divyashree Chambers, B Wing, O'Shaugnessy Road
   Bangalore, Karnataka  560025
   India

   Phone: +91 80 4301 3320
   EMail: rsj@cisco.com


   Kalyani Garigipati
   Cisco Systems, Inc.
   Divyashree Chambers, B Wing, O'Shaugnessy Road
   Bangalore, Karnataka  560025
   India

   Phone: +91 80 4426 4831
   EMail: kagarigi@cisco.com


   Yoav Nir
   Check Point Software Technologies Ltd.
   5 Hasolelim St.
   Tel Aviv  67897
   Israel

   EMail: ynir@checkpoint.com


   Yaron Sheffer
   Porticor Cloud Security

   EMail: yaronf.ietf@gmail.com


   Dacheng Zhang
   Huawei Technologies Ltd.

   EMail: zhangdacheng@huawei.com










Singh, et al.                Standards Track                   [Page 26]

</pre><br/>
    <span class="noprint"><small><small>Html markup produced by rfcmarkup 1.126, available from
      <a href="https://tools.ietf.org/tools/rfcmarkup/">https://tools.ietf.org/tools/rfcmarkup/</a>
    </small></small></span>
  </div>




</body><!-- Mirrored from tools.ietf.org/html/rfc6311 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 06 Mar 2018 23:18:30 GMT --></html>