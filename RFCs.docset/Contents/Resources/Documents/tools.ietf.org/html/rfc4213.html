<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml"><!-- Mirrored from tools.ietf.org/html/rfc4213 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 06 Mar 2018 23:18:42 GMT --><!-- Added by HTTrack --><head><meta content="text/html;charset=utf-8" http-equiv="content-type"/><!-- /Added by HTTrack -->

    <meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
    <meta content="index,follow" name="robots"/>
    <meta content="rfcmarkup version 1.126" name="creator"/>
    <link href="http://purl.org/dc/elements/1.1/" rel="schema.DC"/>
<meta content="rfc2893" name="DC.Relation.Replaces"/>
<meta content="urn:ietf:rfc:4213" name="DC.Identifier"/>
<meta content="October, 2005" name="DC.Date.Issued"/>
<meta content="Gilligan, Robert E." name="DC.Creator"/>
<meta content="Nordmark, Erik" name="DC.Creator"/>
<meta content="This document specifies IPv4 compatibility mechanisms that can be
implemented by IPv6 hosts and routers. Two mechanisms are specified,
dual stack and configured tunneling. Dual stack implies providing
complete implementations of both versions of the Internet Protocol
(IPv4 and IPv6), and configured tunneling provides a means to carry
IPv6 packets over unmodified IPv4 routing infrastructures.  This
document obsoletes RFC 2893. [STANDARDS-TRACK]" name="DC.Description.Abstract"/>
<meta content="Basic Transition Mechanisms for IPv6 Hosts and Routers" name="DC.Title"/>

    <link href="https://tools.ietf.org/images/rfc.png" rel="icon" type="image/png"/>
    <link href="https://tools.ietf.org/images/rfc.png" rel="shortcut icon" type="image/png"/>
    <title>RFC 4213 - Basic Transition Mechanisms for IPv6 Hosts and Routers</title>
    
    
    <style type="text/css">
	@media only screen 
	  and (min-width: 992px)
	  and (max-width: 1199px) {
	    body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 768px)
	  and (max-width: 991px) {
            body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 480px)
	  and (max-width: 767px) {
            body { font-size: 11pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (max-width: 479px) {
            body { font-size: 8pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-device-width : 375px) 
	  and (max-device-width : 667px) {
            body { font-size: 9.5pt; }
            div.content { width: 96ex; margin: 0 1px; }
        }
	@media only screen 
	  and (min-device-width: 1200px) {
            body { font-size: 10pt; margin: 0 4em; }
            div.content { width: 96ex; margin: 0; }
        }
        h1, h2, h3, h4, h5, h6, .h1, .h2, .h3, .h4, .h5, .h6 {
	    font-weight: bold;
            line-height: 0pt;
            display: inline;
            white-space: pre;
            font-family: monospace;
            font-size: 1em;
	    font-weight: bold;
        }
        pre {
            font-size: 1em;
            margin-top: 0px;
            margin-bottom: 0px;
        }
	.pre {
	    white-space: pre;
	    font-family: monospace;
	}
	.header{
	    font-weight: bold;
	}
        .newpage {
            page-break-before: always;
        }
        .invisible {
            text-decoration: none;
            color: white;
        }
        a.selflink {
          color: black;
          text-decoration: none;
        }
        @media print {
            body {
                font-family: monospace;
                font-size: 10.5pt;
            }
            h1, h2, h3, h4, h5, h6 {
                font-size: 1em;
            }
        
            a:link, a:visited {
                color: inherit;
                text-decoration: none;
            }
            .noprint {
                display: none;
            }
        }
	@media screen {
	    .grey, .grey a:link, .grey a:visited {
		color: #777;
	    }
            .docinfo {
                background-color: #EEE;
            }
            .top {
                border-top: 7px solid #EEE;
            }
            .bgwhite  { background-color: white; }
            .bgred    { background-color: #F44; }
            .bggrey   { background-color: #666; }
            .bgbrown  { background-color: #840; }            
            .bgorange { background-color: #FA0; }
            .bgyellow { background-color: #EE0; }
            .bgmagenta{ background-color: #F4F; }
            .bgblue   { background-color: #66F; }
            .bgcyan   { background-color: #4DD; }
            .bggreen  { background-color: #4F4; }

            .legend   { font-size: 90%; }
            .cplate   { font-size: 70%; border: solid grey 1px; }
	}
    </style>
    <!--[if IE]>
    <style>
    body {
       font-size: 13px;
       margin: 10px 10px;
    }
    </style>
    <![endif]-->

    <script type="text/javascript"><!--
    function addHeaderTags() {
	var spans = document.getElementsByTagName("span");
	for (var i=0; i < spans.length; i++) {
	    var elem = spans[i];
	    if (elem) {
		var level = elem.getAttribute("class");
                if (level == "h1" || level == "h2" || level == "h3" || level == "h4" || level == "h5" || level == "h6") {
                    elem.innerHTML = "<"+level+">"+elem.innerHTML+"</"+level+">";		
                }
	    }
	}
    }
    var legend_html = "Colour legend:<br />      <table>         <tr><td>Unknown:</td>                   <td><span class='cplate bgwhite'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft:</td>                     <td><span class='cplate bgred'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Informational:</td>             <td><span class='cplate bgorange'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Experimental:</td>              <td><span class='cplate bgyellow'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Best Common Practice:</td>      <td><span class='cplate bgmagenta'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Proposed Standard:</td>         <td><span class='cplate bgblue'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft Standard (old designation):</td> <td><span class='cplate bgcyan'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Internet Standard:</td>         <td><span class='cplate bggreen'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Historic:</td>                  <td><span class='cplate bggrey'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Obsolete:</td>                  <td><span class='cplate bgbrown'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>     </table>";
    function showElem(id) {
        var elem = document.getElementById(id);
        elem.innerHTML = eval(id+"_html");
        elem.style.visibility='visible';
    }
    function hideElem(id) {
        var elem = document.getElementById(id);
        elem.style.visibility='hidden';        
        elem.innerHTML = "";
    }
    // -->
    </script>
</head>
<body onload="addHeaderTags()">
  <div class="content">
   <div style="height: 13px;">
      <div class="pre noprint docinfo bgblue" onclick="showElem('legend');" onmouseout="hideElem('legend')" onmouseover="this.style.cursor='pointer';" style="height: 6px; position: absolute;" title="Click for colour legend.">                                                                        </div>
      <div class="docinfo noprint pre legend" id="legend" onmouseout="hideElem('legend');" onmouseover="showElem('legend');" style="position:absolute; top: 4px; left: 4ex; visibility:hidden; background-color: white; padding: 4px 9px 5px 7px; border: solid #345 1px; ">
      </div>
   </div>
<span class="pre noprint docinfo top">[<a href="index.html" title="Document search and retrieval page">Docs</a>] [<a href="https://tools.ietf.org/rfc/rfc4213.txt" title="Plaintext version of this document">txt</a>|<a href="https://tools.ietf.org/pdf/rfc4213" title="PDF version of this document">pdf</a>] [<a href="https://tools.ietf.org/html/draft-ietf-v6ops-mech-v2" title="draft-ietf-v6ops-mech-v2">draft-ietf-v6op...</a>] [<a href="https://datatracker.ietf.org/doc/rfc4213" title="IESG Datatracker information for this document">Tracker</a>] [<a href="https://tools.ietf.org/rfcdiff?difftype=--hwdiff&amp;url2=rfc4213" title="Inline diff (wdiff)">Diff1</a>] [<a href="https://tools.ietf.org/rfcdiff?url2=rfc4213" title="Side-by-side diff">Diff2</a>] [<a href="https://datatracker.ietf.org/ipr/search/?rfc=4213&amp;submit=rfc" title="IPR disclosures related to this document">IPR</a>] [<a href="https://www.rfc-editor.org/errata_search.php?rfc=4213">Errata</a>]</span><br/>
<span class="pre noprint docinfo">                                                                        </span><br/>
<span class="pre noprint docinfo">                                                       PROPOSED STANDARD</span><br/>
<span class="pre noprint docinfo">                                                            <span style="color: #C00;">Errata Exist</span></span><br/>
<pre>Network Working Group                                        E. Nordmark
Request for Comments: 4213                        Sun Microsystems, Inc.
Obsoletes: <a href="rfc2893.html">2893</a>                                              R. Gilligan
Category: Standards Track                                 Intransa, Inc.
                                                            October 2005


         <span class="h1">Basic Transition Mechanisms for IPv6 Hosts and Routers</span>

Status of This Memo

   This document specifies an Internet standards track protocol for the
   Internet community, and requests discussion and suggestions for
   improvements.  Please refer to the current edition of the "Internet
   Official Protocol Standards" (STD 1) for the standardization state
   and status of this protocol.  Distribution of this memo is unlimited.

Copyright Notice

   Copyright (C) The Internet Society (2005).

Abstract

   This document specifies IPv4 compatibility mechanisms that can be
   implemented by IPv6 hosts and routers.  Two mechanisms are specified,
   dual stack and configured tunneling.  Dual stack implies providing
   complete implementations of both versions of the Internet Protocol
   (IPv4 and IPv6), and configured tunneling provides a means to carry
   IPv6 packets over unmodified IPv4 routing infrastructures.

   This document obsoletes <a href="rfc2893.html">RFC 2893</a>.




















<span class="grey">Nordmark &amp; Gilligan         Standards Track                     [Page 1]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-2" id="page-2" name="page-2"> </a>
<span class="grey"><a href="rfc4213.html">RFC 4213</a>            Basic IPv6 Transition Mechanisms        October 2005</span>


Table of Contents

   <a href="#section-1">1</a>. Introduction ....................................................<a href="#page-2">2</a>
      <a href="#section-1.1">1.1</a>. Terminology ................................................<a href="#page-3">3</a>
   <a href="#section-2">2</a>. Dual IP Layer Operation .........................................<a href="#page-4">4</a>
      <a href="#section-2.1">2.1</a>. Address Configuration ......................................<a href="#page-5">5</a>
      <a href="#section-2.2">2.2</a>. DNS ........................................................<a href="#page-5">5</a>
   <a href="#section-3">3</a>. Configured Tunneling Mechanisms .................................<a href="#page-6">6</a>
      <a href="#section-3.1">3.1</a>. Encapsulation ..............................................<a href="#page-7">7</a>
      <a href="#section-3.2">3.2</a>. Tunnel MTU and Fragmentation ...............................<a href="#page-8">8</a>
           <a href="#section-3.2.1">3.2.1</a>. Static Tunnel MTU ...................................<a href="#page-9">9</a>
           <a href="#section-3.2.2">3.2.2</a>. Dynamic Tunnel MTU ..................................<a href="#page-9">9</a>
      <a href="#section-3.3">3.3</a>. Hop Limit .................................................<a href="#page-11">11</a>
      <a href="#section-3.4">3.4</a>. Handling ICMPv4 Errors ....................................<a href="#page-11">11</a>
      <a href="#section-3.5">3.5</a>. IPv4 Header Construction ..................................<a href="#page-13">13</a>
      <a href="#section-3.6">3.6</a>. Decapsulation .............................................<a href="#page-14">14</a>
      <a href="#section-3.7">3.7</a>. Link-Local Addresses ......................................<a href="#page-17">17</a>
      <a href="#section-3.8">3.8</a>. Neighbor Discovery over Tunnels ...........................<a href="#page-18">18</a>
   <a href="#section-4">4</a>. Threat Related to Source Address Spoofing ......................<a href="#page-18">18</a>
   <a href="#section-5">5</a>. Security Considerations ........................................<a href="#page-19">19</a>
   <a href="#section-6">6</a>. Acknowledgements ...............................................<a href="#page-21">21</a>
   <a href="#section-7">7</a>. References .....................................................<a href="#page-21">21</a>
      <a href="#section-7.1">7.1</a>. Normative References ......................................<a href="#page-21">21</a>
      <a href="#section-7.2">7.2</a>. Informative References ....................................<a href="#page-21">21</a>
   <a href="#section-8">8</a>. Changes from <a href="rfc2893.html">RFC 2893</a> ..........................................<a href="#page-23">23</a>

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/1.%20%20Introduction"></a><a class="selflink" href="#section-1" name="section-1">1</a>.  Introduction</span>

   The key to a successful IPv6 transition is compatibility with the
   large installed base of IPv4 hosts and routers.  Maintaining
   compatibility with IPv4 while deploying IPv6 will streamline the task
   of transitioning the Internet to IPv6.  This specification defines
   two mechanisms that IPv6 hosts and routers may implement in order to
   be compatible with IPv4 hosts and routers.

   The mechanisms in this document are designed to be employed by IPv6
   hosts and routers that need to interoperate with IPv4 hosts and
   utilize IPv4 routing infrastructures.  We expect that most nodes in
   the Internet will need such compatibility for a long time to come,
   and perhaps even indefinitely.

   The mechanisms specified here are:

   -  Dual IP layer (also known as dual stack):  A technique for
      providing complete support for both Internet protocols -- IPv4 and
      IPv6 -- in hosts and routers.





<span class="grey">Nordmark &amp; Gilligan         Standards Track                     [Page 2]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-3" id="page-3" name="page-3"> </a>
<span class="grey"><a href="rfc4213.html">RFC 4213</a>            Basic IPv6 Transition Mechanisms        October 2005</span>


   -  Configured tunneling of IPv6 over IPv4:  A technique for
      establishing point-to-point tunnels by encapsulating IPv6 packets
      within IPv4 headers to carry them over IPv4 routing
      infrastructures.

   The mechanisms defined here are intended to be the core of a
   "transition toolbox" -- a growing collection of techniques that
   implementations and users may employ to ease the transition.  The
   tools may be used as needed.  Implementations and sites decide which
   techniques are appropriate to their specific needs.

   This document defines the basic set of transition mechanisms, but
   these are not the only tools available.  Additional transition and
   compatibility mechanisms are specified in other documents.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/1.1.%20%20Terminology"></a><a class="selflink" href="#section-1.1" name="section-1.1">1.1</a>.  Terminology</span>

   The following terms are used in this document:

   Types of Nodes

      IPv4-only node:

         A host or router that implements only IPv4.  An IPv4-only node
         does not understand IPv6.  The installed base of IPv4 hosts and
         routers existing before the transition begins are IPv4-only
         nodes.

      IPv6/IPv4 node:

         A host or router that implements both IPv4 and IPv6.

      IPv6-only node:

         A host or router that implements IPv6 and does not implement
         IPv4.  The operation of IPv6-only nodes is not addressed in
         this memo.

      IPv6 node:

         Any host or router that implements IPv6.  IPv6/IPv4 and IPv6-
         only nodes are both IPv6 nodes.

      IPv4 node:

         Any host or router that implements IPv4.  IPv6/IPv4 and IPv4-
         only nodes are both IPv4 nodes.




<span class="grey">Nordmark &amp; Gilligan         Standards Track                     [Page 3]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-4" id="page-4" name="page-4"> </a>
<span class="grey"><a href="rfc4213.html">RFC 4213</a>            Basic IPv6 Transition Mechanisms        October 2005</span>


   Techniques Used in the Transition

      IPv6-over-IPv4 tunneling:

         The technique of encapsulating IPv6 packets within IPv4 so that
         they can be carried across IPv4 routing infrastructures.

      Configured tunneling:

         IPv6-over-IPv4 tunneling where the IPv4 tunnel endpoint
         address(es) are determined by configuration information on
         tunnel endpoints.  All tunnels are assumed to be bidirectional.
         The tunnel provides a (virtual) point-to-point link to the IPv6
         layer, using the configured IPv4 addresses as the lower-layer
         endpoint addresses.

   Other transition mechanisms, including other tunneling mechanisms,
   are outside the scope of this document.

   The key words MUST, MUST NOT, REQUIRED, SHALL, SHALL NOT, SHOULD,
   SHOULD NOT, RECOMMENDED, MAY, and OPTIONAL, when they appear in this
   document, are to be interpreted as described in [<a href="rfc2119.html" title='"Key words for use in RFCs to Indicate Requirement Levels"'>RFC2119</a>].

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/2.%20%20Dual%20IP%20Layer%20Operation"></a><a class="selflink" href="#section-2" name="section-2">2</a>.  Dual IP Layer Operation</span>

   The most straightforward way for IPv6 nodes to remain compatible with
   IPv4-only nodes is by providing a complete IPv4 implementation.  IPv6
   nodes that provide complete IPv4 and IPv6 implementations are called
   "IPv6/IPv4 nodes".  IPv6/IPv4 nodes have the ability to send and
   receive both IPv4 and IPv6 packets.  They can directly interoperate
   with IPv4 nodes using IPv4 packets, and also directly interoperate
   with IPv6 nodes using IPv6 packets.

   Even though a node may be equipped to support both protocols, one or
   the other stack may be disabled for operational reasons.  Here we use
   a rather loose notion of "stack".  A stack being enabled has IP
   addresses assigned, but whether or not any particular application is
   available on the stacks is explicitly not defined.  Thus, IPv6/IPv4
   nodes may be operated in one of three modes:

   -  With their IPv4 stack enabled and their IPv6 stack disabled.

   -  With their IPv6 stack enabled and their IPv4 stack disabled.

   -  With both stacks enabled.

   IPv6/IPv4 nodes with their IPv6 stack disabled will operate like
   IPv4-only nodes.  Similarly, IPv6/IPv4 nodes with their IPv4 stacks



<span class="grey">Nordmark &amp; Gilligan         Standards Track                     [Page 4]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-5" id="page-5" name="page-5"> </a>
<span class="grey"><a href="rfc4213.html">RFC 4213</a>            Basic IPv6 Transition Mechanisms        October 2005</span>


   disabled will operate like IPv6-only nodes.  IPv6/IPv4 nodes MAY
   provide a configuration switch to disable either their IPv4 or IPv6
   stack.

   The configured tunneling technique, which is described in <a href="#section-3">Section 3</a>,
   may or may not be used in addition to the dual IP layer operation.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/2.1.%20%20Address%20Configuration"></a><a class="selflink" href="#section-2.1" name="section-2.1">2.1</a>.  Address Configuration</span>

   Because the nodes support both protocols, IPv6/IPv4 nodes may be
   configured with both IPv4 and IPv6 addresses.  IPv6/IPv4 nodes use
   IPv4 mechanisms (e.g., DHCP) to acquire their IPv4 addresses, and
   IPv6 protocol mechanisms (e.g., stateless address autoconfiguration
   [<a href="rfc2462.html" title='"IPv6 Stateless Address Autoconfiguration"'>RFC2462</a>] and/or DHCPv6) to acquire their IPv6 addresses.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/2.2.%20%20DNS"></a><a class="selflink" href="#section-2.2" name="section-2.2">2.2</a>.  DNS</span>

   The Domain Naming System (DNS) is used in both IPv4 and IPv6 to map
   between hostnames and IP addresses.  A new resource record type named
   "AAAA" has been defined for IPv6 addresses [<a href="rfc3596.html" title='"DNS Extensions to Support IP Version 6"'>RFC3596</a>].  Since
   IPv6/IPv4 nodes must be able to interoperate directly with both IPv4
   and IPv6 nodes, they must provide resolver libraries capable of
   dealing with IPv4 "A" records as well as IPv6 "AAAA" records.  Note
   that the lookup of A versus AAAA records is independent of whether
   the DNS packets are carried in IPv4 or IPv6 packets and that there is
   no assumption that the DNS servers know the IPv4/IPv6 capabilities of
   the requesting node.

   The issues and operational guidelines for using IPv6 with DNS are
   described at more length in other documents, e.g., [<a href="#ref-DNSOPV6" title='"Operational Considerations and Issues with IPv6 DNS"'>DNSOPV6</a>].

   DNS resolver libraries on IPv6/IPv4 nodes MUST be capable of handling
   both AAAA and A records.  However, when a query locates an AAAA
   record holding an IPv6 address, and an A record holding an IPv4
   address, the resolver library MAY order the results returned to the
   application in order to influence the version of IP packets used to
   communicate with that specific node -- IPv6 first, or IPv4 first.

   The applications SHOULD be able to specify whether they want IPv4,
   IPv6, or both records [<a href="rfc3493.html" title='"Basic Socket Interface Extensions for IPv6"'>RFC3493</a>].  That defines which address families
   the resolver looks up.  If there is not an application choice, or if
   the application has requested both, the resolver library MUST NOT
   filter out any records.

   Since most applications try the addresses in the order they are
   returned by the resolver, this can affect the IP version "preference"
   of applications.




<span class="grey">Nordmark &amp; Gilligan         Standards Track                     [Page 5]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-6" id="page-6" name="page-6"> </a>
<span class="grey"><a href="rfc4213.html">RFC 4213</a>            Basic IPv6 Transition Mechanisms        October 2005</span>


   The actual ordering mechanisms are out of scope of this memo.
   Address selection is described at more length in [<a href="rfc3484.html" title='"Default Address Selection for Internet Protocol version 6 (IPv6)"'>RFC3484</a>].

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/3.%20%20Configured%20Tunneling%20Mechanisms"></a><a class="selflink" href="#section-3" name="section-3">3</a>.  Configured Tunneling Mechanisms</span>

   In most deployment scenarios, the IPv6 routing infrastructure will be
   built up over time.  While the IPv6 infrastructure is being deployed,
   the existing IPv4 routing infrastructure can remain functional and
   can be used to carry IPv6 traffic.  Tunneling provides a way to
   utilize an existing IPv4 routing infrastructure to carry IPv6
   traffic.

   IPv6/IPv4 hosts and routers can tunnel IPv6 datagrams over regions of
   IPv4 routing topology by encapsulating them within IPv4 packets.
   Tunneling can be used in a variety of ways:

   -  Router-to-Router.  IPv6/IPv4 routers interconnected by an IPv4
      infrastructure can tunnel IPv6 packets between themselves.  In
      this case, the tunnel spans one segment of the end-to-end path
      that the IPv6 packet takes.

   -  Host-to-Router.  IPv6/IPv4 hosts can tunnel IPv6 packets to an
      intermediary IPv6/IPv4 router that is reachable via an IPv4
      infrastructure.  This type of tunnel spans the first segment of
      the packet's end-to-end path.

   -  Host-to-Host.  IPv6/IPv4 hosts that are interconnected by an IPv4
      infrastructure can tunnel IPv6 packets between themselves.  In
      this case, the tunnel spans the entire end-to-end path that the
      packet takes.

   -  Router-to-Host.  IPv6/IPv4 routers can tunnel IPv6 packets to
      their final destination IPv6/IPv4 host.  This tunnel spans only
      the last segment of the end-to-end path.

   Configured tunneling can be used in all of the above cases, but it is
   most likely to be used router-to-router due to the need to explicitly
   configure the tunneling endpoints.

   The underlying mechanisms for tunneling are:

   -  The entry node of the tunnel (the encapsulator) creates an
      encapsulating IPv4 header and transmits the encapsulated packet.

   -  The exit node of the tunnel (the decapsulator) receives the
      encapsulated packet, reassembles the packet if needed, removes the
      IPv4 header, and processes the received IPv6 packet.




<span class="grey">Nordmark &amp; Gilligan         Standards Track                     [Page 6]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-7" id="page-7" name="page-7"> </a>
<span class="grey"><a href="rfc4213.html">RFC 4213</a>            Basic IPv6 Transition Mechanisms        October 2005</span>


   -  The encapsulator may need to maintain soft-state information for
      each tunnel recording such parameters as the MTU of the tunnel in
      order to process IPv6 packets forwarded into the tunnel.

   In configured tunneling, the tunnel endpoint addresses are determined
   in the encapsulator from configuration information stored for each
   tunnel.  When an IPv6 packet is transmitted over a tunnel, the
   destination and source addresses for the encapsulating IPv4 header
   are set as described in <a href="#section-3.5">Section 3.5</a>.

   The determination of which packets to tunnel is usually made by
   routing information on the encapsulator.  This is usually done via a
   routing table, which directs packets based on their destination
   address using the prefix mask and match technique.

   The decapsulator matches the received protocol-41 packets to the
   tunnels it has configured, and allows only the packets in which IPv4
   source addresses match the tunnels configured on the decapsulator.
   Therefore, the operator must ensure that the tunnel's IPv4 address
   configuration is the same both at the encapsulator and the
   decapsulator.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.1.%20%20Encapsulation"></a><a class="selflink" href="#section-3.1" name="section-3.1">3.1</a>.  Encapsulation</span>

   The encapsulation of an IPv6 datagram in IPv4 is shown below:

                                             +-------------+
                                             |    IPv4     |
                                             |   Header    |
             +-------------+                 +-------------+
             |    IPv6     |                 |    IPv6     |
             |   Header    |                 |   Header    |
             +-------------+                 +-------------+
             |  Transport  |                 |  Transport  |
             |   Layer     |      ===&gt;       |   Layer     |
             |   Header    |                 |   Header    |
             +-------------+                 +-------------+
             |             |                 |             |
             ~    Data     ~                 ~    Data     ~
             |             |                 |             |
             +-------------+                 +-------------+

                      Encapsulating IPv6 in IPv4








<span class="grey">Nordmark &amp; Gilligan         Standards Track                     [Page 7]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-8" id="page-8" name="page-8"> </a>
<span class="grey"><a href="rfc4213.html">RFC 4213</a>            Basic IPv6 Transition Mechanisms        October 2005</span>


   In addition to adding an IPv4 header, the encapsulator also has to
   handle some more complex issues:

   -  Determine when to fragment and when to report an ICMPv6 "packet
      too big" error back to the source.

   -  How to reflect ICMPv4 errors from routers along the tunnel path
      back to the source as ICMPv6 errors.

   Those issues are discussed in the following sections.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.2.%20%20Tunnel%20MTU%20and%20Fragmentation"></a><a class="selflink" href="#section-3.2" name="section-3.2">3.2</a>.  Tunnel MTU and Fragmentation</span>

   Naively, the encapsulator could view encapsulation as IPv6 using IPv4
   as a link layer with a very large MTU (65535-20 bytes at most; 20
   bytes "extra" are needed for the encapsulating IPv4 header).  The
   encapsulator would only need to report ICMPv6 "packet too big" errors
   back to the source for packets that exceed this MTU.  However, such a
   scheme would be inefficient or non-interoperable for three reasons
   and therefore MUST NOT be used:

   1) It would result in more fragmentation than needed.  IPv4 layer
      fragmentation should be avoided due to the performance problems
      caused by the loss unit being smaller than the retransmission unit
      [<a href="#ref-KM97" title='"Fragmentation Considered Harmful"'>KM97</a>].

   2) Any IPv4 fragmentation occurring inside the tunnel, i.e., between
      the encapsulator and the decapsulator, would have to be
      reassembled at the tunnel endpoint.  For tunnels that terminate at
      a router, this would require additional memory and other resources
      to reassemble the IPv4 fragments into a complete IPv6 packet
      before that packet could be forwarded.

   3) The encapsulator has no way of knowing that the decapsulator is
      able to defragment such IPv4 packets (see <a href="#section-3.6">Section 3.6</a> for
      details), and has no way of knowing that the decapsulator is able
      to handle such a large IPv6 Maximum Receive Unit (MRU).

   Hence, the encapsulator MUST NOT treat the tunnel as an interface
   with an MTU of 64 kilobytes, but instead either use the fixed static
   MTU or OPTIONAL dynamic MTU determination based on the IPv4 path MTU
   to the tunnel endpoint.

   If both the mechanisms are implemented, the decision of which to use
   SHOULD be configurable on a per-tunnel endpoint basis.






<span class="grey">Nordmark &amp; Gilligan         Standards Track                     [Page 8]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-9" id="page-9" name="page-9"> </a>
<span class="grey"><a href="rfc4213.html">RFC 4213</a>            Basic IPv6 Transition Mechanisms        October 2005</span>


<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/3.2.1.%20%20Static%20Tunnel%20MTU"></a><a class="selflink" href="#section-3.2.1" name="section-3.2.1">3.2.1</a>.  Static Tunnel MTU</span>

   A node using static tunnel MTU treats the tunnel interface as having
   a fixed-interface MTU.  By default, the MTU MUST be between 1280 and
   1480 bytes (inclusive), but it SHOULD be 1280 bytes.  If the default
   is not 1280 bytes, the implementation MUST have a configuration knob
   that can be used to change the MTU value.

   A node must be able to accept a fragmented IPv6 packet that, after
   reassembly, is as large as 1500 octets [<a href="rfc2460.html" title='"Internet Protocol, Version 6 (IPv6) Specification"'>RFC2460</a>].  This memo also
   includes requirements (see <a href="#section-3.6">Section 3.6</a>) for the amount of IPv4
   reassembly and IPv6 MRU that MUST be supported by all the
   decapsulators.  These ensure correct interoperability with any fixed
   MTUs between 1280 and 1480 bytes.

   A larger fixed MTU than supported by these requirements must not be
   configured unless it has been administratively ensured that the
   decapsulator can reassemble or receive packets of that size.

   The selection of a good tunnel MTU depends on many factors, at least:

   -  Whether the IPv4 protocol-41 packets will be transported over
      media that may have a lower path MTU (e.g., IPv4 Virtual Private
      Networks); then picking too high a value might lead to IPv4
      fragmentation.

   -  Whether the tunnel is used to transport IPv6 tunneled packets
      (e.g., a mobile node with an IPv6-in-IPv4 configured tunnel, and
      an IPv6-in-IPv6 tunnel interface); then picking too low a value
      might lead to IPv6 fragmentation.

   If layered encapsulation is believed to be present, it may be prudent
   to consider supporting dynamic MTU determination instead as it is
   able to minimize fragmentation and optimize packet sizes.

   When using the static tunnel MTU, the Don't Fragment bit MUST NOT be
   set in the encapsulating IPv4 header.  As a result, the encapsulator
   should not receive any ICMPv4 "packet too big" messages as a result
   of the packets it has encapsulated.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/3.2.2.%20%20Dynamic%20Tunnel%20MTU"></a><a class="selflink" href="#section-3.2.2" name="section-3.2.2">3.2.2</a>.  Dynamic Tunnel MTU</span>

   The dynamic MTU determination is OPTIONAL.  However, if it is
   implemented, it SHOULD have the behavior described in this document.

   The fragmentation inside the tunnel can be reduced to a minimum by
   having the encapsulator track the IPv4 path MTU across the tunnel,
   using the IPv4 Path MTU Discovery Protocol [<a href="rfc1191.html" title='"Path MTU discovery"'>RFC1191</a>] and recording



<span class="grey">Nordmark &amp; Gilligan         Standards Track                     [Page 9]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-10" id="page-10" name="page-10"> </a>
<span class="grey"><a href="rfc4213.html">RFC 4213</a>            Basic IPv6 Transition Mechanisms        October 2005</span>


   the resulting path MTU.  The IPv6 layer in the encapsulator can then
   view a tunnel as a link layer with an MTU equal to the IPv4 path MTU,
   minus the size of the encapsulating IPv4 header.

   Note that this does not eliminate IPv4 fragmentation in the case when
   the IPv4 path MTU would result in an IPv6 MTU less than 1280 bytes.
   (Any link layer used by IPv6 has to have an MTU of at least 1280
   bytes [<a href="rfc2460.html" title='"Internet Protocol, Version 6 (IPv6) Specification"'>RFC2460</a>].)  In this case, the IPv6 layer has to "see" a link
   layer with an MTU of 1280 bytes and the encapsulator has to use IPv4
   fragmentation in order to forward the 1280 byte IPv6 packets.

   The encapsulator SHOULD employ the following algorithm to determine
   when to forward an IPv6 packet that is larger than the tunnel's path
   MTU using IPv4 fragmentation, and when to return an ICMPv6 "packet
   too big" message per [<a href="rfc1981.html" title='"Path MTU Discovery for IP version 6"'>RFC1981</a>]:

         if (IPv4 path MTU - 20) is less than 1280
                 if packet is larger than 1280 bytes
                         Send ICMPv6 "packet too big" with MTU = 1280.
                         Drop packet.
                 else
                         Encapsulate but do not set the Don't Fragment
                         flag in the IPv4 header.  The resulting IPv4
                         packet might be fragmented by the IPv4 layer
                         on the encapsulator or by some router along
                         the IPv4 path.
                 endif
         else
                 if packet is larger than (IPv4 path MTU - 20)
                         Send ICMPv6 "packet too big" with
                         MTU = (IPv4 path MTU - 20).
                         Drop packet.
                 else
                         Encapsulate and set the Don't Fragment flag
                         in the IPv4 header.
                 endif
         endif

   Encapsulators that have a large number of tunnels may choose between
   dynamic versus static tunnel MTUs on a per-tunnel endpoint basis.  In
   cases where the number of tunnels that any one node is using is
   large, it is helpful to observe that this state information can be
   cached and discarded when not in use.

   Note that using dynamic tunnel MTU is subject to IPv4 path MTU
   blackholes should the ICMPv4 "packet too big" messages be dropped by
   firewalls or not generated by the routers [RFC1435, <a href="rfc2923.html">RFC2923</a>].




<span class="grey">Nordmark &amp; Gilligan         Standards Track                    [Page 10]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-11" id="page-11" name="page-11"> </a>
<span class="grey"><a href="rfc4213.html">RFC 4213</a>            Basic IPv6 Transition Mechanisms        October 2005</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.3.%20%20Hop%20Limit"></a><a class="selflink" href="#section-3.3" name="section-3.3">3.3</a>.  Hop Limit</span>

   IPv6-over-IPv4 tunnels are modeled as "single-hop" from the IPv6
   perspective.  The tunnel is opaque to users of the network, and it is
   not detectable by network diagnostic tools such as traceroute.

   The single-hop model is implemented by having the encapsulators and
   decapsulators process the IPv6 hop limit field as they would if they
   were forwarding a packet on to any other datalink.  That is, they
   decrement the hop limit by 1 when forwarding an IPv6 packet.  (The
   originating node and final destination do not decrement the hop
   limit.)

   The TTL of the encapsulating IPv4 header is selected in an
   implementation-dependent manner.  The current suggested value is
   published in the "Assigned Numbers" RFC [<a href="rfc3232.html" title='"Assigned Numbers: RFC 1700 is Replaced by an On-line Database"'>RFC3232</a>][ASSIGNED].
   Implementations MAY provide a mechanism to allow the administrator to
   configure the IPv4 TTL as the IP Tunnel MIB [<a href="rfc4087.html" title='"IP Tunnel MIB"'>RFC4087</a>].

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.4.%20%20Handling%20ICMPv4%20Errors"></a><a class="selflink" href="#section-3.4" name="section-3.4">3.4</a>.  Handling ICMPv4 Errors</span>

   In response to encapsulated packets it has sent into the tunnel, the
   encapsulator might receive ICMPv4 error messages from IPv4 routers
   inside the tunnel.  These packets are addressed to the encapsulator
   because it is the IPv4 source of the encapsulated packet.

   ICMPv4 error handling is only applicable to dynamic MTU
   determination, even though the functions could be used with static
   MTU tunnels as well.

   The ICMPv4 "packet too big" error messages are handled according to
   IPv4 Path MTU Discovery [<a href="rfc1191.html" title='"Path MTU discovery"'>RFC1191</a>] and the resulting path MTU is
   recorded in the IPv4 layer.  The recorded path MTU is used by IPv6 to
   determine if an ICMPv6 "packet too big" error has to be generated as
   described in <a href="#section-3.2.2">Section 3.2.2</a>.

   The handling of other types of ICMPv4 error messages depends on how
   much information is available from the encapsulated packet that
   caused the error.

   Many older IPv4 routers return only 8 bytes of data beyond the IPv4
   header of the packet in error, which is not enough to include the
   address fields of the IPv6 header.  More modern IPv4 routers are
   likely to return enough data beyond the IPv4 header to include the
   entire IPv6 header and possibly even the data beyond that.  See
   [<a href="rfc1812.html" title='"Requirements for IP Version 4 Routers"'>RFC1812</a>].





<span class="grey">Nordmark &amp; Gilligan         Standards Track                    [Page 11]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-12" id="page-12" name="page-12"> </a>
<span class="grey"><a href="rfc4213.html">RFC 4213</a>            Basic IPv6 Transition Mechanisms        October 2005</span>


   If sufficient data bytes from the offending packet are available, the
   encapsulator MAY extract the encapsulated IPv6 packet and use it to
   generate an ICMPv6 message directed back to the originating IPv6
   node, as shown below:

                         +--------------+
                         | IPv4 Header  |
                         | dst = encaps |
                         |       node   |
                         +--------------+
                         |    ICMPv4    |
                         |    Header    |
                  - -    +--------------+
                         | IPv4 Header  |
                         | src = encaps |
                 IPv4    |       node   |
                         +--------------+   - -
                 Packet  |    IPv6      |
                         |    Header    |   Original IPv6
                  in     +--------------+   Packet -
                         |  Transport   |   Can be used to
                 Error   |    Header    |   generate an
                         +--------------+   ICMPv6
                         |              |   error message
                         ~     Data     ~   back to the source.
                         |              |
                  - -    +--------------+   - -

             ICMPv4 Error Message Returned to Encapsulating Node

   When receiving ICMPv4 errors as above and the errors are not "packet
   too big", it would be useful to log the error as an error related to
   the tunnel.  Also, if sufficient headers are available, then the
   originating node MAY send an ICMPv6 error of type "unreachable" with
   code "address unreachable" to the IPv6 source.  (The "address
   unreachable" code is appropriate since, from the perspective of IPv6,
   the tunnel is a link and that code is used for link-specific errors
   [<a href="rfc2463.html" title='"Internet Control Message Protocol (ICMPv6) for the Internet Protocol Version 6 (IPv6) Specification"'>RFC2463</a>]).

   Note that when the IPv4 path MTU is exceeded, and sufficient bytes of
   payload associated with the ICMPv4 errors are not available, or
   ICMPv4 errors do not cause the generation of ICMPv6 errors in case
   there is enough payload, there will be at least two packet drops
   instead of at least one (the case of a single layer of MTU
   discovery).  Consider a case where an IPv6 host is connected to an
   IPv4/IPv6 router, which is connected to a network where an ICMPv4
   error about too big packet size is generated.  First, the router
   needs to learn the tunnel (IPv4) MTU that causes at least one packet



<span class="grey">Nordmark &amp; Gilligan         Standards Track                    [Page 12]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-13" id="page-13" name="page-13"> </a>
<span class="grey"><a href="rfc4213.html">RFC 4213</a>            Basic IPv6 Transition Mechanisms        October 2005</span>


   loss, and then the host needs to learn the (IPv6) MTU from the router
   that causes at least one packet loss.  Still, in all cases there can
   be more than one packet loss if there are multiple large packets in
   flight at the same time.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.5.%20%20IPv4%20Header%20Construction"></a><a class="selflink" href="#section-3.5" name="section-3.5">3.5</a>.  IPv4 Header Construction</span>

   When encapsulating an IPv6 packet in an IPv4 datagram, the IPv4
   header fields are set as follows:

      Version:

         4

      IP Header Length in 32-bit words:

         5 (There are no IPv4 options in the encapsulating header.)

      Type of Service:

         0 unless otherwise specified. (See [<a href="rfc2983.html" title='"Differentiated Services and Tunnels"'>RFC2983</a>] and <a href="rfc3168.html#section-9.1">[RFC3168]
         Section 9.1</a> for issues relating to the Type-of-Service byte and
         tunneling.)

      Total Length:

         Payload length from IPv6 header plus length of IPv6 and IPv4
         headers (i.e., IPv6 payload length plus a constant 60 bytes).

      Identification:

         Generated uniquely as for any IPv4 packet transmitted by the
         system.

      Flags:

         Set the Don't Fragment (DF) flag as specified in <a href="#section-3.2">Section 3.2</a>.
         Set the More Fragments (MF) bit as necessary if fragmenting.

      Fragment Offset:

         Set as necessary if fragmenting.

      Time to Live:

         Set in an implementation-specific manner, as described in
         <a href="#section-3.3">Section 3.3</a>.




<span class="grey">Nordmark &amp; Gilligan         Standards Track                    [Page 13]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-14" id="page-14" name="page-14"> </a>
<span class="grey"><a href="rfc4213.html">RFC 4213</a>            Basic IPv6 Transition Mechanisms        October 2005</span>


      Protocol:

         41 (Assigned payload type number for IPv6).

      Header Checksum:

         Calculate the checksum of the IPv4 header [<a href="rfc791.html" title='"Internet Protocol"'>RFC791</a>].

      Source Address:

         An IPv4 address of the encapsulator: either configured by the
         administrator or an address of the outgoing interface.

      Destination Address:

         IPv4 address of the tunnel endpoint.

   When encapsulating the packets, the node must ensure that it will use
   the correct source address so that the packets are acceptable to the
   decapsulator as described in <a href="#section-3.6">Section 3.6</a>.  Configuring the source
   address is appropriate particularly in cases in which automatic
   selection of source address may produce different results in a
   certain period of time.  This is often the case with multiple
   addresses, and multiple interfaces, or when routes may change
   frequently.  Therefore, it SHOULD be possible to administratively
   specify the source address of a tunnel.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.6.%20%20Decapsulation"></a><a class="selflink" href="#section-3.6" name="section-3.6">3.6</a>.  Decapsulation</span>

   When an IPv6/IPv4 host or a router receives an IPv4 datagram that is
   addressed to one of its own IPv4 addresses or a joined multicast
   group address, and the value of the protocol field is 41, the packet
   is potentially a tunnel packet and needs to be verified to belong to
   one of the configured tunnel interfaces (by checking
   source/destination addresses), reassembled (if fragmented at the IPv4
   level), and have the IPv4 header removed and the resulting IPv6
   datagram be submitted to the IPv6 layer code on the node.

   The decapsulator MUST verify that the tunnel source address is
   correct before further processing packets, to mitigate the problems
   with address spoofing (see <a href="#section-4">Section 4</a>).  This check also applies to
   packets that are delivered to transport protocols on the
   decapsulator.  This is done by verifying that the source address is
   the IPv4 address of the encapsulator, as configured on the
   decapsulator.  Packets for which the IPv4 source address does not
   match MUST be discarded and an ICMP message SHOULD NOT be generated;





<span class="grey">Nordmark &amp; Gilligan         Standards Track                    [Page 14]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-15" id="page-15" name="page-15"> </a>
<span class="grey"><a href="rfc4213.html">RFC 4213</a>            Basic IPv6 Transition Mechanisms        October 2005</span>


   however, if the implementation normally sends an ICMP message when
   receiving an unknown protocol packet, such an error message MAY be
   sent (e.g., ICMPv4 Protocol 41 Unreachable).

   A side effect of this address verification is that the node will
   silently discard packets with a wrong source address and packets that
   were received by the node but not directly addressed to it (e.g.,
   broadcast addresses).

   Independent of any other forms of IPv4 ingress filtering the
   administrator of the node may have configured, the implementation MAY
   perform ingress filtering, i.e., check that the packet is arriving
   from the interface in the direction of the route toward the tunnel
   end-point, similar to a Strict Reverse Path Forwarding (RPF) check
   [<a href="rfc3704.html" title='"Ingress Filtering for Multihomed Networks"'>RFC3704</a>].  As this may cause problems on tunnels that are routed
   through multiple links, it is RECOMMENDED that this check, if done,
   is disabled by default.  The packets caught by this check SHOULD be
   discarded; an ICMP message SHOULD NOT be generated by default.

   The decapsulator MUST be capable of having, on the tunnel interfaces,
   an IPv6 MRU of at least the maximum of 1500 bytes and the largest
   (IPv6) interface MTU on the decapsulator.

   The decapsulator MUST be capable of reassembling an IPv4 packet that
   is (after the reassembly) the maximum of 1500 bytes and the largest
   (IPv4) interface MTU on the decapsulator.  The 1500-byte number is a
   result of encapsulators that use the static MTU scheme in <a href="#section-3.2.1">Section</a>
   <a href="#section-3.2.1">3.2.1</a>, while encapsulators that use the dynamic scheme in <a href="#section-3.2.2">Section</a>
   <a href="#section-3.2.2">3.2.2</a> can cause up to the largest interface MTU on the decapsulator
   to be received. (Note that it is strictly the interface MTU on the
   last IPv4 router *before* the decapsulator that matters, but for most
   links the MTU is the same between all neighbors.)

   This reassembly limit allows dynamic tunnel MTU determination by the
   encapsulator to take advantage of larger IPv4 path MTUs.  An
   implementation MAY have a configuration knob that can be used to set
   a larger value of the tunnel reassembly buffers than the above
   number, but it MUST NOT be set below the above number.













<span class="grey">Nordmark &amp; Gilligan         Standards Track                    [Page 15]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-16" id="page-16" name="page-16"> </a>
<span class="grey"><a href="rfc4213.html">RFC 4213</a>            Basic IPv6 Transition Mechanisms        October 2005</span>


   The decapsulation is shown below:

            +-------------+
            |    IPv4     |
            |   Header    |
            +-------------+                 +-------------+
            |    IPv6     |                 |    IPv6     |
            |   Header    |                 |   Header    |
            +-------------+                 +-------------+
            |  Transport  |                 |  Transport  |
            |   Layer     |      ===&gt;       |   Layer     |
            |   Header    |                 |   Header    |
            +-------------+                 +-------------+
            |             |                 |             |
            ~    Data     ~                 ~    Data     ~
            |             |                 |             |
            +-------------+                 +-------------+

                    Decapsulating IPv6 from IPv4

   The decapsulator performs IPv4 reassembly before decapsulating the
   IPv6 packet.

   When decapsulating the packet, the IPv6 header is not modified.
   (However, see [<a href="rfc2983.html" title='"Differentiated Services and Tunnels"'>RFC2983</a>] and <a href="rfc3168.html#section-9.1">[RFC3168] section 9.1</a> for issues relating
   to the Type of Service byte and tunneling.)  If the packet is
   subsequently forwarded, its hop limit is decremented by one.

   The encapsulating IPv4 header is discarded, and the resulting packet
   is checked for validity when submitted to the IPv6 layer.  When
   reconstructing the IPv6 packet, the length MUST be determined from
   the IPv6 payload length since the IPv4 packet might be padded (thus
   have a length that is larger than the IPv6 packet plus the IPv4
   header being removed).

   After the decapsulation, the node MUST silently discard a packet with
   an invalid IPv6 source address.  The list of invalid source addresses
   SHOULD include at least:

   -  all multicast addresses (FF00::/8)

   -  the loopback address (::1)

   -  all the IPv4-compatible IPv6 addresses [<a href="rfc3513.html" title='"Internet Protocol Version 6 (IPv6) Addressing Architecture"'>RFC3513</a>] (::/96),
      excluding the unspecified address for Duplicate Address Detection
      (::/128)

   -  all the IPv4-mapped IPv6 addresses (::ffff:0:0/96)



<span class="grey">Nordmark &amp; Gilligan         Standards Track                    [Page 16]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-17" id="page-17" name="page-17"> </a>
<span class="grey"><a href="rfc4213.html">RFC 4213</a>            Basic IPv6 Transition Mechanisms        October 2005</span>


   In addition, the node should be configured to perform ingress
   filtering [<a href="rfc2827.html" title='"Network Ingress Filtering: Defeating Denial of Service Attacks which employ IP Source Address Spoofing"'>RFC2827</a>][RFC3704] on the IPv6 source address, similar to
   on any of its interfaces, e.g.:

   1) if the tunnel is toward the Internet, the node should be
      configured to check that the site's IPv6 prefixes are not used as
      the source addresses, or

   2) if the tunnel is toward an edge network, the node should be
      configured to check that the source address belongs to that edge
      network.

   The prefix lists in the former typically need to be manually
   configured; the latter could be verified automatically, e.g., by
   using a strict unicast RPF check, as long as an interface can be
   designated to be toward an edge.

   It is RECOMMENDED that the implementations provide a single knob to
   make it easier to for the administrators to enable strict ingress
   filtering toward edge networks.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.7.%20%20Link-Local%20Addresses"></a><a class="selflink" href="#section-3.7" name="section-3.7">3.7</a>.  Link-Local Addresses</span>

   The configured tunnels are IPv6 interfaces (over the IPv4 "link
   layer") and thus MUST have link-local addresses.  The link-local
   addresses are used by, e.g., routing protocols operating over the
   tunnels.

   The interface identifier [<a href="rfc3513.html" title='"Internet Protocol Version 6 (IPv6) Addressing Architecture"'>RFC3513</a>] for such an interface may be based
   on the 32-bit IPv4 address of an underlying interface, or formed
   using some other means, as long as it is unique from the other tunnel
   endpoint with a reasonably high probability.

   Note that it may be desirable to form the link-local address in a
   fashion that minimizes the probability and the effect of having to
   renumber the link-local address in the event of a topology or
   hardware change.

   If an IPv4 address is used for forming the IPv6 link-local address,
   the interface identifier is the IPv4 address, prepended by zeros.
   Note that the "Universal/Local" bit is zero, indicating that the
   interface identifier is not globally unique.  The link-local address
   is formed by appending the interface identifier to the prefix
   FE80::/64.

   When the host has more than one IPv4 address in use on the physical
   interface concerned, a choice of one of these IPv4 addresses is made




<span class="grey">Nordmark &amp; Gilligan         Standards Track                    [Page 17]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-18" id="page-18" name="page-18"> </a>
<span class="grey"><a href="rfc4213.html">RFC 4213</a>            Basic IPv6 Transition Mechanisms        October 2005</span>


   by the administrator or the implementation when forming the link-
   local address.

      +-------+-------+-------+-------+-------+-------+------+------+
      |  FE      80      00      00      00      00      00     00  |
      +-------+-------+-------+-------+-------+-------+------+------+
      |  00      00      00      00   |        IPv4 Address         |
      +-------+-------+-------+-------+-------+-------+------+------+

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.8.%20%20Neighbor%20Discovery%20over%20Tunnels"></a><a class="selflink" href="#section-3.8" name="section-3.8">3.8</a>.  Neighbor Discovery over Tunnels</span>

   Configured tunnel implementations MUST at least accept and respond to
   the probe packets used by Neighbor Unreachability Detection (NUD)
   [<a href="rfc2461.html" title='"Neighbor Discovery for IP Version 6 (IPv6)"'>RFC2461</a>].  The implementations SHOULD also send NUD probe packets to
   detect when the configured tunnel fails at which point the
   implementation can use an alternate path to reach the destination.
   Note that Neighbor Discovery allows that the sending of NUD probes be
   omitted for router-to-router links if the routing protocol tracks
   bidirectional reachability.

   For the purposes of Neighbor Discovery, the configured tunnels
   specified in this document are assumed to NOT have a link-layer
   address, even though the link-layer (IPv4) does have an address.
   This means that:

   -  the sender of Neighbor Discovery packets SHOULD NOT include Source
      Link Layer Address options or Target Link Layer Address options on
      the tunnel link.

   -  the receiver MUST, while otherwise processing the Neighbor
      Discovery packet, silently ignore the content of any Source Link
      Layer Address options or Target Link Layer Address options
      received on the tunnel link.

   Not using link-layer address options is consistent with how Neighbor
   Discovery is used on other point-to-point links.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/4.%20%20Threat%20Related%20to%20Source%20Address%20Spoofing"></a><a class="selflink" href="#section-4" name="section-4">4</a>.  Threat Related to Source Address Spoofing</span>

   The specification above contains rules that apply tunnel source
   address verification in particular and ingress filtering
   [<a href="rfc2827.html" title='"Network Ingress Filtering: Defeating Denial of Service Attacks which employ IP Source Address Spoofing"'>RFC2827</a>][RFC3704] in general to packets before they are
   decapsulated.  When IP-in-IP tunneling (independent of IP versions)
   is used, it is important that this not be used to bypass any ingress
   filtering in use for non-tunneled packets.  Thus, the rules in this
   document are derived based on should ingress filtering be used for
   IPv4 and IPv6, the use of tunneling should not provide an easy way to
   circumvent the filtering.



<span class="grey">Nordmark &amp; Gilligan         Standards Track                    [Page 18]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-19" id="page-19" name="page-19"> </a>
<span class="grey"><a href="rfc4213.html">RFC 4213</a>            Basic IPv6 Transition Mechanisms        October 2005</span>


   In this case, without specific ingress filtering checks in the
   decapsulator, it would be possible for an attacker to inject a packet
   with:

   -  Outer IPv4 source: real IPv4 address of attacker

   -  Outer IPv4 destination: IPv4 address of decapsulator

   -  Inner IPv6 source: Alice, which is either the decapsulator or a
      node close to it

   -  Inner IPv6 destination: Bob

   Even if all IPv4 routers between the attacker and the decapsulator
   implement IPv4 ingress filtering, and all IPv6 routers between the
   decapsulator and Bob implement IPv6 ingress filtering, the above
   spoofed packets will not be filtered out.  As a result, Bob will
   receive a packet that looks like it was sent from Alice even though
   the sender was some unrelated node.

   The solution to this is to have the decapsulator accept only
   encapsulated packets from the explicitly configured source address
   (i.e., the other end of the tunnel) as specified in <a href="#section-3.6">Section 3.6</a>.
   While this does not provide complete protection in the case ingress
   filtering has not been deployed, it does provide a significant
   increase in security.  The issue and the remainder threats are
   discussed at more length in Security Considerations.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/5.%20%20Security%20Considerations"></a><a class="selflink" href="#section-5" name="section-5">5</a>.  Security Considerations</span>

   Generic security considerations of using IPv6 are discussed in a
   separate document [<a href="#ref-V6SEC" title='"IPv6 Transition/Co-existence Security Considerations"'>V6SEC</a>].

   An implementation of tunneling needs to be aware that although a
   tunnel is a link (as defined in [<a href="rfc2460.html" title='"Internet Protocol, Version 6 (IPv6) Specification"'>RFC2460</a>]), the threat model for a
   tunnel might be rather different than for other links, since the
   tunnel potentially includes all of the Internet.

   Several mechanisms (e.g., Neighbor Discovery) depend on Hop Count
   being 255 and/or the addresses being link local for ensuring that a
   packet originated on-link, in a semi-trusted environment.  Tunnels
   are more vulnerable to a breach of this assumption than physical
   links, as an attacker anywhere in the Internet can send an IPv6-in-
   IPv4 packet to the tunnel decapsulator, causing injection of an
   encapsulted IPv6 packet to the configured tunnel interface unless the
   decapsulation checks are able to discard packets injected in such a
   manner.




<span class="grey">Nordmark &amp; Gilligan         Standards Track                    [Page 19]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-20" id="page-20" name="page-20"> </a>
<span class="grey"><a href="rfc4213.html">RFC 4213</a>            Basic IPv6 Transition Mechanisms        October 2005</span>


   Therefore, this memo specifies that the decapsulators make these
   steps (as described in <a href="#section-3.6">Section 3.6</a>) to mitigate this threat:

   -  IPv4 source address of the packet MUST be the same as configured
      for the tunnel end-point;

   -  Independent of any IPv4 ingress filtering the administrator may
      have configured, the implementation MAY perform IPv4 ingress
      filtering to check that the IPv4 packets are received from an
      expected interface (but as this may cause some problems, it may be
      disabled by default);

   -  IPv6 packets with several, obviously invalid IPv6 source addresses
      received from the tunnel MUST be discarded (see <a href="#section-3.6">Section 3.6</a> for
      details); and

   -  IPv6 ingress filtering should be performed (typically requiring
      configuration from the operator), to check that the tunneled IPv6
      packets are received from an expected interface.

   Especially the first verification is vital: to avoid this check, the
   attacker must be able to know the source of the tunnel (ranging from
   difficult to predictable) and be able to spoof it (easier).

   If the remainder threats of tunnel source verification are considered
   to be significant, a tunneling scheme with authentication should be
   used instead, e.g., IPsec [<a href="rfc2401.html" title='"Security Architecture for the Internet Protocol"'>RFC2401</a>] (preferable) or Generic Routing
   Encapsulation with a pre-configured secret key [<a href="rfc2890.html" title='"Key and Sequence Number Extensions to GRE"'>RFC2890</a>].  As the
   configured tunnels are set up more or less manually, setting up the
   keying material is probably not a problem.  However, setting up
   secure IPsec IPv6-in-IPv4 tunnels is described in another document
   [<a href="#ref-V64IPSEC" title='"Using IPsec to Secure IPv6-over- IPv4 Tunnels"'>V64IPSEC</a>].

   If the tunneling is done inside an administrative domain, proper
   ingress filtering at the edge of the domain can also eliminate the
   threat from outside of the domain.  Therefore, shorter tunnels are
   preferable to longer ones, possibly spanning the whole Internet.

   In addition, an implementation MUST treat interfaces to different
   links as separate, e.g., to ensure that Neighbor Discovery packets
   arriving on one link do not affect other links.  This is especially
   important for tunnel links.

   When dropping packets due to failing to match the allowed IPv4 source
   addresses for a tunnel the node should not "acknowledge" the
   existence of a tunnel, otherwise this could be used to probe the
   acceptable tunnel endpoint addresses.  For that reason, the
   specification says that such packets MUST be discarded, and an ICMP



<span class="grey">Nordmark &amp; Gilligan         Standards Track                    [Page 20]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-21" id="page-21" name="page-21"> </a>
<span class="grey"><a href="rfc4213.html">RFC 4213</a>            Basic IPv6 Transition Mechanisms        October 2005</span>


   error message SHOULD NOT be generated, unless the implementation
   normally sends ICMP destination unreachable messages for unknown
   protocols; in such a case, the same code MAY be sent.  As should be
   obvious, not returning the same ICMP code if an error is returned for
   other protocols may hint that the IPv6 stack (or the protocol 41
   tunneling processing) has been enabled -- the behaviour should be
   consistent on how the implementation otherwise behaves to be
   transparent to probing.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/6.%20%20Acknowledgements"></a><a class="selflink" href="#section-6" name="section-6">6</a>.  Acknowledgements</span>

   We would like to thank the members of the IPv6 working group, the
   Next Generation Transition (ngtrans) working group, and the v6ops
   working group for their many contributions and extensive review of
   this document.  Special thanks are due to (in alphabetical order) Jim
   Bound, Ross Callon, Tim Chown,  Alex Conta, Bob Hinden, Bill Manning,
   John Moy, Mohan Parthasarathy, Chirayu Patel, Pekka Savola, and Fred
   Templin for many helpful suggestions.  Pekka Savola helped in editing
   the final revisions of the specification.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/7.%20%20References"></a><a class="selflink" href="#section-7" name="section-7">7</a>.  References</span>

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/7.1.%20%20Normative%20References"></a><a class="selflink" href="#section-7.1" name="section-7.1">7.1</a>.  Normative References</span>

   [<a id="ref-RFC791" name="ref-RFC791">RFC791</a>]   Postel, J., "Internet Protocol", STD 5, <a href="rfc791.html">RFC 791</a>, September
              1981.

   [<a id="ref-RFC1191" name="ref-RFC1191">RFC1191</a>]  Mogul, J. and S. Deering, "Path MTU discovery", <a href="rfc1191.html">RFC 1191</a>,
              November 1990.

   [<a id="ref-RFC1981" name="ref-RFC1981">RFC1981</a>]  McCann, J., Deering, S., and J. Mogul, "Path MTU Discovery
              for IP version 6", <a href="rfc1981.html">RFC 1981</a>, August 1996.

   [<a id="ref-RFC2119" name="ref-RFC2119">RFC2119</a>]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", <a href="https://tools.ietf.org/html/bcp14">BCP 14</a>, <a href="rfc2119.html">RFC 2119</a>, March 1997.

   [<a id="ref-RFC2460" name="ref-RFC2460">RFC2460</a>]  Deering, S. and R. Hinden, "Internet Protocol, Version 6
              (IPv6) Specification", <a href="rfc2460.html">RFC 2460</a>, December 1998.

   [<a id="ref-RFC2463" name="ref-RFC2463">RFC2463</a>]  Conta, A. and S. Deering, "Internet Control Message
              Protocol (ICMPv6) for the Internet Protocol Version 6
              (IPv6) Specification", <a href="rfc2463.html">RFC 2463</a>, December 1998.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/7.2.%20%20Informative%20References"></a><a class="selflink" href="#section-7.2" name="section-7.2">7.2</a>.  Informative References</span>

   [<a id="ref-ASSIGNED" name="ref-ASSIGNED">ASSIGNED</a>] IANA, "Assigned numbers online database",
              <a href="http://www.iana.org/numbers.html">http://www.iana.org/numbers.html</a>




<span class="grey">Nordmark &amp; Gilligan         Standards Track                    [Page 21]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-22" id="page-22" name="page-22"> </a>
<span class="grey"><a href="rfc4213.html">RFC 4213</a>            Basic IPv6 Transition Mechanisms        October 2005</span>


   [<a id="ref-DNSOPV6" name="ref-DNSOPV6">DNSOPV6</a>]  Durand, A., Ihren, J., and Savola P., "Operational
              Considerations and Issues with IPv6 DNS", Work in
              Progress, October 2004.

   [<a id="ref-KM97" name="ref-KM97">KM97</a>]     Kent, C., and J. Mogul, "Fragmentation Considered
              Harmful".  In Proc.  SIGCOMM '87 Workshop on Frontiers in
              Computer Communications Technology.  August 1987.

   [<a id="ref-V6SEC" name="ref-V6SEC">V6SEC</a>]    Savola, P., "IPv6 Transition/Co-existence Security
              Considerations", Work in Progress, October 2004.

   [<a id="ref-V64IPSEC" name="ref-V64IPSEC">V64IPSEC</a>] Graveman, R., et al., "Using IPsec to Secure IPv6-over-
              IPv4 Tunnels", Work in Progress, December 2004.

   [<a id="ref-RFC1435" name="ref-RFC1435">RFC1435</a>]  Knowles, S., "IESG Advice from Experience with Path MTU
              Discovery", <a href="rfc1435.html">RFC 1435</a>, March 1993.

   [<a id="ref-RFC1812" name="ref-RFC1812">RFC1812</a>]  Baker, F., "Requirements for IP Version 4 Routers", <a href="rfc1812.html">RFC</a>
              <a href="rfc1812.html">1812</a>, June 1995.

   [<a id="ref-RFC2401" name="ref-RFC2401">RFC2401</a>]  Kent, S. and R. Atkinson, "Security Architecture for the
              Internet Protocol", <a href="rfc2401.html">RFC 2401</a>, November 1998.

   [<a id="ref-RFC2461" name="ref-RFC2461">RFC2461</a>]  Narten, T., Nordmark, E., and W. Simpson, "Neighbor
              Discovery for IP Version 6 (IPv6)", <a href="rfc2461.html">RFC 2461</a>, December
              1998.

   [<a id="ref-RFC2462" name="ref-RFC2462">RFC2462</a>]  Thomson, S. and T. Narten, "IPv6 Stateless Address
              Autoconfiguration", <a href="rfc2462.html">RFC 2462</a>, December 1998.

   [<a id="ref-RFC2827" name="ref-RFC2827">RFC2827</a>]  Ferguson, P. and D. Senie, "Network Ingress Filtering:
              Defeating Denial of Service Attacks which employ IP Source
              Address Spoofing", <a href="https://tools.ietf.org/html/bcp38">BCP 38</a>, <a href="rfc2827.html">RFC 2827</a>, May 2000.

   [<a id="ref-RFC2890" name="ref-RFC2890">RFC2890</a>]  Dommety, G., "Key and Sequence Number Extensions to GRE",
              <a href="rfc2890.html">RFC 2890</a>, September 2000.

   [<a id="ref-RFC2923" name="ref-RFC2923">RFC2923</a>]  Lahey, K., "TCP Problems with Path MTU Discovery", <a href="rfc2923.html">RFC</a>
              <a href="rfc2923.html">2923</a>, September 2000.

   [<a id="ref-RFC2983" name="ref-RFC2983">RFC2983</a>]  Black, D., "Differentiated Services and Tunnels", <a href="rfc2983.html">RFC</a>
              <a href="rfc2983.html">2983</a>, October 2000.

   [<a id="ref-RFC3056" name="ref-RFC3056">RFC3056</a>]  Carpenter, B. and K. Moore, "Connection of IPv6 Domains
              via IPv4 Clouds", <a href="rfc3056.html">RFC 3056</a>, February 2001.






<span class="grey">Nordmark &amp; Gilligan         Standards Track                    [Page 22]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-23" id="page-23" name="page-23"> </a>
<span class="grey"><a href="rfc4213.html">RFC 4213</a>            Basic IPv6 Transition Mechanisms        October 2005</span>


   [<a id="ref-RFC3168" name="ref-RFC3168">RFC3168</a>]  Ramakrishnan, K., Floyd, S., and D. Black, "The Addition
              of Explicit Congestion Notification (ECN) to IP", <a href="rfc3168.html">RFC</a>
              <a href="rfc3168.html">3168</a>, September 2001.

   [<a id="ref-RFC3232" name="ref-RFC3232">RFC3232</a>]  Reynolds, J., "Assigned Numbers: <a href="rfc1700.html">RFC 1700</a> is Replaced by
              an On-line Database", <a href="rfc3232.html">RFC 3232</a>, January 2002.

   [<a id="ref-RFC3484" name="ref-RFC3484">RFC3484</a>]  Draves, R., "Default Address Selection for Internet
              Protocol version 6 (IPv6)", <a href="rfc3484.html">RFC 3484</a>, February 2003.

   [<a id="ref-RFC3493" name="ref-RFC3493">RFC3493</a>]  Gilligan, R., Thomson, S., Bound, J., McCann, J., and W.
              Stevens, "Basic Socket Interface Extensions for IPv6", <a href="rfc3493.html">RFC</a>
              <a href="rfc3493.html">3493</a>, February 2003.

   [<a id="ref-RFC3513" name="ref-RFC3513">RFC3513</a>]  Hinden, R. and S. Deering, "Internet Protocol Version 6
              (IPv6) Addressing Architecture", <a href="rfc3513.html">RFC 3513</a>, April 2003.

   [<a id="ref-RFC3596" name="ref-RFC3596">RFC3596</a>]  Thomson, S., Huitema, C., Ksinant, V., and M. Souissi,
              "DNS Extensions to Support IP Version 6", <a href="rfc3596.html">RFC 3596</a>,
              October 2003.

   [<a id="ref-RFC3704" name="ref-RFC3704">RFC3704</a>]  Baker, F. and P. Savola, "Ingress Filtering for Multihomed
              Networks", <a href="https://tools.ietf.org/html/bcp84">BCP 84</a>, <a href="rfc3704.html">RFC 3704</a>, March 2004.

   [<a id="ref-RFC4087" name="ref-RFC4087">RFC4087</a>]  Thaler, D., "IP Tunnel MIB", <a href="rfc4087.html">RFC 4087</a>, June 2005.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/8.%20%20Changes%20from%20RFC%202893"></a><a class="selflink" href="#section-8" name="section-8">8</a>.  Changes from <a href="rfc2893.html">RFC 2893</a></span>

   The motivation for the bulk of these changes are to simplify the
   document to only contain the mechanisms of wide-spread use.

   <a href="rfc2893.html">RFC 2893</a> contains a mechanism called automatic tunneling.  But a much
   more general mechanism is specified in <a href="rfc3056.html">RFC 3056</a> [<a href="rfc3056.html" title='"Connection of IPv6 Domains via IPv4 Clouds"'>RFC3056</a>] which gives
   each node with a (global) IPv4 address a /48 IPv6 prefix i.e., enough
   for a whole site.

   The following changes have been performed since <a href="rfc2893.html">RFC 2893</a>:

   -  Removed references to A6 and retained AAAA.

   -  Removed automatic tunneling and use of IPv4-compatible addresses.

   -  Removed default Configured Tunnel using IPv4 "Anycast Address"

   -  Removed Source Address Selection section since this is now covered
      by another document ([<a href="rfc3484.html" title='"Default Address Selection for Internet Protocol version 6 (IPv6)"'>RFC3484</a>]).

   -  Removed brief mention of 6over4.



<span class="grey">Nordmark &amp; Gilligan         Standards Track                    [Page 23]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-24" id="page-24" name="page-24"> </a>
<span class="grey"><a href="rfc4213.html">RFC 4213</a>            Basic IPv6 Transition Mechanisms        October 2005</span>


   -  Split into normative and non-normative references and other
      reference cleanup.

   -  Dropped "or equal" in if (IPv4 path MTU - 20) is less than or
      equal to 1280.

   -  Dropped this: However, IPv6 may be used in some environments where
      interoperability with IPv4 is not required.  IPv6 nodes that are
      designed to be used in such environments need not use or even
      implement these mechanisms.

   -  Described Static MTU and Dynamic MTU cases separately; clarified
      that the dynamic path MTU mechanism is OPTIONAL but if it is
      implemented it should follow the rules in <a href="#section-3.2.2">section 3.2.2</a>.

   -  Specified Static MTU to default to a MTU of 1280 to 1480 bytes,
      and that this may be configurable.  Discussed the issues with
      using Static MTU at more length.

   -  Specified minimal rules for IPv4 reassembly and IPv6 MRU to
      enhance interoperability and to minimize blacholes.

   -  Restated the "currently underway" language about Type-of-Service,
      and loosely point at [<a href="rfc2983.html" title='"Differentiated Services and Tunnels"'>RFC2983</a>] and [<a href="rfc3168.html" title='"The Addition of Explicit Congestion Notification (ECN) to IP"'>RFC3168</a>].

   -  Fixed reference to Assigned Numbers to be to online version (with
      proper pointer to "Assigned Numbers is obsolete" RFC).

   -  Clarified text about ingress filtering e.g., that it applies to
      packet delivered to transport protocols on the decapsulator as
      well as packets being forwarded by the decapsulator, and how the
      decapsulator's checks help when IPv4 and IPv6 ingress filtering is
      in place.

   -  Removed unidirectional tunneling; assume all tunnels are
      bidirectional, between endpoint addresses (not nodes).

   -  Removed the guidelines for advertising addresses in DNS as
      slightly out of scope, referring to another document for the
      details.

   -  Removed the SHOULD requirement that the link-local addresses
      should be formed based on IPv4 addresses.








<span class="grey">Nordmark &amp; Gilligan         Standards Track                    [Page 24]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-25" id="page-25" name="page-25"> </a>
<span class="grey"><a href="rfc4213.html">RFC 4213</a>            Basic IPv6 Transition Mechanisms        October 2005</span>


   -  Added a SHOULD for implementing a knob to be able to set the
      source address of the tunnel, and add discussion why this is
      useful.

   -  Added stronger wording for source address checks: both IPv4 and
      IPv6 source addresses MUST be checked, and RPF-like ingress
      filtering is optional.

   -  Rewrote security considerations to be more precise about the
      threats of tunneling.

   -  Added a note about considering using TTL=255 when encapsulating.

   -  Added more discussion in <a href="#section-3.2">Section 3.2</a> why using an "infinite" IPv6
      MTU leads to likely interoperability problems.

   -  Added an explicit requirement that if both MTU determination
      methods are used, choosing one should be possible on a per-tunnel
      basis.

   -  Clarified that ICMPv4 error handling is only applicable to dynamic
      MTU determination.

   -  Removed/clarified DNS record filtering; an API is a SHOULD and if
      it does not exist, MUST NOT filter anything.  Decree ordering out
      of scope, but refer to <a href="rfc3484.html">RFC3484</a>.

   -  Add a note that the destination IPv4 address could also be a
      multicast address.

   -  Make it RECOMMENDED to provide a toggle to perform strict ingress
      filtering on an interface.

   -  Generalize the text on the data in ICMPv4 messages.

   -  Made a lot of miscellaneous editorial cleanups.















<span class="grey">Nordmark &amp; Gilligan         Standards Track                    [Page 25]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-26" id="page-26" name="page-26"> </a>
<span class="grey"><a href="rfc4213.html">RFC 4213</a>            Basic IPv6 Transition Mechanisms        October 2005</span>


Authors' Addresses

   Erik Nordmark
   Sun Microsystems
   17 Network Circle
   Menlo Park, CA 94025
   USA

   Phone: +1 650 786 2921
   EMail: erik.nordmark@sun.com


   Robert E. Gilligan
   Intransa, Inc.
   2870 Zanker Rd., Suite 100
   San Jose, CA 95134 USA

   Phone : +1 408 678 8600
   Fax :   +1 408 678 8800
   EMail:  bob.gilligan@acm.org































<span class="grey">Nordmark &amp; Gilligan         Standards Track                    [Page 26]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-27" id="page-27" name="page-27"> </a>
<span class="grey"><a href="rfc4213.html">RFC 4213</a>            Basic IPv6 Transition Mechanisms        October 2005</span>


Full Copyright Statement

   Copyright (C) The Internet Society (2005).

   This document is subject to the rights, licenses and restrictions
   contained in <a href="https://tools.ietf.org/html/bcp78">BCP 78</a>, and except as set forth therein, the authors
   retain all their rights.

   This document and the information contained herein are provided on an
   "AS IS" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS
   OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET
   ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED,
   INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE
   INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED
   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.

Intellectual Property

   The IETF takes no position regarding the validity or scope of any
   Intellectual Property Rights or other rights that might be claimed to
   pertain to the implementation or use of the technology described in
   this document or the extent to which any license under such rights
   might or might not be available; nor does it represent that it has
   made any independent effort to identify any such rights.  Information
   on the procedures with respect to rights in RFC documents can be
   found in <a href="https://tools.ietf.org/html/bcp78">BCP 78</a> and <a href="https://tools.ietf.org/html/bcp79">BCP 79</a>.

   Copies of IPR disclosures made to the IETF Secretariat and any
   assurances of licenses to be made available, or the result of an
   attempt made to obtain a general license or permission for the use of
   such proprietary rights by implementers or users of this
   specification can be obtained from the IETF on-line IPR repository at
   <a href="http://www.ietf.org/ipr">http://www.ietf.org/ipr</a>.

   The IETF invites any interested party to bring to its attention any
   copyrights, patents or patent applications, or other proprietary
   rights that may cover technology that may be required to implement
   this standard.  Please address the information to the IETF at ietf-
   ipr@ietf.org.

Acknowledgement

   Funding for the RFC Editor function is currently provided by the
   Internet Society.







Nordmark &amp; Gilligan         Standards Track                    [Page 27]

</pre><br/>
    <span class="noprint"><small><small>Html markup produced by rfcmarkup 1.126, available from
      <a href="https://tools.ietf.org/tools/rfcmarkup/">https://tools.ietf.org/tools/rfcmarkup/</a>
    </small></small></span>
  </div>




</body><!-- Mirrored from tools.ietf.org/html/rfc4213 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 06 Mar 2018 23:18:42 GMT --></html>