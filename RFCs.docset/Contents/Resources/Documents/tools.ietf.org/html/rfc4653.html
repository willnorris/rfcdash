<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml"><!-- Mirrored from tools.ietf.org/html/rfc4653 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 06 Mar 2018 23:18:40 GMT --><!-- Added by HTTrack --><head><meta content="text/html;charset=utf-8" http-equiv="content-type"/><!-- /Added by HTTrack -->

    <meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
    <meta content="index,follow" name="robots"/>
    <meta content="rfcmarkup version 1.126" name="creator"/>
    <link href="http://purl.org/dc/elements/1.1/" rel="schema.DC"/>
<meta content="urn:ietf:rfc:4653" name="DC.Identifier"/>
<meta content="This document specifies Non-Congestion Robustness (NCR) for TCP. In
the absence of explicit congestion notification from the network, TCP
uses loss as an indication of congestion. One of the ways TCP detects
loss is using the arrival of three duplicate acknowledgments. However,
this heuristic is not always correct, notably in the case when network
paths reorder segments (for whatever reason), resulting in degraded
performance. TCP-NCR is designed to mitigate this degraded performance
by increasing the number of duplicate acknowledgments required to
trigger loss recovery, based on the current state of the connection,
in an effort to better disambiguate true segment loss from segment
reordering. This document specifies the changes to TCP, as well as the
costs and benefits of these modifications. This memo defines an
Experimental Protocol for the Internet community." name="DC.Description.Abstract"/>
<meta content="Blanton, Ethan" name="DC.Creator"/>
<meta content="Reddy, A. L. Narasimha" name="DC.Creator"/>
<meta content="Bhandarkar, Sumitha" name="DC.Creator"/>
<meta content="Allman, Mark" name="DC.Creator"/>
<meta content="August, 2006" name="DC.Date.Issued"/>
<meta content="Improving the Robustness of TCP to Non-Congestion Events" name="DC.Title"/>

    <link href="https://tools.ietf.org/images/rfc.png" rel="icon" type="image/png"/>
    <link href="https://tools.ietf.org/images/rfc.png" rel="shortcut icon" type="image/png"/>
    <title>RFC 4653 - Improving the Robustness of TCP to Non-Congestion Events</title>
    
    
    <style type="text/css">
	@media only screen 
	  and (min-width: 992px)
	  and (max-width: 1199px) {
	    body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 768px)
	  and (max-width: 991px) {
            body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 480px)
	  and (max-width: 767px) {
            body { font-size: 11pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (max-width: 479px) {
            body { font-size: 8pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-device-width : 375px) 
	  and (max-device-width : 667px) {
            body { font-size: 9.5pt; }
            div.content { width: 96ex; margin: 0 1px; }
        }
	@media only screen 
	  and (min-device-width: 1200px) {
            body { font-size: 10pt; margin: 0 4em; }
            div.content { width: 96ex; margin: 0; }
        }
        h1, h2, h3, h4, h5, h6, .h1, .h2, .h3, .h4, .h5, .h6 {
	    font-weight: bold;
            line-height: 0pt;
            display: inline;
            white-space: pre;
            font-family: monospace;
            font-size: 1em;
	    font-weight: bold;
        }
        pre {
            font-size: 1em;
            margin-top: 0px;
            margin-bottom: 0px;
        }
	.pre {
	    white-space: pre;
	    font-family: monospace;
	}
	.header{
	    font-weight: bold;
	}
        .newpage {
            page-break-before: always;
        }
        .invisible {
            text-decoration: none;
            color: white;
        }
        a.selflink {
          color: black;
          text-decoration: none;
        }
        @media print {
            body {
                font-family: monospace;
                font-size: 10.5pt;
            }
            h1, h2, h3, h4, h5, h6 {
                font-size: 1em;
            }
        
            a:link, a:visited {
                color: inherit;
                text-decoration: none;
            }
            .noprint {
                display: none;
            }
        }
	@media screen {
	    .grey, .grey a:link, .grey a:visited {
		color: #777;
	    }
            .docinfo {
                background-color: #EEE;
            }
            .top {
                border-top: 7px solid #EEE;
            }
            .bgwhite  { background-color: white; }
            .bgred    { background-color: #F44; }
            .bggrey   { background-color: #666; }
            .bgbrown  { background-color: #840; }            
            .bgorange { background-color: #FA0; }
            .bgyellow { background-color: #EE0; }
            .bgmagenta{ background-color: #F4F; }
            .bgblue   { background-color: #66F; }
            .bgcyan   { background-color: #4DD; }
            .bggreen  { background-color: #4F4; }

            .legend   { font-size: 90%; }
            .cplate   { font-size: 70%; border: solid grey 1px; }
	}
    </style>
    <!--[if IE]>
    <style>
    body {
       font-size: 13px;
       margin: 10px 10px;
    }
    </style>
    <![endif]-->

    <script type="text/javascript"><!--
    function addHeaderTags() {
	var spans = document.getElementsByTagName("span");
	for (var i=0; i < spans.length; i++) {
	    var elem = spans[i];
	    if (elem) {
		var level = elem.getAttribute("class");
                if (level == "h1" || level == "h2" || level == "h3" || level == "h4" || level == "h5" || level == "h6") {
                    elem.innerHTML = "<"+level+">"+elem.innerHTML+"</"+level+">";		
                }
	    }
	}
    }
    var legend_html = "Colour legend:<br />      <table>         <tr><td>Unknown:</td>                   <td><span class='cplate bgwhite'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft:</td>                     <td><span class='cplate bgred'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Informational:</td>             <td><span class='cplate bgorange'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Experimental:</td>              <td><span class='cplate bgyellow'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Best Common Practice:</td>      <td><span class='cplate bgmagenta'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Proposed Standard:</td>         <td><span class='cplate bgblue'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft Standard (old designation):</td> <td><span class='cplate bgcyan'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Internet Standard:</td>         <td><span class='cplate bggreen'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Historic:</td>                  <td><span class='cplate bggrey'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Obsolete:</td>                  <td><span class='cplate bgbrown'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>     </table>";
    function showElem(id) {
        var elem = document.getElementById(id);
        elem.innerHTML = eval(id+"_html");
        elem.style.visibility='visible';
    }
    function hideElem(id) {
        var elem = document.getElementById(id);
        elem.style.visibility='hidden';        
        elem.innerHTML = "";
    }
    // -->
    </script>
</head>
<body onload="addHeaderTags()">
  <div class="content">
   <div style="height: 13px;">
      <div class="pre noprint docinfo bgyellow" onclick="showElem('legend');" onmouseout="hideElem('legend')" onmouseover="this.style.cursor='pointer';" style="height: 6px; position: absolute;" title="Click for colour legend.">                                                                        </div>
      <div class="docinfo noprint pre legend" id="legend" onmouseout="hideElem('legend');" onmouseover="showElem('legend');" style="position:absolute; top: 4px; left: 4ex; visibility:hidden; background-color: white; padding: 4px 9px 5px 7px; border: solid #345 1px; ">
      </div>
   </div>
<span class="pre noprint docinfo top">[<a href="index.html" title="Document search and retrieval page">Docs</a>] [<a href="https://tools.ietf.org/rfc/rfc4653.txt" title="Plaintext version of this document">txt</a>|<a href="https://tools.ietf.org/pdf/rfc4653" title="PDF version of this document">pdf</a>] [<a href="https://tools.ietf.org/html/draft-ietf-tcpm-tcp-dcr" title="draft-ietf-tcpm-tcp-dcr">draft-ietf-tcpm...</a>] [<a href="https://datatracker.ietf.org/doc/rfc4653" title="IESG Datatracker information for this document">Tracker</a>] [<a href="https://tools.ietf.org/rfcdiff?difftype=--hwdiff&amp;url2=rfc4653" title="Inline diff (wdiff)">Diff1</a>] [<a href="https://tools.ietf.org/rfcdiff?url2=rfc4653" title="Side-by-side diff">Diff2</a>] [<a href="https://www.rfc-editor.org/errata_search.php?rfc=4653">Errata</a>]</span><br/>
<span class="pre noprint docinfo">                                                                        </span><br/>
<span class="pre noprint docinfo">                                                            EXPERIMENTAL</span><br/>
<span class="pre noprint docinfo">                                                            <span style="color: #C00;">Errata Exist</span></span><br/>
<pre>Network Working Group                                      S. Bhandarkar
Request for Comments: 4653                                A. L. N. Reddy
Category: Experimental                              Texas A&amp;M University
                                                               M. Allman
                                                               ICIR/ICSI
                                                              E. Blanton
                                                       Purdue University
                                                             August 2006


        <span class="h1">Improving the Robustness of TCP to Non-Congestion Events</span>


Status of This Memo

   This memo defines an Experimental Protocol for the Internet
   community.  It does not specify an Internet standard of any kind.
   Discussion and suggestions for improvement are requested.
   Distribution of this memo is unlimited.

Copyright Notice

   Copyright (C) The Internet Society (2006).

Abstract

   This document specifies Non-Congestion Robustness (NCR) for TCP.  In
   the absence of explicit congestion notification from the network, TCP
   uses loss as an indication of congestion.  One of the ways TCP
   detects loss is using the arrival of three duplicate acknowledgments.
   However, this heuristic is not always correct, notably in the case
   when network paths reorder segments (for whatever reason), resulting
   in degraded performance.  TCP-NCR is designed to mitigate this
   degraded performance by increasing the number of duplicate
   acknowledgments required to trigger loss recovery, based on the
   current state of the connection, in an effort to better disambiguate
   true segment loss from segment reordering.  This document specifies
   the changes to TCP, as well as the costs and benefits of these
   modifications.












<span class="grey">Bhandarkar, et al.            Experimental                      [Page 1]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-2" id="page-2" name="page-2"> </a>
<span class="grey"><a href="rfc4653.html">RFC 4653</a>            Improving the Robustness of TCP          August 2006</span>


Table of Contents

   <a href="#section-1">1</a>. Introduction ....................................................<a href="#page-2">2</a>
      <a href="#section-1.1">1.1</a>. Terminology ................................................<a href="#page-4">4</a>
   <a href="#section-2">2</a>. NCR Description .................................................<a href="#page-5">5</a>
   <a href="#section-3">3</a>. Algorithm .......................................................<a href="#page-6">6</a>
      <a href="#section-3.1">3.1</a>. Initialization .............................................<a href="#page-8">8</a>
      3.2. Terminating Extended Limited Transmit and
           Preventing Bursts ..........................................<a href="#page-9">9</a>
      <a href="#section-3.3">3.3</a>. Extended Limited Transmit .................................<a href="#page-10">10</a>
      <a href="#section-3.4">3.4</a>. Entering Loss Recovery ....................................<a href="#page-11">11</a>
   <a href="#section-4">4</a>. Advantages .....................................................<a href="#page-12">12</a>
   <a href="#section-5">5</a>. Disadvantages ..................................................<a href="#page-12">12</a>
   <a href="#section-6">6</a>. Related Work ...................................................<a href="#page-13">13</a>
   <a href="#section-7">7</a>. Security Considerations ........................................<a href="#page-14">14</a>
   <a href="#section-8">8</a>. Acknowledgments ................................................<a href="#page-14">14</a>
   <a href="#section-9">9</a>. IANA Considerations ............................................<a href="#page-14">14</a>
   <a href="#section-10">10</a>. References ....................................................<a href="#page-14">14</a>
      <a href="#section-10.1">10.1</a>. Normative References .....................................<a href="#page-14">14</a>
      <a href="#section-10.2">10.2</a>. Informative References ...................................<a href="#page-15">15</a>

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/1.%20%20Introduction"></a><a class="selflink" href="#section-1" name="section-1">1</a>.  Introduction</span>

   One strength of TCP [<a href="rfc793.html" title='"Transmission Control Protocol"'>RFC793</a>] lies in its ability to adjust its
   sending rate according to the perceived congestion in the network
   [Jac88, <a href="rfc2581.html">RFC2581</a>].  In the absence of explicit notification of
   congestion from the network, TCP uses segment loss as an indication
   of congestion (i.e., assuming queue overflow).  TCP receivers send
   cumulative acknowledgments (ACKs) indicating the next sequence number
   expected from the sender for arriving segments [<a href="rfc793.html" title='"Transmission Control Protocol"'>RFC793</a>].  When
   segments arrive out of order, duplicate ACKs are generated.  As
   specified in [<a href="rfc2581.html" title='"TCP Congestion Control"'>RFC2581</a>], a TCP sender uses the arrival of three
   duplicate ACKs as an indication of segment loss.  The TCP sender
   retransmits the lost segment and reduces the load imposed on the
   network, assuming the segment loss was caused by resource contention
   within the network path.  The TCP sender does not assume loss on the
   first or second duplicate ACK, but waits for three duplicate ACKs to
   account for minor packet reordering.  However, the use of this
   constant threshold of duplicate ACKs has several problems that can be
   mitigated with a dynamic threshold.

   The following is an example of TCP's behavior:

     + TCP A is the data sender, and TCP B is the data receiver.

     + TCP A sends 10 segments, each consisting of a single data byte
       (i.e., transmits bytes 1-10 in segments 1-10).




<span class="grey">Bhandarkar, et al.            Experimental                      [Page 2]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-3" id="page-3" name="page-3"> </a>
<span class="grey"><a href="rfc4653.html">RFC 4653</a>            Improving the Robustness of TCP          August 2006</span>


     + Assume segment 3 is dropped in the network.

     + TCP B cumulatively acknowledges segments 1 and 2, making the
       cumulative ACK transmitted to the sender 3 (the next expected
       sequence number).  (Note: TCP B may generate one or two ACKs,
       depending on whether delayed ACKs [RFC1122, <a href="rfc2581.html">RFC2581</a>] are
       employed.)

     + The arrival of segments 4-10 at TCP B will each trigger the
       transmission of a cumulative ACK for sequence number 3.  (Note:
       [<a href="rfc2581.html" title='"TCP Congestion Control"'>RFC2581</a>] recommends that delayed ACKs not be used when the ACK
       is triggered by an out-of-order segment.)

     + When TCP A receives the third duplicate ACK (or fourth ACK
       overall) for sequence number 3, TCP A will retransmit
       segment 3 and reduce the sending rate by roughly half (see
       [<a href="rfc2581.html" title='"TCP Congestion Control"'>RFC2581</a>] for specifics on the congestion control state
       adjustments).

   Alternatively, suppose segment 3 was not dropped by the network, but
   rather delayed such that segment 3 arrives at TCP B after segment 10.
   The above scenario will play out in precisely the same manner
   insomuch as a retransmission of segment 3 will be triggered.  In
   other words, TCP is not capable of disambiguating this reordering
   event from a segment loss, resulting in an unnecessary retransmission
   and rate reduction.

   The following is the specific motivation behind making TCP robust to
   reordered segments:

     * A number of Internet measurement studies have shown that packet
       reordering is not a rare phenomenon [Pax97, BPS99, JIDKT03,
       GPL04].  Further, the reordering can be well beyond that required
       for fast retransmit to be falsely triggered.

     * [<a href="#ref-BA02" title='"On Making TCP More Robust to Packet Reordering,"'>BA02</a>, <a href="#ref-ZKFP03" title='"RR-TCP: A Reordering-Robust TCP with DSACK"'>ZKFP03</a>] show the negative performance implications that
       packet reordering has on current TCP.

     * The requirement imposed by TCP for almost in-order packet
       delivery places a constraint on the design of future technology.
       Novel routing algorithms, network components, link-layer
       retransmission mechanisms, and applications could all be looked
       at with a fresh perspective if TCP were to be more robust to
       segment reordering.  For instance, high-speed packet switches
       could cause resequencing of packets if TCP were more robust.
       There has been work proposed in the literature explicitly to
       ensure that packet ordering is maintained in such switches (e.g.,
       [<a href="#ref-KM02" title='"Maintaining packet order in twostage switches,"'>KM02</a>]).  Also, link-layer mechanisms that attempt to recover



<span class="grey">Bhandarkar, et al.            Experimental                      [Page 3]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-4" id="page-4" name="page-4"> </a>
<span class="grey"><a href="rfc4653.html">RFC 4653</a>            Improving the Robustness of TCP          August 2006</span>


       from packet corruption by retransmitting could be allowed to
       reorder packets, and thus increase the chances of local loss
       repair rather than rely on TCP to repair the loss (and,
       needlessly reduce its sending rate).  Additional examples include
       multi-path routing, high-delay satellite links, and some of the
       schemes proposed for a differentiated services architecture.  By
       making TCP more robust to non-congestion events, TCP-NCR may open
       the design space of the future Internet components.

   In this document, we specify a set of TCP sender modifications to
   provide Non-Congestion Robustness (NCR) to TCP.  In particular, these
   changes are built on top of TCP with selective acknowledgments
   (SACKs) [<a href="rfc2018.html" title='"TCP Selective Acknowledgement Options"'>RFC2018</a>] and the SACK-based loss recovery scheme given in
   [<a href="rfc3517.html" title='"A Conservative Selective Acknowledgment (SACK)-based Loss Recovery Algorithm for TCP"'>RFC3517</a>], since SACK is widely deployed at this point ([<a href="#ref-MAF05" title="M. Allman">MAF05</a>]
   indicates that 68% of web servers and 88% of web clients utilize SACK
   as of spring 2004).

   Note that the TCP-NCR algorithm provided in this document could be
   easily adapted to SCTP [<a href="rfc2960.html" title="C. Sharp">RFC2960</a>] since SCTP uses congestion control
   algorithms similar to TCP's (and thus has the same reordering
   robustness issues).

   As noted in several places in the remainder of this document, we
   consider TCP-NCR experimental in that more experience with the
   techniques is required before TCP-NCR should be used on a large scale
   on the Internet.  We encourage implementation and experimentation
   with TCP-NCR in the hopes of gaining an understanding of its
   suitability for wide-scale deployment.

   The remainder of this document is organized as follows.  <a href="#section-2">Section 2</a>
   provides a high-level description of the TCP-NCR mechanisms.  In
   <a href="#section-3">Section 3</a>, we specify the TCP-NCR algorithm.  <a href="#section-4">Section 4</a> provides a
   brief overview of the benefits of TCP-NCR, while <a href="#section-5">Section 5</a> discusses
   the drawbacks.  <a href="#section-6">Section 6</a> discusses related work.  <a href="#section-7">Section 7</a>
   discusses security concerns.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/1.1.%20%20Terminology"></a><a class="selflink" href="#section-1.1" name="section-1.1">1.1</a>.  Terminology</span>

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in [<a href="rfc2119.html" title='"Key words for use in RFCs to Indicate Requirement Levels"'>RFC2119</a>].

   Readers should be familiar with the TCP terminology (e.g.,
   FlightSize, Pipe) given in [<a href="rfc2581.html" title='"TCP Congestion Control"'>RFC2581</a>] and [<a href="rfc3517.html" title='"A Conservative Selective Acknowledgment (SACK)-based Loss Recovery Algorithm for TCP"'>RFC3517</a>].







<span class="grey">Bhandarkar, et al.            Experimental                      [Page 4]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-5" id="page-5" name="page-5"> </a>
<span class="grey"><a href="rfc4653.html">RFC 4653</a>            Improving the Robustness of TCP          August 2006</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/2.%20%20NCR%20Description"></a><a class="selflink" href="#section-2" name="section-2">2</a>.  NCR Description</span>

   As discussed above, in the face of packet reordering, three duplicate
   ACKs may not be enough to disambiguate loss from reordering.  In this
   section we provide a non-normative sketch of TCP-NCR.  The detailed
   algorithms for implementing Non-Congestion Robustness for TCP are
   presented in the next section.

   The general idea behind TCP-NCR is to increase the threshold used to
   trigger a fast retransmission from the current fixed value of three
   duplicate ACKs [<a href="rfc2581.html" title='"TCP Congestion Control"'>RFC2581</a>] to approximately a congestion window of data
   having left the network (but not less than the currently standardized
   value of three duplicate ACKs).  Since cwnd represents the amount of
   data a TCP flow can transmit in one round-trip time (RTT), waiting to
   receive notice that cwnd bytes have left the network before deciding
   whether the root cause is loss or reordering imposes a delay of
   roughly one RTT on both the retransmission and the congestion control
   response.  The appropriate choice for a new value of the threshold is
   essentially a trade-off between making the best decision regarding
   the cause of the duplicate ACKs and responsiveness.  The choice to
   trigger a retransmission only after a cwnd's worth of data is known
   to have left the network represents roughly the largest amount of
   time a TCP can wait before the (often costly) retransmission timeout
   may be triggered.  Therefore, the algorithm described in this
   document attempts to make the best decision possible at the expense
   of timeliness.

   Simply increasing the threshold before retransmitting a segment can
   make TCP brittle to packet loss or ACK loss since such loss reduces
   the number of duplicate ACKs that will arrive at the sender from the
   receiver.  For instance, if the cwnd is 10 segments and one segment
   is lost, a duplicate ACK threshold of 10 will never be met because
   duplicate ACKs corresponding to at most 9 segments will arrive at the
   sender.  To offset the issue of loss, we extend TCP's Limited
   Transmit [<a href="rfc3042.html" title="&quot;Enhancing TCP's Loss Recovery Using Limited Transmit&quot;">RFC3042</a>] scheme to allow for the sending of new data during
   the period when the TCP sender is disambiguating loss and reordering.
   This new data serves to increase the likelihood that enough duplicate
   ACKs arrive at the sender to trigger loss recovery if it is
   appropriate.

   Note that TCP tightly couples reliability and congestion control:
   when a segment is declared lost, a retransmission is triggered, and a
   change to the sending rate is also made on the assumption that the
   drop is due to resource contention [<a href="rfc2581.html" title='"TCP Congestion Control"'>RFC2581</a>].  Therefore, simply by
   changing the retransmission trigger, the congestion control response
   is also changed.  However, we lack experience on the Internet as to
   whether delaying the point that a rate reduction takes place is




<span class="grey">Bhandarkar, et al.            Experimental                      [Page 5]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-6" id="page-6" name="page-6"> </a>
<span class="grey"><a href="rfc4653.html">RFC 4653</a>            Improving the Robustness of TCP          August 2006</span>


   appropriate for wide-scale deployment.  Therefore, the Extended
   Limited Transmit mechanism proposed in this document offers two
   variants for experimentation.

   The first Extended Limited Transmit variant, Careful Limited
   Transmit, calls for the transmission of one previously unsent
   segment, in response to duplicate acknowledgments, for every two
   segments that are known to have left the network.  This effectively
   halves the sending rate, since normal TCP operation calls for the
   sending of one segment for every segment that has left the network.
   Further, the halving starts immediately and is not delayed until a
   retransmission is triggered.  In the case of packet reordering (i.e.,
   not segment loss), the congestion control state is restored to its
   previous state when reordering is determined.

   The second variant, Aggressive Limited Transmit, calls for
   transmitting one previously unsent data segment, in response to
   duplicate acknowledgments, for every segment known to have left the
   network.  With this variant, while waiting to disambiguate the loss
   from a reordering event, ACK-clocked transmission continues at
   roughly the same rate as before the event started.  Retransmission
   and the sending rate reduction happen per [RFC2581, <a href="rfc3517.html">RFC3517</a>], albeit
   with the delayed threshold described above.  Although this approach
   delays legitimate rate reductions (possibly slightly and temporarily
   aggravating overall congestion on the network), the scheme has the
   advantage of not reducing the transmission rate in the face of
   segment reordering.

   Which of the two Extended Limited Transmit variants is best for use
   on the Internet is an open question.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/3.%20%20Algorithm"></a><a class="selflink" href="#section-3" name="section-3">3</a>.  Algorithm</span>

   The TCP-NCR modifications make two fundamental changes to the way
   [<a href="rfc3517.html" title='"A Conservative Selective Acknowledgment (SACK)-based Loss Recovery Algorithm for TCP"'>RFC3517</a>] currently operates, as follows.

   First, the trigger for retransmitting a segment is changed from three
   duplicate ACKs [RFC2581, <a href="rfc3517.html">RFC3517</a>] to indications that a congestion
   window's worth of data has left the network.  Second, TCP-NCR
   decouples initial congestion control decisions from retransmission
   decisions, in some cases delaying congestion control changes relative
   to TCP's current behavior as defined in [<a href="rfc2581.html" title='"TCP Congestion Control"'>RFC2581</a>].  The algorithm
   provides two alternatives for extending Limited Transmit.  The two
   variants of extended Limited Transmit are:







<span class="grey">Bhandarkar, et al.            Experimental                      [Page 6]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-7" id="page-7" name="page-7"> </a>
<span class="grey"><a href="rfc4653.html">RFC 4653</a>            Improving the Robustness of TCP          August 2006</span>


       Careful Limited Transmit

        This variant calls for reducing the sending rate at
        approximately the same time [<a href="rfc2581.html" title='"TCP Congestion Control"'>RFC2581</a>] implementations reduce
        the congestion window, while at the same time withholding a
        retransmission (and the final congestion determination) for
        approximately one RTT.

       Aggressive Limited Transmit

        This variant calls for maintaining the sending rate in the
        face of duplicate ACKs until TCP concludes that a segment is
        lost and needs to be retransmitted (which TCP-NCR delays by
        one RTT when compared with current loss recovery schemes).

   A TCP-NCR implementation MUST use either Careful Limited Transmit or
   Aggressive Limited Transmit.

   A constant MUST be set, depending on which variant of extended
   Limited Transmit is used, as follows:

       Careful Limited Transmit

        LT_F = 2/3

       Aggressive Limited Transmit

        LT_F = 1/2

   This constant reflects the fraction of outstanding data (including
   data sent during Extended Limited Transmit) that must be SACKed
   before a retransmission is triggered.  Since Aggressive Limited
   Transmit sends a new segment for every segment known to have left the
   network, a total of roughly cwnd segments will be sent during
   Aggressive Limited Transmit, and therefore ideally a total of roughly
   2*cwnd segments will be outstanding when a retransmission is
   triggered.  The duplicate ACK threshold is then set to LT_F = 1/2 of
   2*cwnd (or about 1 RTT worth of data).  The factor is different for
   Careful Limited Transmit because the sender only transmits one new
   segment for every two segments that are SACKed and therefore will
   ideally have a total of 1.5*cwnd segments outstanding when the
   retransmission is to be triggered.  Hence, the required threshold is
   LT_F=2/3 of 1.5*cwnd to delay the retransmission by roughly 1 RTT.

   There are situations whereby the sender cannot transmit new data
   during Extended Limited Transmit (e.g., lack of data from the
   application, receiver's advertised window limit).  These situations
   can lead to the problems discussed in the last section when a TCP



<span class="grey">Bhandarkar, et al.            Experimental                      [Page 7]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-8" id="page-8" name="page-8"> </a>
<span class="grey"><a href="rfc4653.html">RFC 4653</a>            Improving the Robustness of TCP          August 2006</span>


   does not employ Extended Limited Transmit and is starved for ACKs.
   Therefore, TCP-NCR adapts the duplicate ACK threshold on each SACK
   arrival to be as robust as possible given the actual amount of data
   that has been transmitted, or roughly LT_F times the number of
   outstanding segments.

   The TCP-NCR modifications specified in this document lend themselves
   to incremental deployment.  Only the TCP implementation on the sender
   side requires modification (assuming both hosts support SACK).  The
   changes themselves are modest.  However, as will be discussed below,
   availability of additional buffer space at the receiver will help
   maximize the benefits of using TCP-NCR but is not strictly necessary.

   The following algorithms depend on the notions provided by [<a href="rfc3517.html" title='"A Conservative Selective Acknowledgment (SACK)-based Loss Recovery Algorithm for TCP"'>RFC3517</a>],
   and we assume the reader is familiar with the terminology given in
   [<a href="rfc3517.html" title='"A Conservative Selective Acknowledgment (SACK)-based Loss Recovery Algorithm for TCP"'>RFC3517</a>].  The TCP-NCR algorithm can be adapted to alternate SACK-
   based loss recovery schemes.  [<a href="#ref-BR04" title='"TCP-DCR: Making TCP Robust to Non-Congestion Events"'>BR04</a>, <a href="#ref-BSRV04" title='"TCP-DCR: A Novel Protocol for Tolerating Wireless Channel Errors"'>BSRV04</a>] outline non-SACK-based
   algorithms; however, we do not specify those algorithms in this
   document and do not recommend them due to both the complexity and
   security implications of having only a gross understanding of the
   number of outstanding segments in the network.

   A TCP connection using the Nagle algorithm [RFC896, <a href="rfc1122.html">RFC1122</a>] MAY
   employ the TCP-NCR algorithm.  If a TCP implementation does implement
   TCP-NCR, the implementation MUST follow the various specifications
   provided in Sections <a href="#section-3.1">3.1</a> - <a href="#section-3.4">3.4</a>.  If the Nagle algorithm is not being
   used, there is no way to accurately calculate the number of
   outstanding segments in the network (and, therefore, no good way to
   derive an appropriate duplicate ACK threshold) without adding state
   to the TCP sender.  A TCP connection that does not employ the Nagle
   algorithm SHOULD NOT use TCP-NCR.  We envision that NCR could be
   adapted to an implementation that carefully tracks the sequence
   numbers transmitted in each segment.  However, we leave this as
   future work.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.1.%20%20Initialization"></a><a class="selflink" href="#section-3.1" name="section-3.1">3.1</a>.  Initialization</span>

   When entering a period of loss/reordering detection and Extended
   Limited Transmit, a TCP-NCR MUST initialize several state variables.
   A TCP MUST enter Extended Limited Transmit upon receiving the first
   ACK with a SACK block after the reception of an ACK that (a) did not
   contain SACK information and (b) did increase the connection's
   cumulative ACK point.  The initializations are:

   (I.1) The TCP MUST save the current FlightSize.

         FlightSizePrev = FlightSize




<span class="grey">Bhandarkar, et al.            Experimental                      [Page 8]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-9" id="page-9" name="page-9"> </a>
<span class="grey"><a href="rfc4653.html">RFC 4653</a>            Improving the Robustness of TCP          August 2006</span>


   (I.2) The TCP MUST set a variable for tracking the number of
         segments for which an ACK does not trigger a transmission
         during Careful Limited Transmit.

         Skipped = 0

         (Note: Skipped is not used during Aggressive Limited
         Transmit.)

   (I.3) The TCP MUST set DupThresh (from [<a href="rfc3517.html" title='"A Conservative Selective Acknowledgment (SACK)-based Loss Recovery Algorithm for TCP"'>RFC3517</a>]) based on the
         current FlightSize.

         DupThresh = max (LT_F * (FlightSize / SMSS),3)

         Note: We keep the lower bound of DupThresh = 3 from
         [RFC2581, <a href="rfc3517.html">RFC3517</a>].

   In addition to the above steps, the incoming ACK MUST be processed
   with the E series of steps in <a href="#section-3.3">Section 3.3</a>.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.2.%20%20Terminating%20Extended%20Limited%20Transmit%20and%20Preventing%20Bursts"></a><a class="selflink" href="#section-3.2" name="section-3.2">3.2</a>.  Terminating Extended Limited Transmit and Preventing Bursts</span>

   Extended Limited Transmit MUST be terminated at the start of loss
   recovery as outlined in <a href="#section-3.4">Section 3.4</a>.

   The arrival of an ACK that advances the cumulative ACK point while in
   Extended Limited Transmit, but before loss recovery is triggered,
   signals that a series of duplicate ACKs was caused by reordering and
   not congestion.  Therefore, the receipt of an ACK that extends the
   cumulative ACK point MUST terminate Extended Limited Transmit.  As
   described below (in (T.4)), an ACK that extends the cumulative ACK
   point and *also* contains SACK information will also trigger the
   beginning of a new Extended Limited Transmit phase.

   Upon the termination of Extended Limited Transmit, and especially
   when using the Careful variant, TCP-NCR may be in a situation where
   the entire cwnd is not being utilized, and therefore TCP-NCR will be
   prone to transmitting a burst of segments into the network.
   Therefore, to mitigate this bursting when a TCP-NCR in the Extended
   Limited Transmit phase receives an ACK that updates the cumulative
   ACK point (regardless of whether the ACK contains SACK information),
   the following steps MUST be taken:









<span class="grey">Bhandarkar, et al.            Experimental                      [Page 9]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-10" id="page-10" name="page-10"> </a>
<span class="grey"><a href="rfc4653.html">RFC 4653</a>            Improving the Robustness of TCP          August 2006</span>


   (T.1) A TCP MUST reset cwnd to:

         cwnd = min (FlightSize + SMSS,FlightSizePrev)

         This step ensures that cwnd is not grossly larger than the
         amount of data outstanding, a situation that would cause a
         line rate burst.

   (T.2) A TCP MUST set ssthresh to:

         ssthresh = FlightSizePrev

         This step provides TCP-NCR with a sense of "history".  If step
         (T.1) reduces cwnd below FlightSizePrev, this step ensures that
         TCP-NCR will slow start back to the operating point in effect
         before Extended Limited Transmit.

   (T.3) A TCP is now permitted to transmit previously unsent data as
         allowed by cwnd, FlightSize, application data availability, and
         the receiver's advertised window.

   (T.4) When an incoming ACK extends the cumulative ACK point and also
         contains SACK information, the initializations in steps (I.2)
         and (I.3) from <a href="#section-3.1">Section 3.1</a> MUST be taken (but step (I.1) MUST
         NOT be executed) to re-start Extended Limited Transmit.  In
         addition, the series of steps in <a href="#section-3.3">Section 3.3</a> (the "E" steps)
         MUST be taken.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.3.%20%20Extended%20Limited%20Transmit"></a><a class="selflink" href="#section-3.3" name="section-3.3">3.3</a>.  Extended Limited Transmit</span>

   On each ACK containing SACK information that arrives after TCP-NCR
   has entered the Extended Limited Transmit phase (as outlined in
   <a href="#section-3.1">Section 3.1</a>) and before Extended Limited Transmit terminates, the
   sender MUST use the following procedure.

   (E.1) The SetPipe () procedure from [<a href="rfc3517.html" title='"A Conservative Selective Acknowledgment (SACK)-based Loss Recovery Algorithm for TCP"'>RFC3517</a>] MUST be used to set
         the "pipe" variable (which represents the number of bytes
         still considered "in the network").  Note: the current value
         of DupThresh MUST be used by SetPipe () to produce an accurate
         assessment of the amount of data still considered in the
         network.

   (E.2) If the comparison in equation (1), below, holds and there are
         SMSS bytes of previously unsent data available for
         transmission, then the sender MUST transmit one segment of SMSS
         bytes.

           (pipe + Skipped) &lt;= (FlightSizePrev - SMSS)              (1)



<span class="grey">Bhandarkar, et al.            Experimental                     [Page 10]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-11" id="page-11" name="page-11"> </a>
<span class="grey"><a href="rfc4653.html">RFC 4653</a>            Improving the Robustness of TCP          August 2006</span>


         If the comparison in equation (1) does not hold or no new data
         can be transmitted (due to lack of data from the application
         or the advertised window limit), skip to step (E.6).

   (E.3) Pipe MUST be incremented by SMSS bytes.

   (E.4) If using Careful Limited Transmit, Skipped MUST be incremented
         by SMSS bytes to ensure that the next SMSS bytes of SACKed data
         processed does not trigger a Limited Transmit transmission
         (since the goal of Careful Limited Transmit is to send upon
         receipt of every second duplicate ACK).

   (E.5) A TCP MUST return to step (E.2) to ensure that as many bytes
         as are appropriate are transmitted.  This provides robustness
         to ACK loss that can be (largely) compensated for using SACK
         information.

   (E.6) DupThresh MUST be reset via:

           DupThresh = max (LT_F * (FlightSize / SMSS),3)

         where FlightSize is the total number of bytes that have not
         been cumulatively acknowledged (which is different from
         "pipe").

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.4.%20%20Entering%20Loss%20Recovery"></a><a class="selflink" href="#section-3.4" name="section-3.4">3.4</a>.  Entering Loss Recovery</span>

   When a segment is deemed lost via the algorithms in [<a href="rfc3517.html" title='"A Conservative Selective Acknowledgment (SACK)-based Loss Recovery Algorithm for TCP"'>RFC3517</a>],
   Extended Limited Transmit MUST be terminated, leaving the algorithms
   in [<a href="rfc3517.html" title='"A Conservative Selective Acknowledgment (SACK)-based Loss Recovery Algorithm for TCP"'>RFC3517</a>] to govern TCP's behavior.  One slight change to
   [<a href="rfc3517.html" title='"A Conservative Selective Acknowledgment (SACK)-based Loss Recovery Algorithm for TCP"'>RFC3517</a>] MUST be made, however.  In <a href="#section-5">Section 5</a>, step (2) of [<a href="rfc3517.html" title='"A Conservative Selective Acknowledgment (SACK)-based Loss Recovery Algorithm for TCP"'>RFC3517</a>]
   MUST be changed to:

       (2) ssthresh = cwnd = (FlightSizePrev / 2)

   This ensures that the congestion control modifications are made with
   respect to the amount of data in the network before FlightSize was
   increased by Extended Limited Transmit.

   Note: Once the algorithm in [<a href="rfc3517.html" title='"A Conservative Selective Acknowledgment (SACK)-based Loss Recovery Algorithm for TCP"'>RFC3517</a>] takes over from Extended
   Limited Transmit, the DupThresh value MUST be held constant until the
   loss recovery phase is terminated.









<span class="grey">Bhandarkar, et al.            Experimental                     [Page 11]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-12" id="page-12" name="page-12"> </a>
<span class="grey"><a href="rfc4653.html">RFC 4653</a>            Improving the Robustness of TCP          August 2006</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/4.%20%20Advantages"></a><a class="selflink" href="#section-4" name="section-4">4</a>.  Advantages</span>

   The major advantages of TCP-NCR are twofold.  As discussed in <a href="#section-1">Section</a>
   <a href="#section-1">1</a>, TCP-NCR will open up the design space for network applications and
   components that are currently constrained by TCP's lack of robustness
   to packet reordering.  The second advantage is in terms of an
   increase in TCP performance.

   [<a id="ref-BR04" name="ref-BR04">BR04</a>] presents ns-2 [<a href="#ref-NS-2">NS-2</a>] simulations of a pre-cursor to the TCP-
   NCR algorithm specified in this document, called TCP-DCR (Delayed
   Congestion Response).  The paper shows that TCP-DCR aids performance
   in comparison to unmodified TCP in the presence of packet reordering.
   In addition, the extended version of [<a href="#ref-BR04" title='"TCP-DCR: Making TCP Robust to Non-Congestion Events"'>BR04</a>] presents results based on
   emulations involving Linux (kernel 2.4.24).  These results show that
   the performance of TCP-DCR is similar to Linux's native
   implementation that seeks to "undo" wrong decisions according to
   duplicate-SACK (DSACK) [<a href="rfc2883.html" title='"An Extension to the Selective Acknowledgement (SACK) Option for TCP"'>RFC2883</a>] feedback (similar to the schemes
   outlined in [<a href="#ref-ZKFP03" title='"RR-TCP: A Reordering-Robust TCP with DSACK"'>ZKFP03</a>]), when packets are reordered by less than one
   RTT.  The advantage of using TCP-DCR over the DSACK-based scheme is
   that the DSACK-based scheme tries to estimate the exact amount of
   reordering in the network using fairly complex algorithms, whereas
   TCP-DCR achieves similar results with less complicated modifications.

   In addition, [<a href="#ref-BR04" title='"TCP-DCR: Making TCP Robust to Non-Congestion Events"'>BR04</a>,<a href="#ref-BSRV04" title='"TCP-DCR: A Novel Protocol for Tolerating Wireless Channel Errors"'>BSRV04</a>] illustrate the ability of TCP-DCR to allow
   for the improvement of other parts of the system.  For example, these
   papers show that increasing TCP's robustness to packet reordering
   allows a novel wireless ARQ mechanism to be added at the link-layer.
   The added robustness of the link-layer to channel errors, in turn,
   increases TCP performance by not requiring TCP to retransmit packets
   that were dropped due to corruption (and thus also prevents TCP from
   needlessly reducing the sending rate when retransmitting these
   segments).

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/5.%20%20Disadvantages"></a><a class="selflink" href="#section-5" name="section-5">5</a>.  Disadvantages</span>

   Although all the changes outlined above are implemented in the
   sender, the receiver also potentially has a part to play.  In
   particular, TCP-NCR increases the receiver's buffering requirement by
   up to an extra cwnd -- in the case of the TCP sender using Aggressive
   Limited Transmit and actual loss occurring in the network.
   Therefore, to maximize the benefits from TCP-NCR, receivers should
   advertise a large window to absorb the extra out-of-order traffic.
   In the case that the additional buffer requirements are not met, the
   use of the above algorithm takes into account the reduced advertised
   window -- with a corresponding loss in robustness to packet
   reordering.





<span class="grey">Bhandarkar, et al.            Experimental                     [Page 12]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-13" id="page-13" name="page-13"> </a>
<span class="grey"><a href="rfc4653.html">RFC 4653</a>            Improving the Robustness of TCP          August 2006</span>


   In addition, using TCP-NCR could delay the delivery of data to the
   application by up to one RTT because the fast retransmission point is
   delayed by roughly one RTT in TCP-NCR.  Applications that are
   sensitive to such delays should turn off the TCP-NCR option.  For
   instance, a socket option could be introduced to allow applications
   to control whether NCR would be used for a particular connection.

   Finally, the use of TCP-NCR makes the recovery from congestion events
   sluggish in comparison to the standard reaction in [<a href="rfc2581.html" title='"TCP Congestion Control"'>RFC2581</a>].  [BR04,
   BSRV04] show (via simulation) that the delay in congestion response
   has minimal impact on the connection itself and the traffic sharing a
   bottleneck.  [<a href="#ref-BBFS01" title='"Dynamic Behavior of Slowly Responsive Congestion Control Algorithms"'>BBFS01</a>] also indicates (again, via simulation) that
   "slowly responsive" congestion control may be safe for deployment in
   the Internet.  These studies suggest that schemes that slightly delay
   congestion control decisions may be reasonable; however, further
   experimentation on the Internet is required to verify these results.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/6.%20%20Related%20Work"></a><a class="selflink" href="#section-6" name="section-6">6</a>.  Related Work</span>

   Over the past few years, several solutions have been proposed to
   improve the performance of TCP in the face of segment reordering.
   These schemes generally fall into one of two categories (with some
   overlap): mechanisms that try to prevent spurious retransmits from
   happening and mechanisms that try to detect spurious retransmits and
   "undo" the needless congestion control state changes that have been
   taken.

   [<a href="#ref-BA02" title='"On Making TCP More Robust to Packet Reordering,"'>BA02</a>,<a href="#ref-ZKFP03" title='"RR-TCP: A Reordering-Robust TCP with DSACK"'>ZKFP03</a>] attempt to prevent segment reordering from triggering
   spurious retransmits by using various algorithms to approximate the
   duplicate ACK threshold required to disambiguate loss and reordering
   over a given network path at a given time.  TCP-NCR similarly tries
   to prevent spurious retransmits.  However, TCP-NCR takes a simplified
   approach compared to those in [<a href="#ref-BA02" title='"On Making TCP More Robust to Packet Reordering,"'>BA02</a>, <a href="#ref-ZKFP03" title='"RR-TCP: A Reordering-Robust TCP with DSACK"'>ZKFP03</a>], in that TCP-NCR simply
   delays retransmission by an amount based on the current cwnd (in
   comparison to standard TCP), while the other schemes use relatively
   complex algorithms in an attempt to derive a more precise value for
   DupThresh that depends on the current patterns of packet reordering.
   While TCP-NCR offers simplicity, the other schemes may offer more
   precision such that applications would not be forced to wait as long
   for their retransmissions.  Future work could be undertaken to
   achieve robustness without needless delay.

   On the other hand, several schemes have been developed to detect and
   mitigate needless retransmissions after the fact.  [RFC3522, <a href="rfc3708.html">RFC3708</a>,
   BA02, <a href="rfc4015.html">RFC4015</a>, <a href="rfc4138.html">RFC4138</a>] present algorithms to detect spurious
   retransmits and mitigate the changes these events made to the
   congestion control state.  TCP-NCR could be used in conjunction with
   these algorithms, with TCP-NCR attempting to prevent spurious



<span class="grey">Bhandarkar, et al.            Experimental                     [Page 13]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-14" id="page-14" name="page-14"> </a>
<span class="grey"><a href="rfc4653.html">RFC 4653</a>            Improving the Robustness of TCP          August 2006</span>


   retransmits and some other scheme kicking in if the prevention
   failed.  In addition, note that TCP-NCR is concentrated on preventing
   spurious fast retransmits; some of the above algorithms also attempt
   to detect and mitigate spurious timeout-based retransmits.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/7.%20%20Security%20Considerations"></a><a class="selflink" href="#section-7" name="section-7">7</a>.  Security Considerations</span>

   General attacks against the congestion control of TCP are described
   in [<a href="rfc2581.html" title='"TCP Congestion Control"'>RFC2581</a>].  SACK-based loss recovery for TCP [<a href="rfc3517.html" title='"A Conservative Selective Acknowledgment (SACK)-based Loss Recovery Algorithm for TCP"'>RFC3517</a>] mitigates
   some of the duplicate ACK attacks against TCP's congestion control.
   This document builds upon that work, and the Extended Limited
   Transmit algorithms specified in this document have been designed to
   thwart the ACK division problems that are described in [<a href="rfc3465.html" title='"TCP Congestion Control with Appropriate Byte Counting (ABC)"'>RFC3465</a>].

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/8.%20%20Acknowledgments"></a><a class="selflink" href="#section-8" name="section-8">8</a>.  Acknowledgments</span>

   Feedback from Lars Eggert, Ted Faber, Wesley Eddy, Gorry Fairhurst,
   Sally Floyd, Sara Landstrom, Nauzad Sadry, Pasi Sarolahti, Joe Touch,
   Nitin Vaidya, and the TCPM working group have contributed
   significantly to this document.  Our thanks to all!

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/9.%20%20References"></a><a class="selflink" href="#section-9" name="section-9">9</a>.  References</span>

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/9.1.%20%20Normative%20References"></a><a class="selflink" href="#section-9.1" name="section-9.1">9.1</a>.  Normative References</span>

   [<a id="ref-RFC793" name="ref-RFC793">RFC793</a>]  Postel, J., "Transmission Control Protocol", STD 7, <a href="rfc793.html">RFC</a>
             <a href="rfc793.html">793</a>, September 1981.

   [<a id="ref-RFC2018" name="ref-RFC2018">RFC2018</a>] Mathis, M., Mahdavi, J., Floyd, S., and A. Romanow, "TCP
             Selective Acknowledgement Options", <a href="rfc2018.html">RFC 2018</a>, October 1996.

   [<a id="ref-RFC2119" name="ref-RFC2119">RFC2119</a>] Bradner, S., "Key words for use in RFCs to Indicate
             Requirement Levels", <a href="https://tools.ietf.org/html/bcp14">BCP 14</a>, <a href="rfc2119.html">RFC 2119</a>, March 1997.

   [<a id="ref-RFC2581" name="ref-RFC2581">RFC2581</a>] Allman, M., Paxson, V., and W. Stevens, "TCP Congestion
             Control", <a href="rfc2581.html">RFC 2581</a>, April 1999.

   [<a id="ref-RFC3042" name="ref-RFC3042">RFC3042</a>] Allman, M., Balakrishnan, H., and S. Floyd, "Enhancing
             TCP's Loss Recovery Using Limited Transmit", <a href="rfc3042.html">RFC 3042</a>,
             January 2001.

   [<a id="ref-RFC3517" name="ref-RFC3517">RFC3517</a>] Blanton, E., Allman, M., Fall, K., and L. Wang, "A
             Conservative Selective Acknowledgment (SACK)-based Loss
             Recovery Algorithm for TCP", <a href="rfc3517.html">RFC 3517</a>, April 2003.







<span class="grey">Bhandarkar, et al.            Experimental                     [Page 14]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-15" id="page-15" name="page-15"> </a>
<span class="grey"><a href="rfc4653.html">RFC 4653</a>            Improving the Robustness of TCP          August 2006</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/9.2.%20%20Informative%20References"></a><a class="selflink" href="#section-9.2" name="section-9.2">9.2</a>.  Informative References</span>

   [<a id="ref-BA02" name="ref-BA02">BA02</a>]    E. Blanton and M. Allman, "On Making TCP More Robust to
             Packet Reordering," ACM Computer Communication Review,
             January 2002.

   [<a id="ref-BBFS01" name="ref-BBFS01">BBFS01</a>]  D. Bansal, H. Balakrishnan, S. Floyd and S. Shenker,
             "Dynamic Behavior of Slowly Responsive Congestion Control
             Algorithms", Proceedings of ACM SIGCOMM, Sep. 2001.

   [<a id="ref-BPS99" name="ref-BPS99">BPS99</a>]   J. Bennett, C. Partridge, and N. Shectman, "Packet
             reordering is not pathological network behavior," IEEE/ACM
             Transactions on Networking, December 1999.

   [<a id="ref-BR04" name="ref-BR04">BR04</a>]    Sumitha Bhandarkar and A. L. Narasimha Reddy, "TCP-DCR:
             Making TCP Robust to Non-Congestion Events", In the
             Proceedings of Networking 2004 conference, May 2004.
             Extended version available as tech report TAMU-ECE-2003-04.

   [<a id="ref-BSRV04" name="ref-BSRV04">BSRV04</a>]  Sumitha Bhandarkar, Nauzad Sadry, A. L. Narasimha Reddy and
             Nitin Vaidya, "TCP-DCR: A Novel Protocol for Tolerating
             Wireless Channel Errors", to appear in IEEE Transactions on
             Mobile Computing.

   [<a id="ref-GPL04" name="ref-GPL04">GPL04</a>]   Ladan Gharai, Colin Perkins and Tom Lehman, "Packet
             Reordering, High Speed Networks and Transport Protocol
             Performance", ICCCN 2004, October 2004.

   [<a id="ref-Jac88" name="ref-Jac88">Jac88</a>]   V. Jacobson, "Congestion Avoidance and Control", Computer
             Communication Review, vol. 18, no. 4, pp. 314-329, Aug.
             1988.  <a href="ftp://ftp.ee.lbl.gov/papers/congavoid.ps.Z">ftp://ftp.ee.lbl.gov/papers/congavoid.ps.Z</a>.

   [<a id="ref-JIDKT03" name="ref-JIDKT03">JIDKT03</a>] S. Jaiswal, G. Iannaccone, C. Diot, J. Kurose, and D.
             Towsley, "Measurement and Classification of Out-of-Sequence
             Packets in a Tier-1 IP Backbone," Proceedings of IEEE
             INFOCOM, 2003.

   [<a id="ref-KM02" name="ref-KM02">KM02</a>]    I. Keslassy and N. McKeown, "Maintaining packet order in
             twostage switches," Proceedings of the IEEE Infocom, June
             2002

   [<a id="ref-MAF05" name="ref-MAF05">MAF05</a>]   A. Medina, M. Allman, S. Floyd.  Measuring the Evolution of
             Transport Protocols in the Internet.  ACM Computer
             Communication Review, 35(2), April 2005.

   [<a id="ref-NS-2" name="ref-NS-2">NS-2</a>]    ns-2 Network Simulator. <a href="http://www.isi.edu/nsnam/">http://www.isi.edu/nsnam/</a>





<span class="grey">Bhandarkar, et al.            Experimental                     [Page 15]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-16" id="page-16" name="page-16"> </a>
<span class="grey"><a href="rfc4653.html">RFC 4653</a>            Improving the Robustness of TCP          August 2006</span>


   [<a id="ref-Pax97" name="ref-Pax97">Pax97</a>]   V. Paxson, "End-to-End Internet Packet Dynamics,"
             Proceedings of ACM SIGCOMM, September 1997.

   [<a id="ref-RFC896" name="ref-RFC896">RFC896</a>]  Nagle, J., "Congestion control in IP/TCP internetworks",
             <a href="rfc896.html">RFC 896</a>, January 1984.

   [<a id="ref-RFC1122" name="ref-RFC1122">RFC1122</a>] Braden, R., "Requirements for Internet Hosts -
             Communication Layers", STD 3, <a href="rfc1122.html">RFC 1122</a>, October 1989.

   [<a id="ref-RFC2883" name="ref-RFC2883">RFC2883</a>] Floyd, S., Mahdavi, J., Mathis, M., and M. Podolsky, "An
             Extension to the Selective Acknowledgement (SACK) Option
             for TCP", <a href="rfc2883.html">RFC 2883</a>, July 2000.

   [<a id="ref-RFC2960" name="ref-RFC2960">RFC2960</a>] R. Stewart, Q. Xie, K. Morneault, C. Sharp, H.
             Schwarzbauer, T. Taylor, I. Rytina, M. Kalla, L. Zhang, V.
             Paxson.  Stream Control Transmission Protocol.  October
             2000.

   [<a id="ref-RFC3465" name="ref-RFC3465">RFC3465</a>] Allman, M., "TCP Congestion Control with Appropriate Byte
             Counting (ABC)", <a href="rfc3465.html">RFC 3465</a>, February 2003.

   [<a id="ref-RFC3522" name="ref-RFC3522">RFC3522</a>] Ludwig, R. and M. Meyer, "The Eifel Detection Algorithm for
             TCP", <a href="rfc3522.html">RFC 3522</a>, April 2003.

   [<a id="ref-RFC3708" name="ref-RFC3708">RFC3708</a>] Blanton, E. and M. Allman, "Using TCP Duplicate Selective
             Acknowledgement (DSACKs) and Stream Control Transmission
             Protocol (SCTP) Duplicate Transmission Sequence Numbers
             (TSNs) to Detect Spurious Retransmissions", <a href="rfc3708.html">RFC 3708</a>,
             February 2004.

   [<a id="ref-RFC4015" name="ref-RFC4015">RFC4015</a>] Ludwig, R. and A. Gurtov, "The Eifel Response Algorithm for
             TCP", <a href="rfc4015.html">RFC 4015</a>, February 2005.

   [<a id="ref-RFC4138" name="ref-RFC4138">RFC4138</a>] Sarolahti, P. and M. Kojo, "Forward RTO-Recovery (F-RTO):
             An Algorithm for Detecting Spurious Retransmission Timeouts
             with TCP and the Stream Control Transmission Protocol
             (SCTP)", <a href="rfc4138.html">RFC 4138</a>, August 2005.

   [<a id="ref-ZKFP03" name="ref-ZKFP03">ZKFP03</a>]  M. Zhang, B. Karp, S. Floyd, L. Peterson, "RR-TCP: A
             Reordering-Robust TCP with DSACK", in Proceedings of the
             Eleventh IEEE International Conference on Networking
             Protocols (ICNP 2003), Atlanta, GA, November, 2003.









<span class="grey">Bhandarkar, et al.            Experimental                     [Page 16]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-17" id="page-17" name="page-17"> </a>
<span class="grey"><a href="rfc4653.html">RFC 4653</a>            Improving the Robustness of TCP          August 2006</span>


Authors' Addresses

   Sumitha Bhandarkar
   Dept. of Elec. Engg.
   214 ZACH
   College Station, TX 77843-3128

   Phone: (512) 468-8078
   EMail: sumitha@tamu.edu
   URL: <a href="http://students.cs.tamu.edu/sumitha/">http://students.cs.tamu.edu/sumitha/</a>


   A. L. Narasimha Reddy
   Professor
   Dept. of Elec. Engg.
   315C WERC
   College Station, TX 77843-3128

   Phone: (979) 845-7598
   EMail: reddy@ee.tamu.edu
   URL: <a href="http://ee.tamu.edu/~reddy/">http://ee.tamu.edu/~reddy/</a>


   Mark Allman
   ICSI Center for Internet Research
   1947 Center Street, Suite 600
   Berkeley, CA 94704-1198

   Phone: (440) 235-1792
   EMail: mallman@icir.org
   URL: <a href="http://www.icir.org/mallman/">http://www.icir.org/mallman/</a>


   Ethan Blanton
   Purdue University Computer Science
   305 North University Street
   West Lafayette, IN  47907

   EMail: eblanton@cs.purdue.edu












<span class="grey">Bhandarkar, et al.            Experimental                     [Page 17]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-18" id="page-18" name="page-18"> </a>
<span class="grey"><a href="rfc4653.html">RFC 4653</a>            Improving the Robustness of TCP          August 2006</span>


Full Copyright Statement

   Copyright (C) The Internet Society (2006).

   This document is subject to the rights, licenses and restrictions
   contained in <a href="https://tools.ietf.org/html/bcp78">BCP 78</a>, and except as set forth therein, the authors
   retain all their rights.

   This document and the information contained herein are provided on an
   "AS IS" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS
   OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET
   ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED,
   INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE
   INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED
   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.

Intellectual Property

   The IETF takes no position regarding the validity or scope of any
   Intellectual Property Rights or other rights that might be claimed to
   pertain to the implementation or use of the technology described in
   this document or the extent to which any license under such rights
   might or might not be available; nor does it represent that it has
   made any independent effort to identify any such rights.  Information
   on the procedures with respect to rights in RFC documents can be
   found in <a href="https://tools.ietf.org/html/bcp78">BCP 78</a> and <a href="https://tools.ietf.org/html/bcp79">BCP 79</a>.

   Copies of IPR disclosures made to the IETF Secretariat and any
   assurances of licenses to be made available, or the result of an
   attempt made to obtain a general license or permission for the use of
   such proprietary rights by implementers or users of this
   specification can be obtained from the IETF on-line IPR repository at
   <a href="http://www.ietf.org/ipr">http://www.ietf.org/ipr</a>.

   The IETF invites any interested party to bring to its attention any
   copyrights, patents or patent applications, or other proprietary
   rights that may cover technology that may be required to implement
   this standard.  Please address the information to the IETF at
   ietf-ipr@ietf.org.

Acknowledgement

   Funding for the RFC Editor function is provided by the IETF
   Administrative Support Activity (IASA).







Bhandarkar, et al.            Experimental                     [Page 18]

</pre><br/>
    <span class="noprint"><small><small>Html markup produced by rfcmarkup 1.126, available from
      <a href="https://tools.ietf.org/tools/rfcmarkup/">https://tools.ietf.org/tools/rfcmarkup/</a>
    </small></small></span>
  </div>




</body><!-- Mirrored from tools.ietf.org/html/rfc4653 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 06 Mar 2018 23:18:40 GMT --></html>