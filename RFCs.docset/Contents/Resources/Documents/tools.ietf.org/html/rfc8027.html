<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml"><!-- Mirrored from tools.ietf.org/html/rfc8027 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 06 Mar 2018 23:18:17 GMT --><!-- Added by HTTrack --><head><meta content="text/html;charset=utf-8" http-equiv="content-type"/><!-- /Added by HTTrack -->

    <meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
    <meta content="index,follow" name="robots"/>
    <meta content="rfcmarkup version 1.126" name="creator"/>
    <link href="http://purl.org/dc/elements/1.1/" rel="schema.DC"/>
<meta content="draft-hardaker-dnsop-dnssec-roadblock-avoidance" name="DC.Relation.Replaces"/>
<meta content="urn:ietf:rfc:8027" name="DC.Identifier"/>
<meta content="November, 2016" name="DC.Date.Issued"/>
<meta content="Hardaker, Wesley" name="DC.Creator"/>
<meta content="Krishnaswamy, Suresh" name="DC.Creator"/>
<meta content="This document describes problems that a Validating DNS resolver, stub-
resolver, or application might run into within a non-compliant
infrastructure. It outlines potential detection and mitigation
techniques. The scope of the document is to create a shared approach
to detect and overcome network issues that a DNSSEC software/system
may face." name="DC.Description.Abstract"/>
<meta content="DNSSEC Roadblock Avoidance" name="DC.Title"/>

    <link href="https://tools.ietf.org/images/rfc.png" rel="icon" type="image/png"/>
    <link href="https://tools.ietf.org/images/rfc.png" rel="shortcut icon" type="image/png"/>
    <title>RFC 8027 - DNSSEC Roadblock Avoidance</title>
    
    
    <style type="text/css">
	@media only screen 
	  and (min-width: 992px)
	  and (max-width: 1199px) {
	    body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 768px)
	  and (max-width: 991px) {
            body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 480px)
	  and (max-width: 767px) {
            body { font-size: 11pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (max-width: 479px) {
            body { font-size: 8pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-device-width : 375px) 
	  and (max-device-width : 667px) {
            body { font-size: 9.5pt; }
            div.content { width: 96ex; margin: 0 1px; }
        }
	@media only screen 
	  and (min-device-width: 1200px) {
            body { font-size: 10pt; margin: 0 4em; }
            div.content { width: 96ex; margin: 0; }
        }
        h1, h2, h3, h4, h5, h6, .h1, .h2, .h3, .h4, .h5, .h6 {
	    font-weight: bold;
            line-height: 0pt;
            display: inline;
            white-space: pre;
            font-family: monospace;
            font-size: 1em;
	    font-weight: bold;
        }
        pre {
            font-size: 1em;
            margin-top: 0px;
            margin-bottom: 0px;
        }
	.pre {
	    white-space: pre;
	    font-family: monospace;
	}
	.header{
	    font-weight: bold;
	}
        .newpage {
            page-break-before: always;
        }
        .invisible {
            text-decoration: none;
            color: white;
        }
        a.selflink {
          color: black;
          text-decoration: none;
        }
        @media print {
            body {
                font-family: monospace;
                font-size: 10.5pt;
            }
            h1, h2, h3, h4, h5, h6 {
                font-size: 1em;
            }
        
            a:link, a:visited {
                color: inherit;
                text-decoration: none;
            }
            .noprint {
                display: none;
            }
        }
	@media screen {
	    .grey, .grey a:link, .grey a:visited {
		color: #777;
	    }
            .docinfo {
                background-color: #EEE;
            }
            .top {
                border-top: 7px solid #EEE;
            }
            .bgwhite  { background-color: white; }
            .bgred    { background-color: #F44; }
            .bggrey   { background-color: #666; }
            .bgbrown  { background-color: #840; }            
            .bgorange { background-color: #FA0; }
            .bgyellow { background-color: #EE0; }
            .bgmagenta{ background-color: #F4F; }
            .bgblue   { background-color: #66F; }
            .bgcyan   { background-color: #4DD; }
            .bggreen  { background-color: #4F4; }

            .legend   { font-size: 90%; }
            .cplate   { font-size: 70%; border: solid grey 1px; }
	}
    </style>
    <!--[if IE]>
    <style>
    body {
       font-size: 13px;
       margin: 10px 10px;
    }
    </style>
    <![endif]-->

    <script type="text/javascript"><!--
    function addHeaderTags() {
	var spans = document.getElementsByTagName("span");
	for (var i=0; i < spans.length; i++) {
	    var elem = spans[i];
	    if (elem) {
		var level = elem.getAttribute("class");
                if (level == "h1" || level == "h2" || level == "h3" || level == "h4" || level == "h5" || level == "h6") {
                    elem.innerHTML = "<"+level+">"+elem.innerHTML+"</"+level+">";		
                }
	    }
	}
    }
    var legend_html = "Colour legend:<br />      <table>         <tr><td>Unknown:</td>                   <td><span class='cplate bgwhite'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft:</td>                     <td><span class='cplate bgred'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Informational:</td>             <td><span class='cplate bgorange'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Experimental:</td>              <td><span class='cplate bgyellow'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Best Common Practice:</td>      <td><span class='cplate bgmagenta'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Proposed Standard:</td>         <td><span class='cplate bgblue'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft Standard (old designation):</td> <td><span class='cplate bgcyan'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Internet Standard:</td>         <td><span class='cplate bggreen'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Historic:</td>                  <td><span class='cplate bggrey'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Obsolete:</td>                  <td><span class='cplate bgbrown'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>     </table>";
    function showElem(id) {
        var elem = document.getElementById(id);
        elem.innerHTML = eval(id+"_html");
        elem.style.visibility='visible';
    }
    function hideElem(id) {
        var elem = document.getElementById(id);
        elem.style.visibility='hidden';        
        elem.innerHTML = "";
    }
    // -->
    </script>
</head>
<body onload="addHeaderTags()">
  <div class="content">
   <div style="height: 13px;">
      <div class="pre noprint docinfo bgmagenta" onclick="showElem('legend');" onmouseout="hideElem('legend')" onmouseover="this.style.cursor='pointer';" style="height: 6px; position: absolute;" title="Click for colour legend.">                                                                        </div>
      <div class="docinfo noprint pre legend" id="legend" onmouseout="hideElem('legend');" onmouseover="showElem('legend');" style="position:absolute; top: 4px; left: 4ex; visibility:hidden; background-color: white; padding: 4px 9px 5px 7px; border: solid #345 1px; ">
      </div>
   </div>
<span class="pre noprint docinfo top">[<a href="index.html" title="Document search and retrieval page">Docs</a>] [<a href="https://tools.ietf.org/rfc/rfc8027.txt" title="Plaintext version of this document">txt</a>|<a href="https://tools.ietf.org/pdf/rfc8027" title="PDF version of this document">pdf</a>] [<a href="https://tools.ietf.org/html/draft-ietf-dnsop-dnssec-roadblock-avoidance" title="draft-ietf-dnsop-dnssec-roadblock-avoidance">draft-ietf-dnso...</a>] [<a href="https://datatracker.ietf.org/doc/rfc8027" title="IESG Datatracker information for this document">Tracker</a>] [<a href="https://tools.ietf.org/rfcdiff?difftype=--hwdiff&amp;url2=rfc8027" title="Inline diff (wdiff)">Diff1</a>] [<a href="https://tools.ietf.org/rfcdiff?url2=rfc8027" title="Side-by-side diff">Diff2</a>] [<a href="https://datatracker.ietf.org/ipr/search/?rfc=8027&amp;submit=rfc" title="IPR disclosures related to this document">IPR</a>] [<a href="https://www.rfc-editor.org/errata_search.php?rfc=8027">Errata</a>]</span><br/>
<span class="pre noprint docinfo">                                                                        </span><br/>
<span class="pre noprint docinfo">                                                   BEST CURRENT PRACTICE</span><br/>
<span class="pre noprint docinfo">                                                            <span style="color: #C00;">Errata Exist</span></span><br/>
<pre>Internet Engineering Task Force (IETF)                       W. Hardaker
Request for Comments: 8027                                       USC/ISI
BCP: 207                                                  O. Gudmundsson
Category: Best Current Practice                               CloudFlare
ISSN: 2070-1721                                          S. Krishnaswamy
                                                                 Parsons
                                                           November 2016


                       <span class="h1">DNSSEC Roadblock Avoidance</span>

Abstract

   This document describes problems that a Validating DNS resolver,
   stub-resolver, or application might run into within a non-compliant
   infrastructure.  It outlines potential detection and mitigation
   techniques.  The scope of the document is to create a shared approach
   to detect and overcome network issues that a DNSSEC software/system
   may face.

Status of This Memo

   This memo documents an Internet Best Current Practice.

   This document is a product of the Internet Engineering Task Force
   (IETF).  It represents the consensus of the IETF community.  It has
   received public review and has been approved for publication by the
   Internet Engineering Steering Group (IESG).  Further information on
   BCPs is available in <a href="rfc7841.html#section-2">Section 2 of RFC 7841</a>.

   Information about the current status of this document, any errata,
   and how to provide feedback on it may be obtained at
   <a href="http://www.rfc-editor.org/info/rfc8027">http://www.rfc-editor.org/info/rfc8027</a>.

Copyright Notice

   Copyright (c) 2016 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to <a href="https://tools.ietf.org/html/bcp78">BCP 78</a> and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (<a href="http://trustee.ietf.org/license-info">http://trustee.ietf.org/license-info</a>) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.



<span class="grey">Hardaker, et al.          Best Current Practice                 [Page 1]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-2" id="page-2" name="page-2"> </a>
<span class="grey"><a href="rfc8027.html">RFC 8027</a>               DNSSEC Roadblock Avoidance          November 2016</span>


Table of Contents

   <a href="#section-1">1</a>. Introduction ....................................................<a href="#page-3">3</a>
      <a href="#section-1.1">1.1</a>. Notation ...................................................<a href="#page-3">3</a>
      <a href="#section-1.2">1.2</a>. Background .................................................<a href="#page-3">3</a>
      <a href="#section-1.3">1.3</a>. Implementation Experiences .................................<a href="#page-4">4</a>
           <a href="#section-1.3.1">1.3.1</a>. Test Zone Implementation ............................<a href="#page-4">4</a>
   <a href="#section-2">2</a>. Goals ...........................................................<a href="#page-4">4</a>
   <a href="#section-3">3</a>. Detecting DNSSEC Non-compliance .................................<a href="#page-5">5</a>
      <a href="#section-3.1">3.1</a>. Determining DNSSEC Support in Recursive Resolvers ..........<a href="#page-5">5</a>
           <a href="#section-3.1.1">3.1.1</a>. Supports UDP Answers ................................<a href="#page-6">6</a>
           <a href="#section-3.1.2">3.1.2</a>. Supports TCP Answers ................................<a href="#page-6">6</a>
           <a href="#section-3.1.3">3.1.3</a>. Supports EDNS0 ......................................<a href="#page-6">6</a>
           <a href="#section-3.1.4">3.1.4</a>. Supports the DO Bit .................................<a href="#page-7">7</a>
           <a href="#section-3.1.5">3.1.5</a>. Supports the AD Bit DNSKEY Algorithms 5 and/or 8 ....<a href="#page-7">7</a>
           <a href="#section-3.1.6">3.1.6</a>. Returns RRSIG for Signed Answer .....................<a href="#page-7">7</a>
           <a href="#section-3.1.7">3.1.7</a>. Supports Querying for DNSKEY Records ................<a href="#page-8">8</a>
           <a href="#section-3.1.8">3.1.8</a>. Supports Querying for DS Records ....................<a href="#page-8">8</a>
           <a href="#section-3.1.9">3.1.9</a>. Supports Negative Answers with NSEC Records .........<a href="#page-8">8</a>
           <a href="#section-3.1.10">3.1.10</a>. Supports Negative Answers with NSEC3 Records .......<a href="#page-9">9</a>
           3.1.11. Supports Queries Where DNAME Records Lead
                   to an Answer .......................................<a href="#page-9">9</a>
           <a href="#section-3.1.12">3.1.12</a>. Permissive DNSSEC .................................<a href="#page-10">10</a>
           <a href="#section-3.1.13">3.1.13</a>. Supports Unknown RRtypes ..........................<a href="#page-10">10</a>
      <a href="#section-3.2">3.2</a>. Direct Network Queries ....................................<a href="#page-10">10</a>
           <a href="#section-3.2.1">3.2.1</a>. Support for Remote UDP over Port 53 ................<a href="#page-10">10</a>
           <a href="#section-3.2.2">3.2.2</a>. Support for Remote UDP with Fragmentation ..........<a href="#page-11">11</a>
           <a href="#section-3.2.3">3.2.3</a>. Support for Outbound TCP over Port 53 ..............<a href="#page-11">11</a>
      <a href="#section-3.3">3.3</a>. Support for DNSKEY and DS Combinations ....................<a href="#page-11">11</a>
   <a href="#section-4">4</a>. Aggregating the Results ........................................<a href="#page-12">12</a>
      <a href="#section-4.1">4.1</a>. Resolver Capability Description ...........................<a href="#page-12">12</a>
   <a href="#section-5">5</a>. Roadblock Avoidance ............................................<a href="#page-13">13</a>
      <a href="#section-5.1">5.1</a>. Partial Resolver Usage ....................................<a href="#page-16">16</a>
           <a href="#section-5.1.1">5.1.1</a>. Known Insecure Lookups .............................<a href="#page-16">16</a>
           <a href="#section-5.1.2">5.1.2</a>. Partial NSEC/NSEC3 Support .........................<a href="#page-16">16</a>
   <a href="#section-6">6</a>. Start-Up and Network Connectivity Issues .......................<a href="#page-16">16</a>
      <a href="#section-6.1">6.1</a>. What to Do ................................................<a href="#page-17">17</a>
   <a href="#section-7">7</a>. Quick Test .....................................................<a href="#page-17">17</a>
      <a href="#section-7.1">7.1</a>. Test Negative Answers Algorithm 5 .........................<a href="#page-17">17</a>
      <a href="#section-7.2">7.2</a>. Test Algorithm 8 ..........................................<a href="#page-18">18</a>
      <a href="#section-7.3">7.3</a>. Test Algorithm 13 .........................................<a href="#page-18">18</a>
      <a href="#section-7.4">7.4</a>. Fails When DNSSEC Does Not Validate .......................<a href="#page-18">18</a>
   <a href="#section-8">8</a>. Security Considerations ........................................<a href="#page-18">18</a>
   <a href="#section-9">9</a>. Normative References ...........................................<a href="#page-18">18</a>
   Acknowledgments ...................................................<a href="#page-19">19</a>
   Authors' Addresses ................................................<a href="#page-19">19</a>





<span class="grey">Hardaker, et al.          Best Current Practice                 [Page 2]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-3" id="page-3" name="page-3"> </a>
<span class="grey"><a href="rfc8027.html">RFC 8027</a>               DNSSEC Roadblock Avoidance          November 2016</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/1.%20%20Introduction"></a><a class="selflink" href="#section-1" name="section-1">1</a>.  Introduction</span>

   This document describes problems observable during DNSSEC ([<a href="rfc4034.html" title='"Resource Records for the DNS Security Extensions"'>RFC4034</a>]
   [<a href="rfc4035.html" title='"Protocol Modifications for the DNS Security Extensions"'>RFC4035</a>]) deployment that derive from non-compliant infrastructure.
   It poses potential detection and mitigation techniques.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/1.1.%20%20Notation"></a><a class="selflink" href="#section-1.1" name="section-1.1">1.1</a>.  Notation</span>

   In this document, a "Host Validator" can either be a validating stub-
   resolver, such as a library that an application has linked in, or a
   validating resolver daemon running on the same machine.  It may or
   may not be trying to use upstream caching resolvers during its own
   resolution process; both cases are covered by the tests defined in
   this document.

   The sub-variant of this is a "Validating Forwarding Resolver", which
   is a resolver that is configured to use upstream Resolvers when
   possible.  A Validating Forwarding Resolver also needs to perform the
   tests outlined in this document before using an upstream recursive
   resolver.

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in [<a href="rfc2119.html" title='"Key words for use in RFCs to Indicate Requirement Levels"'>RFC2119</a>].

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/1.2.%20%20Background"></a><a class="selflink" href="#section-1.2" name="section-1.2">1.2</a>.  Background</span>

   Deployment of DNSSEC validation is hampered by network components
   that make it difficult or sometimes impossible for validating
   resolvers to effectively obtain the DNSSEC data they need.  This can
   occur for many different reasons including, but not limited to, the
   following:

   o  Recursive resolvers and DNS proxies [<a href="rfc5625.html" title='"DNS Proxy Implementation Guidelines"'>RFC5625</a>] not being fully
      DNSSEC compliant

   o  Resolvers not being DNSSEC aware

   o  "Middleboxes" actively blocking, modifying, and/or restricting
      outbound traffic to the DNS port (53) either UDP and/or TCP

   o  In-path network components not allowing UDP fragments

   This document talks about ways that a Host Validator can detect the
   state of the network it is attached to, and ways to hopefully
   circumvent the problems associated with the network defects it
   discovers.  The tests described in this document may be performed on
   any validating resolver to detect and prevent problems.  While these



<span class="grey">Hardaker, et al.          Best Current Practice                 [Page 3]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-4" id="page-4" name="page-4"> </a>
<span class="grey"><a href="rfc8027.html">RFC 8027</a>               DNSSEC Roadblock Avoidance          November 2016</span>


   recommendations are mainly aimed at Host Validators, it is prudent to
   perform these tests from regular validating resolvers, just to make
   sure things work.

   There are situations where a host cannot talk directly to a Resolver;
   the tests below cannot address how to overcome that, and inconsistent
   results can be seen in such cases.  This can happen, for instance,
   when there are DNS proxies/forwarders between the user and the actual
   resolvers.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/1.3.%20%20Implementation%20Experiences"></a><a class="selflink" href="#section-1.3" name="section-1.3">1.3</a>.  Implementation Experiences</span>

   Multiple lessons learned from multiple implementations led to the
   development of this document, including (in alphabetical order)
   DNSSEC-Tools' DNSSEC-Check, DNSSEC_Resolver_Check, dnssec-trigger,
   and FCC_Grade.

   Detecting lack of support for specified Domain Name System Key
   (DNSKEY) algorithms and Delegation Signer (DS) digest algorithms is
   outside the scope of this document, but the document provides
   information on how to do that.  See the sample test tool:
   &lt;<a href="https://github.com/ogud/DNSSEC_ALG_Check">https://github.com/ogud/DNSSEC_ALG_Check</a>&gt;.

   This document does describe compliance tests for algorithms 5, 7, and
   13 with DS digest algorithms 1 and 2.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/1.3.1.%20%20Test%20Zone%20Implementation"></a><a class="selflink" href="#section-1.3.1" name="section-1.3.1">1.3.1</a>.  Test Zone Implementation</span>

   In this document, the "test.example.com" domain is used to refer to
   DNS records that contain test records that have known DNSSEC
   properties associated with them.  For example, the "badsign-
   a.test.example.com" domain is used below to refer to a DNS A record
   where the signatures published for it are invalid (i.e., they are
   "bad signatures" that should cause a validation failure).

   At the time of this publication, the "test.dnssec-tools.org" domain
   implements all of these test records.  Thus, it may be possible to
   replace "test.example.com" in this document with "test.dnssec-
   tools.org" when performing real-world tests.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/2.%20%20Goals"></a><a class="selflink" href="#section-2" name="section-2">2</a>.  Goals</span>

   This document is intended to show how a Host Validator can detect the
   capabilities of a recursive resolver and work around any problems
   that could potentially affect DNSSEC resolution.  This enables the
   Host Validator to make use of the caching functionality of the
   recursive resolver, which is desirable in that it decreases network
   traffic and improves response times.



<span class="grey">Hardaker, et al.          Best Current Practice                 [Page 4]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-5" id="page-5" name="page-5"> </a>
<span class="grey"><a href="rfc8027.html">RFC 8027</a>               DNSSEC Roadblock Avoidance          November 2016</span>


   A Host Validator has two choices: it can wait to determine that it
   has problems with a recursive resolver based on the results that it
   is getting from real-world queries issued to it or it can proactively
   test for problems (<a href="#section-3">Section 3</a>) to build a workaround list ahead of
   time (<a href="#section-5">Section 5</a>).  There are pros and cons to both of these paths
   that are application specific, and this document does not attempt to
   provide guidance about whether proactive tests should or should not
   be used.  Either way, DNSSEC roadblock avoidance techniques ought to
   be used when needed and if possible.

   Note: Besides being useful for Host Validators, the same tests can be
   used for a recursive resolver to check if its upstream connections
   hinder DNSSEC validation.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/3.%20%20Detecting%20DNSSEC%20Non-compliance"></a><a class="selflink" href="#section-3" name="section-3">3</a>.  Detecting DNSSEC Non-compliance</span>

   This section outlines tests that a validator should perform in order
   to test certain features of the surrounding network.  A resolver
   should perform these tests when first starting but MAY also perform
   these tests when it has detected network changes (e.g., address
   changes, network reattachment, or etc.).

   Note: When performing these tests against an address, we make the
   following assumption about that address: it is a unicast address or
   an anycast [<a href="rfc4786.html" title='"Operation of Anycast Services"'>RFC4786</a>] cluster where all servers have identical
   configuration and connectivity.

   Note: When performing these tests, we also assume that the path is
   clear of "DNS-interfering" middleboxes, like firewalls, proxies, or
   forwarders.  The presence of such infrastructure can easily make a
   recursive resolver appear to be functioning improperly.  It is beyond
   the scope of the document as how to work around such interference,
   although the tests defined in this document may indicate when such
   misbehaving middleware is causing interference.

   Note: This document specifies two sets of tests to perform: a
   comprehensive one and a fast one.  The fast one will detect most
   common problems; thus, if the fast one passes, then the comprehensive
   one MAY be considered passed as well.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.1.%20%20Determining%20DNSSEC%20Support%20in%20Recursive%20Resolvers"></a><a class="selflink" href="#section-3.1" name="section-3.1">3.1</a>.  Determining DNSSEC Support in Recursive Resolvers</span>

   Ideally, a Host Validator can make use of the caching present in
   recursive resolvers.  This section discusses the tests that a
   recursive resolver MUST pass in order to be fully usable as a DNS
   cache.





<span class="grey">Hardaker, et al.          Best Current Practice                 [Page 5]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-6" id="page-6" name="page-6"> </a>
<span class="grey"><a href="rfc8027.html">RFC 8027</a>               DNSSEC Roadblock Avoidance          November 2016</span>


   Unless stated otherwise:

   o  all of the following tests SHOULD have the Recursion Desired (RD)
      flag set when sending out a query and queries SHOULD be sent over
      UDP.

   o  the tests MUST NOT have the DNSSEC OK (DO) bit set or utilize any
      of the other DNSSEC-related requirements, like Extension
      Mechanisms for DNS (EDNS0).

   The tests are designed to check for support of one feature at a time.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/3.1.1.%20%20Supports%20UDP%20Answers"></a><a class="selflink" href="#section-3.1.1" name="section-3.1.1">3.1.1</a>.  Supports UDP Answers</span>

   Purpose: This tests basic DNS-over-UDP functionality to a resolver.

   Test: A DNS request is sent to the resolver under test for an A
   record for a known existing domain, such as good-a.test.example.com.

   SUCCESS: A DNS response was received that contains an A record in the
   answer section.  (The data itself does not need to be checked.)

   Note: An implementation MAY chose not to perform the rest of the
   tests if this test fails, as it is highly unlikely that the resolver
   under test will pass any of the remaining tests.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/3.1.2.%20%20Supports%20TCP%20Answers"></a><a class="selflink" href="#section-3.1.2" name="section-3.1.2">3.1.2</a>.  Supports TCP Answers</span>

   Purpose: This tests basic TCP functionality to a resolver.

   Test: A DNS request is sent over TCP to the resolver under test for
   an A record for a known existing domain, such as good-
   a.test.example.com.

   SUCCESS: A DNS response was received that contains an A record in the
   answer section.  (The data itself does not need to be checked.)

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/3.1.3.%20%20Supports%20EDNS0"></a><a class="selflink" href="#section-3.1.3" name="section-3.1.3">3.1.3</a>.  Supports EDNS0</span>

   Purpose: Test whether a resolver properly supports the EDNS0
   extension option.

   Prerequisite: Supports UDP or TCP.

   Test: Send a request to the resolver under test for an A record for a
   known existing domain, such as good-a.test.example.com, with an EDNS0
   OPT record in the additional section.




<span class="grey">Hardaker, et al.          Best Current Practice                 [Page 6]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-7" id="page-7" name="page-7"> </a>
<span class="grey"><a href="rfc8027.html">RFC 8027</a>               DNSSEC Roadblock Avoidance          November 2016</span>


   SUCCESS: A DNS response was received that contains an EDNS0 option
   with version number 0.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/3.1.4.%20%20Supports%20the%20DO%20Bit"></a><a class="selflink" href="#section-3.1.4" name="section-3.1.4">3.1.4</a>.  Supports the DO Bit</span>

   Purpose: This tests whether a resolver has minimal support of the DO
   bit.

   Prerequisite: Supports EDNS0.

   Test: Send a request to the resolver under test for an A record for a
   known existing domain, such as good-a.test.example.com.  Set the DO
   bit in the outgoing query.

   SUCCESS: A DNS response was received that contains the DO bit set.

   Note: This only tests that the resolver set the DO bit in the
   response.  Later tests will determine if the DO bit was actually made
   use of.  Some resolvers successfully pass this test because they
   simply copy the unknown flags into the response.  These resolvers
   will fail the later tests.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/3.1.5.%20%20Supports%20the%20AD%20Bit%20DNSKEY%20Algorithms%205%20and%2For%208"></a><a class="selflink" href="#section-3.1.5" name="section-3.1.5">3.1.5</a>.  Supports the AD Bit DNSKEY Algorithms 5 and/or 8</span>

   Purpose: This tests whether the resolver is a validating resolver.

   Prerequisite: Supports the DO bit.

   Test: Send requests to the resolver under test for an A record for a
   known existing domain in a DNSSEC-signed zone that is verifiable to a
   configured trust anchor, such as good-a.test.example.com using the
   root's published DNSKEY or DS record as a trust anchor.  Set the DO
   bit in the outgoing query.  This test should be done twice: once for
   a zone that contains algorithm 5 (RSASHA1) and again for algorithm 8
   (RSASHA256).

   SUCCESS: A DNS response was received that contains the Authentic Data
   (AD) bit set for algorithm 5 (RSASHA1).

   BONUS: The AD bit is set for a resolver that supports algorithm 8
   (RSASHA256).

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/3.1.6.%20%20Returns%20RRSIG%20for%20Signed%20Answer"></a><a class="selflink" href="#section-3.1.6" name="section-3.1.6">3.1.6</a>.  Returns RRSIG for Signed Answer</span>

   Purpose: This tests whether a resolver will properly return Resource
   Record Signature (RRSIG) records when the DO bit is set.

   Prerequisite: Supports the DO bit.



<span class="grey">Hardaker, et al.          Best Current Practice                 [Page 7]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-8" id="page-8" name="page-8"> </a>
<span class="grey"><a href="rfc8027.html">RFC 8027</a>               DNSSEC Roadblock Avoidance          November 2016</span>


   Test: Send a request to the resolver under test for an A record for a
   known existing domain in a DNSSEC-signed zone, such as good-
   a.test.example.com.  Set the DO bit in the outgoing query.

   SUCCESS: A DNS response was received that contains at least one RRSIG
   record.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/3.1.7.%20%20Supports%20Querying%20for%20DNSKEY%20Records"></a><a class="selflink" href="#section-3.1.7" name="section-3.1.7">3.1.7</a>.  Supports Querying for DNSKEY Records</span>

   Purpose: This tests whether a resolver can query for and receive a
   DNSKEY record from a signed zone.

   Prerequisite: Supports the DO bit.

   Test: Send a request to the resolver under test for a DNSKEY record
   that is known to exist in a signed zone, such as test.example.com/
   DNSKEY.  Set the DO bit in the outgoing query.

   SUCCESS: A DNS response was received that contains a DNSKEY record in
   the answer section.

   Note: Some DNSKEY Resource Record Sets (RRsets) are large and, if the
   network path has problems with large answers, this query may result
   in either a false positive or a false negative.  In general, the
   DNSKEY queried for should be small enough to fit into a 1220-byte
   answer to avoid a false negative result when TCP is disabled.
   However, querying many zones will result in answers greater than 1220
   bytes, so DNS over TCP MUST be available for DNSSEC use in general.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/3.1.8.%20%20Supports%20Querying%20for%20DS%20Records"></a><a class="selflink" href="#section-3.1.8" name="section-3.1.8">3.1.8</a>.  Supports Querying for DS Records</span>

   Purpose: This tests whether a resolver can query for and receive a DS
   record from a signed zone.

   Prerequisite: Supports the DO bit.

   Test: Send a request to the resolver under test for a DS record that
   is known to exist in a signed zone, such as test.example.com/DS.  Set
   the DO bit in the outgoing query.

   SUCCESS: A DNS response was received that contains a DS record in the
   answer section.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/3.1.9.%20%20Supports%20Negative%20Answers%20with%20NSEC%20Records"></a><a class="selflink" href="#section-3.1.9" name="section-3.1.9">3.1.9</a>.  Supports Negative Answers with NSEC Records</span>

   Purpose: This tests whether a resolver properly returns NextSECure
   (NSEC) records for a nonexisting domain in a DNSSEC-signed zone.




<span class="grey">Hardaker, et al.          Best Current Practice                 [Page 8]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-9" id="page-9" name="page-9"> </a>
<span class="grey"><a href="rfc8027.html">RFC 8027</a>               DNSSEC Roadblock Avoidance          November 2016</span>


   Prerequisite: Supports the DO bit.

   Test: Send a request to the resolver under test for an A record that
   is known to not exist in an NSEC-signed zone, such as
   nonexistent.test.example.com.  Set the DO bit in the outgoing query.

   SUCCESS: A DNS response was received that contains an NSEC record.

   Note: The query issued in this test MUST be sent to an NSEC-signed
   zone.  Getting back appropriate NSEC3 records does not indicate a
   failure, but a bad test.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/3.1.10.%20%20Supports%20Negative%20Answers%20with%20NSEC3%20Records"></a><a class="selflink" href="#section-3.1.10" name="section-3.1.10">3.1.10</a>.  Supports Negative Answers with NSEC3 Records</span>

   Purpose: This tests whether a resolver properly returns NSEC3 records
   ([<a href="rfc5155.html" title='"DNS Security (DNSSEC) Hashed Authenticated Denial of Existence"'>RFC5155</a>]) for a nonexisting domain in a DNSSEC-signed zone.

   Prerequisite: Supports the DO bit.

   Test: Send a request to the resolver under test for an A record that
   is known to be nonexistent in a zone signed using NSEC3, such as
   nonexistent.nsec3-ns.test.example.com.  Set the DO bit in the
   outgoing query.

   SUCCESS: A DNS response was received that contains an NSEC3 record.

   Bonus: If the AD bit is set, this validator supports algorithm 7
   (RSASHA1-NSEC3-SHA1).

   Note: The query issued in this test MUST be sent to an NSEC3-signed
   zone.  Getting back appropriate NSEC records does not indicate a
   failure, but a bad test.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/3.1.11.%20%20Supports%20Queries%20Where%20DNAME%20Records%20Lead%20to%20an%20Answer"></a><a class="selflink" href="#section-3.1.11" name="section-3.1.11">3.1.11</a>.  Supports Queries Where DNAME Records Lead to an Answer</span>

   Purpose: This tests whether a resolver can query for an A record in a
   zone with a known DNAME referral for the record's parent.

   Test: Send a request to the resolver under test for an A record that
   is known to exist in a signed zone within a DNAME-referral child
   zone, such as good-a.dname-good-ns.test.example.com.

   SUCCESS: A DNS response was received that contains a DNAME in the
   answer section.  An RRSIG MUST also be received in the answer section
   that covers the DNAME record.






<span class="grey">Hardaker, et al.          Best Current Practice                 [Page 9]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-10" id="page-10" name="page-10"> </a>
<span class="grey"><a href="rfc8027.html">RFC 8027</a>               DNSSEC Roadblock Avoidance          November 2016</span>


<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/3.1.12.%20%20Permissive%20DNSSEC"></a><a class="selflink" href="#section-3.1.12" name="section-3.1.12">3.1.12</a>.  Permissive DNSSEC</span>

   Purpose: To see if a validating resolver is ignoring DNSSEC
   validation failures.

   Prerequisite: Supports the AD bit.

   Test: Ask for data from a broken DNSSEC delegation, such as badsign-
   a.test.example.com.

   SUCCESS: A reply was received with the Rcode set to SERVFAIL.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/3.1.13.%20%20Supports%20Unknown%20RRtypes"></a><a class="selflink" href="#section-3.1.13" name="section-3.1.13">3.1.13</a>.  Supports Unknown RRtypes</span>

   Purpose: Some DNS Resolvers/gateways only support some Resource
   Record Types (RRtypes).  This causes problems for applications that
   need recently defined types.

   Prerequisite: Supports UDP or TCP.

   Test: Send a request for a recently defined type or an unknown type
   in the 20000-22000 range, that resolves to a server that will return
   an answer for all types, such as alltypes.example.com (a server today
   that supports this is alltypes.res.dnssecready.org).

   SUCCESS: A DNS response was retrieved that contains the type
   requested in the answer section.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.2.%20%20Direct%20Network%20Queries"></a><a class="selflink" href="#section-3.2" name="section-3.2">3.2</a>.  Direct Network Queries</span>

   If needed, a Host Validator may need to make direct queries to
   authoritative servers or known Open Recursive Resolvers in order to
   collect data.  To do that, a number of key network features MUST be
   functional.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/3.2.1.%20%20Support%20for%20Remote%20UDP%20over%20Port%2053"></a><a class="selflink" href="#section-3.2.1" name="section-3.2.1">3.2.1</a>.  Support for Remote UDP over Port 53</span>

   Purpose: This tests basic UDP functionality to outside the local
   network.

   Test: A DNS request is sent to a known distant authoritative server
   for a record known to be within that server's authoritative data.
   Example: send a query to the address of ns1.test.example.com for the
   good-a.test.example.com/A record.

   SUCCESS: A DNS response was received that contains an A record in the
   answer section.




<span class="grey">Hardaker, et al.          Best Current Practice                [Page 10]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-11" id="page-11" name="page-11"> </a>
<span class="grey"><a href="rfc8027.html">RFC 8027</a>               DNSSEC Roadblock Avoidance          November 2016</span>


   Note: An implementation can use the local resolvers for determining
   the address of the name server that is authoritative for the given
   zone.  The recursive bit MAY be set for this request, but it does not
   need to be.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/3.2.2.%20%20Support%20for%20Remote%20UDP%20with%20Fragmentation"></a><a class="selflink" href="#section-3.2.2" name="section-3.2.2">3.2.2</a>.  Support for Remote UDP with Fragmentation</span>

   Purpose: This tests if the local network can receive fragmented UDP
   answers.

   Prerequisite: Local UDP traffic &gt; 1500 bytes in size is possible.

   Test: A DNS request is sent over UDP to a known distant DNS address
   asking for a record that has an answer larger than 2000 bytes.  For
   example, send a query for the test.example.com/DNSKEY record with the
   DO bit set in the outgoing query.

   SUCCESS: A DNS response was received that contains the large answer.

   Note: A failure in getting large answers over UDP is not a serious
   problem if TCP is working.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/3.2.3.%20%20Support%20for%20Outbound%20TCP%20over%20Port%2053"></a><a class="selflink" href="#section-3.2.3" name="section-3.2.3">3.2.3</a>.  Support for Outbound TCP over Port 53</span>

   Purpose: This tests basic TCP functionality to outside the local
   network.

   Test: A DNS request is sent over TCP to a known distant authoritative
   server for a record known to be within that server's authoritative
   data.  Example: send a query to the address of ns1.test.example.com
   for the good-a.test.example.com/A record.

   SUCCESS: A DNS response was received that contains an A record in the
   answer section.

   Note: An implementation can use the local resolvers for determining
   the address of the name server that is authoritative for the given
   zone.  The recursive bit MAY be set for this request, but it does not
   need to be.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.3.%20%20Support%20for%20DNSKEY%20and%20DS%20Combinations"></a><a class="selflink" href="#section-3.3" name="section-3.3">3.3</a>.  Support for DNSKEY and DS Combinations</span>

   Purpose: This test can check what algorithm combinations are
   supported.

   Prerequisite: Supports the AD bit for Algorithms 5 and/or 8.





<span class="grey">Hardaker, et al.          Best Current Practice                [Page 11]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-12" id="page-12" name="page-12"> </a>
<span class="grey"><a href="rfc8027.html">RFC 8027</a>               DNSSEC Roadblock Avoidance          November 2016</span>


   Test: A DNS request is sent over UDP to the resolver under test for a
   known combination of the DS algorithm number (N) and DNSKEY algorithm
   number (M) of the example form ds-N.alg-M-nsec.test.example.com.
   Examples:

            ds-2.alg-13-nsec.test.example.com TXT
                 or
            ds-4.alg-13-nsec3.test.example.com TXT

   SUCCESS: A DNS response is received with the AD bit set and with a
   matching record type in the answer section.

   Note: For algorithms 6 and 7, NSEC is not defined; thus, a query for
   alg-M-nsec3 is required.  Similarly, NSEC3 is not defined for
   algorithms 1, 3, and 5.  Furthermore, algorithms 2, 4, 9, and 11 do
   not currently have definitions for signed zones.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/4.%20%20Aggregating%20the%20Results"></a><a class="selflink" href="#section-4" name="section-4">4</a>.  Aggregating the Results</span>

   Some conclusions can be drawn from the results of the above tests in
   an "aggregated" form.  This section defines some labels to assign to
   a resolver under test given the results of the tests run against
   them.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.1.%20%20Resolver%20Capability%20Description"></a><a class="selflink" href="#section-4.1" name="section-4.1">4.1</a>.  Resolver Capability Description</span>

   This section will group and label certain common results.

   Resolvers are classified into the following broad behaviors:

   Validator:  The resolver passes all DNSSEC tests and had the AD bit
      appropriately set.

   DNSSEC-Aware:  The resolver passes all DNSSEC tests, but it does not
      appropriately set the AD bit on answers, indicating it is not
      validating.  A Host Validator will function fine using this
      resolver as a forwarder.

   Non-DNSSEC-Capable:  The resolver is not DNSSEC-aware and will make
      it hard for a Host Validator to operate behind it.  It MAY be
      usable to query for data that is in known insecure sections of the
      DNS tree.

   Not a DNS Resolver:  This is an improperly behaving resolver and
      should not be used at all.






<span class="grey">Hardaker, et al.          Best Current Practice                [Page 12]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-13" id="page-13" name="page-13"> </a>
<span class="grey"><a href="rfc8027.html">RFC 8027</a>               DNSSEC Roadblock Avoidance          November 2016</span>


   While it would be great if all resolvers fell cleanly into one of the
   broad categories above, that is not the case.  For that reason, it is
   necessary to augment the classification with a more descriptive
   result.  This is done by adding the word "Partial" in front of
   Validator/DNSSEC-aware classifications, followed by sub-descriptors
   of what is not working.

   Unknown:  Failed the unknown test

   DNAME:  Failed the DNAME test

   NSEC3:  Failed the NSEC3 test

   TCP:  TCP not available

   SlowBig:  UDP is size limited, but TCP fallback works

   NoBig:  TCP not available and UDP is size limited

   Permissive:  Passes data known to fail validation

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/5.%20%20Roadblock%20Avoidance"></a><a class="selflink" href="#section-5" name="section-5">5</a>.  Roadblock Avoidance</span>

   The goal of this document is to tie the above tests and aggregations
   to avoidance practices; however, the document does not specify
   exactly how to do that.

   Once we have determined what level of support is available in the
   network, we can determine what must be done in order to effectively
   act as a validating resolver.  This section discusses some of the
   options available given the results from the previous sections.

   The general fallback approach can be described by the following
   sequence:

      If the resolver is labeled as "Validator" or "DNSSEC-aware":

          Send queries through this resolver and perform local
          validation on the results.

          If validation fails, try the next resolver.

      Else, if the resolver is labeled "Not a DNS Resolver" or
      "Non-DNSSEC-capable":

          Mark it as unusable and try the next resolver.





<span class="grey">Hardaker, et al.          Best Current Practice                [Page 13]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-14" id="page-14" name="page-14"> </a>
<span class="grey"><a href="rfc8027.html">RFC 8027</a>               DNSSEC Roadblock Avoidance          November 2016</span>


      Else if no more resolvers are configured and if direct queries
      are supported:

          1. Try iterating from the Root.

          2. If the answer is SECURE/BOGUS:
             Return the result of the iteration.

          3. If the answer is INSECURE:
             Re-query "Non-DNSSEC-capable" servers and return
             answers from them without the AD bit set to the client.

          This will increase the likelihood that split-view unsigned
          answers are found.

      Else:

          Return an error code and log a failure.


   While attempting resolution through a particular recursive name
   server with a particular transport method that worked, any transport-
   specific parameters MUST be remembered in order to avoid any
   unnecessary fallback attempts.

   Transport-specific parameters MUST also be remembered for each
   authoritative name server that is queried while performing an
   iterative mode lookup.

   Any transport settings that are remembered for a particular name
   server MUST be periodically refreshed; they should also be refreshed
   when an error is encountered as described below.

   For a stub resolver, problems with the name server can manifest
   themselves under the following types of error conditions:

   o  No Response, error response, or missing DNSSEC metadata

   o  Illegal Response: An illegal response is received, which prevents
      the validator from fetching all the necessary records required for
      constructing an authentication chain.  This could result when
      referral loops are encountered, when any of the antecedent zone
      delegations are lame, when aliases are erroneously followed for
      certain RRtypes (such as Start of Authority (SOA), DNSKEYs, or DS
      records), or when resource records for certain types (e.g., DS)
      are returned from a zone that is not authoritative for such
      records.




<span class="grey">Hardaker, et al.          Best Current Practice                [Page 14]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-15" id="page-15" name="page-15"> </a>
<span class="grey"><a href="rfc8027.html">RFC 8027</a>               DNSSEC Roadblock Avoidance          November 2016</span>


   o  Bogus Response: A Bogus Response is received, when the
      cryptographic assertions in the authentication chain do not
      validate properly.

   For each of the above error conditions, a validator MAY adopt the
   following dynamic fallback technique, preferring a particular
   approach if it is known to work for a given name server or zone from
   previous attempts.

   o  No response, error response, or missing DNSSEC metadata:

      *  Retry with different EDNS0 sizes (4096, 1492, or None).

      *  Retry with TCP only.

      *  Perform an iterative query starting from the Root if the
         previous error was returned from a lookup that had recursion
         enabled.

      *  Retry using an alternative transport method, if this
         alternative method is known (configured) to be supported by the
         name server in question.

   o  Illegal Response

      *  Perform an iterative query starting from the Root if the
         previous error was returned from a lookup that had recursion
         enabled.

      *  Check if any of the antecedent zones up to the closest
         configured trust anchor are Insecure.

   o  Bogus Response

      *  Perform an iterative query starting from the Root if the
         previous error was returned from a lookup that had recursion
         enabled.

   For each fallback technique, attempts to reach multiple potential
   name servers should be skewed such that the next name server is tried
   when the previous one returns an error or a timeout is reached.

   The validator SHOULD remember, in its zone-specific fallback cache,
   any broken behavior identified for a particular zone for a duration
   of that zone's SOA-negative TTL.






<span class="grey">Hardaker, et al.          Best Current Practice                [Page 15]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-16" id="page-16" name="page-16"> </a>
<span class="grey"><a href="rfc8027.html">RFC 8027</a>               DNSSEC Roadblock Avoidance          November 2016</span>


   The validator MAY place name servers that exhibit broken behavior
   into a blacklist and bypass these name servers for all zones that
   they are authoritative for.  The validator MUST time out entries in
   this name server blacklist periodically, where this interval could be
   set to be the same as the DNSSEC BAD cache default TTL.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.1.%20%20Partial%20Resolver%20Usage"></a><a class="selflink" href="#section-5.1" name="section-5.1">5.1</a>.  Partial Resolver Usage</span>

   It may be possible to use Non-DNSSEC-Capable caching resolvers in
   careful ways if maximum optimization is desired.  This section
   describes some of the advanced techniques that could be implemented
   to use a resolver in at least a minimal way.  Most of the time, this
   would be unnecessary; the exception being the case where none of the
   resolvers are fully compliant and, thus, the choice would be to use
   them at least minimally or not at all (and no caching benefits would
   be available).

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/5.1.1.%20%20Known%20Insecure%20Lookups"></a><a class="selflink" href="#section-5.1.1" name="section-5.1.1">5.1.1</a>.  Known Insecure Lookups</span>

   If a resolver is Non-DNSSEC-Capable but a section of the DNS tree has
   been determined to be Insecure [<a href="rfc4035.html" title='"Protocol Modifications for the DNS Security Extensions"'>RFC4035</a>], then queries to this
   section of the tree MAY be sent through the Non-DNSSEC-Capable
   caching resolver.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/5.1.2.%20%20Partial%20NSEC%2FNSEC3%20Support"></a><a class="selflink" href="#section-5.1.2" name="section-5.1.2">5.1.2</a>.  Partial NSEC/NSEC3 Support</span>

   Resolvers that understand DNSSEC generally, and understand NSEC but
   not NSEC3, are partially usable.  These resolvers generally also lack
   support for unknown types, rendering them mostly useless and to be
   avoided.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/6.%20%20Start-Up%20and%20Network%20Connectivity%20Issues"></a><a class="selflink" href="#section-6" name="section-6">6</a>.  Start-Up and Network Connectivity Issues</span>

   A number of scenarios will produce either short-term or long-term
   connectivity issues with respect to DNSSEC validation.  Consider the
   following cases:

      Time Synchronization: Time synchronization problems can occur when
      a device has been off for a period of time and the clock is no
      longer in close synchronization with "real time" or when a device
      always has the clock set to the same time during start-up.  This
      will cause problems when the device needs to resolve its source of
      time synchronization, such as "ntp.example.com".

      Changing Network Properties: A newly established network
      connection may change state shortly after an HTTP-based paywall
      authentication system has been used.  This is especially common in
      hotel, airport, and coffee-shop networks where DNSSEC, validation,



<span class="grey">Hardaker, et al.          Best Current Practice                [Page 16]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-17" id="page-17" name="page-17"> </a>
<span class="grey"><a href="rfc8027.html">RFC 8027</a>               DNSSEC Roadblock Avoidance          November 2016</span>


      and even DNS are not functional until the user proceeds through a
      series of forced web pages used to enable their network.  The
      tests in <a href="#section-3">Section 3</a> will produce very different results before and
      after the network authorization has succeeded.  APIs exist on many
      operating systems to detect initial network device status changes,
      such as right after DHCP has finished, but few (none?) exist to
      detect that authentication through a paywall has succeeded.

   There are only two choices when situations like this happen:

      Continue to perform DNSSEC processing, which will likely result in
      all DNS requests failing.  This is the most secure route, but
      causes the most operational grief for users.

      Turn off DNSSEC support until the network proves to be usable.
      This allows the user to continue using the network, at the cost of
      security.  It also allows for a denial-of-service attack if a man-
      in-the-middle can convince a device that DNSSEC is impossible.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/6.1.%20%20What%20to%20Do"></a><a class="selflink" href="#section-6.1" name="section-6.1">6.1</a>.  What to Do</span>

   If the Host Validator detects that DNSSEC resolution is not possible,
   it SHOULD log the event and/or SHOULD report an error to the user.
   In the case where there is no user, no reporting can be performed;
   thus, the device MAY have a policy of action, like continue or fail.
   Until middleboxes allow DNSSEC-protected information to traverse them
   consistently, software implementations may need to offer this choice
   to let users pick the security level they require.  Note that
   continuing without DNSSEC protection in the absence of a notification
   or report could lead to situations where users assume a level of
   security that does not exist.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/7.%20%20Quick%20Test"></a><a class="selflink" href="#section-7" name="section-7">7</a>.  Quick Test</span>

   The quick tests defined below make the assumption that the questions
   to be asked are of a real resolver; and the only real question is:
   "How complete is the DNSSEC support?".  This quick test has been
   implemented in a few programs developed at IETF hackathons at IETF 93
   and IETF 94.  The programs use a common grading method.  For each
   question that returns an expected answer, the resolver gets a point.
   If the AD bit is set as expected, the resolver gets a second point.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/7.1.%20%20Test%20Negative%20Answers%20Algorithm%205"></a><a class="selflink" href="#section-7.1" name="section-7.1">7.1</a>.  Test Negative Answers Algorithm 5</span>

   Query: realy-doesnotexist.test.example.com.  A

   Answer: RCODE= NXDOMAIN, Empty Answer, Authority: NSEC-proof




<span class="grey">Hardaker, et al.          Best Current Practice                [Page 17]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-18" id="page-18" name="page-18"> </a>
<span class="grey"><a href="rfc8027.html">RFC 8027</a>               DNSSEC Roadblock Avoidance          November 2016</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/7.2.%20%20Test%20Algorithm%208"></a><a class="selflink" href="#section-7.2" name="section-7.2">7.2</a>.  Test Algorithm 8</span>

   Query: alg-8-nsec3.test.example.com.  SOA

   Answer: RCODE= 0, Answer: SOA record

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/7.3.%20%20Test%20Algorithm%2013"></a><a class="selflink" href="#section-7.3" name="section-7.3">7.3</a>.  Test Algorithm 13</span>

   Query: alg-13-nsec.test.example.com.  SOA

   Answer: RCODE= 0, Answer: SOA record

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/7.4.%20%20Fails%20When%20DNSSEC%20Does%20Not%20Validate"></a><a class="selflink" href="#section-7.4" name="section-7.4">7.4</a>.  Fails When DNSSEC Does Not Validate</span>

   Query: dnssec-failed.test.example.com.  SOA

   Answer: RCODE= SERVFAIL, empty answer, and authority, AD=0

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/8.%20%20Security%20Considerations"></a><a class="selflink" href="#section-8" name="section-8">8</a>.  Security Considerations</span>

   This document discusses problems that may occur while deploying the
   DNSSEC protocol.  It describes what may be possible to help detect
   and mitigate these problems.  Following the outlined suggestions will
   result in a more secure DNSSEC-operational environment than if DNSSEC
   was simply disabled.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/9.%20%20Normative%20References"></a><a class="selflink" href="#section-9" name="section-9">9</a>.  Normative References</span>

   [<a id="ref-RFC2119" name="ref-RFC2119">RFC2119</a>]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", <a href="https://tools.ietf.org/html/bcp14">BCP 14</a>, <a href="rfc2119.html">RFC 2119</a>,
              DOI 10.17487/RFC2119, March 1997,
              &lt;<a href="http://www.rfc-editor.org/info/rfc2119">http://www.rfc-editor.org/info/rfc2119</a>&gt;.

   [<a id="ref-RFC4034" name="ref-RFC4034">RFC4034</a>]  Arends, R., Austein, R., Larson, M., Massey, D., and S.
              Rose, "Resource Records for the DNS Security Extensions",
              <a href="rfc4034.html">RFC 4034</a>, DOI 10.17487/RFC4034, March 2005,
              &lt;<a href="http://www.rfc-editor.org/info/rfc4034">http://www.rfc-editor.org/info/rfc4034</a>&gt;.

   [<a id="ref-RFC4035" name="ref-RFC4035">RFC4035</a>]  Arends, R., Austein, R., Larson, M., Massey, D., and S.
              Rose, "Protocol Modifications for the DNS Security
              Extensions", <a href="rfc4035.html">RFC 4035</a>, DOI 10.17487/RFC4035, March 2005,
              &lt;<a href="http://www.rfc-editor.org/info/rfc4035">http://www.rfc-editor.org/info/rfc4035</a>&gt;.

   [<a id="ref-RFC4786" name="ref-RFC4786">RFC4786</a>]  Abley, J. and K. Lindqvist, "Operation of Anycast
              Services", <a href="https://tools.ietf.org/html/bcp126">BCP 126</a>, <a href="rfc4786.html">RFC 4786</a>, DOI 10.17487/RFC4786,
              December 2006, &lt;<a href="http://www.rfc-editor.org/info/rfc4786">http://www.rfc-editor.org/info/rfc4786</a>&gt;.





<span class="grey">Hardaker, et al.          Best Current Practice                [Page 18]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-19" id="page-19" name="page-19"> </a>
<span class="grey"><a href="rfc8027.html">RFC 8027</a>               DNSSEC Roadblock Avoidance          November 2016</span>


   [<a id="ref-RFC5155" name="ref-RFC5155">RFC5155</a>]  Laurie, B., Sisson, G., Arends, R., and D. Blacka, "DNS
              Security (DNSSEC) Hashed Authenticated Denial of
              Existence", <a href="rfc5155.html">RFC 5155</a>, DOI 10.17487/RFC5155, March 2008,
              &lt;<a href="http://www.rfc-editor.org/info/rfc5155">http://www.rfc-editor.org/info/rfc5155</a>&gt;.

   [<a id="ref-RFC5625" name="ref-RFC5625">RFC5625</a>]  Bellis, R., "DNS Proxy Implementation Guidelines",
              <a href="https://tools.ietf.org/html/bcp152">BCP 152</a>, <a href="rfc5625.html">RFC 5625</a>, DOI 10.17487/RFC5625, August 2009,
              &lt;<a href="http://www.rfc-editor.org/info/rfc5625">http://www.rfc-editor.org/info/rfc5625</a>&gt;.

Acknowledgments

   We thank the IESG and DNSOP working group members for their extensive
   comments and suggestions.

Authors' Addresses

   Wes Hardaker
   USC/ISI
   P.O. Box 382
   Davis, CA  95617
   United States of America

   Email: ietf@hardakers.net


   Olafur Gudmundsson
   CloudFlare
   San Francisco, CA  94107
   United States of America

   Email: olafur+ietf@cloudflare.com


   Suresh Krishnaswamy
   Parsons
   7110 Samuel Morse Dr
   Columbia, MD  21046
   United States of America

   Email: suresh@tislabs.com











Hardaker, et al.          Best Current Practice                [Page 19]

</pre><br/>
    <span class="noprint"><small><small>Html markup produced by rfcmarkup 1.126, available from
      <a href="https://tools.ietf.org/tools/rfcmarkup/">https://tools.ietf.org/tools/rfcmarkup/</a>
    </small></small></span>
  </div>




</body><!-- Mirrored from tools.ietf.org/html/rfc8027 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 06 Mar 2018 23:18:17 GMT --></html>