<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml"><!-- Mirrored from tools.ietf.org/html/rfc4015 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 06 Mar 2018 23:18:43 GMT --><!-- Added by HTTrack --><head><meta content="text/html;charset=utf-8" http-equiv="content-type"/><!-- /Added by HTTrack -->

    <meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
    <meta content="index,follow" name="robots"/>
    <meta content="rfcmarkup version 1.126" name="creator"/>
    <link href="http://purl.org/dc/elements/1.1/" rel="schema.DC"/>
<meta content="draft-ludwig-tsvwg-tcp-eifel-response" name="DC.Relation.Replaces"/>
<meta content="urn:ietf:rfc:4015" name="DC.Identifier"/>
<meta content="February, 2005" name="DC.Date.Issued"/>
<meta content="Gurtov, Andrei" name="DC.Creator"/>
<meta content="Ludwig, Reiner" name="DC.Creator"/>
<meta content="Based on an appropriate detection algorithm, the Eifel response
algorithm provides a way for a TCP sender to respond to a detected
spurious timeout. It adapts the retransmission timer to avoid further
spurious timeouts and (depending on the detection algorithm) can avoid
the often unnecessary go-back-N retransmits that would otherwise be
sent. In addition, the Eifel response algorithm restores the
congestion control state in such a way that packet bursts are avoided.
[STANDARDS-TRACK]" name="DC.Description.Abstract"/>
<meta content="The Eifel Response Algorithm for TCP" name="DC.Title"/>

    <link href="https://tools.ietf.org/images/rfc.png" rel="icon" type="image/png"/>
    <link href="https://tools.ietf.org/images/rfc.png" rel="shortcut icon" type="image/png"/>
    <title>RFC 4015 - The Eifel Response Algorithm for TCP</title>
    
    
    <style type="text/css">
	@media only screen 
	  and (min-width: 992px)
	  and (max-width: 1199px) {
	    body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 768px)
	  and (max-width: 991px) {
            body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 480px)
	  and (max-width: 767px) {
            body { font-size: 11pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (max-width: 479px) {
            body { font-size: 8pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-device-width : 375px) 
	  and (max-device-width : 667px) {
            body { font-size: 9.5pt; }
            div.content { width: 96ex; margin: 0 1px; }
        }
	@media only screen 
	  and (min-device-width: 1200px) {
            body { font-size: 10pt; margin: 0 4em; }
            div.content { width: 96ex; margin: 0; }
        }
        h1, h2, h3, h4, h5, h6, .h1, .h2, .h3, .h4, .h5, .h6 {
	    font-weight: bold;
            line-height: 0pt;
            display: inline;
            white-space: pre;
            font-family: monospace;
            font-size: 1em;
	    font-weight: bold;
        }
        pre {
            font-size: 1em;
            margin-top: 0px;
            margin-bottom: 0px;
        }
	.pre {
	    white-space: pre;
	    font-family: monospace;
	}
	.header{
	    font-weight: bold;
	}
        .newpage {
            page-break-before: always;
        }
        .invisible {
            text-decoration: none;
            color: white;
        }
        a.selflink {
          color: black;
          text-decoration: none;
        }
        @media print {
            body {
                font-family: monospace;
                font-size: 10.5pt;
            }
            h1, h2, h3, h4, h5, h6 {
                font-size: 1em;
            }
        
            a:link, a:visited {
                color: inherit;
                text-decoration: none;
            }
            .noprint {
                display: none;
            }
        }
	@media screen {
	    .grey, .grey a:link, .grey a:visited {
		color: #777;
	    }
            .docinfo {
                background-color: #EEE;
            }
            .top {
                border-top: 7px solid #EEE;
            }
            .bgwhite  { background-color: white; }
            .bgred    { background-color: #F44; }
            .bggrey   { background-color: #666; }
            .bgbrown  { background-color: #840; }            
            .bgorange { background-color: #FA0; }
            .bgyellow { background-color: #EE0; }
            .bgmagenta{ background-color: #F4F; }
            .bgblue   { background-color: #66F; }
            .bgcyan   { background-color: #4DD; }
            .bggreen  { background-color: #4F4; }

            .legend   { font-size: 90%; }
            .cplate   { font-size: 70%; border: solid grey 1px; }
	}
    </style>
    <!--[if IE]>
    <style>
    body {
       font-size: 13px;
       margin: 10px 10px;
    }
    </style>
    <![endif]-->

    <script type="text/javascript"><!--
    function addHeaderTags() {
	var spans = document.getElementsByTagName("span");
	for (var i=0; i < spans.length; i++) {
	    var elem = spans[i];
	    if (elem) {
		var level = elem.getAttribute("class");
                if (level == "h1" || level == "h2" || level == "h3" || level == "h4" || level == "h5" || level == "h6") {
                    elem.innerHTML = "<"+level+">"+elem.innerHTML+"</"+level+">";		
                }
	    }
	}
    }
    var legend_html = "Colour legend:<br />      <table>         <tr><td>Unknown:</td>                   <td><span class='cplate bgwhite'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft:</td>                     <td><span class='cplate bgred'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Informational:</td>             <td><span class='cplate bgorange'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Experimental:</td>              <td><span class='cplate bgyellow'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Best Common Practice:</td>      <td><span class='cplate bgmagenta'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Proposed Standard:</td>         <td><span class='cplate bgblue'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft Standard (old designation):</td> <td><span class='cplate bgcyan'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Internet Standard:</td>         <td><span class='cplate bggreen'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Historic:</td>                  <td><span class='cplate bggrey'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Obsolete:</td>                  <td><span class='cplate bgbrown'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>     </table>";
    function showElem(id) {
        var elem = document.getElementById(id);
        elem.innerHTML = eval(id+"_html");
        elem.style.visibility='visible';
    }
    function hideElem(id) {
        var elem = document.getElementById(id);
        elem.style.visibility='hidden';        
        elem.innerHTML = "";
    }
    // -->
    </script>
</head>
<body onload="addHeaderTags()">
  <div class="content">
   <div style="height: 13px;">
      <div class="pre noprint docinfo bgblue" onclick="showElem('legend');" onmouseout="hideElem('legend')" onmouseover="this.style.cursor='pointer';" style="height: 6px; position: absolute;" title="Click for colour legend.">                                                                        </div>
      <div class="docinfo noprint pre legend" id="legend" onmouseout="hideElem('legend');" onmouseover="showElem('legend');" style="position:absolute; top: 4px; left: 4ex; visibility:hidden; background-color: white; padding: 4px 9px 5px 7px; border: solid #345 1px; ">
      </div>
   </div>
<span class="pre noprint docinfo top">[<a href="index.html" title="Document search and retrieval page">Docs</a>] [<a href="https://tools.ietf.org/rfc/rfc4015.txt" title="Plaintext version of this document">txt</a>|<a href="https://tools.ietf.org/pdf/rfc4015" title="PDF version of this document">pdf</a>] [<a href="https://tools.ietf.org/html/draft-ietf-tsvwg-tcp-eifel-response" title="draft-ietf-tsvwg-tcp-eifel-response">draft-ietf-tsvw...</a>] [<a href="https://datatracker.ietf.org/doc/rfc4015" title="IESG Datatracker information for this document">Tracker</a>] [<a href="https://tools.ietf.org/rfcdiff?difftype=--hwdiff&amp;url2=rfc4015" title="Inline diff (wdiff)">Diff1</a>] [<a href="https://tools.ietf.org/rfcdiff?url2=rfc4015" title="Side-by-side diff">Diff2</a>]         </span><br/>
<span class="pre noprint docinfo">                                                                        </span><br/>
<span class="pre noprint docinfo">                                                       PROPOSED STANDARD</span><br/>
<span class="pre noprint docinfo">                                                                        </span><br/>
<pre>Network Working Group                                          R. Ludwig
Request for Comments: 4015                             Ericsson Research
Category: Standards Track                                      A. Gurtov
                                                                    HIIT
                                                           February 2005


                  <span class="h1">The Eifel Response Algorithm for TCP</span>

Status of This Memo

   This document specifies an Internet standards track protocol for the
   Internet community, and requests discussion and suggestions for
   improvements.  Please refer to the current edition of the "Internet
   Official Protocol Standards" (STD 1) for the standardization state
   and status of this protocol.  Distribution of this memo is unlimited.

Copyright Notice

   Copyright (C) The Internet Society (2005).

Abstract

   Based on an appropriate detection algorithm, the Eifel response
   algorithm provides a way for a TCP sender to respond to a detected
   spurious timeout.  It adapts the retransmission timer to avoid
   further spurious timeouts and (depending on the detection algorithm)
   can avoid the often unnecessary go-back-N retransmits that would
   otherwise be sent.  In addition, the Eifel response algorithm
   restores the congestion control state in such a way that packet
   bursts are avoided.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/1.%20%20Introduction"></a><a class="selflink" href="#section-1" name="section-1">1</a>.  Introduction</span>

   The Eifel response algorithm relies on a detection algorithm such as
   the Eifel detection algorithm, defined in [<a href="rfc3522.html" title='"The Eifel Detection Algorithm for TCP"'>RFC3522</a>].  That document
   contains informative background and motivation context that may be
   useful for implementers of the Eifel response algorithm, but it is
   not necessary to read [<a href="rfc3522.html" title='"The Eifel Detection Algorithm for TCP"'>RFC3522</a>] in order to implement the Eifel
   response algorithm.  Note that alternative response algorithms have
   been proposed [<a href="#ref-BA02" title="E. and M. Allman">BA02</a>] that could also rely on the Eifel detection
   algorithm, and alternative detection algorithms have been proposed
   [<a href="rfc3708.html" title='"Using TCP Duplicate Selective Acknowledgement (DSACKs) and Stream Control Transmission Protocol (SCTP) Duplicate Transmission Sequence Numbers (TSNs) to Detect Spurious Retransmissions"'>RFC3708</a>], [<a href="#ref-SK04" title="P. and M. Kojo">SK04</a>] that could work together with the Eifel response
   algorithm.

   Based on an appropriate detection algorithm, the Eifel response
   algorithm provides a way for a TCP sender to respond to a detected
   spurious timeout.  It adapts the retransmission timer to avoid



<span class="grey">Ludwig &amp; Gurtov             Standards Track                     [Page 1]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-2" id="page-2" name="page-2"> </a>
<span class="grey"><a href="rfc4015.html">RFC 4015</a>          The Eifel Response Algorithm for TCP     February 2005</span>


   further spurious timeouts and (depending on the detection algorithm)
   can avoid the often unnecessary go-back-N retransmits that would
   otherwise be sent.  In addition, the Eifel response algorithm
   restores the congestion control state in such a way that packet
   bursts are avoided.

      Note: A previous version of the Eifel response algorithm also
      included a response to a detected spurious fast retransmit.
      However, as a consensus was not reached about how to adapt the
      duplicate acknowledgement threshold in that case, that part of the
      algorithm was removed for the time being.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/1.1.%20%20Terminology"></a><a class="selflink" href="#section-1.1" name="section-1.1">1.1</a>.  Terminology</span>

   The keywords MUST, MUST NOT, REQUIRED, SHALL, SHALL NOT, SHOULD,
   SHOULD NOT, RECOMMENDED, MAY, and OPTIONAL, when they appear in this
   document, are to be interpreted as described in [<a href="rfc2119.html" title='"Key words for use in RFCs to Indicate Requirement Levels"'>RFC2119</a>].

   We refer to the first-time transmission of an octet as the 'original
   transmit'.  A subsequent transmission of the same octet is referred
   to as a 'retransmit'.  In most cases, this terminology can also be
   applied to data segments.  However, when repacketization occurs, a
   segment can contain both first-time transmissions and retransmissions
   of octets.  In that case, this terminology is only consistent when
   applied to octets.  For the Eifel detection and response algorithms,
   this makes no difference, as they also operate correctly when
   repacketization occurs.

   We use the term 'acceptable ACK' as defined in [<a href="rfc793.html" title='"Transmission Control Protocol"'>RFC793</a>].  That is an
   ACK that acknowledges previously unacknowledged data.  We use the
   term 'bytes_acked' to refer to the amount (in terms of octets) of
   previously unacknowledged data that is acknowledged by the most
   recently received acceptable ACK.  We use the TCP sender state
   variables 'SND.UNA' and 'SND.NXT' as defined in [<a href="rfc793.html" title='"Transmission Control Protocol"'>RFC793</a>].  SND.UNA
   holds the segment sequence number of the oldest outstanding segment.
   SND.NXT holds the segment sequence number of the next segment the TCP
   sender will (re-)transmit.  In addition, we define as 'SND.MAX' the
   segment sequence number of the next original transmit to be sent.
   The definition of SND.MAX is equivalent to the definition of
   'snd_max' in [<a href="#ref-WS95" title="TCP/IP Illustrated">WS95</a>].

   We use the TCP sender state variables 'cwnd' (congestion window), and
   'ssthresh' (slow-start threshold), and the term 'FlightSize' as
   defined in [<a href="rfc2581.html" title='"TCP Congestion Control"'>RFC2581</a>].  FlightSize is the amount (in terms of octets)
   of outstanding data at a given point in time.  We use the term
   'Initial Window' (IW) as defined in [<a href="rfc3390.html" title="&quot;Increasing TCP's Initial Window&quot;">RFC3390</a>].  The IW is the size of
   the sender's congestion window after the three-way handshake is
   completed.  We use the TCP sender state variables 'SRTT' and



<span class="grey">Ludwig &amp; Gurtov             Standards Track                     [Page 2]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-3" id="page-3" name="page-3"> </a>
<span class="grey"><a href="rfc4015.html">RFC 4015</a>          The Eifel Response Algorithm for TCP     February 2005</span>


   'RTTVAR', and the terms 'RTO' and 'G' as defined in [<a href="rfc2988.html" title="&quot;Computing TCP's Retransmission Timer&quot;">RFC2988</a>].  G is
   the clock granularity of the retransmission timer.  In addition, we
   assume that the TCP sender maintains the value of the latest round-
   trip time (RTT) measurement in the (local) variable 'RTT-SAMPLE'.

   We use the TCP sender state variable 'T_last', and the term 'tcpnow'
   as used in [<a href="rfc2861.html" title='"TCP Congestion Window Validation"'>RFC2861</a>].  T_last holds the system time when the TCP
   sender sent the last data segment, whereas tcpnow is the TCP sender's
   current system time.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/2.%20%20Appropriate%20Detection%20Algorithms"></a><a class="selflink" href="#section-2" name="section-2">2</a>.  Appropriate Detection Algorithms</span>

   If the Eifel response algorithm is implemented at the TCP sender, it
   MUST be implemented together with a detection algorithm that is
   specified in a standards track or experimental RFC.

   Designers of detection algorithms who want their algorithms to work
   together with the Eifel response algorithm should reuse the variable
   "SpuriousRecovery" with the semantics and defined values specified in
   [<a href="rfc3522.html" title='"The Eifel Detection Algorithm for TCP"'>RFC3522</a>].  In addition, we define the constant LATE_SPUR_TO (set
   equal to -1) as another possible value of the variable
   SpuriousRecovery.  Detection algorithms should set the value of
   SpuriousRecovery to LATE_SPUR_TO if the detection of a spurious
   retransmit is based on the ACK for the retransmit (as opposed to an
   ACK for an original transmit).  For example, this applies to
   detection algorithms that are based on the DSACK option [<a href="rfc3708.html" title='"Using TCP Duplicate Selective Acknowledgement (DSACKs) and Stream Control Transmission Protocol (SCTP) Duplicate Transmission Sequence Numbers (TSNs) to Detect Spurious Retransmissions"'>RFC3708</a>].

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/3.%20%20The%20Eifel%20Response%20Algorithm"></a><a class="selflink" href="#section-3" name="section-3">3</a>.  The Eifel Response Algorithm</span>

   The complete algorithm is specified in <a href="#section-3.1">section 3.1</a>.  In sections <a href="#section-3.2">3.2</a>
   - 3.6, we discuss the different steps of the algorithm.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.1.%20%20The%20Algorithm"></a><a class="selflink" href="#section-3.1" name="section-3.1">3.1</a>.  The Algorithm</span>

   Given that a TCP sender has enabled a detection algorithm that
   complies with the requirements set in <a href="#section-2">Section 2</a>, a TCP sender MAY use
   the Eifel response algorithm as defined in this subsection.

   If the Eifel response algorithm is used, the following steps MUST be
   taken by the TCP sender, but only upon initiation of a timeout-based
   loss recovery.  That is when the first timeout-based retransmit is
   sent.  The algorithm MUST NOT be reinitiated after a timeout-based
   loss recovery has already been started but not completed.  In
   particular, it may not be reinitiated upon subsequent timeouts for
   the same segment, or upon retransmitting segments other than the
   oldest outstanding segment.





<span class="grey">Ludwig &amp; Gurtov             Standards Track                     [Page 3]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-4" id="page-4" name="page-4"> </a>
<span class="grey"><a href="rfc4015.html">RFC 4015</a>          The Eifel Response Algorithm for TCP     February 2005</span>


   (0)     Before the variables cwnd and ssthresh get updated when
           loss recovery is initiated, set a "pipe_prev" variable as
           follows:
               pipe_prev &lt;- max (FlightSize, ssthresh)

           Set a "SRTT_prev" variable and a "RTTVAR_prev" variable as
           follows:
               SRTT_prev &lt;- SRTT + (2 * G)
               RTTVAR_prev &lt;- RTTVAR

   (DET)   This is a placeholder for a detection algorithm that must
           be executed at this point, and that sets the variable
           SpuriousRecovery as outlined in <a href="#section-2">Section 2</a>.  If
           [<a href="rfc3522.html" title='"The Eifel Detection Algorithm for TCP"'>RFC3522</a>] is used as the detection algorithm, steps (1) -
           (6) of that algorithm go here.

   (7)     If SpuriousRecovery equals SPUR_TO, then
               proceed to step (8);

           else if SpuriousRecovery equals LATE_SPUR_TO, then
               proceed to step (9);

           else
               proceed to step (DONE).

   (8)     Resume the transmission with previously unsent data:

           Set
               SND.NXT &lt;- SND.MAX

   (9)     Reverse the congestion control state:

           If the acceptable ACK has the ECN-Echo flag [<a href="rfc3168.html" title='"The Addition of Explicit Congestion Notification (ECN) to IP"'>RFC3168</a>] set,
           then
               proceed to step (DONE);

           else set
               cwnd &lt;- FlightSize + min (bytes_acked, IW)
               ssthresh &lt;- pipe_prev

           Proceed to step (DONE).

   (10)    Interworking with Congestion Window Validation:

           If congestion window validation is implemented according
           to [<a href="rfc2861.html" title='"TCP Congestion Window Validation"'>RFC2861</a>], then set
               T_last &lt;- tcpnow




<span class="grey">Ludwig &amp; Gurtov             Standards Track                     [Page 4]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-5" id="page-5" name="page-5"> </a>
<span class="grey"><a href="rfc4015.html">RFC 4015</a>          The Eifel Response Algorithm for TCP     February 2005</span>


   (11)    Adapt the conservativeness of the retransmission timer:

           Upon the first RTT-SAMPLE taken from new data; i.e., the
           first RTT-SAMPLE that can be derived from an acceptable
           ACK for data that was previously unsent when the spurious
           timeout occurred,

               if the retransmission timer is implemented according
               to [<a href="rfc2988.html" title="&quot;Computing TCP's Retransmission Timer&quot;">RFC2988</a>], then set
                     SRTT   &lt;- max (SRTT_prev, RTT-SAMPLE)
                     RTTVAR &lt;- max (RTTVAR_prev, RTT-SAMPLE/2)
                     RTO    &lt;- SRTT + max (G, 4*RTTVAR)

                     Run the bounds check on the RTO (rules (2.4) and
                     (2.5) in [<a href="rfc2988.html" title="&quot;Computing TCP's Retransmission Timer&quot;">RFC2988</a>]), and restart the
                     retransmission timer;

               else
                     appropriately adapt the conservativeness of the
                     retransmission timer that is implemented.

   (DONE)  No further processing.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.2.%20%20Storing%20the%20Current%20Congestion%20Control%20State%20%28Step%200%29"></a><a class="selflink" href="#section-3.2" name="section-3.2">3.2</a>.  Storing the Current Congestion Control State (Step 0)</span>

   The TCP sender stores in pipe_prev what is considered a safe slow-
   start threshold (ssthresh) before loss recovery is initiated; i.e.,
   before the loss indication is taken into account.  This is either the
   current FlightSize, if the TCP sender is in congestion avoidance, or
   the current ssthresh, if the TCP sender is in slow-start.  If the TCP
   sender later detects that it has entered loss recovery unnecessarily,
   then pipe_prev is used in step (9) to reverse the congestion control
   state.  Thus, until the loss recovery phase is terminated, pipe_prev
   maintains a memory of the congestion control state of the time right
   before the loss recovery phase was initiated.  A similar approach is
   proposed in [<a href="rfc2861.html" title='"TCP Congestion Window Validation"'>RFC2861</a>], where this state is stored in ssthresh
   directly after a TCP sender has become idle or application limited.

   There had been debates about whether the value of pipe_prev should be
   decayed over time; e.g., upon subsequent timeouts for the same
   outstanding segment.  We do not require decaying pipe_prev for the
   Eifel response algorithm and do not believe that such a conservative
   approach should be in place.  Instead, we follow the idea of
   revalidating the congestion window through slow-start, as suggested
   in [<a href="rfc2861.html" title='"TCP Congestion Window Validation"'>RFC2861</a>].  That is, in step (9), the cwnd is reset to a value
   that avoids large packet bursts, and ssthresh is reset to the value
   of pipe_prev.  Note that [<a href="rfc2581.html" title='"TCP Congestion Control"'>RFC2581</a>] and [<a href="rfc2861.html" title='"TCP Congestion Window Validation"'>RFC2861</a>] also do not require




<span class="grey">Ludwig &amp; Gurtov             Standards Track                     [Page 5]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-6" id="page-6" name="page-6"> </a>
<span class="grey"><a href="rfc4015.html">RFC 4015</a>          The Eifel Response Algorithm for TCP     February 2005</span>


   a decaying of ssthresh after it has been reset in response to a loss
   indication, or after a TCP sender has become idle or application
   limited.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.3.%20%20Suppressing%20the%20Unnecessary%20go-back-N%20Retransmits%20%28Step%208%29"></a><a class="selflink" href="#section-3.3" name="section-3.3">3.3</a>.  Suppressing the Unnecessary go-back-N Retransmits (Step 8)</span>

   Without the use of the TCP timestamps option [<a href="rfc1323.html" title='"TCP Extensions for High Performance"'>RFC1323</a>], the TCP
   sender suffers from the retransmission ambiguity problem [<a href="#ref-Zh86" title="Why TCP Timers Don't Work Well">Zh86</a>],
   [<a href="#ref-KP87" title="P. and C. Partridge">KP87</a>].  Therefore, when the first acceptable ACK arrives after a
   spurious timeout, the TCP sender must assume that this ACK was sent
   in response to the retransmit when in fact it was sent in response to
   an original transmit.  Furthermore, the TCP sender must further
   assume that all other segments that were outstanding at that point
   were lost.

      Note: Except for certain cases where original ACKs were lost, the
      first acceptable ACK cannot carry a DSACK option [<a href="rfc2883.html" title='"An Extension to the Selective Acknowledgement (SACK) Option for TCP"'>RFC2883</a>].

   Consequently, once the TCP sender's state has been updated after the
   first acceptable ACK has arrived, SND.NXT equals SND.UNA.  This is
   what causes the often unnecessary go-back-N retransmits.  From that
   point on every arriving acceptable ACK that was sent in response to
   an original transmit will advance SND.NXT.  But as long as SND.NXT is
   smaller than the value that SND.MAX had when the timeout occurred,
   those ACKs will clock out retransmits, whether or not the
   corresponding original transmits were lost.

   In fact, during this phase the TCP sender breaks 'packet
   conservation' [<a href="#ref-Jac88" title="Congestion Avoidance and Control">Jac88</a>].  This is because the go-back-N retransmits are
   sent during slow-start.  For each original transmit leaving the
   network, two retransmits are sent into the network as long as SND.NXT
   does not equal SND.MAX (see [<a href="#ref-LK00" title="R. and R. H. Katz">LK00</a>] for more detail).

   Once a spurious timeout has been detected (upon receipt of an ACK for
   an original transmit), it is safe to let the TCP sender resume the
   transmission with previously unsent data.  Thus, the Eifel response
   algorithm changes the TCP sender's state by setting SND.NXT to
   SND.MAX.  Note that this step is only executed if the variable
   SpuriousRecovery equals SPUR_TO, which in turn requires a detection
   algorithm such as the Eifel detection algorithm [<a href="rfc3522.html" title='"The Eifel Detection Algorithm for TCP"'>RFC3522</a>] or the F-
   RTO algorithm [<a href="#ref-SK04" title="P. and M. Kojo">SK04</a>] that detects a spurious retransmit based upon
   receiving an ACK for an original transmit (as opposed to the ACK for
   the retransmit [<a href="rfc3708.html" title='"Using TCP Duplicate Selective Acknowledgement (DSACKs) and Stream Control Transmission Protocol (SCTP) Duplicate Transmission Sequence Numbers (TSNs) to Detect Spurious Retransmissions"'>RFC3708</a>]).








<span class="grey">Ludwig &amp; Gurtov             Standards Track                     [Page 6]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-7" id="page-7" name="page-7"> </a>
<span class="grey"><a href="rfc4015.html">RFC 4015</a>          The Eifel Response Algorithm for TCP     February 2005</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.4.%20%20Reversing%20the%20Congestion%20Control%20State%20%28Step%209%29"></a><a class="selflink" href="#section-3.4" name="section-3.4">3.4</a>.  Reversing the Congestion Control State (Step 9)</span>

   When a TCP sender enters loss recovery, it reduces cwnd and ssthresh.
   However, once the TCP sender detects that the loss recovery has been
   falsely triggered, this reduction proves unnecessary.  We therefore
   believe that it is safe to revert to the previous congestion control
   state, following the approach of revalidating the congestion window
   as outlined below.  This is unless the acceptable ACK signals
   congestion through the ECN-Echo flag [<a href="rfc3168.html" title='"The Addition of Explicit Congestion Notification (ECN) to IP"'>RFC3168</a>].  In that case, the
   TCP sender MUST refrain from reversing congestion control state.

   If the ECN-Echo flag is not set, cwnd is reset to the sum of the
   current FlightSize and the minimum of bytes_acked and IW.  In some
   cases, this can mean that the first few acceptable ACKs that arrive
   will not clock out any data segments.  Recall that bytes_acked is the
   number of bytes that have been acknowledged by the acceptable ACK.
   Note that the value of cwnd must not be changed any further for that
   ACK, and that the value of FlightSize at this point in time may be
   different from the value of FlightSize in step (0).  The value of IW
   puts a limit on the size of the packet burst that the TCP sender may
   send into the network after the Eifel response algorithm has
   terminated.  The value of IW is considered an acceptable burst size.
   It is the amount of data that a TCP sender may send into a yet
   "unprobed" network at the beginning of a connection.

   Then ssthresh is reset to the value of pipe_prev.  As a result, the
   TCP sender either immediately resumes probing the network for more
   bandwidth in congestion avoidance, or it slow-starts to what is
   considered a safe operating point for the congestion window.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.5.%20%20Interworking%20with%20the%20CWV%20Algorithm%20%28Step%2010%29"></a><a class="selflink" href="#section-3.5" name="section-3.5">3.5</a>.  Interworking with the CWV Algorithm (Step 10)</span>

   An implementation of the Congestion Window Validation (CWV) algorithm
   [<a href="rfc2861.html" title='"TCP Congestion Window Validation"'>RFC2861</a>] could potentially misinterpret a delay spike that caused a
   spurious timeout as a phase where the TCP sender had been idle.
   Therefore, T_last is reset to prevent the triggering of the CWV
   algorithm in this case.

      Note: The term 'idle' implies that the TCP sender has no data
      outstanding; i.e., all data sent has been acknowledged [<a href="#ref-Jac88" title="Congestion Avoidance and Control">Jac88</a>].
      According to this definition, a TCP sender is not idle while it is
      waiting for an acceptable ACK after a timeout.  Unfortunately, the
      pseudo-code in [<a href="rfc2861.html" title='"TCP Congestion Window Validation"'>RFC2861</a>] does not include a check for the
      condition "idle" (SND.UNA == SND.MAX).  We therefore had to add
      step (10) to the Eifel response algorithm.






<span class="grey">Ludwig &amp; Gurtov             Standards Track                     [Page 7]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-8" id="page-8" name="page-8"> </a>
<span class="grey"><a href="rfc4015.html">RFC 4015</a>          The Eifel Response Algorithm for TCP     February 2005</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.6.%20%20Adapting%20the%20Retransmission%20Timer%20%28Step%2011%29"></a><a class="selflink" href="#section-3.6" name="section-3.6">3.6</a>.  Adapting the Retransmission Timer (Step 11)</span>

   There is currently only one retransmission timer standardized for TCP
   [<a href="rfc2988.html" title="&quot;Computing TCP's Retransmission Timer&quot;">RFC2988</a>].  We therefore only address that timer explicitly.  Future
   standards that might define alternatives to [<a href="rfc2988.html" title="&quot;Computing TCP's Retransmission Timer&quot;">RFC2988</a>] should propose
   similar measures to adapt the conservativeness of the retransmission
   timer.

   A spurious timeout often results from a delay spike, which is a
   sudden increase of the RTT that usually cannot be predicted.  After a
   delay spike, the RTT may have changed permanently; e.g., due to a
   path change, or because the available bandwidth on a bandwidth-
   dominated path has decreased.  This may often occur with wide-area
   wireless access links.  In this case, the RTT estimators (SRTT and
   RTTVAR) should be reinitialized from the first RTT-SAMPLE taken from
   new data according to rule (2.2) of [<a href="rfc2988.html" title="&quot;Computing TCP's Retransmission Timer&quot;">RFC2988</a>].  That is, from the
   first RTT-SAMPLE that can be derived from an acceptable ACK for data
   that was previously unsent when the spurious timeout occurred.

   However, a delay spike may only indicate a transient phase, after
   which the RTT returns to its previous range of values, or even to
   smaller values.  Also, a spurious timeout may occur because the TCP
   sender's RTT estimators were only inaccurate enough that the
   retransmission timer expires "a tad too early".  We believe that two
   times the clock granularity of the retransmission timer (2 * G) is a
   reasonable upper bound on "a tad too early".  Thus, when the new RTO
   is calculated in step (11), we ensure that it is at least (2 * G)
   greater (see also step (0)) than the RTO was before the spurious
   timeout occurred.

   Note that other TCP sender processing will usually take place between
   steps (10) and (11).  During this phase (i.e., before step (11) has
   been reached), the RTO is managed according to the rules of
   [<a href="rfc2988.html" title="&quot;Computing TCP's Retransmission Timer&quot;">RFC2988</a>].  We believe that this is sufficiently conservative for the
   following reasons.  First, the retransmission timer is restarted upon
   the acceptable ACK that was used to detect the spurious timeout.  As
   a result, the delay spike is already implicitly factored in for
   segments outstanding at that time.  This is discussed in more detail
   in [<a href="#ref-EL04" title="H. and R. Ludwig">EL04</a>], where this effect is called the "RTO offset".
   Furthermore, if timestamps are enabled, a new and valid RTT-SAMPLE
   can be derived from that acceptable ACK.  This RTT-SAMPLE must be
   relatively large, as it includes the delay spike that caused the
   spurious timeout.  Consequently, the RTT estimators will be updated
   rather conservatively.  Without timestamps the RTO will stay
   conservatively backed-off due to Karn's algorithm [<a href="rfc2988.html" title="&quot;Computing TCP's Retransmission Timer&quot;">RFC2988</a>] until the
   first RTT-SAMPLE can be derived from an acceptable ACK for data that
   was previously unsent when the spurious timeout occurred.




<span class="grey">Ludwig &amp; Gurtov             Standards Track                     [Page 8]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-9" id="page-9" name="page-9"> </a>
<span class="grey"><a href="rfc4015.html">RFC 4015</a>          The Eifel Response Algorithm for TCP     February 2005</span>


   For the new RTO to become effective, the retransmission timer has to
   be restarted.  This is consistent with [<a href="rfc2988.html" title="&quot;Computing TCP's Retransmission Timer&quot;">RFC2988</a>], which recommends
   restarting the retransmission timer with the arrival of an acceptable
   ACK.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/4.%20%20Advanced%20Loss%20Recovery%20is%20Crucial%20for%20the%20Eifel%20Response%20Algorithm"></a><a class="selflink" href="#section-4" name="section-4">4</a>.  Advanced Loss Recovery is Crucial for the Eifel Response Algorithm</span>

   We have studied environments where spurious timeouts and multiple
   losses from the same flight of packets often coincide [<a href="#ref-GL02" title="A. and R. Ludwig">GL02</a>], [<a href="#ref-GL03" title="A. and R. Ludwig">GL03</a>].
   In such a case, the oldest outstanding segment arrives at the TCP
   receiver, but one or more packets from the remaining outstanding
   flight are lost.  In those environments, end-to-end performance
   suffers if the Eifel response algorithm is operated without an
   advanced loss recovery scheme such as a SACK-based scheme [<a href="rfc3517.html" title='"A Conservative Selective Acknowledgment (SACK)-based Loss Recovery Algorithm for TCP"'>RFC3517</a>]
   or NewReno [<a href="rfc3782.html" title="&quot;The NewReno Modification to TCP's Fast Recovery Algorithm&quot;">RFC3782</a>].  The reason is TCP-Reno's aggressiveness after
   a spurious timeout.  Even though TCP-Reno breaks 'packet
   conservation' (see <a href="#section-3.3">Section 3.3</a>) when blindly retransmitting all
   outstanding segments, it usually recovers all packets lost from that
   flight within a single round-trip time.  On the contrary, the more
   conservative TCP-Reno-with-Eifel is often forced into another
   timeout.  Thus, we recommend that the Eifel response algorithm always
   be operated in combination with [<a href="rfc3517.html" title='"A Conservative Selective Acknowledgment (SACK)-based Loss Recovery Algorithm for TCP"'>RFC3517</a>] or [<a href="rfc3782.html" title="&quot;The NewReno Modification to TCP's Fast Recovery Algorithm&quot;">RFC3782</a>].  Additional
   robustness is achieved with the Limited Transmit and Early Retransmit
   algorithms [<a href="rfc3042.html" title="&quot;Enhancing TCP's Loss Recovery Using Limited Transmit&quot;">RFC3042</a>], [<a href="#ref-AAAB04" title="Work in Progress">AAAB04</a>].

      Note: The SACK-based scheme we used for our simulations in [<a href="#ref-GL02" title="A. and R. Ludwig">GL02</a>]
      and [<a href="#ref-GL03" title="A. and R. Ludwig">GL03</a>] is different from the SACK-based scheme that later got
      standardized [<a href="rfc3517.html" title='"A Conservative Selective Acknowledgment (SACK)-based Loss Recovery Algorithm for TCP"'>RFC3517</a>].  The key difference is that [<a href="rfc3517.html" title='"A Conservative Selective Acknowledgment (SACK)-based Loss Recovery Algorithm for TCP"'>RFC3517</a>] is
      more robust to multiple losses from the same flight.  It is less
      conservative in declaring that a packet has left the network, and
      is therefore less dependent on timeouts to recover genuine packet
      losses.

   If the NewReno algorithm [<a href="rfc3782.html" title="&quot;The NewReno Modification to TCP's Fast Recovery Algorithm&quot;">RFC3782</a>] is used in combination with the
   Eifel response algorithm, step (1) of the NewReno algorithm SHOULD be
   modified as follows, but only if SpuriousRecovery equals SPUR_TO:

      (1)  Three duplicate ACKs:
           When the third duplicate ACK is received and the sender is
           not already in the Fast Recovery procedure, go to step 1A.

   That is, the entire step 1B of the NewReno algorithm is obsolete
   because step (8) of the Eifel response algorithm avoids the case
   where three duplicate ACKs result from unnecessary go-back-N
   retransmits after a timeout.  Step (8) of the Eifel response
   algorithm avoids such unnecessary go-back-N retransmits in the first
   place.  However, recall that step (8) is only executed if the
   variable SpuriousRecovery equals SPUR_TO, which in turn requires a



<span class="grey">Ludwig &amp; Gurtov             Standards Track                     [Page 9]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-10" id="page-10" name="page-10"> </a>
<span class="grey"><a href="rfc4015.html">RFC 4015</a>          The Eifel Response Algorithm for TCP     February 2005</span>


   detection algorithm, such as the Eifel detection algorithm [<a href="rfc3522.html" title='"The Eifel Detection Algorithm for TCP"'>RFC3522</a>]
   or the F-RTO algorithm [<a href="#ref-SK04" title="P. and M. Kojo">SK04</a>], that detects a spurious retransmit
   based upon receiving an ACK for an original transmit (as opposed to
   the ACK for the retransmit [<a href="rfc3708.html" title='"Using TCP Duplicate Selective Acknowledgement (DSACKs) and Stream Control Transmission Protocol (SCTP) Duplicate Transmission Sequence Numbers (TSNs) to Detect Spurious Retransmissions"'>RFC3708</a>]).

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/5.%20%20Security%20Considerations"></a><a class="selflink" href="#section-5" name="section-5">5</a>.  Security Considerations</span>

   There is a risk that a detection algorithm is fooled by spoofed ACKs
   that make genuine retransmits appear to the TCP sender as spurious
   retransmits.  When such a detection algorithm is run together with
   the Eifel response algorithm, this could effectively disable
   congestion control at the TCP sender.  Should this become a concern,
   the Eifel response algorithm SHOULD only be run together with
   detection algorithms that are known to be safe against such "ACK
   spoofing attacks".

   For example, the safe variant of the Eifel detection algorithm
   [<a href="rfc3522.html" title='"The Eifel Detection Algorithm for TCP"'>RFC3522</a>], is a reliable method to protect against this risk.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/6.%20%20Acknowledgements"></a><a class="selflink" href="#section-6" name="section-6">6</a>.  Acknowledgements</span>

   Many thanks to Keith Sklower, Randy Katz, Michael Meyer, Stephan
   Baucke, Sally Floyd, Vern Paxson, Mark Allman, Ethan Blanton, Pasi
   Sarolahti, Alexey Kuznetsov, and Yogesh Swami for many discussions
   that contributed to this work.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/7.%20%20References"></a><a class="selflink" href="#section-7" name="section-7">7</a>.  References</span>

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/7.1.%20%20Normative%20References"></a><a class="selflink" href="#section-7.1" name="section-7.1">7.1</a>.  Normative References</span>

   [<a id="ref-RFC2581" name="ref-RFC2581">RFC2581</a>] Allman, M., Paxson, V., and W. Stevens, "TCP Congestion
             Control", <a href="rfc2581.html">RFC 2581</a>, April 1999.

   [<a id="ref-RFC3390" name="ref-RFC3390">RFC3390</a>] Allman, M., Floyd, S., and C. Partridge, "Increasing TCP's
             Initial Window", <a href="rfc3390.html">RFC 3390</a>, October 2002.

   [<a id="ref-RFC2119" name="ref-RFC2119">RFC2119</a>] Bradner, S., "Key words for use in RFCs to Indicate
             Requirement Levels", <a href="https://tools.ietf.org/html/bcp14">BCP 14</a>, <a href="rfc2119.html">RFC 2119</a>, March 1997.

   [<a id="ref-RFC3782" name="ref-RFC3782">RFC3782</a>] Floyd, S., Henderson, T., and A. Gurtov, "The NewReno
             Modification to TCP's Fast Recovery Algorithm", <a href="rfc3782.html">RFC 3782</a>,
             April 2004.

   [<a id="ref-RFC2861" name="ref-RFC2861">RFC2861</a>] Handley, M., Padhye, J., and S. Floyd, "TCP Congestion
             Window Validation", <a href="rfc2861.html">RFC 2861</a>, June 2000.

   [<a id="ref-RFC3522" name="ref-RFC3522">RFC3522</a>] Ludwig, R. and M. Meyer, "The Eifel Detection Algorithm for
             TCP", <a href="rfc3522.html">RFC 3522</a>, April 2003.



<span class="grey">Ludwig &amp; Gurtov             Standards Track                    [Page 10]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-11" id="page-11" name="page-11"> </a>
<span class="grey"><a href="rfc4015.html">RFC 4015</a>          The Eifel Response Algorithm for TCP     February 2005</span>


   [<a id="ref-RFC2988" name="ref-RFC2988">RFC2988</a>] Paxson, V. and M. Allman, "Computing TCP's Retransmission
             Timer", <a href="rfc2988.html">RFC 2988</a>, November 2000.

   [<a id="ref-RFC793" name="ref-RFC793">RFC793</a>]  Postel, J., "Transmission Control Protocol", STD 7, <a href="rfc793.html">RFC</a>
             <a href="rfc793.html">793</a>, September 1981.

   [<a id="ref-RFC3168" name="ref-RFC3168">RFC3168</a>] Ramakrishnan, K., Floyd, S., and D. Black, "The Addition of
             Explicit Congestion Notification (ECN) to IP", <a href="rfc3168.html">RFC 3168</a>,
             September 2001.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/7.2.%20%20Informative%20References"></a><a class="selflink" href="#section-7.2" name="section-7.2">7.2</a>.  Informative References</span>

   [<a id="ref-RFC3042" name="ref-RFC3042">RFC3042</a>] Allman, M., Balakrishnan, H., and S. Floyd, "Enhancing
             TCP's Loss Recovery Using Limited Transmit", <a href="rfc3042.html">RFC 3042</a>,
             January 2001.

   [<a id="ref-AAAB04" name="ref-AAAB04">AAAB04</a>]  Allman, M., Avrachenkov, K., Ayesta, U., and J. Blanton,
             Early Retransmit for TCP and SCTP, Work in Progress, July
             2004.

   [<a id="ref-BA02" name="ref-BA02">BA02</a>]    Blanton, E. and M. Allman, On Making TCP More Robust to
             Packet Reordering, ACM Computer Communication Review, Vol.
             32, No. 1, January 2002.

   [<a id="ref-RFC3708" name="ref-RFC3708">RFC3708</a>] Blanton, E. and M. Allman, "Using TCP Duplicate Selective
             Acknowledgement (DSACKs) and Stream Control Transmission
             Protocol (SCTP) Duplicate Transmission Sequence Numbers
             (TSNs) to Detect Spurious Retransmissions", <a href="rfc3708.html">RFC 3708</a>,
             February 2004.

   [<a id="ref-RFC3517" name="ref-RFC3517">RFC3517</a>] Blanton, E., Allman, M., Fall, K., and L. Wang, "A
             Conservative Selective Acknowledgment (SACK)-based Loss
             Recovery Algorithm for TCP", <a href="rfc3517.html">RFC 3517</a>, April 2003.

   [<a id="ref-EL04" name="ref-EL04">EL04</a>]    Ekstrom, H. and R. Ludwig, The Peak-Hopper: A New End-to-
             End Retransmission Timer for Reliable Unicast Transport, In
             Proceedings of IEEE INFOCOM 04, March 2004.

   [<a id="ref-RFC2883" name="ref-RFC2883">RFC2883</a>] Floyd, S., Mahdavi, J., Mathis, M., and M. Podolsky, "An
             Extension to the Selective Acknowledgement (SACK) Option
             for TCP", <a href="rfc2883.html">RFC 2883</a>, July 2000.

   [<a id="ref-GL02" name="ref-GL02">GL02</a>]    Gurtov, A. and R. Ludwig, Evaluating the Eifel Algorithm
             for TCP in a GPRS Network, In Proceedings of the European
             Wireless Conference, February 2002.

   [<a id="ref-GL03" name="ref-GL03">GL03</a>]    Gurtov, A. and R. Ludwig, Responding to Spurious Timeouts
             in TCP, In Proceedings of IEEE INFOCOM 03, April 2003.



<span class="grey">Ludwig &amp; Gurtov             Standards Track                    [Page 11]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-12" id="page-12" name="page-12"> </a>
<span class="grey"><a href="rfc4015.html">RFC 4015</a>          The Eifel Response Algorithm for TCP     February 2005</span>


   [<a id="ref-Jac88" name="ref-Jac88">Jac88</a>]   Jacobson, V., Congestion Avoidance and Control, In
             Proceedings of ACM SIGCOMM 88.

   [<a id="ref-RFC1323" name="ref-RFC1323">RFC1323</a>] Jacobson, V., Braden, R., and D. Borman, "TCP Extensions
             for High Performance", <a href="rfc1323.html">RFC 1323</a>, May 1992.

   [<a id="ref-KP87" name="ref-KP87">KP87</a>]    Karn, P. and C. Partridge, Improving Round-Trip Time
             Estimates in Reliable Transport Protocols, In Proceedings
             of ACM SIGCOMM 87.

   [<a id="ref-LK00" name="ref-LK00">LK00</a>]    Ludwig, R. and R. H. Katz, The Eifel Algorithm: Making TCP
             Robust Against Spurious Retransmissions, ACM Computer
             Communication Review, Vol. 30, No. 1, January 2000.

   [<a id="ref-SK04" name="ref-SK04">SK04</a>]    Sarolahti, P. and M. Kojo, F-RTO: An Algorithm for
             Detecting Spurious Retransmission Timeouts with TCP and
             SCTP, Work in Progress, November 2004.

   [<a id="ref-WS95" name="ref-WS95">WS95</a>]    Wright, G. R. and W. R. Stevens, TCP/IP Illustrated, Volume
             2 (The Implementation), Addison Wesley, January 1995.

   [<a id="ref-Zh86" name="ref-Zh86">Zh86</a>]    Zhang, L., Why TCP Timers Don't Work Well, In Proceedings
             of ACM SIGCOMM 88.

Authors' Addresses

   Reiner Ludwig
   Ericsson Research (EDD)
   Ericsson Allee 1
   52134 Herzogenrath, Germany

   EMail: Reiner.Ludwig@ericsson.com


   Andrei Gurtov
   Helsinki Institute for Information Technology (HIIT)
   P.O. Box 9800, FIN-02015
   HUT, Finland

   EMail: andrei.gurtov@cs.helsinki.fi
   Homepage: <a href="http://www.cs.helsinki.fi/u/gurtov">http://www.cs.helsinki.fi/u/gurtov</a>










<span class="grey">Ludwig &amp; Gurtov             Standards Track                    [Page 12]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-13" id="page-13" name="page-13"> </a>
<span class="grey"><a href="rfc4015.html">RFC 4015</a>          The Eifel Response Algorithm for TCP     February 2005</span>


Full Copyright Statement

   Copyright (C) The Internet Society (2005).

   This document is subject to the rights, licenses and restrictions
   contained in <a href="https://tools.ietf.org/html/bcp78">BCP 78</a>, and except as set forth therein, the authors
   retain all their rights.

   This document and the information contained herein are provided on an
   "AS IS" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS
   OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET
   ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED,
   INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE
   INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED
   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.

Intellectual Property

   The IETF takes no position regarding the validity or scope of any
   Intellectual Property Rights or other rights that might be claimed to
   pertain to the implementation or use of the technology described in
   this document or the extent to which any license under such rights
   might or might not be available; nor does it represent that it has
   made any independent effort to identify any such rights.  Information
   on the IETF's procedures with respect to rights in IETF Documents can
   be found in <a href="https://tools.ietf.org/html/bcp78">BCP 78</a> and <a href="https://tools.ietf.org/html/bcp79">BCP 79</a>.

   Copies of IPR disclosures made to the IETF Secretariat and any
   assurances of licenses to be made available, or the result of an
   attempt made to obtain a general license or permission for the use of
   such proprietary rights by implementers or users of this
   specification can be obtained from the IETF on-line IPR repository at
   <a href="http://www.ietf.org/ipr">http://www.ietf.org/ipr</a>.

   The IETF invites any interested party to bring to its attention any
   copyrights, patents or patent applications, or other proprietary
   rights that may cover technology that may be required to implement
   this standard.  Please address the information to the IETF at ietf-
   ipr@ietf.org.


Acknowledgement

   Funding for the RFC Editor function is currently provided by the
   Internet Society.






Ludwig &amp; Gurtov             Standards Track                    [Page 13]

</pre><br/>
    <span class="noprint"><small><small>Html markup produced by rfcmarkup 1.126, available from
      <a href="https://tools.ietf.org/tools/rfcmarkup/">https://tools.ietf.org/tools/rfcmarkup/</a>
    </small></small></span>
  </div>




</body><!-- Mirrored from tools.ietf.org/html/rfc4015 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 06 Mar 2018 23:18:43 GMT --></html>