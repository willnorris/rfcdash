<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml"><!-- Mirrored from tools.ietf.org/html/rfc7748 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 06 Mar 2018 23:18:19 GMT --><!-- Added by HTTrack --><head><meta content="text/html;charset=utf-8" http-equiv="content-type"/><!-- /Added by HTTrack -->

    <meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
    <meta content="index,follow" name="robots"/>
    <meta content="rfcmarkup version 1.126" name="creator"/>
    <link href="http://purl.org/dc/elements/1.1/" rel="schema.DC"/>
<meta content="draft-agl-cfrgcurve" name="DC.Relation.Replaces"/>
<meta content="urn:ietf:rfc:7748" name="DC.Identifier"/>
<meta content="January, 2016" name="DC.Date.Issued"/>
<meta content="Langley, Adam" name="DC.Creator"/>
<meta content="Hamburg, Mike" name="DC.Creator"/>
<meta content="This memo specifies two elliptic curves over prime fields that offer a
high level of practical security in cryptographic applications,
including Transport Layer Security (TLS). These curves are intended to
operate at the ~128-bit and ~224-bit security level, respectively, and
are generated deterministically based on a list of required
properties." name="DC.Description.Abstract"/>
<meta content="Elliptic Curves for Security" name="DC.Title"/>

    <link href="https://tools.ietf.org/images/rfc.png" rel="icon" type="image/png"/>
    <link href="https://tools.ietf.org/images/rfc.png" rel="shortcut icon" type="image/png"/>
    <title>RFC 7748 - Elliptic Curves for Security</title>
    
    
    <style type="text/css">
	@media only screen 
	  and (min-width: 992px)
	  and (max-width: 1199px) {
	    body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 768px)
	  and (max-width: 991px) {
            body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 480px)
	  and (max-width: 767px) {
            body { font-size: 11pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (max-width: 479px) {
            body { font-size: 8pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-device-width : 375px) 
	  and (max-device-width : 667px) {
            body { font-size: 9.5pt; }
            div.content { width: 96ex; margin: 0 1px; }
        }
	@media only screen 
	  and (min-device-width: 1200px) {
            body { font-size: 10pt; margin: 0 4em; }
            div.content { width: 96ex; margin: 0; }
        }
        h1, h2, h3, h4, h5, h6, .h1, .h2, .h3, .h4, .h5, .h6 {
	    font-weight: bold;
            line-height: 0pt;
            display: inline;
            white-space: pre;
            font-family: monospace;
            font-size: 1em;
	    font-weight: bold;
        }
        pre {
            font-size: 1em;
            margin-top: 0px;
            margin-bottom: 0px;
        }
	.pre {
	    white-space: pre;
	    font-family: monospace;
	}
	.header{
	    font-weight: bold;
	}
        .newpage {
            page-break-before: always;
        }
        .invisible {
            text-decoration: none;
            color: white;
        }
        a.selflink {
          color: black;
          text-decoration: none;
        }
        @media print {
            body {
                font-family: monospace;
                font-size: 10.5pt;
            }
            h1, h2, h3, h4, h5, h6 {
                font-size: 1em;
            }
        
            a:link, a:visited {
                color: inherit;
                text-decoration: none;
            }
            .noprint {
                display: none;
            }
        }
	@media screen {
	    .grey, .grey a:link, .grey a:visited {
		color: #777;
	    }
            .docinfo {
                background-color: #EEE;
            }
            .top {
                border-top: 7px solid #EEE;
            }
            .bgwhite  { background-color: white; }
            .bgred    { background-color: #F44; }
            .bggrey   { background-color: #666; }
            .bgbrown  { background-color: #840; }            
            .bgorange { background-color: #FA0; }
            .bgyellow { background-color: #EE0; }
            .bgmagenta{ background-color: #F4F; }
            .bgblue   { background-color: #66F; }
            .bgcyan   { background-color: #4DD; }
            .bggreen  { background-color: #4F4; }

            .legend   { font-size: 90%; }
            .cplate   { font-size: 70%; border: solid grey 1px; }
	}
    </style>
    <!--[if IE]>
    <style>
    body {
       font-size: 13px;
       margin: 10px 10px;
    }
    </style>
    <![endif]-->

    <script type="text/javascript"><!--
    function addHeaderTags() {
	var spans = document.getElementsByTagName("span");
	for (var i=0; i < spans.length; i++) {
	    var elem = spans[i];
	    if (elem) {
		var level = elem.getAttribute("class");
                if (level == "h1" || level == "h2" || level == "h3" || level == "h4" || level == "h5" || level == "h6") {
                    elem.innerHTML = "<"+level+">"+elem.innerHTML+"</"+level+">";		
                }
	    }
	}
    }
    var legend_html = "Colour legend:<br />      <table>         <tr><td>Unknown:</td>                   <td><span class='cplate bgwhite'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft:</td>                     <td><span class='cplate bgred'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Informational:</td>             <td><span class='cplate bgorange'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Experimental:</td>              <td><span class='cplate bgyellow'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Best Common Practice:</td>      <td><span class='cplate bgmagenta'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Proposed Standard:</td>         <td><span class='cplate bgblue'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft Standard (old designation):</td> <td><span class='cplate bgcyan'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Internet Standard:</td>         <td><span class='cplate bggreen'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Historic:</td>                  <td><span class='cplate bggrey'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Obsolete:</td>                  <td><span class='cplate bgbrown'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>     </table>";
    function showElem(id) {
        var elem = document.getElementById(id);
        elem.innerHTML = eval(id+"_html");
        elem.style.visibility='visible';
    }
    function hideElem(id) {
        var elem = document.getElementById(id);
        elem.style.visibility='hidden';        
        elem.innerHTML = "";
    }
    // -->
    </script>
</head>
<body onload="addHeaderTags()">
  <div class="content">
   <div style="height: 13px;">
      <div class="pre noprint docinfo bgorange" onclick="showElem('legend');" onmouseout="hideElem('legend')" onmouseover="this.style.cursor='pointer';" style="height: 6px; position: absolute;" title="Click for colour legend.">                                                                        </div>
      <div class="docinfo noprint pre legend" id="legend" onmouseout="hideElem('legend');" onmouseover="showElem('legend');" style="position:absolute; top: 4px; left: 4ex; visibility:hidden; background-color: white; padding: 4px 9px 5px 7px; border: solid #345 1px; ">
      </div>
   </div>
<span class="pre noprint docinfo top">[<a href="index.html" title="Document search and retrieval page">Docs</a>] [<a href="https://tools.ietf.org/rfc/rfc7748.txt" title="Plaintext version of this document">txt</a>|<a href="https://tools.ietf.org/pdf/rfc7748" title="PDF version of this document">pdf</a>] [<a href="https://tools.ietf.org/html/draft-irtf-cfrg-curves" title="draft-irtf-cfrg-curves">draft-irtf-cfrg...</a>] [<a href="https://datatracker.ietf.org/doc/rfc7748" title="IESG Datatracker information for this document">Tracker</a>] [<a href="https://tools.ietf.org/rfcdiff?difftype=--hwdiff&amp;url2=rfc7748" title="Inline diff (wdiff)">Diff1</a>] [<a href="https://tools.ietf.org/rfcdiff?url2=rfc7748" title="Side-by-side diff">Diff2</a>] [<a href="https://www.rfc-editor.org/errata_search.php?rfc=7748">Errata</a>]</span><br/>
<span class="pre noprint docinfo">                                                                        </span><br/>
<span class="pre noprint docinfo">                                                           INFORMATIONAL</span><br/>
<span class="pre noprint docinfo">                                                            <span style="color: #C00;">Errata Exist</span></span><br/>
<pre>Internet Research Task Force (IRTF)                           A. Langley
Request for Comments: 7748                                        Google
Category: Informational                                       M. Hamburg
ISSN: 2070-1721                             Rambus Cryptography Research
                                                               S. Turner
                                                                   sn3rd
                                                            January 2016


                      <span class="h1">Elliptic Curves for Security</span>

Abstract

   This memo specifies two elliptic curves over prime fields that offer
   a high level of practical security in cryptographic applications,
   including Transport Layer Security (TLS).  These curves are intended
   to operate at the ~128-bit and ~224-bit security level, respectively,
   and are generated deterministically based on a list of required
   properties.

Status of This Memo

   This document is not an Internet Standards Track specification; it is
   published for informational purposes.

   This document is a product of the Internet Research Task Force
   (IRTF).  The IRTF publishes the results of Internet-related research
   and development activities.  These results might not be suitable for
   deployment.  This RFC represents the consensus of the Crypto Forum
   Research Group of the Internet Research Task Force (IRTF).  Documents
   approved for publication by the IRSG are not a candidate for any
   level of Internet Standard; see <a href="rfc5741.html#section-2">SectionÂ 2 of RFC 5741</a>.

   Information about the current status of this document, any errata,
   and how to provide feedback on it may be obtained at
   <a href="http://www.rfc-editor.org/info/rfc7748">http://www.rfc-editor.org/info/rfc7748</a>.

Copyright Notice

   Copyright (c) 2016 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to <a href="https://tools.ietf.org/html/bcp78">BCP 78</a> and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (<a href="http://trustee.ietf.org/license-info">http://trustee.ietf.org/license-info</a>) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.



<span class="grey">Langley, et al.               Informational                     [Page 1]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-2" id="page-2" name="page-2"> </a>
<span class="grey"><a href="rfc7748.html">RFC 7748</a>              Elliptic Curves for Security          January 2016</span>


Table of Contents

   <a href="#section-1">1</a>.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   <a href="#page-2">2</a>
   <a href="#section-2">2</a>.  Requirements Language . . . . . . . . . . . . . . . . . . . .   <a href="#page-3">3</a>
   <a href="#section-3">3</a>.  Notation  . . . . . . . . . . . . . . . . . . . . . . . . . .   <a href="#page-3">3</a>
   <a href="#section-4">4</a>.  Recommended Curves  . . . . . . . . . . . . . . . . . . . . .   <a href="#page-4">4</a>
     <a href="#section-4.1">4.1</a>.  Curve25519  . . . . . . . . . . . . . . . . . . . . . . .   <a href="#page-4">4</a>
     <a href="#section-4.2">4.2</a>.  Curve448  . . . . . . . . . . . . . . . . . . . . . . . .   <a href="#page-5">5</a>
   <a href="#section-5">5</a>.  The X25519 and X448 Functions . . . . . . . . . . . . . . . .   <a href="#page-7">7</a>
     <a href="#section-5.1">5.1</a>.  Side-Channel Considerations . . . . . . . . . . . . . . .  <a href="#page-10">10</a>
     <a href="#section-5.2">5.2</a>.  Test Vectors  . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-11">11</a>
   <a href="#section-6">6</a>.  Diffie-Hellman  . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-14">14</a>
     <a href="#section-6.1">6.1</a>.  Curve25519  . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-14">14</a>
     <a href="#section-6.2">6.2</a>.  Curve448  . . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-15">15</a>
   <a href="#section-7">7</a>.  Security Considerations . . . . . . . . . . . . . . . . . . .  <a href="#page-15">15</a>
   <a href="#section-8">8</a>.  References  . . . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-16">16</a>
     <a href="#section-8.1">8.1</a>.  Normative References  . . . . . . . . . . . . . . . . . .  <a href="#page-16">16</a>
     <a href="#section-8.2">8.2</a>.  Informative References  . . . . . . . . . . . . . . . . .  <a href="#page-17">17</a>
   <a href="#appendix-A">Appendix A</a>.  Deterministic Generation . . . . . . . . . . . . . .  <a href="#page-19">19</a>
     <a href="#appendix-A.1">A.1</a>.  p = 1 mod 4 . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-20">20</a>
     <a href="#appendix-A.2">A.2</a>.  p = 3 mod 4 . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-21">21</a>
     <a href="#appendix-A.3">A.3</a>.  Base Points . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-21">21</a>
   Acknowledgements  . . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-22">22</a>
   Authors' Addresses  . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-22">22</a>

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/1.%20%20Introduction"></a><a class="selflink" href="#section-1" name="section-1">1</a>.  Introduction</span>

   Since the initial standardization of Elliptic Curve Cryptography (ECC
   [<a href="rfc6090.html" title='"Fundamental Elliptic Curve Cryptography Algorithms"'>RFC6090</a>]) in [<a href="#ref-SEC1" title='"SEC 1: Elliptic Curve Cryptography"'>SEC1</a>], there has been significant progress related to
   both efficiency and security of curves and implementations.  Notable
   examples are algorithms protected against certain side-channel
   attacks, various "special" prime shapes that allow faster modular
   arithmetic, and a larger set of curve models from which to choose.
   There is also concern in the community regarding the generation and
   potential weaknesses of the curves defined by NIST [<a href="#ref-NIST" title='"Recommended Elliptic Curves for Federal Government Use"'>NIST</a>].

   This memo specifies two elliptic curves ("curve25519" and "curve448")
   that lend themselves to constant-time implementation and an
   exception-free scalar multiplication that is resistant to a wide
   range of side-channel attacks, including timing and cache attacks.
   They are Montgomery curves (where v^2 = u^3 + A*u^2 + u) and thus
   have birationally equivalent Edwards versions.  Edwards curves
   support the fastest (currently known) complete formulas for the
   elliptic-curve group operations, specifically the Edwards curve
   x^2 + y^2 = 1 + d*x^2*y^2 for primes p when p = 3 mod 4, and the
   twisted Edwards curve -x^2 + y^2 = 1 + d*x^2*y^2 when p = 1 mod 4.
   The maps to/from the Montgomery curves to their (twisted) Edwards
   equivalents are also given.



<span class="grey">Langley, et al.               Informational                     [Page 2]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-3" id="page-3" name="page-3"> </a>
<span class="grey"><a href="rfc7748.html">RFC 7748</a>              Elliptic Curves for Security          January 2016</span>


   This memo also specifies how these curves can be used with the
   Diffie-Hellman protocol for key agreement.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/2.%20%20Requirements%20Language"></a><a class="selflink" href="#section-2" name="section-2">2</a>.  Requirements Language</span>

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in <a href="rfc2119.html">RFC 2119</a> [<a href="rfc2119.html" title='"Key words for use in RFCs to Indicate Requirement Levels"'>RFC2119</a>].

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/3.%20%20Notation"></a><a class="selflink" href="#section-3" name="section-3">3</a>.  Notation</span>

   Throughout this document, the following notation is used:

   p        Denotes the prime number defining the underlying field.

   GF(p)    The finite field with p elements.

   A        An element in the finite field GF(p), not equal to -2 or 2.

   d        A non-zero element in the finite field GF(p), not equal to
            1, in the case of an Edwards curve, or not equal to -1, in
            the case of a twisted Edwards curve.

   order    The order of the prime-order subgroup.

   P        A generator point defined over GF(p) of prime order.

   U(P)     The u-coordinate of the elliptic curve point P on a
            Montgomery curve.

   V(P)     The v-coordinate of the elliptic curve point P on a
            Montgomery curve.

   X(P)     The x-coordinate of the elliptic curve point P on a
            (twisted) Edwards curve.

   Y(P)     The y-coordinate of the elliptic curve point P on a
            (twisted) Edwards curve.

   u, v     Coordinates on a Montgomery curve.

   x, y     Coordinates on a (twisted) Edwards curve.









<span class="grey">Langley, et al.               Informational                     [Page 3]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-4" id="page-4" name="page-4"> </a>
<span class="grey"><a href="rfc7748.html">RFC 7748</a>              Elliptic Curves for Security          January 2016</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/4.%20%20Recommended%20Curves"></a><a class="selflink" href="#section-4" name="section-4">4</a>.  Recommended Curves</span>

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.1.%20%20Curve25519"></a><a class="selflink" href="#section-4.1" name="section-4.1">4.1</a>.  Curve25519</span>

   For the ~128-bit security level, the prime 2^255 - 19 is recommended
   for performance on a wide range of architectures.  Few primes of the
   form 2^c-s with s small exist between 2^250 and 2^521, and other
   choices of coefficient are not as competitive in performance.  This
   prime is congruent to 1 mod 4, and the derivation procedure in
   <a href="#appendix-A">Appendix A</a> results in the following Montgomery curve
   v^2 = u^3 + A*u^2 + u, called "curve25519":

   p  2^255 - 19

   A  486662

   order  2^252 + 0x14def9dea2f79cd65812631a5cf5d3ed

   cofactor  8

   U(P)  9

   V(P)  147816194475895447910205935684099868872646061346164752889648818
      37755586237401

   The base point is u = 9, v = 1478161944758954479102059356840998688726
   4606134616475288964881837755586237401.

   This curve is birationally equivalent to a twisted Edwards curve -x^2
   + y^2 = 1 + d*x^2*y^2, called "edwards25519", where:

   p  2^255 - 19

   d  370957059346694393431380835087545651895421138798432190163887855330
      85940283555

   order  2^252 + 0x14def9dea2f79cd65812631a5cf5d3ed

   cofactor  8

   X(P)  151122213495354007725011514095885315114540126930418572060461132
      83949847762202

   Y(P)  463168356949264781694283940034751631413079938662562256157830336
      03165251855960






<span class="grey">Langley, et al.               Informational                     [Page 4]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-5" id="page-5" name="page-5"> </a>
<span class="grey"><a href="rfc7748.html">RFC 7748</a>              Elliptic Curves for Security          January 2016</span>


   The birational maps are:

     (u, v) = ((1+y)/(1-y), sqrt(-486664)*u/x)
     (x, y) = (sqrt(-486664)*u/v, (u-1)/(u+1))

   The Montgomery curve defined here is equal to the one defined in
   [<a href="#ref-curve25519">curve25519</a>], and the equivalent twisted Edwards curve is equal to
   the one defined in [<a href="#ref-ed25519" title='"High-Speed High-Security Signatures"'>ed25519</a>].

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/4.2.%20%20Curve448"></a><a class="selflink" href="#section-4.2" name="section-4.2">4.2</a>.  Curve448</span>

   For the ~224-bit security level, the prime 2^448 - 2^224 - 1 is
   recommended for performance on a wide range of architectures.  This
   prime is congruent to 3 mod 4, and the derivation procedure in
   <a href="#appendix-A">Appendix A</a> results in the following Montgomery curve, called
   "curve448":

   p  2^448 - 2^224 - 1

   A  156326

   order  2^446 -
      0x8335dc163bb124b65129c96fde933d8d723a70aadc873d6d54a7bb0d

   cofactor  4

   U(P)  5

   V(P)  355293926785568175264127502063783334808976399387714271831880898
      435169088786967410002932673765864550910142774147268105838985595290
      606362

   This curve is birationally equivalent to the Edwards curve x^2 + y^2
   = 1 + d*x^2*y^2 where:

   p  2^448 - 2^224 - 1

   d  611975850744529176160423220965553317543219696871016626328968936415
      087860042636474891785599283666020414768678979989378147065462815545
      017

   order  2^446 -
      0x8335dc163bb124b65129c96fde933d8d723a70aadc873d6d54a7bb0d

   cofactor  4






<span class="grey">Langley, et al.               Informational                     [Page 5]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-6" id="page-6" name="page-6"> </a>
<span class="grey"><a href="rfc7748.html">RFC 7748</a>              Elliptic Curves for Security          January 2016</span>


   X(P)  345397493039729516374008604150537410266655260075183290216406970
      281645695073672344430481787759340633221708391583424041788924124567
      700732

   Y(P)  363419362147803445274661903944002267176820680343659030140745099
      590306164083365386343198191849338272965044442230921818680526749009
      182718

   The birational maps are:

     (u, v) = ((y-1)/(y+1), sqrt(156324)*u/x)
     (x, y) = (sqrt(156324)*u/v, (1+u)/(1-u))

   Both of those curves are also 4-isogenous to the following Edwards
   curve x^2 + y^2 = 1 + d*x^2*y^2, called "edwards448", where:

   p  2^448 - 2^224 - 1

   d  -39081

   order  2^446 -
      0x8335dc163bb124b65129c96fde933d8d723a70aadc873d6d54a7bb0d

   cofactor  4

   X(P)  224580040295924300187604334099896036246789641632564134246125461
      686950415467406032909029192869357953282578032075146446173674602635
      247710

   Y(P)  298819210078481492676017930443930673437544040154080242095928241
      372331506189835876003536878655418784733982303233503462500531545062
      832660

   The 4-isogeny maps between the Montgomery curve and this Edwards
   curve are:

     (u, v) = (y^2/x^2, (2 - x^2 - y^2)*y/x^3)
     (x, y) = (4*v*(u^2 - 1)/(u^4 - 2*u^2 + 4*v^2 + 1),
               -(u^5 - 2*u^3 - 4*u*v^2 + u)/
               (u^5 - 2*u^2*v^2 - 2*u^3 - 2*v^2 + u))

   The curve edwards448 defined here is also called "Goldilocks" and is
   equal to the one defined in [<a href="#ref-goldilocks">goldilocks</a>].








<span class="grey">Langley, et al.               Informational                     [Page 6]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-7" id="page-7" name="page-7"> </a>
<span class="grey"><a href="rfc7748.html">RFC 7748</a>              Elliptic Curves for Security          January 2016</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/5.%20%20The%20X25519%20and%20X448%20Functions"></a><a class="selflink" href="#section-5" name="section-5">5</a>.  The X25519 and X448 Functions</span>

   The "X25519" and "X448" functions perform scalar multiplication on
   the Montgomery form of the above curves.  (This is used when
   implementing Diffie-Hellman.)  The functions take a scalar and a
   u-coordinate as inputs and produce a u-coordinate as output.
   Although the functions work internally with integers, the inputs and
   outputs are 32-byte strings (for X25519) or 56-byte strings (for
   X448) and this specification defines their encoding.

   The u-coordinates are elements of the underlying field GF(2^255 - 19)
   or GF(2^448 - 2^224 - 1) and are encoded as an array of bytes, u, in
   little-endian order such that u[0] + 256*u[1] + 256^2*u[2] + ... +
   256^(n-1)*u[n-1] is congruent to the value modulo p and u[n-1] is
   minimal.  When receiving such an array, implementations of X25519
   (but not X448) MUST mask the most significant bit in the final byte.
   This is done to preserve compatibility with point formats that
   reserve the sign bit for use in other protocols and to increase
   resistance to implementation fingerprinting.

   Implementations MUST accept non-canonical values and process them as
   if they had been reduced modulo the field prime.  The non-canonical
   values are 2^255 - 19 through 2^255 - 1 for X25519 and 2^448 - 2^224
   - 1 through 2^448 - 1 for X448.

   The following functions implement this in Python, although the Python
   code is not intended to be performant nor side-channel free.  Here,
   the "bits" parameter should be set to 255 for X25519 and 448 for
   X448:

   &lt;CODE BEGINS&gt;
   def decodeLittleEndian(b, bits):
       return sum([b[i] &lt;&lt; 8*i for i in range((bits+7)/8)])

   def decodeUCoordinate(u, bits):
       u_list = [ord(b) for b in u]
       # Ignore any unused bits.
       if bits % 8:
           u_list[-1] &amp;= (1&lt;&lt;(bits%8))-1
       return decodeLittleEndian(u_list, bits)

   def encodeUCoordinate(u, bits):
       u = u % p
       return ''.join([chr((u &gt;&gt; 8*i) &amp; 0xff)
                       for i in range((bits+7)/8)])
   &lt;CODE ENDS&gt;





<span class="grey">Langley, et al.               Informational                     [Page 7]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-8" id="page-8" name="page-8"> </a>
<span class="grey"><a href="rfc7748.html">RFC 7748</a>              Elliptic Curves for Security          January 2016</span>


   Scalars are assumed to be randomly generated bytes.  For X25519, in
   order to decode 32 random bytes as an integer scalar, set the three
   least significant bits of the first byte and the most significant bit
   of the last to zero, set the second most significant bit of the last
   byte to 1 and, finally, decode as little-endian.  This means that the
   resulting integer is of the form 2^254 plus eight times a value
   between 0 and 2^251 - 1 (inclusive).  Likewise, for X448, set the two
   least significant bits of the first byte to 0, and the most
   significant bit of the last byte to 1.  This means that the resulting
   integer is of the form 2^447 plus four times a value between 0 and
   2^445 - 1 (inclusive).

   &lt;CODE BEGINS&gt;
   def decodeScalar25519(k):
       k_list = [ord(b) for b in k]
       k_list[0] &amp;= 248
       k_list[31] &amp;= 127
       k_list[31] |= 64
       return decodeLittleEndian(k_list, 255)

   def decodeScalar448(k):
       k_list = [ord(b) for b in k]
       k_list[0] &amp;= 252
       k_list[55] |= 128
       return decodeLittleEndian(k_list, 448)
   &lt;CODE ENDS&gt;

   To implement the X25519(k, u) and X448(k, u) functions (where k is
   the scalar and u is the u-coordinate), first decode k and u and then
   perform the following procedure, which is taken from [<a href="#ref-curve25519">curve25519</a>] and
   based on formulas from [<a href="#ref-montgomery">montgomery</a>].  All calculations are performed
   in GF(p), i.e., they are performed modulo p.  The constant a24 is
   (486662 - 2) / 4 = 121665 for curve25519/X25519 and (156326 - 2) / 4
   = 39081 for curve448/X448.

















<span class="grey">Langley, et al.               Informational                     [Page 8]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-9" id="page-9" name="page-9"> </a>
<span class="grey"><a href="rfc7748.html">RFC 7748</a>              Elliptic Curves for Security          January 2016</span>


   x_1 = u
   x_2 = 1
   z_2 = 0
   x_3 = u
   z_3 = 1
   swap = 0

   For t = bits-1 down to 0:
       k_t = (k &gt;&gt; t) &amp; 1
       swap ^= k_t
       // Conditional swap; see text below.
       (x_2, x_3) = cswap(swap, x_2, x_3)
       (z_2, z_3) = cswap(swap, z_2, z_3)
       swap = k_t

       A = x_2 + z_2
       AA = A^2
       B = x_2 - z_2
       BB = B^2
       E = AA - BB
       C = x_3 + z_3
       D = x_3 - z_3
       DA = D * A
       CB = C * B
       x_3 = (DA + CB)^2
       z_3 = x_1 * (DA - CB)^2
       x_2 = AA * BB
       z_2 = E * (AA + a24 * E)

   // Conditional swap; see text below.
   (x_2, x_3) = cswap(swap, x_2, x_3)
   (z_2, z_3) = cswap(swap, z_2, z_3)
   Return x_2 * (z_2^(p - 2))

   (Note that these formulas are slightly different from Montgomery's
   original paper.  Implementations are free to use any correct
   formulas.)

   Finally, encode the resulting value as 32 or 56 bytes in little-
   endian order.  For X25519, the unused, most significant bit MUST be
   zero.










<span class="grey">Langley, et al.               Informational                     [Page 9]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-10" id="page-10" name="page-10"> </a>
<span class="grey"><a href="rfc7748.html">RFC 7748</a>              Elliptic Curves for Security          January 2016</span>


   The cswap function SHOULD be implemented in constant time (i.e.,
   independent of the swap argument).  For example, this can be done as
   follows:

   cswap(swap, x_2, x_3):
         dummy = mask(swap) AND (x_2 XOR x_3)
         x_2 = x_2 XOR dummy
         x_3 = x_3 XOR dummy
         Return (x_2, x_3)

   Where mask(swap) is the all-1 or all-0 word of the same length as x_2
   and x_3, computed, e.g., as mask(swap) = 0 - swap.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.1.%20%20Side-Channel%20Considerations"></a><a class="selflink" href="#section-5.1" name="section-5.1">5.1</a>.  Side-Channel Considerations</span>

   X25519 and X448 are designed so that fast, constant-time
   implementations are easier to produce.  The procedure above ensures
   that the same sequence of field operations is performed for all
   values of the secret key, thus eliminating a common source of side-
   channel leakage.  However, this alone does not prevent all side-
   channels by itself.  It is important that the pattern of memory
   accesses and jumps not depend on the values of any of the bits of k.
   It is also important that the arithmetic used not leak information
   about the integers modulo p, for example by having b*c be
   distinguishable from c*c.  On some architectures, even primitive
   machine instructions, such as single-word division, can have variable
   timing based on their inputs.

   Side-channel attacks are an active research area that still sees
   significant, new results.  Implementors are advised to follow this
   research closely.




















<span class="grey">Langley, et al.               Informational                    [Page 10]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-11" id="page-11" name="page-11"> </a>
<span class="grey"><a href="rfc7748.html">RFC 7748</a>              Elliptic Curves for Security          January 2016</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/5.2.%20%20Test%20Vectors"></a><a class="selflink" href="#section-5.2" name="section-5.2">5.2</a>.  Test Vectors</span>

   Two types of tests are provided.  The first is a pair of test vectors
   for each function that consist of expected outputs for the given
   inputs.  The inputs are generally given as 64 or 112 hexadecimal
   digits that need to be decoded as 32 or 56 binary bytes before
   processing.

   X25519:

   Input scalar:
     a546e36bf0527c9d3b16154b82465edd62144c0ac1fc5a18506a2244ba449ac4
   Input scalar as a number (base 10):
     31029842492115040904895560451863089656
     472772604678260265531221036453811406496
   Input u-coordinate:
     e6db6867583030db3594c1a424b15f7c726624ec26b3353b10a903a6d0ab1c4c
   Input u-coordinate as a number (base 10):
     34426434033919594451155107781188821651
     316167215306631574996226621102155684838
   Output u-coordinate:
     c3da55379de9c6908e94ea4df28d084f32eccf03491c71f754b4075577a28552

   Input scalar:
     4b66e9d4d1b4673c5ad22691957d6af5c11b6421e0ea01d42ca4169e7918ba0d
   Input scalar as a number (base 10):
     35156891815674817266734212754503633747
     128614016119564763269015315466259359304
   Input u-coordinate:
     e5210f12786811d3f4b7959d0538ae2c31dbe7106fc03c3efc4cd549c715a493
   Input u-coordinate as a number (base 10):
     88838573511839298940907593866106493194
     17338800022198945255395922347792736741
   Output u-coordinate:
     95cbde9476e8907d7aade45cb4b873f88b595a68799fa152e6f8f7647aac7957
















<span class="grey">Langley, et al.               Informational                    [Page 11]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-12" id="page-12" name="page-12"> </a>
<span class="grey"><a href="rfc7748.html">RFC 7748</a>              Elliptic Curves for Security          January 2016</span>


   X448:

   Input scalar:
     3d262fddf9ec8e88495266fea19a34d28882acef045104d0d1aae121
     700a779c984c24f8cdd78fbff44943eba368f54b29259a4f1c600ad3
   Input scalar as a number (base 10):
     599189175373896402783756016145213256157230856
     085026129926891459468622403380588640249457727
     683869421921443004045221642549886377526240828
   Input u-coordinate:
     06fce640fa3487bfda5f6cf2d5263f8aad88334cbd07437f020f08f9
     814dc031ddbdc38c19c6da2583fa5429db94ada18aa7a7fb4ef8a086
   Input u-coordinate as a number (base 10):
     382239910814107330116229961234899377031416365
     240571325148346555922438025162094455820962429
     142971339584360034337310079791515452463053830
   Output u-coordinate:
     ce3e4ff95a60dc6697da1db1d85e6afbdf79b50a2412d7546d5f239f
     e14fbaadeb445fc66a01b0779d98223961111e21766282f73dd96b6f

   Input scalar:
     203d494428b8399352665ddca42f9de8fef600908e0d461cb021f8c5
     38345dd77c3e4806e25f46d3315c44e0a5b4371282dd2c8d5be3095f
   Input scalar as a number (base 10):
     633254335906970592779259481534862372382525155
     252028961056404001332122152890562527156973881
     968934311400345568203929409663925541994577184
   Input u-coordinate:
     0fbcc2f993cd56d3305b0b7d9e55d4c1a8fb5dbb52f8e9a1e9b6201b
     165d015894e56c4d3570bee52fe205e28a78b91cdfbde71ce8d157db
   Input u-coordinate as a number (base 10):
     622761797758325444462922068431234180649590390
     024811299761625153767228042600197997696167956
     134770744996690267634159427999832340166786063
   Output u-coordinate:
     884a02576239ff7a2f2f63b2db6a9ff37047ac13568e1e30fe63c4a7
     ad1b3ee3a5700df34321d62077e63633c575c1c954514e99da7c179d














<span class="grey">Langley, et al.               Informational                    [Page 12]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-13" id="page-13" name="page-13"> </a>
<span class="grey"><a href="rfc7748.html">RFC 7748</a>              Elliptic Curves for Security          January 2016</span>


   The second type of test vector consists of the result of calling the
   function in question a specified number of times.  Initially, set k
   and u to be the following values:

   For X25519:
     0900000000000000000000000000000000000000000000000000000000000000
   For X448:
     05000000000000000000000000000000000000000000000000000000
     00000000000000000000000000000000000000000000000000000000

   For each iteration, set k to be the result of calling the function
   and u to be the old value of k.  The final result is the value left
   in k.

   X25519:

   After one iteration:
       422c8e7a6227d7bca1350b3e2bb7279f7897b87bb6854b783c60e80311ae3079
   After 1,000 iterations:
       684cf59ba83309552800ef566f2f4d3c1c3887c49360e3875f2eb94d99532c51
   After 1,000,000 iterations:
       7c3911e0ab2586fd864497297e575e6f3bc601c0883c30df5f4dd2d24f665424


   X448:

   After one iteration:
       3f482c8a9f19b01e6c46ee9711d9dc14fd4bf67af30765c2ae2b846a
       4d23a8cd0db897086239492caf350b51f833868b9bc2b3bca9cf4113
   After 1,000 iterations:
       aa3b4749d55b9daf1e5b00288826c467274ce3ebbdd5c17b975e09d4
       af6c67cf10d087202db88286e2b79fceea3ec353ef54faa26e219f38
   After 1,000,000 iterations:
       077f453681caca3693198420bbe515cae0002472519b3e67661a7e89
       cab94695c8f4bcd66e61b9b9c946da8d524de3d69bd9d9d66b997e37
















<span class="grey">Langley, et al.               Informational                    [Page 13]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-14" id="page-14" name="page-14"> </a>
<span class="grey"><a href="rfc7748.html">RFC 7748</a>              Elliptic Curves for Security          January 2016</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/6.%20%20Diffie-Hellman"></a><a class="selflink" href="#section-6" name="section-6">6</a>.  Diffie-Hellman</span>

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/6.1.%20%20Curve25519"></a><a class="selflink" href="#section-6.1" name="section-6.1">6.1</a>.  Curve25519</span>

   The X25519 function can be used in an Elliptic Curve Diffie-Hellman
   (ECDH) protocol as follows:

   Alice generates 32 random bytes in a[0] to a[31] and transmits K_A =
   X25519(a, 9) to Bob, where 9 is the u-coordinate of the base point
   and is encoded as a byte with value 9, followed by 31 zero bytes.

   Bob similarly generates 32 random bytes in b[0] to b[31], computes
   K_B = X25519(b, 9), and transmits it to Alice.

   Using their generated values and the received input, Alice computes
   X25519(a, K_B) and Bob computes X25519(b, K_A).

   Both now share K = X25519(a, X25519(b, 9)) = X25519(b, X25519(a, 9))
   as a shared secret.  Both MAY check, without leaking extra
   information about the value of K, whether K is the all-zero value and
   abort if so (see below).  Alice and Bob can then use a key-derivation
   function that includes K, K_A, and K_B to derive a symmetric key.

   The check for the all-zero value results from the fact that the
   X25519 function produces that value if it operates on an input
   corresponding to a point with small order, where the order divides
   the cofactor of the curve (see <a href="#section-7">Section 7</a>).  The check may be
   performed by ORing all the bytes together and checking whether the
   result is zero, as this eliminates standard side-channels in software
   implementations.

   Test vector:

   Alice's private key, a:
     77076d0a7318a57d3c16c17251b26645df4c2f87ebc0992ab177fba51db92c2a
   Alice's public key, X25519(a, 9):
     8520f0098930a754748b7ddcb43ef75a0dbf3a0d26381af4eba4a98eaa9b4e6a
   Bob's private key, b:
     5dab087e624a8a4b79e17f8b83800ee66f3bb1292618b6fd1c2f8b27ff88e0eb
   Bob's public key, X25519(b, 9):
     de9edb7d7b7dc1b4d35b61c2ece435373f8343c85b78674dadfc7e146f882b4f
   Their shared secret, K:
     4a5d9d5ba4ce2de1728e3bf480350f25e07e21c947d19e3376f09b3c1e161742








<span class="grey">Langley, et al.               Informational                    [Page 14]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-15" id="page-15" name="page-15"> </a>
<span class="grey"><a href="rfc7748.html">RFC 7748</a>              Elliptic Curves for Security          January 2016</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/6.2.%20%20Curve448"></a><a class="selflink" href="#section-6.2" name="section-6.2">6.2</a>.  Curve448</span>

   The X448 function can be used in an ECDH protocol very much like the
   X25519 function.

   If X448 is to be used, the only differences are that Alice and Bob
   generate 56 random bytes (not 32) and calculate K_A = X448(a, 5) or
   K_B = X448(b, 5), where 5 is the u-coordinate of the base point and
   is encoded as a byte with value 5, followed by 55 zero bytes.

   As with X25519, both sides MAY check, without leaking extra
   information about the value of K, whether the resulting shared K is
   the all-zero value and abort if so.

   Test vector:

   Alice's private key, a:
     9a8f4925d1519f5775cf46b04b5800d4ee9ee8bae8bc5565d498c28d
     d9c9baf574a9419744897391006382a6f127ab1d9ac2d8c0a598726b
   Alice's public key, X448(a, 5):
     9b08f7cc31b7e3e67d22d5aea121074a273bd2b83de09c63faa73d2c
     22c5d9bbc836647241d953d40c5b12da88120d53177f80e532c41fa0
   Bob's private key, b:
     1c306a7ac2a0e2e0990b294470cba339e6453772b075811d8fad0d1d
     6927c120bb5ee8972b0d3e21374c9c921b09d1b0366f10b65173992d
   Bob's public key, X448(b, 5):
     3eb7a829b0cd20f5bcfc0b599b6feccf6da4627107bdb0d4f345b430
     27d8b972fc3e34fb4232a13ca706dcb57aec3dae07bdc1c67bf33609
   Their shared secret, K:
     07fff4181ac6cc95ec1c16a94a0f74d12da232ce40a77552281d282b
     b60c0b56fd2464c335543936521c24403085d59a449a5037514a879d

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/7.%20%20Security%20Considerations"></a><a class="selflink" href="#section-7" name="section-7">7</a>.  Security Considerations</span>

   The security level (i.e., the number of "operations" needed for a
   brute-force attack on a primitive) of curve25519 is slightly under
   the standard 128-bit level.  This is acceptable because the standard
   security levels are primarily driven by much simpler, symmetric
   primitives where the security level naturally falls on a power of
   two.  For asymmetric primitives, rigidly adhering to a power-of-two
   security level would require compromises in other parts of the
   design, which we reject.  Additionally, comparing security levels
   between types of primitives can be misleading under common threat
   models where multiple targets can be attacked concurrently
   [<a href="#ref-bruteforce">bruteforce</a>].






<span class="grey">Langley, et al.               Informational                    [Page 15]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-16" id="page-16" name="page-16"> </a>
<span class="grey"><a href="rfc7748.html">RFC 7748</a>              Elliptic Curves for Security          January 2016</span>


   The ~224-bit security level of curve448 is a trade-off between
   performance and paranoia.  Large quantum computers, if ever created,
   will break both curve25519 and curve448, and reasonable projections
   of the abilities of classical computers conclude that curve25519 is
   perfectly safe.  However, some designs have relaxed performance
   requirements and wish to hedge against some amount of analytical
   advance against elliptic curves and thus curve448 is also provided.

   Protocol designers using Diffie-Hellman over the curves defined in
   this document must not assume "contributory behaviour".  Specially,
   contributory behaviour means that both parties' private keys
   contribute to the resulting shared key.  Since curve25519 and
   curve448 have cofactors of 8 and 4 (respectively), an input point of
   small order will eliminate any contribution from the other party's
   private key.  This situation can be detected by checking for the all-
   zero output, which implementations MAY do, as specified in <a href="#section-6">Section 6</a>.
   However, a large number of existing implementations do not do this.

   Designers using these curves should be aware that for each public
   key, there are several publicly computable public keys that are
   equivalent to it, i.e., they produce the same shared secrets.  Thus
   using a public key as an identifier and knowledge of a shared secret
   as proof of ownership (without including the public keys in the key
   derivation) might lead to subtle vulnerabilities.

   Designers should also be aware that implementations of these curves
   might not use the Montgomery ladder as specified in this document,
   but could use generic, elliptic-curve libraries instead.  These
   implementations could reject points on the twist and could reject
   non-minimal field elements.  While not recommended, such
   implementations will interoperate with the Montgomery ladder
   specified here but may be trivially distinguishable from it.  For
   example, sending a non-canonical value or a point on the twist may
   cause such implementations to produce an observable error while an
   implementation that follows the design in this text would
   successfully produce a shared key.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/8.%20%20References"></a><a class="selflink" href="#section-8" name="section-8">8</a>.  References</span>

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/8.1.%20%20Normative%20References"></a><a class="selflink" href="#section-8.1" name="section-8.1">8.1</a>.  Normative References</span>

   [<a id="ref-RFC2119" name="ref-RFC2119">RFC2119</a>]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", <a href="https://tools.ietf.org/html/bcp14">BCP 14</a>, <a href="rfc2119.html">RFC 2119</a>,
              DOI 10.17487/RFC2119, March 1997,
              &lt;<a href="http://www.rfc-editor.org/info/rfc2119">http://www.rfc-editor.org/info/rfc2119</a>&gt;.






<span class="grey">Langley, et al.               Informational                    [Page 16]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-17" id="page-17" name="page-17"> </a>
<span class="grey"><a href="rfc7748.html">RFC 7748</a>              Elliptic Curves for Security          January 2016</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/8.2.%20%20Informative%20References"></a><a class="selflink" href="#section-8.2" name="section-8.2">8.2</a>.  Informative References</span>

   [<a id="ref-brainpool" name="ref-brainpool">brainpool</a>]
              ECC Brainpool, "ECC Brainpool Standard Curves and Curve
              Generation", October 2005,
              &lt;<a href="http://www.ecc-brainpool.org/download/Domain-parameters.pdf">http://www.ecc-brainpool.org/download/</a>
              <a href="http://www.ecc-brainpool.org/download/Domain-parameters.pdf">Domain-parameters.pdf</a>&gt;.

   [<a id="ref-bruteforce" name="ref-bruteforce">bruteforce</a>]
              Bernstein, D., "Understanding brute force", April 2005,
              &lt;<a href="http://cr.yp.to/snuffle/bruteforce-20050425.pdf">http://cr.yp.to/snuffle/bruteforce-20050425.pdf</a>&gt;.

   [<a id="ref-curve25519" name="ref-curve25519">curve25519</a>]
              Bernstein, D., "Curve25519: new Diffie-Hellman speed
              records", 2006,
              &lt;<a href="http://www.iacr.org/cryptodb/archive/2006/PKC/3351/3351.pdf">http://www.iacr.org/cryptodb/archive/2006/</a>
              <a href="http://www.iacr.org/cryptodb/archive/2006/PKC/3351/3351.pdf">PKC/3351/3351.pdf</a>&gt;.

   [<a id="ref-ed25519" name="ref-ed25519">ed25519</a>]  Bernstein, D., Duif, N., Lange, T., Schwabe, P., and B.
              Yang, "High-Speed High-Security Signatures", 2011,
              &lt;<a href="http://link.springer.com/chapter/10.1007/978-3-642-23951-9_9">http://link.springer.com/</a>
              <a href="http://link.springer.com/chapter/10.1007/978-3-642-23951-9_9">chapter/10.1007/978-3-642-23951-9_9</a>&gt;.

   [<a id="ref-goldilocks" name="ref-goldilocks">goldilocks</a>]
              Hamburg, M., "Ed448-Goldilocks, a new elliptic curve",
              2015, &lt;<a href="http://eprint.iacr.org/2015/625.pdf">http://eprint.iacr.org/2015/625.pdf</a>&gt;.

   [<a id="ref-montgomery" name="ref-montgomery">montgomery</a>]
              Montgomery, P., "Speeding the Pollard and Elliptic Curve
              Methods of Factorization", January 1987,
              &lt;<a href="http://www.ams.org/journals/mcom/1987-48-177/S0025-5718-1987-0866113-7/S0025-5718-1987-0866113-7.pdf">http://www.ams.org/journals/mcom/1987-48-177/</a>
              <a href="http://www.ams.org/journals/mcom/1987-48-177/S0025-5718-1987-0866113-7/S0025-5718-1987-0866113-7.pdf">S0025-5718-1987-0866113-7/S0025-5718-1987-0866113-7.pdf</a>&gt;.

   [<a id="ref-NIST" name="ref-NIST">NIST</a>]     National Institute of Standards, "Recommended Elliptic
              Curves for Federal Government Use", July 1999,
              &lt;<a href="http://csrc.nist.gov/groups/ST/toolkit/documents/dss/NISTReCur.pdf">http://csrc.nist.gov/groups/ST/toolkit/documents/dss/</a>
              <a href="http://csrc.nist.gov/groups/ST/toolkit/documents/dss/NISTReCur.pdf">NISTReCur.pdf</a>&gt;.

   [<a id="ref-reducing" name="ref-reducing">reducing</a>] Menezes, A., Okamoto, T., and S. Vanstone, "Reducing
              elliptic curve logarithms to logarithms in a finite
              field", DOI 10.1109/18.259647, 1993,
              &lt;<a href="http://ieeexplore.ieee.org/xpl/articleDetails.jsp?arnumber=259647">http://ieeexplore.ieee.org/xpl/</a>
              <a href="http://ieeexplore.ieee.org/xpl/articleDetails.jsp?arnumber=259647">articleDetails.jsp?arnumber=259647</a>&gt;.

   [<a id="ref-RFC6090" name="ref-RFC6090">RFC6090</a>]  McGrew, D., Igoe, K., and M. Salter, "Fundamental Elliptic
              Curve Cryptography Algorithms", <a href="rfc6090.html">RFC 6090</a>,
              DOI 10.17487/RFC6090, February 2011,
              &lt;<a href="http://www.rfc-editor.org/info/rfc6090">http://www.rfc-editor.org/info/rfc6090</a>&gt;.



<span class="grey">Langley, et al.               Informational                    [Page 17]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-18" id="page-18" name="page-18"> </a>
<span class="grey"><a href="rfc7748.html">RFC 7748</a>              Elliptic Curves for Security          January 2016</span>


   [<a id="ref-safecurves" name="ref-safecurves">safecurves</a>]
              Bernstein, D. and T. Lange, "SafeCurves: choosing safe
              curves for elliptic-curve cryptography", Oct 2013,
              &lt;<a href="http://safecurves.cr.yp.to/">http://safecurves.cr.yp.to/</a>&gt;.

   [<a id="ref-satoh" name="ref-satoh">satoh</a>]    Satoh, T. and K. Araki, "Fermat quotients and the
              polynomial time discrete log algorithm for anomalous
              elliptic curves", 1998.

   [<a id="ref-SEC1" name="ref-SEC1">SEC1</a>]     Certicom Research, "SEC 1: Elliptic Curve Cryptography",
              September 2000, &lt;<a href="http://www.secg.org/sec1-v2.pdf">http://www.secg.org/sec1-v2.pdf</a>&gt;.

   [<a id="ref-semaev" name="ref-semaev">semaev</a>]   Semaev, I., "Evaluation of discrete logarithms on some
              elliptic curves", 1998, &lt;<a href="http://www.ams.org/journals/mcom/1998-67-221/S0025-5718-98-00887-4/S0025-5718-98-00887-4.pdf">http://www.ams.org/journals/</a>
              <a href="http://www.ams.org/journals/mcom/1998-67-221/S0025-5718-98-00887-4/S0025-5718-98-00887-4.pdf">mcom/1998-67-221/S0025-5718-98-00887-4/</a>
              <a href="http://www.ams.org/journals/mcom/1998-67-221/S0025-5718-98-00887-4/S0025-5718-98-00887-4.pdf">S0025-5718-98-00887-4.pdf</a>&gt;.

   [<a id="ref-smart" name="ref-smart">smart</a>]    Smart, N., "The Discrete Logarithm Problem on Elliptic
              Curves of Trace One", 1999,
              &lt;<a href="http://www.hpl.hp.com/techreports/97/HPL-97-128.pdf">http://www.hpl.hp.com/techreports/97/HPL-97-128.pdf</a>&gt;.































<span class="grey">Langley, et al.               Informational                    [Page 18]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-19" id="page-19" name="page-19"> </a>
<span class="grey"><a href="rfc7748.html">RFC 7748</a>              Elliptic Curves for Security          January 2016</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/Appendix%20A.%20%20Deterministic%20Generation"></a><a class="selflink" href="#appendix-A" name="appendix-A">Appendix A</a>.  Deterministic Generation</span>

   This section specifies the procedure that was used to generate the
   above curves; specifically, it defines how to generate the parameter
   A of the Montgomery curve y^2 = x^3 + A*x^2 + x.  This procedure is
   intended to be as objective as can reasonably be achieved so that
   it's clear that no untoward considerations influenced the choice of
   curve.  The input to this process is p, the prime that defines the
   underlying field.  The size of p determines the amount of work needed
   to compute a discrete logarithm in the elliptic curve group, and
   choosing a precise p depends on many implementation concerns.  The
   performance of the curve will be dominated by operations in GF(p), so
   carefully choosing a value that allows for easy reductions on the
   intended architecture is critical.  This document does not attempt to
   articulate all these considerations.

   The value (A-2)/4 is used in several of the elliptic curve point
   arithmetic formulas.  For simplicity and performance reasons, it is
   beneficial to make this constant small, i.e., to choose A so that
   (A-2) is a small integer that is divisible by four.

   For each curve at a specific security level:

   1.  The trace of Frobenius MUST NOT be in {0, 1} in order to rule out
       the attacks described in [<a href="#ref-smart" title='"The Discrete Logarithm Problem on Elliptic Curves of Trace One"'>smart</a>], [<a href="#ref-satoh" title='"Fermat quotients and the polynomial time discrete log algorithm for anomalous elliptic curves"'>satoh</a>], and [<a href="#ref-semaev" title='"Evaluation of discrete logarithms on some elliptic curves"'>semaev</a>], as in
       [<a href="#ref-brainpool">brainpool</a>] and [<a href="#ref-safecurves">safecurves</a>].

   2.  MOV Degree [<a href="#ref-reducing" title='"Reducing elliptic curve logarithms to logarithms in a finite field"'>reducing</a>]: the embedding degree MUST be greater than
       (order - 1) / 100, as in [<a href="#ref-brainpool">brainpool</a>] and [<a href="#ref-safecurves">safecurves</a>].

   3.  CM Discriminant: discriminant D MUST be greater than 2^100, as in
       [<a href="#ref-safecurves">safecurves</a>].



















<span class="grey">Langley, et al.               Informational                    [Page 19]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-20" id="page-20" name="page-20"> </a>
<span class="grey"><a href="rfc7748.html">RFC 7748</a>              Elliptic Curves for Security          January 2016</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/A.1.%20%20p%20%3D%201%20mod%204"></a><a class="selflink" href="#appendix-A.1" name="appendix-A.1">A.1</a>.  p = 1 mod 4</span>

   For primes congruent to 1 mod 4, the minimal cofactors of the curve
   and its twist are either {4, 8} or {8, 4}.  We choose a curve with
   the latter cofactors so that any algorithms that take the cofactor
   into account don't have to worry about checking for points on the
   twist, because the twist cofactor will be the smaller of the two.

   To generate the Montgomery curve, we find the minimal, positive A
   value such that A &gt; 2 and (A-2) is divisible by four and where the
   cofactors are as desired.  The find1Mod4 function in the following
   Sage script returns this value given p:

   &lt;CODE BEGINS&gt;
   def findCurve(prime, curveCofactor, twistCofactor):
       F = GF(prime)

       for A in xrange(3, int(1e9)):
           if (A-2) % 4 != 0:
             continue

           try:
             E = EllipticCurve(F, [0, A, 0, 1, 0])
           except:
             continue

           groupOrder = E.order()
           twistOrder = 2*(prime+1)-groupOrder

           if (groupOrder % curveCofactor == 0 and
               is_prime(groupOrder // curveCofactor) and
               twistOrder % twistCofactor == 0 and
               is_prime(twistOrder // twistCofactor)):
               return A

   def find1Mod4(prime):
       assert((prime % 4) == 1)
       return findCurve(prime, 8, 4)
   &lt;CODE ENDS&gt;

                   Generating a curve where p = 1 mod 4










<span class="grey">Langley, et al.               Informational                    [Page 20]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-21" id="page-21" name="page-21"> </a>
<span class="grey"><a href="rfc7748.html">RFC 7748</a>              Elliptic Curves for Security          January 2016</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/A.2.%20%20p%20%3D%203%20mod%204"></a><a class="selflink" href="#appendix-A.2" name="appendix-A.2">A.2</a>.  p = 3 mod 4</span>

   For a prime congruent to 3 mod 4, both the curve and twist cofactors
   can be 4, and this is minimal.  Thus, we choose the curve with these
   cofactors and minimal, positive A such that A &gt; 2 and (A-2) is
   divisible by four.  The find3Mod4 function in the following Sage
   script returns this value given p:

   &lt;CODE BEGINS&gt;
   def find3Mod4(prime):
       assert((prime % 4) == 3)
       return findCurve(prime, 4, 4)
   &lt;CODE ENDS&gt;

                   Generating a curve where p = 3 mod 4

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/A.3.%20%20Base%20Points"></a><a class="selflink" href="#appendix-A.3" name="appendix-A.3">A.3</a>.  Base Points</span>

   The base point for a curve is the point with minimal, positive u
   value that is in the correct subgroup.  The findBasepoint function in
   the following Sage script returns this value given p and A:

   &lt;CODE BEGINS&gt;
   def findBasepoint(prime, A):
       F = GF(prime)
       E = EllipticCurve(F, [0, A, 0, 1, 0])

       for uInt in range(1, 1e3):
         u = F(uInt)
         v2 = u^3 + A*u^2 + u
         if not v2.is_square():
           continue
         v = v2.sqrt()

         point = E(u, v)
         pointOrder = point.order()
         if pointOrder &gt; 8 and pointOrder.is_prime():
           return point
   &lt;CODE ENDS&gt;

                         Generating the base point










<span class="grey">Langley, et al.               Informational                    [Page 21]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-22" id="page-22" name="page-22"> </a>
<span class="grey"><a href="rfc7748.html">RFC 7748</a>              Elliptic Curves for Security          January 2016</span>


Acknowledgements

   This document is the result of a combination of <a href="https://tools.ietf.org/html/draft-black-rpgecc-01">draft-black-rpgecc-01</a>
   and <a href="https://tools.ietf.org/html/draft-turner-thecurve25519function-01">draft-turner-thecurve25519function-01</a>.  The following authors of
   those documents wrote much of the text and figures but are not listed
   as authors on this document: Benjamin Black, Joppe W. Bos, Craig
   Costello, Patrick Longa, Michael Naehrig, Watson Ladd, and Rich Salz.

   The authors would also like to thank Tanja Lange, Rene Struik, Rich
   Salz, Ilari Liusvaara, Deirdre Connolly, Simon Josefsson, Stephen
   Farrell, Georg Nestmann, Trevor Perrin, and John Mattsson for their
   reviews and contributions.

   The X25519 function was developed by Daniel J. Bernstein in
   [<a href="#ref-curve25519">curve25519</a>].

Authors' Addresses

   Adam Langley
   Google
   345 Spear Street
   San Francisco, CA  94105
   United States

   Email: agl@google.com


   Mike Hamburg
   Rambus Cryptography Research
   425 Market Street, 11th Floor
   San Francisco, CA  94105
   United States

   Email: mike@shiftleft.org


   Sean Turner
   sn3rd

   Email: sean@sn3rd.com











Langley, et al.               Informational                    [Page 22]

</pre><br/>
    <span class="noprint"><small><small>Html markup produced by rfcmarkup 1.126, available from
      <a href="https://tools.ietf.org/tools/rfcmarkup/">https://tools.ietf.org/tools/rfcmarkup/</a>
    </small></small></span>
  </div>




</body><!-- Mirrored from tools.ietf.org/html/rfc7748 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 06 Mar 2018 23:18:19 GMT --></html>