<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml"><!-- Mirrored from tools.ietf.org/html/rfc8132 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 06 Mar 2018 23:18:17 GMT --><!-- Added by HTTrack --><head><meta content="text/html;charset=utf-8" http-equiv="content-type"/><!-- /Added by HTTrack -->

    <meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
    <meta content="index,follow" name="robots"/>
    <meta content="rfcmarkup version 1.126" name="creator"/>
    <link href="http://purl.org/dc/elements/1.1/" rel="schema.DC"/>
<meta content="draft-vanderstok-core-etch" name="DC.Relation.Replaces"/>
<meta content="urn:ietf:rfc:8132" name="DC.Identifier"/>
<meta content="April, 2017" name="DC.Date.Issued"/>
<meta content="Stok, Peter Van der" name="DC.Creator"/>
<meta content="Sehgal, Anuj" name="DC.Creator"/>
<meta content="Bormann, Carsten" name="DC.Creator"/>
<meta content="The methods defined in RFC 7252 for the Constrained Application
Protocol (CoAP) only allow access to a complete resource, not to parts
of a resource. In case of resources with larger or complex data, or in
situations where resource continuity is required, replacing or
requesting the whole resource is undesirable. Several applications
using CoAP need to access parts of the resources.  This specification
defines the new CoAP methods, FETCH, PATCH, and iPATCH, which are used
to access and update parts of a resource." name="DC.Description.Abstract"/>
<meta content="PATCH and FETCH Methods for the Constrained Application Protocol (CoAP)" name="DC.Title"/>

    <link href="https://tools.ietf.org/images/rfc.png" rel="icon" type="image/png"/>
    <link href="https://tools.ietf.org/images/rfc.png" rel="shortcut icon" type="image/png"/>
    <title>RFC 8132 - PATCH and FETCH Methods for the Constrained Application Protocol (CoAP)</title>
    
    
    <style type="text/css">
	@media only screen 
	  and (min-width: 992px)
	  and (max-width: 1199px) {
	    body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 768px)
	  and (max-width: 991px) {
            body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 480px)
	  and (max-width: 767px) {
            body { font-size: 11pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (max-width: 479px) {
            body { font-size: 8pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-device-width : 375px) 
	  and (max-device-width : 667px) {
            body { font-size: 9.5pt; }
            div.content { width: 96ex; margin: 0 1px; }
        }
	@media only screen 
	  and (min-device-width: 1200px) {
            body { font-size: 10pt; margin: 0 4em; }
            div.content { width: 96ex; margin: 0; }
        }
        h1, h2, h3, h4, h5, h6, .h1, .h2, .h3, .h4, .h5, .h6 {
	    font-weight: bold;
            line-height: 0pt;
            display: inline;
            white-space: pre;
            font-family: monospace;
            font-size: 1em;
	    font-weight: bold;
        }
        pre {
            font-size: 1em;
            margin-top: 0px;
            margin-bottom: 0px;
        }
	.pre {
	    white-space: pre;
	    font-family: monospace;
	}
	.header{
	    font-weight: bold;
	}
        .newpage {
            page-break-before: always;
        }
        .invisible {
            text-decoration: none;
            color: white;
        }
        a.selflink {
          color: black;
          text-decoration: none;
        }
        @media print {
            body {
                font-family: monospace;
                font-size: 10.5pt;
            }
            h1, h2, h3, h4, h5, h6 {
                font-size: 1em;
            }
        
            a:link, a:visited {
                color: inherit;
                text-decoration: none;
            }
            .noprint {
                display: none;
            }
        }
	@media screen {
	    .grey, .grey a:link, .grey a:visited {
		color: #777;
	    }
            .docinfo {
                background-color: #EEE;
            }
            .top {
                border-top: 7px solid #EEE;
            }
            .bgwhite  { background-color: white; }
            .bgred    { background-color: #F44; }
            .bggrey   { background-color: #666; }
            .bgbrown  { background-color: #840; }            
            .bgorange { background-color: #FA0; }
            .bgyellow { background-color: #EE0; }
            .bgmagenta{ background-color: #F4F; }
            .bgblue   { background-color: #66F; }
            .bgcyan   { background-color: #4DD; }
            .bggreen  { background-color: #4F4; }

            .legend   { font-size: 90%; }
            .cplate   { font-size: 70%; border: solid grey 1px; }
	}
    </style>
    <!--[if IE]>
    <style>
    body {
       font-size: 13px;
       margin: 10px 10px;
    }
    </style>
    <![endif]-->

    <script type="text/javascript"><!--
    function addHeaderTags() {
	var spans = document.getElementsByTagName("span");
	for (var i=0; i < spans.length; i++) {
	    var elem = spans[i];
	    if (elem) {
		var level = elem.getAttribute("class");
                if (level == "h1" || level == "h2" || level == "h3" || level == "h4" || level == "h5" || level == "h6") {
                    elem.innerHTML = "<"+level+">"+elem.innerHTML+"</"+level+">";		
                }
	    }
	}
    }
    var legend_html = "Colour legend:<br />      <table>         <tr><td>Unknown:</td>                   <td><span class='cplate bgwhite'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft:</td>                     <td><span class='cplate bgred'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Informational:</td>             <td><span class='cplate bgorange'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Experimental:</td>              <td><span class='cplate bgyellow'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Best Common Practice:</td>      <td><span class='cplate bgmagenta'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Proposed Standard:</td>         <td><span class='cplate bgblue'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft Standard (old designation):</td> <td><span class='cplate bgcyan'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Internet Standard:</td>         <td><span class='cplate bggreen'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Historic:</td>                  <td><span class='cplate bggrey'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Obsolete:</td>                  <td><span class='cplate bgbrown'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>     </table>";
    function showElem(id) {
        var elem = document.getElementById(id);
        elem.innerHTML = eval(id+"_html");
        elem.style.visibility='visible';
    }
    function hideElem(id) {
        var elem = document.getElementById(id);
        elem.style.visibility='hidden';        
        elem.innerHTML = "";
    }
    // -->
    </script>
</head>
<body onload="addHeaderTags()">
  <div class="content">
   <div style="height: 13px;">
      <div class="pre noprint docinfo bgblue" onclick="showElem('legend');" onmouseout="hideElem('legend')" onmouseover="this.style.cursor='pointer';" style="height: 6px; position: absolute;" title="Click for colour legend.">                                                                        </div>
      <div class="docinfo noprint pre legend" id="legend" onmouseout="hideElem('legend');" onmouseover="showElem('legend');" style="position:absolute; top: 4px; left: 4ex; visibility:hidden; background-color: white; padding: 4px 9px 5px 7px; border: solid #345 1px; ">
      </div>
   </div>
<span class="pre noprint docinfo top">[<a href="index.html" title="Document search and retrieval page">Docs</a>] [<a href="https://tools.ietf.org/rfc/rfc8132.txt" title="Plaintext version of this document">txt</a>|<a href="https://tools.ietf.org/pdf/rfc8132" title="PDF version of this document">pdf</a>] [<a href="https://tools.ietf.org/html/draft-ietf-core-etch" title="draft-ietf-core-etch">draft-ietf-core...</a>] [<a href="https://datatracker.ietf.org/doc/rfc8132" title="IESG Datatracker information for this document">Tracker</a>] [<a href="https://tools.ietf.org/rfcdiff?difftype=--hwdiff&amp;url2=rfc8132" title="Inline diff (wdiff)">Diff1</a>] [<a href="https://tools.ietf.org/rfcdiff?url2=rfc8132" title="Side-by-side diff">Diff2</a>]         </span><br/>
<span class="pre noprint docinfo">                                                                        </span><br/>
<span class="pre noprint docinfo">                                                       PROPOSED STANDARD</span><br/>
<span class="pre noprint docinfo">                                                                        </span><br/>
<pre>Internet Engineering Task Force (IETF)                   P. van der Stok
Request for Comments: 8132                                    Consultant
Category: Standards Track                                     C. Bormann
ISSN: 2070-1721                                  Universitaet Bremen TZI
                                                               A. Sehgal
                                                            NAVOMI, Inc.
                                                              April 2017


PATCH and FETCH Methods for the Constrained Application Protocol (CoAP)

Abstract

   The methods defined in <a href="rfc7252.html">RFC 7252</a> for the Constrained Application
   Protocol (CoAP) only allow access to a complete resource, not to
   parts of a resource.  In case of resources with larger or complex
   data, or in situations where resource continuity is required,
   replacing or requesting the whole resource is undesirable.  Several
   applications using CoAP need to access parts of the resources.

   This specification defines the new CoAP methods, FETCH, PATCH, and
   iPATCH, which are used to access and update parts of a resource.

Status of This Memo

   This is an Internet Standards Track document.

   This document is a product of the Internet Engineering Task Force
   (IETF).  It represents the consensus of the IETF community.  It has
   received public review and has been approved for publication by the
   Internet Engineering Steering Group (IESG).  Further information on
   Internet Standards is available in <a href="rfc7841.html#section-2">Section 2 of RFC 7841</a>.

   Information about the current status of this document, any errata,
   and how to provide feedback on it may be obtained at
   <a href="http://www.rfc-editor.org/info/rfc8132">http://www.rfc-editor.org/info/rfc8132</a>.















<span class="grey">van der Stok, et al.         Standards Track                    [Page 1]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-2" id="page-2" name="page-2"> </a>
<span class="grey"><a href="rfc8132.html">RFC 8132</a>                    CoAP FETCH PATCH                  April 2017</span>


Copyright Notice

   Copyright (c) 2017 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to <a href="https://tools.ietf.org/html/bcp78">BCP 78</a> and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (<a href="http://trustee.ietf.org/license-info">http://trustee.ietf.org/license-info</a>) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.

Table of Contents

   <a href="#section-1">1</a>.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   <a href="#page-3">3</a>
     <a href="#section-1.1">1.1</a>.  FETCH . . . . . . . . . . . . . . . . . . . . . . . . . .   <a href="#page-3">3</a>
     <a href="#section-1.2">1.2</a>.  PATCH and iPATCH  . . . . . . . . . . . . . . . . . . . .   <a href="#page-4">4</a>
     <a href="#section-1.3">1.3</a>.  Requirements Language . . . . . . . . . . . . . . . . . .   <a href="#page-5">5</a>
     <a href="#section-1.4">1.4</a>.  Terminology and Acronyms  . . . . . . . . . . . . . . . .   <a href="#page-5">5</a>
   <a href="#section-2">2</a>.  FETCH Method  . . . . . . . . . . . . . . . . . . . . . . . .   <a href="#page-5">5</a>
     <a href="#section-2.1">2.1</a>.  Response Codes  . . . . . . . . . . . . . . . . . . . . .   <a href="#page-6">6</a>
     <a href="#section-2.2">2.2</a>.  Error Handling  . . . . . . . . . . . . . . . . . . . . .   <a href="#page-6">6</a>
     <a href="#section-2.3">2.3</a>.  Option Numbers  . . . . . . . . . . . . . . . . . . . . .   <a href="#page-7">7</a>
       <a href="#section-2.3.1">2.3.1</a>.  The Content-Format Option . . . . . . . . . . . . . .   <a href="#page-7">7</a>
       <a href="#section-2.3.2">2.3.2</a>.  The ETag Option . . . . . . . . . . . . . . . . . . .   <a href="#page-8">8</a>
     <a href="#section-2.4">2.4</a>.  Working with Observe  . . . . . . . . . . . . . . . . . .   <a href="#page-8">8</a>
     <a href="#section-2.5">2.5</a>.  Working with Block  . . . . . . . . . . . . . . . . . . .   <a href="#page-8">8</a>
     <a href="#section-2.6">2.6</a>.  Building FETCH Requests . . . . . . . . . . . . . . . . .   <a href="#page-8">8</a>
     <a href="#section-2.7">2.7</a>.  A Simple Example for FETCH  . . . . . . . . . . . . . . .   <a href="#page-8">8</a>
   <a href="#section-3">3</a>.  PATCH and iPATCH Methods  . . . . . . . . . . . . . . . . . .   <a href="#page-9">9</a>
     <a href="#section-3.1">3.1</a>.  Simple Examples for PATCH and iPATCH  . . . . . . . . . .  <a href="#page-12">12</a>
     <a href="#section-3.2">3.2</a>.  Response Codes  . . . . . . . . . . . . . . . . . . . . .  <a href="#page-14">14</a>
     <a href="#section-3.3">3.3</a>.  Option Numbers  . . . . . . . . . . . . . . . . . . . . .  <a href="#page-14">14</a>
     <a href="#section-3.4">3.4</a>.  Error Handling  . . . . . . . . . . . . . . . . . . . . .  <a href="#page-15">15</a>
   <a href="#section-4">4</a>.  The New Set of CoAP Methods . . . . . . . . . . . . . . . . .  <a href="#page-16">16</a>
   <a href="#section-5">5</a>.  Security Considerations . . . . . . . . . . . . . . . . . . .  <a href="#page-17">17</a>
   <a href="#section-6">6</a>.  IANA Considerations . . . . . . . . . . . . . . . . . . . . .  <a href="#page-18">18</a>
   <a href="#section-7">7</a>.  References  . . . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-19">19</a>
     <a href="#section-7.1">7.1</a>.  Normative References  . . . . . . . . . . . . . . . . . .  <a href="#page-19">19</a>
     <a href="#section-7.2">7.2</a>.  Informative References  . . . . . . . . . . . . . . . . .  <a href="#page-19">19</a>
   Acknowledgements  . . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-20">20</a>
   Authors' Addresses  . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-21">21</a>






<span class="grey">van der Stok, et al.         Standards Track                    [Page 2]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-3" id="page-3" name="page-3"> </a>
<span class="grey"><a href="rfc8132.html">RFC 8132</a>                    CoAP FETCH PATCH                  April 2017</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/1.%20%20Introduction"></a><a class="selflink" href="#section-1" name="section-1">1</a>.  Introduction</span>

   Similar to HTTP, the GET method defined in [<a href="rfc7252.html" title='"The Constrained Application Protocol (CoAP)"'>RFC7252</a>] for the
   Constrained Application Protocol (CoAP) only allows the specification
   of a URI and request parameters in CoAP options, not the transfer of
   a request payload detailing the request.  This leads some
   applications to use POST where a cacheable, idempotent, safe request
   is actually desired.

   Again, similar to the original specification of HTTP, the PUT method
   defined in [<a href="rfc7252.html" title='"The Constrained Application Protocol (CoAP)"'>RFC7252</a>] only allows a complete resource to be replaced.
   This also leads applications to use POST where a cacheable, possibly
   idempotent request is actually desired.

   The present specification adds new CoAP methods: FETCH, to perform
   the equivalent of a GET with a request body; and the twin methods,
   PATCH and iPATCH, to modify parts of a CoAP resource.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/1.1.%20%20FETCH"></a><a class="selflink" href="#section-1.1" name="section-1.1">1.1</a>.  FETCH</span>

   The CoAP GET method [<a href="rfc7252.html" title='"The Constrained Application Protocol (CoAP)"'>RFC7252</a>] is used to obtain the representation of
   a resource, where the resource is specified by a URI and additional
   request parameters can also shape the representation.  This has been
   modeled after the HTTP GET operation and the REST model in general.

   In HTTP, a resource is often used to search for information, and
   existing systems varyingly use the HTTP GET and POST methods to
   perform a search.  Often, a POST method is used solely so that a
   larger set of parameters to the search can be supplied in the request
   body than can comfortably be transferred in the URI with a GET
   request.  [<a href="#ref-HTTP-SEARCH">HTTP-SEARCH</a>] proposes a SEARCH method that is similar to
   GET in most properties but enables sending a request body, as is done
   with POST.  The FETCH method defined in the present specification is
   inspired by [<a href="#ref-HTTP-SEARCH">HTTP-SEARCH</a>], which updates the definition and semantics
   of the HTTP SEARCH request method previously defined by [<a href="rfc5323.html" title='"Web Distributed Authoring and Versioning (WebDAV) SEARCH"'>RFC5323</a>].
   However, there is no intention to limit FETCH to search-type
   operations, and the resulting properties may not be the same as those
   of HTTP SEARCH.













<span class="grey">van der Stok, et al.         Standards Track                    [Page 3]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-4" id="page-4" name="page-4"> </a>
<span class="grey"><a href="rfc8132.html">RFC 8132</a>                    CoAP FETCH PATCH                  April 2017</span>


   A major problem with GET is that the information that controls the
   request needs to be bundled up in some unspecified way into the URI.
   Using the request body for this information has a number of
   advantages:

   o  The client can specify a media type (and a content coding) that
      enables the server to unambiguously interpret the request
      parameters in the context of that media type.  Also, the request
      body is not limited by the character set limitations of URIs,
      which enables a more natural (and more efficient) representation
      of certain domain-specific parameters.

   o  The request parameters are not limited by the maximum size of the
      URI.  In HTTP, that is a problem, as the practical limit for this
      size varies.  In CoAP, another problem is that the block-wise
      transfer is not available for transferring large URI options in
      multiple rounds.

   As an alternative to using GET, many implementations make use of the
   POST method to perform extended requests (even if they are
   semantically idempotent, safe, and even cacheable) to be able to pass
   along the input parameters within the request payload as opposed to
   using the request URI.

   The FETCH method provides a solution that spans the gap between the
   use of GET and POST.  As with POST, the input to the FETCH operation
   is passed along within the payload of the request rather than as part
   of the request URI.  Unlike POST, however, the semantics of the FETCH
   method are more specifically defined.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/1.2.%20%20PATCH%20and%20iPATCH"></a><a class="selflink" href="#section-1.2" name="section-1.2">1.2</a>.  PATCH and iPATCH</span>

   PATCH is also specified for HTTP in [<a href="rfc5789.html" title='"PATCH Method for HTTP"'>RFC5789</a>].  Most of the
   motivation for PATCH described in [<a href="rfc5789.html" title='"PATCH Method for HTTP"'>RFC5789</a>] also applies here. iPATCH
   is the idempotent version of PATCH.

   The PUT method exists to overwrite a resource with completely new
   contents and cannot be used to perform partial changes.  When using
   PUT for partial changes, proxies and caches, and even clients and
   servers, may get confused as to the result of the operation.  PATCH
   was not adopted in an early design stage of CoAP; however, it has
   become necessary with the arrival of applications that require
   partial updates to resources (e.g., [<a href="#ref-COAP-MGMNT">COAP-MGMNT</a>]).  Using PATCH
   avoids transferring all data associated with a resource in case of
   modifications, thereby not burdening the constrained communication
   medium.





<span class="grey">van der Stok, et al.         Standards Track                    [Page 4]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-5" id="page-5" name="page-5"> </a>
<span class="grey"><a href="rfc8132.html">RFC 8132</a>                    CoAP FETCH PATCH                  April 2017</span>


   This document relies on knowledge of the PATCH specification for HTTP
   [<a href="rfc5789.html" title='"PATCH Method for HTTP"'>RFC5789</a>].  This document provides extracts from [<a href="rfc5789.html" title='"PATCH Method for HTTP"'>RFC5789</a>] to make
   independent reading possible.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/1.3.%20%20Requirements%20Language"></a><a class="selflink" href="#section-1.3" name="section-1.3">1.3</a>.  Requirements Language</span>

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
   "OPTIONAL" in this document are to be interpreted as described in
   [<a href="rfc2119.html" title='"Key words for use in RFCs to Indicate Requirement Levels"'>RFC2119</a>].

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/1.4.%20%20Terminology%20and%20Acronyms"></a><a class="selflink" href="#section-1.4" name="section-1.4">1.4</a>.  Terminology and Acronyms</span>

   This document uses terminology defined in [<a href="rfc5789.html" title='"PATCH Method for HTTP"'>RFC5789</a>] and [<a href="rfc7252.html" title='"The Constrained Application Protocol (CoAP)"'>RFC7252</a>].

   Specifically, it uses the terms "safe" and "idempotent" as defined in
   <a href="rfc7252.html#section-5.1">Section 5.1 of [RFC7252]</a>.  (Further discussion of safe and idempotent
   methods can now be found in Sections <a href="#section-4.2.1">4.2.1</a> and <a href="#section-4.2.2">4.2.2</a> of [<a href="rfc7231.html" title='"Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content"'>RFC7231</a>],
   respectively; the implications of idempotence of methods on server
   implementations are also discussed in <a href="rfc7252.html#section-4.5">Section 4.5 of [RFC7252]</a>.)

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/2.%20%20FETCH%20Method"></a><a class="selflink" href="#section-2" name="section-2">2</a>.  FETCH Method</span>

   The CoAP FETCH method is used to obtain a representation of a
   resource, specified by a number of request parameters.  Unlike the
   CoAP GET method, which requests that a server return a representation
   of the resource identified by the effective request URI (as defined
   by [<a href="rfc7252.html" title='"The Constrained Application Protocol (CoAP)"'>RFC7252</a>]), the FETCH method is used by a client to ask the server
   to produce a representation as described by the request parameters
   (including the request options and the payload) based on the resource
   specified by the effective request URI.  The payload returned in
   response to a FETCH cannot be assumed to be a complete representation
   of the resource identified by the effective request URI, i.e., it
   cannot be used by a cache as a payload to be returned by a GET
   request.

   Together with the request options, the body of the request (which may
   be constructed from multiple payloads using the block protocol
   [<a href="rfc7959.html" title='"Block-Wise Transfers in the Constrained Application Protocol (CoAP)"'>RFC7959</a>]) defines the request parameters.  With the FETCH method,
   implementations may submit a request body of any media type that is
   defined with the semantics of selecting information from a resource
   in such a FETCH request; it is outside the scope of this document how
   information about media types admissible for the specific resource is
   obtained by the client (although we can hint that form relations
   [<a href="#ref-CORE-APP" title='"CoRE Application Descriptions"'>CORE-APP</a>] might be a preferred way).  It is RECOMMENDED that any
   discovery method that allows a client to find out that the server
   supports FETCH also provides information regarding what FETCH payload
   media types are applicable.



<span class="grey">van der Stok, et al.         Standards Track                    [Page 5]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-6" id="page-6" name="page-6"> </a>
<span class="grey"><a href="rfc8132.html">RFC 8132</a>                    CoAP FETCH PATCH                  April 2017</span>


   FETCH requests are both safe and idempotent with regards to the
   resource identified by the request URI.  That is, the performance of
   a FETCH is not intended to alter the state of the targeted resource.
   (However, while processing a FETCH request, a server can be expected
   to allocate computing and memory resources or even create additional
   server resources through which the response to the search can be
   retrieved.)

   A successful response to a FETCH request is expected to provide some
   indication as to the final disposition of the requested operation.
   If a successful response includes a body payload, the payload is
   expected to describe the results of the FETCH operation.

   Depending on the response code as defined by [<a href="rfc7252.html" title='"The Constrained Application Protocol (CoAP)"'>RFC7252</a>], the response
   to a FETCH request is cacheable; the request body is part of the
   cache key.  Specifically, 2.05 (Content) response codes (the
   responses for which are cacheable) are a typical way to respond to a
   FETCH request.  (Note that this aspect differs markedly from
   [<a href="#ref-HTTP-SEARCH">HTTP-SEARCH</a>] and also that caches that cannot use the request
   payload as part of the cache key will not be able to cache responses
   to FETCH requests at all.)  The Max-Age option in the response has
   equivalent semantics to its use in a GET.

   The semantics of the FETCH method change to a "conditional FETCH" if
   the request message includes an If-Match or If-None-Match option
   [<a href="rfc7252.html" title='"The Constrained Application Protocol (CoAP)"'>RFC7252</a>].  A conditional FETCH requests that the query be performed
   only under the circumstances described by the conditional option(s).
   It is important to note, however, that such conditions are evaluated
   against the state of the target resource itself as opposed to the
   results of the FETCH operation.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/2.1.%20%20Response%20Codes"></a><a class="selflink" href="#section-2.1" name="section-2.1">2.1</a>.  Response Codes</span>

   FETCH for CoAP adopts the response codes as specified in Sections <a href="#section-5.9">5.9</a>
   and 12.1.2 of [<a href="rfc7252.html" title='"The Constrained Application Protocol (CoAP)"'>RFC7252</a>] as well as the additional response codes
   mentioned in <a href="#section-2.2">Section 2.2</a>.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/2.2.%20%20Error%20Handling"></a><a class="selflink" href="#section-2.2" name="section-2.2">2.2</a>.  Error Handling</span>

   A FETCH request may fail under certain known conditions.  Beyond the
   conditions already defined in [<a href="rfc7252.html" title='"The Constrained Application Protocol (CoAP)"'>RFC7252</a>] for GET, noteworthy ones are:

   Malformed FETCH payload:  If a server determines that the payload
      provided with a FETCH request is not properly formatted, it can
      return a 4.00 (Bad Request) CoAP error.  The definition of a
      malformed payload depends upon the CoAP Content-Format specified
      with the request.




<span class="grey">van der Stok, et al.         Standards Track                    [Page 6]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-7" id="page-7" name="page-7"> </a>
<span class="grey"><a href="rfc8132.html">RFC 8132</a>                    CoAP FETCH PATCH                  April 2017</span>


   Unsupported FETCH payload:  In case a client sends a payload that is
      inappropriate for the resource identified by the Request-URI, the
      server can return a 4.15 (Unsupported Content-Format) CoAP error.
      The server can determine if the payload is supported by checking
      the CoAP Content-Format specified with the request.

   Unprocessable request:  This situation occurs when the payload of a
      FETCH request is determined to be valid (i.e., well-formed and
      supported) but the server is unable to or is incapable of
      processing the request.  The server can return a 4.22
      (Unprocessable Entity) CoAP error.  In situations when the server
      has insufficient computing resources to complete the request
      successfully, it can return a 4.13 (Request Entity Too Large) CoAP
      error (see also below).  If there are more specific errors that
      provide additional insight into the problem, then those should be
      used.

   Request too large:  If the payload of the FETCH request is larger
      than a CoAP server can process, then it can return the 4.13
      (Request Entity Too Large) CoAP error.

   It is possible that other error situations not mentioned here are
   encountered by a CoAP server while processing the FETCH request.  In
   these situations, other appropriate CoAP response codes can also be
   returned.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/2.3.%20%20Option%20Numbers"></a><a class="selflink" href="#section-2.3" name="section-2.3">2.3</a>.  Option Numbers</span>

   FETCH for CoAP adopts the option numbers as specified in Sections
   5.10 and 12.2 of [<a href="rfc7252.html" title='"The Constrained Application Protocol (CoAP)"'>RFC7252</a>].

   Generally, options defined for GET act in an analogous way for FETCH.
   Two specific cases are called out in the rest of this section.

<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/2.3.1.%20%20The%20Content-Format%20Option"></a><a class="selflink" href="#section-2.3.1" name="section-2.3.1">2.3.1</a>.  The Content-Format Option</span>

   A FETCH request MUST include a Content-Format option (see
   <a href="rfc7252.html#section-5.10.3">Section 5.10.3 of [RFC7252]</a>) to specify the media type and content
   coding of the request body.  (Typically, the media type will have
   been specifically designed to specify details for a selection or a
   search on a resource.)










<span class="grey">van der Stok, et al.         Standards Track                    [Page 7]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-8" id="page-8" name="page-8"> </a>
<span class="grey"><a href="rfc8132.html">RFC 8132</a>                    CoAP FETCH PATCH                  April 2017</span>


<span class="h4"><a class="dashAnchor" name="//apple_ref/Section/2.3.2.%20%20The%20ETag%20Option"></a><a class="selflink" href="#section-2.3.2" name="section-2.3.2">2.3.2</a>.  The ETag Option</span>

   The ETag option on a FETCH result has the same semantics as defined
   in <a href="rfc7252.html#section-5.10.6">Section 5.10.6 of [RFC7252]</a>.  In particular, its use as a response
   option describes the "tagged representation", which for FETCH is the
   same as the "selected representation".  The FETCH payload is input to
   that selection process and therefore needs to be part of the cache
   key.  Similarly, the use of ETag as a request option can elicit a
   2.03 (Valid) response if the representation associated with the ETag
   would still be selected by the FETCH request (including its payload).

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/2.4.%20%20Working%20with%20Observe"></a><a class="selflink" href="#section-2.4" name="section-2.4">2.4</a>.  Working with Observe</span>

   The Observe option [<a href="rfc7641.html" title='"Observing Resources in the Constrained Application Protocol (CoAP)"'>RFC7641</a>] can be used with a FETCH request as it
   can be used with a GET request.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/2.5.%20%20Working%20with%20Block"></a><a class="selflink" href="#section-2.5" name="section-2.5">2.5</a>.  Working with Block</span>

   The Block1 option [<a href="rfc7959.html" title='"Block-Wise Transfers in the Constrained Application Protocol (CoAP)"'>RFC7959</a>] can be used with a FETCH request as it
   would be used with a POST request; the Block2 option can then be used
   as it would with GET or POST.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/2.6.%20%20Building%20FETCH%20Requests"></a><a class="selflink" href="#section-2.6" name="section-2.6">2.6</a>.  Building FETCH Requests</span>

   One property of FETCH that may be non-obvious is that a FETCH request
   cannot be generated from a link alone; the client also needs a way to
   generate the request payload.  Again, form relations [<a href="#ref-CORE-APP" title='"CoRE Application Descriptions"'>CORE-APP</a>] may
   be able to fill parts of this gap.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/2.7.%20%20A%20Simple%20Example%20for%20FETCH"></a><a class="selflink" href="#section-2.7" name="section-2.7">2.7</a>.  A Simple Example for FETCH</span>

   The FETCH method needs a media type for its payload (as expressed by
   the Content-Format request option) that specifies the search query in
   similar detail as is shown for the PATCH payload in the PATCH example
   in <a href="#section-3.1">Section 3.1</a>.  ([<a href="#ref-HTTP-SEARCH">HTTP-SEARCH</a>] invents a "text/query" format based
   on some hypothetical SQL dialect for its examples.)

   The example below illustrates retrieval of a subset of a JSON
   [<a href="rfc7159.html" title='"The JavaScript Object Notation (JSON) Data Interchange Format"'>RFC7159</a>] object (the same object as used in <a href="#section-3.1">Section 3.1</a>).  Using a
   hypothetical media type "application/example-map-keys+json" (with a
   Content-Format ID of NNN, which is not defined as this is just an
   example), the client specifies the items in the object that it wants:
   it supplies a JSON array that gives the map keys for these items.  A
   resource located at &lt;coap://www.example.com/object&gt; can be
   represented by a JSON document that we will consider as the target of
   the FETCH.  The client wants to learn the contents of the single map
   key "foo" within this target:




<span class="grey">van der Stok, et al.         Standards Track                    [Page 8]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-9" id="page-9" name="page-9"> </a>
<span class="grey"><a href="rfc8132.html">RFC 8132</a>                    CoAP FETCH PATCH                  April 2017</span>


   {
     "x-coord": 256,
     "y-coord": 45,
     "foo": ["bar","baz"]
   }

               FETCH Example: JSON Document Returned by GET

   The example FETCH request specifies a single top-level member desired
   by giving its map key as the sole element of the "example-map-keys"
   payload:

   FETCH CoAP://www.example.com/object
   Content-Format: NNN (application/example-map-keys+json)
   Accept: application/json
   [
     "foo"
   ]

                          FETCH Example: Request

   The server returns a subset document with just the selected member:

   2.05 Content
   Content-Format: 50 (application/json)
   {
     "foo": ["bar","baz"]
   }

             FETCH Example: Response with Subset JSON Document

   By the logic of this example, the requester could have entered more
   than one map key into the request payload array and would have
   received a more complete subset of the top-level JSON object that is
   representing the resource.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/3.%20%20PATCH%20and%20iPATCH%20Methods"></a><a class="selflink" href="#section-3" name="section-3">3</a>.  PATCH and iPATCH Methods</span>

   The PATCH and iPATCH methods request that a set of changes described
   in the request payload be applied to the target resource of the
   request.  The set of changes is represented in a format identified by
   a media type.  If the Request-URI does not point to an existing
   resource, the server MAY create a new resource with that URI,
   depending on the PATCH document type (whether it can logically modify
   a null resource) and permissions, as well as other conditions such as
   the degree of control the server gives clients in creating new





<span class="grey">van der Stok, et al.         Standards Track                    [Page 9]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-10" id="page-10" name="page-10"> </a>
<span class="grey"><a href="rfc8132.html">RFC 8132</a>                    CoAP FETCH PATCH                  April 2017</span>


   entries in its URI space (see also <a href="#section-3.4">Section 3.4</a>).  Creation of a new
   resource would result in a 2.01 (Created) response code dependent on
   the PATCH document type.

   Restrictions to a PATCH or iPATCH request can be made by including
   the If-Match or If-None-Match options in the request (see Sections
   5.10.8.1 and 5.10.8.2 of [<a href="rfc7252.html" title='"The Constrained Application Protocol (CoAP)"'>RFC7252</a>]).  If the resource could not be
   created or modified, then an appropriate error response code SHOULD
   be sent.

   The difference between the PUT and PATCH requests is documented in
   [<a href="rfc5789.html" title='"PATCH Method for HTTP"'>RFC5789</a>].  When a request is intended to effect a partial update of
   a given resource, clients cannot use PUT while supplying just the
   update, but they might be able to use PATCH or iPATCH.

   The PATCH method is "not safe" and "not idempotent", as is the HTTP
   PATCH method specified in [<a href="rfc5789.html" title='"PATCH Method for HTTP"'>RFC5789</a>].

   The iPATCH method is not safe but idempotent, as with the CoAP PUT
   method specified in <a href="rfc7252.html#section-5.8.3">Section 5.8.3 of [RFC7252]</a>.

   A client can mark a request as idempotent by using the iPATCH method
   instead of the PATCH method.  This is the only difference between the
   two.  The indication of idempotence may enable the server to keep
   less state about the interaction; some constrained servers may only
   implement the iPATCH variant for this reason.

   PATCH and iPATCH are both atomic.  The server MUST apply the entire
   set of changes atomically and never provide a partially modified
   representation to a concurrently executed GET request.  Given the
   constrained nature of the servers, most servers will only execute
   CoAP requests consecutively, thus preventing a concurrent partial
   overlapping of request modifications.  In other words, modifications
   MUST NOT be applied to the server state when an error occurs or when
   only a partial execution is possible on the resources present in the
   server.

   The atomicity applies to a single server.  When a PATCH or iPATCH
   request is multicast to a set of servers, each server can either
   execute all required modifications or not.  It is not required that
   all servers execute all modifications or none.  An Atomic Commit
   protocol that provides multiple server atomicity is out of scope.









<span class="grey">van der Stok, et al.         Standards Track                   [Page 10]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-11" id="page-11" name="page-11"> </a>
<span class="grey"><a href="rfc8132.html">RFC 8132</a>                    CoAP FETCH PATCH                  April 2017</span>


   A PATCH or iPATCH response can invalidate a cache in a similar manner
   to the PUT response.  For the successful (2.xx) response codes, PATCH
   or iPATCH have the following caching behavior:

   o  A 2.01 (Created) response invalidates any cache entry for the
      resource indicated by the Location-* options; the payload is a
      representation of the action result.

   o  A 2.04 (Changed) response invalidates any cache entry for the
      target resource; the payload is a representation of the action
      result.

   There is no guarantee that a resource can be modified with PATCH or
   iPATCH.  Servers MUST ensure that a received PATCH body is
   appropriate for the type of resource identified by the target
   resource of the request.

   It is RECOMMENDED that any discovery method that allows a client to
   find out that the server supports one of PATCH and iPATCH also
   provide information regarding what PATCH payload media types are
   applicable and which of the two methods are implemented by the server
   for each of these media types.

   Servers that do not rely on the idempotence of iPATCH can easily
   support both PATCH and iPATCH, and it is RECOMMENDED they do so.
   This is inexpensive to do, as, for iPATCH, there is no requirement on
   the server to check that the client's intention that the request be
   idempotent is fulfilled (although there is diagnostic value in that
   check, so a less-constrained implementation may want to perform it).






















<span class="grey">van der Stok, et al.         Standards Track                   [Page 11]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-12" id="page-12" name="page-12"> </a>
<span class="grey"><a href="rfc8132.html">RFC 8132</a>                    CoAP FETCH PATCH                  April 2017</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.1.%20%20Simple%20Examples%20for%20PATCH%20and%20iPATCH"></a><a class="selflink" href="#section-3.1" name="section-3.1">3.1</a>.  Simple Examples for PATCH and iPATCH</span>

   The example is taken over from [<a href="rfc6902.html" title='"JavaScript Object Notation (JSON) Patch"'>RFC6902</a>], which specifies a JSON
   notation for PATCH operations.  A resource located at
   &lt;coap://www.example.com/object&gt; contains a target JSON document.

   JSON document original state:
       {
         "x-coord": 256,
         "y-coord": 45,
         "foo": ["bar","baz"]
       }

   REQ: iPATCH CoAP://www.example.com/object
   Content-Format: 51 (application/json-patch+json)
       [
         { "op":"replace", "path":"x-coord", "value":45}
       ]

   RET: CoAP 2.04 Changed

   JSON document final state:
       {
         "x-coord": 45,
         "y-coord": 45,
         "foo": ["bar","baz"]
       }

   This example illustrates use of an idempotent modification to the
   x-coord member of the existing resource "object".  The 2.04 (Changed)
   response code conforms with the CoAP PUT method.




















<span class="grey">van der Stok, et al.         Standards Track                   [Page 12]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-13" id="page-13" name="page-13"> </a>
<span class="grey"><a href="rfc8132.html">RFC 8132</a>                    CoAP FETCH PATCH                  April 2017</span>


   The same example using the Content-Format application/merge-
   patch+json from [<a href="rfc7396.html" title='"JSON Merge Patch"'>RFC7396</a>] looks like the following:

   JSON document original state:
       {
         "x-coord": 256,
         "y-coord": 45,
         "foo": ["bar","baz"]
       }

   REQ: iPATCH CoAP://www.example.com/object
   Content-Format: 52 (application/merge-patch+json)
        { "x-coord":45}

   RET: CoAP 2.04 Changed

   JSON document final state:
       {
         "x-coord": 45,
         "y-coord": 45,
         "foo": ["bar","baz"]
       }

   The examples show the use of the iPATCH method, but the use of the
   PATCH method would have led to the same result.  Below, a non-
   idempotent modification is shown.  Because the action is non-
   idempotent, iPATCH returns an error, while PATCH executes the action.
























<span class="grey">van der Stok, et al.         Standards Track                   [Page 13]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-14" id="page-14" name="page-14"> </a>
<span class="grey"><a href="rfc8132.html">RFC 8132</a>                    CoAP FETCH PATCH                  April 2017</span>


   JSON document original state:
       {
         "x-coord": 256,
         "y-coord": 45,
         "foo": ["bar","baz"]
       }

   REQ: iPATCH CoAP://www.example.com/object
   Content-Format: 51 (application/json-patch+json)
       [
         { "op":"add","path":"foo/1","value":"bar"}
       ]
   RET: CoAP 4.00 Bad Request
   Diagnostic payload: Patch format not idempotent

   JSON document final state is unchanged

   REQ: PATCH CoAP://www.example.com/object
   Content-Format: 51 (application/json-patch+json)
       [
         { "op":"add","path":"foo/1","value":"bar"}
       ]
   RET: CoAP 2.04 Changed

   JSON document final state:
       {
         "x-coord": 45,
         "y-coord": 45,
         "foo": ["bar","bar","baz"]
       }

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.2.%20%20Response%20Codes"></a><a class="selflink" href="#section-3.2" name="section-3.2">3.2</a>.  Response Codes</span>

   PATCH and iPATCH for CoAP adopt the response codes as specified in
   Sections <a href="#section-5.9">5.9</a> and <a href="#section-12.1.2">12.1.2</a> of [<a href="rfc7252.html" title='"The Constrained Application Protocol (CoAP)"'>RFC7252</a>] and add 4.09 (Conflict) and 4.22
   (Unprocessable Entity) with the semantics specified in <a href="#section-3.4">Section 3.4</a> of
   the present specification.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.3.%20%20Option%20Numbers"></a><a class="selflink" href="#section-3.3" name="section-3.3">3.3</a>.  Option Numbers</span>

   PATCH and iPATCH for CoAP adopt the option numbers as specified in
   Sections <a href="#section-5.10">5.10</a> and <a href="#section-12.2">12.2</a> of [<a href="rfc7252.html" title='"The Constrained Application Protocol (CoAP)"'>RFC7252</a>].









<span class="grey">van der Stok, et al.         Standards Track                   [Page 14]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-15" id="page-15" name="page-15"> </a>
<span class="grey"><a href="rfc8132.html">RFC 8132</a>                    CoAP FETCH PATCH                  April 2017</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/3.4.%20%20Error%20Handling"></a><a class="selflink" href="#section-3.4" name="section-3.4">3.4</a>.  Error Handling</span>

   A PATCH or iPATCH request may fail under certain known conditions.
   These situations should be dealt with as expressed below.

   Malformed PATCH or iPATCH payload:  If a server determines that the
      payload provided with a PATCH or iPATCH request is not properly
      formatted, it can return a 4.00 (Bad Request) CoAP error.  The
      definition of a malformed payload depends upon the CoAP Content-
      Format specified with the request.

   Unsupported PATCH or iPATCH payload:  In case a client sends a
      payload that is inappropriate for the resource identified by the
      Request-URI, the server can return a 4.15 (Unsupported Content-
      Format) CoAP error.  The server can determine if the payload is
      supported by checking the CoAP Content-Format specified with the
      request.

   Unprocessable request:  This situation occurs when the payload of a
      PATCH request is determined to be valid (i.e., well-formed and
      supported) but the server is unable to or is incapable of
      processing the request.  The server can return a 4.22
      (Unprocessable Entity) CoAP error.  More specific scenarios might
      include situations such as:

      *  the server has insufficient computing resources to complete the
         request successfully -- 4.13 (Request Entity Too Large) CoAP
         response code (see below); or

      *  the resource specified in the request becomes invalid by
         applying the payload -- 4.09 (Conflict) CoAP response code (see
         "Conflicting state" below)).

      In case there are more specific errors that provide additional
      insight into the problem, then those should be used.

   Resource not found:  The 4.04 (Not Found) error should be returned if
      the payload of a PATCH request cannot be applied to a non-existent
      resource.

   Failed precondition:  In case the client uses the conditional
      If-Match or If-None-Match option to define a precondition for the
      PATCH request, and that precondition fails, then the server can
      return the 4.12 (Precondition Failed) CoAP error.

   Request too large:  If the payload of the PATCH request is larger
      than a CoAP server can process, then it can return the 4.13
      (Request Entity Too Large) CoAP error.



<span class="grey">van der Stok, et al.         Standards Track                   [Page 15]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-16" id="page-16" name="page-16"> </a>
<span class="grey"><a href="rfc8132.html">RFC 8132</a>                    CoAP FETCH PATCH                  April 2017</span>


   Conflicting state:  If the modification specified by a PATCH or
      iPATCH request causes the resource to enter an inconsistent state
      that the server cannot resolve, the server can return the 4.09
      (Conflict) CoAP response.  The server SHOULD generate a payload
      that includes enough information for a user to recognize the
      source of the conflict.  The server MAY return the actual resource
      state to provide the client with the means to create a new
      consistent resource state.  Such a situation might be encountered
      when a structural modification is applied to a configuration data
      store but the structures being modified do not exist.

   Concurrent modification:  Resource-constrained devices might need to
      process requests in the order they are received.  In case requests
      are received concurrently to modify the same resource but they
      cannot be queued, the server can return a 5.03 (Service
      Unavailable) CoAP response code.

   Conflict handling failure:  If the modification implies the
      reservation of resources or the wait time for conditions to become
      true leads to a too-long request execution time, the server can
      return a 5.03 (Service Unavailable) response code.

   It is possible that other error situations not mentioned here are
   encountered by a CoAP server while processing the PATCH request.  In
   these situations, other appropriate CoAP status codes can also be
   returned.

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/4.%20%20The%20New%20Set%20of%20CoAP%20Methods"></a><a class="selflink" href="#section-4" name="section-4">4</a>.  The New Set of CoAP Methods</span>

   Adding three new methods to CoAP's existing four may seem like a
   major change.  However, FETCH and the two PATCH variants fit well
   into the REST paradigm and have been anticipated on the HTTP side.
   Adding both a non-idempotent and an idempotent PATCH variant allows
   interoperability with HTTP's PATCH method to be kept and allows the
   use/indication of an idempotent PATCH when that is possible, which
   saves significant effort on the server side.















<span class="grey">van der Stok, et al.         Standards Track                   [Page 16]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-17" id="page-17" name="page-17"> </a>
<span class="grey"><a href="rfc8132.html">RFC 8132</a>                    CoAP FETCH PATCH                  April 2017</span>


   Interestingly, the three new methods fit into the old table of
   methods with a surprising similarity in the idempotence and safety
   attributes:

           +------+--------+------+--------+------+------------+
           | Code | Name   | Code | Name   | safe | idempotent |
           +------+--------+------+--------+------+------------+
           | 0.01 | GET    | 0.05 | FETCH  | yes  | yes        |
           | 0.02 | POST   | 0.06 | PATCH  | no   | no         |
           | 0.03 | PUT    | 0.07 | iPATCH | no   | yes        |
           | 0.04 | DELETE |      |        | no   | yes        |
           +------+--------+------+--------+------+------------+

<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/5.%20%20Security%20Considerations"></a><a class="selflink" href="#section-5" name="section-5">5</a>.  Security Considerations</span>

   This section analyzes the possible threats to the CoAP FETCH and
   PATCH or iPATCH methods.  It is meant to inform protocol and
   application developers about the security limitations of CoAP FETCH
   and PATCH or iPATCH as described in this document.

   The FETCH method is subject to the same general security
   considerations as all CoAP methods as described in <a href="rfc7252.html#section-11">Section 11 of
   [RFC7252]</a>.  Specifically, the security considerations for FETCH are
   closest to those of GET, except that the FETCH request carries a
   payload that may need additional protection.  The payload of a FETCH
   request may reveal more detailed information about the specific
   portions of a resource of interest to the requester than a GET
   request for the entire resource would; this may mean that
   confidentiality protection of the request by Datagram Transport Layer
   Security (DTLS) or other means is needed for FETCH where it wouldn't
   be needed for GET.

   The PATCH and iPATCH methods are subject to the same general security
   considerations as all CoAP methods as described in <a href="rfc7252.html#section-11">Section 11 of
   [RFC7252]</a>.  The specific security considerations for PATCH or iPATCH
   are nearly identical to the security considerations for PUT
   [<a href="rfc7252.html" title='"The Constrained Application Protocol (CoAP)"'>RFC7252</a>]; the security considerations of <a href="rfc5789.html#section-5">Section 5 of [RFC5789]</a> also
   apply to PATCH and iPATCH.  Specifically, there is likely to be a
   need for authorizing requests (possibly through access control and/or
   authentication) and for ensuring that data is not corrupted through
   transport errors or through accidental overwrites.  The mechanisms
   used for PUT can be used for PATCH or iPATCH as well.

   The new methods defined in the present specification are secured
   following the CoAP recommendations for the existing methods as
   specified in <a href="rfc7252.html#section-9">Section 9 of [RFC7252]</a>.  When additional security
   techniques are standardized for CoAP (e.g., Object Security), these
   techniques are then also available for securing the new methods.



<span class="grey">van der Stok, et al.         Standards Track                   [Page 17]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-18" id="page-18" name="page-18"> </a>
<span class="grey"><a href="rfc8132.html">RFC 8132</a>                    CoAP FETCH PATCH                  April 2017</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/6.%20%20IANA%20Considerations"></a><a class="selflink" href="#section-6" name="section-6">6</a>.  IANA Considerations</span>

   IANA has added the following entries to the subregistry "CoAP Method
   Codes":

                       +------+--------+-----------+
                       | Code | Name   | Reference |
                       +------+--------+-----------+
                       | 0.05 | FETCH  | <a href="rfc8132.html">RFC 8132</a>  |
                       | 0.06 | PATCH  | <a href="rfc8132.html">RFC 8132</a>  |
                       | 0.07 | iPATCH | <a href="rfc8132.html">RFC 8132</a>  |
                       +------+--------+-----------+

   The FETCH method is idempotent and safe, and it returns the same
   response codes that GET can return, plus 4.13 (Request Entity Too
   Large), 4.15 (Unsupported Content-Format), and 4.22 (Unprocessable
   Entity) with the semantics specified in <a href="#section-2.2">Section 2.2</a>.

   The PATCH method is neither idempotent nor safe.  It returns the same
   response codes that POST can return, plus 4.09 (Conflict) and 4.22
   (Unprocessable Entity) with the semantics specified in <a href="#section-3.4">Section 3.4</a>.

   The iPATCH method is identical to the PATCH method, except that it is
   idempotent.

   IANA has added the following code to the subregistry "CoAP Response
   Codes":

                +------+----------------------+-----------+
                | Code | Name                 | Reference |
                +------+----------------------+-----------+
                | 4.09 | Conflict             | <a href="rfc8132.html">RFC 8132</a>  |
                | 4.22 | Unprocessable Entity | <a href="rfc8132.html">RFC 8132</a>  |
                +------+----------------------+-----------+


   IANA has added entries to the subregistry "CoAP Content-Formats":

    +------------------------------+----------------+----+-----------+
    | Media Type                   | Content Coding | ID | Reference |
    +------------------------------+----------------+----+-----------+
    | application/json-patch+json  | identity       | 51 | [<a href="rfc6902.html" title='"JavaScript Object Notation (JSON) Patch"'>RFC6902</a>] |
    | application/merge-patch+json | identity       | 52 | [<a href="rfc7396.html" title='"JSON Merge Patch"'>RFC7396</a>] |
    +------------------------------+----------------+----+-----------+







<span class="grey">van der Stok, et al.         Standards Track                   [Page 18]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-19" id="page-19" name="page-19"> </a>
<span class="grey"><a href="rfc8132.html">RFC 8132</a>                    CoAP FETCH PATCH                  April 2017</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/Section/7.%20%20References"></a><a class="selflink" href="#section-7" name="section-7">7</a>.  References</span>

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/7.1.%20%20Normative%20References"></a><a class="selflink" href="#section-7.1" name="section-7.1">7.1</a>.  Normative References</span>

   [<a id="ref-RFC2119" name="ref-RFC2119">RFC2119</a>]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", <a href="https://tools.ietf.org/html/bcp14">BCP 14</a>, <a href="rfc2119.html">RFC 2119</a>,
              DOI 10.17487/RFC2119, March 1997,
              &lt;<a href="http://www.rfc-editor.org/info/rfc2119">http://www.rfc-editor.org/info/rfc2119</a>&gt;.

   [<a id="ref-RFC5789" name="ref-RFC5789">RFC5789</a>]  Dusseault, L. and J. Snell, "PATCH Method for HTTP",
              <a href="rfc5789.html">RFC 5789</a>, DOI 10.17487/RFC5789, March 2010,
              &lt;<a href="http://www.rfc-editor.org/info/rfc5789">http://www.rfc-editor.org/info/rfc5789</a>&gt;.

   [<a id="ref-RFC7231" name="ref-RFC7231">RFC7231</a>]  Fielding, R., Ed. and J. Reschke, Ed., "Hypertext Transfer
              Protocol (HTTP/1.1): Semantics and Content", <a href="rfc7231.html">RFC 7231</a>,
              DOI 10.17487/RFC7231, June 2014,
              &lt;<a href="http://www.rfc-editor.org/info/rfc7231">http://www.rfc-editor.org/info/rfc7231</a>&gt;.

   [<a id="ref-RFC7252" name="ref-RFC7252">RFC7252</a>]  Shelby, Z., Hartke, K., and C. Bormann, "The Constrained
              Application Protocol (CoAP)", <a href="rfc7252.html">RFC 7252</a>,
              DOI 10.17487/RFC7252, June 2014,
              &lt;<a href="http://www.rfc-editor.org/info/rfc7252">http://www.rfc-editor.org/info/rfc7252</a>&gt;.

   [<a id="ref-RFC7641" name="ref-RFC7641">RFC7641</a>]  Hartke, K., "Observing Resources in the Constrained
              Application Protocol (CoAP)", <a href="rfc7641.html">RFC 7641</a>,
              DOI 10.17487/RFC7641, September 2015,
              &lt;<a href="http://www.rfc-editor.org/info/rfc7641">http://www.rfc-editor.org/info/rfc7641</a>&gt;.

   [<a id="ref-RFC7959" name="ref-RFC7959">RFC7959</a>]  Bormann, C. and Z. Shelby, Ed., "Block-Wise Transfers in
              the Constrained Application Protocol (CoAP)", <a href="rfc7959.html">RFC 7959</a>,
              DOI 10.17487/RFC7959, August 2016,
              &lt;<a href="http://www.rfc-editor.org/info/rfc7959">http://www.rfc-editor.org/info/rfc7959</a>&gt;.

<span class="h3"><a class="dashAnchor" name="//apple_ref/Section/7.2.%20%20Informative%20References"></a><a class="selflink" href="#section-7.2" name="section-7.2">7.2</a>.  Informative References</span>

   [<a id="ref-RFC5323" name="ref-RFC5323">RFC5323</a>]  Reschke, J., Ed., Reddy, S., Davis, J., and A. Babich,
              "Web Distributed Authoring and Versioning (WebDAV)
              SEARCH", <a href="rfc5323.html">RFC 5323</a>, DOI 10.17487/RFC5323, November 2008,
              &lt;<a href="http://www.rfc-editor.org/info/rfc5323">http://www.rfc-editor.org/info/rfc5323</a>&gt;.

   [<a id="ref-RFC6902" name="ref-RFC6902">RFC6902</a>]  Bryan, P., Ed. and M. Nottingham, Ed., "JavaScript Object
              Notation (JSON) Patch", <a href="rfc6902.html">RFC 6902</a>, DOI 10.17487/RFC6902,
              April 2013, &lt;<a href="http://www.rfc-editor.org/info/rfc6902">http://www.rfc-editor.org/info/rfc6902</a>&gt;.

   [<a id="ref-RFC7159" name="ref-RFC7159">RFC7159</a>]  Bray, T., Ed., "The JavaScript Object Notation (JSON) Data
              Interchange Format", <a href="rfc7159.html">RFC 7159</a>, DOI 10.17487/RFC7159, March
              2014, &lt;<a href="http://www.rfc-editor.org/info/rfc7159">http://www.rfc-editor.org/info/rfc7159</a>&gt;.




<span class="grey">van der Stok, et al.         Standards Track                   [Page 19]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-20" id="page-20" name="page-20"> </a>
<span class="grey"><a href="rfc8132.html">RFC 8132</a>                    CoAP FETCH PATCH                  April 2017</span>


   [<a id="ref-RFC7396" name="ref-RFC7396">RFC7396</a>]  Hoffman, P. and J. Snell, "JSON Merge Patch", <a href="rfc7396.html">RFC 7396</a>,
              DOI 10.17487/RFC7396, October 2014,
              &lt;<a href="http://www.rfc-editor.org/info/rfc7396">http://www.rfc-editor.org/info/rfc7396</a>&gt;.

   [<a id="ref-COAP-MGMNT" name="ref-COAP-MGMNT">COAP-MGMNT</a>]
              Stok, P., Bierman, A., Veillette, M., and A. Pelov, "CoAP
              Management Interface", Work in Progress,
              <a href="https://tools.ietf.org/html/draft-ietf-core-comi-00">draft-ietf-core-comi-00</a>, January 2017.

   [<a id="ref-CORE-APP" name="ref-CORE-APP">CORE-APP</a>] Hartke, K., <a href="https://www.google.com/search?sitesearch=tools.ietf.org%2Fhtml%2F&amp;q=inurl:draft-+%22CoRE+Application+Descriptions%22" style="text-decoration: none">"CoRE Application Descriptions"</a>, Work in
              Progress, <a href="https://tools.ietf.org/html/draft-hartke-core-apps-07">draft-hartke-core-apps-07</a>, February 2017.

   [<a id="ref-HTTP-SEARCH" name="ref-HTTP-SEARCH">HTTP-SEARCH</a>]
              Reschke, J., Malhotra, A., and J. Snell, "HTTP SEARCH
              Method", Work in Progress, <a href="https://tools.ietf.org/html/draft-snell-search-method-00">draft-snell-search-method-00</a>,
              April 2015.

Acknowledgements

   Klaus Hartke has pointed out some essential differences between CoAP
   and HTTP concerning PATCH and found a number of problems in an
   earlier draft version of <a href="#section-2">Section 2</a>.  We are grateful for discussions
   with Christian Amsuss, Andy Bierman, Timothy Carey, Paul Duffy,
   Matthias Kovatsch, Michel Veillette, Michael Verschoor, Thomas
   Watteyne, and Gengyu Wei.  Christian Groves provided detailed
   comments during the Working Group Last Call, and Christer Holmberg's
   Gen-ART review provided some further editorial improvement.  Further
   Last Call reviews were provided by Sheng Jiang and Phillip Hallam-
   Baker.  As usual, the IESG had some very good reviews, and we would
   like to specifically call out those by Alexey Melnikov (responsible
   AD) and Alissa Cooper.




















<span class="grey">van der Stok, et al.         Standards Track                   [Page 20]</span></pre>
<hr align="left" class="noprint" style="width: 96ex;"/><!--NewPage--><pre class="newpage"><a class="invisible" href="#page-21" id="page-21" name="page-21"> </a>
<span class="grey"><a href="rfc8132.html">RFC 8132</a>                    CoAP FETCH PATCH                  April 2017</span>


Authors' Addresses

   Peter van der Stok
   Consultant

   Email: consultancy@vanderstok.org


   Carsten Bormann
   Universitaet Bremen TZI
   Postfach 330440
   Bremen  D-28359
   Germany

   Phone: +49-421-218-63921
   Email: cabo@tzi.org


   Anuj Sehgal
   NAVOMI, Inc.

   Email: anuj.sehgal@navomi.com





























van der Stok, et al.         Standards Track                   [Page 21]

</pre><br/>
    <span class="noprint"><small><small>Html markup produced by rfcmarkup 1.126, available from
      <a href="https://tools.ietf.org/tools/rfcmarkup/">https://tools.ietf.org/tools/rfcmarkup/</a>
    </small></small></span>
  </div>




</body><!-- Mirrored from tools.ietf.org/html/rfc8132 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 06 Mar 2018 23:18:17 GMT --></html>