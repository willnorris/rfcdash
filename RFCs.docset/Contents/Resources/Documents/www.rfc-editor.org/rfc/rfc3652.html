<html><head></head><body><pre>Network Working Group                                             S. Sun
Request for Comments: 3652                                     S. Reilly
Category: Informational                                        L. Lannom
                                                              J. Petrone
                                                                    CNRI
                                                           November 2003


            <span class="h1">Handle System Protocol (ver 2.1) Specification</span>

Status of this Memo

   This memo provides information for the Internet community.  It does
   not specify an Internet standard of any kind.  Distribution of this
   memo is unlimited.

Copyright Notice

   Copyright (C) The Internet Society (2003).  All Rights Reserved.

IESG Note

   Several groups within the IETF and IRTF have discussed the Handle
   System and its relationship to existing systems of identifiers.  The
   IESG wishes to point out that these discussions have not resulted in
   IETF consensus on the described Handle System, nor on how it might
   fit into the IETF architecture for identifiers.  Though there has
   been discussion of handles as a form of URI, specifically as a URN,
   these documents describe an alternate view of how namespaces and
   identifiers might work on the Internet and include characterizations
   of existing systems which may not match the IETF consensus view.

Abstract

   The Handle System is a general-purpose global name service that
   allows secured name resolution and administration over the public
   Internet.  This document describes the protocol used for client
   software to access the Handle System for both handle resolution and
   administration.  The protocol specifies the procedure for a client
   software to locate the responsible handle server of any given handle.
   It also defines the messages exchanged between the client and server
   for any handle operation.









<span class="grey">Sun, et al.                  Informational                      [Page 1]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-2"></span>
<span class="grey"><a href="./rfc3652">RFC 3652</a>             Handle System Protocol (v2.1)         November 2003</span>


Table of Contents

   <a href="#section-1">1</a>.  Overview . . . . . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-3">3</a>
   <a href="#section-2">2</a>.  Protocol Elements. . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-4">4</a>
       <a href="#section-2.1">2.1</a>.  Conventions. . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-4">4</a>
             <a href="#section-2.1.1">2.1.1</a>.  Data Transmission Order. . . . . . . . . . . . .  <a href="#page-4">4</a>
             <a href="#section-2.1.2">2.1.2</a>.  Transport Layer. . . . . . . . . . . . . . . . .  <a href="#page-5">5</a>
             <a href="#section-2.1.3">2.1.3</a>.  Character Case . . . . . . . . . . . . . . . . .  <a href="#page-6">6</a>
             <a href="#section-2.1.4">2.1.4</a>.  Standard String Type: UTF8-String. . . . . . . .  <a href="#page-7">7</a>
       <a href="#section-2.2">2.2</a>.  Common Elements. . . . . . . . . . . . . . . . . . . . .  <a href="#page-7">7</a>
             <a href="#section-2.2.1">2.2.1</a>.  Message Envelope . . . . . . . . . . . . . . . .  <a href="#page-8">8</a>
             <a href="#section-2.2.2">2.2.2</a>.  Message Header . . . . . . . . . . . . . . . . . <a href="#page-11">11</a>
             <a href="#section-2.2.3">2.2.3</a>.  Message Body . . . . . . . . . . . . . . . . . . <a href="#page-17">17</a>
             <a href="#section-2.2.4">2.2.4</a>.  Message Credential . . . . . . . . . . . . . . . <a href="#page-18">18</a>
       <a href="#section-2.3">2.3</a>.  Message Transmission . . . . . . . . . . . . . . . . . . <a href="#page-20">20</a>
   <a href="#section-3">3</a>.  Handle Protocol Operations . . . . . . . . . . . . . . . . . . <a href="#page-21">21</a>
       <a href="#section-3.1">3.1</a>.  Client Bootstrapping . . . . . . . . . . . . . . . . . . <a href="#page-21">21</a>
             3.1.1.  Global Handle Registry and its Service
                     Information. . . . . . . . . . . . . . . . . . . <a href="#page-21">21</a>
             <a href="#section-3.1.2">3.1.2</a>.  Locating the Handle System Service Component . . <a href="#page-22">22</a>
             <a href="#section-3.1.3">3.1.3</a>.  Selecting the Responsible Server . . . . . . . . <a href="#page-23">23</a>
       <a href="#section-3.2">3.2</a>.  Query Operation. . . . . . . . . . . . . . . . . . . . . <a href="#page-23">23</a>
             <a href="#section-3.2.1">3.2.1</a>.  Query Request. . . . . . . . . . . . . . . . . . <a href="#page-24">24</a>
             <a href="#section-3.2.2">3.2.2</a>.  Successful Query Response. . . . . . . . . . . . <a href="#page-25">25</a>
             <a href="#section-3.2.3">3.2.3</a>.  Unsuccessful Query Response. . . . . . . . . . . <a href="#page-26">26</a>
       <a href="#section-3.3">3.3</a>.  Error Response from Server . . . . . . . . . . . . . . . <a href="#page-26">26</a>
       <a href="#section-3.4">3.4</a>.  Service Referral . . . . . . . . . . . . . . . . . . . . <a href="#page-27">27</a>
       <a href="#section-3.5">3.5</a>.  Client Authentication. . . . . . . . . . . . . . . . . . <a href="#page-28">28</a>
             <a href="#section-3.5.1">3.5.1</a>.  Challenge from Server to Client. . . . . . . . . <a href="#page-29">29</a>
             <a href="#section-3.5.2">3.5.2</a>.  Challenge-Response from Client to Server . . . . <a href="#page-30">30</a>
             <a href="#section-3.5.3">3.5.3</a>.  Challenge-Response Verification-Request. . . . . <a href="#page-33">33</a>
             <a href="#section-3.5.4">3.5.4</a>.  Challenge-Response Verification-Response . . . . <a href="#page-33">33</a>
       <a href="#section-3.6">3.6</a>.  Handle Administration. . . . . . . . . . . . . . . . . . <a href="#page-34">34</a>
             <a href="#section-3.6.1">3.6.1</a>.  Add Handle Value(s). . . . . . . . . . . . . . . <a href="#page-34">34</a>
             <a href="#section-3.6.2">3.6.2</a>.  Remove Handle Value(s) . . . . . . . . . . . . . <a href="#page-35">35</a>
             <a href="#section-3.6.3">3.6.3</a>.  Modify Handle Value(s) . . . . . . . . . . . . . <a href="#page-36">36</a>
             <a href="#section-3.6.4">3.6.4</a>.  Create Handle. . . . . . . . . . . . . . . . . . <a href="#page-37">37</a>
             <a href="#section-3.6.5">3.6.5</a>.  Delete Handle. . . . . . . . . . . . . . . . . . <a href="#page-39">39</a>
       <a href="#section-3.7">3.7</a>.  Naming Authority (NA) Administration . . . . . . . . . . <a href="#page-40">40</a>
             <a href="#section-3.7.1">3.7.1</a>.  List Handle(s) under a Naming Authority. . . . . <a href="#page-40">40</a>
             3.7.2.  List Sub-Naming Authorities under a Naming
                     Authority. . . . . . . . . . . . . . . . . . . . <a href="#page-41">41</a>
       <a href="#section-3.8">3.8</a>.  Session and Session Management . . . . . . . . . . . . . <a href="#page-42">42</a>
             <a href="#section-3.8.1">3.8.1</a>.  Session Setup Request. . . . . . . . . . . . . . <a href="#page-43">43</a>
             <a href="#section-3.8.2">3.8.2</a>.  Session Setup Response . . . . . . . . . . . . . <a href="#page-46">46</a>
             <a href="#section-3.8.3">3.8.3</a>.  Session Key Exchange . . . . . . . . . . . . . . <a href="#page-47">47</a>
             <a href="#section-3.8.4">3.8.4</a>.  Session Termination. . . . . . . . . . . . . . . <a href="#page-48">48</a>




<span class="grey">Sun, et al.                  Informational                      [Page 2]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-3"></span>
<span class="grey"><a href="./rfc3652">RFC 3652</a>             Handle System Protocol (v2.1)         November 2003</span>


   <a href="#section-4">4</a>.  Implementation Guidelines. . . . . . . . . . . . . . . . . . . <a href="#page-48">48</a>
       <a href="#section-4.1">4.1</a>.  Server Implementation. . . . . . . . . . . . . . . . . . <a href="#page-48">48</a>
       <a href="#section-4.2">4.2</a>.  Client Implementation. . . . . . . . . . . . . . . . . . <a href="#page-49">49</a>
   <a href="#section-5">5</a>.  Security Considerations. . . . . . . . . . . . . . . . . . . . <a href="#page-49">49</a>
   <a href="#section-6">6</a>.  Acknowledgements . . . . . . . . . . . . . . . . . . . . . . . <a href="#page-50">50</a>
   <a href="#section-7">7</a>.  Informative References . . . . . . . . . . . . . . . . . . . . <a href="#page-50">50</a>
   <a href="#section-8">8</a>.  Authors' Addresses . . . . . . . . . . . . . . . . . . . . . . <a href="#page-52">52</a>
   <a href="#section-9">9</a>.  Full Copyright Statement . . . . . . . . . . . . . . . . . . . <a href="#page-53">53</a>

<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/1.%20%20Overview"></a><a class="selflink" href="#section-1" id="section-1">1</a>.  Overview</span>

   The Handle System provides a general-purpose, secured global name
   service for the Internet.  It was originally conceived and described
   in a paper by Robert Kahn and Robert Wilensky [<a href="#ref-18" title="R. Wilensky">18</a>] in 1995.  The
   Handle System defines a client server protocol in which client
   software submits requests via a network to handle servers.  Each
   request describes the operation to be performed on the server.  The
   server will process the request and return a message indicating the
   result of the operation.  This document specifies the protocol for
   client software to access a handle server for handle resolution and
   administration.  It does not include the description of the protocol
   used to manage handle servers.  A discussion of the management
   protocol is out of the scope of this document and will be made
   available in a separate document.  The document assumes that readers
   are familiar with the basic concepts of the Handle System as
   introduced in the "Handle System Overview" [<a href="#ref-1" title='"Handle System Overview"'>1</a>], as well as the data
   model and service definition given in the "Handle System Namespace
   and Service Definition" [<a href="#ref-2" title='"Handle System Namespace and Service Definition"'>2</a>].

   The Handle System consists of a set of service components as defined
   in [<a href="#ref-2" title='"Handle System Namespace and Service Definition"'>2</a>].  From the client's point of view, the Handle System is a
   distributed database for handles.  Different handles under the Handle
   System may be maintained by different handle servers at different
   network locations.  The Handle protocol specifies the procedure for a
   client to locate the responsible handle server of any given handle.
   It also defines the messages exchanged between the client and server
   for any handle operation.

   Some key aspects of the Handle protocol include:

      o  The Handle protocol supports both handle resolution and
         administration.  The protocol follows the data and service
         model defined in [<a href="#ref-2" title='"Handle System Namespace and Service Definition"'>2</a>].

      o  A client may authenticate any server response based on the
         server's digital signature.





<span class="grey">Sun, et al.                  Informational                      [Page 3]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-4"></span>
<span class="grey"><a href="./rfc3652">RFC 3652</a>             Handle System Protocol (v2.1)         November 2003</span>


      o  A server may authenticate its client as handle administrator
         via the Handle authentication protocol.  The Handle
         authentication protocol is a challenge-response protocol that
         supports both public-key and secret-key based authentication.

      o  A session may be established between the client and server so
         that authentication information and network resources (e.g.,
         TCP connection) may be shared among multiple operations.  A
         session key can be established to achieve data integrity and
         confidentiality.

      o  The protocol can be extended to support new operations.
         Controls can be used to extend the existing operations.  The
         protocol is defined to allow future backward compatibility.

      o  Distributed service architecture.  Support service referral
         among different service components.

      o  Handles and their data types are based on the ISO-10646
         (Unicode 2.0) character set.  UTF-8 [<a href="#ref-3" title='"UTF-8, a transformation format of ISO 10646"'>3</a>] is the mandated
         encoding under the Handle protocol.

   The Handle protocol (version 2.1) specified in this document has
   changed significantly from its earlier versions.  These changes are
   necessary due to changes made in the Handle System data model and the
   service model.  Servers that implement this protocol may continue to
   support earlier versions of the protocol by checking the protocol
   version specified in the Message Envelope (see <a href="#section-2.2.1">section 2.2.1</a>).

<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/2.%20%20Protocol%20Elements"></a><a class="selflink" href="#section-2" id="section-2">2</a>.  Protocol Elements</span>

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/2.1.%20%20Conventions"></a><a class="selflink" href="#section-2.1" id="section-2.1">2.1</a>.  Conventions</span>

   The following conventions are followed by the Handle protocol to
   ensure interoperability among different implementations.

<span class="h4"><a class="dashAnchor" name="//apple_ref/cpp/Section/2.1.1.%20%20Data%20Transmission%20Order"></a><a class="selflink" href="#section-2.1.1" id="section-2.1.1">2.1.1</a>.  Data Transmission Order</span>

   The order of transmission of data packets follows the network byte
   order (also called the Big-Endian [<a href="#ref-11" title='"On Holy Wars and a Plea for Peace"'>11</a>]).  That is, when a data-gram
   consists of a group of octets, the order of transmission of those
   octets follows their natural order from left to right and from top to
   bottom, as they are read in English.  For example, in the following
   diagram, the octets are transmitted in the order they are numbered.







<span class="grey">Sun, et al.                  Informational                      [Page 4]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-5"></span>
<span class="grey"><a href="./rfc3652">RFC 3652</a>             Handle System Protocol (v2.1)         November 2003</span>


          0                   1
          0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5
         .-------------------------------.
         |       1       |       2       |
         |-------------------------------|
         |       3       |       4       |
         |-------------------------------|
         |       5       |       6       |
         '-------------------------------'

   If an octet represents a numeric quantity, the left most bit is the
   most significant bit.  For example, the following diagram represents
   the value 170 (decimal).

          0 1 2 3 4 5 6 7
         .---------------.
         |1 0 1 0 1 0 1 0|
         '---------------'

   Similarly, whenever a multi-octet field represents a numeric
   quantity, the left most bit is the most significant bit and the most
   significant octet of the whole field is transmitted first.

<span class="h4"><a class="dashAnchor" name="//apple_ref/cpp/Section/2.1.2.%20%20Transport%20Layer"></a><a class="selflink" href="#section-2.1.2" id="section-2.1.2">2.1.2</a>.  Transport Layer</span>

   The Handle protocol is designed so that messages may be transmitted
   either as separate data-grams over UDP or as a continuous byte stream
   via a TCP connection.  The recommended port number for both UDP and
   TCP is 2641.

   UDP Usage

      Messages carried by UDP are restricted to 512 bytes (not including
      the IP or UDP header).  Longer messages must be fragmented into
      UDP packets where each packet carries a proper sequence number in
      the Message Envelope (see <a href="#section-2.2.1">Section 2.2.1</a>).

      The optimum retransmission policy will vary depending on the
      network or server performance, but the following are recommended:

         o  The client should try other servers or service interfaces
            before repeating a request to the same server address.

         o  The retransmission interval should be based on prior
            statistics if possible.  Overly aggressive retransmission
            should be avoided to prevent network congestion.  The
            recommended retransmission interval is 2-5 seconds.




<span class="grey">Sun, et al.                  Informational                      [Page 5]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-6"></span>
<span class="grey"><a href="./rfc3652">RFC 3652</a>             Handle System Protocol (v2.1)         November 2003</span>


         o  When transmitting large amounts of data, TCP-friendly
            congestion control, such as an interface to the Congestion
            Manager [<a href="#ref-12" title='"The Congestion Manager"'>12</a>], should be implemented whenever possible to
            avoid unfair consumption of the bandwidth against TCP-based
            applications.  Details of the congestion control will be
            discussed in a separate document.

   TCP Usage

      Messages under the Handle protocol can be mapped directly into a
      TCP byte-stream.  However, the size of each message is limited by
      the range of a 4-byte unsigned integer.  Longer messages may be
      fragmented into multiple messages before the transmission and
      reassembled at the receiving end.

      Several connection management policies are recommended:

         o  The server should support multiple connections and should
            not block other activities waiting for TCP data.

         o  By default, the server should close the connection after
            completing the request.  However, if the request asks to
            keep the connection open, the server should assume that the
            client will initiate connection closing.

<span class="h4"><a class="dashAnchor" name="//apple_ref/cpp/Section/2.1.3.%20%20Character%20Case"></a><a class="selflink" href="#section-2.1.3" id="section-2.1.3">2.1.3</a>.  Character Case</span>

   Handles are character strings based on the ISO-10646 character set
   and must be encoded in UTF-8.  By default, handle characters are
   treated as case-sensitive under the Handle protocol.  A handle
   service, however, may be implemented in such a way that ASCII
   characters are processed case-insensitively.  For example, the Global
   Handle Registry (GHR) provides a handle service where ASCII
   characters are processed in a case-insensitive manner.  This suggests
   that ASCII characters in any naming authority are case-insensitive.

   When handles are created under a case-insensitive handle server,
   their original case should be preserved.  To avoid any confusion, the
   server should avoid creating any handle whose character string
   matches that of an existing handle, ignoring the case difference.
   For example, if the handle "X/Y" was already created, the server
   should refuse any request to create the handle "x/y" or any of its
   case variations.








<span class="grey">Sun, et al.                  Informational                      [Page 6]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-7"></span>
<span class="grey"><a href="./rfc3652">RFC 3652</a>             Handle System Protocol (v2.1)         November 2003</span>


<span class="h4"><a class="dashAnchor" name="//apple_ref/cpp/Section/2.1.4.%20%20Standard%20String%20Type%3A%20UTF8-String"></a><a class="selflink" href="#section-2.1.4" id="section-2.1.4">2.1.4</a>.  Standard String Type: UTF8-String</span>

   Handles are transmitted as UTF8-Strings under the Handle protocol.
   Throughout this document, UTF8-String stands for the data type that
   consists of a 4-byte unsigned integer followed by a character string
   in UTF-8 encoding.  The leading integer specifies the number of
   octets of the character string.

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/2.2.%20%20Common%20Elements"></a><a class="selflink" href="#section-2.2" id="section-2.2">2.2</a>.  Common Elements</span>

   Each message exchanged under the system protocol consists of four
   sections (see Fig. 2.2).  Some of these sections (e.g., the Message
   Body) may be empty depending on the protocol operation.

   The Message Envelope must always be present.  It has a fixed size of
   20 octets.  The Message Envelope does not carry any application layer
   information and is primarily used to help deliver the message.
   Content in the Message Envelope is not protected by the digital
   signature in the Message Credential.

   The Message Header must always be present as well.  It has a fixed
   size of 24 octets and holds the common data fields of all messages
   exchanged between client and server.  These include the operation
   code, the response code, and the control options for each protocol
   operation.  Content in the Message Header is protected by the digital
   signature in the Message Credential.

   The Message Body contains data specific to each protocol operation.
   Its format varies according to the operation code and the response
   code in the Message Header.  The Message Body may be empty.  Content
   in the Message Body is protected by the digital signature in the
   Message Credential.

   The Message Credential provides a mechanism for transport security
   for any message exchanged between the client and server.  A non-empty
   Message Credential may contain the digital signature from the
   originator of the message or the one-way Message Authentication Code
   (MAC) based on a pre-established session key.  The Message Credential
   may be used to authenticate the message between the client and
   server.  It can also be used to check data integrity after its
   transmission.










<span class="grey">Sun, et al.                  Informational                      [Page 7]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-8"></span>
<span class="grey"><a href="./rfc3652">RFC 3652</a>             Handle System Protocol (v2.1)         November 2003</span>


      .----------------------.
      |                      |  ; Message wrapper for proper message
      |   Message Envelope   |  ; delivery.  Not protected by the
      |                      |  ; digital signature in the Message
      |                      |  ; Credential.
      |----------------------|
      |                      |  ; Common data fields for all handle
      |   Message Header     |  ; operations.
      |                      |
      |----------------------|
      |                      |  ; Specific data fields for each
      |   Message Body       |  ; request/response.
      |                      |
      |----------------------|
      |                      |  ; Contains digital signature or
      |  Message Credential  |  ; message authentication code (MAC)
      |                      |  ; upon Message Header and Message
      '----------------------'  ; Body.

         Fig 2.2: Message format under the Handle protocol

<span class="h4"><a class="dashAnchor" name="//apple_ref/cpp/Section/2.2.1.%20%20Message%20Envelope"></a><a class="selflink" href="#section-2.2.1" id="section-2.2.1">2.2.1</a>.  Message Envelope</span>

   Each message begins with a Message Envelope under the Handle
   protocol.  If a message has to be truncated before its transmission,
   each truncated portion must also begin with a Message Envelope.

   The Message Envelope allows the reassembly of the message at the
   receiving end.  It has a fixed size of 20 octets and consists of
   seven fields:

       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      .---------------------------------------------------------------.
      | MajorVersion  | MinorVersion  |       MessageFlag             |
      |---------------------------------------------------------------|
      |               SessionId                                       |
      |---------------------------------------------------------------|
      |               RequestId                                       |
      |---------------------------------------------------------------|
      |               SequenceNumber                                  |
      |---------------------------------------------------------------|
      |               MessageLength                                   |
      '---------------------------------------------------------------'







<span class="grey">Sun, et al.                  Informational                      [Page 8]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-9"></span>
<span class="grey"><a href="./rfc3652">RFC 3652</a>             Handle System Protocol (v2.1)         November 2003</span>


<span class="h5"><a class="dashAnchor" name="//apple_ref/cpp/Section/2.2.1.1.%20%20%3CMajorVersion%3E%20and%20%3CMinorVersion%3E"></a><a class="selflink" href="#section-2.2.1.1" id="section-2.2.1.1">2.2.1.1</a>.  &lt;MajorVersion&gt; and &lt;MinorVersion&gt;</span>

   The &lt;MajorVersion&gt; and &lt;MinorVersion&gt; are used to identify the
   version of the Handle protocol.  Each of them is defined as a one-
   byte unsigned integer.  This specification defines the protocol
   version whose &lt;MajorVersion&gt; is 2 and &lt;MinorVersion&gt; is 1.

   &lt;MajorVersion&gt; and &lt;MinorVersion&gt; are designed to allow future
   backward compatibility.  A difference in &lt;MajorVersion&gt; indicates
   major variation in the protocol format and the party with the lower
   &lt;MajorVersion&gt; will have to upgrade its software to ensure precise
   communication.  An increment in &lt;MinorVersion&gt; is made when
   additional capabilities are added to the protocol without any major
   change to the message format.

<span class="h5"><a class="dashAnchor" name="//apple_ref/cpp/Section/2.2.1.2.%20%20%3CMessageFlag%3E"></a><a class="selflink" href="#section-2.2.1.2" id="section-2.2.1.2">2.2.1.2</a>.  &lt;MessageFlag&gt;</span>

   The &lt;MessageFlag&gt; consists of two octets defined as follows:

                                               1   1   1   1   1   1
       0   1   2   3   4   5   6   7   8   9   0   1   2   3   4   5
      .---------------------------------------------------------------.
      |CP |EC |TC |       Reserved                                    |
      '---------------------------------------------------------------'

   Bit 0 is the CP (ComPressed) flag that indicates whether the message
   (excluding the Message Envelope) is compressed.  If the CP bit is set
   (to 1), the message is compressed.  Otherwise, the message is not
   compressed.  The Handle protocol uses the same compression method as
   used by the FTP protocol[8].

   Bit 1 is the EC (EnCrypted) flag that indicates whether the message
   (excluding the Message Envelope) is encrypted.  The EC bit should
   only be set under an established session where a session key is in
   place.  If the EC bit is set (to 1), the message is encrypted using
   the session key.  Otherwise the message is not encrypted.

   Bit 2 is the TC (TrunCated) flag that indicates whether this is a
   truncated message.  Message truncation happens most often when
   transmitting a large message over the UDP protocol.  Details of
   message truncation (or fragmentation) will be discussed in <a href="#section-2.3">section</a>
   <a href="#section-2.3">2.3</a>.

   Bits 3 to 15 are currently reserved and must be set to zero.







<span class="grey">Sun, et al.                  Informational                      [Page 9]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-10"></span>
<span class="grey"><a href="./rfc3652">RFC 3652</a>             Handle System Protocol (v2.1)         November 2003</span>


<span class="h5"><a class="dashAnchor" name="//apple_ref/cpp/Section/2.2.1.3.%20%20%3CSessionId%3E"></a><a class="selflink" href="#section-2.2.1.3" id="section-2.2.1.3">2.2.1.3</a>.  &lt;SessionId&gt;</span>

   The &lt;SessionId&gt; is a four-byte unsigned integer that identifies a
   communication session between the client and server.

   Session and its &lt;SessionId&gt; are assigned by a server, either upon an
   explicit request from a client or when multiple message exchanges are
   expected to fulfill the client's request.  For example, the server
   will assign a unique &lt;SessionId&gt; in its response if it has to
   authenticate the client.  A client may explicitly ask the server to
   set up a session as a virtually private communication channel like
   SSL [<a href="#ref-4" title="P. Karlton">4</a>].  Requests from clients without an established session must
   have their &lt;SessionId&gt; set to zero.  The server must assign a unique
   non-zero &lt;SessionId&gt; for each new session.  It is also responsible
   for terminating those sessions that are not in use after some period
   of time.

   Both clients and servers must maintain the same &lt;SessionId&gt; for
   messages exchanged under an established session.  A message whose
   &lt;SessionId&gt; is zero indicates that no session has been established.

   The session and its state information may be shared among multiple
   handle operations.  They may also be shared over multiple TCP
   connections as well.  Once a session is established, both client and
   server must maintain their state information according to the
   &lt;SessionId&gt;.  The state information may include the stage of the
   conversation, the other party's authentication information, and the
   session key that was established for message encryption or
   authentication.  Details of these are discussed in <a href="#section-3.8">section 3.8</a>.

<span class="h5"><a class="dashAnchor" name="//apple_ref/cpp/Section/2.2.1.4.%20%20%3CRequestId%3E"></a><a class="selflink" href="#section-2.2.1.4" id="section-2.2.1.4">2.2.1.4</a>.  &lt;RequestId&gt;</span>

   Each request from a client is identified by a &lt;RequestId&gt;, a 4-byte
   unsigned integer set by the client.  Each &lt;RequestId&gt; must be unique
   from all other outstanding requests from the same client.  The
   &lt;RequestId&gt; allows the client to keep track of its requests, and any
   response from the server must include the correct &lt;RequestId&gt;.

<span class="h5"><a class="dashAnchor" name="//apple_ref/cpp/Section/2.2.1.5.%20%20%3CSequenceNumber%3E"></a><a class="selflink" href="#section-2.2.1.5" id="section-2.2.1.5">2.2.1.5</a>.  &lt;SequenceNumber&gt;</span>

   Messages under the Handle protocol may be truncated during their
   transmission (e.g., under UDP).  The &lt;SequenceNumber&gt; is a 4-byte
   unsigned integer used as a counter to keep track of each truncated
   portion of the original message.  The message recipient can
   reassemble the original message based on the &lt;SequenceNumber&gt;.  The
   &lt;SequenceNumber&gt; must start with 0 for each message.  Each truncated
   message must set its TC flag in the Message Envelope.  Messages that
   are not truncated must set their &lt;SequenceNumber&gt; to zero.



<span class="grey">Sun, et al.                  Informational                     [Page 10]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-11"></span>
<span class="grey"><a href="./rfc3652">RFC 3652</a>             Handle System Protocol (v2.1)         November 2003</span>


<span class="h5"><a class="dashAnchor" name="//apple_ref/cpp/Section/2.2.1.6.%20%20%3CMessageLen%3E"></a><a class="selflink" href="#section-2.2.1.6" id="section-2.2.1.6">2.2.1.6</a>.  &lt;MessageLen&gt;</span>

   A 4-byte unsigned integer that specifies the total number of octets
   of any message, excluding those in the Message Envelope.  The length
   of any single message exchanged under the Handle protocol is limited
   by the range of a 4-byte unsigned integer.  Longer data can be
   transmitted as multiple messages with a common &lt;RequestId&gt;.

<span class="h4"><a class="dashAnchor" name="//apple_ref/cpp/Section/2.2.2.%20%20%20Message%20Header"></a><a class="selflink" href="#section-2.2.2" id="section-2.2.2">2.2.2</a>.   Message Header</span>

   The Message Header contains the common data elements among any
   protocol operation.  It has a fixed size of 24 octets and consists of
   eight fields.

       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      .---------------------------------------------------------------.
      |                     OpCode                                    |
      |---------------------------------------------------------------|
      |                     ResponseCode                              |
      |---------------------------------------------------------------|
      |                     OpFlag                                    |
      |---------------------------------------------------------------|
      |     SiteInfoSerialNumber      | RecursionCount|               |
      |---------------------------------------------------------------|
      |                     ExpirationTime                            |
      |---------------------------------------------------------------|
      |                     BodyLength                                |
      '---------------------------------------------------------------'

   Every message that is not truncated must have a Message Header.  If a
   message has to be truncated for its transmission, the Message Header
   must appear in the first truncated portion of the message.

   This is different from the Message Envelope, which appears in each
   truncated portion of the message.

<span class="h5"><a class="dashAnchor" name="//apple_ref/cpp/Section/2.2.2.1.%20%20%3COpCode%3E"></a><a class="selflink" href="#section-2.2.2.1" id="section-2.2.2.1">2.2.2.1</a>.  &lt;OpCode&gt;</span>

   The &lt;OpCode&gt; stands for operation code, which is a four-byte unsigned
   integer that specifies the intended operation.  The following table
   lists the &lt;OpCode&gt;s that MUST be supported by all implementations in
   order to conform to the base protocol specification.  Each operation
   code is given a symbolic name that is used throughout this document
   for easy reference.






<span class="grey">Sun, et al.                  Informational                     [Page 11]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-12"></span>
<span class="grey"><a href="./rfc3652">RFC 3652</a>             Handle System Protocol (v2.1)         November 2003</span>


       Op_Code    Symbolic Name            Remark
      ---------   -------------            ------

          0       OC_RESERVED              Reserved
          1       OC_RESOLUTION            Handle query
          2       OC_GET_SITEINFO          Get HS_SITE values

        100       OC_CREATE_HANDLE         Create new handle
        101       OC_DELETE_HANDLE         Delete existing handle
        102       OC_ADD_VALUE             Add handle value(s)
        103       OC_REMOVE_VALUE          Remove handle value(s)
        104       OC_MODIFY_VALUE          Modify handle value(s)
        105       OC_LIST_HANDLE           List handles
        106       OC_LIST_NA               List sub-naming authorities

        200       OC_CHALLENGE_RESPONSE    Response to challenge
        201       OC_VERIFY_RESPONSE       Verify challenge response

        300
         :        { Reserved for handle server administration }
        399

        400       OC_SESSION_SETUP         Session setup request
        401       OC_SESSION_TERMINATE     Session termination request
        402       OC_SESSION_EXCHANGEKEY   Session key exchange

   A detailed description of each of these &lt;OpCode&gt;s can be found in
   <a href="#section-3">section 3</a> of this document.  In general, clients use the &lt;OpCode&gt; to
   tell the server what kind of handle operation they want to
   accomplish.  Response from the server must maintain the same &lt;OpCode&gt;
   as the original request and use the &lt;ResponseCode&gt; to indicate the
   result.

<span class="h5"><a class="dashAnchor" name="//apple_ref/cpp/Section/2.2.2.2.%20%20%3CResponseCode%3E"></a><a class="selflink" href="#section-2.2.2.2" id="section-2.2.2.2">2.2.2.2</a>.  &lt;ResponseCode&gt;</span>

   The &lt;ResponseCode&gt; is a 4-byte unsigned integer that is given by a
   server to indicate the result of any service request.  The list of
   &lt;ResponseCode&gt;s used in the Handle protocol is defined in the
   following table.  Each response code is given a symbolic name that is
   used throughout this document for easy reference.











<span class="grey">Sun, et al.                  Informational                     [Page 12]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-13"></span>
<span class="grey"><a href="./rfc3652">RFC 3652</a>             Handle System Protocol (v2.1)         November 2003</span>


      Res. Code   Symbolic Name            Remark
      ---------   -------------            ------

         0        RC_RESERVED              Reserved for request
         1        RC_SUCCESS               Success response
         2        RC_ERROR                 General error
         3        RC_SERVER_BUSY           Server too busy to respond
         4        RC_PROTOCOL_ERROR        Corrupted or
                                           unrecognizable message
         5        RC_OPERATION_DENIED      Unsupported operation
         6        RC_RECUR_LIMIT_EXCEEDED  Too many recursions for
                                           the request

         100      RC_HANDLE_NOT_FOUND      Handle not found
         101      RC_HANDLE_ALREADY_EXIST  Handle already exists
         102      RC_INVALID_HANDLE        Encoding (or syntax) error

         200      RC_VALUE_NOT_FOUND       Value not found
         201      RC_VALUE_ALREADY_EXIST   Value already exists
         202      RC_VALUE_INVALID         Invalid handle value

         300      RC_EXPIRED_SITE_INFO     SITE_INFO out of date
         301      RC_SERVER_NOT_RESP       Server not responsible
         302      RC_SERVICE_REFERRAL      Server referral
         303      RC_NA_DELEGATE           Naming authority delegation
                                           takes place.

         400      RC_NOT_AUTHORIZED        Not authorized/permitted
         401      RC_ACCESS_DENIED         No access to data
         402      RC_AUTHEN_NEEDED         Authentication required
         403      RC_AUTHEN_FAILED         Failed to authenticate
         404      RC_INVALID_CREDENTIAL    Invalid credential
         405      RC_AUTHEN_TIMEOUT        Authentication timed out
         406      RC_UNABLE_TO_AUTHEN      Unable to authenticate

         500      RC_SESSION_TIMEOUT       Session expired
         501      RC_SESSION_FAILED        Unable to establish session
         502      RC_NO_SESSION_KEY        No session yet available
         503      RC_SESSION_NO_SUPPORT    Session not supported
         504      RC_SESSION_KEY_INVALID   Invalid session key

         900      RC_TRYING                Request under processing
         901      RC_FORWARDED             Request forwarded to
                                           another server
         902      RC_QUEUED                Request queued for later
                                           processing





<span class="grey">Sun, et al.                  Informational                     [Page 13]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-14"></span>
<span class="grey"><a href="./rfc3652">RFC 3652</a>             Handle System Protocol (v2.1)         November 2003</span>


   Response codes under 10000 are reserved for system use.  Any message
   with a response code under 10000 but not listed above should be
   treated as an unknown error.  Response codes above 10000 are user
   defined and can be used for application specific purposes.

   Detailed descriptions of these &lt;ResponseCode&gt;s can be found in
   <a href="#section-3">section 3</a> of this document.  In general, any request from a client
   must have its &lt;ResponseCode&gt; set to 0.  The response message from the
   server must have a non-zero &lt;ResponseCode&gt; to indicate the result.
   For example, a response message from a server with &lt;ResponseCode&gt; set
   to RC_SUCCESS indicates that the server has successfully fulfilled
   the client's request.

<span class="h5"><a class="dashAnchor" name="//apple_ref/cpp/Section/2.2.2.3.%20%20%3COpFlag%3E"></a><a class="selflink" href="#section-2.2.2.3" id="section-2.2.2.3">2.2.2.3</a>.  &lt;OpFlag&gt;</span>

   The &lt;OpFlag&gt; is a 32-bit bit-mask that defines various control
   options for protocol operation.  The following figure shows the
   location of each option flag in the &lt;OpFlag&gt; field.

                                              1   1   1   1   1   1
      0   1   2   3   4   5   6   7   8   9   0   1   2   3   4   5
      .---------------------------------------------------------------.
      |AT |CT |ENC|REC|CA |CN |KC |PO |RD |    Reserved               |
      |---------------------------------------------------------------|
      |                              Reserved                         |
      '---------------------------------------------------------------'

       AT   -  AuThoritative bit.  A request with the AT bit set (to 1)
               indicates that the request should be directed to the
               primary service site (instead of any mirroring sites).  A
               response message with the AT bit set (to 1) indicates
               that the message is returned from a primary server
               (within the primary service site).

       CT   -  CerTified bit.  A request with the CT bit set (to 1) asks
               the server to sign its response with its digital
               signature.  A response with the CT bit set (to 1)
               indicates that the message is signed.  The server must
               sign its response if the request has its CT bit set (to
               1).  If the server fails to provide a valid signature in
               its response, the client should discard the response and
               treat the request as failed.

       ENC  -  ENCryption bit.  A request with the ENC bit set (to 1)
               requires the server to encrypt its response using the
               pre-established session key.





<span class="grey">Sun, et al.                  Informational                     [Page 14]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-15"></span>
<span class="grey"><a href="./rfc3652">RFC 3652</a>             Handle System Protocol (v2.1)         November 2003</span>


       REC  -  RECursive bit.  A request with the REC bit set (to 1)
               asks the server to forward the query on behalf of the
               client if the request has to be processed by another
               handle server.  The server may honor the request by
               forwarding the request to the appropriate handle server
               and passing on any result back to the client.  The server
               may also deny any such request by sending a response
               with &lt;ResponseCode&gt; set to RC_SERVER_NOT_RESP.

       CA   -  Cache Authentication.  A request with the CA bit set (to
               1) asks the caching server (if any) to authenticate any
               server response (e.g., verifying the server's signature)
               on behalf of the client.  A response with the CA bit set
               (to 1) indicates that the response has been
               authenticated by the caching server.

       CN   -  ContiNuous bit.  A message with the CN bit set (to 1)
               tells the message recipient that more messages that are
               part of the same request (or response) will follow.  This
               happens if a request (or response) has data that is too
               large to fit into any single message and has to be
               fragmented into multiple messages.

       KC   -  Keep Connection bit.  A message with the KC bit set
               requires the message recipient to keep the TCP
               connection open (after the response is sent back).  This
               allows the same TCP connection to be used for multiple
               handle operations.

       PO   -  Public Only bit.  Used by query operations only.  A query
               request with the PO bit set (to 1) indicates that the
               client is only asking for handle values that have the
               PUB_READ permission.  A request with PO bit set to zero
               asks for all the handle values regardless of their read
               permission.  If any of the handle values require
               ADMIN_READ permission, the server must authenticate the
               client as the handle administrator.

       RD   -  Request-Digest bit.  A request with the RD bit set (to 1)
               asks the server to include in its response the message
               digest of the request.  A response message with the RD
               bit set (to 1) indicates that the first field in the
               Message Body contains the message digest of the original
               request.  The message digest can be used to check the
               integrity of the server response.  Details of these are
               discussed later in this document.





<span class="grey">Sun, et al.                  Informational                     [Page 15]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-16"></span>
<span class="grey"><a href="./rfc3652">RFC 3652</a>             Handle System Protocol (v2.1)         November 2003</span>


   All other bits in the &lt;OpFlag&gt; field are reserved and must be set to
   zero.

   In general, servers must honor the &lt;OpFlag&gt; specified in the request.
   If a requested option cannot be met, the server should return an
   error message with the proper &lt;ResponseCode&gt; as defined in the
   previous section.

<span class="h5"><a class="dashAnchor" name="//apple_ref/cpp/Section/2.2.2.4.%20%20%3CSiteInfoSerialNumber%3E"></a><a class="selflink" href="#section-2.2.2.4" id="section-2.2.2.4">2.2.2.4</a>.  &lt;SiteInfoSerialNumber&gt;</span>

   The &lt;SiteInfoSerialNumber&gt; is a two-byte unsigned integer.  The
   &lt;SiteInfoSerialNumber&gt; in a request refers to the &lt;SerialNumber&gt; of
   the HS_SITE value used by the client (to access the server).  Servers
   can check the &lt;SiteInfoSerialNumber&gt; in the request to find out if
   the client has up-to-date service information.

   When possible, the server should fulfill a client's request even if
   the service information used by the client is out-of-date.  However,
   the response message should specify the latest version of service
   information in the &lt;SiteInforSerialNumber&gt; field.  Clients with out-
   of-date service information can update the service information from
   the Global Handle Registry.  If the server cannot fulfill a client's
   request due to expired service information, it should reject the
   request and return an error message with &lt;ResponseCode&gt; set to
   RC_EXPIRED_SITE_INFO.

<span class="h5"><a class="dashAnchor" name="//apple_ref/cpp/Section/2.2.2.5.%20%20%3CRecursionCount%3E"></a><a class="selflink" href="#section-2.2.2.5" id="section-2.2.2.5">2.2.2.5</a>.  &lt;RecursionCount&gt;</span>

   The &lt;RecursionCount&gt; is a one-byte unsigned integer that specifies
   the number of service recursions.  Service recursion happens if the
   server has to forward the client's request to another server.  Any
   request directly from the client must have its &lt;RecursionCount&gt; set
   to 0.  If the server has to send a recursive request on behalf of the
   client, it must increment the &lt;RecursionCount&gt; by 1.  Any response
   from the server must maintain the same &lt;RecursionCount&gt; as the one in
   the request.  To prevent an infinite loop of service recursion, the
   server should be configurable to stop sending a recursive request
   when the &lt;RecursionCount&gt; reaches a certain value.

<span class="h5"><a class="dashAnchor" name="//apple_ref/cpp/Section/2.2.2.6.%20%20%3CExpirationTime%3E"></a><a class="selflink" href="#section-2.2.2.6" id="section-2.2.2.6">2.2.2.6</a>.  &lt;ExpirationTime&gt;</span>

   The &lt;ExpirationTime&gt; is a 4-byte unsigned integer that specifies the
   time when the message should be considered expired, relative to
   January 1st, 1970 GMT, in seconds.  It is set to zero if no
   expiration is expected.






<span class="grey">Sun, et al.                  Informational                     [Page 16]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-17"></span>
<span class="grey"><a href="./rfc3652">RFC 3652</a>             Handle System Protocol (v2.1)         November 2003</span>


<span class="h5"><a class="dashAnchor" name="//apple_ref/cpp/Section/2.2.2.7.%20%20%3CBodyLength%3E"></a><a class="selflink" href="#section-2.2.2.7" id="section-2.2.2.7">2.2.2.7</a>.  &lt;BodyLength&gt;</span>

   The &lt;BodyLength&gt; is a 4-byte unsigned integer that specifies the
   number of octets in the Message Body.  The &lt;BodyLength&gt; does not
   count the octets in the Message Header or those in the Message
   Credential.

<span class="h4"><a class="dashAnchor" name="//apple_ref/cpp/Section/2.2.3.%20%20Message%20Body"></a><a class="selflink" href="#section-2.2.3" id="section-2.2.3">2.2.3</a>.  Message Body</span>

   The Message Body always follows the Message Header.  The number of
   octets in the Message Body can be determined from the &lt;BodyLength&gt; in
   the Message Header.  The Message Body may be empty.  The exact format
   of the Message Body depends on the &lt;OpCode&gt; and the &lt;ResponseCode&gt; in
   the Message Header.  Details of the Message Body under each &lt;OpCode&gt;
   and &lt;ResponseCode&gt; are described in <a href="#section-3">section 3</a> of this document.

   For any response message, if the Message Header has its RD bit (in
   &lt;OpFlag&gt;) set to 1, the Message Body must begin with the message
   digest of the original request.  The message digest is defined as
   follows:

      &lt;RequestDigest&gt; ::= &lt;DigestAlgorithmIdentifier&gt;
                          &lt;MessageDigest&gt;

         where

            &lt;DigestAlgorithmIdentifier&gt;
            An octet that identifies the algorithm used to generate the
            message digest.  If the octet is set to 1, the digest is
            generated using the MD5 [<a href="#ref-9" title='"The MD5 Message-Digest Algorithm"'>9</a>] algorithm.  If the octet is set
            to 2, SHA-1 [<a href="#ref-10" title="FIPS PUB 180-1: Secure Hash Standard">10</a>] algorithm is used.

            &lt;MessageDigest&gt;
            The message digest itself.  It is calculated upon the
            Message Header and the Message Body of the original request.
            The length of the field is fixed according to the digest
            algorithm.  For MD5 algorithm, the length is 16 octets.  For
            SHA-1, the length is 20 octets.

   The Message Body may be truncated into multiple portions during its
   transmission (e.g., over UDP).  Recipients of such a message may
   reassemble the Message Body from each portion based on the
   &lt;SequenceNumber&gt; in the Message Envelope.








<span class="grey">Sun, et al.                  Informational                     [Page 17]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-18"></span>
<span class="grey"><a href="./rfc3652">RFC 3652</a>             Handle System Protocol (v2.1)         November 2003</span>


<span class="h4"><a class="dashAnchor" name="//apple_ref/cpp/Section/2.2.4.%20%20Message%20Credential"></a><a class="selflink" href="#section-2.2.4" id="section-2.2.4">2.2.4</a>.  Message Credential</span>

   The Message Credential is primarily used to carry any digital
   signatures signed by the message issuer.  It may also carry the
   Message Authentication Code (MAC) if a session key has been
   established.  The Message Credential is used to protect contents in
   the Message Header and the Message Body from being tampered with
   during transmission.  The format of the Message Credential is
   designed to be semantically compatible with PKCS#7 [<a href="#ref-5" title='"Public-Key Cryptography Standard PKCS#7"'>5</a>].  Each Message
   Credential consists of the following fields:

      0                   1                   2                   3
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      .---------------------------------------------------------------.
      |           CredentialLength                                    |
      |---------------------------------------------------------------|
      |   Version     |    Reserved   |       Options                 |
      |---------------------------------------------------------------|
      |
      |   Signer: &lt;Handle, Index&gt;
      |
      |---------------------------------------------------------------|
      |           Type      (UTF8-String)                             |
      |---------------------------------------------------------------|
      |
      |   SignedInfo: &lt;Length&gt; : 4-byte unsigned integer
      |               DigestAlgorithm: &lt;UTF8-String&gt;
      |               SignedData: &lt;Length, Signature&gt;
      |
      '---------------------------------------------------------------'

   where

      &lt;CredentialLength&gt;
      A 4-byte unsigned integer that specifies the number of octets in
      the Message Credential.  It must be set to zero if the message has
      no Message Credential.

      &lt;Version&gt;
      An octet that identifies the version number of the Message
      Credential.  The version number specified in this document is
      zero.

      &lt;Reserved&gt;
      An octet that must be set to zero.

      &lt;Options&gt;
      Two octets reserved for various cryptography options.



<span class="grey">Sun, et al.                  Informational                     [Page 18]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-19"></span>
<span class="grey"><a href="./rfc3652">RFC 3652</a>             Handle System Protocol (v2.1)         November 2003</span>



      &lt;Signer&gt; ::= &lt;HANDLE&gt;
                   &lt;INDEX&gt;
      A reference to a handle value in terms of the &lt;HANDLE&gt; and the
      &lt;INDEX&gt; of the handle value.  The handle value may contain the
      public key, or the X.509 certificate, that can be used to
      validate the digital signature.

      &lt;Type&gt;
      A UTF8-String that indicates the type of content in the
      &lt;SignedInfo&gt; field (described below).  It may contain HS_DIGEST if
      &lt;SignedInfo&gt; contains the message digest, or HS_MAC if
      &lt;SignedInfo&gt; contains the Message Authentication Code (MAC).  The
      &lt;Type&gt; field will specify the signature algorithm identifier if
      &lt;SignedInfo&gt; contains a digital signature.  For example, with the
      &lt;Type&gt; field set to HS_SIGNED_PSS, the &lt;SignedInfo&gt; field will
      contain the digital signature generated using the RSA-PSS
      algorithm [<a href="#ref-16" title="Springer-Verlag">16</a>].  If the &lt;Type&gt; field is set to HS_SIGNED, the
      &lt;SignedInfo&gt; field will contain the digital signature generated
      from a DSA public key pair.

      &lt;SignedInfo&gt; ::=  &lt;Length&gt;
                        &lt;DigestAlgorithm&gt;
                        &lt;SignedData&gt;
         where

            &lt;Length&gt;
            A 4-byte unsigned integer that specifies the number of
            octets in the &lt;SignedInfo&gt; field.

            &lt;DigestAlgorithm&gt;
            A UTF8-String that refers to the digest algorithm used to
            generate the digital signature.  For example, the value
            "SHA-1" indicates that the SHA-1 algorithm is used to
            generate the message digest for the signature.

            &lt;SignedData&gt; ::=  &lt;LENGTH&gt;
                            &lt;SIGNATURE&gt;
               where

                  &lt;LENGTH&gt;
                  A 4-byte unsigned integer that specifies the number of
                  octets in the &lt;SIGNATURE&gt;.

                  &lt;SIGNATURE&gt;
                  Contains the digital signature or the MAC over the
                  Message Header and Message Body.  The syntax and
                  semantics of the signature depend on the &lt;Type&gt; field



<span class="grey">Sun, et al.                  Informational                     [Page 19]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-20"></span>
<span class="grey"><a href="./rfc3652">RFC 3652</a>             Handle System Protocol (v2.1)         November 2003</span>


                  and the public key referenced in the &lt;Signer&gt; field.
                  For example, if the &lt;Type&gt; field is "HS_SIGNED" and
                  the public key referred to by the &lt;Signer&gt; field is
                  a DSA [<a href="#ref-6">6</a>] public key, the signature will be the
                  ASN.1 octet string representation of the parameter R
                  and S as described in [<a href="#ref-7" title='"Cryptographic Message Syntax (CMS) Algorithms"'>7</a>].  If the &lt;Signer&gt; field
                  refers to a handle value that contains a X.509
                  certificate, the signature should be encoded according
                  to <a href="./rfc3279">RFC 3279</a> and <a href="./rfc3280">RFC 3280</a> [<a href="#ref-14" title='"Algorithms and Identifiers for the Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile"'>14</a>, <a href="#ref-15" title='"Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile"'>15</a>].

   The Message Credential may contain the message authentication code
   (MAC) generated using a pre-established session key.  In this case,
   the &lt;Signer&gt; field must set its &lt;HANDLE&gt; to a zero-length UTF8-String
   and its &lt;INDEX&gt; to the &lt;SessionId&gt; specified in the Message Envelope.
   The &lt;Signature&gt; field must contain the MAC in its &lt;SIGNATURE&gt; field.
   The MAC is the result of the one-way hash over the concatenation of
   the session key, the &lt;Message Header&gt;, the &lt;MessageBody&gt;, and the
   session key again.

   The Message Credential in a response message may contain the digital
   signature signed by the server.  The server's public key can be found
   in the service information used by the client to send the request to
   the server.  In this case, the client should ignore any reference in
   the &lt;Signer&gt; field and use the public key in the service information
   to verify the signature.

   The Message Credential can also be used for non-repudiation purposes.
   This happens if the Message Credential contains a server's digital
   signature.  The signature may be used as evidence to demonstrate that
   the server has rendered its service in response to a client's
   request.

   The Message Credential provides a mechanism for safe transmission of
   any message between the client and server.  Any message whose Message
   Header and Message Body complies with its Message Credential suggests
   that the message indeed comes from its originator and assures that
   the message has not been tampered with during its transmission.

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/2.3.%20%20Message%20Transmission"></a><a class="selflink" href="#section-2.3" id="section-2.3">2.3</a>.  Message Transmission</span>

   A large message may be truncated into multiple packets during its
   transmission.  For example, to fit the size limit of a UDP packet,
   the message issuer must truncate any large message into multiple UDP
   packets before its transmission.  The message recipient must
   reassemble the message from these truncated packets before further
   processing.  Message truncation must be carried out over the entire





<span class="grey">Sun, et al.                  Informational                     [Page 20]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-21"></span>
<span class="grey"><a href="./rfc3652">RFC 3652</a>             Handle System Protocol (v2.1)         November 2003</span>


   message except the Message Envelope.  A new Message Envelope has to
   be inserted in front of each truncated packet before its
   transmission.  For example, a large message that consists of

      .--------------------------------------------------------.
      |  Message Envelope  |  Message Header, Body, Credential |
      '--------------------------------------------------------'

   may be truncated into:

         .--------------------------------------------.
         |  Message Envelope 1 |  Truncated_Packet 1  |
         '--------------------------------------------'
         .--------------------------------------------.
         |  Message Envelope 2 |  Truncated_Packet 2  |
         '--------------------------------------------'

            ......

         .--------------------------------------------.
         |  Message Envelope N |  Truncated Packet N  |
         '--------------------------------------------'

   where the "Truncated_packet 1", "Truncated_packet 2", ..., and
   "Truncated_packet N" result from truncating the Message Header, the
   Message Body and the Message Credential.  Each "Message Envelope i"
   (inserted before each truncation) must set its TC flag to 1 and
   maintain the proper sequence count (in the &lt;SequenceNumber&gt;).  Each
   "Message Envelope i" must also set its &lt;MessageLength&gt; to reflect the
   size of the packet.  The recipient of these truncated packets can
   reassemble the message by concatenating these packets based on their
   &lt;SequenceNumber&gt;.

<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/3.%20%20Handle%20Protocol%20Operations"></a><a class="selflink" href="#section-3" id="section-3">3</a>.  Handle Protocol Operations</span>

   This section describes the details of each protocol operation in
   terms of messages exchanged between the client and server.  It also
   defines the format of the Message Body according to each &lt;OpCode&gt; and
   &lt;ResponseCode&gt; in the Message Header.

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/3.1.%20%20Client%20Bootstrapping"></a><a class="selflink" href="#section-3.1" id="section-3.1">3.1</a>.  Client Bootstrapping</span>

<span class="h4"><a class="dashAnchor" name="//apple_ref/cpp/Section/3.1.1.%20%20Global%20Handle%20Registry%20and%20its%20Service%20Information"></a><a class="selflink" href="#section-3.1.1" id="section-3.1.1">3.1.1</a>.  Global Handle Registry and its Service Information</span>

   The service information for the Global Handle Registry (GHR) allows
   clients to contact the GHR to find out the responsible service
   components for their handles.  The service information is a set of
   HS_SITE values assigned to the root handle "0.NA/0.NA" and is also



<span class="grey">Sun, et al.                  Informational                     [Page 21]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-22"></span>
<span class="grey"><a href="./rfc3652">RFC 3652</a>             Handle System Protocol (v2.1)         November 2003</span>


   called the root service information.  The root service information
   may be distributed along with the client software, or be downloaded
   from the Handle System website at <a href="http://www.handle.net">http://www.handle.net</a>.

   Changes to the root service information are identified by the
   &lt;SerialNumber&gt; in the HS_SITE values.  A server at GHR can find out
   if the root service information used by the client is outdated by
   checking the &lt;SerialNumber&gt; in the client's request.  The client
   should update the root service information if the &lt;ResponseCode&gt; of
   the response message is RC_EXPIRED_SITE_INFO.  Clients may obtain the
   most up-to-date root service information from the root handle.  The
   GHR must sign the root service information using the public key
   specified in the outdated service information (identified in the
   client's request) so that the client can validate the signature.

<span class="h4"><a class="dashAnchor" name="//apple_ref/cpp/Section/3.1.2.%20%20Locating%20the%20Handle%20System%20Service%20Component"></a><a class="selflink" href="#section-3.1.2" id="section-3.1.2">3.1.2</a>.  Locating the Handle System Service Component</span>

   Each handle under the Handle System is managed by a unique handle
   service component (e.g., LHS).  For any given handle, the responsible
   service component (and its service information) can be found from its
   naming authority handle.  Before resolving any given handle, the
   client needs to find the responsible service component by querying
   the naming authority handle from the GHR.

   For example, to find the responsible LHS for the handle "1000/abc",
   client software can query the GHR for the HS_SITE (or HS_SERV) values
   assigned to the naming authority handle "0.NA/1000".  The set of
   HS_SITE values provides the service information of the LHS that
   manages every handle under the naming authority "1000".  If no
   HS_SITE values are found, the client can check if there is any
   HS_SERV value assigned to the naming authority handle.  The HS_SERV
   value provides the service handle that maintains the service
   information for the LHS.  Service handles are used to manage the
   service information shared by different naming authorities.

   It is possible that the naming authority handle requested by the
   client does not reside at the GHR.  This happens when naming
   authority delegation takes place.  Naming authority delegation
   happens when a naming authority delegates an LHS to manage all its
   child naming authorities.  In this case, the delegating naming
   authority must contain the service information, a set of
   HS_NA_DELEGATE values, of the LHS that manages its child naming
   authorities.

   All top-level naming authority handles must be registered and managed
   by the GHR.  When a server at the GHR receives a request for a naming
   authority that has been delegated to an LHS, it must return a message
   with the &lt;ResponseCode&gt; set to RC_NA_DELEGATE, along with the



<span class="grey">Sun, et al.                  Informational                     [Page 22]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-23"></span>
<span class="grey"><a href="./rfc3652">RFC 3652</a>             Handle System Protocol (v2.1)         November 2003</span>


   HS_NA_DELAGATE values from the nearest ancestor naming authority.
   The client can query the LHS described by the HS_NA_DELAGATE values
   for the delegated naming authority handle.  In practice, the ancestor
   naming authority should make itself available to any handle server
   within the GHR, by replicating itself at the time of delegation.
   This will prevent any cross-queries among handle servers (within a
   service site) when the naming authority in query and the ancestor
   naming authority do not hash into the same handle server.

<span class="h4"><a class="dashAnchor" name="//apple_ref/cpp/Section/3.1.3.%20%20Selecting%20the%20Responsible%20Server"></a><a class="selflink" href="#section-3.1.3" id="section-3.1.3">3.1.3</a>.  Selecting the Responsible Server</span>

   Each handle service component is defined in terms of a set of HS_SITE
   values.  Each of these HS_SITE values defines a service site within
   the service component.  A service site may consist of a group of
   handle servers.  For any given handle, the responsible handle server
   within the service component can be found following this procedure:

      1. Select a preferred service site.

         Each service site is defined in terms of an HS_SITE value.  The
         HS_SITE value may contain a &lt;Description&gt; or other attributes
         (under the &lt;AttributeList&gt;) to help the selection.  Clients
         must select the primary service site for any administrative
         operations.

      2. Locate the responsible server within the service site.

         This can be done as follows: Convert every ASCII character in
         the handle to its upper case.  Calculate the MD5 hash of the
         converted handle string according to the &lt;HashOption&gt; given in
         the HS_SITE value.  Take the last 4 bytes of the hash result as
         a signed integer.  Modulo the absolute value of the integer by
         the &lt;NumOfServer&gt; given in the HS_SITE value.  The result is
         the sequence number of the &lt;ServerRecord&gt; listed in the HS_SITE
         value.  For example, if the result of the modulation is 2, the
         third &lt;ServerRecord&gt; listed in the &lt;HS_SITE&gt; should be
         selected.  The &lt;ServerRecord&gt; defines the responsible handle
         server for the given handle.

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/3.2.%20%20Query%20Operation"></a><a class="selflink" href="#section-3.2" id="section-3.2">3.2</a>.  Query Operation</span>

   A query operation consists of a client sending a query request to the
   responsible handle server and the server returning the query result
   to the client.  Query requests are used to retrieve handle values
   assigned to any given handle.






<span class="grey">Sun, et al.                  Informational                     [Page 23]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-24"></span>
<span class="grey"><a href="./rfc3652">RFC 3652</a>             Handle System Protocol (v2.1)         November 2003</span>


<span class="h4"><a class="dashAnchor" name="//apple_ref/cpp/Section/3.2.1.%20%20Query%20Request"></a><a class="selflink" href="#section-3.2.1" id="section-3.2.1">3.2.1</a>.  Query Request</span>

   The Message Header of any query request must set its &lt;OpCode&gt; to
   OC_RESOLUTION (defined in <a href="#section-2.2.2.1">section 2.2.2.1</a>) and &lt;ResponseCode&gt; to 0.

   The Message Body for any query request is defined as follows:

      &lt;Message Body of Query Request&gt;  ::=  &lt;Handle&gt;
                                            &lt;IndexList&gt;
                                            &lt;TypeList&gt;

         where

            &lt;Handle&gt;
            A UTF8-String (as defined in <a href="#section-2.1.4">section 2.1.4</a>) that specifies
            the handle to be resolved.

            &lt;IndexList&gt;
            A 4-byte unsigned integer followed by an array of 4-byte
            unsigned integers.  The first integer indicates the number
            of integers in the integer array.  Each number in the
            integer array is a handle value index and refers to a handle
            value to be retrieved.  The client sets the first integer to
            zero (followed by an empty array) to ask for all the handle
            values regardless of their index.

            &lt;TypeList&gt;
            A 4-byte unsigned integer followed by a list of UTF8-
            Strings.  The first integer indicates the number of
            UTF8-Strings in the list that follows.  Each UTF8-String in
            the list specifies a data type.  This tells the server to
            return all handle values whose data type is listed in the
            list.  If a UTF8-String ends with the '.' (0x2E) character,
            the server must return all handle values whose data type is
            under the type hierarchy specified in the UTF8-String.  The
            &lt;TypeList&gt; may contain no UTF8-String if the first integer
            is 0.  In this case, the server must return all handle
            values regardless of their data type.

   If a query request does not specify any index or data type and the PO
   flag (in the Message Header) is set, the server will return all the
   handle values that have the PUBLIC_READ permission.  Clients can also
   send queries without the PO flag set.  In this case, the server will
   return all the handle values with PUBLIC_READ permission and all the
   handle values with ADMIN_READ permission.  If the query requests a
   specific handle value via the value index and the value does not have
   PUBLIC_READ permission, the server should accept the request (and
   authenticate the client) even if the request has its PO flag set.



<span class="grey">Sun, et al.                  Informational                     [Page 24]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-25"></span>
<span class="grey"><a href="./rfc3652">RFC 3652</a>             Handle System Protocol (v2.1)         November 2003</span>


   If a query consists of a non-empty &lt;IndexList&gt; but an empty
   &lt;TypeList&gt;, the server should only return those handle values whose
   indexes are listed in the &lt;IndexList&gt;.  Likewise, if a query consists
   of a non-empty &lt;TypeList&gt; but an empty &lt;IndexList&gt;, the server should
   only return those handle values whose data types are listed in the
   &lt;TypeList&gt;.

   When both &lt;IndexList&gt; and &lt;TypeList&gt; fields are non-empty, the server
   should return all handle values whose indexes are listed in the
   &lt;IndexList&gt; AND all handle values whose data types are listed in the
   &lt;TypeList&gt;.

<span class="h4"><a class="dashAnchor" name="//apple_ref/cpp/Section/3.2.2.%20%20Successful%20Query%20Response"></a><a class="selflink" href="#section-3.2.2" id="section-3.2.2">3.2.2</a>.  Successful Query Response</span>

   The Message Header of any query response must set its &lt;OpCode&gt; to
   OC_RESOLUTION.  A successful query response must set its
   &lt;ResponseCode&gt; to RC_SUCCESS.

   The message body of the successful query response is defined as
   follows:

      &lt;Message Body of Successful Query Response&gt; ::= [&lt;RequestDigest&gt;]
                                                       &lt;Handle&gt;
                                                       &lt;ValueList&gt;

         where

            &lt;RequestDigest&gt;
            Optional field as defined in <a href="#section-2.2.3">section 2.2.3</a>.

            &lt;Handle&gt;
            A UTF8-String that specifies the handle queried by the
            client.

            &lt;ValueList&gt;
            A 4-byte unsigned integer followed by a list of handle
            values.  The integer specifies the number of handle values
            in the list.  The encoding of each handle value follows the
            specification given in [<a href="#ref-2" title='"Handle System Namespace and Service Definition"'>2</a>] (see <a href="#section-3.1">section 3.1</a>).  The integer
            is set to zero if there is no handle value that satisfies
            the query.










<span class="grey">Sun, et al.                  Informational                     [Page 25]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-26"></span>
<span class="grey"><a href="./rfc3652">RFC 3652</a>             Handle System Protocol (v2.1)         November 2003</span>


<span class="h4"><a class="dashAnchor" name="//apple_ref/cpp/Section/3.2.3.%20%20Unsuccessful%20Query%20Response"></a><a class="selflink" href="#section-3.2.3" id="section-3.2.3">3.2.3</a>.  Unsuccessful Query Response</span>

   If a server cannot fulfill a client's request, it must return an
   error message.  The general format for any error message from the
   server is specified in <a href="#section-3.3">section 3.3</a> of this document.

   For example, a server must return an error message if the queried
   handle does not exist in its database.  The error message will have
   an empty message body and have its &lt;ResponseCode&gt; set to
   RC_HANDLE_NOT_FOUND.

   Note that a server should NOT return an RC_HANDLE_NOT_FOUND message
   if the server is not responsible for the handle being queried.  It is
   possible that the queried handle exists but is managed by another
   handle server (under some other handle service).  When this happens,
   the server should either send a service referral (see <a href="#section-3.4">section 3.4</a>) or
   simply return an error message with &lt;ResponseCode&gt; set to
   RC_SERVER_NOT_RESP.

   The server may return an error message with &lt;ResponseCode&gt; set to
   RC_SERVER_BUSY if the server is too busy to process the request.
   Like RC_HANDLE_NOT_FOUND, an RC_SERVER_BUSY message also has an empty
   message body.

   Servers should return an RC_ACCESS_DENIED message if the request asks
   for a specific handle value (via the handle value index) that has
   neither PUBLIC_READ nor ADMIN_READ permission.

   A handle Server may ask its client to authenticate itself as the
   handle administrator during the resolution.  This happens if any
   handle value in query has ADMIN_READ permission, but no PUBLIC_READ
   permission.  Details of client authentication are described later in
   this document.

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/3.3.%20%20Error%20Response%20from%20Server"></a><a class="selflink" href="#section-3.3" id="section-3.3">3.3</a>.  Error Response from Server</span>

   A handle server will return an error message if it encounters an
   error when processing a request.  Any error response from the server
   must maintain the same &lt;OpCode&gt; (in the message header) as the one in
   the original request.  Each error condition is identified by a unique
   &lt;ResponseCode&gt; as defined in <a href="#section-2.2.2.2">section 2.2.2.2</a> of this document.










<span class="grey">Sun, et al.                  Informational                     [Page 26]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-27"></span>
<span class="grey"><a href="./rfc3652">RFC 3652</a>             Handle System Protocol (v2.1)         November 2003</span>


   The Message Body of an error message may be empty.  Otherwise it
   consists of the following data fields (unless otherwise specified):

      &lt;Message Body of Error Response from Server&gt; ::= [&lt;RequestDigest&gt;]
                                                        &lt;ErrorMessage&gt;
                                                       [ &lt;IndexList&gt; ]

         where

            &lt;RequestDigest&gt;
            Optional field as defined in <a href="#section-2.2.3">section 2.2.3</a>.

            &lt;ErrorMessage&gt;
            A UTF8-String that explains the error.

            &lt;IndexList&gt;
            An optional field.  When not empty, it consists of a 4-byte
            unsigned integer followed by a list of handle value indexes.
            The first integer indicates the number of indexes in the
            list.  Each index in the list is a 4-byte unsigned integer
            that refers to a handle value that contributed to the error.
            An example would be a server that is asked to add three
            handle values, with indexes 1, 2, and 3, and handle values
            with indexes of 1 and 2 already in existence.  In this case,
            the server could return an error message with &lt;REsponseCode&gt;
            set to RC_VALUE_ALREADY_EXIST and add index 1 and 2 to the
            &lt;IndexList&gt;.  Note that the server is not obligated to
            return the complete list of handle value indexes that may
            have caused the error.

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/3.4.%20%20Service%20Referral"></a><a class="selflink" href="#section-3.4" id="section-3.4">3.4</a>.  Service Referral</span>

   A handle server may receive requests for handles that are managed by
   some other handle server or service.  When this happens, the server
   has the option to either return a referral message that directs the
   client to the proper handle service, or simply return an error
   message with &lt;ResponseCode&gt; set to RC_SERVER_NOT_RESP.  Service
   referral also happens when ownership of handles moves from one handle
   service to another.  It may also be used by any local handle service
   to delegate its service into multiple service layers.

   The Message Header of a service referral must maintain the same
   &lt;OpCode&gt; as the one in the original request and set its
   &lt;ResponseCode&gt; to RC_SERVICE_REFERRAL.







<span class="grey">Sun, et al.                  Informational                     [Page 27]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-28"></span>
<span class="grey"><a href="./rfc3652">RFC 3652</a>             Handle System Protocol (v2.1)         November 2003</span>


   The Message Body of any service referral is defined as follows:

      &lt;Message Body of Service Referral&gt; ::= [ &lt;RequestDigest&gt; ]
                                               &lt;ReferralHandle&gt;
                                             [ &lt;ValueList&gt; ]

         where

            &lt;RequestDigest&gt;
            Optional field as defined in <a href="#section-2.2.3">section 2.2.3</a>.

            &lt;ReferralHandle&gt;
            A UTF8-String that identifies the handle (e.g., a service
            handle) that maintains the referral information (i.e., the
            service information of the handle service in which this
            refers).  If the &lt;ReferralHandle&gt; is set to "0.NA/0.NA",
            it is referring the client to the GHR.

            &lt;ValueList&gt;
            An optional field that must be empty if the &lt;ReferralHandle&gt;
            is provided.  When not empty, it consists of a 4-byte
            unsigned integer, followed by a list of HS_SITE values.  The
            integer specifies the number of HS_SITE values in the list.

   Unlike regular query responses that may consist of handle values of
   any data type, a service referral can only have zero or more HS_SITE
   values in its &lt;ValueList&gt;.  The &lt;ReferralHandle&gt; may contain an empty
   UTF8-String if the HS_SITE values in the &lt;ValueList&gt; are not
   maintained by any handle.

   Care must be taken by clients to avoid any loops caused by service
   referrals.  It is also the client's responsibility to authenticate
   the service information obtained from the service referral.  A client
   should always use its own copy of the GHR service information if the
   &lt;ReferralHandle&gt; is set to "0.NA/0.NA".

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/3.5.%20%20Client%20Authentication"></a><a class="selflink" href="#section-3.5" id="section-3.5">3.5</a>.  Client Authentication</span>

   Clients are asked to authenticate themselves as handle administrators
   when querying for any handle value with ADMIN_READ but no PUBLIC_READ
   permission.  Client authentication is also required for any handle
   administration requests that require administrator privileges.  This
   includes adding, removing, or modifying handles or handle values.

   Client authentication consists of multiple messages exchanged between
   the client and server.  Such messages include the challenge from the
   server to the client to authenticate the client, the challenge-
   response from the client in response to the server's challenge, and



<span class="grey">Sun, et al.                  Informational                     [Page 28]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-29"></span>
<span class="grey"><a href="./rfc3652">RFC 3652</a>             Handle System Protocol (v2.1)         November 2003</span>


   the verification request and response message if secret key
   authentication takes place.  Messages exchanged during the
   authentication are correlated via a unique &lt;SessionId&gt; assigned by
   the server.  For each authentication session, the server needs to
   maintain the state information that includes the server's challenge,
   the challenge-response from the client, as well as the original
   client request.

   The authentication starts with a response message from the server
   that contains a challenge to the client.  The client must respond to
   the challenge with a challenge-response message.  The server
   validates the challenge-response, either by verifying the digital
   signature inside the challenge-response, or by sending a verification
   request to another handle server (herein referred to as the
   verification server), that maintains the secret key for the
   administrator.  The purpose of the challenge and the challenge-
   response is to prove to the server that the client possesses the
   private key (or the secret key) of the handle administrator.  If the
   authentication fails, an error response will be sent back with the
   &lt;ResponseCode&gt; set to RC_AUTHEN_FAILED.

   Upon successful client authentication, the server must also make sure
   that the administrator is authorized for the request.  If the
   administrator has sufficient privileges, the server will process the
   request and send back the result.  If the administrator does not have
   sufficient privileges, the server will return an error message with
   &lt;ResponseCode&gt; set to RC_NOT_AUTHORIZED.

   The following sections provide details of each message exchanged
   during the authentication process.

<span class="h4"><a class="dashAnchor" name="//apple_ref/cpp/Section/3.5.1.%20%20Challenge%20from%20Server%20to%20Client"></a><a class="selflink" href="#section-3.5.1" id="section-3.5.1">3.5.1</a>.  Challenge from Server to Client</span>

   The Message Header of the CHALLENGE must keep the same &lt;OpCode&gt; as
   the original request and set the &lt;ResponseCode&gt; to RC_AUTH_NEEDED.
   The server must assign a non-zero unique &lt;SessionId&gt; in the Message
   Envelope to keep track of the authentication.  It must also set the
   RD flag of the &lt;OpFlag&gt; (see <a href="#section-2.2.2.3">section 2.2.2.3</a>) in the Message Header,
   regardless of whether the original request had the RD bit set or not.












<span class="grey">Sun, et al.                  Informational                     [Page 29]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-30"></span>
<span class="grey"><a href="./rfc3652">RFC 3652</a>             Handle System Protocol (v2.1)         November 2003</span>


   The Message Body of the server's CHALLENGE is defined as follows:

      &lt;Message Body of Server's Challenge&gt; ::=  &lt;RequestDigest&gt;
                                                &lt;Nonce&gt;
         where

            &lt;RequestDigest&gt;
            Message Digest of the request message, as defined in <a href="#section-2.2.3">section</a>
            <a href="#section-2.2.3">2.2.3</a>.

            &lt;Nonce&gt;
            A 4-byte unsigned integer followed by a random string
            generated by the server via a secure random number
            generator.  The integer specifies the number of octets in
            the random string.  The size of the random string should be
            no less than 20 octets.

   Note that the server will not sign the challenge if the client did
   not request the server to do so.  If the client worries about whether
   it is speaking to the right server, it may ask the server to sign the
   &lt;Challenge&gt;.  If the client requested the server to sign the
   &lt;Challenge&gt; but failed to validate the server's signature, the client
   should discard the server's response and reissue the request to the
   server.

<span class="h4"><a class="dashAnchor" name="//apple_ref/cpp/Section/3.5.2.%20%20Challenge-Response%20from%20Client%20to%20Server"></a><a class="selflink" href="#section-3.5.2" id="section-3.5.2">3.5.2</a>.  Challenge-Response from Client to Server</span>

   The Message Header of the CHALLENGE_RESPONSE must set its &lt;OpCode&gt; to
   OC_CHALLENGE_RESPONSE and its &lt;ResponseCode&gt; to 0.  It must also keep
   the same &lt;SessionId&gt; (in the Message Envelope) as specified in the
   challenge from the server.

   The Message Body of the CHALLENGE_RESPONSE request is defines as
   follows:

      &lt;Message Body of CHALLENGE_RESPONSE&gt; ::=  &lt;AuthenticationType&gt;
                                                &lt;KeyHandle&gt;
                                                &lt;KeyIndex&gt;
                                                &lt;ChallengeResponse&gt;

         where

            &lt;AuthenticationType&gt;
            A UTF8-String that identifies the type of authentication key
            used by the client.  For example, the field is set to
            "HS_SECKEY" if the client chooses to use a secret key for
            its authentication.  The field is set to "HS_PUBKEY" if a
            public key is used instead.



<span class="grey">Sun, et al.                  Informational                     [Page 30]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-31"></span>
<span class="grey"><a href="./rfc3652">RFC 3652</a>             Handle System Protocol (v2.1)         November 2003</span>



            &lt;KeyHandle&gt;
            A UTF8-String that identifies the handle that holds the
            public or secret key of the handle administrator.

            &lt;KeyIndex&gt;
            A 4-byte unsigned integer that specifies the index of the
            handle value (of the &lt;KeyHandle&gt;) that holds the public or
            secret key of the administrator.

            &lt;ChallengeResponse&gt;
            Contains either the Message Authentication Code (MAC) or the
            digital signature over the challenge from the server.  If
            the &lt;AuthenticationType&gt; is "HS_SECKEY", the
            &lt;ChallengeResponse&gt; consists of an octet followed by the
            MAC.  The octet identifies the algorithm used to generate
            the MAC.  For example, if the first octet is set to 0x01,
            the MAC is generated by

               MD5_Hash(&lt;SecretKey&gt; + &lt;ServerChallenge&gt; + &lt;SecretKey&gt;)

            where the &lt;SecretKey&gt; is the administrator's secret key
            referenced by the &lt;KeyHandle&gt; and &lt;KeyIndex&gt;.  The
            &lt;ServerChallenge&gt; is the Message Body portion of the
            server's challenge.  If the first octet in the
            &lt;ChallengeResponse&gt; is set to 0x02, the MAC is generated
            using

               SHA-1_Hash(&lt;SecretKey&gt; + &lt;ServerChallenge&gt; + &lt;SecretKey&gt;)

            A more secure approach is to use HMAC [<a href="#ref-17" title='"HMAC: Keyed-Hashing for Message Authentication"'>17</a>] for the
            &lt;ChallengeResponse&gt;.  The HMAC can be generated using the
            &lt;SecretKey&gt; and &lt;ServerChallenge&gt;.  A &lt;ChallengeResponse&gt;
            with its first octet set to 0x11 indicates that the HMAC
            is generated using the MD5 algorithm.  Likewise, a
            &lt;ChallengeResponse&gt; with its first octet set to 0x12
            indicates that the HMAC is generated using the SHA-1
            algorithm.

            If the &lt;AuthenticationType&gt; is "HS_PUBKEY", the
            &lt;ChallengeResponse&gt; contains the digital signature over the
            Message Body portion of the server's challenge.  The
            signature is generated in two steps: First, a one-way hash
            value is computed over the blob that is to be signed.
            Second, the hash value is signed using the private key.
            The signature consists of a UTF8-String that specifies the
            digest algorithm used for the signature, followed by the
            signature over the server's challenge.  The &lt;KeyHandle&gt; and



<span class="grey">Sun, et al.                  Informational                     [Page 31]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-32"></span>
<span class="grey"><a href="./rfc3652">RFC 3652</a>             Handle System Protocol (v2.1)         November 2003</span>


            &lt;KeyIndex&gt; refers to the administrator's public key that can
            be used to verify the signature.

   Handle administrators are defined in terms of HS_ADMIN values
   assigned to the handle.  Each HS_ADMIN value defines the set of
   privileges granted to the administrator.  It also provides the
   reference to the authentication key that can be used to authenticate
   the administrator.  The reference can be made directly if the
   &lt;AdminRef&gt; field of the HS_ADMIN value refers to the handle value
   that holds the authentication key.  Indirect reference to the
   authentication key can also be made via administrator groups.  In
   this case, the &lt;AdminRef&gt; field may refer to a handle value of type
   HS_VLIST.  An HS_VLIST value defines an administrator group via a
   list of handle value references, each of which refers to the
   authentication key of a handle administrator.

   For handles with multiple HS_ADMIN values, the server will have to
   check each of those with sufficient privileges to see if its
   &lt;AdminRef&gt; field matches the &lt;KeyHandle&gt; and &lt;KeyIndex&gt;.  If no match
   is found, but there are administrator groups defined, the server must
   check if the &lt;KeyHandle&gt; and &lt;KeyIndex&gt; belong to any of the
   administrator groups that have sufficient privileges.  An
   administrator group may contain another administrator group as a
   member.  Servers must be careful to avoid infinite loops when
   navigating these groups.

   If the &lt;KeyHandle&gt; and &lt;KeyIndex&gt; are not referenced by any of the
   HS_ADMIN values, or the administrator group that has sufficient
   privileges, the server will return an error message with
   &lt;ResponseCode&gt; set to RC_NOT_AUTHORIZED.  Otherwise, the server will
   continue to authenticate the client as follows:

   If the &lt;AuthenticationType&gt; is "HS_PUBKEY", the server will retrieve
   the administrator's public key based on the &lt;KeyHandle&gt; and
   &lt;KeyIndex&gt;.  The public key can be used to verify the
   &lt;ChallengeResponse&gt; against the server's &lt;Challenge&gt;.  If the
   &lt;ChallengeResponse&gt; matches the &lt;Challenge&gt;, the server will continue
   to process the original request and return the result.  Otherwise,
   the server will return an error message with &lt;ResponseCode&gt; set to
   RC_AUTHENTICATION_FAILED.

   If the &lt;AuthenticationType&gt; is "HS_SECKEY", the server will have to
   send a verification request to the verification server; that is, the
   handle server that manages the handle referenced by the &lt;KeyHandle&gt;.
   The verification request and its response are defined in the
   following sections.  The verification server will verify the
   &lt;ChallengeResponse&gt; against the &lt;Challenge&gt; on behalf of the handle
   server.



<span class="grey">Sun, et al.                  Informational                     [Page 32]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-33"></span>
<span class="grey"><a href="./rfc3652">RFC 3652</a>             Handle System Protocol (v2.1)         November 2003</span>


<span class="h4"><a class="dashAnchor" name="//apple_ref/cpp/Section/3.5.3.%20%20Challenge-Response%20Verification-Request"></a><a class="selflink" href="#section-3.5.3" id="section-3.5.3">3.5.3</a>.  Challenge-Response Verification-Request</span>

   The message header of the VERIFICATION_REQUEST must set its &lt;OpCode&gt;
   to OC_VERIFY_CHALLENGE and the &lt;ResponseCode&gt; to 0.

   The message body of the Verification-Request is defined as follows:

      &lt;Message Body of VERIFICATION_REQUEST&gt; ::=  &lt;KeyHandle&gt;
                                                 &lt;KeyIndex&gt;
                                                 &lt;Challenge&gt;
                                                 &lt;ChallengeResponse&gt;

         where

            &lt;KeyHandle&gt;
            A UTF8-String that refers to the handle that holds the
            secret key of the administrator.

            &lt;KeyIndex&gt;
            A 4-byte unsigned integer that is the index of the handle
            value that holds the secret key of the administrator.

            &lt;Challenge&gt;
            The message body of the server's challenge, as described in
            <a href="#section-3.5.1">section 3.5.1</a>.

            &lt;ChallengeResponse&gt;
            The &lt;ChallengeResponse&gt; from the client in response to
            the server's &lt;Challenge&gt;, as defined in <a href="#section-3.5.2">section 3.5.2</a>.

   Any Challenge-Response Verification-Request must set its CT bit in
   the message header.  This is to ensure that the verification server
   will sign the Verification-Response as specified in the next section.

<span class="h4"><a class="dashAnchor" name="//apple_ref/cpp/Section/3.5.4.%20%20Challenge-Response%20Verification-Response"></a><a class="selflink" href="#section-3.5.4" id="section-3.5.4">3.5.4</a>.  Challenge-Response Verification-Response</span>

   The Verification-Response tells the requesting handle server whether
   the &lt;ChallengeResponse&gt; matches the &lt;Challenge&gt; in the Verification-
   Request.

   The Message Header of the Verification-Response must set its
   &lt;ResponseCode&gt; to RC_SUCCESS whether or not the &lt;ChallengeResponse&gt;
   matches the &lt;Challenge&gt;.  The RD flag in the &lt;OpFlag&gt; field should
   also be set (to 1) since the &lt;RequestDigist&gt; will be mandatory in the
   Message Body.






<span class="grey">Sun, et al.                  Informational                     [Page 33]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-34"></span>
<span class="grey"><a href="./rfc3652">RFC 3652</a>             Handle System Protocol (v2.1)         November 2003</span>


   The Message Body of the Verification-Response is defined as follows:

      &lt;Challenge-Response Verification-Response&gt;
                                ::= &lt;RequestDigest&gt;
                                    &lt;VerificationResult&gt;
         where

            &lt;RequestDigest&gt;
            Contains the message digest of the Verification-Request.

            &lt;VerificationResult&gt;
            An octet that is set to 1 if the &lt;ChallengeResponse&gt;
            matches the &lt;Challenge&gt;.  Otherwise it must be set to
            0.

   The verification server may return an error with &lt;ResponseCode&gt; set
   to RC_AUTHEN_FAILED if it cannot perform the verification (e.g., the
   &lt;KeyHandle&gt; does not exist, or the &lt;KeyHandle&gt; and &lt;KeyIndex&gt; refer
   to an invalid handle value).  When this happens, the server that
   performs the client authentication should relay the same error
   message back to the client.

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/3.6.%20%20Handle%20Administration"></a><a class="selflink" href="#section-3.6" id="section-3.6">3.6</a>.  Handle Administration</span>

   The Handle System protocol supports a set of handle administration
   functions that include adding, deleting, and modifying handles or
   handle values.  Before fulfilling any administration request, the
   server must authenticate the client as the handle administrator that
   is authorized for the administrative operation.  Handle
   administration can only be carried out by the primary handle server.

<span class="h4"><a class="dashAnchor" name="//apple_ref/cpp/Section/3.6.1.%20%20Add%20Handle%20Value%28s%29"></a><a class="selflink" href="#section-3.6.1" id="section-3.6.1">3.6.1</a>.  Add Handle Value(s)</span>

   Clients add values to existing handles by sending ADD_VALUE requests
   to the responsible handle server.  The Message Header of the
   ADD_VALUE request must set its &lt;OpCode&gt; to OC_ADD_VALUE.

   The Message Body of the ADD_VALUE request is encoded as follows:

      &lt;Message Body of ADD_VALUE Request&gt; ::=  &lt;Handle&gt;
                                               &lt;ValueList&gt;

         where

            &lt;Handle&gt;
            A UTF8-String that specifies the handle.





<span class="grey">Sun, et al.                  Informational                     [Page 34]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-35"></span>
<span class="grey"><a href="./rfc3652">RFC 3652</a>             Handle System Protocol (v2.1)         November 2003</span>


            &lt;ValueList&gt;
            A 4-byte unsigned integer followed by a list of handle
            values.  The integer indicates the number of handle values
            in the list.

   The server that receives the ADD_VALUE request must first
   authenticate the client as the administrator with the ADD_VALUE
   privilege.  Upon successful authentication, the server will proceed
   to add each value in the &lt;ValueList&gt; to the &lt;Handle&gt;.  If successful,
   the server will return an RC_SUCCESS message to the client.

   Each ADD_VALUE request must be carried out as a transaction.  If
   adding any value in the &lt;ValueList&gt; raises an error, the entire
   operation must be rolled back.  For any failed ADD_VALUE request,
   none of the values in the &lt;ValueList&gt; should be added to the
   &lt;Handle&gt;.  The server must also send a response to the client that
   explains the error.  For example, if a value in the &lt;ValueList&gt; has
   the same index as one of the existing handle values, the server will
   return an error message that has the &lt;ResponseCode&gt; set to
   RC_VALUE_ALREADY_EXISTS.

   ADD_VALUE requests can also be used to add handle administrators.
   This happens if the &lt;ValueList&gt; in the ADD_VALUE request contains any
   HS_ADMIN values.  The server must authenticate the client as an
   administrator with the ADD_ADMIN privilege before fulfilling such
   requests.

   An ADD_VALUE request will result in an error if the requested handle
   does not exist.  When this happens, the server will return an error
   message with &lt;ResponseCode&gt; set to RC_HANDLE_NOT_EXIST.

<span class="h4"><a class="dashAnchor" name="//apple_ref/cpp/Section/3.6.2.%20%20Remove%20Handle%20Value%28s%29"></a><a class="selflink" href="#section-3.6.2" id="section-3.6.2">3.6.2</a>.  Remove Handle Value(s)</span>

   Clients remove existing handle values by sending REMOVE_VALUE
   requests to the responsible handle server.  The Message Header of the
   REMOVE_VALUE request must set its &lt;OpCode&gt; to OC_REMOVE_VALUE.

   The Message Body of any REMOVE_VALUE request is encoded as follows:

      &lt;Message Body of REMOVE_VALUE Request&gt; ::=  &lt;Handle&gt;
                                                  &lt;IndexList&gt;

         where

            &lt;Handle&gt;
            A UTF8-String that specifies the handle whose value(s) needs
            to be removed.




<span class="grey">Sun, et al.                  Informational                     [Page 35]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-36"></span>
<span class="grey"><a href="./rfc3652">RFC 3652</a>             Handle System Protocol (v2.1)         November 2003</span>


            &lt;IndexList&gt;
            A 4-byte unsigned integer followed by a list of handle value
            indexes.  Each index refers to a handle value to be removed
            from the &lt;Handle&gt;.  The integer specifies the number of
            indexes in the list.  Each index is also encoded as a 4-byte
            unsigned integer.

   The server that receives the REMOVE_VALUE request must first
   authenticate the client as the administrator with the REMOVE VALUE
   privilege.  Upon successful authentication, the server will proceed
   to remove the handle values specified in the &lt;IndexList&gt; from the
   &lt;Handle&gt;.  If successful, the server will return an RC_SUCCESS
   message to the client.

   Each REMOVE_VALUE request must be carried out as a transaction.  If
   removing any value specified in the &lt;IndexList&gt; raises an error, the
   entire operation must be rolled back.  For any failed REMOVE_VALUE
   request, none of values referenced in the &lt;IndexList&gt; should be
   removed from the &lt;Handle&gt;.  The server must also send a response to
   the client that explains the error.  For example, attempts to remove
   any handle value with neither PUB_WRITE nor ADMIN_WRITE permission
   will result in an RC_ACCESS_DENIED error.  Note that a REMOVE_VALUE
   request asking to remove a non-existing handle value will not be
   treated as an error.

   REMOVE_VALUE requests can also be used to remove handle
   administrators.  This happens if any of the indexes in the
   &lt;IndexList&gt; refer to an HS_ADMIN value.  Servers must authenticate
   the client as an administrator with the REMOVE_ADMIN privilege before
   fulfilling such requests.

<span class="h4"><a class="dashAnchor" name="//apple_ref/cpp/Section/3.6.3.%20%20Modify%20Handle%20Value%28s%29"></a><a class="selflink" href="#section-3.6.3" id="section-3.6.3">3.6.3</a>.  Modify Handle Value(s)</span>

   Clients can make modifications to an existing handle value by sending
   MODIFY_VALUE requests to the responsible handle server.  The Message
   Header of the MODIFY_VALUE request must set its &lt;OpCode&gt; to
   OC_MODIFY_VALUE.

   The Message Body of any MODIFY_VALUE request is defined as follows:

      &lt;Message Body of MODIFY_VALUE Response&gt; ::= &lt;Handle&gt;
                                                  &lt;ValueList&gt;

         where

            &lt;Handle&gt;
            A UTF8-String that specifies the handle whose value(s) needs
            to be modified.



<span class="grey">Sun, et al.                  Informational                     [Page 36]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-37"></span>
<span class="grey"><a href="./rfc3652">RFC 3652</a>             Handle System Protocol (v2.1)         November 2003</span>



            &lt;ValueList&gt;
            A 4-byte unsigned integer followed by a list of handle
            values.  The integer specifies the number of handle values
            in the list.  Each value in the &lt;ValueList&gt; specifies a
            handle value that will replace the existing handle value
            with the same index.

   The server that receives the MODIFY_VALUE request must first
   authenticate the client as an administrator with the MODIFY_VALUE
   privilege.  Upon successful authentication, the server will proceed
   to replace those handle values listed in the &lt;ValueList&gt;, provided
   each handle value has PUB_WRITE or ADMIN_WRITE permission.  If
   successful, the server must notify the client with an RC_SUCCESS
   message.

   Each MODIFY_VALUE request must be carried out as a transaction.  If
   replacing any value listed in the &lt;ValueList&gt; raises an error, the
   entire operation must be rolled back.  For any failed MODIFY_VALUE
   request, none of values in the &lt;ValueList&gt; should be replaced.  The
   server must also return a response to the client that explains the
   error.  For example, if a MODIFY_VALUE requests to remove a handle
   value that has neither PUB_WRITE nor ADMIN_WRITE permission, the
   server must return an error message with the &lt;ResponseCode&gt; set to
   RC_ACCESS_DENIED.  Any MODIFY_VALUE request to replace non- existing
   handle values is also treated as an error.  In this case, the server
   will return an error message with &lt;ResponseCode&gt; set to
   RC_VALUE_NOT_FOUND.

   MODIFY_VALUE requests can also be used to update handle
   administrators.  This happens if both the values in the &lt;ValueList&gt;
   and the value to be replaced are HS_ADMIN values.  Servers must
   authenticate the client as an administrator with the MODIFY_ADMIN
   privilege before fulfilling such a request.  It is an error to
   replace a non-HS_ADMIN value with an HS_ADMIN value.  In this case,
   the server will return an error message with &lt;ResponseCode&gt; set to
   RC_VALUE_INVALID.

<span class="h4"><a class="dashAnchor" name="//apple_ref/cpp/Section/3.6.4.%20%20Create%20Handle"></a><a class="selflink" href="#section-3.6.4" id="section-3.6.4">3.6.4</a>.  Create Handle</span>

   Clients can create new handles by sending CREATE_HANDLE requests to
   the responsible handle server.  The Message Header of any
   CREATE_HANDLE request must set its &lt;OpCode&gt; to OC_CREATE_HANDLE.








<span class="grey">Sun, et al.                  Informational                     [Page 37]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-38"></span>
<span class="grey"><a href="./rfc3652">RFC 3652</a>             Handle System Protocol (v2.1)         November 2003</span>


   The Message Body of any CREATE_HANDLE request is defined as follows:

      &lt;Message Body of CREATE_HANDLE Response&gt; ::= &lt;Handle&gt;
                                                   &lt;ValueList&gt;

         where

            &lt;Handle&gt;
            A UTF8-String that specifies the handle.

            &lt;ValueList&gt;
            A 4-byte unsigned integer followed by a list of handle
            values.  The integer indicates the number of handle values
            in the list.  The &lt;ValueList&gt; should at least include one
            HS_ADMIN value that defines the handle administrator.

   Only naming authority administrators with the CREATE_HANDLE privilege
   are allowed to create new handles under the naming authority.  The
   server that receives a CREATE_HANDLE request must authenticate the
   client as the administrator of the corresponding naming authority
   handle and make certain that the administrator is authorized to
   create handles under the naming authority.  This is different from
   the ADD_VALUE request where the server authenticates the client as an
   administrator of the handle.  Upon successful authentication, the
   server will proceed to create the new handle and add each value in
   the &lt;ValueList&gt; to the new &lt;Handle&gt;.  If successful, the server will
   return an RC_SUCCESS message to the client.

   Each CREATE_HANDLE request must be carried out as a transaction.  If
   any part of the CREATE_HANDLE process fails, the entire operation can
   be rolled back.  For example, if the server fails to add values in
   the &lt;ValueList&gt; to the new handle, it must return an error message
   without creating the new handle.  Any CREATE_HANDLE request that asks
   to create a handle that already exists will be treated as an error.
   In this case, the server will return an error message with the
   &lt;ResponseCode&gt; set to RC_HANDLE_ALREADY_EXIST.

   CREATE_HANDLE requests can also be used to create naming authorities.
   Naming authorities are created as naming authority handles at the
   GHR.  Before creating a new naming authority handle, the server must
   authenticate the client as the administrator of the parent naming
   authority.  Only administrators with the CREATE_NA privilege are
   allowed to create any sub-naming authority.  Root level naming
   authorities may be created by the administrator of the root handle
   "0.NA/0.NA".






<span class="grey">Sun, et al.                  Informational                     [Page 38]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-39"></span>
<span class="grey"><a href="./rfc3652">RFC 3652</a>             Handle System Protocol (v2.1)         November 2003</span>


<span class="h4"><a class="dashAnchor" name="//apple_ref/cpp/Section/3.6.5.%20%20Delete%20Handle"></a><a class="selflink" href="#section-3.6.5" id="section-3.6.5">3.6.5</a>.  Delete Handle</span>

   Clients delete existing handles by sending DELETE_HANDLE requests to
   the responsible handle server.  The Message Header of the
   DELETE_HANDLE request must set its &lt;OpCode&gt; to OC_DELETE_HANDLE.

   The Message Body of any DELETE_HANDLE request is defined as follows:

      &lt;Message Body of DELETE_HANDLE Request&gt; ::= &lt;Handle&gt;

         where

            &lt;Handle&gt;
            A UTF8-String that specifies the handle.

   The server that receives the DELETE_HANDLE request must first
   authenticate the client as the administrator with the DELETE_HANDLE
   privilege.  Upon successful authentication, the server will proceed
   to delete the handle along with any handle values assigned to the
   handle.  If successful, the server will return an RC_SUCCESS message
   to the client.

   Each DELETE_HANDLE request must be carried out as a transaction.  If
   any part of the DELETE_HANDLE process fails, the entire operation
   must be rolled back.  For example, if the server fails to remove any
   handle values assigned to the handle (before deleting the handle), it
   must return an error message without deleting the handle.  This may
   happen if the handle contains a value that has neither PUB_WRITE nor
   ADMIN_WRITE permission.  In this case, the server will return an
   error message with the &lt;ResponseCode&gt; set to RC_PERMISSION_DENIED.  A
   DELETE_HANDLE request that asks to delete a non-existing handle will
   also be treated as an error.  The server will return an error message
   with the &lt;ResponseCode&gt; set to RC_HANDLE_NOT_EXIST.

   DELETE_HANDLE requests can also be used to delete naming authorities.
   This is achieved by deleting the corresponding naming authority
   handle on the GHR.  Before deleting a naming authority handle, the
   server must authenticate the client as the administrator of the
   naming authority handle.  Only administrators with the DELETE_NA
   privilege are allowed to delete the naming authority.  Root level
   naming authorities may be deleted by the administrator of the root
   handle "0.NA/0.NA".









<span class="grey">Sun, et al.                  Informational                     [Page 39]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-40"></span>
<span class="grey"><a href="./rfc3652">RFC 3652</a>             Handle System Protocol (v2.1)         November 2003</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/3.7.%20%20Naming%20Authority%20%28NA%29%20Administration"></a><a class="selflink" href="#section-3.7" id="section-3.7">3.7</a>.  Naming Authority (NA) Administration</span>

   The Handle System manages naming authorities via naming authority
   handles.  Naming authority handles are managed by the GHR.  Clients
   can change the service information of any naming authority by
   changing the HS_SITE values assigned to the corresponding naming
   authority handle.  Creating or deleting naming authorities is done by
   creating or deleting the corresponding naming authority handles.
   Root level naming authorities may be created or deleted by the
   administrator of the root handle "0.NA/0.NA".  Non-root-level naming
   authorities may be created by the administrator of its parent naming
   authority.

   For example, the administrator of the naming authority handle
   "0.NA/10" may create the naming authority "10.1000" by sending a
   CREATE_HANDLE request to the GHR to create the naming authority
   handle "0.NA/10.1000".  Before fulfilling the request, the server at
   the GHR must authenticate the client as the administrator of the
   parent naming authority, that is, the administrator of the naming
   authority handle "0.NA/10".  The server must also make sure that the
   administrator has the NA_CREATE privilege.

   The Handle protocol also allows clients to list handles or sub-naming
   authorities under a naming authority.  Details of these operations
   are described in the following sections.

<span class="h4"><a class="dashAnchor" name="//apple_ref/cpp/Section/3.7.1.%20%20List%20Handle%28s%29%20under%20a%20Naming%20Authority"></a><a class="selflink" href="#section-3.7.1" id="section-3.7.1">3.7.1</a>.  List Handle(s) under a Naming Authority</span>

   Clients send LIST_HANDLE requests to handle servers to get a list of
   handles under a naming authority.  The Message Header of the
   LIST_HANDLE request must set its &lt;OpCode&gt; to OC_LIST_HANDLE.

   The Message Body of any LIST_HANDLE request is defined as follows:

      &lt;Message Body of LIST_HANDLE Request&gt; ::= &lt;NA_Handle&gt;

         where

            &lt;NA_Handle&gt;
            A UTF8-String that specifies the naming authority handle.

   To obtain a complete list of the handles, the request must be sent to
   every handle server listed in one of the service sites of the
   responsible handle service.  Each server within the service site will
   return its own list of handles under the naming authority.  The
   Message Body of a successful LIST_HANDLE response (from each handle
   server) is defined as follows:




<span class="grey">Sun, et al.                  Informational                     [Page 40]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-41"></span>
<span class="grey"><a href="./rfc3652">RFC 3652</a>             Handle System Protocol (v2.1)         November 2003</span>


      &lt;Message Body of LIST_HANDLE Response&gt;  ::=  &lt;Num_Handles&gt;
                                                   &lt;HandleList&gt;
         where

            &lt;Num_Handles&gt;
            Number of handles (managed by the handle server) under the
            naming authority.

            &lt;HandleList&gt;
            A list of UTF8-Strings, each of which identify a handle
            under the naming authority.

   The LIST_HANDLE request may potentially slow down the overall system
   performance.  A handle service (or its service site) has the option
   of whether or not to support such request.  The server will return an
   RC_OPERATION_DENIED message if LIST_HANDLE is not supported.  The
   server that receives a LIST_HANDLE request should authenticate the
   client as a naming authority administrator with the LIST_HANDLE
   privilege before fulfilling the request.

<span class="h4"><a class="dashAnchor" name="//apple_ref/cpp/Section/3.7.2.%20%20List%20Sub-Naming%20Authorities%20under%20a%20Naming%20Authority"></a><a class="selflink" href="#section-3.7.2" id="section-3.7.2">3.7.2</a>.  List Sub-Naming Authorities under a Naming Authority</span>

   Clients send LIST_NA requests to handle servers to get a list of
   sub-naming authorities under a naming authority.  The Message Header
   of the LIST_NA request must set its &lt;OpCode&gt; to OC_LIST_NA.

   The Message Body of any LIST_NA request is defined as follows:

      &lt;Message Body of LIST_HANDLE Request&gt; ::= &lt;NA_Handle&gt;

        where

          &lt;NA_Handle&gt;
          A UTF8-String that specifies the naming authority handle.

   To obtain a complete list of the sub-naming authorities, the request
   must be sent to every handle server listed in any one of the service
   sites of the GHR.  Each server within the service site will return
   its own list of sub-naming authority handles under the given naming
   authority.  The Message Body of a successful LIST_NA response (from
   each handle server) is defined as follows:










<span class="grey">Sun, et al.                  Informational                     [Page 41]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-42"></span>
<span class="grey"><a href="./rfc3652">RFC 3652</a>             Handle System Protocol (v2.1)         November 2003</span>


      &lt;Message Body of LIST_HANDLE Response&gt; ::=  &lt;Num_Handles&gt;
                                                  &lt;HandleList&gt;
         where

            &lt;Num_Handles&gt;
            Number of handles (managed by the handle server) under the
            naming authority.

            &lt;HandleList&gt;
            A list of UTF8-Strings, each of which identifies a sub-
            naming authority user-specified naming authority.

   LIST_NA requests must be sent to servers under the GHR that manages
   all the naming authority handles.  The LIST_NA request may
   potentially slow down the overall system performance, especially the
   GHS.  A server (or service sites) under the GHR has the option of
   whether or not to support such requests.  The server will return an
   RC_OPERATION_DENIED message if LIST_NA is not supported.  The server
   that receives a LIST_HANDLE request should authenticate the client as
   a naming authority administrator with the LIST_NA privilege before
   fulfilling the request.

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/3.8.%20%20Session%20and%20Session%20Management"></a><a class="selflink" href="#section-3.8" id="section-3.8">3.8</a>.  Session and Session Management</span>

   Sessions are used to allow sharing of authentication information or
   network resources among multiple protocol operations.  For example, a
   naming authority administrator may authenticate itself once through
   the session setup, and then register multiple handles under the
   session.

   A client may ask the server to establish a session key and use it for
   subsequent requests.  A session key is a secret key that is shared by
   the client and server.  It can be used to authenticate or encrypt any
   message exchanged under the session.  A session is encrypted if every
   message exchanged within the session is encrypted using the session
   key.

   Sessions may be established as the result of an explicit
   OC_SESSION_SETUP request from a client.  A server may also
   automatically setup a session when multiple message exchanges are
   expected to fulfill a request.  For example, the server will
   automatically establish a session if it receives a CREATE_HANDLE
   request that requires client authentication.

   Every session is identified by a non-zero Session ID that appears in
   the Message Header.  Servers are responsible for generating a unique
   Session ID for each outstanding session.  Each session may have a set
   of state information associated with it.  The state information may



<span class="grey">Sun, et al.                  Informational                     [Page 42]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-43"></span>
<span class="grey"><a href="./rfc3652">RFC 3652</a>             Handle System Protocol (v2.1)         November 2003</span>


   include the session key and the information obtained from client
   authentication, as well as any communication options.  Servers and
   clients are responsible for keeping the state information in sync
   until the session is terminated.

   A session may be terminated with an OC_SESSION_TERMINATE request from
   the client.  Servers may also terminate a session that has been idle
   for a significant amount of time.

<span class="h4"><a class="dashAnchor" name="//apple_ref/cpp/Section/3.8.1.%20%20Session%20Setup%20Request"></a><a class="selflink" href="#section-3.8.1" id="section-3.8.1">3.8.1</a>.  Session Setup Request</span>

   Clients establish a session with a handle server with a SESSION_SETUP
   request.  A SESSION_SETUP request can also be used to update any
   state information associated to an existing session.  The Message
   Header of the SESSION_SETUP request must have its &lt;OpCode&gt; set to
   OC_SESSION_SETUP and &lt;ResponseCode&gt; to 0.

   The Message Body of any SESSION_SETUP request is defined as follows:

      &lt;SESSION_SETUP Request Message Body&gt; ::= &lt;SessionAttributes&gt;

         where

            &lt;SessionAttributes&gt;
            A 4-byte unsigned integer followed by a list of session
            attributes.  The integer indicates the number of session
            attributes in the list.  Possible session attributes include
            the &lt;HS_SESSION_IDENTITY&gt;, the &lt;HS_SESSION_TIMEOUT&gt;, and the
            &lt;HS_SESSION_KEY_EXCHANGE&gt;.  Each of these attributes is
            defined as follows:

               &lt;HS_SESSION_IDENTITY&gt; ::= &lt;Key&gt;
                                         &lt;Handle&gt;
                                         &lt;ValueIndex&gt;
                  where

                     &lt;Key&gt;
                     A UTF-8 string constant "HS_SESSION_IDENTITY".

                     &lt;Handle&gt;
                     &lt;ValueIndex&gt;
                     A UTF-8 string followed by a 4-byte unsigned
                     integer that specifies the handle and the handle
                     value used for client authentication.  It must
                     refer to a handle value that contains the public
                     key of the client.  The public key is used by
                     the server to authenticate the client.




<span class="grey">Sun, et al.                  Informational                     [Page 43]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-44"></span>
<span class="grey"><a href="./rfc3652">RFC 3652</a>             Handle System Protocol (v2.1)         November 2003</span>


               &lt;HS_SESSION_KEY_EXCHANGE&gt; ::= &lt;Key&gt;
                                             &lt;KeyExchangeData&gt;
                  where

                     &lt;Key&gt;
                     A UTF-8 string constant "HS_SESSION_KEY_EXCHANGE".

                     &lt;KeyExchangeData&gt;
                     One of the these tuples: &lt;ClientCipher
                     &lt;ClientCipher KeyExchange&gt;,
                     &lt;HdlCipher KeyExchange&gt;, or
                     &lt;ServerCipher KeyExchange&gt;.
                     Each of these tuples is defined as follows:

                     &lt;ClientCipher KeyExchange&gt; ::= &lt;Key&gt;
                                                 &lt;PubKey&gt;
                        where

                           &lt;Key&gt;
                           A UTF-8 string constant "CLIENT_CIPHER".

                           &lt;PubKey&gt;
                           A public key provided by the client and used
                           by the server to encrypt the session key.

                     &lt;HdlCipher KeyExchange&gt; ::= &lt;Key&gt;
                                                 &lt;ExchangeKeyHdl&gt;
                                                 &lt;ExchangeKeyIndex&gt;
                        where

                           &lt;Key&gt;
                           A UTF-8 string constant "HDL_CIPHER".

                           &lt;ExchangeKeyHdl&gt;
                           &lt;ExchangeKeyIndex&gt;
                           A UTF-8 string followed by a 4-byte unsigned
                           integer.  The &lt;ExchangeKeyHdl&gt; and
                           &lt;ExchangeKeyIndex&gt; refers to a handle value
                           used for session key exchange.  The handle
                           value must contain the public key of the
                           client.  The public key will be used by the
                           server to encrypt the session key before
                           sending it to the client.

                     &lt;ServerCipher KeyExchange&gt; ::= &lt;Key&gt;

                        where




<span class="grey">Sun, et al.                  Informational                     [Page 44]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-45"></span>
<span class="grey"><a href="./rfc3652">RFC 3652</a>             Handle System Protocol (v2.1)         November 2003</span>


                        &lt;Key&gt;
                        A UTF-8 string constant "SERVER_CIPHER".  This
                        tells the server that the client will be
                        responsible for generating the session key.  The
                        server will have to provide its public key in
                        the response message and set the &lt;ResponseCode&gt;
                        to RC_SESSION_EXCHANGEKEY.  The client can use
                        the server's public key to encrypt the session
                        key and send it to the server via a subsequent
                        SESSION_EXCHANGEKEY request.

                     &lt;DiffieHellman KeyExchange&gt; ::= &lt;Key&gt;
                                                     &lt;DHParams&gt;
                        where

                           &lt;Key&gt;
                           A UTF-8 string constant "DIFFIE_HELLMAN"

                           &lt;DHParams&gt;
                           The values used as input in the Diffie-
                           Hellman algorithm.  It consists of three big
                           integers of variable length.  Each big
                           integer is encoded in terms of a 4-byte
                           unsigned integer followed by an octet string.
                           The octet string contains the big integer
                           itself.  The 4-byte unsigned integer
                           specifies the number of octets of the octet
                           string.


          &lt;HS_SESSION_TIMEOUT&gt; ::=  &lt;Key&gt;
                                    &lt;TimeOut&gt;
             where

                &lt;Key&gt;
                A UTF-8 string constant "HS_SESSION_TIMEOUT".

                &lt;TimeOut&gt;
                A 4-byte unsigned integer that specifies the desired
                duration of the session in seconds.

   Note that it should be treated as an error if the same session
   attribute is listed multiple times in the &lt;SessionAttribute&gt; field.
   When this happens, the server should return an error message with
   &lt;ResponseCode&gt; set to RC_PROTOCOL_ERROR.

   A SESSION_SETUP_REQUEST can be used to change session attributes of
   any established session.  This happens if the &lt;SessionId&gt; is non-zero



<span class="grey">Sun, et al.                  Informational                     [Page 45]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-46"></span>
<span class="grey"><a href="./rfc3652">RFC 3652</a>             Handle System Protocol (v2.1)         November 2003</span>


   and matches one of the established sessions.  Care must be taken by
   the server to prevent any unauthorized request from changing the
   session attributes.  For example, an encrypted session may only be
   changed into an unencrypted session by a SESSION_SETUP_REQUEST with
   an appropriate MAC in its Message Credential.

<span class="h4"><a class="dashAnchor" name="//apple_ref/cpp/Section/3.8.2.%20%20Session%20Setup%20Response"></a><a class="selflink" href="#section-3.8.2" id="section-3.8.2">3.8.2</a>.  Session Setup Response</span>

   The Message Header of the SESSION_SETUP response must set its
   &lt;OpCode&gt; to OC_SESSION_SETUP.  The &lt;ResponseCode&gt; of the
   SESSION_SETUP response varies according to the SESSION_SETUP request.
   It must be set to RC_SUCCESS if the SESSION_SETUP request is
   successful and the server does not expect a session key to be
   returned by the client.

   The Message Body of the SESSION_SETUP response is empty unless the
   request is asking for &lt;HS_SESSION_KEY_EXCHANGE&gt;.  In this case, the
   Message Body of the SESSION_SETUP response may contain the encrypted
   session key from the server, or the server's public key, to be used
   for session key exchange.  The exact format depends on the content of
   the &lt;HS_SESSION_KEY_EXCHANGE&gt; in the SESSION_SETUP request.  If
   &lt;ClientCipher KeyExchange&gt; or &lt;HdlCipher KeyExchange&gt; is given in the
   SESSION_SETUP request, the Message Body of the SESSION_SETUP response
   will contain the encrypted session key from the server and is defined
   as follows:

      &lt;Message Body of SESSION_SETUP Response&gt;
                                        ::= &lt;RequestDigest&gt;
                                            &lt;EncryptedSessionKey&gt;
                                          [ &lt;EncryptionAlgorithm&gt; ]
        where

          &lt;RequestDigest&gt;
          Message digest of the SESSION_SETUP request is as specified in
          <a href="#section-2.2.3">section 2.2.3</a>.

          &lt;EncryptedSessionKey&gt;
          Session key is encrypted using the public key provided in the
          SESSION_SETUP request.  The session key is a randomly
          generated octet string from the server.  The server will only
          return the &lt;EncryptedSessionKey&gt; if the &lt;KeyExchangeData&gt; in
          the SESSION_SETUP request provides the public key from the
          client.

          &lt;EncryptionAlgorithm&gt;
          (optional) UTF-8 string that identifies the encryption
          algorithm used by the session key.




<span class="grey">Sun, et al.                  Informational                     [Page 46]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-47"></span>
<span class="grey"><a href="./rfc3652">RFC 3652</a>             Handle System Protocol (v2.1)         November 2003</span>


   If &lt;ServerCipher KeyExchange&gt; is given in the SESSION_SETUP request,
   the server must provide its public key in the SESSION_SETUP response.
   The public key can be used by the client in a subsequent
   SESSION_EXCHANGEKEY request (defined below) for session key exchange.
   In this case, the Message Header of the SESSION_SETUP response must
   set its &lt;ResponseCode&gt; to RC_SESSION_EXCHANGEKEY.  The Message Body
   of the SESSION_SETUP response must include the server's public key
   and is defined as follows:

      &lt;Message Body of SESSION_SETUP response&gt;
                              ::= &lt;RequestDigest&gt;
                                  &lt;Public Key for Session Key Exchange&gt;

        where

          &lt;RequestDigest&gt;
          Message digest of the SESSION_SETUP request as specified in
          <a href="#section-2.2.3">section 2.2.3</a>.

          &lt;Public Key for Session Key Exchange&gt;
          Public key from the server to be used for session key
          exchange.  It is encoded in the same format as the &lt;PublicKey&gt;
          record in the HS_SITE value (see section 3.2.2 in [<a href="#ref-2" title='"Handle System Namespace and Service Definition"'>2</a>]).

<span class="h4"><a class="dashAnchor" name="//apple_ref/cpp/Section/3.8.3.%20%20Session%20Key%20Exchange"></a><a class="selflink" href="#section-3.8.3" id="section-3.8.3">3.8.3</a>.  Session Key Exchange</span>

   If the &lt;ResponseCode&gt; of a SESSION_SETUP response is
   RC_SESSION_EXCHANGEKEY, the client is responsible for generating the
   session key and sending it to the server.  In this case, the client
   can generate a session key, encrypt it with the public key provided
   by the server in the SESSION_SETUP response, and send the encrypted
   session key to the server in a SESSION_EXCHANGEKEY request.

   The Message Header of the SESSION_EXCHANGEKEY request must set its
   &lt;OpCode&gt; to OC_SESSION_EXCHANGEKEY and its &lt;ResponseCode&gt; to 0.  The
   Message Body of the SESSION_EXCHANGEKEY request is defined as
   follows:

      &lt;Message Body of OC_SESSION_EXCHANGEKEY&gt;
                      ::=   &lt;Encrypted Session Key&gt;
                          [ &lt;EncryptionAlgorithm&gt; ]

        where

          &lt;EncryptedSessionKey&gt;
          Session key encrypted using the public key provided in the
          SESSION_SETUP response.  The session key is a randomly
          generated octet string by the client.



<span class="grey">Sun, et al.                  Informational                     [Page 47]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-48"></span>
<span class="grey"><a href="./rfc3652">RFC 3652</a>             Handle System Protocol (v2.1)         November 2003</span>



          &lt;EncryptionAlgorithm&gt;
          (optional) UTF-8 string that identifies the encryption
          algorithm used by the session key.

   During the session key exchange, the server receiving the exchange
   key or session key has the responsibility of ensuring that the key
   meets the security requirements defined in its local policy.  If the
   server considers the key being volunable, it must return an error
   message to the client with &lt;ResponseCode&gt; set to
   RC_SESSION_KEY_INVALID.

<span class="h4"><a class="dashAnchor" name="//apple_ref/cpp/Section/3.8.4.%20%20Session%20Termination"></a><a class="selflink" href="#section-3.8.4" id="section-3.8.4">3.8.4</a>.  Session Termination</span>

   Clients can terminate a session with a SESSION_TERMINATE request.
   The Message Header of a SESSION_TERMINATE request must have its
   &lt;OpCode&gt; set to OC_SESSION_TERMINATE and its &lt;ResponseCode&gt; to 0.
   The message body of any SESSION_TERMINATE request must be empty.

   The server must send a SESSION_TERMINATE response to the client after
   the session is terminated.  The server should only terminate the
   session after it has finished processing all the requests (under the
   session) that were submitted before the Session Termination request.

   The message header of the SESSION_TERMINATE response must set its
   &lt;OpCode&gt; to OC_SESSION_TERMINATE.  A successful SESSION_TERMINATE
   response must have its &lt;ResponseCode&gt; set to RC_SUCCESS, and an empty
   message body.

<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/4.%20%20Implementation%20Guidelines"></a><a class="selflink" href="#section-4" id="section-4">4</a>.  Implementation Guidelines</span>

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/4.1.%20%20Server%20Implementation"></a><a class="selflink" href="#section-4.1" id="section-4.1">4.1</a>.  Server Implementation</span>

   The optimal structure for any handle server will depend on the host
   operating system.  This section only addresses those implementation
   considerations that are common to most handle servers.

   A good server implementation should allow easy configuration or
   fine-tuning.  A suggested list of configurable items includes the
   server's network interface(s) (e.g., IP address, port number, etc.),
   the number of concurrent processes/threads allowed, time-out
   intervals for any TCP connection and/or authentication process, re-
   try policy under UDP connection, policies on whether to support
   recursive service, case-sensitivity for ASCII characters, and
   different levels of transaction logging, etc.






<span class="grey">Sun, et al.                  Informational                     [Page 48]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-49"></span>
<span class="grey"><a href="./rfc3652">RFC 3652</a>             Handle System Protocol (v2.1)         November 2003</span>


   All handle server implementations must support all the handle data
   types as defined in the "Handle System Namespace and Service
   Definition" [<a href="#ref-2" title='"Handle System Namespace and Service Definition"'>2</a>].  They should also be able to store handle values of
   any application defined data type.

   A handle server must support multiple concurrent activities, whether
   they are implemented as separate processes or threads in the host's
   operating system, or multiplexed inside a single name server program.
   A handle server should not block the service of UDP requests while it
   waits for TCP data or other query activities.  Similarly, a handle
   server should not attempt to provide recursive service without
   processing such requests in parallel, though it may choose to
   serialize requests from a single client, or to regard identical
   requests from the same client as duplicates.

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/4.2.%20%20Client%20Implementation"></a><a class="selflink" href="#section-4.2" id="section-4.2">4.2</a>.  Client Implementation</span>

   Clients should be prepared to receive handle values of any data type.
   Clients may choose to implement a callback interface to allow new
   modules or plug-ins to be added to support any application-defined
   data types.

   Clients that follow service referrals or handle aliases must avoid
   falling into an infinite loop.  They should not repeatedly contact
   the same server for the same request with the same target entry.  A
   client may choose to use a counter that is incremented each time it
   follows a service referral or handle alias.  There should be a
   configurable upper limit to the counter to control the levels of
   service referrals or handle aliases followed by the client.

   Clients that provide some caching can expect much better performance
   than those that do not.  Client implementations should always
   consider caching the service information associated with a naming
   authority.  This will reduce the number of roundtrips for subsequent
   handle requests under the same naming authority.

<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/5.%20%20Security%20Considerations"></a><a class="selflink" href="#section-5" id="section-5">5</a>.  Security Considerations</span>

   The overall Handle System security considerations are discussed in
   "Handle System Overview" [<a href="#ref-1" title='"Handle System Overview"'>1</a>]; that discussion applies equally to this
   document.  Security considerations regarding the Handle System data
   model and service model are discussed in "Handle System Namespace and
   Service Definition" [<a href="#ref-2" title='"Handle System Namespace and Service Definition"'>2</a>].








<span class="grey">Sun, et al.                  Informational                     [Page 49]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-50"></span>
<span class="grey"><a href="./rfc3652">RFC 3652</a>             Handle System Protocol (v2.1)         November 2003</span>


   For efficiency, the Handle protocol includes a simple challenge-
   response authentication protocol for basic client authentication.
   Handle servers are free to provide additional authentication
   mechanisms (e.g., SASL) as needed.  Details of this will be discussed
   in a separate document.

   Data integrity under the Handle protocol is achieved via the server's
   digital signature.  Care must be taken to protect the server's
   private key from any impersonation attack.  Any change to the
   server's public key pair must be registered (in terms of service
   information) with the GHR.

<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/6.%20%20Acknowledgements"></a><a class="selflink" href="#section-6" id="section-6">6</a>.  Acknowledgements</span>

   This work is derived from the earlier versions of the Handle System
   implementation. The overall digital object architecture, including
   the Handle System, was described in a paper by Robert Kahn and Robert
   Wilensky [22] in 1995. Development continued at CNRI as part of the
   Computer Science Technical Reports (CSTR) project, funded by the
   Defense Advanced Projects Agency (DARPA) under Grant Number MDA-972-
   92-J-1029 and MDA-972-99-1-0018.  Design ideas are based on those
   discussed within the Handle System development team, including David
   Ely, Charles Orth, Allison Yu, Sean Reilly, Jane Euler, Catherine
   Rey, Stephanie Nguyen, Jason Petrone, and Helen She.  Their
   contributions to this work are gratefully acknowledged.

   The authors also thank Russ Housley (housley@vigilsec.com), Ted
   Hardie (hardie@qualcomm.com), and Mark Baugher (mbaugher@cisco.com)
   for their extensive review and comments, as well as recommendations
   received from other members of the IETF/IRTF community.

<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/7.%20%20Informative%20References"></a><a class="selflink" href="#section-7" id="section-7">7</a>.  Informative References</span>

   [<a id="ref-1">1</a>]  Sun, S. and L. Lannom, "Handle System Overview", <a href="./rfc3650">RFC 3650</a>,
        November 2003.

   [<a id="ref-2">2</a>]  Sun, S., Reilly, S. and L. Lannom, "Handle System Namespace and
        Service Definition", <a href="./rfc3651">RFC 3651</a>, November 2003.

   [<a id="ref-3">3</a>]  Yergeau, F., "UTF-8, a transformation format of ISO 10646", <a href="./rfc2279">RFC</a>
        <a href="./rfc2279">2279</a>, January 1998.

   [<a id="ref-4">4</a>]  A. Freier, P. Karlton, P. Kocher "The SSL Protocol Version 3.0"

   [<a id="ref-5">5</a>]  RSA Laboratories, "Public-Key Cryptography Standard PKCS#7"
        <a href="http://www.rsasecurity.com/rsalabs/pkcs/">http://www.rsasecurity.com/rsalabs/pkcs/</a>





<span class="grey">Sun, et al.                  Informational                     [Page 50]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-51"></span>
<span class="grey"><a href="./rfc3652">RFC 3652</a>             Handle System Protocol (v2.1)         November 2003</span>


   [<a id="ref-6">6</a>]  U.S. Federal Information Processing Standard: Digital Signature
        Standard.

   [<a id="ref-7">7</a>]  Housley, R., "Cryptographic Message Syntax (CMS) Algorithms",
        <a href="./rfc3370">RFC 3370</a>, August 2002.

   [<a id="ref-8">8</a>]  Braden, R., "FTP Data Compression", <a href="./rfc468">RFC 468</a>, March 1973.

   [<a id="ref-9">9</a>]  Rivest, R., "The MD5 Message-Digest Algorithm", <a href="./rfc1321">RFC 1321</a>, April
        1992.

   [<a id="ref-10">10</a>] NIST, FIPS PUB 180-1: Secure Hash Standard, April 1995.

   [<a id="ref-11">11</a>] D. Cohen, "On Holy Wars and a Plea for Peace", Internet
        Experiment, Note IEN 137, 1 April 1980.

   [<a id="ref-12">12</a>] Balakrishnan, H. and S. Seshan, "The Congestion Manager", <a href="./rfc3124">RFC</a>
        <a href="./rfc3124">3124</a>, June 2001.

   [<a id="ref-13">13</a>] R. Kahn, R. Wilensky, "A Framework for Distributed Digital
        Object Services, May 1995, <a href="http://www.cnri.reston.va.us/k-w.html">http://www.cnri.reston.va.us/k-w.html</a>

   [<a id="ref-14">14</a>] Polk, W., Housley, R. and L. Bassham, "Algorithms and
        Identifiers for the Internet X.509 Public Key Infrastructure
        Certificate and Certificate Revocation List (CRL) Profile", <a href="./rfc3279">RFC</a>
        <a href="./rfc3279">3279</a>, April 2002.

   [<a id="ref-15">15</a>] Housley, R., Polk, W., Ford, W. and D. Solo, "Internet X.509
        Public Key Infrastructure Certificate and Certificate Revocation
        List (CRL) Profile", <a href="./rfc3280">RFC 3280</a>, April 2002.

   [<a id="ref-16">16</a>] M. Bellare and P. Rogaway. The Exact Security of Digital
        Signatures - How to Sign with RSA and Rabin. In Advances in
        Cryptology-Eurocrypt '96, pp.399-416, Springer-Verlag, 1996.

   [<a id="ref-17">17</a>] Krawczyk, H., Bellare, M. and R. Canetti, "HMAC: Keyed-Hashing
        for Message Authentication", <a href="./rfc2104">RFC 2104</a>, February 1997.

   [<a id="ref-18">18</a>] R. Kahn, R. Wilensky, "A Framework for Distributed Digital
        Object Services, May 1995, <a href="http://www.cnri.reston.va.us/k-w.html">http://www.cnri.reston.va.us/k-w.html</a>











<span class="grey">Sun, et al.                  Informational                     [Page 51]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-52"></span>
<span class="grey"><a href="./rfc3652">RFC 3652</a>             Handle System Protocol (v2.1)         November 2003</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/8.%20%20Authors%27%20Addresses"></a><a class="selflink" href="#section-8" id="section-8">8</a>.  Authors' Addresses</span>

   Sam X. Sun
   Corporation for National Research Initiatives (CNRI)
   1895 Preston White Dr., Suite 100
   Reston, VA 20191

   Phone: 703-262-5316
   EMail: ssun@cnri.reston.va.us


   Sean Reilly
   Corporation for National Research Initiatives (CNRI)
   1895 Preston White Dr., Suite 100
   Reston, VA 20191

   Phone: 703-620-8990
   EMail: sreilly@cnri.reston.va.us


   Larry Lannom
   Corporation for National Research Initiatives (CNRI)
   1895 Preston White Dr., Suite 100
   Reston, VA 20191

   Phone: 703-262-5307
   EMail: llannom@cnri.reston.va.us


   Jason Petrone
   Corporation for National Research Initiatives (CNRI)
   1895 Preston White Dr., Suite 100
   Reston, VA 20191

   Phone: 703-262-5340
   EMail: jpetrone@cnri.reston.va.us















<span class="grey">Sun, et al.                  Informational                     [Page 52]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-53"></span>
<span class="grey"><a href="./rfc3652">RFC 3652</a>             Handle System Protocol (v2.1)         November 2003</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/9.%20%20Full%20Copyright%20Statement"></a><a class="selflink" href="#section-9" id="section-9">9</a>.  Full Copyright Statement</span>

   Copyright (C) The Internet Society (2003).  All Rights Reserved.

   This document and translations of it may be copied and furnished to
   others, and derivative works that comment on or otherwise explain it
   or assist in its implementation may be prepared, copied, published
   and distributed, in whole or in part, without restriction of any
   kind, provided that the above copyright notice and this paragraph are
   included on all such copies and derivative works.  However, this
   document itself may not be modified in any way, such as by removing
   the copyright notice or references to the Internet Society or other
   Internet organizations, except as needed for the purpose of
   developing Internet standards in which case the procedures for
   copyrights defined in the Internet Standards process must be
   followed, or as required to translate it into languages other than
   English.

   The limited permissions granted above are perpetual and will not be
   revoked by the Internet Society or its successors or assignees.

   This document and the information contained herein is provided on an
   "AS IS" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING
   TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING
   BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION
   HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF
   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.

Acknowledgement

   Funding for the RFC Editor function is currently provided by the
   Internet Society.



















Sun, et al.                  Informational                     [Page 53]
</pre>
</body></html>