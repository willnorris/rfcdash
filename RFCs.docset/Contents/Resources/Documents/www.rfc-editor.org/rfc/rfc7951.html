<html><head></head><body><pre>Internet Engineering Task Force (IETF)                         L. Lhotka
Request for Comments: 7951                                        CZ.NIC
Category: Standards Track                                    August 2016
ISSN: 2070-1721


                <span class="h1">JSON Encoding of Data Modeled with YANG</span>

Abstract

   This document defines encoding rules for representing configuration
   data, state data, parameters of Remote Procedure Call (RPC)
   operations or actions, and notifications defined using YANG as
   JavaScript Object Notation (JSON) text.

Status of This Memo

   This is an Internet Standards Track document.

   This document is a product of the Internet Engineering Task Force
   (IETF).  It represents the consensus of the IETF community.  It has
   received public review and has been approved for publication by the
   Internet Engineering Steering Group (IESG).  Further information on
   Internet Standards is available in <a href="./rfc7841#section-2">SectionÂ 2 of RFC 7841</a>.

   Information about the current status of this document, any errata,
   and how to provide feedback on it may be obtained at
   <a href="http://www.rfc-editor.org/info/rfc7951">http://www.rfc-editor.org/info/rfc7951</a>.

Copyright Notice

   Copyright (c) 2016 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to <a href="https://www.rfc-editor.org/bcp/bcp78">BCP 78</a> and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (<a href="http://trustee.ietf.org/license-info">http://trustee.ietf.org/license-info</a>) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.








<span class="grey">Lhotka                       Standards Track                    [Page 1]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-2"></span>
<span class="grey"><a href="./rfc7951">RFC 7951</a>               JSON Encoding of YANG Data            August 2016</span>


Table of Contents

   <a href="#section-1">1</a>.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   <a href="#page-3">3</a>
   <a href="#section-2">2</a>.  Terminology and Notation  . . . . . . . . . . . . . . . . . .   <a href="#page-3">3</a>
   <a href="#section-3">3</a>.  Properties of the JSON Encoding . . . . . . . . . . . . . . .   <a href="#page-4">4</a>
   <a href="#section-4">4</a>.  Names and Namespaces  . . . . . . . . . . . . . . . . . . . .   <a href="#page-5">5</a>
   <a href="#section-5">5</a>.  Encoding of YANG Data Node Instances  . . . . . . . . . . . .   <a href="#page-7">7</a>
     <a href="#section-5.1">5.1</a>.  The "leaf" Data Node  . . . . . . . . . . . . . . . . . .   <a href="#page-7">7</a>
     <a href="#section-5.2">5.2</a>.  The "container" Data Node . . . . . . . . . . . . . . . .   <a href="#page-8">8</a>
     <a href="#section-5.3">5.3</a>.  The "leaf-list" Data Node . . . . . . . . . . . . . . . .   <a href="#page-8">8</a>
     <a href="#section-5.4">5.4</a>.  The "list" Data Node  . . . . . . . . . . . . . . . . . .   <a href="#page-9">9</a>
     <a href="#section-5.5">5.5</a>.  The "anydata" Data Node . . . . . . . . . . . . . . . . .   <a href="#page-9">9</a>
     <a href="#section-5.6">5.6</a>.  The "anyxml" Data Node  . . . . . . . . . . . . . . . . .  <a href="#page-10">10</a>
     <a href="#section-5.7">5.7</a>.  Metadata Objects  . . . . . . . . . . . . . . . . . . . .  <a href="#page-11">11</a>
   <a href="#section-6">6</a>.  Representing YANG Data Types in JSON Values . . . . . . . . .  <a href="#page-11">11</a>
     <a href="#section-6.1">6.1</a>.  Numeric Types . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-11">11</a>
     <a href="#section-6.2">6.2</a>.  The "string" Type . . . . . . . . . . . . . . . . . . . .  <a href="#page-11">11</a>
     <a href="#section-6.3">6.3</a>.  The "boolean" Type  . . . . . . . . . . . . . . . . . . .  <a href="#page-11">11</a>
     <a href="#section-6.4">6.4</a>.  The "enumeration" Type  . . . . . . . . . . . . . . . . .  <a href="#page-12">12</a>
     <a href="#section-6.5">6.5</a>.  The "bits" Type . . . . . . . . . . . . . . . . . . . . .  <a href="#page-12">12</a>
     <a href="#section-6.6">6.6</a>.  The "binary" Type . . . . . . . . . . . . . . . . . . . .  <a href="#page-12">12</a>
     <a href="#section-6.7">6.7</a>.  The "leafref" Type  . . . . . . . . . . . . . . . . . . .  <a href="#page-12">12</a>
     <a href="#section-6.8">6.8</a>.  The "identityref" Type  . . . . . . . . . . . . . . . . .  <a href="#page-12">12</a>
     <a href="#section-6.9">6.9</a>.  The "empty" Type  . . . . . . . . . . . . . . . . . . . .  <a href="#page-13">13</a>
     <a href="#section-6.10">6.10</a>. The "union" Type  . . . . . . . . . . . . . . . . . . . .  <a href="#page-14">14</a>
     <a href="#section-6.11">6.11</a>. The "instance-identifier" Type  . . . . . . . . . . . . .  <a href="#page-15">15</a>
   <a href="#section-7">7</a>.  I-JSON Compliance . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-15">15</a>
   <a href="#section-8">8</a>.  Security Considerations . . . . . . . . . . . . . . . . . . .  <a href="#page-16">16</a>
   <a href="#section-9">9</a>.  References  . . . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-16">16</a>
     <a href="#section-9.1">9.1</a>.  Normative References  . . . . . . . . . . . . . . . . . .  <a href="#page-16">16</a>
     <a href="#section-9.2">9.2</a>.  Informative References  . . . . . . . . . . . . . . . . .  <a href="#page-17">17</a>
   <a href="#appendix-A">Appendix A</a>.  A Complete Example . . . . . . . . . . . . . . . . .  <a href="#page-18">18</a>
   Acknowledgements  . . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-20">20</a>
   Author's Address  . . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-20">20</a>

















<span class="grey">Lhotka                       Standards Track                    [Page 2]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-3"></span>
<span class="grey"><a href="./rfc7951">RFC 7951</a>               JSON Encoding of YANG Data            August 2016</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/1.%20%20Introduction"></a><a class="selflink" href="#section-1" id="section-1">1</a>.  Introduction</span>

   The Network Configuration Protocol (NETCONF) [<a href="./rfc6241" title='"Network Configuration Protocol (NETCONF)"'>RFC6241</a>] uses XML [<a href="#ref-XML" title='"Extensible Markup Language (XML) 1.0 (Fifth Edition)"'>XML</a>]
   for encoding data in its Content Layer.  Other management protocols
   might want to use other encodings while still benefiting from using
   YANG [<a href="./rfc7950" title='"The YANG 1.1 Data Modeling Language"'>RFC7950</a>] as the data modeling language.

   For example, the RESTCONF protocol [<a href="#ref-RESTCONF" title='"RESTCONF Protocol"'>RESTCONF</a>] supports two encodings:
   XML (media type "application/yang.data+xml") and JavaScript Object
   Notation (JSON) (media type "application/yang.data+json").

   The specification of the YANG 1.1 data modeling language [<a href="./rfc7950" title='"The YANG 1.1 Data Modeling Language"'>RFC7950</a>]
   defines only XML encoding of data trees, i.e., configuration data,
   state data, input/output parameters of Remote Procedure Call (RPC)
   operations or actions, and notifications.  The aim of this document
   is to define rules for encoding the same data as JSON text [<a href="./rfc7159" title='"The JavaScript Object Notation (JSON) Data Interchange Format"'>RFC7159</a>].

<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/2.%20%20Terminology%20and%20Notation"></a><a class="selflink" href="#section-2" id="section-2">2</a>.  Terminology and Notation</span>

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in [<a href="./rfc2119" title='"Key words for use in RFCs to Indicate Requirement Levels"'>RFC2119</a>].

   The following terms are defined in [<a href="./rfc7950" title='"The YANG 1.1 Data Modeling Language"'>RFC7950</a>]:

   o  action

   o  anydata

   o  anyxml

   o  augment

   o  container

   o  data node

   o  data tree

   o  identity

   o  instance identifier

   o  leaf

   o  leaf-list

   o  list



<span class="grey">Lhotka                       Standards Track                    [Page 3]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-4"></span>
<span class="grey"><a href="./rfc7951">RFC 7951</a>               JSON Encoding of YANG Data            August 2016</span>


   o  module

   o  RPC operation

   o  submodule

   The following terms are defined in [<a href="./rfc6241" title='"Network Configuration Protocol (NETCONF)"'>RFC6241</a>]:

   o  configuration data

   o  notification

   o  state data

<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/3.%20%20Properties%20of%20the%20JSON%20Encoding"></a><a class="selflink" href="#section-3" id="section-3">3</a>.  Properties of the JSON Encoding</span>

   This document defines JSON encoding for YANG data trees and their
   subtrees.  It is always assumed that the top-level structure in JSON-
   encoded data is an object.

   Instances of YANG data nodes (leafs, containers, leaf-lists, lists,
   anydata nodes, and anyxml nodes) are encoded as members of a JSON
   object, i.e., name/value pairs.  <a href="#section-4">Section 4</a> defines how the name part
   is formed, and the following sections deal with the value part.  The
   encoding rules are identical for all types of data trees, i.e.,
   configuration data, state data, parameters of RPC operations,
   actions, and notifications.

   With the exception of "anydata" encoding (<a href="#section-5.5">Section 5.5</a>), all rules in
   this document are also applicable to YANG 1.0 [<a href="./rfc6020" title='"YANG - A Data Modeling Language for the Network Configuration Protocol (NETCONF)"'>RFC6020</a>].

   Unlike XML element content, JSON values carry partial type
   information (number, string, boolean).  The JSON encoding is defined
   so that this information is never in conflict with the data type of
   the corresponding YANG leaf or leaf-list.

   With the exception of anyxml and schema-less anydata nodes, it is
   possible to map a JSON-encoded data tree to XML encoding as defined
   in [<a href="./rfc7950" title='"The YANG 1.1 Data Modeling Language"'>RFC7950</a>], and vice versa.  However, such conversions require the
   YANG data model to be available.

   In order to achieve maximum interoperability while allowing
   implementations to use a variety of existing JSON parsers, the JSON
   encoding rules follow, as much as possible, the constraints of the
   I-JSON (Internet JSON) restricted profile [<a href="./rfc7493" title='"The I-JSON Message Format"'>RFC7493</a>].  <a href="#section-7">Section 7</a>
   discusses I-JSON conformance in more detail.





<span class="grey">Lhotka                       Standards Track                    [Page 4]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-5"></span>
<span class="grey"><a href="./rfc7951">RFC 7951</a>               JSON Encoding of YANG Data            August 2016</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/4.%20%20Names%20and%20Namespaces"></a><a class="selflink" href="#section-4" id="section-4">4</a>.  Names and Namespaces</span>

   A JSON object member name MUST be in one of the following forms:

   o  simple - identical to the identifier of the corresponding YANG
      data node.

   o  namespace-qualified - the data node identifier is prefixed with
      the name of the module in which the data node is defined,
      separated from the data node identifier by the colon character
      (":").

   The name of a module determines the namespace of all data node names
   defined in that module.  If a data node is defined in a submodule,
   then the namespace-qualified member name uses the name of the main
   module to which the submodule belongs.

   ABNF syntax [<a href="./rfc5234" title='"Augmented BNF for Syntax Specifications: ABNF"'>RFC5234</a>] of a member name is shown in Figure 1, where
   the production for "identifier" is defined in <a href="./rfc7950#section-14">SectionÂ 14 of
   [RFC7950]</a>.

           member-name = [identifier ":"] identifier

             Figure 1: ABNF Production for a JSON Member Name

   A namespace-qualified member name MUST be used for all members of a
   top-level JSON object and then also whenever the namespaces of the
   data node and its parent node are different.  In all other cases, the
   simple form of the member name MUST be used.

   For example, consider the following YANG module:

   module example-foomod {

     namespace "http://example.com/foomod";

     prefix "foomod";

     container top {
       leaf foo {
         type uint8;
       }
     }
   }







<span class="grey">Lhotka                       Standards Track                    [Page 5]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-6"></span>
<span class="grey"><a href="./rfc7951">RFC 7951</a>               JSON Encoding of YANG Data            August 2016</span>


   If the data model consists only of this module, then the following is
   valid JSON-encoded configuration data:

   {
     "example-foomod:top": {
       "foo": 54
     }
   }

   Note that the member of the top-level object uses the namespace-
   qualified name but the "foo" leaf doesn't because it is defined in
   the same module as its parent container "top".

   Now, assume that the container "top" is augmented from another
   module, "example-barmod":

   module example-barmod {

     namespace "http://example.com/barmod";

     prefix "barmod";

     import example-foomod {
       prefix "foomod";
     }

     augment "/foomod:top" {
       leaf bar {
         type boolean;
       }
     }
   }

   Valid JSON-encoded configuration data containing both leafs may then
   look like this:

   {
     "example-foomod:top": {
       "foo": 54,
       "example-barmod:bar": true
     }
   }

   The name of the "bar" leaf is prefixed with the namespace identifier
   because its parent is defined in a different module.






<span class="grey">Lhotka                       Standards Track                    [Page 6]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-7"></span>
<span class="grey"><a href="./rfc7951">RFC 7951</a>               JSON Encoding of YANG Data            August 2016</span>


   Explicit namespace identifiers are sometimes needed when encoding
   values of the "identityref" and "instance-identifier" types.  The
   same form of namespace-qualified name as defined above is then used.
   See Sections <a href="#section-6.8">6.8</a> and <a href="#section-6.11">6.11</a> for details.

<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/5.%20%20Encoding%20of%20YANG%20Data%20Node%20Instances"></a><a class="selflink" href="#section-5" id="section-5">5</a>.  Encoding of YANG Data Node Instances</span>

   Every data node instance is encoded as a name/value pair where the
   name is formed from the data node identifier using the rules of
   <a href="#section-4">Section 4</a>.  The value depends on the category of the data node, as
   explained in the following subsections.

   Character encoding MUST be UTF-8.

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/5.1.%20%20The%20%22leaf%22%20Data%20Node"></a><a class="selflink" href="#section-5.1" id="section-5.1">5.1</a>.  The "leaf" Data Node</span>

   A leaf instance is encoded as a name/value pair where the value can
   be a string, number, literal "true" or "false", or the special array
   "[null]", depending on the type of the leaf (see <a href="#section-6">Section 6</a> for the
   type encoding rules).

   Example: For the leaf node definition

   leaf foo {
     type uint8;
   }

   the following is a valid JSON-encoded instance:

   "foo": 123





















<span class="grey">Lhotka                       Standards Track                    [Page 7]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-8"></span>
<span class="grey"><a href="./rfc7951">RFC 7951</a>               JSON Encoding of YANG Data            August 2016</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/5.2.%20%20The%20%22container%22%20Data%20Node"></a><a class="selflink" href="#section-5.2" id="section-5.2">5.2</a>.  The "container" Data Node</span>

   A container instance is encoded as a name/object pair.  The
   container's child data nodes are encoded as members of the object.

   Example: For the container definition

   container bar {
     leaf foo {
       type uint8;
     }
   }

   the following is a valid JSON-encoded instance:

   "bar": {
     "foo": 123
   }

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/5.3.%20%20The%20%22leaf-list%22%20Data%20Node"></a><a class="selflink" href="#section-5.3" id="section-5.3">5.3</a>.  The "leaf-list" Data Node</span>

   A leaf-list is encoded as a name/array pair, and the array elements
   are values of some scalar type, which can be a string, number,
   literal "true" or "false", or the special array "[null]", depending
   on the type of the leaf-list (see <a href="#section-6">Section 6</a> for the type encoding
   rules).

   The ordering of array elements follows the same rules as the ordering
   of XML elements representing leaf-list entries in the XML encoding.
   Specifically, the "ordered-by" properties (<a href="./rfc7950#section-7.7.7">SectionÂ 7.7.7 in
   [RFC7950]</a>) MUST be observed.

   Example: For the leaf-list definition

   leaf-list foo {
     type uint8;
   }

   the following is a valid JSON-encoded instance:

   "foo": [123, 0]










<span class="grey">Lhotka                       Standards Track                    [Page 8]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-9"></span>
<span class="grey"><a href="./rfc7951">RFC 7951</a>               JSON Encoding of YANG Data            August 2016</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/5.4.%20%20The%20%22list%22%20Data%20Node"></a><a class="selflink" href="#section-5.4" id="section-5.4">5.4</a>.  The "list" Data Node</span>

   A list instance is encoded as a name/array pair, and the array
   elements are JSON objects.

   The ordering of array elements follows the same rules as the ordering
   of XML elements representing list entries in the XML encoding.
   Specifically, the "ordered-by" properties (<a href="./rfc7950#section-7.7.7">SectionÂ 7.7.7 in
   [RFC7950]</a>) MUST be observed.

   Unlike the XML encoding, where list keys are required to precede any
   other siblings within a list entry and appear in the order specified
   by the data model, the order of members in a JSON-encoded list entry
   is arbitrary because JSON objects are fundamentally unordered
   collections of members.

   Example: For the list definition

   list bar {
     key foo;
     leaf foo {
       type uint8;
     }
     leaf baz {
       type string;
     }
   }

   the following is a valid JSON-encoded instance:

   "bar": [
     {
       "foo": 123,
       "baz": "zig"
     },
     {
       "baz": "zag",
       "foo": 0
     }
   ]

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/5.5.%20%20The%20%22anydata%22%20Data%20Node"></a><a class="selflink" href="#section-5.5" id="section-5.5">5.5</a>.  The "anydata" Data Node</span>

   The anydata data node serves as a container for an arbitrary set of
   nodes that otherwise appear as normal YANG-modeled data.  A data
   model for anydata content may or may not be known at runtime.  In the
   latter case, converting JSON-encoded instances to the XML encoding
   defined in [<a href="./rfc7950" title='"The YANG 1.1 Data Modeling Language"'>RFC7950</a>] may be impossible.



<span class="grey">Lhotka                       Standards Track                    [Page 9]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-10"></span>
<span class="grey"><a href="./rfc7951">RFC 7951</a>               JSON Encoding of YANG Data            August 2016</span>


   An anydata instance is encoded in the same way as a container, i.e.,
   as a name/object pair.  The requirement that anydata content can be
   modeled by YANG implies the following rules for the JSON text inside
   the object:

   o  It is valid I-JSON [<a href="./rfc7493" title='"The I-JSON Message Format"'>RFC7493</a>].

   o  All object member names satisfy the ABNF production in Figure 1.

   o  Any JSON array contains either only unique scalar values (as a
      leaf-list; see <a href="#section-5.3">Section 5.3</a>) or only objects (as a list; see
      <a href="#section-5.4">Section 5.4</a>).

   o  The "null" value is only allowed in the single-element array
      "[null]" corresponding to the encoding of the "empty" type; see
      <a href="#section-6.9">Section 6.9</a>.

   Example: For the anydata definition

   anydata data;

   the following is a valid JSON-encoded instance:

   "data": {
     "ietf-notification:notification": {
       "eventTime": "2014-07-29T13:43:01Z",
       "example-event:event": {
         "event-class": "fault",
         "reporting-entity": {
           "card": "Ethernet0"
         },
         "severity": "major"
       }
     }
   }

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/5.6.%20%20The%20%22anyxml%22%20Data%20Node"></a><a class="selflink" href="#section-5.6" id="section-5.6">5.6</a>.  The "anyxml" Data Node</span>

   An anyxml instance is encoded as a JSON name/value pair.  The value
   MUST satisfy I-JSON constraints.

   Example: For the anyxml definition

   anyxml bar;

   the following is a valid JSON-encoded instance:

   "bar": [true, null, true]



<span class="grey">Lhotka                       Standards Track                   [Page 10]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-11"></span>
<span class="grey"><a href="./rfc7951">RFC 7951</a>               JSON Encoding of YANG Data            August 2016</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/5.7.%20%20Metadata%20Objects"></a><a class="selflink" href="#section-5.7" id="section-5.7">5.7</a>.  Metadata Objects</span>

   Apart from instances of YANG data nodes, a JSON document MAY contain
   special object members whose name starts with the "@" character
   (COMMERCIAL AT).  Such members are used for special purposes, such as
   encoding metadata [<a href="./rfc7952" title='"Defining and Using Metadata with YANG"'>RFC7952</a>].  The exact syntax and semantics of such
   members are outside the scope of this document.

<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/6.%20%20Representing%20YANG%20Data%20Types%20in%20JSON%20Values"></a><a class="selflink" href="#section-6" id="section-6">6</a>.  Representing YANG Data Types in JSON Values</span>

   The type of the JSON value in an instance of the leaf or leaf-list
   data node depends on the type of that data node, as specified in the
   following subsections.

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/6.1.%20%20Numeric%20Types"></a><a class="selflink" href="#section-6.1" id="section-6.1">6.1</a>.  Numeric Types</span>

   A value of the "int8", "int16", "int32", "uint8", "uint16", or
   "uint32" type is represented as a JSON number.

   A value of the "int64", "uint64", or "decimal64" type is represented
   as a JSON string whose content is the lexical representation of the
   corresponding YANG type as specified in Sections <a href="#section-9.2.1">9.2.1</a> and <a href="#section-9.3.1">9.3.1</a> of
   [<a href="./rfc7950" title='"The YANG 1.1 Data Modeling Language"'>RFC7950</a>].

   For example, if the type of the leaf "foo" in <a href="#section-5.1">Section 5.1</a> was
   "uint64" instead of "uint8", the instance would have to be encoded as

   "foo": "123"

   The special handling of 64-bit numbers follows from the I-JSON
   recommendation to encode numbers exceeding the IEEE 754-2008
   double-precision range [<a href="#ref-IEEE754-2008">IEEE754-2008</a>] as strings; see <a href="./rfc7493#section-2.2">SectionÂ 2.2 in
   [RFC7493]</a>.

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/6.2.%20%20The%20%22string%22%20Type"></a><a class="selflink" href="#section-6.2" id="section-6.2">6.2</a>.  The "string" Type</span>

   A "string" value is represented as a JSON string, subject to JSON
   string encoding rules.

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/6.3.%20%20The%20%22boolean%22%20Type"></a><a class="selflink" href="#section-6.3" id="section-6.3">6.3</a>.  The "boolean" Type</span>

   A "boolean" value is represented as the corresponding JSON literal
   name "true" or "false".








<span class="grey">Lhotka                       Standards Track                   [Page 11]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-12"></span>
<span class="grey"><a href="./rfc7951">RFC 7951</a>               JSON Encoding of YANG Data            August 2016</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/6.4.%20%20The%20%22enumeration%22%20Type"></a><a class="selflink" href="#section-6.4" id="section-6.4">6.4</a>.  The "enumeration" Type</span>

   An "enumeration" value is represented as a JSON string -- one of the
   names assigned by "enum" statements in YANG.

   The representation is identical to the lexical representation of the
   "enumeration" type in XML; see <a href="./rfc7950#section-9.6">SectionÂ 9.6 in [RFC7950]</a>.

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/6.5.%20%20The%20%22bits%22%20Type"></a><a class="selflink" href="#section-6.5" id="section-6.5">6.5</a>.  The "bits" Type</span>

   A "bits" value is represented as a JSON string -- a space-separated
   sequence of names of bits that are set.  The permitted bit names are
   assigned by "bit" statements in YANG.

   The representation is identical to the lexical representation of the
   "bits" type; see <a href="./rfc7950#section-9.7">SectionÂ 9.7 in [RFC7950]</a>.

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/6.6.%20%20The%20%22binary%22%20Type"></a><a class="selflink" href="#section-6.6" id="section-6.6">6.6</a>.  The "binary" Type</span>

   A "binary" value is represented as a JSON string -- base64 encoding
   of arbitrary binary data.

   The representation is identical to the lexical representation of the
   "binary" type in XML; see <a href="./rfc7950#section-9.8">SectionÂ 9.8 in [RFC7950]</a>.

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/6.7.%20%20The%20%22leafref%22%20Type"></a><a class="selflink" href="#section-6.7" id="section-6.7">6.7</a>.  The "leafref" Type</span>

   A "leafref" value is represented using the same rules as the type of
   the leaf to which the leafref value refers.

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/6.8.%20%20The%20%22identityref%22%20Type"></a><a class="selflink" href="#section-6.8" id="section-6.8">6.8</a>.  The "identityref" Type</span>

   An "identityref" value is represented as a string -- the name of an
   identity.  If the identity is defined in a module other than the leaf
   node containing the identityref value, the namespace-qualified form
   (<a href="#section-4">Section 4</a>) MUST be used.  Otherwise, both the simple and namespace-
   qualified forms are permitted.














<span class="grey">Lhotka                       Standards Track                   [Page 12]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-13"></span>
<span class="grey"><a href="./rfc7951">RFC 7951</a>               JSON Encoding of YANG Data            August 2016</span>


   For example, consider the following schematic module:

   module example-mod {
     ...
     import ietf-interfaces {
       prefix if;
     }
     ...
     leaf type {
       type identityref {
         base "if:interface-type";
       }
     }
   }

   A valid instance of the "type" leaf is then encoded as follows:

   "type": "iana-if-type:ethernetCsmacd"

   The namespace identifier "iana-if-type" must be present in this case
   because the "ethernetCsmacd" identity is not defined in the same
   module as the "type" leaf.

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/6.9.%20%20The%20%22empty%22%20Type"></a><a class="selflink" href="#section-6.9" id="section-6.9">6.9</a>.  The "empty" Type</span>

   An "empty" value is represented as "[null]", i.e., an array with the
   "null" literal being its only element.  For the purposes of this
   document, "[null]" is considered an atomic scalar value.

   This encoding of the "empty" type was chosen instead of using simply
   "null" in order to facilitate the use of empty leafs in common
   programming languages where the "null" value of a member is treated
   as if the member is not present.

   Example: For the leaf definition

   leaf foo {
     type empty;
   }

   a valid instance is

   "foo": [null]








<span class="grey">Lhotka                       Standards Track                   [Page 13]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-14"></span>
<span class="grey"><a href="./rfc7951">RFC 7951</a>               JSON Encoding of YANG Data            August 2016</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/6.10.%20%20The%20%22union%22%20Type"></a><a class="selflink" href="#section-6.10" id="section-6.10">6.10</a>.  The "union" Type</span>

   A value of the "union" type is encoded as the value of any of the
   member types.

   When validating a value of the "union" type, the type information
   conveyed by the JSON encoding MUST also be taken into account.  JSON
   syntax thus provides additional means for resolving the member type
   of the union that are not available in XML encoding.

   For example, consider the following YANG definition:

   leaf bar {
     type union {
       type uint16;
       type string;
     }
   }

   In RESTCONF [<a href="#ref-RESTCONF" title='"RESTCONF Protocol"'>RESTCONF</a>], it is possible to set the value of "bar" in
   the following way when using the "application/yang.data+xml"
   media type:

   &lt;bar&gt;13.5&lt;/bar&gt;

   because the value may be interpreted as a string, i.e., the
   second member type of the union.  When using the
   "application/yang.data+json" media type, however, this is an error:

   "bar": 13.5

   In this case, the JSON encoding indicates that the value is supposed
   to be a number rather than a string, and it is not a valid "uint16"
   value.

   Conversely, the value of

   "bar": "1"

   is to be interpreted as a string.











<span class="grey">Lhotka                       Standards Track                   [Page 14]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-15"></span>
<span class="grey"><a href="./rfc7951">RFC 7951</a>               JSON Encoding of YANG Data            August 2016</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/6.11.%20%20The%20%22instance-identifier%22%20Type"></a><a class="selflink" href="#section-6.11" id="section-6.11">6.11</a>.  The "instance-identifier" Type</span>

   An "instance-identifier" value is encoded as a string that is
   analogical to the lexical representation in XML encoding; see
   <a href="./rfc7950#section-9.13.2">SectionÂ 9.13.2 in [RFC7950]</a>.  However, the encoding of namespaces in
   instance-identifier values follows the rules stated in <a href="#section-4">Section 4</a>,
   namely:

   o  The leftmost (top-level) data node name is always in the
      namespace-qualified form.

   o  Any subsequent data node name is in the namespace-qualified form
      if the node is defined in a module other than its parent node, and
      the simple form is used otherwise.  This rule also holds for node
      names appearing in predicates.

   For example,

   /ietf-interfaces:interfaces/interface[name='eth0']/ietf-ip:ipv4/ip

   is a valid instance-identifier value because the data nodes
   "interfaces", "interface", and "name" are defined in the module
   "ietf-interfaces", whereas "ipv4" and "ip" are defined in "ietf-ip".

<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/7.%20%20I-JSON%20Compliance"></a><a class="selflink" href="#section-7" id="section-7">7</a>.  I-JSON Compliance</span>

   I-JSON [<a href="./rfc7493" title='"The I-JSON Message Format"'>RFC7493</a>] is a restricted profile of JSON that guarantees
   maximum interoperability for protocols that use JSON in their
   messages, no matter what JSON encoders/decoders are used in protocol
   implementations.  The encoding defined in this document therefore
   observes the I-JSON requirements and recommendations as closely as
   possible.

   In particular, the following properties are guaranteed:

   o  Character encoding is UTF-8.

   o  Member names within the same JSON object are always unique.

   o  The order of JSON object members is never relied upon.

   o  Numbers of any type supported by YANG can be exchanged reliably.
      See <a href="#section-6.1">Section 6.1</a> for details.

   The JSON encoding defined in this document deviates from I-JSON only
   in the representation of the "binary" type.  In order to remain
   compatible with XML encoding, the base64 encoding scheme is used
   (<a href="#section-6.6">Section 6.6</a>), whilst I-JSON recommends base64url instead.



<span class="grey">Lhotka                       Standards Track                   [Page 15]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-16"></span>
<span class="grey"><a href="./rfc7951">RFC 7951</a>               JSON Encoding of YANG Data            August 2016</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/8.%20%20Security%20Considerations"></a><a class="selflink" href="#section-8" id="section-8">8</a>.  Security Considerations</span>

   This document defines an alternative encoding for data modeled in the
   YANG data modeling language.  As such, it doesn't contribute any new
   security issues beyond those discussed in <a href="./rfc7950#section-17">SectionÂ 17 of [RFC7950]</a>.

   This document defines no mechanisms for signing and encrypting data
   modeled with YANG.  Under normal circumstances, data security and
   integrity are guaranteed by the management protocol in use, such as
   NETCONF [<a href="./rfc6241" title='"Network Configuration Protocol (NETCONF)"'>RFC6241</a>] or RESTCONF [<a href="#ref-RESTCONF" title='"RESTCONF Protocol"'>RESTCONF</a>].  If this is not the case,
   external mechanisms, such as Public-Key Cryptography Standards (PKCS)
   #7 [<a href="./rfc2315" title='"PKCS #7: Cryptographic Message Syntax Version 1.5"'>RFC2315</a>] or JSON Object Signing and Encryption (JOSE) [<a href="./rfc7515" title='"JSON Web Signature (JWS)"'>RFC7515</a>]
   [<a href="./rfc7516" title='"JSON Web Encryption (JWE)"'>RFC7516</a>], need to be considered.

   JSON processing is rather different from XML, and JSON parsers may
   thus suffer from different types of vulnerabilities than their XML
   counterparts.  To minimize these new security risks, software on the
   receiving side SHOULD reject all messages that do not comply with the
   rules of this document and reply with an appropriate error message to
   the sender.

<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/9.%20%20References"></a><a class="selflink" href="#section-9" id="section-9">9</a>.  References</span>

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/9.1.%20%20Normative%20References"></a><a class="selflink" href="#section-9.1" id="section-9.1">9.1</a>.  Normative References</span>

   [<a id="ref-RFC2119">RFC2119</a>]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", <a href="https://www.rfc-editor.org/bcp/bcp14">BCP 14</a>, <a href="./rfc2119">RFC 2119</a>,
              DOI 10.17487/RFC2119, March 1997,
              &lt;<a href="http://www.rfc-editor.org/info/rfc2119">http://www.rfc-editor.org/info/rfc2119</a>&gt;.

   [<a id="ref-RFC5234">RFC5234</a>]  Crocker, D., Ed. and P. Overell, "Augmented BNF for Syntax
              Specifications: ABNF", STD 68, <a href="./rfc5234">RFC 5234</a>,
              DOI 10.17487/RFC5234, January 2008,
              &lt;<a href="http://www.rfc-editor.org/info/rfc5234">http://www.rfc-editor.org/info/rfc5234</a>&gt;.

   [<a id="ref-RFC6241">RFC6241</a>]  Enns, R., Ed., Bjorklund, M., Ed., Schoenwaelder, J., Ed.,
              and A. Bierman, Ed., "Network Configuration Protocol
              (NETCONF)", <a href="./rfc6241">RFC 6241</a>, DOI 10.17487/RFC6241, June 2011,
              &lt;<a href="http://www.rfc-editor.org/info/rfc6241">http://www.rfc-editor.org/info/rfc6241</a>&gt;.

   [<a id="ref-RFC7159">RFC7159</a>]  Bray, T., Ed., "The JavaScript Object Notation (JSON) Data
              Interchange Format", <a href="./rfc7159">RFC 7159</a>, DOI 10.17487/RFC7159, March
              2014, &lt;<a href="http://www.rfc-editor.org/info/rfc7159">http://www.rfc-editor.org/info/rfc7159</a>&gt;.

   [<a id="ref-RFC7493">RFC7493</a>]  Bray, T., Ed., "The I-JSON Message Format", <a href="./rfc7493">RFC 7493</a>,
              DOI 10.17487/RFC7493, March 2015,
              &lt;<a href="http://www.rfc-editor.org/info/rfc7493">http://www.rfc-editor.org/info/rfc7493</a>&gt;.




<span class="grey">Lhotka                       Standards Track                   [Page 16]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-17"></span>
<span class="grey"><a href="./rfc7951">RFC 7951</a>               JSON Encoding of YANG Data            August 2016</span>


   [<a id="ref-RFC7950">RFC7950</a>]  Bjorklund, M., Ed., "The YANG 1.1 Data Modeling Language",
              <a href="./rfc7950">RFC 7950</a>, DOI 10.17487/RFC7950, August 2016,
              &lt;<a href="http://www.rfc-editor.org/info/rfc7950">http://www.rfc-editor.org/info/rfc7950</a>&gt;.

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/9.2.%20%20Informative%20References"></a><a class="selflink" href="#section-9.2" id="section-9.2">9.2</a>.  Informative References</span>

   [<a id="ref-IEEE754-2008">IEEE754-2008</a>]
              IEEE, "IEEE Standard for Floating-Point Arithmetic",
              IEEE 754-2008, DOI 10.1109/IEEESTD.2008.4610935, 2008,
              &lt;<a href="http://standards.ieee.org/findstds/standard/754-2008.html">http://standards.ieee.org/findstds/</a>
              <a href="http://standards.ieee.org/findstds/standard/754-2008.html">standard/754-2008.html</a>&gt;.

   [<a id="ref-RESTCONF">RESTCONF</a>] Bierman, A., Bjorklund, M., and K. Watsen, "RESTCONF
              Protocol", Work in Progress,
              <a href="./draft-ietf-netconf-restconf-16">draft-ietf-netconf-restconf-16</a>, August 2016.

   [<a id="ref-RFC2315">RFC2315</a>]  Kaliski, B., "PKCS #7: Cryptographic Message Syntax
              Version 1.5", <a href="./rfc2315">RFC 2315</a>, DOI 10.17487/RFC2315, March 1998,
              &lt;<a href="http://www.rfc-editor.org/info/rfc2315">http://www.rfc-editor.org/info/rfc2315</a>&gt;.

   [<a id="ref-RFC6020">RFC6020</a>]  Bjorklund, M., Ed., "YANG - A Data Modeling Language for
              the Network Configuration Protocol (NETCONF)", <a href="./rfc6020">RFC 6020</a>,
              DOI 10.17487/RFC6020, October 2010,
              &lt;<a href="http://www.rfc-editor.org/info/rfc6020">http://www.rfc-editor.org/info/rfc6020</a>&gt;.

   [<a id="ref-RFC7223">RFC7223</a>]  Bjorklund, M., "A YANG Data Model for Interface
              Management", <a href="./rfc7223">RFC 7223</a>, DOI 10.17487/RFC7223, May 2014,
              &lt;<a href="http://www.rfc-editor.org/info/rfc7223">http://www.rfc-editor.org/info/rfc7223</a>&gt;.

   [<a id="ref-RFC7515">RFC7515</a>]  Jones, M., Bradley, J., and N. Sakimura, "JSON Web
              Signature (JWS)", <a href="./rfc7515">RFC 7515</a>, DOI 10.17487/RFC7515, May
              2015, &lt;<a href="http://www.rfc-editor.org/info/rfc7515">http://www.rfc-editor.org/info/rfc7515</a>&gt;.

   [<a id="ref-RFC7516">RFC7516</a>]  Jones, M. and J. Hildebrand, "JSON Web Encryption (JWE)",
              <a href="./rfc7516">RFC 7516</a>, DOI 10.17487/RFC7516, May 2015,
              &lt;<a href="http://www.rfc-editor.org/info/rfc7516">http://www.rfc-editor.org/info/rfc7516</a>&gt;.

   [<a id="ref-RFC7952">RFC7952</a>]  Lhotka, L., "Defining and Using Metadata with YANG",
              <a href="./rfc7952">RFC 7952</a>, DOI 10.17487/RFC7952, August 2016,
              &lt;<a href="http://www.rfc-editor.org/info/rfc7952">http://www.rfc-editor.org/info/rfc7952</a>&gt;.

   [<a id="ref-XML">XML</a>]      Bray, T., Paoli, J., Sperberg-McQueen, M., Maler, E., and
              F. Yergeau, "Extensible Markup Language (XML) 1.0 (Fifth
              Edition)", World Wide Web Consortium Recommendation
              REC-xml-20081126, November 2008,
              &lt;<a href="http://www.w3.org/TR/2008/REC-xml-20081126">http://www.w3.org/TR/2008/REC-xml-20081126</a>&gt;.





<span class="grey">Lhotka                       Standards Track                   [Page 17]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-18"></span>
<span class="grey"><a href="./rfc7951">RFC 7951</a>               JSON Encoding of YANG Data            August 2016</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/Appendix%20A.%20%20A%20Complete%20Example"></a><a class="selflink" href="#appendix-A" id="appendix-A">Appendix A</a>.  A Complete Example</span>

   The JSON document shown below represents the same data as the reply
   to the NETCONF &lt;get&gt; request appearing in <a href="./rfc7223#appendix-D">AppendixÂ D of [RFC7223]</a>.
   The data model is a combination of two YANG modules:
   "ietf-interfaces" and "ex-vlan" (the latter is an example module from
   <a href="./rfc7223#appendix-C">AppendixÂ C of [RFC7223]</a>).  The "if-mib" feature defined in the
   "ietf-interfaces" module is supported.

   {
     "ietf-interfaces:interfaces": {
       "interface": [
         {
           "name": "eth0",
           "type": "iana-if-type:ethernetCsmacd",
           "enabled": false
         },
         {
           "name": "eth1",
           "type": "iana-if-type:ethernetCsmacd",
           "enabled": true,
           "ex-vlan:vlan-tagging": true
         },
         {
           "name": "eth1.10",
           "type": "iana-if-type:l2vlan",
           "enabled": true,
           "ex-vlan:base-interface": "eth1",
           "ex-vlan:vlan-id": 10
         },
         {
           "name": "lo1",
           "type": "iana-if-type:softwareLoopback",
           "enabled": true
         }
       ]
     },
     "ietf-interfaces:interfaces-state": {
       "interface": [
         {
           "name": "eth0",
           "type": "iana-if-type:ethernetCsmacd",
           "admin-status": "down",
           "oper-status": "down",
           "if-index": 2,
           "phys-address": "00:01:02:03:04:05",
           "statistics": {
             "discontinuity-time": "2013-04-01T03:00:00+00:00"



<span class="grey">Lhotka                       Standards Track                   [Page 18]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-19"></span>
<span class="grey"><a href="./rfc7951">RFC 7951</a>               JSON Encoding of YANG Data            August 2016</span>


           }
         },
         {
           "name": "eth1",
           "type": "iana-if-type:ethernetCsmacd",
           "admin-status": "up",
           "oper-status": "up",
           "if-index": 7,
           "phys-address": "00:01:02:03:04:06",
           "higher-layer-if": [
             "eth1.10"
           ],
           "statistics": {
             "discontinuity-time": "2013-04-01T03:00:00+00:00"
           }
         },
         {
           "name": "eth1.10",
           "type": "iana-if-type:l2vlan",
           "admin-status": "up",
           "oper-status": "up",
           "if-index": 9,
           "lower-layer-if": [
             "eth1"
           ],
           "statistics": {
             "discontinuity-time": "2013-04-01T03:00:00+00:00"
           }
         },
         {
           "name": "eth2",
           "type": "iana-if-type:ethernetCsmacd",
           "admin-status": "down",
           "oper-status": "down",
           "if-index": 8,
           "phys-address": "00:01:02:03:04:07",
           "statistics": {
             "discontinuity-time": "2013-04-01T03:00:00+00:00"
           }
         },
         {
           "name": "lo1",
           "type": "iana-if-type:softwareLoopback",
           "admin-status": "up",
           "oper-status": "up",
           "if-index": 1,
           "statistics": {
             "discontinuity-time": "2013-04-01T03:00:00+00:00"



<span class="grey">Lhotka                       Standards Track                   [Page 19]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-20"></span>
<span class="grey"><a href="./rfc7951">RFC 7951</a>               JSON Encoding of YANG Data            August 2016</span>


           }
         }
       ]
     }
   }

Acknowledgements

   The author wishes to thank Andy Bierman, Martin Bjorklund, Dean
   Bogdanovic, Balazs Lengyel, Juergen Schoenwaelder, and Phil Shafer
   for their helpful comments and suggestions.

Author's Address

   Ladislav Lhotka
   CZ.NIC

   Email: lhotka@nic.cz

































Lhotka                       Standards Track                   [Page 20]
</pre>
</body></html>