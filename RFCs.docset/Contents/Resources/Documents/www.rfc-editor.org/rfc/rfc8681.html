<!DOCTYPE html>
<html class="RFC" lang="en"><head>
<meta charset="utf-8"/>
<meta content="Common,Latin" name="scripts"/>
<meta content="initial-scale=1.0" name="viewport"/>
<title>RFC 8681: Sliding Window Random Linear Code (RLC) Forward Erasure Correction (FEC) Schemes for FECFRAME</title>
<meta content="Vincent Roca" name="author"/>
<meta content="Belkacem Teibi" name="author"/>
<meta content="
       
This document describes two fully specified Forward Erasure Correction (FEC) Schemes for Sliding Window Random Linear Codes (RLC), one for RLC over the Galois Field (a.k.a., Finite Field) GF(2), a second one for RLC over the Galois Field GF(2 8 ), each time with the possibility of controlling the code density.
They can protect arbitrary media streams along the lines defined by FECFRAME extended to Sliding Window FEC Codes.
These Sliding Window FEC Codes rely on an encoding window that slides over the source symbols, generating new repair symbols whenever needed.
Compared to block FEC codes, these Sliding Window FEC Codes offer key advantages with real-time flows in terms of reduced FEC-related latency while often providing improved packet erasure recovery capabilities.
 
    " name="description"/>
<meta content="xml2rfc 2.38.0" name="generator"/>
<meta content="RLC" name="keyword"/>
<meta content="FEC" name="keyword"/>
<meta content="FECFRAME" name="keyword"/>
<meta content="packet loss recovery" name="keyword"/>
<meta content="reliability" name="keyword"/>
<meta content="8681" name="rfc.number"/>
<link href="rfc8681.xml" rel="alternate" type="application/rfc+xml"/>
<link href="#copyright" rel="license"/>
<style type="text/css">/*

  NOTE: Changes at the bottom of this file overrides some earlier settings.

  Once the style has stabilized and has been adopted as an official RFC style,
  this can be consolidated so that style settings occur only in one place, but
  for now the contents of this file consists first of the initial CSS work as
  provided to the RFC Formatter (xml2rfc) work, followed by itemized and
  commented changes found necssary during the development of the v3
  formatters.

*/

/* fonts */
@import url('https://fonts.googleapis.com/css?family=Noto+Sans'); /* Sans-serif */
@import url('https://fonts.googleapis.com/css?family=Noto+Serif'); /* Serif (print) */
@import url('https://fonts.googleapis.com/css?family=Roboto+Mono'); /* Monospace */

@viewport {
  zoom: 1.0;
  width: extend-to-zoom;
}
@-ms-viewport {
  width: extend-to-zoom;
  zoom: 1.0;
}
/* general and mobile first */
html {
}
body {
  max-width: 90%;
  margin: 1.5em auto;
  color: #222;
  background-color: #fff;
  font-size: 14px;
  font-family: 'Noto Sans', Arial, Helvetica, sans-serif;
  line-height: 1.6;
  scroll-behavior: smooth;
}
.ears {
  display: none;
}

/* headings */
#title, h1, h2, h3, h4, h5, h6 {
  margin: 1em 0 0.5em;
  font-weight: bold;
  line-height: 1.3;
}
#title {
  clear: both;
  border-bottom: 1px solid #ddd;
  margin: 0 0 0.5em 0;
  padding: 1em 0 0.5em;
}
.author {
  padding-bottom: 4px;
}
h1 {
  font-size: 26px;
  margin: 1em 0;
}
h2 {
  font-size: 22px;
  margin-top: -20px;  /* provide offset for in-page anchors */
  padding-top: 33px;
}
h3 {
  font-size: 18px;
  margin-top: -36px;  /* provide offset for in-page anchors */
  padding-top: 42px;
}
h4 {
  font-size: 16px;
  margin-top: -36px;  /* provide offset for in-page anchors */
  padding-top: 42px;
}
h5, h6 {
  font-size: 14px;
}
#n-copyright-notice {
  border-bottom: 1px solid #ddd;
  padding-bottom: 1em;
  margin-bottom: 1em;
}
/* general structure */
p {
  padding: 0;
  margin: 0 0 1em 0;
  text-align: left;
}
div, span {
  position: relative;
}
div {
  margin: 0;
}
.alignRight.art-text {
  background-color: #f9f9f9;
  border: 1px solid #eee;
  border-radius: 3px;
  padding: 1em 1em 0;
  margin-bottom: 1.5em;
}
.alignRight.art-text pre {
  padding: 0;
}
.alignRight {
  margin: 1em 0;
}
.alignRight > *:first-child {
  border: none;
  margin: 0;
  float: right;
  clear: both;
}
.alignRight > *:nth-child(2) {
  clear: both;
  display: block;
  border: none;
}
svg {
  display: block;
}
.alignCenter.art-text {
  background-color: #f9f9f9;
  border: 1px solid #eee;
  border-radius: 3px;
  padding: 1em 1em 0;
  margin-bottom: 1.5em;
}
.alignCenter.art-text pre {
  padding: 0;
}
.alignCenter {
  margin: 1em 0;
}
.alignCenter > *:first-child {
  border: none;
  /* this isn't optimal, but it's an existence proof.  PrinceXML doesn't
     support flexbox yet.
  */
  display: table;
  margin: 0 auto;
}

/* lists */
ol, ul {
  padding: 0;
  margin: 0 0 1em 2em;
}
ol ol, ul ul, ol ul, ul ol {
  margin-left: 1em;
}
li {
  margin: 0 0 0.25em 0;
}
.ulCompact li {
  margin: 0;
}
ul.empty, .ulEmpty {
  list-style-type: none;
}
ul.empty li, .ulEmpty li {
  margin-top: 0.5em;
}
ul.compact, .ulCompact,
ol.compact, .olCompact {
  line-height: 100%;
  margin: 0 0 0 2em;
}

/* definition lists */
dl {
}
dl > dt {
  float: left;
  margin-right: 1em;
}
/* 
dl.nohang > dt {
  float: none;
}
*/
dl > dd {
  margin-bottom: .8em;
  min-height: 1.3em;
}
dl.compact > dd, .dlCompact > dd {
  margin-bottom: 0em;
}
dl > dd > dl {
  margin-top: 0.5em;
  margin-bottom: 0em;
}

/* links */
a {
  text-decoration: none;
}
a[href] {
  color: #22e; /* Arlen: WCAG 2019 */
}
a[href]:hover {
  background-color: #f2f2f2;
}
figcaption a[href],
a[href].selfRef {
  color: #222;
}
/* XXX probably not this:
a.selfRef:hover {
  background-color: transparent;
  cursor: default;
} */

/* Figures */
tt, code, pre, code {
  background-color: #f9f9f9;
  font-family: 'Roboto Mono', monospace;
}
pre {
  border: 1px solid #eee;
  margin: 0;
  padding: 1em;
}
img {
  max-width: 100%;
}
figure {
  margin: 0;
}
figure blockquote {
  margin: 0.8em 0.4em 0.4em;
}
figcaption {
  font-style: italic;
  margin: 0 0 1em 0;
}
@media screen {
  pre {
    overflow-x: auto;
    max-width: 100%;
    max-width: calc(100% - 22px);
  }
}

/* aside, blockquote */
aside, blockquote {
  margin-left: 0;
  padding: 1.2em 2em;
}
blockquote {
  background-color: #f9f9f9;
  color: #111; /* Arlen: WCAG 2019 */
  border: 1px solid #ddd;
  border-radius: 3px;
  margin: 1em 0;
}
cite {
  display: block;
  text-align: right;
  font-style: italic;
}

/* tables */
table {
  width: 100%;
  margin: 0 0 1em;
  border-collapse: collapse;
  border: 1px solid #eee;
}
th, td {
  text-align: left;
  vertical-align: top;
  padding: 0.5em 0.75em;
}
th {
  text-align: left;
  background-color: #e9e9e9;
}
tr:nth-child(2n+1) > td {
  background-color: #f5f5f5;
}
table caption {
  font-style: italic;
  margin: 0;
  padding: 0;
  text-align: left;
}
table p {
  /* XXX to avoid bottom margin on table row signifiers. If paragraphs should
     be allowed within tables more generally, it would be far better to select on a class. */
  margin: 0;
}

/* pilcrow */
a.pilcrow {
  color: #666; /* Arlen: AHDJ 2019 */
  text-decoration: none;
  visibility: hidden;
  user-select: none;
  -ms-user-select: none;
  -o-user-select:none;
  -moz-user-select: none;
  -khtml-user-select: none;
  -webkit-user-select: none;
  -webkit-touch-callout: none;
}
@media screen {
  aside:hover > a.pilcrow,
  p:hover > a.pilcrow,
  blockquote:hover > a.pilcrow,
  div:hover > a.pilcrow,
  li:hover > a.pilcrow,
  pre:hover > a.pilcrow {
    visibility: visible;
  }
  a.pilcrow:hover {
    background-color: transparent;
  }
}

/* misc */
hr {
  border: 0;
  border-top: 1px solid #eee;
}
.bcp14 {
  font-variant: small-caps;
}

.role {
  font-variant: all-small-caps;
}

/* info block */
#identifiers {
  margin: 0;
  font-size: 0.9em;
}
#identifiers dt {
  width: 3em;
  clear: left;
}
#identifiers dd {
  float: left;
  margin-bottom: 0;
}
#identifiers .authors .author {
  display: inline-block;
  margin-right: 1.5em;
}
#identifiers .authors .org {
  font-style: italic;
}

/* The prepared/rendered info at the very bottom of the page */
.docInfo {
  color: #666; /* Arlen: WCAG 2019 */
  font-size: 0.9em;
  font-style: italic;
  margin-top: 2em;
}
.docInfo .prepared {
  float: left;
}
.docInfo .prepared {
  float: right;
}

/* table of contents */
#toc  {
  padding: 0.75em 0 2em 0;
  margin-bottom: 1em;
}
nav.toc ul {
  margin: 0 0.5em 0 0;
  padding: 0;
  list-style: none;
}
nav.toc li {
  line-height: 1.3em;
  margin: 0.75em 0;
  padding-left: 1.2em;
  text-indent: -1.2em;
}
/* references */
.references dt {
  text-align: right;
  font-weight: bold;
  min-width: 7em;
}
.references dd {
  margin-left: 8em;
  overflow: auto;
}

.refInstance {
  margin-bottom: 1.25em;
}

.references .ascii {
  margin-bottom: 0.25em;
}

/* index */
.index ul {
  margin: 0 0 0 1em;
  padding: 0;
  list-style: none;
}
.index ul ul {
  margin: 0;
}
.index li {
  margin: 0;
  text-indent: -2em;
  padding-left: 2em;
  padding-bottom: 5px;
}
.indexIndex {
  margin: 0.5em 0 1em;
}
.index a {
  font-weight: 700;
}
/* make the index two-column on all but the smallest screens */
@media (min-width: 600px) {
  .index ul {
    -moz-column-count: 2;
    -moz-column-gap: 20px;
  }
  .index ul ul {
    -moz-column-count: 1;
    -moz-column-gap: 0;
  }
}

/* authors */
address.vcard {
  font-style: normal;
  margin: 1em 0;
}

address.vcard .nameRole {
  font-weight: 700;
  margin-left: 0;
}
address.vcard .label {
  font-family: "Noto Sans",Arial,Helvetica,sans-serif;
  margin: 0.5em 0;
}
address.vcard .type {
  display: none;
}
.alternative-contact {
  margin: 1.5em 0 1em;
}
hr.addr {
  border-top: 1px dashed;
  margin: 0;
  color: #ddd;
  max-width: calc(100% - 16px);
}

/* temporary notes */
.rfcEditorRemove::before {
  position: absolute;
  top: 0.2em;
  right: 0.2em;
  padding: 0.2em;
  content: "The RFC Editor will remove this note";
  color: #9e2a00; /* Arlen: WCAG 2019 */
  background-color: #ffd; /* Arlen: WCAG 2019 */
}
.rfcEditorRemove {
  position: relative;
  padding-top: 1.8em;
  background-color: #ffd; /* Arlen: WCAG 2019 */
  border-radius: 3px;
}
.cref {
  background-color: #ffd; /* Arlen: WCAG 2019 */
  padding: 2px 4px;
}
.crefSource {
  font-style: italic;
}
/* alternative layout for smaller screens */
@media screen and (max-width: 1023px) {
  body {
    padding-top: 2em;
  }
  #title {
    padding: 1em 0;
  }
  h1 {
    font-size: 24px;
  }
  h2 {
    font-size: 20px;
    margin-top: -18px;  /* provide offset for in-page anchors */
    padding-top: 38px;
  }
  #identifiers dd {
    max-width: 60%;
  }
  #toc {
    position: fixed;
    z-index: 2;
    top: 0;
    right: 0;
    padding: 0;
    margin: 0;
    background-color: inherit;
    border-bottom: 1px solid #ccc;
  }
  #toc h2 {
    margin: -1px 0 0 0;
    padding: 4px 0 4px 6px;
    padding-right: 1em;
    min-width: 190px;
    font-size: 1.1em;
    text-align: right;
    background-color: #444;
    color: white;
    cursor: pointer;
  }
  #toc h2::before { /* css hamburger */
    float: right;
    position: relative;
    width: 1em;
    height: 1px;
    left: -164px;
    margin: 6px 0 0 0;
    background: white none repeat scroll 0 0;
    box-shadow: 0 4px 0 0 white, 0 8px 0 0 white;
    content: "";
  }
  #toc nav {
    display: none;
    padding: 0.5em 1em 1em;
    overflow: auto;
    height: calc(100vh - 48px);
    border-left: 1px solid #ddd;
  }
}

/* alternative layout for wide screens */
@media screen and (min-width: 1024px) {
  body {
    max-width: 724px;
    margin: 42px auto;
    padding-left: 1.5em;
    padding-right: 29em;
  }
  #toc {
    position: fixed;
    top: 42px;
    right: 42px;
    width: 25%;
    margin: 0;
    padding: 0 1em;
    z-index: 1;
  }
  #toc h2 {
    border-top: none;
    border-bottom: 1px solid #ddd;
    font-size: 1em;
    font-weight: normal;
    margin: 0;
    padding: 0.25em 1em 1em 0;
  }
  #toc nav {
    display: block;
    height: calc(90vh - 84px);
    bottom: 0;
    padding: 0.5em 0 0;
    overflow: auto;
  }
  img { /* future proofing */
    max-width: 100%;
    height: auto;
  }
}

/* pagination */
@media print {
  body {

    width: 100%;
  }
  p {
    orphans: 3;
    widows: 3;
  }
  #n-copyright-notice {
    border-bottom: none;
  }
  #toc, #n-introduction {
    page-break-before: always;
  }
  #toc {
    border-top: none;
    padding-top: 0;
  }
  figure, pre {
    page-break-inside: avoid;
  }
  figure {
    overflow: scroll;
  }
  h1, h2, h3, h4, h5, h6 {
    page-break-after: avoid;
  }
  h2+*, h3+*, h4+*, h5+*, h6+* {
    page-break-before: avoid;
  }
  pre {
    white-space: pre-wrap;
    word-wrap: break-word;
    font-size: 10pt;
  }
  table {
    border: 1px solid #ddd;
  }
  td {
    border-top: 1px solid #ddd;
  }
}

/* This is commented out here, as the string-set: doesn't
   pass W3C validation currently */
/*
.ears thead .left {
  string-set: ears-top-left content();
}

.ears thead .center {
  string-set: ears-top-center content();
}

.ears thead .right {
  string-set: ears-top-right content();
}

.ears tfoot .left {
  string-set: ears-bottom-left content();
}

.ears tfoot .center {
  string-set: ears-bottom-center content();
}

.ears tfoot .right {
  string-set: ears-bottom-right content();
}
*/

@page :first {
  padding-top: 0;
  @top-left {
    content: normal;
    border: none;
  }
  @top-center {
    content: normal;
    border: none;
  }
  @top-right {
    content: normal;
    border: none;
  }
}

@page {
  size: A4;
  margin-bottom: 45mm;
  padding-top: 20px;
  /* The follwing is commented out here, but set appropriately by in code, as
     the content depends on the document */
  /*
  @top-left {
    content: 'Internet-Draft';
    vertical-align: bottom;
    border-bottom: solid 1px #ccc;
  }
  @top-left {
    content: string(ears-top-left);
    vertical-align: bottom;
    border-bottom: solid 1px #ccc;
  }
  @top-center {
    content: string(ears-top-center);
    vertical-align: bottom;
    border-bottom: solid 1px #ccc;
  }
  @top-right {
    content: string(ears-top-right);
    vertical-align: bottom;
    border-bottom: solid 1px #ccc;
  }
  @bottom-left {
    content: string(ears-bottom-left);
    vertical-align: top;
    border-top: solid 1px #ccc;
  }
  @bottom-center {
    content: string(ears-bottom-center);
    vertical-align: top;
    border-top: solid 1px #ccc;
  }
  @bottom-right {
      content: '[Page ' counter(page) ']';
      vertical-align: top;
      border-top: solid 1px #ccc;
  }
  */

}

/* Changes introduced to fix issues found during implementation */
/* Make sure links are clickable even if overlapped by following H* */
a {
  z-index: 2;
}
/* Separate body from document info even without intervening H1 */
section {
  clear: both;
}


/* Top align author divs, to avoid names without organization dropping level with org names */
.author {
  vertical-align: top;
}

/* Leave room in document info to show Internet-Draft on one line */
#identifiers dt {
  width: 8em;
}

/* Don't waste quite as much whitespace between label and value in doc info */
#identifiers dd {
  margin-left: 1em;
}

/* Give floating toc a background color (needed when it's a div inside section */
#toc {
  background-color: white;
}

/* Make the collapsed ToC header render white on gray also when it's a link */
@media screen and (max-width: 1023px) {
  #toc h2 a,
  #toc h2 a:link,
  #toc h2 a:focus,
  #toc h2 a:hover,
  #toc a.toplink,
  #toc a.toplink:hover {
    color: white;
    background-color: #444;
    text-decoration: none;
  }
}

/* Give the bottom of the ToC some whitespace */
@media screen and (min-width: 1024px) {
  #toc {
    padding: 0 0 1em 1em;
  }
}

/* Style section numbers with more space between number and title */
.section-number {
  padding-right: 0.5em;
}

/* prevent monospace from becoming overly large */
tt, code, pre, code {
  font-size: 95%;
}

/* Fix the height/width aspect for ascii art*/
pre.sourcecode,
.art-text pre {
  line-height: 1.12;
}


/* Add styling for a link in the ToC that points to the top of the document */
a.toplink {
  float: right;
  margin-right: 0.5em;
}

/* Fix the dl styling to match the RFC 7992 attributes */
dl > dt,
dl.dlParallel > dt {
  float: left;
  margin-right: 1em;
}
dl.dlNewline > dt {
  float: none;
}

/* Provide styling for table cell text alignment */
table td.text-left,
table th.text-left {
  text-align: left;
}
table td.text-center,
table th.text-center {
  text-align: center;
}
table td.text-right,
table th.text-right {
  text-align: right;
}

/* Make the alternative author contact informatio look less like just another
   author, and group it closer with the primary author contact information */
.alternative-contact {
  margin: 0.5em 0 0.25em 0;
}
address .non-ascii {
  margin: 0 0 0 2em;
}

/* With it being possible to set tables with alignment
  left, center, and right, { width: 100%; } does not make sense */
table {
  width: auto;
}

/* Avoid reference text that sits in a block with very wide left margin,
   because of a long floating dt label.*/
.references dd {
  overflow: visible;
}

/* Control caption placement */
caption {
  caption-side: bottom;
}

/* Limit the width of the author address vcard, so names in right-to-left
   script don't end up on the other side of the page. */

address.vcard {
  max-width: 30em;
  margin-right: auto;
}

/* For address alignment dependent on LTR or RTL scripts */
address div.left {
  text-align: left;
}
address div.right {
  text-align: right;
}

/* Provide table alignment support.  We can't use the alignX classes above
   since they do unwanted things with caption and other styling. */
table.right {
 margin-left: auto;
 margin-right: 0;
}
table.center {
 margin-left: auto;
 margin-right: auto;
}
table.left {
 margin-left: 0;
 margin-right: auto;
}

/* Give the table caption label the same styling as the figcaption */
caption a[href] {
  color: #222;
}

@media print {
  .toplink {
    display: none;
  }

  /* avoid overwriting the top border line with the ToC header */
  #toc {
    padding-top: 1px;
  }

  /* Avoid page breaks inside dl and author address entries */
  .vcard {
    page-break-inside: avoid;
  }

}
/* Avoid wrapping of URLs in references */
@media screen {
  .references a {
    white-space: nowrap;
  }
}
/* Tweak the bcp14 keyword presentation */
.bcp14 {
  font-variant: small-caps;
  font-weight: bold;
  font-size: 0.9em;
}
/* Tweak the invisible space above H* in order not to overlay links in text above */
 h2 {
  margin-top: -18px;  /* provide offset for in-page anchors */
  padding-top: 31px;
 }
 h3 {
  margin-top: -18px;  /* provide offset for in-page anchors */
  padding-top: 24px;
 }
 h4 {
  margin-top: -18px;  /* provide offset for in-page anchors */
  padding-top: 24px;
 }
/* Float artwork pilcrow to the right */
@media screen {
  .artwork a.pilcrow {
    display: block;
    line-height: 0.7;
    margin-top: 0.15em;
  }
}
/* Make pilcrows on dd visible */
@media screen {
  dd:hover > a.pilcrow {
    visibility: visible;
  }
}
/* Make the placement of figcaption match that of a table's caption
   by removing the figure's added bottom margin */
.alignLeft.art-text,
.alignCenter.art-text,
.alignRight.art-text {
   margin-bottom: 0;
}
.alignLeft,
.alignCenter,
.alignRight {
  margin: 1em 0 0 0;
}
/* In print, the pilcrow won't show on hover, so prevent it from taking up space,
   possibly even requiring a new line */
@media print {
  a.pilcrow {
    display: none;
  }
}
/* Styling for the external metadata */
div#external-metadata {
  background-color: #eee;
  padding: 0.5em;
  margin-bottom: 0.5em;
  display: none;
}
div#internal-metadata {
  padding: 0.5em;                       /* to match the external-metadata padding */
}
/* Styling for title RFC Number */
h1#rfcnum {
  clear: both;
  margin: 0 0 -1em;
  padding: 1em 0 0 0;
}
/* Make .olPercent look the same as <ol><li> */
dl.olPercent > dd {
  margin: 0 0 0.25em 0;
  min-height: initial;
}
/* Give aside some styling to set it apart */
aside {
  border-left: 1px solid #ddd;
  margin: 1em 0 1em 2em;
  padding: 0.2em 2em;
}
aside > dl,
aside > ol,
aside > ul,
aside > table,
aside > p {
  margin-bottom: 0.5em;
}
/* Additional page break settings */
@media print {
  figcaption, table caption {
    page-break-before: avoid;
  }
}
/* Font size adjustments for print */
@media print {
  body  { font-size: 10pt;      line-height: normal; max-width: 96%; }
  h1    { font-size: 1.72em;    padding-top: 1.5em; } /* 1*1.2*1.2*1.2 */
  h2    { font-size: 1.44em;    padding-top: 1.5em; } /* 1*1.2*1.2 */
  h3    { font-size: 1.2em;     padding-top: 1.5em; } /* 1*1.2 */
  h4    { font-size: 1em;       padding-top: 1.5em; }
  h5, h6 { font-size: 1em;      margin: initial; padding: 0.5em 0 0.3em; }
}
/* Sourcecode margin in print, when there's no pilcrow */
@media print {
  .artwork,
  .sourcecode {
    margin-bottom: 1em;
  }
}
/*
  The margin-left: 0 on <dd> removes all distinction
  between levels from nested <dl>s.  Undo that.
*/
dl.olPercent > dd,
dd {
  margin-left: revert;
}
/* Avoid narrow tables forcing too narrow table captions, which may render badly */
table {
  min-width: 20em;
}</style>
<link href="rfc-local.css" rel="stylesheet" type="text/css"/>
<link href="https://dx.doi.org/10.17487/rfc8681" rel="alternate"/>
  <link href="urn:issn:2070-1721" rel="alternate"/>
  <link href="https://datatracker.ietf.org/doc/draft-ietf-tsvwg-rlc-fec-scheme-16" rel="prev"/>
  </head>
<body>
<script src="https://www.rfc-editor.org/js/metadata.min.js"></script>
<table class="ears">
<thead><tr>
<td class="left">RFC 8681</td>
<td class="center">RLC FEC Scheme</td>
<td class="right">January 2020</td>
</tr></thead>
<tfoot><tr>
<td class="left">Roca &amp; Teibi</td>
<td class="center">Standards Track</td>
<td class="right">[Page]</td>
</tr></tfoot>
</table>
<div class="document-information" id="external-metadata"></div>
<div class="document-information" id="internal-metadata">
<dl id="identifiers">
<dt class="label-stream">Stream:</dt>
<dd class="stream">Internet Engineering Task Force (IETF)</dd>
<dt class="label-rfc">RFC:</dt>
<dd class="rfc"><a class="eref" href="https://www.rfc-editor.org/rfc/rfc8681">8681</a></dd>
<dt class="label-category">Category:</dt>
<dd class="category">Standards Track</dd>
<dt class="label-published">Published:</dt>
<dd class="published">
<time class="published" datetime="2020-01">January 2020</time>
    </dd>
<dt class="label-issn">ISSN:</dt>
<dd class="issn">2070-1721</dd>
<dt class="label-authors">Authors:</dt>
<dd class="authors">
<div class="author">
      <div class="author-name">V. Roca</div>
<div class="org">INRIA</div>
</div>
<div class="author">
      <div class="author-name">B. Teibi</div>
<div class="org">INRIA</div>
</div>
</dd>
</dl>
</div>
<h1 id="rfcnum">RFC 8681</h1>
<h1 id="title">Sliding Window Random Linear Code (RLC) Forward Erasure Correction (FEC) Schemes for FECFRAME</h1>
<section id="section-abstract">
      <h2 id="abstract"><a class="selfRef" href="#abstract">Abstract</a></h2>
<p id="section-abstract-1">
This document describes two fully specified Forward Erasure Correction (FEC) Schemes for Sliding Window Random Linear Codes (RLC), one for RLC over the Galois Field (a.k.a., Finite Field) GF(2), a second one for RLC over the Galois Field GF(2<sup>8</sup>), each time with the possibility of controlling the code density.
They can protect arbitrary media streams along the lines defined by FECFRAME extended to Sliding Window FEC Codes.
These Sliding Window FEC Codes rely on an encoding window that slides over the source symbols, generating new repair symbols whenever needed.
Compared to block FEC codes, these Sliding Window FEC Codes offer key advantages with real-time flows in terms of reduced FEC-related latency while often providing improved packet erasure recovery capabilities.<a class="pilcrow" href="#section-abstract-1">¶</a></p>
</section>
<div id="status-of-memo">
<section id="section-boilerplate.1">
        <h2 id="name-status-of-this-memo">
<a class="section-name selfRef" href="#name-status-of-this-memo">Status of This Memo</a>
        </h2>
<p id="section-boilerplate.1-1">
            This is an Internet Standards Track document.<a class="pilcrow" href="#section-boilerplate.1-1">¶</a></p>
<p id="section-boilerplate.1-2">
            This document is a product of the Internet Engineering Task Force
            (IETF).  It represents the consensus of the IETF community.  It has
            received public review and has been approved for publication by
            the Internet Engineering Steering Group (IESG).  Further
            information on Internet Standards is available in Section 2 of 
            RFC 7841.<a class="pilcrow" href="#section-boilerplate.1-2">¶</a></p>
<p id="section-boilerplate.1-3">
            Information about the current status of this document, any
            errata, and how to provide feedback on it may be obtained at
            <span><a href="https://www.rfc-editor.org/info/rfc8681">https://www.rfc-editor.org/info/rfc8681</a></span>.<a class="pilcrow" href="#section-boilerplate.1-3">¶</a></p>
</section>
</div>
<div id="copyright">
<section id="section-boilerplate.2">
        <h2 id="name-copyright-notice">
<a class="section-name selfRef" href="#name-copyright-notice">Copyright Notice</a>
        </h2>
<p id="section-boilerplate.2-1">
            Copyright (c) 2020 IETF Trust and the persons identified as the
            document authors. All rights reserved.<a class="pilcrow" href="#section-boilerplate.2-1">¶</a></p>
<p id="section-boilerplate.2-2">
            This document is subject to BCP 78 and the IETF Trust's Legal
            Provisions Relating to IETF Documents
            (<span><a href="https://trustee.ietf.org/license-info">https://trustee.ietf.org/license-info</a></span>) in effect on the date of
            publication of this document. Please review these documents
            carefully, as they describe your rights and restrictions with
            respect to this document. Code Components extracted from this
            document must include Simplified BSD License text as described in
            Section 4.e of the Trust Legal Provisions and are provided without
            warranty as described in the Simplified BSD License.<a class="pilcrow" href="#section-boilerplate.2-2">¶</a></p>
</section>
</div>
<div id="toc">
<section id="section-toc.1">
        <a class="toplink" href="#" onclick="scroll(0,0)">▲</a><h2 id="name-table-of-contents">
<a class="section-name selfRef" href="#name-table-of-contents">Table of Contents</a>
        </h2>
<nav class="toc"><ul class="toc ulEmpty">
<li class="toc ulEmpty" id="section-toc.1-1.1">
            <p id="section-toc.1-1.1.1"><a class="xref" href="#section-1">1</a>.  <a class="xref" href="#name-introduction">Introduction</a><a class="pilcrow" href="#section-toc.1-1.1.1">¶</a></p>
<ul class="toc ulEmpty">
<li class="toc ulEmpty" id="section-toc.1-1.1.2.1">
                <p id="section-toc.1-1.1.2.1.1"><a class="xref" href="#section-1.1">1.1</a>.  <a class="xref" href="#name-limits-of-block-codes-with-">Limits of Block Codes with Real-Time Flows</a><a class="pilcrow" href="#section-toc.1-1.1.2.1.1">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.1.2.2">
                <p id="section-toc.1-1.1.2.2.1"><a class="xref" href="#section-1.2">1.2</a>.  <a class="xref" href="#name-lower-latency-and-better-pr">Lower Latency and Better Protection of Real-Time Flows with the Sliding Window RLC Codes</a><a class="pilcrow" href="#section-toc.1-1.1.2.2.1">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.1.2.3">
                <p id="section-toc.1-1.1.2.3.1"><a class="xref" href="#section-1.3">1.3</a>.  <a class="xref" href="#name-small-transmission-overhead">Small Transmission Overheads with the Sliding Window RLC FEC Scheme</a><a class="pilcrow" href="#section-toc.1-1.1.2.3.1">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.1.2.4">
                <p id="section-toc.1-1.1.2.4.1"><a class="xref" href="#section-1.4">1.4</a>.  <a class="xref" href="#name-document-organization">Document Organization</a><a class="pilcrow" href="#section-toc.1-1.1.2.4.1">¶</a></p>
</li>
</ul>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.2">
            <p id="section-toc.1-1.2.1"><a class="xref" href="#section-2">2</a>.  <a class="xref" href="#name-definitions-and-abbreviatio">Definitions and Abbreviations</a><a class="pilcrow" href="#section-toc.1-1.2.1">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.3">
            <p id="section-toc.1-1.3.1"><a class="xref" href="#section-3">3</a>.  <a class="xref" href="#name-common-procedures">Common Procedures</a><a class="pilcrow" href="#section-toc.1-1.3.1">¶</a></p>
<ul class="toc ulEmpty">
<li class="toc ulEmpty" id="section-toc.1-1.3.2.1">
                <p id="section-toc.1-1.3.2.1.1"><a class="xref" href="#section-3.1">3.1</a>.  <a class="xref" href="#name-codec-parameters">Codec Parameters</a><a class="pilcrow" href="#section-toc.1-1.3.2.1.1">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.3.2.2">
                <p id="section-toc.1-1.3.2.2.1"><a class="xref" href="#section-3.2">3.2</a>.  <a class="xref" href="#name-adu-adui-and-source-symbols">ADU, ADUI, and Source Symbols Mappings</a><a class="pilcrow" href="#section-toc.1-1.3.2.2.1">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.3.2.3">
                <p id="section-toc.1-1.3.2.3.1"><a class="xref" href="#section-3.3">3.3</a>.  <a class="xref" href="#name-encoding-window-management">Encoding Window Management</a><a class="pilcrow" href="#section-toc.1-1.3.2.3.1">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.3.2.4">
                <p id="section-toc.1-1.3.2.4.1"><a class="xref" href="#section-3.4">3.4</a>.  <a class="xref" href="#name-source-symbol-identificatio">Source Symbol Identification</a><a class="pilcrow" href="#section-toc.1-1.3.2.4.1">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.3.2.5">
                <p id="section-toc.1-1.3.2.5.1"><a class="xref" href="#section-3.5">3.5</a>.  <a class="xref" href="#name-pseudorandom-number-generat">Pseudorandom Number Generator (PRNG)</a><a class="pilcrow" href="#section-toc.1-1.3.2.5.1">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.3.2.6">
                <p id="section-toc.1-1.3.2.6.1"><a class="xref" href="#section-3.6">3.6</a>.  <a class="xref" href="#name-coding-coefficients-generat">Coding Coefficients Generation Function</a><a class="pilcrow" href="#section-toc.1-1.3.2.6.1">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.3.2.7">
                <p id="section-toc.1-1.3.2.7.1"><a class="xref" href="#section-3.7">3.7</a>.  <a class="xref" href="#name-finite-field-operations">Finite Field Operations</a><a class="pilcrow" href="#section-toc.1-1.3.2.7.1">¶</a></p>
<ul class="toc ulEmpty">
<li class="toc ulEmpty" id="section-toc.1-1.3.2.7.2.1">
                    <p id="section-toc.1-1.3.2.7.2.1.1"><a class="xref" href="#section-3.7.1">3.7.1</a>.  <a class="xref" href="#name-finite-field-definitions">Finite Field Definitions</a><a class="pilcrow" href="#section-toc.1-1.3.2.7.2.1.1">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.3.2.7.2.2">
                    <p id="section-toc.1-1.3.2.7.2.2.1"><a class="xref" href="#section-3.7.2">3.7.2</a>.  <a class="xref" href="#name-linear-combination-of-sourc">Linear Combination of Source Symbol Computation</a><a class="pilcrow" href="#section-toc.1-1.3.2.7.2.2.1">¶</a></p>
</li>
</ul>
</li>
</ul>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.4">
            <p id="section-toc.1-1.4.1"><a class="xref" href="#section-4">4</a>.  <a class="xref" href="#name-sliding-window-rlc-fec-sche">Sliding Window RLC FEC Scheme over GF(2<sup>8</sup>) for Arbitrary Packet Flows</a><a class="pilcrow" href="#section-toc.1-1.4.1">¶</a></p>
<ul class="toc ulEmpty">
<li class="toc ulEmpty" id="section-toc.1-1.4.2.1">
                <p id="section-toc.1-1.4.2.1.1"><a class="xref" href="#section-4.1">4.1</a>.  <a class="xref" href="#name-formats-and-codes">Formats and Codes</a><a class="pilcrow" href="#section-toc.1-1.4.2.1.1">¶</a></p>
<ul class="toc ulEmpty">
<li class="toc ulEmpty" id="section-toc.1-1.4.2.1.2.1">
                    <p id="section-toc.1-1.4.2.1.2.1.1"><a class="xref" href="#section-4.1.1">4.1.1</a>.  <a class="xref" href="#name-fec-framework-configuration">FEC Framework Configuration Information</a><a class="pilcrow" href="#section-toc.1-1.4.2.1.2.1.1">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.4.2.1.2.2">
                    <p id="section-toc.1-1.4.2.1.2.2.1"><a class="xref" href="#section-4.1.2">4.1.2</a>.  <a class="xref" href="#name-explicit-source-fec-payload">Explicit Source FEC Payload ID</a><a class="pilcrow" href="#section-toc.1-1.4.2.1.2.2.1">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.4.2.1.2.3">
                    <p id="section-toc.1-1.4.2.1.2.3.1"><a class="xref" href="#section-4.1.3">4.1.3</a>.  <a class="xref" href="#name-repair-fec-payload-id">Repair FEC Payload ID</a><a class="pilcrow" href="#section-toc.1-1.4.2.1.2.3.1">¶</a></p>
</li>
</ul>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.4.2.2">
                <p id="section-toc.1-1.4.2.2.1"><a class="xref" href="#section-4.2">4.2</a>.  <a class="xref" href="#name-procedures">Procedures</a><a class="pilcrow" href="#section-toc.1-1.4.2.2.1">¶</a></p>
</li>
</ul>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.5">
            <p id="section-toc.1-1.5.1"><a class="xref" href="#section-5">5</a>.  <a class="xref" href="#name-sliding-window-rlc-fec-schem">Sliding Window RLC FEC Scheme over GF(2) for Arbitrary Packet Flows</a><a class="pilcrow" href="#section-toc.1-1.5.1">¶</a></p>
<ul class="toc ulEmpty">
<li class="toc ulEmpty" id="section-toc.1-1.5.2.1">
                <p id="section-toc.1-1.5.2.1.1"><a class="xref" href="#section-5.1">5.1</a>.  <a class="xref" href="#name-formats-and-codes-2">Formats and Codes</a><a class="pilcrow" href="#section-toc.1-1.5.2.1.1">¶</a></p>
<ul class="toc ulEmpty">
<li class="toc ulEmpty" id="section-toc.1-1.5.2.1.2.1">
                    <p id="section-toc.1-1.5.2.1.2.1.1"><a class="xref" href="#section-5.1.1">5.1.1</a>.  <a class="xref" href="#name-fec-framework-configuration-">FEC Framework Configuration Information</a><a class="pilcrow" href="#section-toc.1-1.5.2.1.2.1.1">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.5.2.1.2.2">
                    <p id="section-toc.1-1.5.2.1.2.2.1"><a class="xref" href="#section-5.1.2">5.1.2</a>.  <a class="xref" href="#name-explicit-source-fec-payload-">Explicit Source FEC Payload ID</a><a class="pilcrow" href="#section-toc.1-1.5.2.1.2.2.1">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.5.2.1.2.3">
                    <p id="section-toc.1-1.5.2.1.2.3.1"><a class="xref" href="#section-5.1.3">5.1.3</a>.  <a class="xref" href="#name-repair-fec-payload-id-2">Repair FEC Payload ID</a><a class="pilcrow" href="#section-toc.1-1.5.2.1.2.3.1">¶</a></p>
</li>
</ul>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.5.2.2">
                <p id="section-toc.1-1.5.2.2.1"><a class="xref" href="#section-5.2">5.2</a>.  <a class="xref" href="#name-procedures-2">Procedures</a><a class="pilcrow" href="#section-toc.1-1.5.2.2.1">¶</a></p>
</li>
</ul>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.6">
            <p id="section-toc.1-1.6.1"><a class="xref" href="#section-6">6</a>.  <a class="xref" href="#name-fec-code-specification">FEC Code Specification</a><a class="pilcrow" href="#section-toc.1-1.6.1">¶</a></p>
<ul class="toc ulEmpty">
<li class="toc ulEmpty" id="section-toc.1-1.6.2.1">
                <p id="section-toc.1-1.6.2.1.1"><a class="xref" href="#section-6.1">6.1</a>.  <a class="xref" href="#name-encoding-side">Encoding Side</a><a class="pilcrow" href="#section-toc.1-1.6.2.1.1">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.6.2.2">
                <p id="section-toc.1-1.6.2.2.1"><a class="xref" href="#section-6.2">6.2</a>.  <a class="xref" href="#name-decoding-side">Decoding Side</a><a class="pilcrow" href="#section-toc.1-1.6.2.2.1">¶</a></p>
</li>
</ul>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.7">
            <p id="section-toc.1-1.7.1"><a class="xref" href="#section-7">7</a>.  <a class="xref" href="#name-security-considerations">Security Considerations</a><a class="pilcrow" href="#section-toc.1-1.7.1">¶</a></p>
<ul class="toc ulEmpty">
<li class="toc ulEmpty" id="section-toc.1-1.7.2.1">
                <p id="section-toc.1-1.7.2.1.1"><a class="xref" href="#section-7.1">7.1</a>.  <a class="xref" href="#name-attacks-against-the-data-fl">Attacks Against the Data Flow</a><a class="pilcrow" href="#section-toc.1-1.7.2.1.1">¶</a></p>
<ul class="toc ulEmpty">
<li class="toc ulEmpty" id="section-toc.1-1.7.2.1.2.1">
                    <p id="section-toc.1-1.7.2.1.2.1.1"><a class="xref" href="#section-7.1.1">7.1.1</a>.  <a class="xref" href="#name-access-to-confidential-cont">Access to Confidential Content</a><a class="pilcrow" href="#section-toc.1-1.7.2.1.2.1.1">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.7.2.1.2.2">
                    <p id="section-toc.1-1.7.2.1.2.2.1"><a class="xref" href="#section-7.1.2">7.1.2</a>.  <a class="xref" href="#name-content-corruption">Content Corruption</a><a class="pilcrow" href="#section-toc.1-1.7.2.1.2.2.1">¶</a></p>
</li>
</ul>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.7.2.2">
                <p id="section-toc.1-1.7.2.2.1"><a class="xref" href="#section-7.2">7.2</a>.  <a class="xref" href="#name-attacks-against-the-fec-par">Attacks Against the FEC Parameters</a><a class="pilcrow" href="#section-toc.1-1.7.2.2.1">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.7.2.3">
                <p id="section-toc.1-1.7.2.3.1"><a class="xref" href="#section-7.3">7.3</a>.  <a class="xref" href="#name-when-several-source-flows-a">When Several Source Flows are to be Protected Together</a><a class="pilcrow" href="#section-toc.1-1.7.2.3.1">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.7.2.4">
                <p id="section-toc.1-1.7.2.4.1"><a class="xref" href="#section-7.4">7.4</a>.  <a class="xref" href="#name-baseline-secure-fec-framewo">Baseline Secure FEC Framework Operation</a><a class="pilcrow" href="#section-toc.1-1.7.2.4.1">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.7.2.5">
                <p id="section-toc.1-1.7.2.5.1"><a class="xref" href="#section-7.5">7.5</a>.  <a class="xref" href="#name-additional-security-conside">Additional Security Considerations for Numerical Computations</a><a class="pilcrow" href="#section-toc.1-1.7.2.5.1">¶</a></p>
</li>
</ul>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.8">
            <p id="section-toc.1-1.8.1"><a class="xref" href="#section-8">8</a>.  <a class="xref" href="#name-operations-and-management-c">Operations and Management Considerations</a><a class="pilcrow" href="#section-toc.1-1.8.1">¶</a></p>
<ul class="toc ulEmpty">
<li class="toc ulEmpty" id="section-toc.1-1.8.2.1">
                <p id="section-toc.1-1.8.2.1.1"><a class="xref" href="#section-8.1">8.1</a>.  <a class="xref" href="#name-operational-recommendations">Operational Recommendations: Finite Field GF(2) Versus GF(2<sup>8</sup>)</a><a class="pilcrow" href="#section-toc.1-1.8.2.1.1">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.8.2.2">
                <p id="section-toc.1-1.8.2.2.1"><a class="xref" href="#section-8.2">8.2</a>.  <a class="xref" href="#name-operational-recommendations-">Operational Recommendations: Coding Coefficients Density Threshold</a><a class="pilcrow" href="#section-toc.1-1.8.2.2.1">¶</a></p>
</li>
</ul>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.9">
            <p id="section-toc.1-1.9.1"><a class="xref" href="#section-9">9</a>.  <a class="xref" href="#name-iana-considerations">IANA Considerations</a><a class="pilcrow" href="#section-toc.1-1.9.1">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.10">
            <p id="section-toc.1-1.10.1"><a class="xref" href="#section-10">10</a>. <a class="xref" href="#name-references">References</a><a class="pilcrow" href="#section-toc.1-1.10.1">¶</a></p>
<ul class="toc ulEmpty">
<li class="toc ulEmpty" id="section-toc.1-1.10.2.1">
                <p id="section-toc.1-1.10.2.1.1"><a class="xref" href="#section-10.1">10.1</a>.  <a class="xref" href="#name-normative-references">Normative References</a><a class="pilcrow" href="#section-toc.1-1.10.2.1.1">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.10.2.2">
                <p id="section-toc.1-1.10.2.2.1"><a class="xref" href="#section-10.2">10.2</a>.  <a class="xref" href="#name-informative-references">Informative References</a><a class="pilcrow" href="#section-toc.1-1.10.2.2.1">¶</a></p>
</li>
</ul>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.11">
            <p id="section-toc.1-1.11.1"><a class="xref" href="#section-appendix.a">Appendix A</a>.  <a class="xref" href="#name-tinymt32-validation-criteri">TinyMT32 Validation Criteria (Normative)</a><a class="pilcrow" href="#section-toc.1-1.11.1">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.12">
            <p id="section-toc.1-1.12.1"><a class="xref" href="#section-appendix.b">Appendix B</a>.  <a class="xref" href="#name-assessing-the-prng-adequacy">Assessing the PRNG Adequacy (Informational)</a><a class="pilcrow" href="#section-toc.1-1.12.1">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.13">
            <p id="section-toc.1-1.13.1"><a class="xref" href="#section-appendix.c">Appendix C</a>.  <a class="xref" href="#name-possible-parameter-derivati">Possible Parameter Derivation (Informational)</a><a class="pilcrow" href="#section-toc.1-1.13.1">¶</a></p>
<ul class="toc ulEmpty">
<li class="toc ulEmpty" id="section-toc.1-1.13.2.1">
                <p id="section-toc.1-1.13.2.1.1"><a class="xref" href="#section-c.1">C.1</a>.  <a class="xref" href="#name-case-of-a-cbr-real-time-flo">Case of a CBR Real-Time Flow</a><a class="pilcrow" href="#section-toc.1-1.13.2.1.1">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.13.2.2">
                <p id="section-toc.1-1.13.2.2.1"><a class="xref" href="#section-c.2">C.2</a>.  <a class="xref" href="#name-other-types-of-real-time-fl">Other Types of Real-Time Flow</a><a class="pilcrow" href="#section-toc.1-1.13.2.2.1">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.13.2.3">
                <p id="section-toc.1-1.13.2.3.1"><a class="xref" href="#section-c.3">C.3</a>.  <a class="xref" href="#name-case-of-a-non-real-time-flo">Case of a Non-Real-Time Flow</a><a class="pilcrow" href="#section-toc.1-1.13.2.3.1">¶</a></p>
</li>
</ul>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.14">
            <p id="section-toc.1-1.14.1"><a class="xref" href="#section-appendix.d">Appendix D</a>.  <a class="xref" href="#name-decoding-beyond-maximum-lat">Decoding Beyond Maximum Latency Optimization (Informational)</a><a class="pilcrow" href="#section-toc.1-1.14.1">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.15">
            <p id="section-toc.1-1.15.1"><a class="xref" href="#section-appendix.e"></a><a class="xref" href="#name-acknowledgments">Acknowledgments</a><a class="pilcrow" href="#section-toc.1-1.15.1">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.16">
            <p id="section-toc.1-1.16.1"><a class="xref" href="#section-appendix.f"></a><a class="xref" href="#name-authors-addresses">Authors' Addresses</a><a class="pilcrow" href="#section-toc.1-1.16.1">¶</a></p>
</li>
</ul>
</nav>
</section>
</div>
<div id="introduction">
<section id="section-1">
      <h2 id="name-introduction">
<a class="section-number selfRef" href="#section-1">1. </a><a class="section-name selfRef" href="#name-introduction">Introduction</a>
      </h2>
<p id="section-1-1">
Application-Level Forward Erasure Correction (AL-FEC) codes, or simply FEC codes, are a key element of communication systems.
They are used to recover from packet losses (or erasures) during content delivery sessions to a potentially large number of receivers (multicast/broadcast transmissions).
This is the case with the File Delivery over Unidirectional Transport
(FLUTE)/Asynchronous Layered Coding (ALC) protocol <span>[<a class="xref" href="#RFC6726">RFC6726</a>]</span> when used for reliable file transfers over lossy networks, and the FECFRAME protocol <span>[<a class="xref" href="#RFC6363">RFC6363</a>]</span> when used for reliable continuous media transfers over lossy networks.<a class="pilcrow" href="#section-1-1">¶</a></p>
<p id="section-1-2">
The present document only focuses on the FECFRAME protocol, which is used in multicast/broadcast delivery mode, particularly for content that features stringent real-time constraints: each source packet has a maximum validity period after which it will not be considered by the destination application.<a class="pilcrow" href="#section-1-2">¶</a></p>
<div id="intro_block_codes">
<section id="section-1.1">
        <h3 id="name-limits-of-block-codes-with-">
<a class="section-number selfRef" href="#section-1.1">1.1. </a><a class="section-name selfRef" href="#name-limits-of-block-codes-with-">Limits of Block Codes with Real-Time Flows</a>
        </h3>
<p id="section-1.1-1">
With FECFRAME, there is a single FEC encoding point (either an end host/server
(source) or a middlebox) and a single FEC decoding point per receiver (either
an end host (receiver) or middlebox).
In this context, currently standardized AL-FEC codes for FECFRAME like Reed-Solomon <span>[<a class="xref" href="#RFC6865">RFC6865</a>]</span>, LDPC-Staircase <span>[<a class="xref" href="#RFC6816">RFC6816</a>]</span>, or Raptor/RaptorQ <span>[<a class="xref" href="#RFC6681">RFC6681</a>]</span>, are all linear block codes: they require the data flow to be segmented into blocks of a predefined maximum size.<a class="pilcrow" href="#section-1.1-1">¶</a></p>
<p id="section-1.1-2">
To define this block size, it is required to find an appropriate balance between robustness and decoding latency: the larger the block size, the higher the robustness (e.g., in case of long packet erasure bursts), but also the higher the maximum decoding latency (i.e., the maximum time required to recover a lost (erased) packet thanks to FEC protection).
Therefore, with a multicast/broadcast session where different receivers experience different packet loss rates, the block size should be chosen by considering the worst communication conditions one wants to support, but without exceeding the desired maximum decoding latency.
This choice then impacts the FEC-related latency of all receivers, even those experiencing a good communication quality, since no FEC encoding can happen until all the source data of the block is available at the sender, which directly depends on the block size.<a class="pilcrow" href="#section-1.1-2">¶</a></p>
</section>
</div>
<div id="intro_conv_codes">
<section id="section-1.2">
        <h3 id="name-lower-latency-and-better-pr">
<a class="section-number selfRef" href="#section-1.2">1.2. </a><a class="section-name selfRef" href="#name-lower-latency-and-better-pr">Lower Latency and Better Protection of Real-Time Flows with the Sliding Window RLC Codes</a>
        </h3>
<p id="section-1.2-1">
This document introduces two fully specified FEC schemes that do not follow the block code approach: the Sliding Window Random Linear Codes (RLC) over either Galois Fields (a.k.a., Finite Fields) GF(2) (the "binary case") or GF(2<sup>8</sup>), each time with the possibility of controlling the code density.
These FEC schemes are used to protect arbitrary media streams along the lines defined by FECFRAME extended to Sliding Window FEC Codes <span>[<a class="xref" href="#RFC8680">RFC8680</a>]</span>.
These FEC schemes and, more generally, Sliding Window FEC Codes are recommended, for instance, with media that feature real-time constraints sent within a multicast/broadcast session <span>[<a class="xref" href="#Roca17">Roca17</a>]</span>.<a class="pilcrow" href="#section-1.2-1">¶</a></p>
<p id="section-1.2-2">
The RLC codes belong to the broad class of Sliding Window AL-FEC Codes (a.k.a., convolutional codes) <span>[<a class="xref" href="#RFC8406">RFC8406</a>]</span>.
The encoding process is based on an encoding window that slides over the set of source packets (in fact source symbols as we will see in <a class="xref" href="#CommonProc_adui_creation">Section 3.2</a>), this window being either of fixed size or variable size (a.k.a., an elastic window).
Repair symbols are generated on-the-fly, by computing a random linear combination of the source symbols present in the current encoding window, and passed to the transport layer.<a class="pilcrow" href="#section-1.2-2">¶</a></p>
<p id="section-1.2-3">
At the receiver, a linear system is managed from the set of received source and repair packets.
New variables (representing source symbols) and equations (representing the linear combination carried by each repair symbol received) are added upon receiving new packets.
Variables and the equations they are involved in are removed when they are too old with respect to their validity period (real-time constraints).
Lost source symbols are then recovered thanks to this linear system whenever its rank permits to solve it (at least partially).<a class="pilcrow" href="#section-1.2-3">¶</a></p>
<p id="section-1.2-4">
The protection of any multicast/broadcast session needs to be dimensioned by considering the worst communication conditions one wants to support.
This is also true with RLC (more generally, any sliding window) code.
However, the receivers experiencing a good to medium communication quality will observe a reduced FEC-related latency compared to block codes <span>[<a class="xref" href="#Roca17">Roca17</a>]</span> since an isolated lost source packet is quickly recovered with the following repair packet.
On the opposite, with a block code, recovering an isolated lost source packet always requires waiting for the first repair packet to arrive after the end of the block.
Additionally, under certain situations (e.g., with a limited FEC-related latency budget and with constant bitrate transmissions after FECFRAME encoding), Sliding Window Codes can more efficiently achieve a target transmission quality (e.g., measured by the residual loss after FEC decoding) by sending fewer repair packets (i.e., higher code rate) than block codes.<a class="pilcrow" href="#section-1.2-4">¶</a></p>
</section>
</div>
<div id="intro_low_tx_overhead">
<section id="section-1.3">
        <h3 id="name-small-transmission-overhead">
<a class="section-number selfRef" href="#section-1.3">1.3. </a><a class="section-name selfRef" href="#name-small-transmission-overhead">Small Transmission Overheads with the Sliding Window RLC FEC Scheme</a>
        </h3>
<p id="section-1.3-1">
The Sliding Window RLC FEC scheme is designed to limit the packet header overhead.
The main requirement is that each repair packet header must enable a receiver to reconstruct the set of source symbols plus the associated coefficients used during the encoding process.
In order to minimize packet overhead, the set of source symbols in the encoding window as well as the set of coefficients over GF(2<sup>m</sup>) (where m is 1 or 8, depending on the FEC scheme) used in the linear combination are not individually listed in the repair packet header.
Instead, each FEC Repair Packet header contains:<a class="pilcrow" href="#section-1.3-1">¶</a></p>
<ul>
<li id="section-1.3-2.1">the Encoding Symbol Identifier (ESI) of the first source symbol in the encoding window as well as the number of symbols (since this number may vary with a variable size, elastic window).
 These two pieces of information enable each receiver to reconstruct the set of source symbols considered during encoding, the only constraint being that there cannot be any gap;<a class="pilcrow" href="#section-1.3-2.1">¶</a>
</li>
<li id="section-1.3-2.2">the seed and density threshold parameters used by a coding coefficients generation function (<a class="xref" href="#CommonProc_coef_generation_func">Section 3.6</a>).
 These two pieces of information enable each receiver to generate the same set of coding coefficients over GF(2<sup>m</sup>) as the sender;<a class="pilcrow" href="#section-1.3-2.2">¶</a>
</li>
</ul>
<p id="section-1.3-3">
Therefore, no matter the number of source symbols present in the encoding window, each FEC Repair Packet features a fixed 64-bit long header, called Repair FEC Payload ID (<a class="xref" href="#fig_repair_fpi">Figure 8</a>).
Similarly, each FEC Source Packet features a fixed 32-bit long trailer, called Explicit Source FEC Payload ID (<a class="xref" href="#fig_src_fpi">Figure 6</a>), that contains the ESI of the first source symbol (<a class="xref" href="#CommonProc_adui_creation">Section 3.2</a>).<a class="pilcrow" href="#section-1.3-3">¶</a></p>
</section>
</div>
<section id="section-1.4">
        <h3 id="name-document-organization">
<a class="section-number selfRef" href="#section-1.4">1.4. </a><a class="section-name selfRef" href="#name-document-organization">Document Organization</a>
        </h3>
<p id="section-1.4-1">
This fully-specified FEC scheme follows the structure required by <span>[<a class="xref" href="#RFC6363">RFC6363</a>], <a class="relref" href="https://www.rfc-editor.org/rfc/rfc6363#section-5.6">Section 5.6</a></span> ("FEC Scheme Requirements"), namely:<a class="pilcrow" href="#section-1.4-1">¶</a></p>
<ol class="normal" id="section-1.4-2" start="3" type="1">
          <li id="section-1.4-2.1">Procedures:
 This section describes procedures specific to this FEC scheme, namely: RLC parameters derivation, ADUI and source symbols mapping, pseudorandom number generator, and coding coefficients generation function;<a class="pilcrow" href="#section-1.4-2.1">¶</a>
</li>
<li id="section-1.4-2.2">Formats and Codes:
 This section defines the Source FEC Payload ID and Repair FEC Payload ID formats, carrying the signaling information associated to each source or repair symbol.
 It also defines the FEC Framework Configuration Information (FFCI) carrying signaling information for the session;<a class="pilcrow" href="#section-1.4-2.2">¶</a>
</li>
<li id="section-1.4-2.3">FEC Code Specification:
 Finally this section provides the code specification.<a class="pilcrow" href="#section-1.4-2.3">¶</a>
</li>
</ol>
</section>
</section>
</div>
<div id="definitionsAndAbbreviations">
<section id="section-2">
      <h2 id="name-definitions-and-abbreviatio">
<a class="section-number selfRef" href="#section-2">2. </a><a class="section-name selfRef" href="#name-definitions-and-abbreviatio">Definitions and Abbreviations</a>
      </h2>
<p id="section-2-1">
The key words "<span class="bcp14">MUST</span>", "<span class="bcp14">MUST NOT</span>", "<span class="bcp14">REQUIRED</span>", "<span class="bcp14">SHALL</span>", "<span class="bcp14">SHALL NOT</span>", "<span class="bcp14">SHOULD</span>", "<span class="bcp14">SHOULD NOT</span>", "<span class="bcp14">RECOMMENDED</span>", "<span class="bcp14">NOT RECOMMENDED</span>",
"<span class="bcp14">MAY</span>", and "<span class="bcp14">OPTIONAL</span>" in this document are to be interpreted as
described in BCP 14 <span>[<a class="xref" href="#RFC2119">RFC2119</a>]</span> <span>[<a class="xref" href="#RFC8174">RFC8174</a>]</span>
when, and only when, they appear in all capitals, as shown here.<a class="pilcrow" href="#section-2-1">¶</a></p>
<p id="section-2-2">This document uses the following definitions and abbreviations:<a class="pilcrow" href="#section-2-2">¶</a></p>
<dl class="dlParallel" id="section-2-3">
        <dt id="section-2-3.1">a<sup>b</sup>
</dt>
<dd id="section-2-3.2"> a to the power of b<a class="pilcrow" href="#section-2-3.2">¶</a>
</dd>
<dt id="section-2-3.3">GF(q)</dt>
<dd id="section-2-3.4"> denotes a finite field (also known as the Galois Field) with q elements.
 We assume that q = 2<sup>m</sup> in this document<a class="pilcrow" href="#section-2-3.4">¶</a>
</dd>
<dt id="section-2-3.5">m</dt>
<dd id="section-2-3.6"> defines the length of the elements in the finite field, in bits.
 In this document, m is equal to 1 or 8<a class="pilcrow" href="#section-2-3.6">¶</a>
</dd>
<dt id="section-2-3.7">ADU:</dt>
<dd id="section-2-3.8"> Application Data Unit<a class="pilcrow" href="#section-2-3.8">¶</a>
</dd>
<dt id="section-2-3.9">ADUI:</dt>
<dd id="section-2-3.10"> Application Data Unit Information (includes the F, L and padding fields in addition to the ADU)<a class="pilcrow" href="#section-2-3.10">¶</a>
</dd>
<dt id="section-2-3.11">E:</dt>
<dd id="section-2-3.12"> size of an encoding symbol (i.e., source or repair symbol), assumed fixed (in bytes)<a class="pilcrow" href="#section-2-3.12">¶</a>
</dd>
<dt id="section-2-3.13">br_in:</dt>
<dd id="section-2-3.14"> transmission bitrate at the input of the FECFRAME sender, assumed fixed (in bits/s)<a class="pilcrow" href="#section-2-3.14">¶</a>
</dd>
<dt id="section-2-3.15">br_out:</dt>
<dd id="section-2-3.16"> transmission bitrate at the output of the FECFRAME sender, assumed fixed (in bits/s)<a class="pilcrow" href="#section-2-3.16">¶</a>
</dd>
<dt id="section-2-3.17">max_lat:</dt>
<dd id="section-2-3.18">  maximum FEC-related latency within FECFRAME (a decimal number expressed in seconds)<a class="pilcrow" href="#section-2-3.18">¶</a>
</dd>
<dt id="section-2-3.19">cr:</dt>
<dd id="section-2-3.20"> RLC coding rate, ratio between the total number of source symbols and the total number of source plus repair symbols<a class="pilcrow" href="#section-2-3.20">¶</a>
</dd>
<dt id="section-2-3.21">ew_size:</dt>
<dd id="section-2-3.22"> encoding window current size at a sender (in symbols)<a class="pilcrow" href="#section-2-3.22">¶</a>
</dd>
<dt id="section-2-3.23">ew_max_size:</dt>
<dd id="section-2-3.24"> encoding window maximum size at a sender (in symbols)<a class="pilcrow" href="#section-2-3.24">¶</a>
</dd>
<dt id="section-2-3.25">dw_max_size:</dt>
<dd id="section-2-3.26"> decoding window maximum size at a receiver (in symbols)<a class="pilcrow" href="#section-2-3.26">¶</a>
</dd>
<dt id="section-2-3.27">ls_max_size:</dt>
<dd id="section-2-3.28"> linear system maximum size (or width) at a receiver (in symbols)<a class="pilcrow" href="#section-2-3.28">¶</a>
</dd>
<dt id="section-2-3.29">WSR:</dt>
<dd id="section-2-3.30"> window size ratio parameter used to derive ew_max_size (encoder) and ls_max_size (decoder).<a class="pilcrow" href="#section-2-3.30">¶</a>
</dd>
<dt id="section-2-3.31">PRNG:</dt>
<dd id="section-2-3.32"> pseudorandom number generator<a class="pilcrow" href="#section-2-3.32">¶</a>
</dd>
<dt id="section-2-3.33">TinyMT32:</dt>
<dd id="section-2-3.34"> PRNG used in this specification.<a class="pilcrow" href="#section-2-3.34">¶</a>
</dd>
<dt id="section-2-3.35">DT:</dt>
<dd id="section-2-3.36"> coding coefficients density threshold, an integer between 0 and 15 (inclusive) the controls
 the fraction of coefficients that are nonzero<a class="pilcrow" href="#section-2-3.36">¶</a>
</dd>
</dl>
</section>
</div>
<div id="CommonProcedures">
<section id="section-3">
      <h2 id="name-common-procedures">
<a class="section-number selfRef" href="#section-3">3. </a><a class="section-name selfRef" href="#name-common-procedures">Common Procedures</a>
      </h2>
<p id="section-3-1">
This section introduces the procedures that are used by these FEC schemes.<a class="pilcrow" href="#section-3-1">¶</a></p>
<div id="CommonProc_rlcParameters">
<section id="section-3.1">
        <h3 id="name-codec-parameters">
<a class="section-number selfRef" href="#section-3.1">3.1. </a><a class="section-name selfRef" href="#name-codec-parameters">Codec Parameters</a>
        </h3>
<p id="section-3.1-1">
A codec implementing the Sliding Window RLC FEC scheme relies on several parameters:<a class="pilcrow" href="#section-3.1-1">¶</a></p>
<dl class="dlNewline" id="section-3.1-2">
          <dt id="section-3.1-2.1">Maximum FEC-related latency budget, max_lat (a decimal number expressed in seconds) with real-time flows:</dt>
<dd id="section-3.1-2.2">
 a source ADU flow can have real-time constraints, and therefore any FECFRAME related operation should take place within the validity
 period of each ADU (<a class="xref" href="#decodingBeyondMaxLatency">Appendix D</a> describes an exception to this rule).
 When there are multiple flows with different real-time
 constraints, we consider the most stringent constraints (see
 item 6 in <span><a class="relref" href="https://www.rfc-editor.org/rfc/rfc6363#section-10.2">Section 10.2</a> of [<a class="xref" href="#RFC6363">RFC6363</a>]</span>,
 for recommendations when several flows are globally protected).
 The maximum FEC-related latency budget, max_lat, accounts for all sources of latency added by FEC encoding (at a sender) and FEC decoding (at a receiver).
 Other sources of latency (e.g., added by network communications) are out of scope and must be considered separately (said differently, they have already been deducted from max_lat).
 max_lat can be regarded as the latency budget permitted for all FEC-related operations.
 This is an input parameter that enables a FECFRAME sender to derive other internal parameters (see <a class="xref" href="#possible_param_derivation">Appendix C</a>);<a class="pilcrow" href="#section-3.1-2.2">¶</a>
</dd>
<dt id="section-3.1-2.3">Encoding window current (resp. maximum) size, ew_size (resp. ew_max_size) (in symbols):</dt>
<dd id="section-3.1-2.4">
            <p id="section-3.1-2.4.1">
 at a FECFRAME sender, during FEC encoding, a repair symbol is computed as a linear combination of the ew_size source symbols present in the encoding window.
 The ew_max_size is the maximum size of this window, while ew_size is the current size.
 For example, in the common case at session start, upon receiving new source ADUs, the ew_size progressively increases until it reaches its maximum value, ew_max_size.
 We have:<a class="pilcrow" href="#section-3.1-2.4.1">¶</a></p>
<ul class="ulEmpty">
<li class="ulEmpty" id="section-3.1-2.4.2.1"> 0 &lt; ew_size &lt;= ew_max_size<a class="pilcrow" href="#section-3.1-2.4.2.1">¶</a>
</li>
</ul>
</dd>
<dt id="section-3.1-2.5">Decoding window maximum size, dw_max_size (in symbols):</dt>
<dd id="section-3.1-2.6">
 at a FECFRAME receiver, dw_max_size is the maximum number of received or lost source symbols that are still within their latency budget;<a class="pilcrow" href="#section-3.1-2.6">¶</a>
</dd>
<dt id="section-3.1-2.7">Linear system maximum size, ls_max_size (in symbols):</dt>
<dd id="section-3.1-2.8">
 at a FECFRAME receiver, the linear system maximum size, ls_max_size, is the maximum number of received or lost source symbols in the linear system (i.e., the variables).
 It <span class="bcp14">SHOULD NOT</span> be smaller than dw_max_size since it would mean that, even after receiving a sufficient number of FEC Repair Packets, a lost ADU may not be recovered just because the associated source symbols have been prematurely removed from the linear system, which is usually counter-productive.
 On the opposite, the linear system <span class="bcp14">MAY</span> grow beyond the dw_max_size  (<a class="xref" href="#decodingBeyondMaxLatency">Appendix D</a>);<a class="pilcrow" href="#section-3.1-2.8">¶</a>
</dd>
<dt id="section-3.1-2.9">Symbol size, E (in bytes):</dt>
<dd id="section-3.1-2.10">
 the E parameter determines the source and repair symbol sizes (necessarily equal).
 This is an input parameter that enables a FECFRAME sender to derive other internal parameters, as explained below.
 An implementation at a sender <span class="bcp14">MUST</span> fix the E parameter and <span class="bcp14">MUST</span> communicate it as part of the FEC Scheme-Specific Information (<a class="xref" href="#ArbitraryFlows_fssi">Section 4.1.1.2</a>).<a class="pilcrow" href="#section-3.1-2.10">¶</a>
</dd>
<dt id="section-3.1-2.11">Code rate, cr:</dt>
<dd id="section-3.1-2.12">
  The code rate parameter determines the amount of redundancy added to the flow.
  More precisely the cr is the ratio between the total number of source symbols and the total number of source plus repair symbols and by definition: 0 &lt; cr &lt;= 1.
  This is an input parameter that enables a FECFRAME sender to derive other internal parameters, as explained below.
  However, there is no need to communicate the cr parameter per see (it's not required to process a repair symbol at a receiver).
  This code rate parameter can be static.
  However, in specific use-cases (e.g., with unicast transmissions in presence of a feedback mechanism that estimates the communication quality, out of scope of FECFRAME), the code rate may be adjusted dynamically.<a class="pilcrow" href="#section-3.1-2.12">¶</a>
</dd>
</dl>
<p id="section-3.1-3">
<a class="xref" href="#possible_param_derivation">Appendix C</a> proposes non-normative techniques to derive those parameters, depending on the use-case specificities.<a class="pilcrow" href="#section-3.1-3">¶</a></p>
</section>
</div>
<div id="CommonProc_adui_creation">
<section id="section-3.2">
        <h3 id="name-adu-adui-and-source-symbols">
<a class="section-number selfRef" href="#section-3.2">3.2. </a><a class="section-name selfRef" href="#name-adu-adui-and-source-symbols">ADU, ADUI, and Source Symbols Mappings</a>
        </h3>
<p id="section-3.2-1">
At a sender, an ADU coming from the application is not directly mapped to source symbols.
When multiple source flows (e.g., media streams) are mapped onto the same FECFRAME instance, each flow is assigned its own Flow ID value (see below).
This Flow ID is then prepended to each ADU before FEC encoding.
This way, FEC decoding at a receiver also recovers this Flow ID and the recovered ADU can be assigned to the right source flow
(note that the 5-tuple used to identify the right source flow of a received ADU is absent with a recovered ADU since it is not FEC protected).<a class="pilcrow" href="#section-3.2-1">¶</a></p>
<p id="section-3.2-2">
Additionally, since ADUs are of variable size, padding is needed so that each ADU (with its flow identifier) contribute
to an integral number of source symbols.
This requires adding the original ADU length to each ADU before doing FEC encoding.
Because of these requirements, an intermediate format, the ADUI, or ADU Information, is considered <span>[<a class="xref" href="#RFC6363">RFC6363</a>]</span>.<a class="pilcrow" href="#section-3.2-2">¶</a></p>
<p id="section-3.2-3">
For each incoming ADU, an ADUI <span class="bcp14">MUST</span> be created as follows.
First of all, 3 bytes are prepended (<a class="xref" href="#fig_adui_creation">Figure 1</a>):<a class="pilcrow" href="#section-3.2-3">¶</a></p>
<dl class="dlParallel" id="section-3.2-4">
          <dt id="section-3.2-4.1">Flow ID (F) (8-bit field):</dt>
<dd id="section-3.2-4.2">
 this unsigned byte contains the integer identifier associated to the source ADU flow to which this ADU belongs.
 It is assumed that a single byte is sufficient, which implies that no more than 256 flows will be protected by
 a single FECFRAME session instance.<a class="pilcrow" href="#section-3.2-4.2">¶</a>
</dd>
<dt id="section-3.2-4.3">Length (L) (16-bit field):</dt>
<dd id="section-3.2-4.4">
 this unsigned integer contains the length of this ADU, in network byte order (i.e., big endian).
 This length is for the ADU itself and does not include the F, L, or Pad fields.<a class="pilcrow" href="#section-3.2-4.4">¶</a>
</dd>
</dl>
<p id="section-3.2-5">
Then, zero padding is added to the ADU if needed:<a class="pilcrow" href="#section-3.2-5">¶</a></p>
<dl class="dlParallel" id="section-3.2-6">
          <dt id="section-3.2-6.1">Padding (Pad) (variable size field):</dt>
<dd id="section-3.2-6.2">
 this field contains zero padding to  align the F, L, ADU and padding 
 up to a size that is multiple of E bytes (i.e., the source and repair symbol length).<a class="pilcrow" href="#section-3.2-6.2">¶</a>
</dd>
</dl>
<p id="section-3.2-7">
The data unit resulting from the ADU and the F, L, and Pad fields is called ADUI.
Since ADUs can have different sizes, this is also the case for ADUIs.
However, an ADUI always contributes to an integral number of source symbols.<a class="pilcrow" href="#section-3.2-7">¶</a></p>
<span id="name-adui-creation-example-resul"></span><div id="fig_adui_creation">
<figure id="figure-1">
          <div class="artwork art-text alignLeft" id="section-3.2-8.1">
<pre>   symbol length, E              E                     E
&lt; ------------------ &gt;&lt; ------------------ &gt;&lt; ------------------ &gt;
+-+--+---------------------------------------------+-------------+
|F| L|                     ADU                     |     Pad     |
+-+--+---------------------------------------------+-------------+
</pre>
</div>
<figcaption><a class="selfRef" href="#figure-1">Figure 1</a>:
<a class="selfRef" href="#name-adui-creation-example-resul">ADUI Creation Example, Resulting in Three Source Symbols</a>
          </figcaption></figure>
</div>
<p id="section-3.2-9">
Note that neither the initial 3 bytes nor the optional padding are sent over the network.
However, they are considered during FEC encoding, and a receiver that lost a certain FEC Source Packet (e.g., the UDP datagram
containing this FEC Source Packet when UDP is used as the transport protocol) will be able to recover the ADUI if FEC decoding succeeds.
Thanks to the initial 3 bytes, this receiver will get rid of the padding (if any) and identify the corresponding ADU flow.<a class="pilcrow" href="#section-3.2-9">¶</a></p>
</section>
</div>
<div id="encodingWindowManagement">
<section id="section-3.3">
        <h3 id="name-encoding-window-management">
<a class="section-number selfRef" href="#section-3.3">3.3. </a><a class="section-name selfRef" href="#name-encoding-window-management">Encoding Window Management</a>
        </h3>
<p id="section-3.3-1">
Source symbols and the corresponding ADUs are removed from the encoding window:<a class="pilcrow" href="#section-3.3-1">¶</a></p>
<ul>
<li id="section-3.3-2.1"> when the sliding encoding window has reached its maximum size, ew_max_size.
 In that case the oldest symbol <span class="bcp14">MUST</span> be removed before adding a new symbol, so that the current encoding window size always
 remains inferior or equal to the maximum size: ew_size &lt;= ew_max_size;<a class="pilcrow" href="#section-3.3-2.1">¶</a>
</li>
<li id="section-3.3-2.2"> when an ADU has reached its maximum validity duration in case of a real-time flow.
 When this happens, all source symbols corresponding to the ADUI that expired <span class="bcp14">SHOULD</span> be removed from the encoding window;<a class="pilcrow" href="#section-3.3-2.2">¶</a>
</li>
</ul>
<p id="section-3.3-3">
Source symbols are added to the sliding encoding window each time a new ADU arrives, once the ADU-to-source symbols mapping has been performed
(<a class="xref" href="#CommonProc_adui_creation">Section 3.2</a>).
The current size of the encoding window, ew_size, is updated after adding new source symbols.
This process may require to remove old source symbols so that: ew_size &lt;= ew_max_size.<a class="pilcrow" href="#section-3.3-3">¶</a></p>
<p id="section-3.3-4">
Note that a FEC codec may feature practical limits in the number of source symbols in the encoding window (e.g., for computational complexity reasons).
This factor may further limit the ew_max_size value, in addition to the maximum FEC-related latency budget (<a class="xref" href="#CommonProc_rlcParameters">Section 3.1</a>).<a class="pilcrow" href="#section-3.3-4">¶</a></p>
</section>
</div>
<div id="CommonProc_esi">
<section id="section-3.4">
        <h3 id="name-source-symbol-identificatio">
<a class="section-number selfRef" href="#section-3.4">3.4. </a><a class="section-name selfRef" href="#name-source-symbol-identificatio">Source Symbol Identification</a>
        </h3>
<p id="section-3.4-1">
Each source symbol is identified by an Encoding Symbol ID (ESI), an unsigned integer.
The ESI of source symbols <span class="bcp14">MUST</span> start with value 0 for the first source symbol and <span class="bcp14">MUST</span> be managed sequentially.
Wrapping to zero happens after reaching the maximum value made possible by the ESI field size
(this maximum value is FEC scheme dependent, for instance, 2<sup>32</sup>-1 with FEC schemes 9 and 10).<a class="pilcrow" href="#section-3.4-1">¶</a></p>
<p id="section-3.4-2">
No such consideration applies to repair symbols.<a class="pilcrow" href="#section-3.4-2">¶</a></p>
</section>
</div>
<div id="CommonProc_prng">
<section id="section-3.5">
        <h3 id="name-pseudorandom-number-generat">
<a class="section-number selfRef" href="#section-3.5">3.5. </a><a class="section-name selfRef" href="#name-pseudorandom-number-generat">Pseudorandom Number Generator (PRNG)</a>
        </h3>
<p id="section-3.5-1">
In order to compute coding coefficients (see <a class="xref" href="#CommonProc_coef_generation_func">Section 3.6</a>), the RLC FEC schemes rely on the TinyMT32 PRNG defined in <span>[<a class="xref" href="#RFC8682">RFC8682</a>]</span> with two additional functions defined in this section.<a class="pilcrow" href="#section-3.5-1">¶</a></p>
<p id="section-3.5-2">
This PRNG <span class="bcp14">MUST</span> first be initialized with a 32-bit unsigned integer, used as a seed, with:<a class="pilcrow" href="#section-3.5-2">¶</a></p>
<div id="section-3.5-3">
<pre class="sourcecode lang-c">   void   tinymt32_init (tinymt32_t * s, uint32_t seed);
</pre><a class="pilcrow" href="#section-3.5-3">¶</a>
</div>
<p id="section-3.5-4">
With the FEC schemes defined in this document, the seed is in practice restricted to a value between 0 and 0xFFFF inclusive (note that this PRNG accepts a seed value equal to 0),
since this is the Repair_Key 16-bit field value of the Repair FEC Payload ID (<a class="xref" href="#ArbitraryFlows_repair_fpi">Section 4.1.3</a>).
In practice, how to manage the seed and Repair_Key values (both are equal) is left to the implementer, using a monotonically increasing counter being one possibility (<a class="xref" href="#ArbitraryFlows_FECCodeSpecification_encoding">Section 6.1</a>).
In addition to the seed, this function takes as parameter a pointer to an instance of a tinymt32_t structure that is used to keep the internal state of the PRNG.<a class="pilcrow" href="#section-3.5-4">¶</a></p>
<p id="section-3.5-5">
Then, each time a new pseudorandom integer between 0 and 15 inclusive (4-bit pseudorandom integer) is needed, the following function is used:<a class="pilcrow" href="#section-3.5-5">¶</a></p>
<div id="section-3.5-6">
<pre class="sourcecode lang-c">   uint32_t   tinymt32_rand16 (tinymt32_t * s);
</pre><a class="pilcrow" href="#section-3.5-6">¶</a>
</div>
<p id="section-3.5-7">
This function takes as parameter a pointer to the same tinymt32_t structure (that is left unchanged between successive calls to the function).<a class="pilcrow" href="#section-3.5-7">¶</a></p>
<p id="section-3.5-8">
Similarly, each time a new pseudorandom integer between 0 and 255 inclusive (8-bit pseudorandom integer) is needed, the following function is used:<a class="pilcrow" href="#section-3.5-8">¶</a></p>
<div id="section-3.5-9">
<pre class="sourcecode lang-c">   uint32_t   tinymt32_rand256 (tinymt32_t * s);
</pre><a class="pilcrow" href="#section-3.5-9">¶</a>
</div>
<p id="section-3.5-10">
These two functions keep respectively the 4 or 8 less significant bits of the 32-bit pseudorandom number generated by the tinymt32_generate_uint32() function of <span>[<a class="xref" href="#RFC8682">RFC8682</a>]</span>.
This is done by computing the result of a binary AND between the tinymt32_generate_uint32() output and respectively the 0xF or 0xFF constants, using 32-bit unsigned integer operations.
<a class="xref" href="#fig_tinymt32_mapping">Figure 2</a> shows a possible implementation.
This is a C language implementation, written for C99 <span>[<a class="xref" href="#C99">C99</a>]</span>.
Test results discussed in  <a class="xref" href="#annex_assessing_prng">Appendix B</a> show that this simple technique, applied to this PRNG, is in line with the RLC FEC schemes needs.<a class="pilcrow" href="#section-3.5-10">¶</a></p>
<span id="name-4-bit-and-8-bit-mapping-fun"></span><div id="fig_tinymt32_mapping">
<figure id="figure-2">
          <div id="section-3.5-11.1">
<pre class="sourcecode lang-c">&lt;CODE BEGINS&gt;
/**
 * This function outputs a pseudorandom integer in [0 .. 15] range.
 *
 * @param s     pointer to tinymt internal state.
 * @return      unsigned integer between 0 and 15 inclusive.
 */
uint32_t tinymt32_rand16(tinymt32_t *s)
{
    return (tinymt32_generate_uint32(s) &amp; 0xF);
}

/**
 * This function outputs a pseudorandom integer in [0 .. 255] range.
 *
 * @param s     pointer to tinymt internal state.
 * @return      unsigned integer between 0 and 255 inclusive.
 */
uint32_t tinymt32_rand256(tinymt32_t *s)
{
    return (tinymt32_generate_uint32(s) &amp; 0xFF);
}

&lt;CODE ENDS&gt;</pre>
</div>
<figcaption><a class="selfRef" href="#figure-2">Figure 2</a>:
<a class="selfRef" href="#name-4-bit-and-8-bit-mapping-fun">4-bit and 8-bit Mapping Functions for TinyMT32</a>
          </figcaption></figure>
</div>
<p id="section-3.5-12">
Any implementation of this PRNG <span class="bcp14">MUST</span> have the same output as
that provided by the reference implementation of <span>[<a class="xref" href="#RFC8682">RFC8682</a>]</span>.

In order to increase the compliance confidence, three criteria are proposed: the one described in <span>[<a class="xref" href="#RFC8682">RFC8682</a>]</span> (for the TinyMT32 32-bit unsigned integer generator), and the two others detailed in <a class="xref" href="#annex_tinymt32_validation">Appendix A</a> (for the mapping to 4-bit and 8-bit intervals).
Because of the way the mapping functions work, it is unlikely that an implementation that fulfills the first criterion fails to fulfill the two others.<a class="pilcrow" href="#section-3.5-12">¶</a></p>
</section>
</div>
<div id="CommonProc_coef_generation_func">
<section id="section-3.6">
        <h3 id="name-coding-coefficients-generat">
<a class="section-number selfRef" href="#section-3.6">3.6. </a><a class="section-name selfRef" href="#name-coding-coefficients-generat">Coding Coefficients Generation Function</a>
        </h3>
<p id="section-3.6-1">
   The coding coefficients used during the encoding process are
   generated at the RLC encoder by the generate_coding_coefficients()
   function each time a new repair symbol needs to be produced.

The fraction of coefficients that are nonzero (i.e., the density) is controlled by the DT (Density Threshold) parameter.
DT has values between 0 (the minimum value) and 15 (the maximum value), and the average probability of having a nonzero coefficient equals (DT + 1) / 16.
In particular, when DT equals 15 the function guaranties that all coefficients are nonzero (i.e., maximum density).<a class="pilcrow" href="#section-3.6-1">¶</a></p>
<p id="section-3.6-2">
These considerations apply to both the RLC over GF(2) and RLC over GF(2<sup>8</sup>), the only difference being the value of the m parameter.
With the RLC over GF(2) FEC scheme (<a class="xref" href="#ArbitraryFlows_RLC_GF_2">Section 5</a>), m is equal to 1.
With RLC over GF(2<sup>8</sup>) FEC scheme (<a class="xref" href="#ArbitraryFlows_RLC_GF_28">Section 4</a>), m is equal to 8.<a class="pilcrow" href="#section-3.6-2">¶</a></p>
<p id="section-3.6-3">
<a class="xref" href="#fig_coef_generation_func">Figure 3</a> shows the reference generate_coding_coefficients() implementation.
This is a C language implementation, written for C99 <span>[<a class="xref" href="#C99">C99</a>]</span>.<a class="pilcrow" href="#section-3.6-3">¶</a></p>
<span id="name-reference-implementation-of"></span><div id="fig_coef_generation_func">
<figure id="figure-3">
          <div id="section-3.6-4.1">
<pre class="sourcecode lang-c">&lt;CODE BEGINS&gt;
#include &lt;string.h&gt;

/*
 * Fills in the table of coding coefficients (of the right size)
 * provided with the appropriate number of coding coefficients to
 * use for the repair symbol key provided.
 *
 * (in) repair_key    key associated to this repair symbol. This
 *                    parameter is ignored (useless) if m=1 and dt=15
 * (in/out) cc_tab    pointer to a table of the right size to store
 *                    coding coefficients. All coefficients are
 *                    stored as bytes, regardless of the m parameter,
 *                    upon return of this function.
 * (in) cc_nb         number of entries in the cc_tab table. This
 *                    value is equal to the current encoding window
 *                    size.
 * (in) dt            integer between 0 and 15 (inclusive) that
 *                    controls the density. With value 15, all
 *                    coefficients are guaranteed to be nonzero
 *                    (i.e., equal to 1 with GF(2) and equal to a
 *                    value in {1,... 255} with GF(2^^8)), otherwise
 *                    a fraction of them will be 0.
 * (in) m             Finite Field GF(2^^m) parameter. In this
 *                    document only values 1 and 8 are considered.
 * (out)              returns 0 in case of success, an error code
 *                    different than 0 otherwise.
 */
int generate_coding_coefficients (uint16_t  repair_key,
                                  uint8_t*  cc_tab,
                                  uint16_t  cc_nb,
                                  uint8_t   dt,
                                  uint8_t   m)
{
    uint32_t      i;
    tinymt32_t    s;    /* PRNG internal state */

    if (dt &gt; 15) {
        return -1; /* error, bad dt parameter */
    }
    switch (m) {
    case 1:
        if (dt == 15) {
            /* all coefficients are 1 */
            memset(cc_tab, 1, cc_nb);
        } else {
            /* here coefficients are either 0 or 1 */
            tinymt32_init(&amp;s, repair_key);
            for (i = 0 ; i &lt; cc_nb ; i++) {
                cc_tab[i] = (tinymt32_rand16(&amp;s) &lt;= dt) ? 1 : 0;
            }
        }
        break;

    case 8:
        tinymt32_init(&amp;s, repair_key);
        if (dt == 15) {
            /* coefficient 0 is avoided here in order to include
             * all the source symbols */
            for (i = 0 ; i &lt; cc_nb ; i++) {
                do {
                    cc_tab[i] = (uint8_t) tinymt32_rand256(&amp;s);
                } while (cc_tab[i] == 0);
            }
        } else {
            /* here a certain number of coefficients should be 0 */
            for (i = 0 ; i &lt; cc_nb ; i++) {
                if (tinymt32_rand16(&amp;s) &lt;= dt) {
                    do {
                        cc_tab[i] = (uint8_t) tinymt32_rand256(&amp;s);
                    } while (cc_tab[i] == 0);
                } else {
                    cc_tab[i] = 0;
                }
            }
        }
        break;

    default:
        return -2; /* error, bad parameter m */
    }
    return 0; /* success */
}

&lt;CODE ENDS&gt;</pre>
</div>
<figcaption><a class="selfRef" href="#figure-3">Figure 3</a>:
<a class="selfRef" href="#name-reference-implementation-of">Reference Implementation of the Coding Coefficients Generation Function</a>
          </figcaption></figure>
</div>
</section>
</div>
<div id="CommonProc_gf_specificiation">
<section id="section-3.7">
        <h3 id="name-finite-field-operations">
<a class="section-number selfRef" href="#section-3.7">3.7. </a><a class="section-name selfRef" href="#name-finite-field-operations">Finite Field Operations</a>
        </h3>
<section id="section-3.7.1">
          <h4 id="name-finite-field-definitions">
<a class="section-number selfRef" href="#section-3.7.1">3.7.1. </a><a class="section-name selfRef" href="#name-finite-field-definitions">Finite Field Definitions</a>
          </h4>
<p id="section-3.7.1-1">
The two RLC FEC schemes specified in this document reuse the Finite Fields
defined in <span>[<a class="xref" href="#RFC5510">RFC5510</a>], <a class="relref" href="https://www.rfc-editor.org/rfc/rfc5510#section-8.1">Section 8.1</a></span>.
More specifically, the elements of the field GF(2<sup>m</sup>) are represented by polynomials with binary coefficients (i.e., over GF(2)) and degree lower or equal to m-1.
The addition between two elements is defined as the addition of binary polynomials in GF(2), which is equivalent to a bitwise XOR operation on the binary representation of these elements.<a class="pilcrow" href="#section-3.7.1-1">¶</a></p>
<p id="section-3.7.1-2">
With GF(2<sup>8</sup>), multiplication between two elements is the multiplication modulo a given irreducible polynomial of degree 8.
The following irreducible polynomial is used for GF(2<sup>8</sup>):<a class="pilcrow" href="#section-3.7.1-2">¶</a></p>
<ul class="ulEmpty">
<li class="ulEmpty" id="section-3.7.1-3.1">x<sup>8</sup> + x<sup>4</sup> + x<sup>3</sup> + x<sup>2</sup> + 1<a class="pilcrow" href="#section-3.7.1-3.1">¶</a>
</li>
</ul>
<p id="section-3.7.1-4">
With GF(2), multiplication corresponds to a logical AND operation.<a class="pilcrow" href="#section-3.7.1-4">¶</a></p>
</section>
<div id="CommonProc_linear_combination_computation">
<section id="section-3.7.2">
          <h4 id="name-linear-combination-of-sourc">
<a class="section-number selfRef" href="#section-3.7.2">3.7.2. </a><a class="section-name selfRef" href="#name-linear-combination-of-sourc">Linear Combination of Source Symbol Computation</a>
          </h4>
<p id="section-3.7.2-1">
The two RLC FEC schemes require the computation of a linear combination of source symbols, using the coding coefficients produced by the generate_coding_coefficients() function and stored in the cc_tab[] array.<a class="pilcrow" href="#section-3.7.2-1">¶</a></p>
<p id="section-3.7.2-2">
With the RLC over GF(2<sup>8</sup>) FEC scheme, a linear combination of the ew_size source symbol present in the encoding window, say src_0 to src_ew_size_1, in order to generate a repair symbol, is computed as follows.
For each byte of position i in each source and the repair symbol, where i belongs to [0; E-1], compute:<a class="pilcrow" href="#section-3.7.2-2">¶</a></p>
<div id="section-3.7.2-3">
<pre class="sourcecode lang-pseudocode">   repair[i] = cc_tab[0] * src_0[i] XOR cc_tab[1] * src_1[i] XOR ... 
   XOR cc_tab[ew_size - 1] * src_ew_size_1[i]
</pre><a class="pilcrow" href="#section-3.7.2-3">¶</a>
</div>
<p id="section-3.7.2-4">
where * is the multiplication over GF(2<sup>8</sup>).
In practice various optimizations need to be used in order to make this computation efficient (see in particular <span>[<a class="xref" href="#PGM13">PGM13</a>]</span>).<a class="pilcrow" href="#section-3.7.2-4">¶</a></p>
<p id="section-3.7.2-5">
With the RLC over GF(2) FEC scheme (binary case), a linear combination is computed as follows.
The repair symbol is the XOR sum of all the source symbols corresponding to a coding coefficient cc_tab[j] equal to 1 (i.e., the source symbols corresponding to zero coding coefficients are ignored).
The XOR sum of the byte of position i in each source is computed and stored in the corresponding byte of the repair symbol, where i belongs to [0; E-1].
In practice, the XOR sums will be computed several bytes at a time (e.g., on 64 bit words, or on arrays of 16 or more bytes when using SIMD CPU extensions).<a class="pilcrow" href="#section-3.7.2-5">¶</a></p>
<p id="section-3.7.2-6">
With both FEC schemes, the details of how to optimize the computation of these linear combinations are of high practical importance but out of scope of this document.<a class="pilcrow" href="#section-3.7.2-6">¶</a></p>
</section>
</div>
</section>
</div>
</section>
</div>
<div id="ArbitraryFlows_RLC_GF_28">
<section id="section-4">
      <h2 id="name-sliding-window-rlc-fec-sche">
<a class="section-number selfRef" href="#section-4">4. </a><a class="section-name selfRef" href="#name-sliding-window-rlc-fec-sche">Sliding Window RLC FEC Scheme over GF(2<sup>8</sup>) for Arbitrary Packet Flows</a>
      </h2>
<p id="section-4-1">
This fully-specified FEC scheme defines the Sliding Window Random Linear Codes (RLC) over GF(2<sup>8</sup>).<a class="pilcrow" href="#section-4-1">¶</a></p>
<div id="ArbitraryFlows_formatsAndCodes">
<section id="section-4.1">
        <h3 id="name-formats-and-codes">
<a class="section-number selfRef" href="#section-4.1">4.1. </a><a class="section-name selfRef" href="#name-formats-and-codes">Formats and Codes</a>
        </h3>
<section id="section-4.1.1">
          <h4 id="name-fec-framework-configuration">
<a class="section-number selfRef" href="#section-4.1.1">4.1.1. </a><a class="section-name selfRef" href="#name-fec-framework-configuration">FEC Framework Configuration Information</a>
          </h4>
<p id="section-4.1.1-1">
Following the guidelines of <span><a class="relref" href="https://www.rfc-editor.org/rfc/rfc6363#section-5.6">Section 5.6</a> of [<a class="xref" href="#RFC6363">RFC6363</a>]</span>, this section provides 
the FEC Framework Configuration Information (or FFCI).
This FCCI needs to be shared (e.g., using SDP) between the FECFRAME sender and receiver
instances in order to synchronize them.
It includes a FEC Encoding ID, mandatory for any FEC scheme specification, plus scheme-specific elements.<a class="pilcrow" href="#section-4.1.1-1">¶</a></p>
<section id="section-4.1.1.1">
            <h5 id="name-fec-encoding-id">
<a class="section-number selfRef" href="#section-4.1.1.1">4.1.1.1. </a><a class="section-name selfRef" href="#name-fec-encoding-id">FEC Encoding ID</a>
            </h5>
<dl class="dlParallel" id="section-4.1.1.1-1">
              <dt id="section-4.1.1.1-1.1">FEC Encoding ID:</dt>
<dd id="section-4.1.1.1-1.2">the value assigned to this fully specified FEC scheme <span class="bcp14">MUST</span> be 10,
 as assigned by IANA (<a class="xref" href="#iana">Section 9</a>).<a class="pilcrow" href="#section-4.1.1.1-1.2">¶</a>
</dd>
</dl>
<p id="section-4.1.1.1-2">
When SDP is used to communicate the FFCI, this FEC Encoding ID is carried in
the 'encoding-id' parameter.<a class="pilcrow" href="#section-4.1.1.1-2">¶</a></p>
</section>
<div id="ArbitraryFlows_fssi">
<section id="section-4.1.1.2">
            <h5 id="name-fec-scheme-specific-informa">
<a class="section-number selfRef" href="#section-4.1.1.2">4.1.1.2. </a><a class="section-name selfRef" href="#name-fec-scheme-specific-informa">FEC Scheme-Specific Information</a>
            </h5>
<p id="section-4.1.1.2-1">
The FEC Scheme-Specific Information (FSSI) includes elements that are specific to the present FEC scheme.
More precisely:<a class="pilcrow" href="#section-4.1.1.2-1">¶</a></p>
<dl class="dlParallel" id="section-4.1.1.2-2">
              <dt id="section-4.1.1.2-2.1">Encoding symbol size (E):</dt>
<dd id="section-4.1.1.2-2.2">
 a non-negative integer that indicates the size of each encoding symbol in bytes;<a class="pilcrow" href="#section-4.1.1.2-2.2">¶</a>
</dd>
<dt id="section-4.1.1.2-2.3">Window Size Ratio (WSR) parameter: </dt>
<dd id="section-4.1.1.2-2.4">
 a non-negative integer between 0 and 255 (both inclusive) used to initialize window sizes.
 A value of 0 indicates this parameter is not considered (e.g., a fixed encoding window size may be chosen).
 A value between 1 and 255 inclusive is required by certain of the parameter derivation techniques described in <a class="xref" href="#possible_param_derivation">Appendix C</a>;<a class="pilcrow" href="#section-4.1.1.2-2.4">¶</a>
</dd>
</dl>
<p id="section-4.1.1.2-3">
This element is required both by the sender (RLC encoder) and the receiver(s) (RLC decoder).<a class="pilcrow" href="#section-4.1.1.2-3">¶</a></p>
<p id="section-4.1.1.2-4">
When SDP is used to communicate the FFCI, this FEC Scheme-Specific Information is carried in
the 'fssi' parameter in textual representation as specified in <span>[<a class="xref" href="#RFC6364">RFC6364</a>]</span>.
For instance:<a class="pilcrow" href="#section-4.1.1.2-4">¶</a></p>
<div id="section-4.1.1.2-5">
<pre class="sourcecode lang-sdp">   fssi=E:1400,WSR:191
</pre><a class="pilcrow" href="#section-4.1.1.2-5">¶</a>
</div>
<p id="section-4.1.1.2-6">
In that case the name values "E" and "WSR" are used to convey the E and WSR parameters respectively.<a class="pilcrow" href="#section-4.1.1.2-6">¶</a></p>
<p id="section-4.1.1.2-7">
If another mechanism requires the FSSI to be carried as an opaque octet string, the encoding format consists
of the following three octets, where the E field is carried in "big-endian" or "network order" format, that is,
most significant byte first:<a class="pilcrow" href="#section-4.1.1.2-7">¶</a></p>
<dl class="dlParallel" id="section-4.1.1.2-8">
              <dt id="section-4.1.1.2-8.1"></dt>
<dd id="section-4.1.1.2-8.2"> Encoding symbol length (E): 16-bit field;<a class="pilcrow" href="#section-4.1.1.2-8.2">¶</a>
</dd>
<dt id="section-4.1.1.2-8.3"></dt>
<dd id="section-4.1.1.2-8.4"> Window Size Ratio Parameter (WSR): 8-bit field.<a class="pilcrow" href="#section-4.1.1.2-8.4">¶</a>
</dd>
</dl>
<p id="section-4.1.1.2-9">
These three octets can be communicated as such, or for instance, be subject to an additional Base64 encoding.<a class="pilcrow" href="#section-4.1.1.2-9">¶</a></p>
<span id="name-fssi-encoding-format"></span><div id="fig_ArbitraryFlows_fssi_binary">
<figure id="figure-4">
              <div class="artwork art-text alignLeft" id="section-4.1.1.2-10.1">
<pre> 0                   1                   2
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   Encoding Symbol Length (E)  |      WSR      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>
</div>
<figcaption><a class="selfRef" href="#figure-4">Figure 4</a>:
<a class="selfRef" href="#name-fssi-encoding-format">FSSI Encoding Format</a>
              </figcaption></figure>
</div>
</section>
</div>
</section>
<div id="ArbitraryFlows_src_fpi">
<section id="section-4.1.2">
          <h4 id="name-explicit-source-fec-payload">
<a class="section-number selfRef" href="#section-4.1.2">4.1.2. </a><a class="section-name selfRef" href="#name-explicit-source-fec-payload">Explicit Source FEC Payload ID</a>
          </h4>
<p id="section-4.1.2-1">
A FEC Source Packet <span class="bcp14">MUST</span> contain an Explicit Source FEC Payload ID that is appended to the
end of the packet as illustrated in <a class="xref" href="#fig_src_pkt_format">Figure 5</a>.<a class="pilcrow" href="#section-4.1.2-1">¶</a></p>
<span id="name-structure-of-an-fec-source-"></span><div id="fig_src_pkt_format">
<figure id="figure-5">
            <div class="artwork art-text alignLeft" id="section-4.1.2-2.1">
<pre>+--------------------------------+
|           IP Header            |
+--------------------------------+
|        Transport Header        |
+--------------------------------+
|              ADU               |
+--------------------------------+
| Explicit Source FEC Payload ID |
+--------------------------------+
</pre>
</div>
<figcaption><a class="selfRef" href="#figure-5">Figure 5</a>:
<a class="selfRef" href="#name-structure-of-an-fec-source-">Structure of an FEC Source Packet with the Explicit Source FEC Payload ID</a>
            </figcaption></figure>
</div>
<p id="section-4.1.2-3">
More precisely, the Explicit Source FEC Payload ID is composed of the following field,
carried in "big-endian" or "network order" format, that is, most significant byte first
(<a class="xref" href="#fig_src_fpi">Figure 6</a>):<a class="pilcrow" href="#section-4.1.2-3">¶</a></p>
<dl class="dlParallel" id="section-4.1.2-4">
            <dt id="section-4.1.2-4.1">Encoding Symbol ID (ESI) (32-bit field):</dt>
<dd id="section-4.1.2-4.2">
 this unsigned integer identifies the first source symbol of the ADUI corresponding to this FEC Source Packet.
 The ESI is incremented for each new source symbol, and after reaching the maximum value
 (2<sup>32</sup>-1), wrapping to zero occurs.<a class="pilcrow" href="#section-4.1.2-4.2">¶</a>
</dd>
</dl>
<span id="name-source-fec-payload-id-encod"></span><div id="fig_src_fpi">
<figure id="figure-6">
            <div class="artwork art-text alignLeft" id="section-4.1.2-5.1">
<pre> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                   Encoding Symbol ID (ESI)                    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>
</div>
<figcaption><a class="selfRef" href="#figure-6">Figure 6</a>:
<a class="selfRef" href="#name-source-fec-payload-id-encod">Source FEC Payload ID Encoding Format</a>
            </figcaption></figure>
</div>
</section>
</div>
<div id="ArbitraryFlows_repair_fpi">
<section id="section-4.1.3">
          <h4 id="name-repair-fec-payload-id">
<a class="section-number selfRef" href="#section-4.1.3">4.1.3. </a><a class="section-name selfRef" href="#name-repair-fec-payload-id">Repair FEC Payload ID</a>
          </h4>
<p id="section-4.1.3-1">
A FEC Repair Packet <span class="bcp14">MAY</span> contain one or more repair symbols.
When there are several repair symbols, all of them <span class="bcp14">MUST</span> have been generated from the same encoding window,
using Repair_Key values that are managed as explained below.
A receiver can easily deduce the number of repair symbols within a FEC Repair Packet by
comparing the received FEC Repair Packet size (equal to the UDP payload size when UDP is the underlying
transport protocol) and the symbol size, E, communicated in the FFCI.<a class="pilcrow" href="#section-4.1.3-1">¶</a></p>
<p id="section-4.1.3-2">
A FEC Repair Packet <span class="bcp14">MUST</span> contain a Repair FEC Payload ID that is prepended to the
repair symbol as illustrated in <a class="xref" href="#fig_repair_pkt_format">Figure 7</a>.<a class="pilcrow" href="#section-4.1.3-2">¶</a></p>
<span id="name-structure-of-an-fec-repair-"></span><div id="fig_repair_pkt_format">
<figure id="figure-7">
            <div class="artwork art-text alignLeft" id="section-4.1.3-3.1">
<pre>+--------------------------------+
|           IP Header            |
+--------------------------------+
|        Transport Header        |
+--------------------------------+
|     Repair FEC Payload ID      |
+--------------------------------+
|         Repair Symbol          |
+--------------------------------+
</pre>
</div>
<figcaption><a class="selfRef" href="#figure-7">Figure 7</a>:
<a class="selfRef" href="#name-structure-of-an-fec-repair-">Structure of an FEC Repair Packet with the Repair FEC Payload ID</a>
            </figcaption></figure>
</div>
<p id="section-4.1.3-4">
More precisely, the Repair FEC Payload ID is composed of the following fields where all integer fields are carried
in "big-endian" or "network order" format, that is, most significant byte first (<a class="xref" href="#fig_repair_fpi">Figure 8</a>):<a class="pilcrow" href="#section-4.1.3-4">¶</a></p>
<dl class="dlParallel" id="section-4.1.3-5">
            <dt id="section-4.1.3-5.1">Repair_Key (16-bit field):</dt>
<dd id="section-4.1.3-5.2">
 this unsigned integer is used as a seed by the coefficient generation function (<a class="xref" href="#CommonProc_coef_generation_func">Section 3.6</a>)
 in order to generate the desired number of coding coefficients.
 This repair key may be a monotonically increasing integer value that loops back to 0 after reaching 65535
 (see <a class="xref" href="#ArbitraryFlows_FECCodeSpecification_encoding">Section 6.1</a>).
 When a FEC Repair Packet contains several repair symbols, this repair key value is that of the first repair symbol.
 The remaining repair keys can be deduced by incrementing by 1 this value, up to a maximum value of 65535 after which it loops back to 0.<a class="pilcrow" href="#section-4.1.3-5.2">¶</a>
</dd>
<dt id="section-4.1.3-5.3">Density Threshold for the coding coefficients, DT (4-bit field):</dt>
<dd id="section-4.1.3-5.4">
 this unsigned integer carries the Density Threshold (DT) used by the coding coefficient generation function <a class="xref" href="#CommonProc_coef_generation_func">Section 3.6</a>.
 More precisely, it controls the probability of having a nonzero coding coefficient, which equals (DT+1) / 16.
 When a FEC Repair Packet contains several repair symbols, the DT value applies to all of them;<a class="pilcrow" href="#section-4.1.3-5.4">¶</a>
</dd>
<dt id="section-4.1.3-5.5">Number of Source Symbols in the encoding window, NSS (12-bit field):</dt>
<dd id="section-4.1.3-5.6">
 this unsigned integer indicates the number of source symbols in the encoding window when this repair symbol was generated.
 When a FEC Repair Packet contains several repair symbols, this NSS value applies to all of them;<a class="pilcrow" href="#section-4.1.3-5.6">¶</a>
</dd>
<dt id="section-4.1.3-5.7">ESI of First Source Symbol in the encoding window, FSS_ESI (32-bit field):</dt>
<dd id="section-4.1.3-5.8">
 this unsigned integer indicates the ESI of the first source symbol in the encoding window when this repair symbol was generated.
 When a FEC Repair Packet contains several repair symbols, this FSS_ESI value applies to all of them;<a class="pilcrow" href="#section-4.1.3-5.8">¶</a>
</dd>
</dl>
<span id="name-repair-fec-payload-id-encod"></span><div id="fig_repair_fpi">
<figure id="figure-8">
            <div class="artwork art-text alignLeft" id="section-4.1.3-6.1">
<pre> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|       Repair_Key              |  DT   |NSS (# src symb in ew) |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                            FSS_ESI                            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>
</div>
<figcaption><a class="selfRef" href="#figure-8">Figure 8</a>:
<a class="selfRef" href="#name-repair-fec-payload-id-encod">Repair FEC Payload ID Encoding Format</a>
            </figcaption></figure>
</div>
</section>
</div>
</section>
</div>
<div id="ArbitraryFlows_Procedures">
<section id="section-4.2">
        <h3 id="name-procedures">
<a class="section-number selfRef" href="#section-4.2">4.2. </a><a class="section-name selfRef" href="#name-procedures">Procedures</a>
        </h3>
<p id="section-4.2-1">
All the procedures of <a class="xref" href="#CommonProcedures">Section 3</a> apply to this FEC scheme.<a class="pilcrow" href="#section-4.2-1">¶</a></p>
</section>
</div>
</section>
</div>
<div id="ArbitraryFlows_RLC_GF_2">
<section id="section-5">
      <h2 id="name-sliding-window-rlc-fec-schem">
<a class="section-number selfRef" href="#section-5">5. </a><a class="section-name selfRef" href="#name-sliding-window-rlc-fec-schem">Sliding Window RLC FEC Scheme over GF(2) for Arbitrary Packet Flows</a>
      </h2>
<p id="section-5-1">
This fully-specified FEC scheme defines the Sliding Window Random Linear Codes (RLC) over GF(2) (binary case).<a class="pilcrow" href="#section-5-1">¶</a></p>
<section id="section-5.1">
        <h3 id="name-formats-and-codes-2">
<a class="section-number selfRef" href="#section-5.1">5.1. </a><a class="section-name selfRef" href="#name-formats-and-codes-2">Formats and Codes</a>
        </h3>
<section id="section-5.1.1">
          <h4 id="name-fec-framework-configuration-">
<a class="section-number selfRef" href="#section-5.1.1">5.1.1. </a><a class="section-name selfRef" href="#name-fec-framework-configuration-">FEC Framework Configuration Information</a>
          </h4>
<section id="section-5.1.1.1">
            <h5 id="name-fec-encoding-id-2">
<a class="section-number selfRef" href="#section-5.1.1.1">5.1.1.1. </a><a class="section-name selfRef" href="#name-fec-encoding-id-2">FEC Encoding ID</a>
            </h5>
<dl class="dlParallel" id="section-5.1.1.1-1">
              <dt id="section-5.1.1.1-1.1">FEC Encoding ID:</dt>
<dd id="section-5.1.1.1-1.2">the value assigned to this fully specified FEC scheme
 <span class="bcp14">MUST</span> be 9,
 as assigned by IANA (<a class="xref" href="#iana">Section 9</a>).<a class="pilcrow" href="#section-5.1.1.1-1.2">¶</a>
</dd>
</dl>
<p id="section-5.1.1.1-2">
When SDP is used to communicate the FFCI, this FEC Encoding ID is carried in
the 'encoding-id' parameter.<a class="pilcrow" href="#section-5.1.1.1-2">¶</a></p>
</section>
<section id="section-5.1.1.2">
            <h5 id="name-fec-scheme-specific-informat">
<a class="section-number selfRef" href="#section-5.1.1.2">5.1.1.2. </a><a class="section-name selfRef" href="#name-fec-scheme-specific-informat">FEC Scheme-Specific Information</a>
            </h5>
<p id="section-5.1.1.2-1">
All the considerations of <a class="xref" href="#ArbitraryFlows_fssi">Section 4.1.1.2</a> apply here.<a class="pilcrow" href="#section-5.1.1.2-1">¶</a></p>
</section>
</section>
<section id="section-5.1.2">
          <h4 id="name-explicit-source-fec-payload-">
<a class="section-number selfRef" href="#section-5.1.2">5.1.2. </a><a class="section-name selfRef" href="#name-explicit-source-fec-payload-">Explicit Source FEC Payload ID</a>
          </h4>
<p id="section-5.1.2-1">
All the considerations of <a class="xref" href="#ArbitraryFlows_src_fpi">Section 4.1.2</a> apply here.<a class="pilcrow" href="#section-5.1.2-1">¶</a></p>
</section>
<section id="section-5.1.3">
          <h4 id="name-repair-fec-payload-id-2">
<a class="section-number selfRef" href="#section-5.1.3">5.1.3. </a><a class="section-name selfRef" href="#name-repair-fec-payload-id-2">Repair FEC Payload ID</a>
          </h4>
<p id="section-5.1.3-1">
All the considerations of <a class="xref" href="#ArbitraryFlows_repair_fpi">Section 4.1.3</a> apply here, with the only exception that the Repair_Key field
is useless if DT = 15 (indeed, in that case all the coefficients are necessarily equal to 1 and the coefficient generation function does not use any PRNG).
When DT = 15 the  FECFRAME sender <span class="bcp14">MUST</span> set the Repair_Key field to zero on transmission and a receiver <span class="bcp14">MUST</span> ignore it on receipt.<a class="pilcrow" href="#section-5.1.3-1">¶</a></p>
</section>
</section>
<section id="section-5.2">
        <h3 id="name-procedures-2">
<a class="section-number selfRef" href="#section-5.2">5.2. </a><a class="section-name selfRef" href="#name-procedures-2">Procedures</a>
        </h3>
<p id="section-5.2-1">
All the procedures of <a class="xref" href="#CommonProcedures">Section 3</a> apply to this FEC scheme.<a class="pilcrow" href="#section-5.2-1">¶</a></p>
</section>
</section>
</div>
<div id="ArbitraryFlows_FECCodeSpecification">
<section id="section-6">
      <h2 id="name-fec-code-specification">
<a class="section-number selfRef" href="#section-6">6. </a><a class="section-name selfRef" href="#name-fec-code-specification">FEC Code Specification</a>
      </h2>
<div id="ArbitraryFlows_FECCodeSpecification_encoding">
<section id="section-6.1">
        <h3 id="name-encoding-side">
<a class="section-number selfRef" href="#section-6.1">6.1. </a><a class="section-name selfRef" href="#name-encoding-side">Encoding Side</a>
        </h3>
<p id="section-6.1-1">
This section provides a high level description of a Sliding Window RLC encoder.<a class="pilcrow" href="#section-6.1-1">¶</a></p>
<p id="section-6.1-2">
Whenever a new FEC Repair Packet is needed, the RLC encoder instance first gathers the ew_size source symbols currently in the sliding encoding window. 
Then it chooses a repair key, which can be a monotonically increasing integer value, incremented for each repair symbol up to a maximum
value of 65535 (as it is carried within a 16-bit field) after which it loops back to 0. 
This repair key is communicated to the coefficient generation function (<a class="xref" href="#CommonProc_coef_generation_func">Section 3.6</a>) in order to generate
ew_size coding coefficients.
Finally, the FECFRAME sender computes the repair symbol as a linear combination of the ew_size source symbols using the ew_size coding coefficients
(<a class="xref" href="#CommonProc_gf_specificiation">Section 3.7</a>).
When E is small and when there is an incentive to pack several repair symbols within the same FEC Repair Packet, the appropriate number of repair symbols
are computed.
In that case the repair key for each of them <span class="bcp14">MUST</span> be incremented by 1, keeping the same ew_size source symbols, since only the first repair key will
be carried in the Repair FEC Payload ID.
The FEC Repair Packet can then be passed to the transport layer for transmission.
The source versus repair FEC packet transmission order is out of scope of this document and several approaches exist that are implementation-specific.<a class="pilcrow" href="#section-6.1-2">¶</a></p>
<p id="section-6.1-3">
Other solutions are possible to select a repair key value when a new FEC Repair Packet is needed, for instance, by choosing a random integer between 0 and 65535.
However, selecting the same repair key as before (which may happen in case of a random process) is only meaningful if the encoding window has changed,
otherwise the same FEC Repair Packet will be generated.
In any case, choosing the repair key is entirely at the discretion of the sender, since it is communicated to the receiver(s) in each Repair FEC Payload ID. A receiver should not make any assumption on the way the repair key is managed.<a class="pilcrow" href="#section-6.1-3">¶</a></p>
</section>
</div>
<div id="ArbitraryFlows_FECCodeSpecification_decoding">
<section id="section-6.2">
        <h3 id="name-decoding-side">
<a class="section-number selfRef" href="#section-6.2">6.2. </a><a class="section-name selfRef" href="#name-decoding-side">Decoding Side</a>
        </h3>
<p id="section-6.2-1">
This section provides a high level description of a Sliding Window RLC decoder.<a class="pilcrow" href="#section-6.2-1">¶</a></p>
<p id="section-6.2-2">
A FECFRAME receiver needs to maintain a linear system whose variables are the received and lost source symbols.
Upon receiving a FEC Repair Packet, a receiver first extracts all the repair symbols it contains (in case several repair symbols are packed together).
For each repair symbol, when at least one of the corresponding source symbols it protects has been lost, the receiver adds an equation to the linear system
(or no equation if this repair packet does not change the linear system rank).
This equation of course re-uses the ew_size coding coefficients that are computed by the same coefficient generation function
(<a class="xref" href="#CommonProc_coef_generation_func">Section 3.6</a>), using the repair key and encoding window descriptions carried in the Repair FEC Payload ID.
Whenever possible (i.e., when a sub-system covering one or more lost source
symbols is of full rank), decoding is performed in order to recover lost
source symbols.  Gaussian elimination is one possible algorithm to solve this
linear system.  Each time an ADUI can be totally recovered, padding is removed
(thanks to the Length field, L, of the ADUI) and the ADU is assigned to the
corresponding application flow (thanks to the Flow ID field, F, of the ADUI).
This ADU is finally passed to the corresponding upper application.  Received
FEC Source Packets, containing an ADU, <span class="bcp14">MAY</span> be passed to the
application either immediately or after some time to guaranty an ordered
delivery to the application.  This document does not mandate any approach as
this is an operational and management decision.<a class="pilcrow" href="#section-6.2-2">¶</a></p>
<p id="section-6.2-3">
With real-time flows, a lost ADU that is decoded after the maximum latency or an ADU received after this delay has no value to the application.
This raises the question of deciding whether or not an ADU is late.
This decision <span class="bcp14">MAY</span> be taken within the FECFRAME receiver (e.g., using the decoding window, see <a class="xref" href="#CommonProc_rlcParameters">Section 3.1</a>)
or within the application (e.g., using RTP timestamps within the ADU).
Deciding which option to follow and whether or not to pass all ADUs, including those assumed late, to the application are operational decisions that depend
on the application and are therefore out of scope of this document.
Additionally, <a class="xref" href="#decodingBeyondMaxLatency">Appendix D</a> discusses a backward compatible optimization whereby late source symbols <span class="bcp14">MAY</span> still be used within
the FECFRAME receiver in order to improve transmission robustness.<a class="pilcrow" href="#section-6.2-3">¶</a></p>
</section>
</div>
</section>
</div>
<div id="SecurityConsiderations">
<section id="section-7">
      <h2 id="name-security-considerations">
<a class="section-number selfRef" href="#section-7">7. </a><a class="section-name selfRef" href="#name-security-considerations">Security Considerations</a>
      </h2>
<p id="section-7-1">
The FEC Framework document <span>[<a class="xref" href="#RFC6363">RFC6363</a>]</span> provides a fairly comprehensive
analysis of security considerations applicable to FEC schemes.
Therefore, the present section follows the security considerations section of
<span>[<a class="xref" href="#RFC6363">RFC6363</a>]</span> and only discusses specific topics.<a class="pilcrow" href="#section-7-1">¶</a></p>
<section id="section-7.1">
        <h3 id="name-attacks-against-the-data-fl">
<a class="section-number selfRef" href="#section-7.1">7.1. </a><a class="section-name selfRef" href="#name-attacks-against-the-data-fl">Attacks Against the Data Flow</a>
        </h3>
<section id="section-7.1.1">
          <h4 id="name-access-to-confidential-cont">
<a class="section-number selfRef" href="#section-7.1.1">7.1.1. </a><a class="section-name selfRef" href="#name-access-to-confidential-cont">Access to Confidential Content</a>
          </h4>
<p id="section-7.1.1-1">The Sliding Window RLC FEC scheme specified in this document does not change the
recommendations of <span>[<a class="xref" href="#RFC6363">RFC6363</a>]</span>.
To summarize, if confidentiality is a concern, it is <span class="bcp14">RECOMMENDED</span> that one of the
solutions mentioned in <span>[<a class="xref" href="#RFC6363">RFC6363</a>]</span> is used with special
considerations to the way this solution is applied (e.g., is encryption applied
before or after FEC protection, within the end system or in a middlebox), to the operational 
constraints (e.g., performing FEC decoding in a protected environment may be
complicated or even impossible) and to the threat model.<a class="pilcrow" href="#section-7.1.1-1">¶</a></p>
</section>
<div id="sec_content_corruption">
<section id="section-7.1.2">
          <h4 id="name-content-corruption">
<a class="section-number selfRef" href="#section-7.1.2">7.1.2. </a><a class="section-name selfRef" href="#name-content-corruption">Content Corruption</a>
          </h4>
<p id="section-7.1.2-1">The Sliding Window RLC FEC scheme specified in this document does not change the
recommendations of <span>[<a class="xref" href="#RFC6363">RFC6363</a>]</span>.
To summarize, it is <span class="bcp14">RECOMMENDED</span> that one of the solutions mentioned in
<span>[<a class="xref" href="#RFC6363">RFC6363</a>]</span> is used on both the FEC Source and Repair Packets.<a class="pilcrow" href="#section-7.1.2-1">¶</a></p>
</section>
</div>
</section>
<section id="section-7.2">
        <h3 id="name-attacks-against-the-fec-par">
<a class="section-number selfRef" href="#section-7.2">7.2. </a><a class="section-name selfRef" href="#name-attacks-against-the-fec-par">Attacks Against the FEC Parameters</a>
        </h3>
<p id="section-7.2-1">
The FEC scheme specified in this document defines parameters that
can be the basis of attacks.
More specifically, the following parameters of the FFCI may be modified
by an attacker who targets receivers (<a class="xref" href="#ArbitraryFlows_fssi">Section 4.1.1.2</a>):<a class="pilcrow" href="#section-7.2-1">¶</a></p>
<dl class="dlParallel" id="section-7.2-2">
          <dt id="section-7.2-2.1">FEC Encoding ID:</dt>
<dd id="section-7.2-2.2">changing this parameter leads a receiver to consider a different FEC scheme.
 The consequences are severe, the format of the Explicit Source FEC Payload ID
 and Repair FEC Payload ID of received packets will probably differ, leading to
 various malfunctions.
 Even if the original and modified FEC schemes share the same format, FEC decoding
 will either fail or lead to corrupted decoded symbols.
 This will happen if an attacker turns value 9 (i.e., RLC over GF(2)) to value 10 (RLC over GF(2<sup>8</sup>)),
 an additional consequence being a higher processing overhead at the receiver.
 In any case, the attack results in a form of Denial of Service (DoS) or corrupted content.<a class="pilcrow" href="#section-7.2-2.2">¶</a>
</dd>
<dt id="section-7.2-2.3">Encoding symbol length (E):</dt>
<dd id="section-7.2-2.4">setting this E parameter to a different value will confuse a receiver.
 If the size of a received FEC Repair Packet is no longer multiple of the modified E value,
 a receiver quickly detects a problem and <span class="bcp14">SHOULD</span> reject the packet.
 If the new E value is a sub-multiple of the original E value (e.g., half the original value),
 then receivers may not detect the problem immediately.
 For instance, a receiver may think that a received FEC Repair Packet contains more repair symbols
 (e.g., twice as many if E is reduced by half), leading to malfunctions whose nature depends on
 implementation details.
 Here also, the attack always results in a form of DoS or corrupted content.<a class="pilcrow" href="#section-7.2-2.4">¶</a>
</dd>
</dl>
<p id="section-7.2-3">
It is therefore <span class="bcp14">RECOMMENDED</span> that security measures be taken to
guarantee the FFCI integrity, as specified in <span>[<a class="xref" href="#RFC6363">RFC6363</a>]</span>.
How to achieve this depends on the way the FFCI is communicated from the sender
to the receiver, which is not specified in this document.<a class="pilcrow" href="#section-7.2-3">¶</a></p>
<p id="section-7.2-4">
Similarly, attacks are possible against the Explicit Source FEC Payload ID
and Repair FEC Payload ID.
More specifically, in case of a FEC Source Packet, the following value can be modified by an attacker who targets receivers:<a class="pilcrow" href="#section-7.2-4">¶</a></p>
<dl class="dlParallel" id="section-7.2-5">
          <dt id="section-7.2-5.1">Encoding Symbol ID (ESI):</dt>
<dd id="section-7.2-5.2">changing the ESI leads a receiver to consider a wrong ADU, resulting in severe consequences, including
 corrupted content passed to the receiving application;<a class="pilcrow" href="#section-7.2-5.2">¶</a>
</dd>
</dl>
<p id="section-7.2-6">
And in case of a FEC Repair Packet:<a class="pilcrow" href="#section-7.2-6">¶</a></p>
<dl class="dlParallel" id="section-7.2-7">
          <dt id="section-7.2-7.1">Repair Key:</dt>
<dd id="section-7.2-7.2">changing this value leads a receiver to generate a wrong coding coefficient sequence, and therefore
 any source symbol decoded using the repair symbols contained in this packet will be corrupted;<a class="pilcrow" href="#section-7.2-7.2">¶</a>
</dd>
<dt id="section-7.2-7.3">DT:</dt>
<dd id="section-7.2-7.4">changing this value also leads a receiver to generate a wrong coding coefficient sequence, and therefore
 any source symbol decoded using the repair symbols contained in this packet will be corrupted.
 In addition, if the DT value is significantly increased, it will generate a higher processing overhead at a receiver.
 In case of very large encoding windows, this may impact the terminal performance;<a class="pilcrow" href="#section-7.2-7.4">¶</a>
</dd>
<dt id="section-7.2-7.5">NSS:</dt>
<dd id="section-7.2-7.6">changing this value leads a receiver to consider a different set of source symbols, and therefore
 any source symbol decoded using the repair symbols contained in this packet will be corrupted.
 In addition, if the NSS value is significantly increased, it will generate a higher processing overhead at a receiver,
 which may impact the terminal performance;<a class="pilcrow" href="#section-7.2-7.6">¶</a>
</dd>
<dt id="section-7.2-7.7">FSS_ESI:</dt>
<dd id="section-7.2-7.8">changing this value also leads a receiver to consider a different set of source symbols and therefore
 any source symbol decoded using the repair symbols contained in this packet will be corrupted.<a class="pilcrow" href="#section-7.2-7.8">¶</a>
</dd>
</dl>
<p id="section-7.2-8">
It is therefore <span class="bcp14">RECOMMENDED</span> that security measures are taken to guarantee the
FEC Source and Repair Packets as stated in <span>[<a class="xref" href="#RFC6363">RFC6363</a>]</span>.<a class="pilcrow" href="#section-7.2-8">¶</a></p>
</section>
<section id="section-7.3">
        <h3 id="name-when-several-source-flows-a">
<a class="section-number selfRef" href="#section-7.3">7.3. </a><a class="section-name selfRef" href="#name-when-several-source-flows-a">When Several Source Flows are to be Protected Together</a>
        </h3>
<p id="section-7.3-1">The Sliding Window RLC FEC scheme specified in this document does not change the
recommendations of <span>[<a class="xref" href="#RFC6363">RFC6363</a>]</span>.<a class="pilcrow" href="#section-7.3-1">¶</a></p>
</section>
<section id="section-7.4">
        <h3 id="name-baseline-secure-fec-framewo">
<a class="section-number selfRef" href="#section-7.4">7.4. </a><a class="section-name selfRef" href="#name-baseline-secure-fec-framewo">Baseline Secure FEC Framework Operation</a>
        </h3>
<p id="section-7.4-1">The Sliding Window RLC FEC scheme specified in this document does not change the
recommendations of <span>[<a class="xref" href="#RFC6363">RFC6363</a>]</span> concerning the use of
the IPsec/Encapsulating Security Payload (ESP) security protocol as a mandatory-to-implement (but not mandatory-to-use) security scheme.
This is well suited to situations where the only insecure domain is the one
over which the FEC Framework operates.<a class="pilcrow" href="#section-7.4-1">¶</a></p>
</section>
<section id="section-7.5">
        <h3 id="name-additional-security-conside">
<a class="section-number selfRef" href="#section-7.5">7.5. </a><a class="section-name selfRef" href="#name-additional-security-conside">Additional Security Considerations for Numerical Computations</a>
        </h3>
<p id="section-7.5-1">
In addition to the above security considerations, inherited from <span>[<a class="xref" href="#RFC6363">RFC6363</a>]</span>, 
the present document introduces several formulae, in particular in <a class="xref" href="#param_derivation_cbr_realtime">Appendix C.1</a>.
It is <span class="bcp14">RECOMMENDED</span> to check that the computed values stay within reasonable bounds since numerical overflows,
caused by an erroneous implementation or an erroneous input value, may lead to hazardous behaviors.
However, what "reasonable bounds" means is use-case and implementation dependent and is not detailed in this document.<a class="pilcrow" href="#section-7.5-1">¶</a></p>
<p id="section-7.5-2">
<a class="xref" href="#param_derivation_other_realtime_flows">Appendix C.2</a> also mentions the possibility of "using the
timestamp field of an RTP packet header" when applicable.
A malicious attacker may deliberately corrupt this header field in order to trigger hazardous behaviors at a FECFRAME receiver.
Protection against this type of content corruption can be addressed with the above recommendations on a baseline secure operation.
In addition, it is also <span class="bcp14">RECOMMENDED</span> to check that the timestamp value be within reasonable bounds.<a class="pilcrow" href="#section-7.5-2">¶</a></p>
</section>
</section>
</div>
<section id="section-8">
      <h2 id="name-operations-and-management-c">
<a class="section-number selfRef" href="#section-8">8. </a><a class="section-name selfRef" href="#name-operations-and-management-c">Operations and Management Considerations</a>
      </h2>
<p id="section-8-1">
The FEC Framework document <span>[<a class="xref" href="#RFC6363">RFC6363</a>]</span> provides a fairly comprehensive
analysis of operations and management considerations applicable to FEC schemes.
Therefore, the present section only discusses specific topics.<a class="pilcrow" href="#section-8-1">¶</a></p>
<div id="oprecom_ff_considerations">
<section id="section-8.1">
        <h3 id="name-operational-recommendations">
<a class="section-number selfRef" href="#section-8.1">8.1. </a><a class="section-name selfRef" href="#name-operational-recommendations">Operational Recommendations: Finite Field GF(2) Versus GF(2<sup>8</sup>)</a>
        </h3>
<p id="section-8.1-1">
The present document specifies two FEC schemes that differ on the Finite Field used for the coding coefficients.
It is expected that the RLC over GF(2<sup>8</sup>) FEC scheme will be mostly used since it warrants a higher packet loss protection.
In case of small encoding windows, the associated processing overhead is not an issue (e.g., we measured decoding speeds between
745 Mbps and 2.8 Gbps on an ARM Cortex-A15 embedded board in <span>[<a class="xref" href="#Roca17">Roca17</a>]</span> depending on the code rate and the channel conditions, using an encoding window of size 18 or 23 symbols; see the above article for the details).
Of course the CPU overhead will increase with the encoding window size, because more operations in the GF(2<sup>8</sup>) finite field will
be needed.<a class="pilcrow" href="#section-8.1-1">¶</a></p>
<p id="section-8.1-2">
The RLC over GF(2) FEC scheme offers an alternative.
In that case operations symbols can be directly XOR-ed together which warrants high bitrate encoding and decoding operations, and
can be an advantage with large encoding windows.
However, packet loss protection is significantly reduced by using this FEC scheme.<a class="pilcrow" href="#section-8.1-2">¶</a></p>
</section>
</div>
<section id="section-8.2">
        <h3 id="name-operational-recommendations-">
<a class="section-number selfRef" href="#section-8.2">8.2. </a><a class="section-name selfRef" href="#name-operational-recommendations-">Operational Recommendations: Coding Coefficients Density Threshold</a>
        </h3>
<p id="section-8.2-1"> 
In addition to the choice of the Finite Field, the two FEC schemes define a coding coefficient density threshold (DT) parameter.
This parameter enables a sender to control the code density, i.e., the proportion of coefficients that are nonzero on average.
With RLC over GF(2<sup>8</sup>), it is usually appropriate that small encoding windows be associated to a density threshold equal to 15,
the maximum value, in order to warrant a high loss protection.<a class="pilcrow" href="#section-8.2-1">¶</a></p>
<p id="section-8.2-2">
On the opposite, with larger encoding windows, it is usually appropriate that the density threshold be reduced.
With large encoding windows, an alternative can be to use RLC over GF(2) and a density threshold equal to 7 (i.e., an average density equal to 1/2) or smaller.<a class="pilcrow" href="#section-8.2-2">¶</a></p>
<p id="section-8.2-3">
Note that using a density threshold equal to 15 with RLC over GF(2) is equivalent to using an XOR code that computes the XOR sum of all the source symbols in the encoding window.
In that case: (1) only a single repair symbol can be produced for any encoding window, and (2) the repair_key parameter becomes useless (the coding coefficients generation function does not rely on the PRNG).<a class="pilcrow" href="#section-8.2-3">¶</a></p>
</section>
</section>
<div id="iana">
<section id="section-9">
      <h2 id="name-iana-considerations">
<a class="section-number selfRef" href="#section-9">9. </a><a class="section-name selfRef" href="#name-iana-considerations">IANA Considerations</a>
      </h2>
<p id="section-9-1">
This document registers two values in the "FEC Framework (FECFRAME)
FEC Encoding IDs" registry <span>[<a class="xref" href="#RFC6363">RFC6363</a>]</span> as follows:<a class="pilcrow" href="#section-9-1">¶</a></p>
<ul>
<li id="section-9-2.1">9 refers to the Sliding Window Random Linear Codes (RLC) over GF(2) FEC Scheme for Arbitrary Packet Flows, as defined in <a class="xref" href="#ArbitraryFlows_RLC_GF_2">Section 5</a> of this document.<a class="pilcrow" href="#section-9-2.1">¶</a>
</li>
<li id="section-9-2.2">10 refers to the Sliding Window Random Linear Codes (RLC) over GF(2<sup>8</sup>) FEC Scheme for Arbitrary Packet Flows, as defined in <a class="xref" href="#ArbitraryFlows_RLC_GF_28">Section 4</a> of this document.<a class="pilcrow" href="#section-9-2.2">¶</a>
</li>
</ul>
</section>
</div>
<section id="section-10">
      <h2 id="name-references">
<a class="section-number selfRef" href="#section-10">10. </a><a class="section-name selfRef" href="#name-references">References</a>
      </h2>
<section id="section-10.1">
        <h3 id="name-normative-references">
<a class="section-number selfRef" href="#section-10.1">10.1. </a><a class="section-name selfRef" href="#name-normative-references">Normative References</a>
        </h3>
<dl class="references">
<dt id="C99">[C99]</dt>
<dd>
<span class="refAuthor">International Organization for Standardization</span>, <span class="refTitle">"Programming languages - C: C99, correction 3:2007"</span>, <span class="seriesInfo">ISO/IEC 9899:1999/Cor 3:2007</span>, <time datetime="2007-11">November 2007</time>. </dd>
<dt id="RFC2119">[RFC2119]</dt>
<dd>
<span class="refAuthor">Bradner, S.</span>, <span class="refTitle">"Key words for use in RFCs to Indicate Requirement Levels"</span>, <span class="seriesInfo">BCP 14</span>, <span class="seriesInfo">RFC 2119</span>, <span class="seriesInfo">DOI 10.17487/RFC2119</span>, <time datetime="1997-03">March 1997</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc2119">https://www.rfc-editor.org/info/rfc2119</a>&gt;</span>. </dd>
<dt id="RFC6363">[RFC6363]</dt>
<dd>
<span class="refAuthor">Watson, M.</span><span class="refAuthor">, Begen, A.</span><span class="refAuthor">, and V. Roca</span>, <span class="refTitle">"Forward Error Correction (FEC) Framework"</span>, <span class="seriesInfo">RFC 6363</span>, <span class="seriesInfo">DOI 10.17487/RFC6363</span>, <time datetime="2011-10">October 2011</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc6363">https://www.rfc-editor.org/info/rfc6363</a>&gt;</span>. </dd>
<dt id="RFC6364">[RFC6364]</dt>
<dd>
<span class="refAuthor">Begen, A.</span>, <span class="refTitle">"Session Description Protocol Elements for the Forward Error Correction (FEC) Framework"</span>, <span class="seriesInfo">RFC 6364</span>, <span class="seriesInfo">DOI 10.17487/RFC6364</span>, <time datetime="2011-10">October 2011</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc6364">https://www.rfc-editor.org/info/rfc6364</a>&gt;</span>. </dd>
<dt id="RFC8174">[RFC8174]</dt>
<dd>
<span class="refAuthor">Leiba, B.</span>, <span class="refTitle">"Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words"</span>, <span class="seriesInfo">BCP 14</span>, <span class="seriesInfo">RFC 8174</span>, <span class="seriesInfo">DOI 10.17487/RFC8174</span>, <time datetime="2017-05">May 2017</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc8174">https://www.rfc-editor.org/info/rfc8174</a>&gt;</span>. </dd>
<dt id="RFC8680">[RFC8680]</dt>
<dd>
<span class="refAuthor">Roca, V.</span><span class="refAuthor"> and A. Begen</span>, <span class="refTitle">"Forward Error Correction (FEC) Framework Extension to Sliding Window Codes"</span>, <span class="seriesInfo">RFC 8680</span>, <span class="seriesInfo">DOI 10.17487/RFC8680</span>, <time datetime="2020-01">January 2020</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc8680">https://www.rfc-editor.org/info/rfc8680</a>&gt;</span>. </dd>
<dt id="RFC8682">[RFC8682]</dt>
<dd>
<span class="refAuthor">Saito, M.</span><span class="refAuthor">, Matsumoto, M.</span><span class="refAuthor">, Roca, V., Ed.</span><span class="refAuthor">, and E. Baccelli</span>, <span class="refTitle">"TinyMT32 Pseudorandom Number Generator (PRNG)"</span>, <span class="seriesInfo">RFC 8682</span>, <span class="seriesInfo">DOI 10.17487/RFC8682</span>, <time datetime="2020-01">January 2020</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc8682">https://www.rfc-editor.org/info/rfc8682</a>&gt;</span>. </dd>
</dl>
</section>
<section id="section-10.2">
        <h3 id="name-informative-references">
<a class="section-number selfRef" href="#section-10.2">10.2. </a><a class="section-name selfRef" href="#name-informative-references">Informative References</a>
        </h3>
<dl class="references">
<dt id="PGM13">[PGM13]</dt>
<dd>
<span class="refAuthor">Plank, J.</span><span class="refAuthor">, Greenan, K.</span><span class="refAuthor">, and E. Miller</span>, <span class="refTitle">"A Complete Treatment of Software Implementations of Finite Field Arithmetic for Erasure Coding Applications"</span>, <span class="seriesInfo">University of Tennessee Technical Report UT-CS-13-717</span>, <time datetime="2013-10">October 2013</time>, <span>&lt;<a href="http://web.eecs.utk.edu/~plank/plank/papers/UT-CS-13-717.html">http://web.eecs.utk.edu/~plank/plank/papers/UT-CS-13-717.html</a>&gt;</span>. </dd>
<dt id="RFC5170">[RFC5170]</dt>
<dd>
<span class="refAuthor">Roca, V.</span><span class="refAuthor">, Neumann, C.</span><span class="refAuthor">, and D. Furodet</span>, <span class="refTitle">"Low Density Parity Check (LDPC) Staircase and Triangle Forward Error Correction (FEC) Schemes"</span>, <span class="seriesInfo">RFC 5170</span>, <span class="seriesInfo">DOI 10.17487/RFC5170</span>, <time datetime="2008-06">June 2008</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc5170">https://www.rfc-editor.org/info/rfc5170</a>&gt;</span>. </dd>
<dt id="RFC5510">[RFC5510]</dt>
<dd>
<span class="refAuthor">Lacan, J.</span><span class="refAuthor">, Roca, V.</span><span class="refAuthor">, Peltotalo, J.</span><span class="refAuthor">, and S. Peltotalo</span>, <span class="refTitle">"Reed-Solomon Forward Error Correction (FEC) Schemes"</span>, <span class="seriesInfo">RFC 5510</span>, <span class="seriesInfo">DOI 10.17487/RFC5510</span>, <time datetime="2009-04">April 2009</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc5510">https://www.rfc-editor.org/info/rfc5510</a>&gt;</span>. </dd>
<dt id="RFC6681">[RFC6681]</dt>
<dd>
<span class="refAuthor">Watson, M.</span><span class="refAuthor">, Stockhammer, T.</span><span class="refAuthor">, and M. Luby</span>, <span class="refTitle">"Raptor Forward Error Correction (FEC) Schemes for FECFRAME"</span>, <span class="seriesInfo">RFC 6681</span>, <span class="seriesInfo">DOI 10.17487/RFC6681</span>, <time datetime="2012-08">August 2012</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc6681">https://www.rfc-editor.org/info/rfc6681</a>&gt;</span>. </dd>
<dt id="RFC6726">[RFC6726]</dt>
<dd>
<span class="refAuthor">Paila, T.</span><span class="refAuthor">, Walsh, R.</span><span class="refAuthor">, Luby, M.</span><span class="refAuthor">, Roca, V.</span><span class="refAuthor">, and R. Lehtonen</span>, <span class="refTitle">"FLUTE - File Delivery over Unidirectional Transport"</span>, <span class="seriesInfo">RFC 6726</span>, <span class="seriesInfo">DOI 10.17487/RFC6726</span>, <time datetime="2012-11">November 2012</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc6726">https://www.rfc-editor.org/info/rfc6726</a>&gt;</span>. </dd>
<dt id="RFC6816">[RFC6816]</dt>
<dd>
<span class="refAuthor">Roca, V.</span><span class="refAuthor">, Cunche, M.</span><span class="refAuthor">, and J. Lacan</span>, <span class="refTitle">"Simple Low-Density Parity Check (LDPC) Staircase Forward Error Correction (FEC) Scheme for FECFRAME"</span>, <span class="seriesInfo">RFC 6816</span>, <span class="seriesInfo">DOI 10.17487/RFC6816</span>, <time datetime="2012-12">December 2012</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc6816">https://www.rfc-editor.org/info/rfc6816</a>&gt;</span>. </dd>
<dt id="RFC6865">[RFC6865]</dt>
<dd>
<span class="refAuthor">Roca, V.</span><span class="refAuthor">, Cunche, M.</span><span class="refAuthor">, Lacan, J.</span><span class="refAuthor">, Bouabdallah, A.</span><span class="refAuthor">, and K. Matsuzono</span>, <span class="refTitle">"Simple Reed-Solomon Forward Error Correction (FEC) Scheme for FECFRAME"</span>, <span class="seriesInfo">RFC 6865</span>, <span class="seriesInfo">DOI 10.17487/RFC6865</span>, <time datetime="2013-02">February 2013</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc6865">https://www.rfc-editor.org/info/rfc6865</a>&gt;</span>. </dd>
<dt id="RFC8406">[RFC8406]</dt>
<dd>
<span class="refAuthor">Adamson, B.</span><span class="refAuthor">, Adjih, C.</span><span class="refAuthor">, Bilbao, J.</span><span class="refAuthor">, Firoiu, V.</span><span class="refAuthor">, Fitzek, F.</span><span class="refAuthor">, Ghanem, S.</span><span class="refAuthor">, Lochin, E.</span><span class="refAuthor">, Masucci, A.</span><span class="refAuthor">, Montpetit, M-J.</span><span class="refAuthor">, Pedersen, M.</span><span class="refAuthor">, Peralta, G.</span><span class="refAuthor">, Roca, V., Ed.</span><span class="refAuthor">, Saxena, P.</span><span class="refAuthor">, and S. Sivakumar</span>, <span class="refTitle">"Taxonomy of Coding Techniques for Efficient Network Communications"</span>, <span class="seriesInfo">RFC 8406</span>, <span class="seriesInfo">DOI 10.17487/RFC8406</span>, <time datetime="2018-06">June 2018</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc8406">https://www.rfc-editor.org/info/rfc8406</a>&gt;</span>. </dd>
<dt id="Roca16">[Roca16]</dt>
<dd>
<span class="refAuthor">Roca, V.</span><span class="refAuthor">, Teibi, B.</span><span class="refAuthor">, Burdinat, C.</span><span class="refAuthor">, Tran-Thai, T.</span><span class="refAuthor">, and C. Thienot</span>, <span class="refTitle">"Block or Convolutional AL-FEC Codes? A Performance Comparison for Robust Low-Latency Communications"</span>, <span class="seriesInfo">HAL ID hal-01395937v2</span>, <time datetime="2017-02">February 2017</time>, <span>&lt;<a href="https://hal.inria.fr/hal-01395937/en/">https://hal.inria.fr/hal-01395937/en/</a>&gt;</span>. </dd>
<dt id="Roca17">[Roca17]</dt>
<dd>
<span class="refAuthor">Roca, V.</span><span class="refAuthor">, Teibi, B.</span><span class="refAuthor">, Burdinat, C.</span><span class="refAuthor">, Tran, T.</span><span class="refAuthor">, and C. Thienot</span>, <span class="refTitle">"Less Latency and Better Protection with AL-FEC Sliding Window Codes: a Robust Multimedia CBR Broadcast Case Study"</span>, <span class="refContent">13th IEEE International Conference on Wireless and                   
            Mobile Computing, Networking and Communications (WiMob17)</span>, <span class="seriesInfo">HAL ID hal-01571609</span>, <time datetime="2017-10">October 2017</time>, <span>&lt;<a href="https://hal.inria.fr/hal-01571609v1/en/">https://hal.inria.fr/hal-01571609v1/en/</a>&gt;</span>. </dd>
</dl>
</section>
</section>
<div id="annex_tinymt32_validation">
<section id="section-appendix.a">
      <h2 id="name-tinymt32-validation-criteri">
<a class="section-number selfRef" href="#section-appendix.a">Appendix A. </a><a class="section-name selfRef" href="#name-tinymt32-validation-criteri">TinyMT32 Validation Criteria (Normative)</a>
      </h2>
<p id="section-appendix.a-1">
PRNG determinism, for a given seed, is a requirement.
Consequently, in order to validate an implementation of the TinyMT32 PRNG, the following criteria <span class="bcp14">MUST</span> be met.<a class="pilcrow" href="#section-appendix.a-1">¶</a></p>
<p id="section-appendix.a-2">
The first criterion focuses on the tinymt32_rand256(), where the 32-bit integer of the core TinyMT32 PRNG is scaled down to an 8-bit integer.
Using a seed value of 1, the first 50 values returned by: tinymt32_rand256() as 8-bit unsigned integers
<span class="bcp14">MUST</span> be equal to values provided in <a class="xref" href="#fig_tinymt32_out_truncated_256">Figure 9</a>, to be read line by line.<a class="pilcrow" href="#section-appendix.a-2">¶</a></p>
<span id="name-first-50-decimal-values-to-"></span><div id="fig_tinymt32_out_truncated_256">
<figure id="figure-9">
        <div class="artwork art-text alignLeft" id="section-appendix.a-3.1">
<pre>        37        225        177        176         21
       246         54        139        168        237
       211        187         62        190        104
       135        210         99        176         11
       207         35         40        113        179
       214        254        101        212        211
       226         41        234        232        203
        29        194        211        112        107
       217        104        197        135         23
        89        210        252        109        166
</pre>
</div>
<figcaption><a class="selfRef" href="#figure-9">Figure 9</a>:
<a class="selfRef" href="#name-first-50-decimal-values-to-">First 50 decimal values (to be read per line) returned by tinymt32_rand256() as 8-bit unsigned integers, with a seed value of 1</a>
        </figcaption></figure>
</div>
<p id="section-appendix.a-4">
The second criterion focuses on the tinymt32_rand16(), where the 32-bit integer of the core TinyMT32 PRNG is scaled down to a 4-bit integer.
Using a seed value of 1, the first 50 values returned by: tinymt32_rand16() as 4-bit unsigned integers
<span class="bcp14">MUST</span> be equal to values provided in <a class="xref" href="#fig_tinymt32_out_truncated_16">Figure 10</a>, to be read line by line.<a class="pilcrow" href="#section-appendix.a-4">¶</a></p>
<span id="name-first-50-decimal-values-to-b"></span><div id="fig_tinymt32_out_truncated_16">
<figure id="figure-10">
        <div class="artwork art-text alignLeft" id="section-appendix.a-5.1">
<pre>         5          1          1          0          5
         6          6         11          8         13
         3         11         14         14          8
         7          2          3          0         11
        15          3          8          1          3
         6         14          5          4          3
         2          9         10          8         11
        13          2          3          0         11
         9          8          5          7          7
         9          2         12         13          6
</pre>
</div>
<figcaption><a class="selfRef" href="#figure-10">Figure 10</a>:
<a class="selfRef" href="#name-first-50-decimal-values-to-b">First 50 decimal values (to be read per line) returned by tinymt32_rand16() as 4-bit unsigned integers, with a seed value of 1</a>
        </figcaption></figure>
</div>
</section>
</div>
<div id="annex_assessing_prng">
<section id="section-appendix.b">
      <h2 id="name-assessing-the-prng-adequacy">
<a class="section-number selfRef" href="#section-appendix.b">Appendix B. </a><a class="section-name selfRef" href="#name-assessing-the-prng-adequacy">Assessing the PRNG Adequacy (Informational)</a>
      </h2>
<p id="section-appendix.b-1">
This annex discusses the adequacy of the TinyMT32 PRNG and the tinymt32_rand16() and tinymt32_rand256() functions, to the RLC FEC schemes.
The goal is to assess the adequacy of these two functions in producing coding coefficients that are sufficiently different from one another, across various repair symbols with repair key values in sequence (we can expect this approach to be commonly used by implementers, see <a class="xref" href="#ArbitraryFlows_FECCodeSpecification_encoding">Section 6.1</a>).
This section is purely informational and does not claim to be a solid evaluation.<a class="pilcrow" href="#section-appendix.b-1">¶</a></p>
<p id="section-appendix.b-2">
The two RLC FEC schemes use the PRNG to produce pseudorandom coding coefficients (<a class="xref" href="#CommonProc_coef_generation_func">Section 3.6</a>), each time a new repair symbol is needed.
A different repair key is used for each repair symbol, usually by incrementing the repair key value (<a class="xref" href="#ArbitraryFlows_FECCodeSpecification_encoding">Section 6.1</a>).
For each repair symbol, a limited number of pseudorandom numbers is needed, depending on the DT and encoding window size (<a class="xref" href="#CommonProc_coef_generation_func">Section 3.6</a>), using either tinymt32_rand16() or tinymt32_rand256().
Therefore, we are more interested in the randomness of small sequences of random numbers mapped to 4-bit or 8-bit integers, than in the randomness of a very large sequence of random numbers which is not representative of the usage of the PRNG.<a class="pilcrow" href="#section-appendix.b-2">¶</a></p>
<p id="section-appendix.b-3">
Evaluation of tinymt32_rand16():
We first generate a huge number (1,000,000,000) of small sequences (20 pseudorandom numbers per sequence), increasing the seed value for each sequence, and perform statistics on the number of occurrences of each of the 16 possible values across all sequences.
In this first test we consider 32-bit seed values in order to assess the PRNG quality after output truncation to 4 bits.<a class="pilcrow" href="#section-appendix.b-3">¶</a></p>
<span id="name-tinymt32_rand16-occurrence-"></span><div id="table_tinymt32_out_truncated_16_huge_nb_small_seq">
<table class="center" id="table-1">
        <caption>
<a class="selfRef" href="#table-1">Table 1</a>:
<a class="selfRef" href="#name-tinymt32_rand16-occurrence-">tinymt32_rand16() Occurrence Statistics</a>
        </caption>
<thead>
          <tr>
            <th class="text-left" colspan="1" rowspan="1">Value</th>
            <th class="text-left" colspan="1" rowspan="1"> Occurrences</th>
            <th class="text-left" colspan="1" rowspan="1">Percentage (%)</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td class="text-left" colspan="1" rowspan="1">0</td>
            <td class="text-left" colspan="1" rowspan="1">1250036799</td>
            <td class="text-left" colspan="1" rowspan="1">6.2502</td>
          </tr>
          <tr>
            <td class="text-left" colspan="1" rowspan="1">1</td>
            <td class="text-left" colspan="1" rowspan="1">1249995831</td>
            <td class="text-left" colspan="1" rowspan="1">6.2500</td>
          </tr>
          <tr>
            <td class="text-left" colspan="1" rowspan="1">2</td>
            <td class="text-left" colspan="1" rowspan="1">1250038674</td>
            <td class="text-left" colspan="1" rowspan="1">6.2502</td>
          </tr>
          <tr>
            <td class="text-left" colspan="1" rowspan="1">3</td>
            <td class="text-left" colspan="1" rowspan="1">1250000881</td>
            <td class="text-left" colspan="1" rowspan="1">6.2500</td>
          </tr>
          <tr>
            <td class="text-left" colspan="1" rowspan="1">4</td>
            <td class="text-left" colspan="1" rowspan="1">1250023929</td>
            <td class="text-left" colspan="1" rowspan="1">6.2501</td>
          </tr>
          <tr>
            <td class="text-left" colspan="1" rowspan="1">5</td>
            <td class="text-left" colspan="1" rowspan="1">1249986320</td>
            <td class="text-left" colspan="1" rowspan="1">6.2499</td>
          </tr>
          <tr>
            <td class="text-left" colspan="1" rowspan="1">6</td>
            <td class="text-left" colspan="1" rowspan="1">1249995587</td>
            <td class="text-left" colspan="1" rowspan="1">6.2500</td>
          </tr>
          <tr>
            <td class="text-left" colspan="1" rowspan="1">7</td>
            <td class="text-left" colspan="1" rowspan="1">1250020363</td>
            <td class="text-left" colspan="1" rowspan="1">6.2501</td>
          </tr>
          <tr>
            <td class="text-left" colspan="1" rowspan="1">8</td>
            <td class="text-left" colspan="1" rowspan="1">1249995276</td>
            <td class="text-left" colspan="1" rowspan="1">6.2500</td>
          </tr>
          <tr>
            <td class="text-left" colspan="1" rowspan="1">9</td>
            <td class="text-left" colspan="1" rowspan="1">1249982856</td>
            <td class="text-left" colspan="1" rowspan="1">6.2499</td>
          </tr>
          <tr>
            <td class="text-left" colspan="1" rowspan="1">10</td>
            <td class="text-left" colspan="1" rowspan="1">1249984111</td>
            <td class="text-left" colspan="1" rowspan="1">6.2499</td>
          </tr>
          <tr>
            <td class="text-left" colspan="1" rowspan="1">11</td>
            <td class="text-left" colspan="1" rowspan="1">1250009551</td>
            <td class="text-left" colspan="1" rowspan="1">6.2500</td>
          </tr>
          <tr>
            <td class="text-left" colspan="1" rowspan="1">12</td>
            <td class="text-left" colspan="1" rowspan="1">1249955768</td>
            <td class="text-left" colspan="1" rowspan="1">6.2498</td>
          </tr>
          <tr>
            <td class="text-left" colspan="1" rowspan="1">13</td>
            <td class="text-left" colspan="1" rowspan="1">1249994654</td>
            <td class="text-left" colspan="1" rowspan="1">6.2500</td>
          </tr>
          <tr>
            <td class="text-left" colspan="1" rowspan="1">14</td>
            <td class="text-left" colspan="1" rowspan="1">1250000569</td>
            <td class="text-left" colspan="1" rowspan="1">6.2500</td>
          </tr>
          <tr>
            <td class="text-left" colspan="1" rowspan="1">15</td>
            <td class="text-left" colspan="1" rowspan="1">1249978831</td>
            <td class="text-left" colspan="1" rowspan="1">6.2499</td>
          </tr>
        </tbody>
      </table>
</div>
<p id="section-appendix.b-5">
Evaluation of tinymt32_rand16(): We first generate a huge number
(1,000,000,000) of small sequences 
(20 pseudorandom numbers per sequence), increasing the seed value for each
sequence, and perform 
statistics on the number of occurrences of each of the 16 possible values
across the 20,000,000,000 
numbers of all sequences. In this first test, we consider 32-bit seed values in
order to assess the PRNG
quality after output truncation to 4 bits.<a class="pilcrow" href="#section-appendix.b-5">¶</a></p>
<p id="section-appendix.b-6">
The results (<a class="xref" href="#table_tinymt32_out_truncated_16_huge_nb_small_seq">Table 1</a>) show that all possible values are almost equally represented, or said differently, that the tinymt32_rand16() output converges to a uniform distribution where each of the 16 possible values would appear exactly 1 / 16 * 100 = 6.25% of times.<a class="pilcrow" href="#section-appendix.b-6">¶</a></p>
<p id="section-appendix.b-7">
Since the RLC FEC schemes use of this PRNG will be limited to 16-bit seed values, we carried out the same test for the first 2<sup>16</sup> seed values only.
The distribution (not shown) is of course less uniform, with value occurrences ranging between 6.2121% (i.e., 81,423 occurrences out of a total of 65536*20=1,310,720) and 6.2948% (i.e., 82,507 occurrences).
However, we do not believe it significantly impacts the RLC FEC scheme behavior.<a class="pilcrow" href="#section-appendix.b-7">¶</a></p>
<p id="section-appendix.b-8">
Other types of biases may exist that may be visible with smaller tests, for instance to evaluate the convergence speed to a uniform distribution.

   We therefore perform 200 tests, each of them producing 200 sequences,
   keeping only the first value of each sequence.

We use non-overlapping repair keys for each sequence, starting with value 0 and increasing it after each use.<a class="pilcrow" href="#section-appendix.b-8">¶</a></p>
<span id="name-tinymt32_rand16-occurrence-s"></span><div id="table_tinymt32_out_truncated_16_small_nb_small_seq">
<table class="center" id="table-2">
        <caption>
<a class="selfRef" href="#table-2">Table 2</a>:
<a class="selfRef" href="#name-tinymt32_rand16-occurrence-s">tinymt32_rand16() Occurrence Statistics</a>
        </caption>
<thead>
          <tr>
            <th class="text-left" colspan="1" rowspan="1">Value</th>
            <th class="text-left" colspan="1" rowspan="1">Min Occurrences</th>
            <th class="text-left" colspan="1" rowspan="1">Max Occurrences</th>
            <th class="text-left" colspan="1" rowspan="1">Average Occurrences</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td class="text-left" colspan="1" rowspan="1">0</td>
            <td class="text-left" colspan="1" rowspan="1">4</td>
            <td class="text-left" colspan="1" rowspan="1">21</td>
            <td class="text-left" colspan="1" rowspan="1">6.3675</td>
          </tr>
          <tr>
            <td class="text-left" colspan="1" rowspan="1">1</td>
            <td class="text-left" colspan="1" rowspan="1">4</td>
            <td class="text-left" colspan="1" rowspan="1">22</td>
            <td class="text-left" colspan="1" rowspan="1">6.0200</td>
          </tr>
          <tr>
            <td class="text-left" colspan="1" rowspan="1">2</td>
            <td class="text-left" colspan="1" rowspan="1">4</td>
            <td class="text-left" colspan="1" rowspan="1">20</td>
            <td class="text-left" colspan="1" rowspan="1">6.3125</td>
          </tr>
          <tr>
            <td class="text-left" colspan="1" rowspan="1">3</td>
            <td class="text-left" colspan="1" rowspan="1">5</td>
            <td class="text-left" colspan="1" rowspan="1">23</td>
            <td class="text-left" colspan="1" rowspan="1">6.1775</td>
          </tr>
          <tr>
            <td class="text-left" colspan="1" rowspan="1">4</td>
            <td class="text-left" colspan="1" rowspan="1">5</td>
            <td class="text-left" colspan="1" rowspan="1">24</td>
            <td class="text-left" colspan="1" rowspan="1">6.1000</td>
          </tr>
          <tr>
            <td class="text-left" colspan="1" rowspan="1">5</td>
            <td class="text-left" colspan="1" rowspan="1">4</td>
            <td class="text-left" colspan="1" rowspan="1">21</td>
            <td class="text-left" colspan="1" rowspan="1">6.5925</td>
          </tr>
          <tr>
            <td class="text-left" colspan="1" rowspan="1">6</td>
            <td class="text-left" colspan="1" rowspan="1">5</td>
            <td class="text-left" colspan="1" rowspan="1">30</td>
            <td class="text-left" colspan="1" rowspan="1">6.3075</td>
          </tr>
          <tr>
            <td class="text-left" colspan="1" rowspan="1">7</td>
            <td class="text-left" colspan="1" rowspan="1">6</td>
            <td class="text-left" colspan="1" rowspan="1">22</td>
            <td class="text-left" colspan="1" rowspan="1">6.2225</td>
          </tr>
          <tr>
            <td class="text-left" colspan="1" rowspan="1">8</td>
            <td class="text-left" colspan="1" rowspan="1">5</td>
            <td class="text-left" colspan="1" rowspan="1">26</td>
            <td class="text-left" colspan="1" rowspan="1">6.1750</td>
          </tr>
          <tr>
            <td class="text-left" colspan="1" rowspan="1">9</td>
            <td class="text-left" colspan="1" rowspan="1">3</td>
            <td class="text-left" colspan="1" rowspan="1">21</td>
            <td class="text-left" colspan="1" rowspan="1">5.9425</td>
          </tr>
          <tr>
            <td class="text-left" colspan="1" rowspan="1">10 </td>
            <td class="text-left" colspan="1" rowspan="1">5</td>
            <td class="text-left" colspan="1" rowspan="1">24</td>
            <td class="text-left" colspan="1" rowspan="1">6.3175</td>
          </tr>
          <tr>
            <td class="text-left" colspan="1" rowspan="1">11 </td>
            <td class="text-left" colspan="1" rowspan="1">4</td>
            <td class="text-left" colspan="1" rowspan="1">22</td>
            <td class="text-left" colspan="1" rowspan="1">6.4300</td>
          </tr>
          <tr>
            <td class="text-left" colspan="1" rowspan="1">12 </td>
            <td class="text-left" colspan="1" rowspan="1">5</td>
            <td class="text-left" colspan="1" rowspan="1">21</td>
            <td class="text-left" colspan="1" rowspan="1">6.1600</td>
          </tr>
          <tr>
            <td class="text-left" colspan="1" rowspan="1">13 </td>
            <td class="text-left" colspan="1" rowspan="1">5</td>
            <td class="text-left" colspan="1" rowspan="1">22</td>
            <td class="text-left" colspan="1" rowspan="1">6.3100</td>
          </tr>
          <tr>
            <td class="text-left" colspan="1" rowspan="1">14 </td>
            <td class="text-left" colspan="1" rowspan="1">4</td>
            <td class="text-left" colspan="1" rowspan="1">26</td>
            <td class="text-left" colspan="1" rowspan="1">6.3950</td>
          </tr>
          <tr>
            <td class="text-left" colspan="1" rowspan="1">15 </td>
            <td class="text-left" colspan="1" rowspan="1">4</td>
            <td class="text-left" colspan="1" rowspan="1">21</td>
            <td class="text-left" colspan="1" rowspan="1">6.1700</td>
          </tr>
        </tbody>
      </table>
</div>
<p id="section-appendix.b-10">
<a class="xref" href="#table_tinymt32_out_truncated_16_small_nb_small_seq">Table 2</a> shows across all 200 tests, for each of the 16 possible pseudorandom number values, the minimum (resp. maximum) number of times it appeared in a test, as well as the average number of occurrences across the 200 tests.
Although the distribution is not perfect, there is no major bias.
On the contrary, in the same conditions, the Park-Miller linear congruential PRNG of <span>[<a class="xref" href="#RFC5170">RFC5170</a>]</span> with a result scaled down to 4-bit values, using seeds in sequence starting from 1, systematically returns 0 as the first value during some time. Then, after a certain repair key value threshold, it systematically returns 1, etc.<a class="pilcrow" href="#section-appendix.b-10">¶</a></p>
<p id="section-appendix.b-11">
Evaluation of tinymt32_rand256():
The same approach is used here.
Results (not shown) are similar: occurrences vary between 7,810,3368 (i.e., 0.3905%) and 7,814,7952 (i.e., 0.3907%).
Here also we see a convergence to the theoretical uniform distribution where each of the 256 possible values would appear exactly 1 / 256 * 100 = 0.390625% of times.<a class="pilcrow" href="#section-appendix.b-11">¶</a></p>
</section>
</div>
<div id="possible_param_derivation">
<section id="section-appendix.c">
      <h2 id="name-possible-parameter-derivati">
<a class="section-number selfRef" href="#section-appendix.c">Appendix C. </a><a class="section-name selfRef" href="#name-possible-parameter-derivati">Possible Parameter Derivation (Informational)</a>
      </h2>
<p id="section-appendix.c-1">
<a class="xref" href="#CommonProc_rlcParameters">Section 3.1</a> defines several parameters to control the encoder or decoder.
This annex proposes techniques to derive these parameters according to the target use-case.
This annex is informational, in the sense that using a different derivation technique will not prevent the encoder and decoder to interoperate: a decoder can still recover an erased source symbol without any error.
However, in case of a real-time flow, an inappropriate parameter derivation may lead to the decoding of erased source packets after their validity period, making them useless to the target application.
This annex proposes an approach to reduce this risk, among other things.<a class="pilcrow" href="#section-appendix.c-1">¶</a></p>
<p id="section-appendix.c-2">
The FEC schemes defined in this document can be used in various manners, depending on the target use-case:<a class="pilcrow" href="#section-appendix.c-2">¶</a></p>
<ul>
<li id="section-appendix.c-3.1"> the source ADU flow they protect may or may not have real-time constraints;<a class="pilcrow" href="#section-appendix.c-3.1">¶</a>
</li>
<li id="section-appendix.c-3.2"> the source ADU flow may be a Constant Bitrate (CBR) or Variable Bitrate (VBR) flow;<a class="pilcrow" href="#section-appendix.c-3.2">¶</a>
</li>
<li id="section-appendix.c-3.3"> with a VBR source ADU flow, the flow's minimum and maximum bitrates may or may not be known;<a class="pilcrow" href="#section-appendix.c-3.3">¶</a>
</li>
<li id="section-appendix.c-3.4"> and the communication path between encoder and decoder may be a CBR communication path (e.g., as with certain LTE-based broadcast channels) or not (general case, e.g., with Internet).<a class="pilcrow" href="#section-appendix.c-3.4">¶</a>
</li>
</ul>
<p id="section-appendix.c-4">
The parameter derivation technique should be suited to the use-case, as described in the following sections.<a class="pilcrow" href="#section-appendix.c-4">¶</a></p>
<div id="param_derivation_cbr_realtime">
<section id="section-c.1">
        <h2 id="name-case-of-a-cbr-real-time-flo">
<a class="section-number selfRef" href="#section-c.1">C.1. </a><a class="section-name selfRef" href="#name-case-of-a-cbr-real-time-flo">Case of a CBR Real-Time Flow</a>
        </h2>
<p id="section-c.1-1">
In the following, we consider a real-time flow with max_lat latency budget.
The encoding symbol size, E, is constant.
The code rate, cr, is also constant, its value depending on the expected communication loss model (this choice is out of scope of this document).<a class="pilcrow" href="#section-c.1-1">¶</a></p>
<p id="section-c.1-2">
In a first configuration, the source ADU flow bitrate at the input of the FECFRAME sender is fixed and equal to br_in (in bits/s), and this value is known by the FECFRAME sender.
It follows that the transmission bitrate at the output of the FECFRAME sender will be higher, depending on the added repair flow overhead.
In order to comply with the maximum FEC-related latency budget, we have:<a class="pilcrow" href="#section-c.1-2">¶</a></p>
<ul class="ulEmpty">
<li class="ulEmpty" id="section-c.1-3.1"> dw_max_size = (max_lat * br_in) / (8 * E)<a class="pilcrow" href="#section-c.1-3.1">¶</a>
</li>
</ul>
<p id="section-c.1-4">
assuming that the encoding and decoding times are negligible with respect to the target max_lat.
This is a reasonable assumption in many situations (e.g., see <a class="xref" href="#oprecom_ff_considerations">Section 8.1</a> in case of small window sizes).
Otherwise the max_lat parameter should be adjusted in order to avoid the problem.
In any case, interoperability will never be compromised by choosing a too large value.<a class="pilcrow" href="#section-c.1-4">¶</a></p>
<p id="section-c.1-5">
In a second configuration, the FECFRAME sender generates a fixed bitrate flow, equal to the CBR communication path bitrate equal to br_out (in bits/s), and this value is known by the FECFRAME sender, as in <span>[<a class="xref" href="#Roca17">Roca17</a>]</span>.
The maximum source flow bitrate needs to be such that, with the added repair flow overhead, the total transmission bitrate remains inferior or equal to br_out.
We have:<a class="pilcrow" href="#section-c.1-5">¶</a></p>
<ul class="ulEmpty">
<li class="ulEmpty" id="section-c.1-6.1"> dw_max_size = (max_lat * br_out * cr) / (8 * E)<a class="pilcrow" href="#section-c.1-6.1">¶</a>
</li>
</ul>
<p id="section-c.1-7">
assuming here also that the encoding and decoding times are negligible with respect to the target max_lat.<a class="pilcrow" href="#section-c.1-7">¶</a></p>
<p id="section-c.1-8">
For decoding to be possible within the latency budget, it is required that the encoding window maximum size be smaller than or at most equal to the decoding window maximum size.
The ew_max_size is the main parameter at a FECFRAME sender, but its exact value has no impact on the FEC-related latency budget.
The ew_max_size parameter is computed as follows:<a class="pilcrow" href="#section-c.1-8">¶</a></p>
<ul class="ulEmpty">
<li class="ulEmpty" id="section-c.1-9.1"> ew_max_size = dw_max_size * WSR / 255<a class="pilcrow" href="#section-c.1-9.1">¶</a>
</li>
</ul>
<p id="section-c.1-10">
In line with <span>[<a class="xref" href="#Roca17">Roca17</a>]</span>, WSR = 191 is considered as a reasonable value (the resulting encoding to decoding window size ratio is then close to 0.75), but other values between 1 and 255 inclusive are possible, depending on the use-case.<a class="pilcrow" href="#section-c.1-10">¶</a></p>
<p id="section-c.1-11">
The dw_max_size is computed by a FECFRAME sender but not explicitly communicated to a FECFRAME receiver.
However, a FECFRAME receiver can easily evaluate the ew_max_size by observing the maximum Number of Source Symbols (NSS) value contained in the Repair FEC Payload ID of received FEC Repair Packets (<a class="xref" href="#ArbitraryFlows_repair_fpi">Section 4.1.3</a>).
A receiver can then easily compute dw_max_size:<a class="pilcrow" href="#section-c.1-11">¶</a></p>
<ul class="ulEmpty">
<li class="ulEmpty" id="section-c.1-12.1"> dw_max_size = max_NSS_observed * 255 / WSR<a class="pilcrow" href="#section-c.1-12.1">¶</a>
</li>
</ul>
<p id="section-c.1-13">
A receiver can then choose an appropriate linear system maximum size:<a class="pilcrow" href="#section-c.1-13">¶</a></p>
<ul class="ulEmpty">
<li class="ulEmpty" id="section-c.1-14.1"> ls_max_size &gt;= dw_max_size<a class="pilcrow" href="#section-c.1-14.1">¶</a>
</li>
</ul>
<p id="section-c.1-15">
It is good practice to use a larger value for ls_max_size as explained in <a class="xref" href="#decodingBeyondMaxLatency">Appendix D</a>, which does not impact maximum latency nor interoperability.<a class="pilcrow" href="#section-c.1-15">¶</a></p>
<p id="section-c.1-16">
In any case, for a given use-case (i.e., for target encoding and decoding devices and desired protection levels in front of communication impairments) and for the computed ew_max_size, dw_max_size and ls_max_size values, it is <span class="bcp14">RECOMMENDED</span> to check that the maximum encoding time and maximum memory requirements at a FECFRAME sender, and maximum decoding time and maximum memory requirements at a FECFRAME receiver, stay within reasonable bounds.
When assuming that the encoding and decoding times are negligible with respect to the target max_lat, this should be verified as well, otherwise the max_lat <span class="bcp14">SHOULD</span> be adjusted accordingly.<a class="pilcrow" href="#section-c.1-16">¶</a></p>
<p id="section-c.1-17">
The particular case of session start needs to be managed appropriately since the ew_size, starting at zero, increases each time a new source ADU is received by the FECFRAME sender, until it reaches the ew_max_size value.
Therefore, a FECFRAME receiver <span class="bcp14">SHOULD</span> continuously observe the received FEC Repair Packets, since the NSS value carried in the Repair FEC Payload ID will increase too, and adjust its ls_max_size accordingly if need be.
With a CBR flow, session start is expected to be the only moment when the encoding window size will increase.
Similarly, with a CBR real-time flow, the session end is expected to be the only moment when the encoding window size will progressively decrease.
No adjustment of the ls_max_size is required at the FECFRAME receiver in that case.<a class="pilcrow" href="#section-c.1-17">¶</a></p>
</section>
</div>
<div id="param_derivation_other_realtime_flows">
<section id="section-c.2">
        <h2 id="name-other-types-of-real-time-fl">
<a class="section-number selfRef" href="#section-c.2">C.2. </a><a class="section-name selfRef" href="#name-other-types-of-real-time-fl">Other Types of Real-Time Flow</a>
        </h2>
<p id="section-c.2-1">
In the following, we consider a real-time source ADU flow with a max_lat latency budget and a variable bitrate (VBR) measured at the entry of the FECFRAME sender.
A first approach consists in considering the smallest instantaneous bitrate of the source ADU flow, when this parameter is known, and to reuse the derivation of <a class="xref" href="#param_derivation_cbr_realtime">Appendix C.1</a>.
Considering the smallest bitrate means that the encoding and decoding window maximum size estimations are pessimistic: these windows have the smallest size required to enable on-time decoding at a FECFRAME receiver.
If the instantaneous bitrate is higher than this smallest bitrate, this approach leads to an encoding window that is unnecessarily small, which reduces robustness in front of long erasure bursts.<a class="pilcrow" href="#section-c.2-1">¶</a></p>
<p id="section-c.2-2">
Another approach consists in using ADU timing information (e.g., using the timestamp field of an RTP packet header, or registering the time upon receiving a new ADU).
From the global FEC-related latency budget, the FECFRAME sender can derive a practical maximum latency budget for encoding operations, max_lat_for_encoding.
For the FEC schemes specified in this document, this latency budget <span class="bcp14">SHOULD</span> be computed with:<a class="pilcrow" href="#section-c.2-2">¶</a></p>
<ul class="ulEmpty">
<li class="ulEmpty" id="section-c.2-3.1"> max_lat_for_encoding = max_lat * WSR / 255<a class="pilcrow" href="#section-c.2-3.1">¶</a>
</li>
</ul>
<p id="section-c.2-4">
It follows that any source symbols associated to an ADU that has timed-out with respect to max_lat_for_encoding <span class="bcp14">SHOULD</span> be removed from the encoding window.
With this approach there is no pre-determined ew_size value: this value fluctuates over the time according to the instantaneous source ADU flow bitrate.
For practical reasons, a FECFRAME sender may still require that ew_size does not increase beyond a maximum value (<a class="xref" href="#param_derivation_non_realtime">Appendix C.3</a>).<a class="pilcrow" href="#section-c.2-4">¶</a></p>
<p id="section-c.2-5">
With both approaches, and no matter the choice of the FECFRAME sender, a FECFRAME receiver can still easily evaluate the ew_max_size by observing the maximum Number of Source Symbols (NSS) value contained in the Repair FEC Payload ID of received FEC Repair Packets.
A receiver can then compute dw_max_size and derive an appropriate ls_max_size as explained in <a class="xref" href="#param_derivation_cbr_realtime">Appendix C.1</a>.<a class="pilcrow" href="#section-c.2-5">¶</a></p>
<p id="section-c.2-6">
When the observed NSS fluctuates significantly, a FECFRAME receiver may want to adapt its ls_max_size accordingly.
In particular when the NSS is significantly reduced, a FECFRAME receiver may want to reduce the ls_max_size too in order to limit computation complexity.
A balance must be found between using an ls_max_size "too large" (which increases computation complexity and memory requirements) and the opposite (which reduces recovery performance).<a class="pilcrow" href="#section-c.2-6">¶</a></p>
</section>
</div>
<div id="param_derivation_non_realtime">
<section id="section-c.3">
        <h2 id="name-case-of-a-non-real-time-flo">
<a class="section-number selfRef" href="#section-c.3">C.3. </a><a class="section-name selfRef" href="#name-case-of-a-non-real-time-flo">Case of a Non-Real-Time Flow</a>
        </h2>
<p id="section-c.3-1">
Finally there are configurations where a source ADU flow has no real-time constraints.
FECFRAME and the FEC schemes defined in this document can still be used.
The choice of appropriate parameter values can be directed by practical considerations.
For instance, it can derive from an estimation of the maximum memory amount that could be dedicated to the linear system at a FECFRAME receiver, or the maximum computation complexity at a FECFRAME receiver, both of them depending on the ls_max_size parameter.
The same considerations also apply to the FECFRAME sender, where the maximum memory amount and computation complexity depend on the ew_max_size parameter.<a class="pilcrow" href="#section-c.3-1">¶</a></p>
<p id="section-c.3-2">
Here also, the NSS value contained in FEC Repair Packets is used by a FECFRAME receiver to determine the current coding window size and ew_max_size by observing its maximum value over the time.<a class="pilcrow" href="#section-c.3-2">¶</a></p>
</section>
</div>
</section>
</div>
<div id="decodingBeyondMaxLatency">
<section id="section-appendix.d">
      <h2 id="name-decoding-beyond-maximum-lat">
<a class="section-number selfRef" href="#section-appendix.d">Appendix D. </a><a class="section-name selfRef" href="#name-decoding-beyond-maximum-lat">Decoding Beyond Maximum Latency Optimization (Informational)</a>
      </h2>
<p id="section-appendix.d-1">
This annex introduces non-normative considerations.
It is provided as suggestions, without any impact on interoperability.
For more information see <span>[<a class="xref" href="#Roca16">Roca16</a>]</span>.<a class="pilcrow" href="#section-appendix.d-1">¶</a></p>
<p id="section-appendix.d-2">
With a real-time source ADU flow, it is possible to improve the decoding performance of Sliding Window Codes without impacting maximum latency, at the cost of extra memory and CPU overhead.
The optimization consists, for a FECFRAME receiver, to extend the linear system beyond the decoding window maximum size, by keeping a certain number of old source symbols whereas their associated ADUs timed-out:<a class="pilcrow" href="#section-appendix.d-2">¶</a></p>
<ul class="ulEmpty">
<li class="ulEmpty" id="section-appendix.d-3.1"> ls_max_size &gt; dw_max_size<a class="pilcrow" href="#section-appendix.d-3.1">¶</a>
</li>
</ul>
<p id="section-appendix.d-4">
Usually the following choice is a good trade-off between decoding performance and extra CPU overhead:<a class="pilcrow" href="#section-appendix.d-4">¶</a></p>
<ul class="ulEmpty">
<li class="ulEmpty" id="section-appendix.d-5.1"> ls_max_size = 2 * dw_max_size<a class="pilcrow" href="#section-appendix.d-5.1">¶</a>
</li>
</ul>
<p id="section-appendix.d-6">
When the dw_max_size is very small, it may be preferable to keep a minimum ls_max_size value (e.g., LS_MIN_SIZE_DEFAULT = 40 symbols).
Going below this threshold will not save a significant amount of memory nor CPU cycles.
Therefore:<a class="pilcrow" href="#section-appendix.d-6">¶</a></p>
<ul class="ulEmpty">
<li class="ulEmpty" id="section-appendix.d-7.1"> ls_max_size = max(2 * dw_max_size, LS_MIN_SIZE_DEFAULT)<a class="pilcrow" href="#section-appendix.d-7.1">¶</a>
</li>
</ul>
<p id="section-appendix.d-8">
Finally, it is worth noting that a receiver that benefits from an FEC protection significantly higher than what is required to recover from packet losses, can choose to reduce the ls_max_size.
In that case lost ADUs will be recovered without relying on this optimization.<a class="pilcrow" href="#section-appendix.d-8">¶</a></p>
<span id="name-relationship-between-parame"></span><div id="fig_decoding_beyond_max_latency">
<figure id="figure-11">
        <div class="artwork art-text alignLeft" id="section-appendix.d-9.1">
<pre>                             ls_max_size
/---------------------------------^-------------------------------\

        late source symbols
 (pot. decoded but not delivered)            dw_max_size
/--------------^-----------------\ /--------------^---------------\
src0 src1 src2 src3 src4 src5 src6 src7 src8 src9 src10 src11 src12
</pre>
</div>
<figcaption><a class="selfRef" href="#figure-11">Figure 11</a>:
<a class="selfRef" href="#name-relationship-between-parame">Relationship between Parameters to Decode beyond Maximum Latency</a>
        </figcaption></figure>
</div>
<p id="section-appendix.d-10">
It means that source symbols, and therefore ADUs, may be decoded even if the added latency exceeds the maximum value permitted by the application (the "late source symbols" of <a class="xref" href="#fig_decoding_beyond_max_latency">Figure 11</a>).
It follows that the corresponding ADUs will not be useful to the application.
However, decoding these "late symbols" significantly improves the global robustness in bad reception conditions and is therefore recommended for receivers experiencing bad communication conditions <span>[<a class="xref" href="#Roca16">Roca16</a>]</span>.
In any case whether or not to use this optimization and what exact value to use for the ls_max_size parameter are local decisions made by each receiver independently, without any impact on the other receivers nor on the source.<a class="pilcrow" href="#section-appendix.d-10">¶</a></p>
</section>
</div>
<section id="section-appendix.e">
      <h2 id="name-acknowledgments">
<a class="section-name selfRef" href="#name-acknowledgments">Acknowledgments</a>
      </h2>
<p id="section-appendix.e-1">
The authors would like to thank the three TSVWG chairs, Wesley Eddy (our shepherd), David Black, and Gorry Fairhurst; as well as Spencer Dawkins, our responsible AD;
and all those who provided comments -- namely (in alphabetical order), Alan DeKok, Jonathan Detchart, Russ Housley, Emmanuel Lochin, Marie-Jose Montpetit, and Greg Skinner.
Last but not least, the authors are really grateful to the IESG members, in particular Benjamin Kaduk, Mirja Kuehlewind, Eric Rescorla, Adam Roach, and Roman Danyliw for their highly valuable feedback that greatly contributed to improving this specification.<a class="pilcrow" href="#section-appendix.e-1">¶</a></p>
</section>
<div id="authors-addresses">
<section id="section-appendix.f">
      <h2 id="name-authors-addresses">
<a class="section-name selfRef" href="#name-authors-addresses">Authors' Addresses</a>
      </h2>
<address class="vcard">
        <div class="left" dir="auto"><span class="fn nameRole">Vincent Roca</span></div>
<div class="left" dir="auto"><span class="org">INRIA</span></div>
<div class="left" dir="auto"><span class="extended-address">Univ. Grenoble Alpes</span></div>
<div class="left" dir="auto"><span class="country-name">France</span></div>
<div class="email">
<span>Email:</span>
<a class="email" href="mailto:vincent.roca@inria.fr">vincent.roca@inria.fr</a>
</div>
</address>
<address class="vcard">
        <div class="left" dir="auto"><span class="fn nameRole">Belkacem Teibi</span></div>
<div class="left" dir="auto"><span class="org">INRIA</span></div>
<div class="left" dir="auto"><span class="extended-address">Univ. Grenoble Alpes</span></div>
<div class="left" dir="auto"><span class="country-name">France</span></div>
<div class="email">
<span>Email:</span>
<a class="email" href="mailto:belkacem.teibi@gmail.com">belkacem.teibi@gmail.com</a>
</div>
</address>
</section>
</div>
<script>var toc = document.getElementById("toc");
var tocToggle = toc.querySelector("h2");
var tocNav = toc.querySelector("nav");

// mobile menu toggle
tocToggle.onclick = function(event) {
    if (window.innerWidth < 1024) {
 var tocNavDisplay = tocNav.currentStyle ? tocNav.currentStyle.display : getComputedStyle(tocNav, null).display;
 if (tocNavDisplay == "none") {
     tocNav.style.display = "block";
 } else {
     tocNav.style.display = "none";
 }
    }
}

// toc anchor scroll to anchor
tocNav.addEventListener("click", function (event) {
    event.preventDefault();
    if (event.target.nodeName == 'A') {
 if (window.innerWidth < 1024) {
     tocNav.style.display = "none";
 }
 var href = event.target.getAttribute("href");
 var anchorId = href.substr(1);
 var anchor =  document.getElementById(anchorId);
 anchor.scrollIntoView(true);
 window.history.pushState("","",href);
    }
});

// switch toc mode when window resized
window.onresize = function () {
    if (window.innerWidth < 1024) {
 tocNav.style.display = "none";
    } else {
 tocNav.style.display = "block";
    }
}
</script>


</body></html>