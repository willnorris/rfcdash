<html><head></head><body><pre>Independent Submission                                   D. Harkins, Ed.
Request for Comments: 8492                                 HP Enterprise
Category: Informational                                    February 2019
ISSN: 2070-1721


    <span class="h1">Secure Password Ciphersuites for Transport Layer Security (TLS)</span>

Abstract

   This memo defines several new ciphersuites for the Transport Layer
   Security (TLS) protocol to support certificateless, secure
   authentication using only a simple, low-entropy password.  The
   exchange is called "TLS-PWD".  The ciphersuites are all based on an
   authentication and key exchange protocol, named "dragonfly", that is
   resistant to offline dictionary attacks.

Status of This Memo

   This document is not an Internet Standards Track specification; it is
   published for informational purposes.

   This is a contribution to the RFC Series, independently of any other
   RFC stream.  The RFC Editor has chosen to publish this document at
   its discretion and makes no statement about its value for
   implementation or deployment.  Documents approved for publication by
   the RFC Editor are not candidates for any level of Internet Standard;
   see <a href="./rfc7841#section-2">SectionÂ 2 of RFC 7841</a>.

   Information about the current status of this document, any errata,
   and how to provide feedback on it may be obtained at
   <a href="https://www.rfc-editor.org/info/rfc8492">https://www.rfc-editor.org/info/rfc8492</a>.

Copyright Notice

   Copyright (c) 2019 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to <a href="https://www.rfc-editor.org/bcp/bcp78">BCP 78</a> and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (<a href="https://trustee.ietf.org/license-info">https://trustee.ietf.org/license-info</a>) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.







<span class="grey">Harkins                       Informational                     [Page 1]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-2"></span>
<span class="grey"><a href="./rfc8492">RFC 8492</a>                      TLS Password                 February 2019</span>


Table of Contents

   <a href="#section-1">1</a>. Introduction and Motivation .....................................<a href="#page-3">3</a>
      <a href="#section-1.1">1.1</a>. The Case for Certificateless Authentication ................<a href="#page-3">3</a>
      <a href="#section-1.2">1.2</a>. Resistance to Dictionary Attacks ...........................<a href="#page-3">3</a>
   <a href="#section-2">2</a>. Key Words .......................................................<a href="#page-4">4</a>
   <a href="#section-3">3</a>. Notation and Background .........................................<a href="#page-4">4</a>
      <a href="#section-3.1">3.1</a>. Notation ...................................................<a href="#page-4">4</a>
      <a href="#section-3.2">3.2</a>. Discrete Logarithm Cryptography ............................<a href="#page-5">5</a>
           <a href="#section-3.2.1">3.2.1</a>. Elliptic Curve Cryptography .........................<a href="#page-5">5</a>
           <a href="#section-3.2.2">3.2.2</a>. Finite Field Cryptography ...........................<a href="#page-7">7</a>
      <a href="#section-3.3">3.3</a>. Instantiating the Random Function ..........................<a href="#page-8">8</a>
      <a href="#section-3.4">3.4</a>. Passwords ..................................................<a href="#page-8">8</a>
      <a href="#section-3.5">3.5</a>. Assumptions ................................................<a href="#page-9">9</a>
   <a href="#section-4">4</a>. Specification of the TLS-PWD Handshake .........................<a href="#page-10">10</a>
      <a href="#section-4.1">4.1</a>. TLS-PWD Pre-TLS 1.3 .......................................<a href="#page-10">10</a>
      <a href="#section-4.2">4.2</a>. TLS-PWD in TLS 1.3 ........................................<a href="#page-11">11</a>
      <a href="#section-4.3">4.3</a>. Protecting the Username ...................................<a href="#page-11">11</a>
           <a href="#section-4.3.1">4.3.1</a>. Construction of a Protected Username ...............<a href="#page-12">12</a>
           <a href="#section-4.3.2">4.3.2</a>. Recovery of a Protected Username ...................<a href="#page-13">13</a>
      <a href="#section-4.4">4.4</a>. Fixing the Password Element ...............................<a href="#page-14">14</a>
           <a href="#section-4.4.1">4.4.1</a>. Computing an ECC Password Element ..................<a href="#page-16">16</a>
           <a href="#section-4.4.2">4.4.2</a>. Computing an FFC Password Element ..................<a href="#page-18">18</a>
           <a href="#section-4.4.3">4.4.3</a>. Password Naming ....................................<a href="#page-19">19</a>
           <a href="#section-4.4.4">4.4.4</a>. Generating TLS-PWD Commit ..........................<a href="#page-20">20</a>
      <a href="#section-4.5">4.5</a>. Changes to Handshake Message Contents .....................<a href="#page-20">20</a>
           <a href="#section-4.5.1">4.5.1</a>. Pre-1.3 TLS ........................................<a href="#page-20">20</a>
                  <a href="#section-4.5.1.1">4.5.1.1</a>. ClientHello Changes .......................<a href="#page-20">20</a>
                  <a href="#section-4.5.1.2">4.5.1.2</a>. ServerKeyExchange Changes .................<a href="#page-21">21</a>
                  <a href="#section-4.5.1.3">4.5.1.3</a>. ClientKeyExchange Changes .................<a href="#page-23">23</a>
           <a href="#section-4.5.2">4.5.2</a>. TLS 1.3 ............................................<a href="#page-24">24</a>
                  <a href="#section-4.5.2.1">4.5.2.1</a>. TLS 1.3 KeyShare ..........................<a href="#page-24">24</a>
                  <a href="#section-4.5.2.2">4.5.2.2</a>. ClientHello Changes .......................<a href="#page-24">24</a>
                  <a href="#section-4.5.2.3">4.5.2.3</a>. ServerHello Changes .......................<a href="#page-25">25</a>
                  <a href="#section-4.5.2.4">4.5.2.4</a>. HelloRetryRequest Changes .................<a href="#page-25">25</a>
      <a href="#section-4.6">4.6</a>. Computing the Shared Secret ...............................<a href="#page-26">26</a>
   <a href="#section-5">5</a>. Ciphersuite Definition .........................................<a href="#page-26">26</a>
   <a href="#section-6">6</a>. IANA Considerations ............................................<a href="#page-27">27</a>
   <a href="#section-7">7</a>. Security Considerations ........................................<a href="#page-27">27</a>
   <a href="#section-8">8</a>. Human Rights Considerations ....................................<a href="#page-30">30</a>
   <a href="#section-9">9</a>. Implementation Considerations ..................................<a href="#page-31">31</a>
   <a href="#section-10">10</a>. References ....................................................<a href="#page-32">32</a>
      <a href="#section-10.1">10.1</a>. Normative References .....................................<a href="#page-32">32</a>
      <a href="#section-10.2">10.2</a>. Informative References ...................................<a href="#page-33">33</a>
   <a href="#appendix-A">Appendix A</a>. Example Exchange ......................................<a href="#page-35">35</a>
   Acknowledgements ..................................................<a href="#page-40">40</a>
   Author's Address ..................................................<a href="#page-40">40</a>




<span class="grey">Harkins                       Informational                     [Page 2]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-3"></span>
<span class="grey"><a href="./rfc8492">RFC 8492</a>                      TLS Password                 February 2019</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/1.%20%20Introduction%20and%20Motivation"></a><a class="selflink" href="#section-1" id="section-1">1</a>.  Introduction and Motivation</span>

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/1.1.%20%20The%20Case%20for%20Certificateless%20Authentication"></a><a class="selflink" href="#section-1.1" id="section-1.1">1.1</a>.  The Case for Certificateless Authentication</span>

   Transport Layer Security (TLS) usually uses public key certificates
   for authentication [<a href="./rfc5246" title='"The Transport Layer Security (TLS) Protocol Version 1.2"'>RFC5246</a>] [<a href="./rfc8446" title='"The Transport Layer Security (TLS) Protocol Version 1.3"'>RFC8446</a>].  This is problematic in some
   cases:

   o  Frequently, TLS [<a href="./rfc5246" title='"The Transport Layer Security (TLS) Protocol Version 1.2"'>RFC5246</a>] is used in devices owned, operated, and
      provisioned by people who lack competency to properly use
      certificates and merely want to establish a secure connection
      using a more natural credential like a simple password.  The
      proliferation of deployments that use a self-signed server
      certificate in TLS [<a href="./rfc5246" title='"The Transport Layer Security (TLS) Protocol Version 1.2"'>RFC5246</a>] followed by a basic password exchange
      over the unauthenticated channel underscores this case.

   o  The alternatives to TLS-PWD for employing certificateless TLS
      authentication -- using pre-shared keys in an exchange that is
      susceptible to dictionary attacks or using a Secure Remote
      Password (SRP) exchange that requires users to, a priori, be fixed
      to a specific Finite Field Cryptography (FFC) group for all
      subsequent connections -- are not acceptable for modern
      applications that require both security and cryptographic agility.

   o  A password is a more natural credential than a certificate (from
      early childhood, people learn the semantics of a shared secret),
      so a password-based TLS ciphersuite can be used to protect an
      HTTP-based certificate enrollment scheme like Enrollment over
      Secure Transport (EST) [<a href="./rfc7030" title='"Enrollment over Secure Transport"'>RFC7030</a>] to parlay a simple password into
      a certificate for subsequent use with any certificate-based
      authentication protocol.  This addresses a significant
      "chicken-and-egg" dilemma found with certificate-only use of
      [<a href="./rfc5246" title='"The Transport Layer Security (TLS) Protocol Version 1.2"'>RFC5246</a>].

   o  Some PIN-code readers will transfer the entered PIN to a smart
      card in cleartext.  Assuming a hostile environment, this is a bad
      practice.  A password-based TLS ciphersuite can enable the
      establishment of an authenticated connection between reader and
      card based on the PIN.

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/1.2.%20%20Resistance%20to%20Dictionary%20Attacks"></a><a class="selflink" href="#section-1.2" id="section-1.2">1.2</a>.  Resistance to Dictionary Attacks</span>

   It is a common misconception that a protocol that authenticates with
   a shared and secret credential is resistant to dictionary attacks if
   the credential is assumed to be an N-bit uniformly random secret,
   where N is sufficiently large.  The concept of resistance to
   dictionary attacks really has nothing to do with whether that secret




<span class="grey">Harkins                       Informational                     [Page 3]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-4"></span>
<span class="grey"><a href="./rfc8492">RFC 8492</a>                      TLS Password                 February 2019</span>


   can be found in a standard collection of a language's defined words
   (i.e., a dictionary).  It has to do with how an adversary gains an
   advantage in attacking the protocol.

   For a protocol to be resistant to dictionary attacks, any advantage
   an adversary can gain must be a function of the amount of
   interactions she makes with an honest protocol participant and not a
   function of the amount of computation she uses.  This means that the
   adversary will not be able to obtain any information about the
   password except whether a single guess from a single protocol run
   that she took part in is correct or incorrect.

   It is assumed that the attacker has access to a pool of data from
   which the secret was drawn -- it could be all numbers between 1 and
   2^N; it could be all defined words in a dictionary.  The key is that
   the attacker cannot do an attack and then go offline and enumerate
   through the pool trying potential secrets (computation) to see if one
   is correct.  She must do an active attack for each secret she wishes
   to try (interaction), and the only information she can glean from
   that attack is whether the secret used with that particular attack is
   correct or not.

<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/2.%20%20Key%20Words"></a><a class="selflink" href="#section-2" id="section-2">2</a>.  Key Words</span>

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
   "OPTIONAL" in this document are to be interpreted as described in
   <a href="https://www.rfc-editor.org/bcp/bcp14">BCP 14</a> [<a href="./rfc2119" title='"Key words for use in RFCs to Indicate Requirement Levels"'>RFC2119</a>] [<a href="./rfc8174" title='"Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words"'>RFC8174</a>] when, and only when, they appear in all
   capitals, as shown here.

<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/3.%20%20Notation%20and%20Background"></a><a class="selflink" href="#section-3" id="section-3">3</a>.  Notation and Background</span>

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/3.1.%20%20Notation"></a><a class="selflink" href="#section-3.1" id="section-3.1">3.1</a>.  Notation</span>

   The following notation is used in this memo:

   password
       a secret -- and potentially low-entropy -- word, phrase, code, or
       key used as a credential for authentication.  The password is
       shared between the TLS client and TLS server.

   y = H(x)
       a binary string of arbitrary length, x, is given to a function H,
       which produces a fixed-length output, y.

   a | b
       denotes concatenation of string "a" with string "b".




<span class="grey">Harkins                       Informational                     [Page 4]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-5"></span>
<span class="grey"><a href="./rfc8492">RFC 8492</a>                      TLS Password                 February 2019</span>


   [a]b
       indicates a string consisting of the single bit "a" repeated
       "b" times.

   x mod y
       indicates the remainder of division of x by y.  The result will
       be between 0 and y.

   len(x)
       indicates the length in bits of the string "x".

   lgr(a, b)
       takes "a" and a prime, b, and returns the Legendre symbol (a/b).

   LSB(x)
       returns the least-significant bit of the bitstring "x".

   G.x
       indicates the x-coordinate of a point, G, on an elliptic curve.

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/3.2.%20%20Discrete%20Logarithm%20Cryptography"></a><a class="selflink" href="#section-3.2" id="section-3.2">3.2</a>.  Discrete Logarithm Cryptography</span>

   The ciphersuites defined in this memo use discrete logarithm
   cryptography (see [<a href="#ref-SP800-56A">SP800-56A</a>]) to produce an authenticated and shared
   secret value that is an Element in a group defined by a set of domain
   parameters.  The domain parameters can be based on either FFC or
   Elliptic Curve Cryptography (ECC).

   Elements in a group -- either an FFC or ECC group -- are indicated
   using uppercase, while scalar values are indicated using lowercase.

<span class="h4"><a class="dashAnchor" name="//apple_ref/cpp/Section/3.2.1.%20%20Elliptic%20Curve%20Cryptography"></a><a class="selflink" href="#section-3.2.1" id="section-3.2.1">3.2.1</a>.  Elliptic Curve Cryptography</span>

   The authenticated key exchange defined in this memo uses fundamental
   algorithms of elliptic curves defined over GF(p) as described in
   [<a href="./rfc6090" title='"Fundamental Elliptic Curve Cryptography Algorithms"'>RFC6090</a>].  Ciphersuites defined in this memo SHALL only use ECC
   curves based on the Weierstrass equation y^2 = x^3 + a*x + b.

   Domain parameters for the ECC groups used by this memo are:

   o  A prime, p, determining a prime field GF(p).  The cryptographic
      group will be a subgroup of the full elliptic curve group, which
      consists of points on an elliptic curve -- Elements from GF(p)
      that satisfy the curve's equation -- together with the "point at
      infinity" that serves as the identity Element.






<span class="grey">Harkins                       Informational                     [Page 5]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-6"></span>
<span class="grey"><a href="./rfc8492">RFC 8492</a>                      TLS Password                 February 2019</span>


   o  Elements a and b from GF(p) that define the curve's equation.  The
      point (x, y) in GF(p) x GF(p) is on the elliptic curve if and only
      if (y^2 - x^3 - a*x - b) mod p equals zero (0).

   o  A point, G, on the elliptic curve, which serves as a generator for
      the ECC group.  G is chosen such that its order, with respect to
      elliptic curve addition, is a sufficiently large prime.

   o  A prime, q, which is the order of G and thus is also the size of
      the cryptographic subgroup that is generated by G.

   o  A co-factor, f, defined by the requirement that the size of the
      full elliptic curve group (including the "point at infinity") be
      the product of f and q.

   This memo uses the following ECC functions:

   o  Z = elem-op(X, Y) = X + Y: two points on the curve, X and Y, are
      summed to produce another point on the curve, Z.  This is the
      group operation for ECC groups.

   o  Z = scalar-op(x, Y) = x * Y: an integer scalar, x, acts on a point
      on the curve, Y, via repetitive addition (Y is added to itself
      x times), to produce another ECC Element, Z.

   o  Y = inverse(X): a point on the curve, X, has an inverse, Y, which
      is also a point on the curve, when their sum is the "point at
      infinity" (the identity for elliptic curve addition).  In other
      words, R + inverse(R) = "0".

   o  z = F(X): the x-coordinate of a point (x, y) on the curve is
      returned.  This is a mapping function to convert a group Element
      into an integer.

   Only ECC groups over GF(p) can be used with TLS-PWD.
   Characteristic-2 curves SHALL NOT be used by TLS-PWD.  ECC groups
   over GF(2^m) SHALL NOT be used by TLS-PWD.  In addition, ECC groups
   with a co-factor greater than one (1) SHALL NOT be used by TLS-PWD.

   A composite (x, y) pair can be validated as a point on the elliptic
   curve by checking that 1) both coordinates x and y are greater than
   zero (0) and less than the prime defining the underlying field,
   2) coordinates x and y satisfy the equation of the curve, and 3) they
   do not represent the "point at infinity".  If any of those conditions
   are not true, the (x, y) pair is not a valid point on the curve.






<span class="grey">Harkins                       Informational                     [Page 6]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-7"></span>
<span class="grey"><a href="./rfc8492">RFC 8492</a>                      TLS Password                 February 2019</span>


   A compliant implementation of TLS-PWD SHALL support
   group twenty-three (23) and SHOULD support group twenty-four (24)
   from the "TLS Supported Groups" registry; see [<a href="#ref-TLS_REG" title='"Transport Layer Security (TLS) Parameters"'>TLS_REG</a>].

<span class="h4"><a class="dashAnchor" name="//apple_ref/cpp/Section/3.2.2.%20%20Finite%20Field%20Cryptography"></a><a class="selflink" href="#section-3.2.2" id="section-3.2.2">3.2.2</a>.  Finite Field Cryptography</span>

   Domain parameters for the FFC groups used by this memo are:

   o  A prime, p, determining a prime field GF(p) (i.e., the integers
      modulo p).  The FFC group will be a subgroup of GF(p)* (i.e., the
      multiplicative group of non-zero Elements in GF(p)).

   o  An Element, G, in GF(p)*, which serves as a generator for the FFC
      group.  G is chosen such that its multiplicative order is a
      sufficiently large prime divisor of ((p - 1)/2).

   o  A prime, q, which is the multiplicative order of G and thus is
      also the size of the cryptographic subgroup of GF(p)* that is
      generated by G.

   This memo uses the following FFC functions:

   o  Z = elem-op(X, Y) = (X * Y) mod p: two FFC Elements, X and Y, are
      multiplied modulo the prime, p, to produce another FFC Element, Z.
      This is the group operation for FFC groups.

   o  Z = scalar-op(x, Y) = Y^x mod p: an integer scalar, x, acts on an
      FFC group Element, Y, via exponentiation modulo the prime, p, to
      produce another FFC Element, Z.

   o  Y = inverse(X): a group Element, X, has an inverse, Y, when the
      product of the Element and its inverse modulo the prime equals
      one (1).  In other words, (X * inverse(X)) mod p = 1.

   o  z = F(X): is the identity function, since an Element in an FFC
      group is already an integer.  It is included here for consistency
      in the specification.

   Many FFC groups used in IETF protocols are based on safe primes and
   do not define an order (q).  For these groups, the order (q) used in
   this memo shall be the prime of the group minus one divided by two --
   (p - 1)/2.

   An integer can be validated as being an Element in an FFC group by
   checking that 1) it is between one (1) and the prime, p, exclusive
   and 2) modular exponentiation of the integer by the group order, q,
   equals one (1).  If either of these conditions is not true, the
   integer is not an Element in the group.



<span class="grey">Harkins                       Informational                     [Page 7]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-8"></span>
<span class="grey"><a href="./rfc8492">RFC 8492</a>                      TLS Password                 February 2019</span>


   A compliant implementation of TLS-PWD SHOULD support
   group two hundred fifty-six (256) and group two hundred fifty-eight
   (258) from the "TLS Supported Groups" registry on [<a href="#ref-TLS_REG" title='"Transport Layer Security (TLS) Parameters"'>TLS_REG</a>].

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/3.3.%20%20Instantiating%20the%20Random%20Function"></a><a class="selflink" href="#section-3.3" id="section-3.3">3.3</a>.  Instantiating the Random Function</span>

   The protocol described in this memo uses a random function, H, which
   is modeled as a "random oracle".  At first glance, one may view this
   as a hash function.  As noted in [<a href="#ref-RANDOR" title='"Random Oracles are Practical: A Paradigm for Designing Efficient Protocols"'>RANDOR</a>], though, hash functions are
   too structured to be used directly as a random oracle.  But they can
   be used to instantiate the random oracle.

   The random function, H, in this memo is instantiated by using the
   hash algorithm defined by the particular TLS-PWD ciphersuite in
   Hashed Message Authentication Code (HMAC) mode with a key whose
   length is equal to the block size of the hash algorithm and whose
   value is zero.  For example, if the ciphersuite is
   TLS_ECCPWD_WITH_AES_128_GCM_SHA256, then H will be instantiated with
   SHA256 as:

      H(x) = HMAC-SHA256([0]32, x)

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/3.4.%20%20Passwords"></a><a class="selflink" href="#section-3.4" id="section-3.4">3.4</a>.  Passwords</span>

   The authenticated key exchange used in TLS-PWD requires each side to
   have a common view of a shared credential.  To protect the server's
   database of stored passwords, a password MAY be salted.  When
   [<a href="./rfc5246" title='"The Transport Layer Security (TLS) Protocol Version 1.2"'>RFC5246</a>] or earlier is used, the password SHALL be salted.  When
   [<a href="./rfc8446" title='"The Transport Layer Security (TLS) Protocol Version 1.3"'>RFC8446</a>] is used, a password MAY be stored with a salt or without.
   The password, username, and, optionally, the salt can create an
   irreversible digest called the "base", which is used in the
   authenticated key exchange.

   The salting function is defined as:

      base = HMAC-SHA256(salt, username | password)

   The unsalted function is defined as:

      base = SHA256(username | password)











<span class="grey">Harkins                       Informational                     [Page 8]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-9"></span>
<span class="grey"><a href="./rfc8492">RFC 8492</a>                      TLS Password                 February 2019</span>


   The password used for generation of the base SHALL be represented as
   a UTF-8 encoded character string processed according to the rules of
   the OpaqueString profile of [<a href="./rfc8265" title='"Preparation, Enforcement, and Comparison of Internationalized Strings Representing Usernames and Passwords"'>RFC8265</a>], and the salt SHALL be a
   32-octet random number.  The server SHALL store a tuple of the form:

      { username, base, salt }

   if the password is salted and:

      { username, base }

   if it is not.  When password salting is being used, the client
   generates the base upon receiving the salt from the server;
   otherwise, it may store the base at the time the username and
   password are provisioned.

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/3.5.%20%20Assumptions"></a><a class="selflink" href="#section-3.5" id="section-3.5">3.5</a>.  Assumptions</span>

   The security properties of the authenticated key exchange defined in
   this memo are based on a number of assumptions:

   1.  The random function, H, is a "random oracle" as defined in
       [<a href="#ref-RANDOR" title='"Random Oracles are Practical: A Paradigm for Designing Efficient Protocols"'>RANDOR</a>].

   2.  The discrete logarithm problem for the chosen group is hard.
       That is, given g, p, and y = g^x mod p, it is computationally
       infeasible to determine x.  Similarly, for an ECC group given the
       curve definition, a generator G, and Y = x * G, it is
       computationally infeasible to determine x.

   3.  Quality random numbers with sufficient entropy can be created.
       This may entail the use of specialized hardware.  If such
       hardware is unavailable, a cryptographic mixing function (like a
       strong hash function) to distill entropy from multiple,
       uncorrelated sources of information and events may be needed.  A
       very good discussion of this can be found in [<a href="./rfc4086" title='"Randomness Requirements for Security"'>RFC4086</a>].

   If the server supports username protection (see <a href="#section-4.3">Section 4.3</a>), it is
   assumed that the server has chosen a domain parameter set and
   generated a username-protection keypair.  The chosen domain parameter
   set and public key are assumed to be conveyed to the client at the
   time the client's username and password were provisioned.









<span class="grey">Harkins                       Informational                     [Page 9]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-10"></span>
<span class="grey"><a href="./rfc8492">RFC 8492</a>                      TLS Password                 February 2019</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/4.%20%20Specification%20of%20the%20TLS-PWD%20Handshake"></a><a class="selflink" href="#section-4" id="section-4">4</a>.  Specification of the TLS-PWD Handshake</span>

   The key exchange underlying TLS-PWD is the "dragonfly"
   password-authenticated key exchange (PAKE) as defined in [<a href="./rfc7664" title='"Dragonfly Key Exchange"'>RFC7664</a>].

   The authenticated key exchange is accomplished by each side deriving
   a Password Element (PE) [<a href="./rfc7664" title='"Dragonfly Key Exchange"'>RFC7664</a>] in the chosen group, making a
   "commitment" to a single guess of the password using the PE, and
   generating a shared secret.  The ability of each side to produce a
   valid finished message using a key derived from the shared secret
   allows each side to authenticates itself to the other side.

   The authenticated key exchange is dropped into the standard TLS
   message handshake by defining extensions to some of the messages.

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/4.1.%20%20TLS-PWD%20Pre-TLS%201.3"></a><a class="selflink" href="#section-4.1" id="section-4.1">4.1</a>.  TLS-PWD Pre-TLS 1.3</span>

          Client                                            Server
         --------                                          --------

          ClientHello (name)      --------&gt;

                                                        ServerHello
                                         ServerKeyExchange (commit)
                                  &lt;--------        ServerHello Done

          ClientKeyExchange (commit)
          ChangeCipherSpec
          Finished                --------&gt;

                                                   ChangeCipherSpec
                                  &lt;--------                Finished

          Application Data        &lt;-------&gt;        Application Data

                  Figure 1: Pre-TLS 1.3 TLS-PWD Handshake















<span class="grey">Harkins                       Informational                    [Page 10]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-11"></span>
<span class="grey"><a href="./rfc8492">RFC 8492</a>                      TLS Password                 February 2019</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/4.2.%20%20TLS-PWD%20in%20TLS%201.3"></a><a class="selflink" href="#section-4.2" id="section-4.2">4.2</a>.  TLS-PWD in TLS 1.3</span>

         Client                                            Server
        --------                                          --------
         ClientHello (name)
         + key_share (commit)       --------&gt;
                                                        ServerHello
                                               + key_share (commit)
                                              {EncryptedExtensions}
                                                         {Finished}
                                    &lt;--------   [Application Data*]
         {Finished}                 --------&gt;
         [Application Data]         &lt;-------&gt;    [Application Data]

                    Figure 2: TLS 1.3 TLS-PWD Handshake

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/4.3.%20%20Protecting%20the%20Username"></a><a class="selflink" href="#section-4.3" id="section-4.3">4.3</a>.  Protecting the Username</span>

   The client is required to identify herself to the server before the
   server can look up the appropriate client credential with which to
   perform the authenticated key exchange.  This has negative privacy
   implications and opens up the client to tracking and increased
   monitoring.  It is therefore useful for the client to be able to
   protect her username from passive monitors of the exchange and
   against active attack by a malicious server.  TLS-PWD provides such a
   mechanism.  Support for protected usernames is RECOMMENDED.

   To enable username protection, a server chooses a domain parameter
   set and generates an ephemeral public/private keypair.  This keypair
   SHALL only be used for username protection.  For efficiency, the
   domain parameter set used for username protection MUST be based on
   ECC.  Any ECC group that is appropriate for TLS-PWD (see
   <a href="#section-3.2.1">Section 3.2.1</a>) is suitable for this purpose, but for
   interoperability, prime256v1 (aka NIST's p256 curve) MUST be
   supported.  The domain parameter set chosen for username protection
   is independent of the domain parameter set chosen for the underlying
   key exchange -- i.e., they need not be the same.

   When the client's username and password are provisioned on the
   server, the chosen group and its public key are provisioned on the
   client.  This is stored on the client along with the server-specific
   state (e.g., the hostname) it uses to initiate a TLS-PWD exchange.
   The server uses the same group and public key with all clients.

   To protect a username, the client and server perform a static-
   ephemeral Diffie-Hellman exchange.  Since the y-coordinate is not
   necessary and eliminating it will reduce message size, compact
   representation (and therefore compact output; see [<a href="./rfc6090" title='"Fundamental Elliptic Curve Cryptography Algorithms"'>RFC6090</a>]) is used



<span class="grey">Harkins                       Informational                    [Page 11]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-12"></span>
<span class="grey"><a href="./rfc8492">RFC 8492</a>                      TLS Password                 February 2019</span>


   in the static-ephemeral Diffie-Hellman exchange.  The result of the
   Diffie-Hellman exchange is passed to the HMAC-based Key Derivation
   Function (HKDF) [<a href="./rfc5869" title='"HMAC-based Extract-and-Expand Key Derivation Function (HKDF)"'>RFC5869</a>] to create a key-encrypting key suitable for
   AES-SIV [<a href="./rfc5297" title='"Synthetic Initialization Vector (SIV) Authenticated Encryption Using the Advanced Encryption Standard (AES)"'>RFC5297</a>] (where "AES" stands for "Advanced Encryption
   Standard" and "SIV" stands for "Synthetic Initialization Vector") in
   its deterministic authenticated encryption mode.  The length of the
   key-encrypting key (1) and the hash function to use with the HKDF
   depend on the length of the prime, p, of the group used to provide
   username protection:

   o  SHA-256, SIV-128, l=256 bits: when len(p) &lt;= 256

   o  SHA-384, SIV-192, l=384 bits: when 256 &lt; len(p) &lt;= 384

   o  SHA-512, SIV-256, l=512 bits: when len(p) &gt; 384

<span class="h4"><a class="dashAnchor" name="//apple_ref/cpp/Section/4.3.1.%20%20Construction%20of%20a%20Protected%20Username"></a><a class="selflink" href="#section-4.3.1" id="section-4.3.1">4.3.1</a>.  Construction of a Protected Username</span>

   Prior to initiating a TLS-PWD exchange, the client chooses a random
   secret, c, such that 1 &lt; c &lt; (q - 1), where q is the order of the
   group from which the server's public key was generated, and it uses
   scalar-op() with the group's generator to create a public key, C.  It
   uses scalar-op() with the server's public key and c to create a
   shared secret, and it derives a key-encrypting key, k, using the
   "saltless" mode of the HKDF [<a href="./rfc5869" title='"HMAC-based Extract-and-Expand Key Derivation Function (HKDF)"'>RFC5869</a>]:

      C = scalar-op(c, G)

      Z = scalar-op(c, S)

      k = HKDF-expand(HKDF-extract(NULL, Z.x), "", l)

   where NULL indicates the salt-free invocation and "" indicates an
   empty string (i.e., there is no "context" passed to the HKDF).

   The client's username SHALL be represented as a UTF-8 encoded
   character string processed according to the rules of the OpaqueString
   profile of [<a href="./rfc8265" title='"Preparation, Enforcement, and Comparison of Internationalized Strings Representing Usernames and Passwords"'>RFC8265</a>].  The output of OpaqueString is then passed with
   the key, k, to SIV-encrypt with no Additional Authenticated Data
   (AAD) and no nonce, to produce an encrypted username, u:

      u = SIV-encrypt(k, username)

   Note: The format of the ciphertext output includes the
   authenticating SIV.






<span class="grey">Harkins                       Informational                    [Page 12]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-13"></span>
<span class="grey"><a href="./rfc8492">RFC 8492</a>                      TLS Password                 February 2019</span>


   The protected username SHALL be the concatenation of the x-coordinate
   of the client's public key, C, and the encrypted username, u.  The
   length of the x-coordinate of C MUST be equal to the length of the
   group's prime, p, prepended with zeros, if necessary.  The protected
   username is inserted into the extension_data field of the pwd_protect
   extension (see <a href="#section-4.4.3">Section 4.4.3</a>).

   To ensure that the username remains confidential, the random secret,
   c, MUST be generated from a source of random entropy; see
   <a href="#section-3.5">Section 3.5</a>.

   The length of the ciphertext output from SIV, minus the synthetic
   initialization vector, will be equal to the length of the input
   plaintext -- in this case, the username.  To further foil traffic
   analysis, it is RECOMMENDED that clients append a series of NULL
   bytes to their usernames prior to passing them to SIV-encrypt() such
   that the resulting padded length of the username is at least
   128 octets.

<span class="h4"><a class="dashAnchor" name="//apple_ref/cpp/Section/4.3.2.%20%20Recovery%20of%20a%20Protected%20Username"></a><a class="selflink" href="#section-4.3.2" id="section-4.3.2">4.3.2</a>.  Recovery of a Protected Username</span>

   A server that receives a protected username needs to recover the
   client's username prior to performing the key exchange.  To do so,
   the server computes the client's public key; completes the static-
   ephemeral Diffie-Hellman exchange; derives the key-encrypting key, k;
   and decrypts the username.

   The length of the x-coordinate of the client's public key is known
   (it is the length of the prime from the domain parameter set used to
   protect usernames) and can easily be separated from the ciphertext in
   the pwd_name extension in the ClientHello -- the first len(p) bits
   are the x-coordinate of the client's public key, and the remaining
   bits are the ciphertext.

   Since compressed representation is used by the client, the server
   MUST compute the y-coordinate of the client's public key by using the
   equation of the curve:

      y^2 = x^3 + ax + b

   and solving for y.  There are two solutions for y, but since
   compressed output is also being used, the selection is irrelevant.
   The server reconstructs the client's public value, C, from (x, y).
   If there is no solution for y or if (x, y) is not a valid point on
   the elliptic curve (see <a href="#section-3.2.1">Section 3.2.1</a>), the server MUST treat the
   ClientHello as if it did not have a password for a given username
   (see <a href="#section-4.5.1.1">Section 4.5.1.1</a>).




<span class="grey">Harkins                       Informational                    [Page 13]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-14"></span>
<span class="grey"><a href="./rfc8492">RFC 8492</a>                      TLS Password                 February 2019</span>


   The server then uses scalar-op() with the reconstructed point C and
   the private key it uses for protected passwords, s, to generate a
   shared secret, and it derives a key-encrypting key, k, in the same
   manner as that described in <a href="#section-4.3.1">Section 4.3.1</a>.

      Z = scalar-op(s, C)

      k = HKDF-expand(HKDF-extract(NULL, Z.x), "", l)

   The key, k, and the ciphertext portion of the pwd_name extension, u,
   are passed to SIV-decrypt with no AAD and no nonce, to produce the
   username:

      username = SIV-decrypt(k, u)

   If SIV-decrypt returns the symbol FAIL indicating unsuccessful
   decryption and verification, the server MUST treat the ClientHello as
   if it did not have a password for a given username (see
   <a href="#section-4.5.1.1">Section 4.5.1.1</a>).  If successful, the server has obtained the
   client's username and can process it as needed.  Any NULL octets
   added by the client prior to encryption can be easily stripped off of
   the string that represents the username.

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/4.4.%20%20Fixing%20the%20Password%20Element"></a><a class="selflink" href="#section-4.4" id="section-4.4">4.4</a>.  Fixing the Password Element</span>

   Prior to making a "commitment", both sides must generate a secret
   Element (PE) in the chosen group, using the common password-derived
   base.  The server generates the PE after it receives the ClientHello
   and chooses the particular group to use, and the client generates the
   PE prior to sending the ClientHello in TLS 1.3 and upon receipt of
   the ServerKeyExchange in TLS pre-1.3.

   Fixing the PE involves an iterative "hunting-and-pecking" technique
   using the prime from the negotiated group's domain parameter set and
   an ECC-specific or FFC-specific operation, depending on the
   negotiated group.

   To thwart side-channel attacks that attempt to determine the number
   of iterations of the hunting-and-pecking loop that are used to find
   the PE for a given password, a security parameter, m, is used to
   ensure that at least m iterations are always performed.

   First, an 8-bit counter is set to the value one (1).  Then, H is used
   to generate a password seed from the counter, the prime of the
   selected group, and the base (which is derived from the username,
   password, and, optionally, the salt; see <a href="#section-3.4">Section 3.4</a>):

   pwd-seed = H(base | counter | p)



<span class="grey">Harkins                       Informational                    [Page 14]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-15"></span>
<span class="grey"><a href="./rfc8492">RFC 8492</a>                      TLS Password                 February 2019</span>


   Next, a context is generated consisting of random information.  For
   versions of TLS less than 1.3, the context is a concatenation of the
   ClientHello random and the ServerHello random.  For TLS 1.3, the
   context is the ClientHello random:

   if (version &lt; 1.3) {
     context = ClientHello.random | ServerHello.random
   } else {
     context = ClientHello.random
   }

   Then, using the technique from <a href="#appendix-B.5.1">Appendix B.5.1</a> of [<a href="#ref-FIPS186-4">FIPS186-4</a>], the
   pwd-seed is expanded, using the Pseudorandom Function (PRF), to the
   length of the prime from the negotiated group's domain parameter set
   plus a constant, sixty-four (64), to produce an intermediate pwd-tmp,
   which is modularly reduced to create the pwd-value:

   n = len(p) + 64
   pwd-tmp = PRF(pwd-seed, "TLS-PWD Hunting And Pecking",
                 context) [0..n];
   pwd-value = (pwd-tmp mod (p - 1)) + 1

   The pwd-value is then passed to the group-specific operation, which
   either returns the selected PE or fails.  If the group-specific
   operation fails, the counter is incremented, a new pwd-seed is
   generated, and the hunting-and-pecking process continues; this
   procedure continues until the group-specific operation returns the
   PE.  After the PE has been chosen, the base is changed to a random
   number, the counter is incremented, and the hunting-and-pecking
   process continues until the counter is greater than the security
   parameter, m.

   The probability that one requires more than n iterations of the
   hunting-and-pecking loop to find an ECC PE is roughly (q/2p)^n and to
   find an FFC PE is roughly (q/p)^n, both of which rapidly approach
   zero (0) as n increases.  The security parameter, m, SHOULD be set
   sufficiently large such that the probability that finding the PE
   would take more than m iterations is sufficiently small (see
   <a href="#section-7">Section 7</a>).

   When the PE has been discovered, pwd-seed, pwd-tmp, and pwd-value
   SHALL be irretrievably destroyed.









<span class="grey">Harkins                       Informational                    [Page 15]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-16"></span>
<span class="grey"><a href="./rfc8492">RFC 8492</a>                      TLS Password                 February 2019</span>


<span class="h4"><a class="dashAnchor" name="//apple_ref/cpp/Section/4.4.1.%20%20Computing%20an%20ECC%20Password%20Element"></a><a class="selflink" href="#section-4.4.1" id="section-4.4.1">4.4.1</a>.  Computing an ECC Password Element</span>

   The group-specific operation for ECC groups uses pwd-value, pwd-seed,
   and the equation for the curve to produce the PE.  First, pwd-value
   is used directly as the x-coordinate, x, with the equation for the
   elliptic curve, with parameters a and b from the domain parameter set
   of the curve, to solve for a y-coordinate, y.  If there is no
   solution to the quadratic equation, this operation fails and the
   hunting-and-pecking process continues.  If a solution is found, then
   an ambiguity exists, as there are technically two solutions to the
   equation, and pwd-seed is used to unambiguously select one of them.
   If the low-order bit of pwd-seed is equal to the low-order bit of y,
   then a candidate PE is defined as the point (x, y); if the low-order
   bit of pwd-seed differs from the low-order bit of y, then a candidate
   PE is defined as the point (x, p - y), where p is the prime over
   which the curve is defined.  The candidate PE becomes the PE, a
   random number is used instead of the base, and the hunting-and-
   pecking process continues until it has looped through m iterations,
   where m is a suitably large number to prevent side-channel attacks
   (see [<a href="./rfc7664" title='"Dragonfly Key Exchange"'>RFC7664</a>]).































<span class="grey">Harkins                       Informational                    [Page 16]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-17"></span>
<span class="grey"><a href="./rfc8492">RFC 8492</a>                      TLS Password                 February 2019</span>


   Algorithmically, the process looks like this:

     found = 0
     counter = 0
     n = len(p) + 64
     if (version &lt; 1.3)
       context = ClientHello.random | ServerHello.random
     } else {
       context = ClientHello.random
     }
     do {
       counter = counter + 1
       seed = H(base | counter | p)
       tmp = PRF(seed, "TLS-PWD Hunting And Pecking", context) [0..n]
       val = (tmp mod (p - 1)) + 1
       if ( (val^3 + a*val + b) mod p is a quadratic residue)
         then
         if (found == 0)
         then
           x = val
           save = seed
           found = 1
           base = random()
         fi
       fi
     } while ((found == 0) || (counter &lt;= m))
     y = sqrt(x^3 + a*x + b) mod p
     if ( lsb(y) == lsb(save))
     then
       PE = (x, y)
     else
       PE = (x, p - y)
     fi

                    Figure 3: Fixing PE for ECC Groups

   Checking whether a value is a quadratic residue modulo a prime can
   leak information about that value in a side-channel attack.
   Therefore, it is RECOMMENDED that the technique used to determine if
   the value is a quadratic residue modulo p first blind the value with
   a random number so that the blinded value can take on all numbers
   between 1 and (p - 1) with equal probability.  Determining the
   quadratic residue in a fashion that resists leakage of information is
   handled by flipping a coin and multiplying the blinded value by
   either a random quadratic residue or a random quadratic nonresidue
   and checking whether the multiplied value is a quadratic residue or a
   quadratic nonresidue modulo p, respectively.  The random residue and




<span class="grey">Harkins                       Informational                    [Page 17]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-18"></span>
<span class="grey"><a href="./rfc8492">RFC 8492</a>                      TLS Password                 February 2019</span>


   nonresidue can be calculated prior to hunting and pecking by
   calculating the Legendre symbol on random values until they are
   found:

   do {
     qr = random()
   } while ( lgr(qr, p) != 1)

   do {
     qnr = random()
   } while ( lgr(qnr, p) != -1)

   Algorithmically, the masking technique to find out whether a value is
   a quadratic residue modulo a prime or not looks like this:

   is_quadratic_residue (val, p) {
       r = (random() mod (p - 1)) + 1
       num = (val * r * r) mod p
       if ( lsb(r) == 1 )
          num = (num * qr) mod p
          if ( lgr(num, p) == 1)
          then
             return TRUE
          fi
       else
          num = (num * qnr) mod p
          if ( lgr(num, p) == -1)
          then
             return TRUE
          fi
       fi
       return FALSE
   }

   The random quadratic residue and quadratic nonresidue (qr and qnr
   above) can be used for all the hunting-and-pecking loops, but the
   blinding value, r, MUST be chosen randomly for each loop.

<span class="h4"><a class="dashAnchor" name="//apple_ref/cpp/Section/4.4.2.%20%20Computing%20an%20FFC%20Password%20Element"></a><a class="selflink" href="#section-4.4.2" id="section-4.4.2">4.4.2</a>.  Computing an FFC Password Element</span>

   The group-specific operation for FFC groups takes the prime (p) and
   the order (q) from the group's domain parameter set and the variable
   pwd-value to directly produce a candidate PE, by exponentiating the
   pwd-value to the value ((p - 1)/q) modulo p.  See <a href="#section-3.2.2">Section 3.2.2</a> when
   the order is not part of the defined domain parameter set.  If the
   result is greater than one (1), the candidate PE becomes the PE, and





<span class="grey">Harkins                       Informational                    [Page 18]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-19"></span>
<span class="grey"><a href="./rfc8492">RFC 8492</a>                      TLS Password                 February 2019</span>


   the hunting-and-pecking process continues until it has looped through
   m iterations, where m is a suitably large number to prevent
   side-channel attacks (see [<a href="./rfc7664" title='"Dragonfly Key Exchange"'>RFC7664</a>]).

   Algorithmically, the process looks like this:

     found = 0
     counter = 0
     n = len(p) + 64
     if (version &lt; 1.3)
       context = ClientHello.random | ServerHello.random
     } else {
       context = ClientHello.random
     }
     do {
       counter = counter + 1
       pwd-seed = H(base | counter | p)
       pwd-tmp = PRF(pwd-seed, "TLS-PWD Hunting And Pecking",
                     context) [0..n]
       pwd-value = (pwd-tmp mod (p - 1)) + 1
       PE = pwd-value^((p - 1)/q) mod p
       if (PE &gt; 1)
       then
         found = 1
         base = random()
       fi
     } while ((found == 0) || (counter &lt;= m))

                    Figure 4: Fixing PE for FFC Groups

<span class="h4"><a class="dashAnchor" name="//apple_ref/cpp/Section/4.4.3.%20%20Password%20Naming"></a><a class="selflink" href="#section-4.4.3" id="section-4.4.3">4.4.3</a>.  Password Naming</span>

   The client is required to identify herself to the server by adding
   either a pwd_protect or pwd_clear extension to her ClientHello
   message, depending on whether the client wishes to protect her
   username (see <a href="#section-4.3">Section 4.3</a>) or not, respectively.  The pwd_protect and
   pwd_clear extensions use the standard mechanism defined in [<a href="./rfc5246" title='"The Transport Layer Security (TLS) Protocol Version 1.2"'>RFC5246</a>].
   The "extension data" field of the extension SHALL contain a pwd_name,
   which is used to identify the password shared between the client and
   server.  If username protection is performed and the ExtensionType is
   pwd_protect, the contents of the pwd_name SHALL be constructed
   according to <a href="#section-4.3.1">Section 4.3.1</a>.

      enum { pwd_protect(29), pwd_clear(30) } ExtensionType;

      opaque pwd_name&lt;1..2^8-1&gt;;





<span class="grey">Harkins                       Informational                    [Page 19]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-20"></span>
<span class="grey"><a href="./rfc8492">RFC 8492</a>                      TLS Password                 February 2019</span>


   An unprotected pwd_name SHALL be a UTF-8 encoded character string
   processed according to the rules of the OpaqueString profile of
   [<a href="./rfc8265" title='"Preparation, Enforcement, and Comparison of Internationalized Strings Representing Usernames and Passwords"'>RFC8265</a>], and a protected pwd_name SHALL be a string of bits.

<span class="h4"><a class="dashAnchor" name="//apple_ref/cpp/Section/4.4.4.%20%20Generating%20TLS-PWD%20Commit"></a><a class="selflink" href="#section-4.4.4" id="section-4.4.4">4.4.4</a>.  Generating TLS-PWD Commit</span>

   The scalar and Element that comprise each peer's "commitment" are
   generated as follows.

   First, two random numbers, called "private" and "mask", between zero
   and the order of the group (exclusive) are generated.  If their sum
   modulo the order of the group, q, equals zero (0) or one (1), the
   numbers must be thrown away and new random numbers generated.  If
   their sum modulo the order of the group, q, is greater than one, the
   sum becomes the scalar.

      scalar = (private + mask) mod q

   The Element is then calculated as the inverse of the group's scalar
   operation (see the group-specific operations discussed in
   <a href="#section-3.2">Section 3.2</a>) with the mask and PE.

      Element = inverse(scalar-op(mask, PE))

   After calculation of the scalar and Element, the mask SHALL be
   irretrievably destroyed.

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/4.5.%20%20Changes%20to%20Handshake%20Message%20Contents"></a><a class="selflink" href="#section-4.5" id="section-4.5">4.5</a>.  Changes to Handshake Message Contents</span>

<span class="h4"><a class="dashAnchor" name="//apple_ref/cpp/Section/4.5.1.%20%20Pre-1.3%20TLS"></a><a class="selflink" href="#section-4.5.1" id="section-4.5.1">4.5.1</a>.  Pre-1.3 TLS</span>

<span class="h5"><a class="dashAnchor" name="//apple_ref/cpp/Section/4.5.1.1.%20%20ClientHello%20Changes"></a><a class="selflink" href="#section-4.5.1.1" id="section-4.5.1.1">4.5.1.1</a>.  ClientHello Changes</span>

   A client offering a PWD ciphersuite MUST include one of the pwd_name
   extensions from <a href="#section-4.4.3">Section 4.4.3</a> in her ClientHello.

   If a server does not have a password for a client identified by the
   username either extracted from the pwd_name (if unprotected) or
   recovered using the technique provided in <a href="#section-4.3.2">Section 4.3.2</a> (if
   protected), or if recovery of a protected username fails, the server
   SHOULD hide that fact by simulating the protocol -- putting random
   data in the PWD-specific components of the ServerKeyExchange -- and
   then rejecting the client's finished message with a "bad_record_mac"
   alert [<a href="./rfc8446" title='"The Transport Layer Security (TLS) Protocol Version 1.3"'>RFC8446</a>].  To properly effect a simulated TLS-PWD exchange, an
   appropriate delay SHOULD be inserted between receipt of the
   ClientHello and response of the ServerHello.  Alternately, a server





<span class="grey">Harkins                       Informational                    [Page 20]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-21"></span>
<span class="grey"><a href="./rfc8492">RFC 8492</a>                      TLS Password                 February 2019</span>


   MAY choose to terminate the exchange if a password is not found.  The
   security implication of terminating the exchange is to expose to an
   attacker whether a username is valid or not.

   The server decides on a group to use with the named user (see
   <a href="#section-9">Section 9</a>) and generates the PE according to <a href="#section-4.4.2">Section 4.4.2</a>.

<span class="h5"><a class="dashAnchor" name="//apple_ref/cpp/Section/4.5.1.2.%20%20ServerKeyExchange%20Changes"></a><a class="selflink" href="#section-4.5.1.2" id="section-4.5.1.2">4.5.1.2</a>.  ServerKeyExchange Changes</span>

   The domain parameter set for the selected group MUST be explicitly
   specified by name in the ServerKeyExchange.  ECC groups are specified
   using the NamedCurve enumeration of [<a href="./rfc8422" title='"Elliptic Curve Cryptography (ECC) Cipher Suites for Transport Layer Security (TLS) Versions 1.2 and Earlier"'>RFC8422</a>], and FFC groups are
   specified using the NamedGroup extensions added by [<a href="./rfc7919" title='"Negotiated Finite Field Diffie-Hellman Ephemeral Parameters for Transport Layer Security (TLS)"'>RFC7919</a>] to the
   "TLS Supported Groups" registry in [<a href="#ref-TLS_REG" title='"Transport Layer Security (TLS) Parameters"'>TLS_REG</a>].  In addition to the
   group specification, the ServerKeyExchange also contains the server's
   "commitment" in the form of a scalar and Element, and the salt that
   was used to store the user's password.

   Two new values have been added to the enumerated KeyExchangeAlgorithm
   to indicate TLS-PWD using FFC and TLS-PWD using ECC: ff_pwd and
   ec_pwd, respectively.

                enum { ff_pwd, ec_pwd } KeyExchangeAlgorithm;

                struct {
                  opaque salt&lt;1..2^8-1&gt;;
                  NamedGroup ff_group;
                  opaque ff_selement&lt;1..2^16-1&gt;;
                  opaque ff_sscalar&lt;1..2^16-1&gt;;
                } ServerFFPWDParams;

                struct {
                  opaque salt&lt;1..2^8-1&gt;;
                  ECParameters curve_params;
                  ECPoint ec_selement;
                  opaque ec_sscalar&lt;1..2^8-1&gt;;
                } ServerECPWDParams;

                struct {
                  select (KeyExchangeAlgorithm) {
                    case ec_pwd:
                      ServerECPWDParams params;
                    case ff_pwd:
                      ServerFFPWDParams params;
                  };
                } ServerKeyExchange;





<span class="grey">Harkins                       Informational                    [Page 21]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-22"></span>
<span class="grey"><a href="./rfc8492">RFC 8492</a>                      TLS Password                 February 2019</span>


<span class="h6"><a class="dashAnchor" name="//apple_ref/cpp/Section/4.5.1.2.1.%20%20Generation%20of%20ServerKeyExchange"></a><a class="selflink" href="#section-4.5.1.2.1" id="section-4.5.1.2.1">4.5.1.2.1</a>.  Generation of ServerKeyExchange</span>

   The scalar and Element referenced in this section are derived
   according to <a href="#section-4.4.4">Section 4.4.4</a>.

<span class="h6"><a class="dashAnchor" name="//apple_ref/cpp/Section/4.5.1.2.1.1.%20%20ECC%20ServerKeyExchange"></a><a class="selflink" href="#section-4.5.1.2.1.1" id="section-4.5.1.2.1.1">4.5.1.2.1.1</a>.  ECC ServerKeyExchange</span>

   ECC domain parameters are specified in the ECParameters component of
   the ECC-specific ServerKeyExchange as defined in [<a href="./rfc8422" title='"Elliptic Curve Cryptography (ECC) Cipher Suites for Transport Layer Security (TLS) Versions 1.2 and Earlier"'>RFC8422</a>].  The
   scalar SHALL become the ec_sscalar component, and the Element SHALL
   become the ec_selement of the ServerKeyExchange.  If the client
   requested a specific point format (compressed or uncompressed) with
   the Supported Point Formats Extension (see [<a href="./rfc8422" title='"Elliptic Curve Cryptography (ECC) Cipher Suites for Transport Layer Security (TLS) Versions 1.2 and Earlier"'>RFC8422</a>]) in its
   ClientHello, the Element MUST be formatted in the ec_selement to
   conform to that request.  If the client offered (an) elliptic
   curve(s) in its ClientHello using the Supported Elliptic Curves
   Extension, the server MUST include (one of the) named curve(s) in the
   ECParameters field in the ServerKeyExchange and the key exchange
   operations specified in <a href="#section-4.5.1.2.1">Section 4.5.1.2.1</a> MUST use that group.

   As mentioned in <a href="#section-3.2.1">Section 3.2.1</a>, characteristic-2 curves and curves
   with a co-factor greater than one (1) SHALL NOT be used by TLS-PWD.

<span class="h6"><a class="dashAnchor" name="//apple_ref/cpp/Section/4.5.1.2.1.2.%20%20FFC%20ServerKeyExchange"></a><a class="selflink" href="#section-4.5.1.2.1.2" id="section-4.5.1.2.1.2">4.5.1.2.1.2</a>.  FFC ServerKeyExchange</span>

   FFC domain parameters use the NamedGroup extension specified in
   [<a href="./rfc7919" title='"Negotiated Finite Field Diffie-Hellman Ephemeral Parameters for Transport Layer Security (TLS)"'>RFC7919</a>].  The scalar SHALL become the ff_sscalar component, and the
   Element SHALL become the ff_selement in the FFC-specific
   ServerKeyExchange.

   As mentioned in <a href="#section-3.2.2">Section 3.2.2</a>, if the prime is a safe prime and no
   order is included in the domain parameter set, the order added to the
   ServerKeyExchange SHALL be the prime minus one divided by two --
   (p - 1)/2.

<span class="h6"><a class="dashAnchor" name="//apple_ref/cpp/Section/4.5.1.2.2.%20%20Processing%20of%20ServerKeyExchange"></a><a class="selflink" href="#section-4.5.1.2.2" id="section-4.5.1.2.2">4.5.1.2.2</a>.  Processing of ServerKeyExchange</span>

   Upon receipt of the ServerKeyExchange, the client decides whether to
   support the indicated group or not.  If the client decides to support
   the indicated group, the server's "commitment" MUST be validated by
   ensuring that 1) the server's scalar value is greater than one (1)
   and less than the order of the group, q and 2) the Element is valid
   for the chosen group (see Sections <a href="#section-3.2.1">3.2.1</a> and <a href="#section-3.2.2">3.2.2</a> for how to
   determine whether an Element is valid for the particular group.  Note
   that if the Element is a compressed point on an elliptic curve, it
   MUST be uncompressed before checking its validity).





<span class="grey">Harkins                       Informational                    [Page 22]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-23"></span>
<span class="grey"><a href="./rfc8492">RFC 8492</a>                      TLS Password                 February 2019</span>


   If the group is acceptable and the server's "commitment" has been
   successfully validated, the client extracts the salt from the
   ServerKeyExchange and generates the PE according to Sections <a href="#section-3.4">3.4</a> and
   4.4.2.  If the group is not acceptable or the server's "commitment"
   failed validation, the exchange MUST be aborted.

<span class="h5"><a class="dashAnchor" name="//apple_ref/cpp/Section/4.5.1.3.%20%20ClientKeyExchange%20Changes"></a><a class="selflink" href="#section-4.5.1.3" id="section-4.5.1.3">4.5.1.3</a>.  ClientKeyExchange Changes</span>

   When the value of KeyExchangeAlgorithm is either ff_pwd or ec_pwd,
   the ClientKeyExchange is used to convey the client's "commitment" to
   the server.  It therefore contains a scalar and an Element.

                     struct {
                       opaque ff_celement&lt;1..2^16-1&gt;;
                       opaque ff_cscalar&lt;1..2^16-1&gt;;
                     } ClientFFPWDParams;

                     struct {
                       ECPoint ec_celement;
                       opaque ec_cscalar&lt;1..2^8-1&gt;;
                     } ClientECPWDParams;

                     struct {
                       select (KeyExchangeAlgorithm) {
                         case ff_pwd: ClientFFPWDParams;
                         case ec_pwd: ClientECPWDParams;
                       } exchange_keys;
                     } ClientKeyExchange;

<span class="h6"><a class="dashAnchor" name="//apple_ref/cpp/Section/4.5.1.3.1.%20%20Generation%20of%20ClientKeyExchange"></a><a class="selflink" href="#section-4.5.1.3.1" id="section-4.5.1.3.1">4.5.1.3.1</a>.  Generation of ClientKeyExchange</span>

   The client's scalar and Element are generated in the manner described
   in <a href="#section-4.5.1.2.1">Section 4.5.1.2.1</a>.

   For an FFC group, the scalar SHALL become the ff_cscalar component
   and the Element SHALL become the ff_celement in the FFC-specific
   ClientKeyExchange.

   For an ECC group, the scalar SHALL become the ec_cscalar component
   and the Element SHALL become the ec_celement in the ECC-specific
   ClientKeyExchange.  If the client requested a specific point format
   (compressed or uncompressed) with the Supported Point Formats
   Extension in its ClientHello, then the Element MUST be formatted in
   the ec_celement to conform to its initial request.







<span class="grey">Harkins                       Informational                    [Page 23]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-24"></span>
<span class="grey"><a href="./rfc8492">RFC 8492</a>                      TLS Password                 February 2019</span>


<span class="h6"><a class="dashAnchor" name="//apple_ref/cpp/Section/4.5.1.3.2.%20%20Processing%20of%20ClientKeyExchange"></a><a class="selflink" href="#section-4.5.1.3.2" id="section-4.5.1.3.2">4.5.1.3.2</a>.  Processing of ClientKeyExchange</span>

   Upon receipt of the ClientKeyExchange, the server must validate the
   client's "commitment" by ensuring that 1) the client's scalar and
   Element differ from the server's scalar and Element, 2) the client's
   scalar value is greater than one (1) and less than the order of the
   group, q, and 3) the Element is valid for the chosen group (see
   Sections <a href="#section-3.2.1">3.2.1</a> and <a href="#section-3.2.2">3.2.2</a> for how to determine whether an Element is
   valid for a particular group.  Note that if the Element is a
   compressed point on an elliptic curve, it MUST be uncompressed before
   checking its validity).  If any of these three conditions are not
   met, the server MUST abort the exchange.

<span class="h4"><a class="dashAnchor" name="//apple_ref/cpp/Section/4.5.2.%20%20TLS%201.3"></a><a class="selflink" href="#section-4.5.2" id="section-4.5.2">4.5.2</a>.  TLS 1.3</span>

<span class="h5"><a class="dashAnchor" name="//apple_ref/cpp/Section/4.5.2.1.%20%20TLS%201.3%20KeyShare"></a><a class="selflink" href="#section-4.5.2.1" id="section-4.5.2.1">4.5.2.1</a>.  TLS 1.3 KeyShare</span>

   TLS 1.3 clients and servers convey their commit values in a
   "key_share" extension.  The structure of this extension SHALL be:

             enum { ff_pwd, ec_pwd } KeyExchangeAlgorithm;

             struct {
                 select (KeyExchangeAlgorithm) {
                     case ec_pwd:
                         opaque elemX[coordinate_length];
                         opaque elemY[coordinate_length];
                     case ff_pwd:
                         opaque elem[coordinate_length];
                  };
                  opaque scalar&lt;1..2^8-1&gt;
             } PWDKeyShareEntry;

             struct {
                  NamedGroup group;
                  PWDKeyShareEntry pwd_key_exchange&lt;1..2^16-1&gt;;
             } KeyShareEntry;

<span class="h5"><a class="dashAnchor" name="//apple_ref/cpp/Section/4.5.2.2.%20%20ClientHello%20Changes"></a><a class="selflink" href="#section-4.5.2.2" id="section-4.5.2.2">4.5.2.2</a>.  ClientHello Changes</span>

   The ClientHello message MUST include a pwd_name extension from
   <a href="#section-4.4.3">Section 4.4.3</a> and it MUST include a key_share extension from
   <a href="#section-4.5.2.1">Section 4.5.2.1</a>.

   Upon receipt of a ClientHello, the server MUST validate the key_share
   extension_data [<a href="./rfc8446" title='"The Transport Layer Security (TLS) Protocol Version 1.3"'>RFC8446</a>] to ensure that the scalar value is greater
   than one (1) and less than the order of the group q, and that the
   Element is valid for the chosen group (see Sections <a href="#section-3.2.1">3.2.1</a> and <a href="#section-3.2.2">3.2.2</a>).



<span class="grey">Harkins                       Informational                    [Page 24]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-25"></span>
<span class="grey"><a href="./rfc8492">RFC 8492</a>                      TLS Password                 February 2019</span>


   If a server does not have a password for a client identified by the
   username either extracted from the pwd_name (if unprotected) or
   recovered using the technique in <a href="#section-4.3.2">Section 4.3.2</a> (if protected), or if
   recovery of a protected username fails, the server SHOULD hide that
   fact by simulating the protocol -- putting random data in the
   PWD-specific components of its KeyShareEntry -- and then rejecting
   the client's finished message with a "bad_record_mac" alert.  To
   properly effect a simulated TLS-PWD exchange, an appropriate delay
   SHOULD be inserted between receipt of the ClientHello and response of
   the ServerHello.  Alternately, a server MAY choose to terminate the
   exchange if a password is not found.  The security implication of
   terminating the exchange is to expose to an attacker whether a
   username is valid or not.

<span class="h5"><a class="dashAnchor" name="//apple_ref/cpp/Section/4.5.2.3.%20%20ServerHello%20Changes"></a><a class="selflink" href="#section-4.5.2.3" id="section-4.5.2.3">4.5.2.3</a>.  ServerHello Changes</span>

   If the server supports TLS-PWD, agrees with the group chosen by the
   client, and finds an unsalted password indicated by the pwd_name
   extension of the received ClientHello, its ServerHello MUST contain a
   key_share extension from <a href="#section-4.5.2.1">Section 4.5.2.1</a> in the same group as that
   chosen by the client.

   Upon receipt of a ServerHello, the client MUST validate the key_share
   extension_data to ensure that the scalar value is greater than
   one (1) and less than the order of the group q, and that the Element
   is valid for the chosen group (see Sections <a href="#section-3.2.1">3.2.1</a> and <a href="#section-3.2.2">3.2.2</a>).

<span class="h5"><a class="dashAnchor" name="//apple_ref/cpp/Section/4.5.2.4.%20%20HelloRetryRequest%20Changes"></a><a class="selflink" href="#section-4.5.2.4" id="section-4.5.2.4">4.5.2.4</a>.  HelloRetryRequest Changes</span>

   The server sends this message in response to a ClientHello if it
   desires a different group or if the password identified by the
   client's password identified by pwd_name is salted.

   A different group is indicated by adding the
   KeyShareHelloRetryRequest extension to the HelloRetryRequest.  The
   indication of a salted password, and the salt used, is done by adding
   the following structure:

                 enum { password_salt(31) } ExtensionType;

                 struct {
                     opaque pwd_salt&lt;2^16-1&gt;;
                 } password_salt;

   A client that receives a HelloRetryRequest indicating the password
   salt SHALL delete its computed PE and derive another version using
   the salt prior to sending another ClientHello.




<span class="grey">Harkins                       Informational                    [Page 25]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-26"></span>
<span class="grey"><a href="./rfc8492">RFC 8492</a>                      TLS Password                 February 2019</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/4.6.%20%20Computing%20the%20Shared%20Secret"></a><a class="selflink" href="#section-4.6" id="section-4.6">4.6</a>.  Computing the Shared Secret</span>

   The client and server use their private value as calculated in
   <a href="#section-4.4.4">Section 4.4.4</a> with the other party's Element and scalar for the
   ServerHello or ClientHello, respectively (here denoted "Peer_Element"
   and "peer_scalar") to generate the shared secret z.

           z = F(scalar-op(private,
                           elem-op(Peer_Element,
                                   scalar-op(peer_scalar, PE))))

   For TLS versions prior to 1.3, the intermediate value, z, is then
   used as the premaster secret after any leading bytes of z that
   contain all zero bits have been stripped off.  For TLS version 1.3,
   leading zero bytes are retained, and the intermediate value z is used
   as the (EC)DHE input in the key schedule.

<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/5.%20%20Ciphersuite%20Definition"></a><a class="selflink" href="#section-5" id="section-5">5</a>.  Ciphersuite Definition</span>

   This memo adds the following ciphersuites:

      CipherSuite TLS_ECCPWD_WITH_AES_128_GCM_SHA256 = (0xC0,0xB0);

      CipherSuite TLS_ECCPWD_WITH_AES_256_GCM_SHA384 = (0xC0,0xB1);

      CipherSuite TLS_ECCPWD_WITH_AES_128_CCM_SHA256 = (0xC0,0xB2);

      CipherSuite TLS_ECCPWD_WITH_AES_256_CCM_SHA384 = (0xC0,0xB3);

   Implementations conforming to this specification MUST support the
   TLS_ECCPWD_WITH_AES_128_GCM_SHA256 ciphersuite; they SHOULD support
   the remaining ciphersuites.

   When negotiated with a version of TLS prior to 1.2, the PRF from that
   earlier version is used; when the negotiated version of TLS is TLS
   1.2, the PRF is the TLS 1.2 PRF [<a href="./rfc5246" title='"The Transport Layer Security (TLS) Protocol Version 1.2"'>RFC5246</a>], using the hash function
   indicated by the ciphersuite; when the negotiated version of TLS is
   TLS 1.3, the PRF is the Derive-Secret function from <a href="./rfc8446#section-7.1">SectionÂ 7.1 of
   [RFC8446]</a>.  Regardless of the TLS version, the TLS-PWD random
   function, H, is always instantiated with the hash algorithm indicated
   by the ciphersuite.

   For those ciphersuites that use Cipher Block Chaining (CBC)
   [<a href="#ref-SP800-38A">SP800-38A</a>] mode, the MAC is HMAC [<a href="./rfc2104" title='"HMAC: Keyed-Hashing for Message Authentication"'>RFC2104</a>] with the hash function
   indicated by the ciphersuite.






<span class="grey">Harkins                       Informational                    [Page 26]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-27"></span>
<span class="grey"><a href="./rfc8492">RFC 8492</a>                      TLS Password                 February 2019</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/6.%20%20IANA%20Considerations"></a><a class="selflink" href="#section-6" id="section-6">6</a>.  IANA Considerations</span>

   IANA has assigned three values for new TLS extension types from the
   "TLS ExtensionType Values" registry defined in [<a href="./rfc8446" title='"The Transport Layer Security (TLS) Protocol Version 1.3"'>RFC8446</a>] and
   [<a href="./rfc8447" title='"IANA Registry Updates for TLS and DTLS"'>RFC8447</a>].  They are pwd_protect (29), pwd_clear (30), and
   password_salt (31).  See Sections <a href="#section-4.5.1.1">4.5.1.1</a> and <a href="#section-4.5.2.2">4.5.2.2</a> for more
   information.

   In summary, the following rows have been added to the "TLS
   ExtensionType Values" registry:

           +-------+----------------+-------------+-----------+
           | Value | Extension Name |   TLS 1.3   | Reference |
           +-------+----------------+-------------+-----------+
           |   29  |  pwd_protect   |      CH     |  <a href="./rfc8492">RFC 8492</a> |
           |   30  |   pwd_clear    |      CH     |  <a href="./rfc8492">RFC 8492</a> |
           |   31  | password_salt  | CH, SH, HRR |  <a href="./rfc8492">RFC 8492</a> |
           +-------+----------------+-------------+-----------+

   IANA has assigned the following ciphersuites from the "TLS Cipher
   Suites" registry defined in [<a href="./rfc8446" title='"The Transport Layer Security (TLS) Protocol Version 1.3"'>RFC8446</a>] and [<a href="./rfc8447" title='"IANA Registry Updates for TLS and DTLS"'>RFC8447</a>]:

      CipherSuite TLS_ECCPWD_WITH_AES_128_GCM_SHA256 = (0xC0,0xB0);

      CipherSuite TLS_ECCPWD_WITH_AES_256_GCM_SHA384 = (0xC0,0xB1);

      CipherSuite TLS_ECCPWD_WITH_AES_128_CCM_SHA256 = (0xC0,0xB2);

      CipherSuite TLS_ECCPWD_WITH_AES_256_CCM_SHA384 = (0xC0,0xB3);

   The "DTLS-OK" column in the registry has been set to "Y", and the
   "Recommended" column has been set to "N" for all ciphersuites defined
   in this memo.

<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/7.%20%20Security%20Considerations"></a><a class="selflink" href="#section-7" id="section-7">7</a>.  Security Considerations</span>

   A security proof of this key exchange in the random oracle model is
   found in [<a href="#ref-lanskro" title='"On the Provable Security of the Dragonfly Protocol"'>lanskro</a>].

   A passive attacker against this protocol will see the
   ServerKeyExchange and the ClientKeyExchange (in TLS pre-1.3), or the
   KeyShare (from TLS 1.3), containing the scalar and Element of the
   server and the client, respectively.  The client and server
   effectively hide their secret private value by masking it modulo the
   order of the selected group.  If the order is "q", then there are
   approximately "q" distinct pairs of numbers that will sum to the
   scalar values observed.  It is possible for an attacker to iterate
   through all such values, but for a large value of "q", this



<span class="grey">Harkins                       Informational                    [Page 27]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-28"></span>
<span class="grey"><a href="./rfc8492">RFC 8492</a>                      TLS Password                 February 2019</span>


   exhaustive search technique is computationally infeasible.  The
   attacker would have a better chance in solving the discrete logarithm
   problem, which we have already assumed (see <a href="#section-3.5">Section 3.5</a>) to be an
   intractable problem.

   A passive attacker can take the Element from the ServerKeyExchange or
   the ClientKeyExchange (in TLS pre-1.3), or from the KeyShare (from
   TLS 1.3), and try to determine the random "mask" value used in its
   construction and then recover the other party's "private" value from
   the scalar in the same message.  But this requires the attacker to
   solve the discrete logarithm problem, which we assumed was
   intractable.

   Both the client and the server obtain a shared secret based on a
   secret group Element and the private information they contributed to
   the exchange.  The secret group Element is based on the password.  If
   they do not share the same password, they will be unable to derive
   the same secret group Element, and if they don't generate the same
   secret group Element, they will be unable to generate the same shared
   secret.  Seeing a finished message will not provide any additional
   advantage of attack, since it is generated with the unknowable
   secret.

   In TLS pre-1.3, an active attacker impersonating the client can
   induce a server to send a ServerKeyExchange containing the server's
   scalar and Element.  The attacker can attempt to generate a
   ClientKeyExchange and send it to the server, but she is required to
   send a finished message first; therefore, the only information she
   can obtain in this attack is less than the information she can obtain
   from a passive attack, so this particular active attack is not very
   fruitful.

   In TLS pre-1.3, an active attacker can impersonate the server and
   send a forged ServerKeyExchange after receiving the ClientHello.  The
   attacker then waits until it receives the ClientKeyExchange and
   finished message from the client.  Now the attacker can attempt to
   run through all possible values of the password, computing the PE
   (see <a href="#section-4.4">Section 4.4</a>), computing candidate premaster secrets (see
   <a href="#section-4.6">Section 4.6</a>), and attempting to recreate the client's finished
   message.

   But the attacker committed to a single guess of the password with her
   forged ServerKeyExchange.  That value was used by the client in her
   computation of the premaster secret, which was used to produce the
   finished message.  Any guess of the password that differs from the
   password used in the forged ServerKeyExchange would result in each
   side using a different PE in the computation of the premaster secret;
   therefore, the finished message cannot be verified as correct, even



<span class="grey">Harkins                       Informational                    [Page 28]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-29"></span>
<span class="grey"><a href="./rfc8492">RFC 8492</a>                      TLS Password                 February 2019</span>


   if a subsequent guess, while running through all possible values, was
   correct.  The attacker gets one guess, and one guess only, per active
   attack.

   Instead of attempting to guess at the password, an attacker can
   attempt to determine the PE and then launch an attack.  But the PE is
   determined by the output of the random function, H, which is
   indistinguishable from a random source, since H is assumed to be a
   "random oracle" (<a href="#section-3.5">Section 3.5</a>).  Therefore, each Element of the finite
   cyclic group will have an equal probability of being the PE.  The
   probability of guessing the PE will be 1/q, where q is the order of
   the group.  For a large value of "q", this will be computationally
   infeasible.

   The implications of resistance to dictionary attacks are significant.
   An implementation can provision a password in a practical and
   realistic manner -- i.e., it MAY be a character string, and it MAY be
   relatively short -- and still maintain security.  The nature of the
   pool of potential passwords determines the size of the pool, D, and
   countermeasures can prevent an attacker from determining the password
   in the only possible way: repeated, active, guessing attacks.  For
   example, a simple four-character string using lowercase English
   characters, and assuming random selection of those characters, will
   result in D of over four hundred thousand.  An attacker would need to
   mount over one hundred thousand active, guessing attacks (which will
   easily be detected) before gaining any significant advantage in
   determining the pre-shared key.

   Countermeasures to deal with successive active, guessing attacks are
   only possible by noticing that a certain username is failing
   repeatedly over a certain period of time.  Attacks that attempt to
   find a password for a random user are more difficult to detect.  For
   instance, if a device uses a serial number as a username and the pool
   of potential passwords is sufficiently small, a more effective attack
   would be to select a password and try all potential "users" to
   disperse the attack and confound countermeasures.  It is therefore
   RECOMMENDED that implementations of TLS-PWD keep track of the total
   number of failed authentications, regardless of username, in an
   effort to detect and thwart this type of attack.

   The benefits of resistance to dictionary attacks can be lessened by a
   client using the same passwords with multiple servers.  An attacker
   could redirect a session from one server to the other if the attacker
   knew that the intended server stored the same password for the client
   as another server.






<span class="grey">Harkins                       Informational                    [Page 29]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-30"></span>
<span class="grey"><a href="./rfc8492">RFC 8492</a>                      TLS Password                 February 2019</span>


   An adversary that has access to, and a considerable amount of control
   over, a client or server could attempt to mount a side-channel attack
   to determine the number of times it took for a certain password (plus
   client random and server random) to select a PE.  Each such attack
   could result in a successive "paring down" of the size of the pool of
   potential passwords, resulting in a manageably small set from which
   to launch a series of active attacks to determine the password.  A
   security parameter, m, is used to normalize the amount of work
   necessary to determine the PE (see <a href="#section-4.4">Section 4.4</a>).  The probability
   that a password will require more than m iterations is roughly
   (q/2p)^m for ECC groups and (q/p)^m for FFC groups, so it is possible
   to mitigate side-channel attacks at the expense of a constant cost
   per connection attempt.  But if a particular password requires more
   than k iterations, it will leak k bits of information to the
   side-channel attacker; for some dictionaries, this will uniquely
   identify the password.  Therefore, the security parameter, m, needs
   to be set with great care.  It is RECOMMENDED that an implementation
   set the security parameter, m, to a value of at least forty (40),
   which will put the probability that more than forty iterations are
   needed in the order of one in one trillion (1:1,000,000,000,000).

   A database of salted passwords prevents an adversary who gains access
   to the database from learning the client's password; it does not
   prevent such an adversary from impersonating the client back to the
   server.  Each side uses the salted password, called the base, as the
   authentication credential, so the database of salted passwords MUST
   be afforded the security of a database of plaintext passwords.

   Authentication is performed by proving knowledge of the password.
   Any third party that knows the password shared by the client and
   server can impersonate one to the other.

   The static-ephemeral Diffie-Hellman exchange used to protect
   usernames requires the server to reuse its Diffie-Hellman public key.
   To prevent an "invalid curve" attack, an entity that reuses its
   Diffie-Hellman public key needs to check whether the received
   ephemeral public key is actually a point on the curve.  This is done
   explicitly as part of the server's reconstruction of the client's
   public key out of only its x-coordinate ("compact representation").

<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/8.%20%20Human%20Rights%20Considerations"></a><a class="selflink" href="#section-8" id="section-8">8</a>.  Human Rights Considerations</span>

   At the time of publication of this document, there was a growing
   interest in considering the impacts that IETF (and IRTF) work can
   have on human rights; some related research is discussed in
   [<a href="./rfc8280" title='"Research into Human Rights Protocol Considerations"'>RFC8280</a>].  As such, the human rights considerations of TLS-PWD are
   presented here.




<span class="grey">Harkins                       Informational                    [Page 30]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-31"></span>
<span class="grey"><a href="./rfc8492">RFC 8492</a>                      TLS Password                 February 2019</span>


   The key exchange underlying TLS-PWD uses public key cryptography to
   perform authentication and authenticated key exchange.  The keys it
   produces can be used to establish secure connections between two
   people to protect their communication.  Implementations of TLS-PWD,
   like implementations of other TLS ciphersuites that perform
   authentication and authenticated key establishment, are considered
   "armaments" or "munitions" by many governments around the world.

   The most fundamental of human rights is the right to protect oneself.
   The right to keep and bear arms is an example of this right.
   Implementations of TLS-PWD can be used as arms, kept and borne, to
   defend oneself against all manner of attackers -- criminals,
   governments, lawyers, etc.  TLS-PWD is a powerful tool in the
   promotion and defense of universal human rights.

<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/9.%20%20Implementation%20Considerations"></a><a class="selflink" href="#section-9" id="section-9">9</a>.  Implementation Considerations</span>

   The selection of the ciphersuite and selection of the particular
   finite cyclic group to use with the ciphersuite are divorced in this
   memo, but they remain intimately close.

   It is RECOMMENDED that implementations take note of the strength
   estimates of particular groups and select a ciphersuite providing
   commensurate security with its hash and encryption algorithms.  A
   ciphersuite whose encryption algorithm has a keylength less than the
   strength estimate or whose hash algorithm has a block size that is
   less than twice the strength estimate SHOULD NOT be used.

   For example, the elliptic curve named "brainpoolP256r1" (whose
   IANA-assigned number is 26) [<a href="./rfc7027" title='"Elliptic Curve Cryptography (ECC) Brainpool Curves for Transport Layer Security (TLS)"'>RFC7027</a>] provides an estimated 128 bits
   of strength and would be compatible with 1) an encryption algorithm
   supporting a key of that length and 2) a hash algorithm that has at
   least a 256-bit block size.  Therefore, a suitable ciphersuite to use
   with brainpoolP256r1 could be TLS_ECCPWD_WITH_AES_128_GCM_SHA256 (see
   <a href="#appendix-A">Appendix A</a> for an example of such an exchange).

   Resistance to dictionary attacks means that the attacker must launch
   an active attack to make a single guess at the password.  If the size
   of the pool from which the password was extracted was D and each
   password in the pool has an equal probability of being chosen, then
   the probability of success after a single guess is 1/D.  After X
   guesses and the removal of failed guesses from the pool of possible
   passwords, the probability becomes 1/(D-X).  As X grows, so does the
   probability of success.  Therefore, it is possible for an attacker to
   determine the password through repeated brute-force, active, guessing
   attacks.  Implementations SHOULD take note of this fact and choose an
   appropriate pool of potential passwords -- i.e., make D big.
   Implementations SHOULD also take countermeasures -- for instance,



<span class="grey">Harkins                       Informational                    [Page 31]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-32"></span>
<span class="grey"><a href="./rfc8492">RFC 8492</a>                      TLS Password                 February 2019</span>


   refusing authentication attempts by a particular username for a
   certain amount of time, after the number of failed authentication
   attempts reaches a certain threshold.  No such threshold or amount of
   time is recommended in this memo.

<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/10.%20%20References"></a><a class="selflink" href="#section-10" id="section-10">10</a>.  References</span>

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/10.1.%20%20Normative%20References"></a><a class="selflink" href="#section-10.1" id="section-10.1">10.1</a>.  Normative References</span>

   [<a id="ref-RFC2104">RFC2104</a>]  Krawczyk, H., Bellare, M., and R. Canetti,
              "HMAC: Keyed-Hashing for Message Authentication",
              <a href="./rfc2104">RFC 2104</a>, DOI 10.17487/RFC2104, February 1997,
              &lt;<a href="https://www.rfc-editor.org/info/rfc2104">https://www.rfc-editor.org/info/rfc2104</a>&gt;.

   [<a id="ref-RFC2119">RFC2119</a>]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", <a href="https://www.rfc-editor.org/bcp/bcp14">BCP 14</a>, <a href="./rfc2119">RFC 2119</a>,
              DOI 10.17487/RFC2119, March 1997,
              &lt;<a href="https://www.rfc-editor.org/info/rfc2119">https://www.rfc-editor.org/info/rfc2119</a>&gt;.

   [<a id="ref-RFC5246">RFC5246</a>]  Dierks, T. and E. Rescorla, "The Transport Layer Security
              (TLS) Protocol Version 1.2", <a href="./rfc5246">RFC 5246</a>,
              DOI 10.17487/RFC5246, August 2008,
              &lt;<a href="https://www.rfc-editor.org/info/rfc5246">https://www.rfc-editor.org/info/rfc5246</a>&gt;.

   [<a id="ref-RFC5297">RFC5297</a>]  Harkins, D., "Synthetic Initialization Vector (SIV)
              Authenticated Encryption Using the Advanced Encryption
              Standard (AES)", <a href="./rfc5297">RFC 5297</a>, DOI 10.17487/RFC5297,
              October 2008, &lt;<a href="https://www.rfc-editor.org/info/rfc5297">https://www.rfc-editor.org/info/rfc5297</a>&gt;.

   [<a id="ref-RFC5869">RFC5869</a>]  Krawczyk, H. and P. Eronen, "HMAC-based Extract-and-Expand
              Key Derivation Function (HKDF)", <a href="./rfc5869">RFC 5869</a>,
              DOI 10.17487/RFC5869, May 2010,
              &lt;<a href="https://www.rfc-editor.org/info/rfc5869">https://www.rfc-editor.org/info/rfc5869</a>&gt;.

   [<a id="ref-RFC7919">RFC7919</a>]  Gillmor, D., "Negotiated Finite Field Diffie-Hellman
              Ephemeral Parameters for Transport Layer Security (TLS)",
              <a href="./rfc7919">RFC 7919</a>, DOI 10.17487/RFC7919, August 2016,
              &lt;<a href="https://www.rfc-editor.org/info/rfc7919">https://www.rfc-editor.org/info/rfc7919</a>&gt;.

   [<a id="ref-RFC8174">RFC8174</a>]  Leiba, B., "Ambiguity of Uppercase vs Lowercase in
              <a href="./rfc2119">RFC 2119</a> Key Words", <a href="https://www.rfc-editor.org/bcp/bcp14">BCP 14</a>, <a href="./rfc8174">RFC 8174</a>,
              DOI 10.17487/RFC8174, May 2017,
              &lt;<a href="https://www.rfc-editor.org/info/rfc8174">https://www.rfc-editor.org/info/rfc8174</a>&gt;.








<span class="grey">Harkins                       Informational                    [Page 32]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-33"></span>
<span class="grey"><a href="./rfc8492">RFC 8492</a>                      TLS Password                 February 2019</span>


   [<a id="ref-RFC8265">RFC8265</a>]  Saint-Andre, P. and A. Melnikov, "Preparation,
              Enforcement, and Comparison of Internationalized Strings
              Representing Usernames and Passwords", <a href="./rfc8265">RFC 8265</a>,
              DOI 10.17487/RFC8265, October 2017,
              &lt;<a href="https://www.rfc-editor.org/info/rfc8265">https://www.rfc-editor.org/info/rfc8265</a>&gt;.

   [<a id="ref-RFC8422">RFC8422</a>]  Nir, Y., Josefsson, S., and M. Pegourie-Gonnard, "Elliptic
              Curve Cryptography (ECC) Cipher Suites for Transport Layer
              Security (TLS) Versions 1.2 and Earlier", <a href="./rfc8422">RFC 8422</a>,
              DOI 10.17487/RFC8422, August 2018,
              &lt;<a href="https://www.rfc-editor.org/info/rfc8422">https://www.rfc-editor.org/info/rfc8422</a>&gt;.

   [<a id="ref-RFC8446">RFC8446</a>]  Rescorla, E., "The Transport Layer Security (TLS) Protocol
              Version 1.3", <a href="./rfc8446">RFC 8446</a>, DOI 10.17487/RFC8446, August 2018,
              &lt;<a href="https://www.rfc-editor.org/info/rfc8446">https://www.rfc-editor.org/info/rfc8446</a>&gt;.

   [<a id="ref-RFC8447">RFC8447</a>]  Salowey, J. and S. Turner, "IANA Registry Updates for TLS
              and DTLS", <a href="./rfc8447">RFC 8447</a>, DOI 10.17487/RFC8447, August 2018,
              &lt;<a href="https://www.rfc-editor.org/info/rfc8447">https://www.rfc-editor.org/info/rfc8447</a>&gt;.

   [<a id="ref-TLS_REG">TLS_REG</a>]  IANA, "Transport Layer Security (TLS) Parameters",
              &lt;<a href="https://www.iana.org/assignments/tls-parameters/">https://www.iana.org/assignments/tls-parameters/</a>&gt;.

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/10.2.%20%20Informative%20References"></a><a class="selflink" href="#section-10.2" id="section-10.2">10.2</a>.  Informative References</span>

   [<a id="ref-FIPS186-4">FIPS186-4</a>]
              National Institute of Standards and Technology, "Digital
              Signature Standard (DSS)", Federal Information Processing
              Standards Publication 186-4, DOI 10.6028/NIST.FIPS.186-4,
              July 2013, &lt;<a href="https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-4.pdf">https://nvlpubs.nist.gov/nistpubs/FIPS/</a>
              <a href="https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-4.pdf">NIST.FIPS.186-4.pdf</a>&gt;.

   [<a id="ref-lanskro">lanskro</a>]  Lancrenon, J. and M. Skrobot, "On the Provable Security of
              the Dragonfly Protocol", ISC 2015 Proceedings of the 18th
              International Conference on Information
              Security - Volume 9290, pp. 244-261,
              DOI 10.1007/978-3-319-23318-5_14, September 2015.

   [<a id="ref-RANDOR">RANDOR</a>]   Bellare, M. and P. Rogaway, "Random Oracles are Practical:
              A Paradigm for Designing Efficient Protocols", Proceedings
              of the 1st ACM Conference on Computer and Communications
              Security, pp. 62-73, ACM Press, DOI 10.1145/168588.168596,
              November 1993.

   [<a id="ref-RFC4086">RFC4086</a>]  Eastlake 3rd, D., Schiller, J., and S. Crocker,
              "Randomness Requirements for Security", <a href="https://www.rfc-editor.org/bcp/bcp106">BCP 106</a>, <a href="./rfc4086">RFC 4086</a>,
              DOI 10.17487/RFC4086, June 2005,
              &lt;<a href="https://www.rfc-editor.org/info/rfc4086">https://www.rfc-editor.org/info/rfc4086</a>&gt;.



<span class="grey">Harkins                       Informational                    [Page 33]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-34"></span>
<span class="grey"><a href="./rfc8492">RFC 8492</a>                      TLS Password                 February 2019</span>


   [<a id="ref-RFC6090">RFC6090</a>]  McGrew, D., Igoe, K., and M. Salter, "Fundamental Elliptic
              Curve Cryptography Algorithms", <a href="./rfc6090">RFC 6090</a>,
              DOI 10.17487/RFC6090, February 2011,
              &lt;<a href="https://www.rfc-editor.org/info/rfc6090">https://www.rfc-editor.org/info/rfc6090</a>&gt;.

   [<a id="ref-RFC7027">RFC7027</a>]  Merkle, J. and M. Lochter, "Elliptic Curve Cryptography
              (ECC) Brainpool Curves for Transport Layer Security
              (TLS)", <a href="./rfc7027">RFC 7027</a>, DOI 10.17487/RFC7027, October 2013,
              &lt;<a href="https://www.rfc-editor.org/info/rfc7027">https://www.rfc-editor.org/info/rfc7027</a>&gt;.

   [<a id="ref-RFC7030">RFC7030</a>]  Pritikin, M., Ed., Yee, P., Ed., and D. Harkins, Ed.,
              "Enrollment over Secure Transport", <a href="./rfc7030">RFC 7030</a>,
              DOI 10.17487/RFC7030, October 2013,
              &lt;<a href="https://www.rfc-editor.org/info/rfc7030">https://www.rfc-editor.org/info/rfc7030</a>&gt;.

   [<a id="ref-RFC7664">RFC7664</a>]  Harkins, D., Ed., "Dragonfly Key Exchange", <a href="./rfc7664">RFC 7664</a>,
              DOI 10.17487/RFC7664, November 2015,
              &lt;<a href="https://www.rfc-editor.org/info/rfc7664">https://www.rfc-editor.org/info/rfc7664</a>&gt;.

   [<a id="ref-RFC8280">RFC8280</a>]  ten Oever, N. and C. Cath, "Research into Human Rights
              Protocol Considerations", <a href="./rfc8280">RFC 8280</a>, DOI 10.17487/RFC8280,
              October 2017, &lt;<a href="https://www.rfc-editor.org/info/rfc8280">https://www.rfc-editor.org/info/rfc8280</a>&gt;.

   [<a id="ref-SP800-38A">SP800-38A</a>]
              Dworkin, M., "Recommendation for Block Cipher Modes of
              Operation - Methods and Techniques", NIST Special
              Publication 800-38A, DOI 10.6028/NIST.SP.800-38A,
              December 2001, &lt;<a href="https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-38a.pdf">https://nvlpubs.nist.gov/nistpubs/</a>
              <a href="https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-38a.pdf">Legacy/SP/nistspecialpublication800-38a.pdf</a>&gt;.

   [<a id="ref-SP800-56A">SP800-56A</a>]
              Barker, E., Chen, L., Roginsky, A., Vassilev, A., and R.
              Davis, "Recommendation for Pair-Wise Key-Establishment
              Schemes Using Discrete Logarithm Cryptography", NIST
              Special Publication 800-56A, Revision 3,
              DOI 10.6028/NIST.SP.800-56Ar3, April 2018,
              &lt;<a href="https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-56Ar3.pdf">https://nvlpubs.nist.gov/nistpubs/SpecialPublications/</a>
              <a href="https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-56Ar3.pdf">NIST.SP.800-56Ar3.pdf</a>&gt;.













<span class="grey">Harkins                       Informational                    [Page 34]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-35"></span>
<span class="grey"><a href="./rfc8492">RFC 8492</a>                      TLS Password                 February 2019</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/Appendix%20A.%20%20Example%20Exchange"></a><a class="selflink" href="#appendix-A" id="appendix-A">Appendix A</a>.  Example Exchange</span>

   username: fred
   password: barney

   ---- prior to running TLS-PWD ----

   server generates salt:

   96 3c 77 cd c1 3a 2a 8d 75 cd dd d1 e0 44 99 29
   84 37 11 c2 1d 47 ce 6e 63 83 cd da 37 e4 7d a3

   and a base:

   6e 7c 79 82 1b 9f 8e 80 21 e9 e7 e8 26 e9 ed 28
   c4 a1 8a ef c8 75 0c 72 6f 74 c7 09 61 d7 00 75

   ---- state derived during the TLS-PWD exchange ----

   client and server agree to use brainpoolP256r1

   client and server generate the PE:

   PE.x:
   29 b2 38 55 81 9f 9c 3f c3 71 ba e2 84 f0 93 a3
   a4 fd 34 72 d4 bd 2e 9d f7 15 2d 22 ab 37 aa e6

   server private and mask:

   private:
   21 d9 9d 34 1c 97 97 b3 ae 72 df d2 89 97 1f 1b
   74 ce 9d e6 8a d4 b9 ab f5 48 88 d8 f6 c5 04 3c
   mask:
   0d 96 ab 62 4d 08 2c 71 25 5b e3 64 8d cd 30 3f
   6a b0 ca 61 a9 50 34 a5 53 e3 30 8d 1d 37 44 e5

   client private and mask:

   private:
   17 1d e8 ca a5 35 2d 36 ee 96 a3 99 79 b5 b7 2f
   a1 89 ae 7a 6a 09 c7 7f 7b 43 8a f1 6d f4 a8 8b
   mask:
   4f 74 5b df c2 95 d3 b3 84 29 f7 eb 30 25 a4 88
   83 72 8b 07 d8 86 05 c0 ee 20 23 16 a0 72 d1 bd







<span class="grey">Harkins                       Informational                    [Page 35]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-36"></span>
<span class="grey"><a href="./rfc8492">RFC 8492</a>                      TLS Password                 February 2019</span>


   both parties generate premaster secret and master secret

   premaster secret:
   01 f7 a7 bd 37 9d 71 61 79 eb 80 c5 49 83 45 11
   af 58 cb b6 dc 87 e0 18 1c 83 e7 01 e9 26 92 a4
   master secret:
   65 ce 15 50 ee ff 3d aa 2b f4 78 cb 84 29 88 a1
   60 26 a4 be f2 2b 3f ab 23 96 e9 8a 7e 05 a1 0f
   3d 8c ac 51 4d da 42 8d 94 be a9 23 89 18 4c ad

   ---- ssldump output of exchange ----

   New TCP connection #1: Charlene Client &lt;-&gt; Sammy Server
   1 1  0.0018 (0.0018)  C&gt;SV3.3(173)  Handshake
         ClientHello
           Version 3.3
           random[32]=
             52 8f bf 52 17 5d e2 c8 69 84 5f db fa 83 44 f7
             d7 32 71 2e bf a6 79 d8 64 3c d3 1a 88 0e 04 3d
           ciphersuites
           TLS_ECCPWD_WITH_AES_128_GCM_SHA256_PRIV
           TLS_ECCPWD_WITH_AES_256_GCM_SHA384_PRIV
           Unknown value 0xff
           compression methods
                     NULL
           extensions
           TLS-PWD unprotected name[5]=
             04 66 72 65 64
           elliptic curve point format[4]=
             03 00 01 02
           elliptic curve list[58]=
             00 38 00 0e 00 0d 00 1c 00 19 00 0b 00 0c 00 1b
             00 18 00 09 00 0a 00 1a 00 16 00 17 00 08 00 06
             00 07 00 14 00 15 00 04 00 05 00 12 00 13 00 01
             00 02 00 03 00 0f 00 10 00 11
   Packet data[178]=
     16 03 03 00 ad 01 00 00 a9 03 03 52 8f bf 52 17
     5d e2 c8 69 84 5f db fa 83 44 f7 d7 32 71 2e bf
     a6 79 d8 64 3c d3 1a 88 0e 04 3d 00 00 06 ff b3
     ff b4 00 ff 01 00 00 7a b8 aa 00 05 04 66 72 65
     64 00 0b 00 04 03 00 01 02 00 0a 00 3a 00 38 00
     0e 00 0d 00 1c 00 19 00 0b 00 0c 00 1b 00 18 00
     09 00 0a 00 1a 00 16 00 17 00 08 00 06 00 07 00
     14 00 15 00 04 00 05 00 12 00 13 00 01 00 02 00
     03 00 0f 00 10 00 11 00 0d 00 22 00 20 06 01 06
     02 06 03 05 01 05 02 05 03 04 01 04 02 04 03 03
     01 03 02 03 03 02 01 02 02 02 03 01 01 00 0f 00
     01 01



<span class="grey">Harkins                       Informational                    [Page 36]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-37"></span>
<span class="grey"><a href="./rfc8492">RFC 8492</a>                      TLS Password                 February 2019</span>


   1 2  0.0043 (0.0024)  S&gt;CV3.3(94)  Handshake
         ServerHello
           Version 3.3
           random[32]=
             52 8f bf 52 43 78 a1 b1 3b 8d 2c bd 24 70 90 72
             13 69 f8 bf a3 ce eb 3c fc d8 5c bf cd d5 8e aa
           session_id[32]=
             ef ee 38 08 22 09 f2 c1 18 38 e2 30 33 61 e3 d6
             e6 00 6d 18 0e 09 f0 73 d5 21 20 cf 9f bf 62 88
           cipherSuite         TLS_ECCPWD_WITH_AES_128_GCM_SHA256_PRIV
           compressionMethod                   NULL
           extensions
           renegotiate[1]=
             00
           elliptic curve point format[4]=
             03 00 01 02
           heartbeat[1]=
             01
   Packet data[99]=
     16 03 03 00 5e 02 00 00 5a 03 03 52 8f bf 52 43
     78 a1 b1 3b 8d 2c bd 24 70 90 72 13 69 f8 bf a3
     ce eb 3c fc d8 5c bf cd d5 8e aa 20 ef ee 38 08
     22 09 f2 c1 18 38 e2 30 33 61 e3 d6 e6 00 6d 18
     0e 09 f0 73 d5 21 20 cf 9f bf 62 88 ff b3 00 00
     12 ff 01 00 01 00 00 0b 00 04 03 00 01 02 00 0f
     00 01 01

























<span class="grey">Harkins                       Informational                    [Page 37]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-38"></span>
<span class="grey"><a href="./rfc8492">RFC 8492</a>                      TLS Password                 February 2019</span>


   1 3  0.0043 (0.0000)  S&gt;CV3.3(141)  Handshake
         ServerKeyExchange
           params
             salt[32]=
               96 3c 77 cd c1 3a 2a 8d 75 cd dd d1 e0 44 99 29
               84 37 11 c2 1d 47 ce 6e 63 83 cd da 37 e4 7d a3
             EC parameters = 3
             curve id = 26
             element[65]=
               04 22 bb d5 6b 48 1d 7f a9 0c 35 e8 d4 2f cd 06
               61 8a 07 78 de 50 6b 1b c3 88 82 ab c7 31 32 ee
               f3 7f 02 e1 3b d5 44 ac c1 45 bd d8 06 45 0d 43
               be 34 b9 28 83 48 d0 3d 6c d9 83 24 87 b1 29 db
               e1
             scalar[32]=
               2f 70 48 96 69 9f c4 24 d3 ce c3 37 17 64 4f 5a
               df 7f 68 48 34 24 ee 51 49 2b b9 66 13 fc 49 21
   Packet data[146]=
     16 03 03 00 8d 0c 00 00 89 00 20 96 3c 77 cd c1
     3a 2a 8d 75 cd dd d1 e0 44 99 29 84 37 11 c2 1d
     47 ce 6e 63 83 cd da 37 e4 7d a3 03 00 1a 41 04
     22 bb d5 6b 48 1d 7f a9 0c 35 e8 d4 2f cd 06 61
     8a 07 78 de 50 6b 1b c3 88 82 ab c7 31 32 ee f3
     7f 02 e1 3b d5 44 ac c1 45 bd d8 06 45 0d 43 be
     34 b9 28 83 48 d0 3d 6c d9 83 24 87 b1 29 db e1
     00 20 2f 70 48 96 69 9f c4 24 d3 ce c3 37 17 64
     4f 5a df 7f 68 48 34 24 ee 51 49 2b b9 66 13 fc
     49 21

   1 4  0.0043 (0.0000)  S&gt;CV3.3(4)  Handshake
         ServerHelloDone
   Packet data[9]=
     16 03 03 00 04 0e 00 00 00


















<span class="grey">Harkins                       Informational                    [Page 38]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-39"></span>
<span class="grey"><a href="./rfc8492">RFC 8492</a>                      TLS Password                 February 2019</span>


   1 5  0.0086 (0.0043)  C&gt;SV3.3(104)  Handshake
         ClientKeyExchange
           element[65]=
             04 a0 c6 9b 45 0b 85 ae e3 9f 64 6b 6e 64 d3 c1
             08 39 5f 4b a1 19 2d bf eb f0 de c5 b1 89 13 1f
             59 5d d4 ba cd bd d6 83 8d 92 19 fd 54 29 91 b2
             c0 b0 e4 c4 46 bf e5 8f 3c 03 39 f7 56 e8 9e fd
             a0
           scalar[32]=
             66 92 44 aa 67 cb 00 ea 72 c0 9b 84 a9 db 5b b8
             24 fc 39 82 42 8f cd 40 69 63 ae 08 0e 67 7a 48
   Packet data[109]=
     16 03 03 00 68 10 00 00 64 41 04 a0 c6 9b 45 0b
     85 ae e3 9f 64 6b 6e 64 d3 c1 08 39 5f 4b a1 19
     2d bf eb f0 de c5 b1 89 13 1f 59 5d d4 ba cd bd
     d6 83 8d 92 19 fd 54 29 91 b2 c0 b0 e4 c4 46 bf
     e5 8f 3c 03 39 f7 56 e8 9e fd a0 00 20 66 92 44
     aa 67 cb 00 ea 72 c0 9b 84 a9 db 5b b8 24 fc 39
     82 42 8f cd 40 69 63 ae 08 0e 67 7a 48

   1 6  0.0086 (0.0000)  C&gt;SV3.3(1)  ChangeCipherSpec
   Packet data[6]=
     14 03 03 00 01 01

   1 7  0.0086 (0.0000)  C&gt;SV3.3(40)  Handshake
   Packet data[45]=
     16 03 03 00 28 44 cd 3f 26 ed 64 9a 1b bb 07 c7
     0c 6d 3e 28 af e6 32 b1 17 29 49 a1 14 8e cb 7a
     0b 4b 70 f5 1f 39 c2 9c 7b 6c cc 57 20

   1 8  0.0105 (0.0018)  S&gt;CV3.3(1)  ChangeCipherSpec
   Packet data[6]=
     14 03 03 00 01 01

   1 9  0.0105 (0.0000)  S&gt;CV3.3(40)  Handshake
   Packet data[45]=
     16 03 03 00 28 fd da 3c 9e 48 0a e7 99 ba 41 8c
     9f fd 47 c8 41 2c fd 22 10 77 3f 0f 78 54 5e 41
     a2 21 94 90 12 72 23 18 24 21 c3 60 a4

   1 10 0.0107 (0.0002)  C&gt;SV3.3(100)  application_data
   Packet data....









<span class="grey">Harkins                       Informational                    [Page 39]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-40"></span>
<span class="grey"><a href="./rfc8492">RFC 8492</a>                      TLS Password                 February 2019</span>


Acknowledgements

   The authenticated key exchange defined here has also been defined for
   use in 802.11 networks, as an Extensible Authentication Protocol
   (EAP) method, and as an authentication method for the Internet Key
   Exchange Protocol (IKE).  Each of these specifications has elicited
   very helpful comments from a wide collection of people that have
   allowed the definition of the authenticated key exchange to be
   refined and improved.

   The author would like to thank Scott Fluhrer for discovering the
   "password as exponent" attack that was possible in an early version
   of this key exchange and for his very helpful suggestions on the
   techniques for fixing the PE to prevent it.  The author would also
   like to thank Hideyuki Suzuki for his insight in discovering an
   attack against a previous version of the underlying key exchange
   protocol.  Special thanks to Lily Chen for helpful discussions on
   hashing into an elliptic curve.  Rich Davis suggested the defensive
   checks that are part of the processing of the ServerKeyExchange and
   ClientKeyExchange messages, and his various comments have greatly
   improved the quality of this memo and the underlying key exchange on
   which it is based.

   Martin Rex, Peter Gutmann, Marsh Ray, and Rene Struik discussed on
   the TLS mailing list the possibility of a side-channel attack against
   the hunting-and-pecking loop.  That discussion prompted the addition
   of the security parameter, m, to the hunting-and-pecking loop.  Scott
   Fluhrer suggested the blinding technique to test whether a value is a
   quadratic residue modulo a prime in a manner that does not leak
   information about the value being tested.

Author's Address

   Dan Harkins (editor)
   HP Enterprise
   3333 Scott Blvd.
   Santa Clara, CA  95054
   United States of America

   Email: dharkins@lounge.org











Harkins                       Informational                    [Page 40]
</pre>
</body></html>