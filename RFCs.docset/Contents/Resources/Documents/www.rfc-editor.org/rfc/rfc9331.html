<!DOCTYPE html>
<html class="RFC" lang="en"><head>
<meta charset="utf-8"/>
<meta content="Common,Latin" name="scripts"/>
<meta content="initial-scale=1.0" name="viewport"/>
<title>RFC 9331: The Explicit Congestion Notification (ECN) Protocol for Low Latency, Low Loss, and Scalable Throughput (L4S)</title>
<meta content="Koen De Schepper" name="author"/>
<meta content="Bob Briscoe" name="author"/>
<meta content="
       This specification defines the protocol to be used for a new network
      service called Low Latency, Low Loss, and Scalable throughput (L4S). L4S
      uses an Explicit Congestion Notification (ECN) scheme at the IP layer
      that is similar to the original (or 'Classic') ECN approach, except as
      specified within. L4S uses 'Scalable' congestion control, which induces
      much more frequent control signals from the network, and it responds to
      them with much more fine-grained adjustments so that very low
      (typically sub-millisecond on average) and consistently low queuing
      delay becomes possible for L4S traffic without compromising link
      utilization. Thus, even capacity-seeking (TCP-like) traffic can have high
      bandwidth and very low delay at the same time, even during periods of
      high traffic load. 
       The L4S identifier defined in this document distinguishes L4S from
      'Classic' (e.g., TCP-Reno-friendly) traffic. Then, network
      bottlenecks can be incrementally modified to distinguish and isolate
      existing traffic that still follows the Classic behaviour, to prevent it
      from degrading the low queuing delay and low loss of L4S traffic. This
      Experimental specification defines the rules that L4S transports
      and network elements need to follow, with the intention that L4S flows
      neither harm each other's performance nor that of Classic traffic. It
      also suggests open questions to be investigated during experimentation.
      Examples of new Active Queue Management (AQM) marking algorithms and
      new transports (whether TCP-like or real time) are specified
      separately. 
    " name="description"/>
<meta content="xml2rfc 3.15.3" name="generator"/>
<meta content="Performance" name="keyword"/>
<meta content="Queuing Delay" name="keyword"/>
<meta content="One Way Delay" name="keyword"/>
<meta content="Round-Trip Time" name="keyword"/>
<meta content="RTT" name="keyword"/>
<meta content="Jitter" name="keyword"/>
<meta content="Congestion Control" name="keyword"/>
<meta content="Congestion Avoidance" name="keyword"/>
<meta content="Quality of Service" name="keyword"/>
<meta content="QoS" name="keyword"/>
<meta content="Quality of Experience" name="keyword"/>
<meta content="QoE" name="keyword"/>
<meta content="Active Queue Management" name="keyword"/>
<meta content="AQM" name="keyword"/>
<meta content="Explicit Congestion Notification" name="keyword"/>
<meta content="ECN" name="keyword"/>
<meta content="Burstiness" name="keyword"/>
<meta content="9331" name="rfc.number"/>
<!-- Generator version information:
  xml2rfc 3.15.3
    Python 3.9.15
    appdirs 1.4.4
    ConfigArgParse 1.5.3
    google-i18n-address 2.5.1
    html5lib 1.1
    intervaltree 3.1.0
    Jinja2 3.1.2
    lxml 4.9.0
    MarkupSafe 2.1.1
    pycountry 22.3.5
    PyYAML 6.0
    requests 2.28.0
    setuptools 44.1.1
    six 1.16.0
    wcwidth 0.2.5
    weasyprint 56.1
-->
<link href="rfc9331.xml" rel="alternate" type="application/rfc+xml"/>
<link href="#copyright" rel="license"/>
<style type="text/css">/*

  NOTE: Changes at the bottom of this file overrides some earlier settings.

  Once the style has stabilized and has been adopted as an official RFC style,
  this can be consolidated so that style settings occur only in one place, but
  for now the contents of this file consists first of the initial CSS work as
  provided to the RFC Formatter (xml2rfc) work, followed by itemized and
  commented changes found necessary during the development of the v3
  formatters.

*/

/* fonts */
@import url('https://fonts.googleapis.com/css?family=Noto+Sans'); /* Sans-serif */
@import url('https://fonts.googleapis.com/css?family=Noto+Serif'); /* Serif (print) */
@import url('https://fonts.googleapis.com/css?family=Roboto+Mono'); /* Monospace */

:root {
  --font-sans: 'Noto Sans', Arial, Helvetica, sans-serif;
  --font-serif: 'Noto Serif', 'Times', 'Times New Roman', serif;
  --font-mono: 'Roboto Mono', Courier, 'Courier New', monospace;
}

@viewport {
  zoom: 1.0;
  width: extend-to-zoom;
}
@-ms-viewport {
  width: extend-to-zoom;
  zoom: 1.0;
}
/* general and mobile first */
html {
}
body {
  max-width: 90%;
  margin: 1.5em auto;
  color: #222;
  background-color: #fff;
  font-size: 14px;
  font-family: var(--font-sans);
  line-height: 1.6;
  scroll-behavior: smooth;
}
.ears {
  display: none;
}

/* headings */
#title, h1, h2, h3, h4, h5, h6 {
  margin: 1em 0 0.5em;
  font-weight: bold;
  line-height: 1.3;
}
#title {
  clear: both;
  border-bottom: 1px solid #ddd;
  margin: 0 0 0.5em 0;
  padding: 1em 0 0.5em;
}
.author {
  padding-bottom: 4px;
}
h1 {
  font-size: 26px;
  margin: 1em 0;
}
h2 {
  font-size: 22px;
  margin-top: -20px;  /* provide offset for in-page anchors */
  padding-top: 33px;
}
h3 {
  font-size: 18px;
  margin-top: -36px;  /* provide offset for in-page anchors */
  padding-top: 42px;
}
h4 {
  font-size: 16px;
  margin-top: -36px;  /* provide offset for in-page anchors */
  padding-top: 42px;
}
h5, h6 {
  font-size: 14px;
}
#n-copyright-notice {
  border-bottom: 1px solid #ddd;
  padding-bottom: 1em;
  margin-bottom: 1em;
}
/* general structure */
p {
  padding: 0;
  margin: 0 0 1em 0;
  text-align: left;
}
div, span {
  position: relative;
}
div {
  margin: 0;
}
.alignRight.art-text {
  background-color: #f9f9f9;
  border: 1px solid #eee;
  border-radius: 3px;
  padding: 1em 1em 0;
  margin-bottom: 1.5em;
}
.alignRight.art-text pre {
  padding: 0;
}
.alignRight {
  margin: 1em 0;
}
.alignRight > *:first-child {
  border: none;
  margin: 0;
  float: right;
  clear: both;
}
.alignRight > *:nth-child(2) {
  clear: both;
  display: block;
  border: none;
}
svg {
  display: block;
}
svg[font-family~="serif" i], svg [font-family~="serif" i] {
  font-family: var(--font-serif);
}
svg[font-family~="sans-serif" i], svg [font-family~="sans-serif" i] {
  font-family: var(--font-sans);
}
svg[font-family~="monospace" i], svg [font-family~="monospace" i] {
  font-family: var(--font-mono);
}
.alignCenter.art-text {
  background-color: #f9f9f9;
  border: 1px solid #eee;
  border-radius: 3px;
  padding: 1em 1em 0;
  margin-bottom: 1.5em;
}
.alignCenter.art-text pre {
  padding: 0;
}
.alignCenter {
  margin: 1em 0;
}
.alignCenter > *:first-child {
  display: table;
  border: none;
  margin: 0 auto;
}

/* lists */
ol, ul {
  padding: 0;
  margin: 0 0 1em 2em;
}
ol ol, ul ul, ol ul, ul ol {
  margin-left: 1em;
}
li {
  margin: 0 0 0.25em 0;
}
.ulCompact li {
  margin: 0;
}
ul.empty, .ulEmpty {
  list-style-type: none;
}
ul.empty li, .ulEmpty li {
  margin-top: 0.5em;
}
ul.ulBare, li.ulBare {
  margin-left: 0em !important;
}
ul.compact, .ulCompact,
ol.compact, .olCompact {
  line-height: 100%;
  margin: 0 0 0 2em;
}

/* definition lists */
dl {
}
dl > dt {
  float: left;
  margin-right: 1em;
}
/* 
dl.nohang > dt {
  float: none;
}
*/
dl > dd {
  margin-bottom: .8em;
  min-height: 1.3em;
}
dl.compact > dd, .dlCompact > dd {
  margin-bottom: 0em;
}
dl > dd > dl {
  margin-top: 0.5em;
  margin-bottom: 0em;
}

/* links */
a {
  text-decoration: none;
}
a[href] {
  color: #22e; /* Arlen: WCAG 2019 */
}
a[href]:hover {
  background-color: #f2f2f2;
}
figcaption a[href],
a[href].selfRef {
  color: #222;
}
/* XXX probably not this:
a.selfRef:hover {
  background-color: transparent;
  cursor: default;
} */

/* Figures */
tt, code, pre {
  background-color: #f9f9f9;
  font-family: var(--font-mono);
}
pre {
  border: 1px solid #eee;
  margin: 0;
  padding: 1em;
}
img {
  max-width: 100%;
}
figure {
  margin: 0;
}
figure blockquote {
  margin: 0.8em 0.4em 0.4em;
}
figcaption {
  font-style: italic;
  margin: 0 0 1em 0;
}
@media screen {
  pre {
    overflow-x: auto;
    max-width: 100%;
    max-width: calc(100% - 22px);
  }
}

/* aside, blockquote */
aside, blockquote {
  margin-left: 0;
  padding: 1.2em 2em;
}
blockquote {
  background-color: #f9f9f9;
  color: #111; /* Arlen: WCAG 2019 */
  border: 1px solid #ddd;
  border-radius: 3px;
  margin: 1em 0;
}
cite {
  display: block;
  text-align: right;
  font-style: italic;
}

/* tables */
table {
  width: 100%;
  margin: 0 0 1em;
  border-collapse: collapse;
  border: 1px solid #eee;
}
th, td {
  text-align: left;
  vertical-align: top;
  padding: 0.5em 0.75em;
}
th {
  text-align: left;
  background-color: #e9e9e9;
}
tr:nth-child(2n+1) > td {
  background-color: #f5f5f5;
}
table caption {
  font-style: italic;
  margin: 0;
  padding: 0;
  text-align: left;
}
table p {
  /* XXX to avoid bottom margin on table row signifiers. If paragraphs should
     be allowed within tables more generally, it would be far better to select on a class. */
  margin: 0;
}

/* pilcrow */
a.pilcrow {
  color: #666; /* Arlen: AHDJ 2019 */
  text-decoration: none;
  visibility: hidden;
  user-select: none;
  -ms-user-select: none;
  -o-user-select:none;
  -moz-user-select: none;
  -khtml-user-select: none;
  -webkit-user-select: none;
  -webkit-touch-callout: none;
}
@media screen {
  aside:hover > a.pilcrow,
  p:hover > a.pilcrow,
  blockquote:hover > a.pilcrow,
  div:hover > a.pilcrow,
  li:hover > a.pilcrow,
  pre:hover > a.pilcrow {
    visibility: visible;
  }
  a.pilcrow:hover {
    background-color: transparent;
  }
}

/* misc */
hr {
  border: 0;
  border-top: 1px solid #eee;
}
.bcp14 {
  font-variant: small-caps;
}

.role {
  font-variant: all-small-caps;
}

/* info block */
#identifiers {
  margin: 0;
  font-size: 0.9em;
}
#identifiers dt {
  width: 3em;
  clear: left;
}
#identifiers dd {
  float: left;
  margin-bottom: 0;
}
/* Fix PDF info block run off issue */
@media print {
  #identifiers dd {
    float: none;
  }
}
#identifiers .authors .author {
  display: inline-block;
  margin-right: 1.5em;
}
#identifiers .authors .org {
  font-style: italic;
}

/* The prepared/rendered info at the very bottom of the page */
.docInfo {
  color: #666; /* Arlen: WCAG 2019 */
  font-size: 0.9em;
  font-style: italic;
  margin-top: 2em;
}
.docInfo .prepared {
  float: left;
}
.docInfo .prepared {
  float: right;
}

/* table of contents */
#toc  {
  padding: 0.75em 0 2em 0;
  margin-bottom: 1em;
}
nav.toc ul {
  margin: 0 0.5em 0 0;
  padding: 0;
  list-style: none;
}
nav.toc li {
  line-height: 1.3em;
  margin: 0.75em 0;
  padding-left: 1.2em;
  text-indent: -1.2em;
}
/* references */
.references dt {
  text-align: right;
  font-weight: bold;
  min-width: 7em;
}
.references dd {
  margin-left: 8em;
  overflow: auto;
}

.refInstance {
  margin-bottom: 1.25em;
}

.references .ascii {
  margin-bottom: 0.25em;
}

/* index */
.index ul {
  margin: 0 0 0 1em;
  padding: 0;
  list-style: none;
}
.index ul ul {
  margin: 0;
}
.index li {
  margin: 0;
  text-indent: -2em;
  padding-left: 2em;
  padding-bottom: 5px;
}
.indexIndex {
  margin: 0.5em 0 1em;
}
.index a {
  font-weight: 700;
}
/* make the index two-column on all but the smallest screens */
@media (min-width: 600px) {
  .index ul {
    -moz-column-count: 2;
    -moz-column-gap: 20px;
  }
  .index ul ul {
    -moz-column-count: 1;
    -moz-column-gap: 0;
  }
}

/* authors */
address.vcard {
  font-style: normal;
  margin: 1em 0;
}

address.vcard .nameRole {
  font-weight: 700;
  margin-left: 0;
}
address.vcard .label {
  font-family: var(--font-sans);
  margin: 0.5em 0;
}
address.vcard .type {
  display: none;
}
.alternative-contact {
  margin: 1.5em 0 1em;
}
hr.addr {
  border-top: 1px dashed;
  margin: 0;
  color: #ddd;
  max-width: calc(100% - 16px);
}

/* temporary notes */
.rfcEditorRemove::before {
  position: absolute;
  top: 0.2em;
  right: 0.2em;
  padding: 0.2em;
  content: "The RFC Editor will remove this note";
  color: #9e2a00; /* Arlen: WCAG 2019 */
  background-color: #ffd; /* Arlen: WCAG 2019 */
}
.rfcEditorRemove {
  position: relative;
  padding-top: 1.8em;
  background-color: #ffd; /* Arlen: WCAG 2019 */
  border-radius: 3px;
}
.cref {
  background-color: #ffd; /* Arlen: WCAG 2019 */
  padding: 2px 4px;
}
.crefSource {
  font-style: italic;
}
/* alternative layout for smaller screens */
@media screen and (max-width: 1023px) {
  body {
    padding-top: 2em;
  }
  #title {
    padding: 1em 0;
  }
  h1 {
    font-size: 24px;
  }
  h2 {
    font-size: 20px;
    margin-top: -18px;  /* provide offset for in-page anchors */
    padding-top: 38px;
  }
  #identifiers dd {
    max-width: 60%;
  }
  #toc {
    position: fixed;
    z-index: 2;
    top: 0;
    right: 0;
    padding: 0;
    margin: 0;
    background-color: inherit;
    border-bottom: 1px solid #ccc;
  }
  #toc h2 {
    margin: -1px 0 0 0;
    padding: 4px 0 4px 6px;
    padding-right: 1em;
    min-width: 190px;
    font-size: 1.1em;
    text-align: right;
    background-color: #444;
    color: white;
    cursor: pointer;
  }
  #toc h2::before { /* css hamburger */
    float: right;
    position: relative;
    width: 1em;
    height: 1px;
    left: -164px;
    margin: 6px 0 0 0;
    background: white none repeat scroll 0 0;
    box-shadow: 0 4px 0 0 white, 0 8px 0 0 white;
    content: "";
  }
  #toc nav {
    display: none;
    padding: 0.5em 1em 1em;
    overflow: auto;
    height: calc(100vh - 48px);
    border-left: 1px solid #ddd;
  }
}

/* alternative layout for wide screens */
@media screen and (min-width: 1024px) {
  body {
    max-width: 724px;
    margin: 42px auto;
    padding-left: 1.5em;
    padding-right: 29em;
  }
  #toc {
    position: fixed;
    top: 42px;
    right: 42px;
    width: 25%;
    margin: 0;
    padding: 0 1em;
    z-index: 1;
  }
  #toc h2 {
    border-top: none;
    border-bottom: 1px solid #ddd;
    font-size: 1em;
    font-weight: normal;
    margin: 0;
    padding: 0.25em 1em 1em 0;
  }
  #toc nav {
    display: block;
    height: calc(90vh - 84px);
    bottom: 0;
    padding: 0.5em 0 0;
    overflow: auto;
  }
  img { /* future proofing */
    max-width: 100%;
    height: auto;
  }
}

/* pagination */
@media print {
  body {

    width: 100%;
  }
  p {
    orphans: 3;
    widows: 3;
  }
  #n-copyright-notice {
    border-bottom: none;
  }
  #toc, #n-introduction {
    page-break-before: always;
  }
  #toc {
    border-top: none;
    padding-top: 0;
  }
  figure, pre {
    page-break-inside: avoid;
  }
  figure {
    overflow: scroll;
  }
  .breakable pre {
    break-inside: auto;
  }
  h1, h2, h3, h4, h5, h6 {
    page-break-after: avoid;
  }
  h2+*, h3+*, h4+*, h5+*, h6+* {
    page-break-before: avoid;
  }
  pre {
    white-space: pre-wrap;
    word-wrap: break-word;
    font-size: 10pt;
  }
  table {
    border: 1px solid #ddd;
  }
  td {
    border-top: 1px solid #ddd;
  }
}

/* This is commented out here, as the string-set: doesn't
   pass W3C validation currently */
/*
.ears thead .left {
  string-set: ears-top-left content();
}

.ears thead .center {
  string-set: ears-top-center content();
}

.ears thead .right {
  string-set: ears-top-right content();
}

.ears tfoot .left {
  string-set: ears-bottom-left content();
}

.ears tfoot .center {
  string-set: ears-bottom-center content();
}

.ears tfoot .right {
  string-set: ears-bottom-right content();
}
*/

@page :first {
  padding-top: 0;
  @top-left {
    content: normal;
    border: none;
  }
  @top-center {
    content: normal;
    border: none;
  }
  @top-right {
    content: normal;
    border: none;
  }
}

@page {
  size: A4;
  margin-bottom: 45mm;
  padding-top: 20px;
  /* The following is commented out here, but set appropriately by in code, as
     the content depends on the document */
  /*
  @top-left {
    content: 'Internet-Draft';
    vertical-align: bottom;
    border-bottom: solid 1px #ccc;
  }
  @top-left {
    content: string(ears-top-left);
    vertical-align: bottom;
    border-bottom: solid 1px #ccc;
  }
  @top-center {
    content: string(ears-top-center);
    vertical-align: bottom;
    border-bottom: solid 1px #ccc;
  }
  @top-right {
    content: string(ears-top-right);
    vertical-align: bottom;
    border-bottom: solid 1px #ccc;
  }
  @bottom-left {
    content: string(ears-bottom-left);
    vertical-align: top;
    border-top: solid 1px #ccc;
  }
  @bottom-center {
    content: string(ears-bottom-center);
    vertical-align: top;
    border-top: solid 1px #ccc;
  }
  @bottom-right {
      content: '[Page ' counter(page) ']';
      vertical-align: top;
      border-top: solid 1px #ccc;
  }
  */

}

/* Changes introduced to fix issues found during implementation */
/* Make sure links are clickable even if overlapped by following H* */
a {
  z-index: 2;
}
/* Separate body from document info even without intervening H1 */
section {
  clear: both;
}


/* Top align author divs, to avoid names without organization dropping level with org names */
.author {
  vertical-align: top;
}

/* Leave room in document info to show Internet-Draft on one line */
#identifiers dt {
  width: 8em;
}

/* Don't waste quite as much whitespace between label and value in doc info */
#identifiers dd {
  margin-left: 1em;
}

/* Give floating toc a background color (needed when it's a div inside section */
#toc {
  background-color: white;
}

/* Make the collapsed ToC header render white on gray also when it's a link */
@media screen and (max-width: 1023px) {
  #toc h2 a,
  #toc h2 a:link,
  #toc h2 a:focus,
  #toc h2 a:hover,
  #toc a.toplink,
  #toc a.toplink:hover {
    color: white;
    background-color: #444;
    text-decoration: none;
  }
}

/* Give the bottom of the ToC some whitespace */
@media screen and (min-width: 1024px) {
  #toc {
    padding: 0 0 1em 1em;
  }
}

/* Style section numbers with more space between number and title */
.section-number {
  padding-right: 0.5em;
}

/* prevent monospace from becoming overly large */
tt, code, pre {
  font-size: 95%;
}

/* Fix the height/width aspect for ascii art*/
.sourcecode pre,
.art-text pre {
  line-height: 1.12;
}


/* Add styling for a link in the ToC that points to the top of the document */
a.toplink {
  float: right;
  margin-right: 0.5em;
}

/* Fix the dl styling to match the RFC 7992 attributes */
dl > dt,
dl.dlParallel > dt {
  float: left;
  margin-right: 1em;
}
dl.dlNewline > dt {
  float: none;
}

/* Provide styling for table cell text alignment */
table td.text-left,
table th.text-left {
  text-align: left;
}
table td.text-center,
table th.text-center {
  text-align: center;
}
table td.text-right,
table th.text-right {
  text-align: right;
}

/* Make the alternative author contact information look less like just another
   author, and group it closer with the primary author contact information */
.alternative-contact {
  margin: 0.5em 0 0.25em 0;
}
address .non-ascii {
  margin: 0 0 0 2em;
}

/* With it being possible to set tables with alignment
  left, center, and right, { width: 100%; } does not make sense */
table {
  width: auto;
}

/* Avoid reference text that sits in a block with very wide left margin,
   because of a long floating dt label.*/
.references dd {
  overflow: visible;
}

/* Control caption placement */
caption {
  caption-side: bottom;
}

/* Limit the width of the author address vcard, so names in right-to-left
   script don't end up on the other side of the page. */

address.vcard {
  max-width: 30em;
  margin-right: auto;
}

/* For address alignment dependent on LTR or RTL scripts */
address div.left {
  text-align: left;
}
address div.right {
  text-align: right;
}

/* Provide table alignment support.  We can't use the alignX classes above
   since they do unwanted things with caption and other styling. */
table.right {
 margin-left: auto;
 margin-right: 0;
}
table.center {
 margin-left: auto;
 margin-right: auto;
}
table.left {
 margin-left: 0;
 margin-right: auto;
}

/* Give the table caption label the same styling as the figcaption */
caption a[href] {
  color: #222;
}

@media print {
  .toplink {
    display: none;
  }

  /* avoid overwriting the top border line with the ToC header */
  #toc {
    padding-top: 1px;
  }

  /* Avoid page breaks inside dl and author address entries */
  .vcard {
    page-break-inside: avoid;
  }

}
/* Tweak the bcp14 keyword presentation */
.bcp14 {
  font-variant: small-caps;
  font-weight: bold;
  font-size: 0.9em;
}
/* Tweak the invisible space above H* in order not to overlay links in text above */
 h2 {
  margin-top: -18px;  /* provide offset for in-page anchors */
  padding-top: 31px;
 }
 h3 {
  margin-top: -18px;  /* provide offset for in-page anchors */
  padding-top: 24px;
 }
 h4 {
  margin-top: -18px;  /* provide offset for in-page anchors */
  padding-top: 24px;
 }
/* Float artwork pilcrow to the right */
@media screen {
  .artwork a.pilcrow {
    display: block;
    line-height: 0.7;
    margin-top: 0.15em;
  }
}
/* Make pilcrows on dd visible */
@media screen {
  dd:hover > a.pilcrow {
    visibility: visible;
  }
}
/* Make the placement of figcaption match that of a table's caption
   by removing the figure's added bottom margin */
.alignLeft.art-text,
.alignCenter.art-text,
.alignRight.art-text {
   margin-bottom: 0;
}
.alignLeft,
.alignCenter,
.alignRight {
  margin: 1em 0 0 0;
}
/* In print, the pilcrow won't show on hover, so prevent it from taking up space,
   possibly even requiring a new line */
@media print {
  a.pilcrow {
    display: none;
  }
}
/* Styling for the external metadata */
div#external-metadata {
  background-color: #eee;
  padding: 0.5em;
  margin-bottom: 0.5em;
  display: none;
}
div#internal-metadata {
  padding: 0.5em;                       /* to match the external-metadata padding */
}
/* Styling for title RFC Number */
h1#rfcnum {
  clear: both;
  margin: 0 0 -1em;
  padding: 1em 0 0 0;
}
/* Make .olPercent look the same as <ol><li> */
dl.olPercent > dd {
  margin-bottom: 0.25em;
  min-height: initial;
}
/* Give aside some styling to set it apart */
aside {
  border-left: 1px solid #ddd;
  margin: 1em 0 1em 2em;
  padding: 0.2em 2em;
}
aside > dl,
aside > ol,
aside > ul,
aside > table,
aside > p {
  margin-bottom: 0.5em;
}
/* Additional page break settings */
@media print {
  figcaption, table caption {
    page-break-before: avoid;
  }
}
/* Font size adjustments for print */
@media print {
  body  { font-size: 10pt;      line-height: normal; max-width: 96%; }
  h1    { font-size: 1.72em;    padding-top: 1.5em; } /* 1*1.2*1.2*1.2 */
  h2    { font-size: 1.44em;    padding-top: 1.5em; } /* 1*1.2*1.2 */
  h3    { font-size: 1.2em;     padding-top: 1.5em; } /* 1*1.2 */
  h4    { font-size: 1em;       padding-top: 1.5em; }
  h5, h6 { font-size: 1em;      margin: initial; padding: 0.5em 0 0.3em; }
}
/* Sourcecode margin in print, when there's no pilcrow */
@media print {
  .artwork,
  .artwork > pre,
  .sourcecode {
    margin-bottom: 1em;
  }
}
/* Avoid narrow tables forcing too narrow table captions, which may render badly */
table {
  min-width: 20em;
}
/* ol type a */
ol.type-a { list-style-type: lower-alpha; }
ol.type-A { list-style-type: upper-alpha; }
ol.type-i { list-style-type: lower-roman; }
ol.type-I { list-style-type: lower-roman; }
/* Apply the print table and row borders in general, on request from the RPC,
and increase the contrast between border and odd row background slightly */
table {
  border: 1px solid #ddd;
}
td {
  border-top: 1px solid #ddd;
}
tr {
  break-inside: avoid;
}
tr:nth-child(2n+1) > td {
  background-color: #f8f8f8;
}
/* Use style rules to govern display of the TOC. */
@media screen and (max-width: 1023px) {
  #toc nav { display: none; }
  #toc.active nav { display: block; }
}
/* Add support for keepWithNext */
.keepWithNext {
  break-after: avoid-page;
  break-after: avoid-page;
}
/* Add support for keepWithPrevious */
.keepWithPrevious {
  break-before: avoid-page;
}
/* Change the approach to avoiding breaks inside artwork etc. */
figure, pre, table, .artwork, .sourcecode  {
  break-before: auto;
  break-after: auto;
}
/* Avoid breaks between <dt> and <dd> */
dl {
  break-before: auto;
  break-inside: auto;
}
dt {
  break-before: auto;
  break-after: avoid-page;
}
dd {
  break-before: avoid-page;
  break-after: auto;
  orphans: 3;
  widows: 3
}
span.break, dd.break {
  margin-bottom: 0;
  min-height: 0;
  break-before: auto;
  break-inside: auto;
  break-after: auto;
}
/* Undo break-before ToC */
@media print {
  #toc {
    break-before: auto;
  }
}
/* Text in compact lists should not get extra bottom margin space,
   since that would makes the list not compact */
ul.compact p, .ulCompact p,
ol.compact p, .olCompact p {
 margin: 0;
}
/* But the list as a whole needs the extra space at the end */
section ul.compact,
section .ulCompact,
section ol.compact,
section .olCompact {
  margin-bottom: 1em;                    /* same as p not within ul.compact etc. */
}
/* The tt and code background above interferes with for instance table cell
   backgrounds.  Changed to something a bit more selective. */
tt, code {
  background-color: transparent;
}
p tt, p code, li tt, li code {
  background-color: #f8f8f8;
}
/* Tweak the pre margin -- 0px doesn't come out well */
pre {
   margin-top: 0.5px;
}
/* Tweak the compact list text */
ul.compact, .ulCompact,
ol.compact, .olCompact,
dl.compact, .dlCompact {
  line-height: normal;
}
/* Don't add top margin for nested lists */
li > ul, li > ol, li > dl,
dd > ul, dd > ol, dd > dl,
dl > dd > dl {
  margin-top: initial;
}
/* Elements that should not be rendered on the same line as a <dt> */
/* This should match the element list in writer.text.TextWriter.render_dl() */
dd > div.artwork:first-child,
dd > aside:first-child,
dd > figure:first-child,
dd > ol:first-child,
dd > div.sourcecode:first-child,
dd > table:first-child,
dd > ul:first-child {
  clear: left;
}
/* fix for weird browser behaviour when <dd/> is empty */
dt+dd:empty::before{
  content: "\00a0";
}
/* Make paragraph spacing inside <li> smaller than in body text, to fit better within the list */
li > p {
  margin-bottom: 0.5em
}
/* Don't let p margin spill out from inside list items */
li > p:last-of-type:only-child {
  margin-bottom: 0;
}
</style>
<link href="rfc-local.css" rel="stylesheet" type="text/css"/>
<link href="https://dx.doi.org/10.17487/rfc9331" rel="alternate"/>
  <link href="urn:issn:2070-1721" rel="alternate"/>
  <link href="https://datatracker.ietf.org/doc/draft-ietf-tsvwg-ecn-l4s-id-29" rel="prev"/>
  </head>
<body class="xml2rfc">
<script src="https://www.rfc-editor.org/js/metadata.min.js"></script>
<table class="ears">
<thead><tr>
<td class="left">RFC 9331</td>
<td class="center">ECN Protocol for L4S</td>
<td class="right">January 2023</td>
</tr></thead>
<tfoot><tr>
<td class="left">De Schepper &amp; Briscoe</td>
<td class="center">Experimental</td>
<td class="right">[Page]</td>
</tr></tfoot>
</table>
<div class="document-information" id="external-metadata"></div>
<div class="document-information" id="internal-metadata">
<dl id="identifiers">
<dt class="label-stream">Stream:</dt>
<dd class="stream">Internet Engineering Task Force (IETF)</dd>
<dt class="label-rfc">RFC:</dt>
<dd class="rfc"><a class="eref" href="https://www.rfc-editor.org/rfc/rfc9331">9331</a></dd>
<dt class="label-category">Category:</dt>
<dd class="category">Experimental</dd>
<dt class="label-published">Published:</dt>
<dd class="published">
<time class="published" datetime="2023-01">January 2023</time>
    </dd>
<dt class="label-issn">ISSN:</dt>
<dd class="issn">2070-1721</dd>
<dt class="label-authors">Authors:</dt>
<dd class="authors">
<div class="author">
      <div class="author-name">K. De Schepper</div>
<div class="org">Nokia Bell Labs</div>
</div>
<div class="author">
      <div class="author-name">B. Briscoe, <span class="editor">Ed.</span>
</div>
<div class="org">Independent</div>
</div>
</dd>
</dl>
</div>
<h1 id="rfcnum">RFC 9331</h1>
<h1 id="title">The Explicit Congestion Notification (ECN) Protocol for Low Latency, Low Loss, and Scalable Throughput (L4S)</h1>
<section id="section-abstract">
      <h2 id="abstract"><a class="selfRef" href="#abstract">Abstract</a></h2>
<p id="section-abstract-1">This specification defines the protocol to be used for a new network
      service called Low Latency, Low Loss, and Scalable throughput (L4S). L4S
      uses an Explicit Congestion Notification (ECN) scheme at the IP layer
      that is similar to the original (or 'Classic') ECN approach, except as
      specified within. L4S uses 'Scalable' congestion control, which induces
      much more frequent control signals from the network, and it responds to
      them with much more fine-grained adjustments so that very low
      (typically sub-millisecond on average) and consistently low queuing
      delay becomes possible for L4S traffic without compromising link
      utilization. Thus, even capacity-seeking (TCP-like) traffic can have high
      bandwidth and very low delay at the same time, even during periods of
      high traffic load.<a class="pilcrow" href="#section-abstract-1">¶</a></p>
<p id="section-abstract-2">The L4S identifier defined in this document distinguishes L4S from
      'Classic' (e.g., TCP-Reno-friendly) traffic. Then, network
      bottlenecks can be incrementally modified to distinguish and isolate
      existing traffic that still follows the Classic behaviour, to prevent it
      from degrading the low queuing delay and low loss of L4S traffic. This
      Experimental specification defines the rules that L4S transports
      and network elements need to follow, with the intention that L4S flows
      neither harm each other's performance nor that of Classic traffic. It
      also suggests open questions to be investigated during experimentation.
      Examples of new Active Queue Management (AQM) marking algorithms and
      new transports (whether TCP-like or real time) are specified
      separately.<a class="pilcrow" href="#section-abstract-2">¶</a></p>
</section>
<div id="status-of-memo">
<section id="section-boilerplate.1">
        <h2 id="name-status-of-this-memo">
<a class="section-name selfRef" href="#name-status-of-this-memo">Status of This Memo</a>
        </h2>
<p id="section-boilerplate.1-1">
            This document is not an Internet Standards Track specification; it is
            published for examination, experimental implementation, and
            evaluation.<a class="pilcrow" href="#section-boilerplate.1-1">¶</a></p>
<p id="section-boilerplate.1-2">
            This document defines an Experimental Protocol for the Internet
            community.  This document is a product of the Internet Engineering
            Task Force (IETF).  It represents the consensus of the IETF community.
            It has received public review and has been approved for publication
            by the Internet Engineering Steering Group (IESG).  Not all documents
            approved by the IESG are candidates for any level of Internet
            Standard; see Section 2 of RFC 7841.<a class="pilcrow" href="#section-boilerplate.1-2">¶</a></p>
<p id="section-boilerplate.1-3">
            Information about the current status of this document, any
            errata, and how to provide feedback on it may be obtained at
            <span><a href="https://www.rfc-editor.org/info/rfc9331">https://www.rfc-editor.org/info/rfc9331</a></span>.<a class="pilcrow" href="#section-boilerplate.1-3">¶</a></p>
</section>
</div>
<div id="copyright">
<section id="section-boilerplate.2">
        <h2 id="name-copyright-notice">
<a class="section-name selfRef" href="#name-copyright-notice">Copyright Notice</a>
        </h2>
<p id="section-boilerplate.2-1">
            Copyright (c) 2023 IETF Trust and the persons identified as the
            document authors. All rights reserved.<a class="pilcrow" href="#section-boilerplate.2-1">¶</a></p>
<p id="section-boilerplate.2-2">
            This document is subject to BCP 78 and the IETF Trust's Legal
            Provisions Relating to IETF Documents
            (<span><a href="https://trustee.ietf.org/license-info">https://trustee.ietf.org/license-info</a></span>) in effect on the date of
            publication of this document. Please review these documents
            carefully, as they describe your rights and restrictions with
            respect to this document. Code Components extracted from this
            document must include Revised BSD License text as described in
            Section 4.e of the Trust Legal Provisions and are provided without
            warranty as described in the Revised BSD License.<a class="pilcrow" href="#section-boilerplate.2-2">¶</a></p>
</section>
</div>
<div id="toc">
<section id="section-toc.1">
        <a class="toplink" href="#" onclick="scroll(0,0)">▲</a><h2 id="name-table-of-contents">
<a class="section-name selfRef" href="#name-table-of-contents">Table of Contents</a>
        </h2>
<nav class="toc"><ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.1">
            <p id="section-toc.1-1.1.1"><a class="auto internal xref" href="#section-1">1</a>.  <a class="internal xref" href="#name-introduction">Introduction</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.1.2.1">
                <p class="keepWithNext" id="section-toc.1-1.1.2.1.1"><a class="auto internal xref" href="#section-1.1">1.1</a>.  <a class="internal xref" href="#name-latency-loss-and-scaling-pr">Latency, Loss, and Scaling Problems</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.1.2.2">
                <p class="keepWithNext" id="section-toc.1-1.1.2.2.1"><a class="auto internal xref" href="#section-1.2">1.2</a>.  <a class="internal xref" href="#name-terminology">Terminology</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.1.2.3">
                <p class="keepWithNext" id="section-toc.1-1.1.2.3.1"><a class="auto internal xref" href="#section-1.3">1.3</a>.  <a class="internal xref" href="#name-scope">Scope</a></p>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.2">
            <p id="section-toc.1-1.2.1"><a class="auto internal xref" href="#section-2">2</a>.  <a class="internal xref" href="#name-l4s-packet-identification-d">L4S Packet Identification: Document Roadmap</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.3">
            <p id="section-toc.1-1.3.1"><a class="auto internal xref" href="#section-3">3</a>.  <a class="internal xref" href="#name-choice-of-l4s-packet-identi">Choice of L4S Packet Identifier: Requirements</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4">
            <p id="section-toc.1-1.4.1"><a class="auto internal xref" href="#section-4">4</a>.  <a class="internal xref" href="#name-transport-layer-behaviour-t">Transport-Layer Behaviour (the 'Prague L4S Requirements')</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.1">
                <p id="section-toc.1-1.4.2.1.1"><a class="auto internal xref" href="#section-4.1">4.1</a>.  <a class="internal xref" href="#name-codepoint-setting">Codepoint Setting</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.2">
                <p id="section-toc.1-1.4.2.2.1"><a class="auto internal xref" href="#section-4.2">4.2</a>.  <a class="internal xref" href="#name-prerequisite-transport-feed">Prerequisite Transport Feedback</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.3">
                <p id="section-toc.1-1.4.2.3.1"><a class="auto internal xref" href="#section-4.3">4.3</a>.  <a class="internal xref" href="#name-prerequisite-congestion-res">Prerequisite Congestion Response</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.3.2.1">
                    <p id="section-toc.1-1.4.2.3.2.1.1"><a class="auto internal xref" href="#section-4.3.1">4.3.1</a>.  <a class="internal xref" href="#name-guidance-on-congestion-resp">Guidance on Congestion Response in the RFC Series</a></p>
</li>
                </ul>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.4">
                <p id="section-toc.1-1.4.2.4.1"><a class="auto internal xref" href="#section-4.4">4.4</a>.  <a class="internal xref" href="#name-filtering-or-smoothing-of-e">Filtering or Smoothing of ECN Feedback</a></p>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.5">
            <p id="section-toc.1-1.5.1"><a class="auto internal xref" href="#section-5">5</a>.  <a class="internal xref" href="#name-network-node-behaviour">Network Node Behaviour</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.5.2.1">
                <p id="section-toc.1-1.5.2.1.1"><a class="auto internal xref" href="#section-5.1">5.1</a>.  <a class="internal xref" href="#name-classification-and-re-marki">Classification and Re-Marking Behaviour</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.5.2.2">
                <p id="section-toc.1-1.5.2.2.1"><a class="auto internal xref" href="#section-5.2">5.2</a>.  <a class="internal xref" href="#name-the-strength-of-l4s-ce-mark">The Strength of L4S CE Marking Relative to Drop</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.5.2.3">
                <p id="section-toc.1-1.5.2.3.1"><a class="auto internal xref" href="#section-5.3">5.3</a>.  <a class="internal xref" href="#name-exception-for-l4s-packet-id">Exception for L4S Packet Identification by Network Nodes with Transport-Layer Awareness</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.5.2.4">
                <p id="section-toc.1-1.5.2.4.1"><a class="auto internal xref" href="#section-5.4">5.4</a>.  <a class="internal xref" href="#name-interaction-of-the-l4s-iden">Interaction of the L4S Identifier with Other Identifiers</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.5.2.4.2.1">
                    <p id="section-toc.1-1.5.2.4.2.1.1"><a class="auto internal xref" href="#section-5.4.1">5.4.1</a>.  <a class="internal xref" href="#name-dualq-examples-of-other-ide">DualQ Examples of Other Identifiers Complementing L4S Identifiers</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.5.2.4.2.1.2.1">
                        <p id="section-toc.1-1.5.2.4.2.1.2.1.1"><a class="auto internal xref" href="#section-5.4.1.1">5.4.1.1</a>.  <a class="internal xref" href="#name-inclusion-of-additional-tra">Inclusion of Additional Traffic with L4S</a></p>
</li>
                      <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.5.2.4.2.1.2.2">
                        <p id="section-toc.1-1.5.2.4.2.1.2.2.1"><a class="auto internal xref" href="#section-5.4.1.2">5.4.1.2</a>.  <a class="internal xref" href="#name-exclusion-of-traffic-from-l">Exclusion of Traffic from L4S Treatment</a></p>
</li>
                      <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.5.2.4.2.1.2.3">
                        <p id="section-toc.1-1.5.2.4.2.1.2.3.1"><a class="auto internal xref" href="#section-5.4.1.3">5.4.1.3</a>.  <a class="internal xref" href="#name-generalized-combination-of-">Generalized Combination of L4S and Other Identifiers</a></p>
</li>
                    </ul>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.5.2.4.2.2">
                    <p id="section-toc.1-1.5.2.4.2.2.1"><a class="auto internal xref" href="#section-5.4.2">5.4.2</a>.  <a class="internal xref" href="#name-per-flow-queuing-examples-o">Per-flow Queuing Examples of Other Identifiers Complementing L4S Identifiers</a></p>
</li>
                </ul>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.5.2.5">
                <p id="section-toc.1-1.5.2.5.1"><a class="auto internal xref" href="#section-5.5">5.5</a>.  <a class="internal xref" href="#name-limiting-packet-bursts-from">Limiting Packet Bursts from Links</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.5.2.5.2.1">
                    <p id="section-toc.1-1.5.2.5.2.1.1"><a class="auto internal xref" href="#section-5.5.1">5.5.1</a>.  <a class="internal xref" href="#name-limiting-packet-bursts-from-">Limiting Packet Bursts from Links Fed by an L4S AQM</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.5.2.5.2.2">
                    <p id="section-toc.1-1.5.2.5.2.2.1"><a class="auto internal xref" href="#section-5.5.2">5.5.2</a>.  <a class="internal xref" href="#name-limiting-packet-bursts-from-l">Limiting Packet Bursts from Links Upstream of an L4S AQM</a></p>
</li>
                </ul>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.6">
            <p id="section-toc.1-1.6.1"><a class="auto internal xref" href="#section-6">6</a>.  <a class="internal xref" href="#name-behaviour-of-tunnels-and-en">Behaviour of Tunnels and Encapsulations</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.6.2.1">
                <p id="section-toc.1-1.6.2.1.1"><a class="auto internal xref" href="#section-6.1">6.1</a>.  <a class="internal xref" href="#name-no-change-to-ecn-tunnels-an">No Change to ECN Tunnels and Encapsulations in General</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.6.2.2">
                <p id="section-toc.1-1.6.2.2.1"><a class="auto internal xref" href="#section-6.2">6.2</a>.  <a class="internal xref" href="#name-vpn-behaviour-to-avoid-limi">VPN Behaviour to Avoid Limitations of Anti-Replay</a></p>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.7">
            <p id="section-toc.1-1.7.1"><a class="auto internal xref" href="#section-7">7</a>.  <a class="internal xref" href="#name-l4s-experiments">L4S Experiments</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.7.2.1">
                <p id="section-toc.1-1.7.2.1.1"><a class="auto internal xref" href="#section-7.1">7.1</a>.  <a class="internal xref" href="#name-open-questions">Open Questions</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.7.2.2">
                <p id="section-toc.1-1.7.2.2.1"><a class="auto internal xref" href="#section-7.2">7.2</a>.  <a class="internal xref" href="#name-open-issues">Open Issues</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.7.2.3">
                <p id="section-toc.1-1.7.2.3.1"><a class="auto internal xref" href="#section-7.3">7.3</a>.  <a class="internal xref" href="#name-future-potential">Future Potential</a></p>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.8">
            <p id="section-toc.1-1.8.1"><a class="auto internal xref" href="#section-8">8</a>.  <a class="internal xref" href="#name-iana-considerations">IANA Considerations</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.9">
            <p id="section-toc.1-1.9.1"><a class="auto internal xref" href="#section-9">9</a>.  <a class="internal xref" href="#name-security-considerations">Security Considerations</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.10">
            <p id="section-toc.1-1.10.1"><a class="auto internal xref" href="#section-10">10</a>. <a class="internal xref" href="#name-references">References</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.10.2.1">
                <p id="section-toc.1-1.10.2.1.1"><a class="auto internal xref" href="#section-10.1">10.1</a>.  <a class="internal xref" href="#name-normative-references">Normative References</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.10.2.2">
                <p id="section-toc.1-1.10.2.2.1"><a class="auto internal xref" href="#section-10.2">10.2</a>.  <a class="internal xref" href="#name-informative-references">Informative References</a></p>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.11">
            <p id="section-toc.1-1.11.1"><a class="auto internal xref" href="#appendix-A">Appendix A</a>.  <a class="internal xref" href="#name-rationale-for-the-prague-l4">Rationale for the 'Prague L4S Requirements'</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.11.2.1">
                <p id="section-toc.1-1.11.2.1.1"><a class="auto internal xref" href="#appendix-A.1">A.1</a>.  <a class="internal xref" href="#name-rationale-for-the-requireme">Rationale for the Requirements for Scalable Transport Protocols</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.11.2.1.2.1">
                    <p id="section-toc.1-1.11.2.1.2.1.1"><a class="auto internal xref" href="#appendix-A.1.1">A.1.1</a>.  <a class="internal xref" href="#name-use-of-l4s-packet-identifie">Use of L4S Packet Identifier</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.11.2.1.2.2">
                    <p id="section-toc.1-1.11.2.1.2.2.1"><a class="auto internal xref" href="#appendix-A.1.2">A.1.2</a>.  <a class="internal xref" href="#name-accurate-ecn-feedback">Accurate ECN Feedback</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.11.2.1.2.3">
                    <p id="section-toc.1-1.11.2.1.2.3.1"><a class="auto internal xref" href="#appendix-A.1.3">A.1.3</a>.  <a class="internal xref" href="#name-capable-of-replacement-by-c">Capable of Replacement by Classic Congestion Control</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.11.2.1.2.4">
                    <p id="section-toc.1-1.11.2.1.2.4.1"><a class="auto internal xref" href="#appendix-A.1.4">A.1.4</a>.  <a class="internal xref" href="#name-fall-back-to-classic-conges">Fall Back to Classic Congestion Control on Packet Loss</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.11.2.1.2.5">
                    <p id="section-toc.1-1.11.2.1.2.5.1"><a class="auto internal xref" href="#appendix-A.1.5">A.1.5</a>.  <a class="internal xref" href="#name-coexistence-with-classic-co">Coexistence with Classic Congestion Control at Classic ECN Bottlenecks</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.11.2.1.2.6">
                    <p id="section-toc.1-1.11.2.1.2.6.1"><a class="auto internal xref" href="#appendix-A.1.6">A.1.6</a>.  <a class="internal xref" href="#name-reduce-rtt-dependence">Reduce RTT Dependence</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.11.2.1.2.7">
                    <p id="section-toc.1-1.11.2.1.2.7.1"><a class="auto internal xref" href="#appendix-A.1.7">A.1.7</a>.  <a class="internal xref" href="#name-scaling-down-to-fractional-">Scaling Down to Fractional Congestion Windows</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.11.2.1.2.8">
                    <p id="section-toc.1-1.11.2.1.2.8.1"><a class="auto internal xref" href="#appendix-A.1.8">A.1.8</a>.  <a class="internal xref" href="#name-measuring-reordering-tolera">Measuring Reordering Tolerance in Time Units</a></p>
</li>
                </ul>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.11.2.2">
                <p id="section-toc.1-1.11.2.2.1"><a class="auto internal xref" href="#appendix-A.2">A.2</a>.  <a class="internal xref" href="#name-scalable-transport-protocol">Scalable Transport Protocol Optimizations</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.11.2.2.2.1">
                    <p id="section-toc.1-1.11.2.2.2.1.1"><a class="auto internal xref" href="#appendix-A.2.1">A.2.1</a>.  <a class="internal xref" href="#name-setting-ect-in-control-pack">Setting ECT in Control Packets and Retransmissions</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.11.2.2.2.2">
                    <p id="section-toc.1-1.11.2.2.2.2.1"><a class="auto internal xref" href="#appendix-A.2.2">A.2.2</a>.  <a class="internal xref" href="#name-faster-than-additive-increa">Faster than Additive Increase</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.11.2.2.2.3">
                    <p id="section-toc.1-1.11.2.2.2.3.1"><a class="auto internal xref" href="#appendix-A.2.3">A.2.3</a>.  <a class="internal xref" href="#name-faster-convergence-at-flow-">Faster Convergence at Flow Start</a></p>
</li>
                </ul>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.12">
            <p id="section-toc.1-1.12.1"><a class="auto internal xref" href="#appendix-B">Appendix B</a>.  <a class="internal xref" href="#name-compromises-in-the-choice-o">Compromises in the Choice of L4S Identifier</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.13">
            <p id="section-toc.1-1.13.1"><a class="auto internal xref" href="#appendix-C">Appendix C</a>.  <a class="internal xref" href="#name-potential-competing-uses-fo">Potential Competing Uses for the ECT(1) Codepoint</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.13.2.1">
                <p id="section-toc.1-1.13.2.1.1"><a class="auto internal xref" href="#appendix-C.1">C.1</a>.  <a class="internal xref" href="#name-integrity-of-congestion-fee">Integrity of Congestion Feedback</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.13.2.2">
                <p id="section-toc.1-1.13.2.2.1"><a class="auto internal xref" href="#appendix-C.2">C.2</a>.  <a class="internal xref" href="#name-notification-of-less-severe">Notification of Less Severe Congestion than CE</a></p>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.14">
            <p id="section-toc.1-1.14.1"><a class="auto internal xref" href="#appendix-D"></a><a class="internal xref" href="#name-acknowledgements">Acknowledgements</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.15">
            <p id="section-toc.1-1.15.1"><a class="auto internal xref" href="#appendix-E"></a><a class="internal xref" href="#name-authors-addresses">Authors' Addresses</a></p>
</li>
        </ul>
</nav>
</section>
</div>
<div id="l4sid_intro">
<section id="section-1">
      <h2 id="name-introduction">
<a class="section-number selfRef" href="#section-1">1. </a><a class="section-name selfRef" href="#name-introduction">Introduction</a>
      </h2>
<p id="section-1-1">This Experimental specification defines the protocol to be used
      for a new network service called Low Latency, Low Loss, and Scalable
      throughput (L4S). L4S uses an Explicit Congestion Notification (ECN)
      scheme at the IP layer with the same set of codepoint transitions as the
      original (or 'Classic') ECN <span>[<a class="cite xref" href="#RFC3168">RFC3168</a>]</span>. <span>[<a class="cite xref" href="#RFC3168">RFC3168</a>]</span> requires an ECN mark to be equivalent
      to a drop, both when applied in the network and when responded to by a
      transport. Unlike Classic ECN marking, i) the network applies L4S
      marking more immediately and more frequently than drop and ii) the
      transport response to each mark is reduced and smoothed relative to that
      for drop. The two changes counterbalance each other so that the
      throughput of an L4S flow will be roughly the same as a comparable
      non-L4S flow under the same conditions. Nonetheless, the much more
      frequent ECN control signals and the finer responses to these signals
      result in very low queuing delay without compromising link utilization,
      and this low delay can be maintained during high load. For instance,
      queuing delay under heavy and highly varying load with the example
      DCTCP/DualQ solution described below on a DSL or Ethernet link is  
      sub-millisecond on average and roughly 1 to 2 milliseconds at the 99th
      percentile without losing link utilization <span>[<a class="cite xref" href="#L4Seval22">L4Seval22</a>]</span> <span>[<a class="cite xref" href="#DualPI2Linux">DualPI2Linux</a>]</span>.       
      Note that the queuing
      delay while waiting to acquire a shared medium such as wireless has to
      be added to the above. It is a different issue that needs to be
      addressed, but separately (see Section <a class="relref" href="https://www.rfc-editor.org/rfc/rfc9330#section-6.3">6.3</a> of the L4S
      architecture <span>[<a class="cite xref" href="#RFC9330">RFC9330</a>]</span>).<a class="pilcrow" href="#section-1-1">¶</a></p>
<p id="section-1-2">L4S relies on 'Scalable' congestion controls for these delay
      properties and for preserving low delay as flow rate scales, hence the
      name. The congestion control used in Data Center TCP (DCTCP) is an
      example of a Scalable congestion control, but DCTCP is applicable solely
      to controlled environments like data centres <span>[<a class="cite xref" href="#RFC8257">RFC8257</a>]</span>, because it is too aggressive to coexist with
      existing TCP-Reno-friendly traffic. Dual-Queue Coupled AQM, which is
      defined in a complementary Experimental specification <span>[<a class="cite xref" href="#RFC9332">RFC9332</a>]</span>, is an AQM framework that
      enables Scalable congestion controls derived from DCTCP to coexist with
      existing traffic, each getting roughly the same flow rate when they
      compete under similar conditions. Note that a Scalable congestion
      control is still not safe to deploy on the Internet unless it satisfies
      the requirements listed in <a class="auto internal xref" href="#l4sid_transport_req">Section 4</a>.<a class="pilcrow" href="#section-1-2">¶</a></p>
<p id="section-1-3">L4S is not only for elastic (TCP-like) traffic -- there are Scalable
      congestion controls for real-time media, such as the L4S variant <span>[<a class="cite xref" href="#SCReAM-L4S">SCReAM-L4S</a>]</span> of the SCReAM <span>[<a class="cite xref" href="#RFC8298">RFC8298</a>]</span> RTP Media Congestion Avoidance Techniques (RMCAT). The factor that
      distinguishes L4S from Classic traffic is its behaviour in response to
      congestion. 
      The transport wire protocol, e.g., TCP, QUIC, the Stream Control Transmission Protocol (SCTP),
      the Datagram Congestion Control Protocol (DCCP), or RTP/RTCP, is orthogonal (and therefore not suitable for
      distinguishing L4S from Classic packets).<a class="pilcrow" href="#section-1-3">¶</a></p>
<p id="section-1-4">The L4S identifier defined in this document is the key piece that
      distinguishes L4S from 'Classic' (e.g., Reno-friendly) traffic.
      Then, network bottlenecks can be incrementally modified to distinguish
      and isolate existing Classic traffic from L4S traffic, to prevent the
      former from degrading the very low queuing delay and loss of the new
      Scalable transports, without harming Classic performance at these
      bottlenecks. Although both sender and network deployment are required
      before any benefit, initial implementations of the separate parts of the
      system have been motivated by the potential performance benefits.<a class="pilcrow" href="#section-1-4">¶</a></p>
<div id="l4sid_problem">
<section id="section-1.1">
        <h3 id="name-latency-loss-and-scaling-pr">
<a class="section-number selfRef" href="#section-1.1">1.1. </a><a class="section-name selfRef" href="#name-latency-loss-and-scaling-pr">Latency, Loss, and Scaling Problems</a>
        </h3>
<p id="section-1.1-1">Latency is becoming the critical performance factor for many
        (perhaps most) Internet applications, e.g., interactive web, web
        services, voice, conversational video, interactive video, interactive
        remote presence, instant messaging, online gaming, remote desktop,
        cloud-based applications &amp; services, and remote control of
        machinery and industrial processes. In many parts of the world,
        further increases in access network bitrate offer diminishing returns
        <span>[<a class="cite xref" href="#Dukkipati06">Dukkipati06</a>]</span>, whereas latency is still a multi-faceted
        problem. As a result, much has been done to reduce propagation time by
        placing caches or servers closer to users. However, queuing remains a
        major, albeit intermittent, component of latency.<a class="pilcrow" href="#section-1.1-1">¶</a></p>
<p id="section-1.1-2">The Diffserv architecture provides Expedited Forwarding (EF) <span>[<a class="cite xref" href="#RFC3246">RFC3246</a>]</span> so that low-latency traffic can jump the queue of
        other traffic. If growth in latency-sensitive applications continues,
        periods with solely latency-sensitive traffic will become increasingly
        common on links where traffic aggregation is low. During these
        periods, if all the traffic were marked for the same treatment,
        Diffserv would make no difference. The links with low aggregation also
        tend to become the path bottleneck under load, for instance, the
        access links dedicated to individual sites (homes, small enterprises,
        or mobile devices). So, instead of differentiation, it becomes
        imperative to remove the underlying causes of any unnecessary
        delay.<a class="pilcrow" href="#section-1.1-2">¶</a></p>
<p id="section-1.1-3">The Bufferbloat project has shown that excessively large buffering
        ('bufferbloat') has been introducing significantly more delay than the
        underlying propagation time <span>[<a class="cite xref" href="#Bufferbloat">Bufferbloat</a>]</span>. These delays
        appear only intermittently -- only when a capacity-seeking
        (e.g., TCP) flow is long enough for the queue to fill the buffer,
        causing every packet in other flows sharing the buffer to have to work
        its way through the queue.<a class="pilcrow" href="#section-1.1-3">¶</a></p>
<p id="section-1.1-4">AQM was originally developed to solve
        this problem (and others). Unlike Diffserv, which gives low latency to
        some traffic at the expense of others, AQM controls latency for <em>all</em> traffic in a class. In general, AQM methods
        introduce an increasing level of discard from the buffer, the longer
        the queue persists above a shallow threshold. 
        This gives sufficient
        signals to capacity-seeking (a.k.a. greedy) flows to keep the
        buffer empty for its intended purpose: absorbing bursts.
 However, Random Early Detection (RED) and other algorithms from the 1990s
        were sensitive to their configuration and hard to set correctly <span>[<a class="cite xref" href="#RFC7567">RFC7567</a>]</span>. So
        this form of AQM was not widely deployed.<a class="pilcrow" href="#section-1.1-4">¶</a></p>
<p id="section-1.1-5">More recent state-of-the-art AQM methods, such
        as Flow Queue CoDel <span>[<a class="cite xref" href="#RFC8290">RFC8290</a>]</span>, Proportional Integral controller Enhanced (PIE) <span>[<a class="cite xref" href="#RFC8033">RFC8033</a>]</span>, or Adaptive RED <span>[<a class="cite xref" href="#ARED01">ARED01</a>]</span>, are
        easier to configure, because they define the queuing threshold in time
        not bytes, so configuration is invariant whatever the link rate.
        However, the sawtoothing window of a Classic congestion control
        creates a dilemma for the operator: either i) configure a shallow AQM
        operating point so the tips of the sawteeth cause minimal queue
        delay, but then the troughs underutilize the link, or ii) configure the
        operating point deeper into the buffer so the troughs utilize the
        link better, but then the tips cause more delay variation. Even with a
        perfectly tuned AQM, the additional queuing delay at the tips of the
        sawteeth will be of the same order as the underlying base round-trip
        time (RTT), thereby roughly doubling the total RTT.<a class="pilcrow" href="#section-1.1-5">¶</a></p>
<p id="section-1.1-6">If a sender's own behaviour is introducing queuing delay variation,
        no AQM in the network can 'un-vary' the delay without significantly
        compromising link utilization. Even flow queuing (e.g., <span>[<a class="cite xref" href="#RFC8290">RFC8290</a>]</span>), which isolates one flow from another, cannot
        isolate a flow from the delay variations it inflicts on itself.
        Therefore, those applications that need to seek out high bandwidth but
        also need low latency will have to migrate to Scalable congestion
        control, which uses much smaller sawtooth variations.<a class="pilcrow" href="#section-1.1-6">¶</a></p>
<p id="section-1.1-7">Altering host behaviour is not enough on its own though. Even if
        hosts adopt low-latency Scalable congestion controls, they need to be
        isolated from the large queue variations induced by existing Classic
        congestion controls. L4S AQMs provide that latency isolation in the
        network, and the L4S identifier enables the AQMs to distinguish the two
        types of packets that need to be isolated: L4S and Classic. L4S
        isolation can be achieved with a queue per flow (e.g., <span>[<a class="cite xref" href="#RFC8290">RFC8290</a>]</span>), but a DualQ <span>[<a class="cite xref" href="#RFC9332">RFC9332</a>]</span> is sufficient and
        actually gives better tail latency <span>[<a class="cite xref" href="#DCttH19">DCttH19</a>]</span>. Both
        approaches are addressed in this document.<a class="pilcrow" href="#section-1.1-7">¶</a></p>
<p id="section-1.1-8">The DualQ solution was developed to make very low latency available
        without requiring per-flow queues at every bottleneck. This was useful
        because per-flow queuing (FQ) has well-known downsides -- not least the
        need to inspect transport-layer headers in the network, which makes it
        incompatible with privacy approaches such as IPsec Virtual Private Network (VPN) tunnels and
        incompatible with link-layer queue management, where transport-layer
        headers can be hidden, e.g., 5G.<a class="pilcrow" href="#section-1.1-8">¶</a></p>
<p id="section-1.1-9">Latency is not the only concern addressed by L4S. It was known when
        TCP congestion avoidance was first developed that it would not scale
        to high bandwidth-delay products (see footnote 6 of Jacobson and
        Karels <span>[<a class="cite xref" href="#TCP-CA">TCP-CA</a>]</span>).
        Given that Reno congestion control is already beyond its scaling range at 
        regular broadband bitrates over WAN distances <span>[<a class="cite xref" href="#RFC3649">RFC3649</a>]</span>, 'less unscalable'
        CUBIC <span>[<a class="cite xref" href="#RFC8312">RFC8312</a>]</span> and Compound <span>[<a class="cite xref" href="#I-D.sridharan-tcpm-ctcp">CTCP</a>]</span> variants of TCP have been
        successfully deployed. However, these are now approaching their
        scaling limits. Unfortunately, fully Scalable congestion controls such
        as DCTCP <span>[<a class="cite xref" href="#RFC8257">RFC8257</a>]</span> outcompete Classic ECN
        congestion controls sharing the same queue, which is why they have
        been confined to private data centres or research testbeds.<a class="pilcrow" href="#section-1.1-9">¶</a></p>
<p id="section-1.1-10">It turns out that these Scalable congestion control algorithms that
        solve the latency problem can also solve the scalability problem of
        Classic congestion controls. The finer sawteeth in the congestion
        window (cwnd) have low amplitude, so they cause very little queuing delay
        variation, and the average time to recover from one congestion signal
        to the next (the average duration of each sawtooth) remains invariant,
        which maintains constant tight control as flow rate scales. A
        background paper <span>[<a class="cite xref" href="#L4Seval22">L4Seval22</a>]</span> gives the full
        explanation of why the design solves both the latency and the scaling
        problems, both in plain English and in more precise mathematical form.
        The explanation is summarized without the mathematics in Section <a class="relref" href="https://www.rfc-editor.org/rfc/rfc9330#section-4">4</a> of
        the L4S architecture <span>[<a class="cite xref" href="#RFC9330">RFC9330</a>]</span>.<a class="pilcrow" href="#section-1.1-10">¶</a></p>
</section>
</div>
<div id="l4sid_Terminology">
<section id="section-1.2">
        <h3 id="name-terminology">
<a class="section-number selfRef" href="#section-1.2">1.2. </a><a class="section-name selfRef" href="#name-terminology">Terminology</a>
        </h3>
<p id="section-1.2-1">
    The key words "<span class="bcp14">MUST</span>", "<span class="bcp14">MUST NOT</span>", "<span class="bcp14">REQUIRED</span>", "<span class="bcp14">SHALL</span>", "<span class="bcp14">SHALL NOT</span>", "<span class="bcp14">SHOULD</span>", "<span class="bcp14">SHOULD NOT</span>", "<span class="bcp14">RECOMMENDED</span>", "<span class="bcp14">NOT RECOMMENDED</span>",
    "<span class="bcp14">MAY</span>", and "<span class="bcp14">OPTIONAL</span>" in this document are to be interpreted as
    described in BCP 14 <span>[<a class="cite xref" href="#RFC2119">RFC2119</a>]</span> <span>[<a class="cite xref" href="#RFC8174">RFC8174</a>]</span> 
    when, and only when, they appear in all capitals, as shown here.<a class="pilcrow" href="#section-1.2-1">¶</a></p>
<span class="break"></span><dl class="dlParallel" id="section-1.2-2">
          <dt id="section-1.2-2.1">Classic Congestion Control:</dt>
          <dd id="section-1.2-2.2" style="margin-left: 1.5em">A congestion control 
            behaviour that can coexist with standard Reno <span>[<a class="cite xref" href="#RFC5681">RFC5681</a>]</span> without causing significantly negative impact
            on its flow rate <span>[<a class="cite xref" href="#RFC5033">RFC5033</a>]</span>. With Classic
            congestion controls, such as Reno or CUBIC, because flow rate has
            scaled since TCP congestion control was first designed in 1988, it
            now takes hundreds of round trips (and growing) to recover after a
            congestion signal (whether a loss or an ECN mark) as shown in the
            examples in Section <a class="relref" href="https://www.rfc-editor.org/rfc/rfc9330#section-5.1">5.1</a> of the L4S architecture <span>[<a class="cite xref" href="#RFC9330">RFC9330</a>]</span> and in <span>[<a class="cite xref" href="#RFC3649">RFC3649</a>]</span>. Therefore, control of queuing and utilization
            becomes very slack, and the slightest disturbances (e.g., from
            new flows starting) prevent a high rate from being attained.<a class="pilcrow" href="#section-1.2-2.2">¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-1.2-2.3">Scalable Congestion Control:</dt>
          <dd id="section-1.2-2.4" style="margin-left: 1.5em">A congestion control
            where the average time from one congestion signal to the next (the
            recovery time) remains invariant as flow rate scales, all
            other factors being equal. This maintains the same degree of
            control over queuing and utilization whatever the flow rate, as
            well as ensuring that high throughput is robust to disturbances.
            For instance, DCTCP averages 2 congestion signals per round trip,
            whatever the flow rate, as do other recently developed Scalable
            congestion controls, e.g., Relentless TCP <span>[<a class="cite xref" href="#I-D.mathis-iccrg-relentless-tcp">RELENTLESS</a>]</span>, Prague for TCP and QUIC <span>[<a class="cite xref" href="#I-D.briscoe-iccrg-prague-congestion-control">PRAGUE-CC</a>]</span> <span>[<a class="cite xref" href="#PragueLinux">PragueLinux</a>]</span>, the L4S ECN
   part of Bottleneck Bandwidth and Round-trip propagation time 
   (BBRv2) <span>[<a class="cite xref" href="#BBRv2">BBRv2</a>]</span> <span>[<a class="cite xref" href="#I-D.cardwell-iccrg-bbr-congestion-control">BBR-CC</a>]</span>, and the L4S
            variant of SCReAM for real-time media <span>[<a class="cite xref" href="#SCReAM-L4S">SCReAM-L4S</a>]</span> <span>[<a class="cite xref" href="#RFC8298">RFC8298</a>]</span>. See <a class="auto internal xref" href="#l4sid_congestion_response">Section 4.3</a> for more explanation.<a class="pilcrow" href="#section-1.2-2.4">¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-1.2-2.5">Classic Service:</dt>
          <dd id="section-1.2-2.6" style="margin-left: 1.5em">The Classic service is intended for
            all the congestion control behaviours
     that coexist with Reno <span>[<a class="cite xref" href="#RFC5681">RFC5681</a>]</span> (e.g., Reno itself,
            CUBIC <span>[<a class="cite xref" href="#RFC8312">RFC8312</a>]</span>, Compound <span>[<a class="cite xref" href="#I-D.sridharan-tcpm-ctcp">CTCP</a>]</span>, and TFRC <span>[<a class="cite xref" href="#RFC5348">RFC5348</a>]</span>). The term 'Classic queue' means a queue
            providing the Classic service.<a class="pilcrow" href="#section-1.2-2.6">¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-1.2-2.7">Low Latency, Low Loss, and Scalable throughput (L4S) service:</dt>
          <dd id="section-1.2-2.8" style="margin-left: 1.5em">
            <p id="section-1.2-2.8.1">The
            'L4S' service is intended for traffic from Scalable congestion
            control algorithms, such as the Prague congestion control <span>[<a class="cite xref" href="#I-D.briscoe-iccrg-prague-congestion-control">PRAGUE-CC</a>]</span>, which was
            derived from DCTCP <span>[<a class="cite xref" href="#RFC8257">RFC8257</a>]</span>. 
            The L4S service
            is for more general traffic than just Prague -- it allows the
            set of congestion controls with similar scaling properties to
            Prague to evolve, such as the examples listed above (Relentless,
            SCReAM, etc.). The term 'L4S queue' means a queue providing the
            L4S service.<a class="pilcrow" href="#section-1.2-2.8.1">¶</a></p>
<p id="section-1.2-2.8.2">The terms Classic or L4S can
            also qualify other nouns, such as 'queue', 'codepoint',
            'identifier', 'classification', 'packet', and 'flow'. For example, an
            L4S packet means a packet with an L4S identifier sent from an L4S
            congestion control.<a class="pilcrow" href="#section-1.2-2.8.2">¶</a></p>
<p id="section-1.2-2.8.3">Both Classic and L4S
            services can cope with a proportion of unresponsive or
            less-responsive traffic as well but, in the L4S case, its rate has
            to be smooth enough or low enough to not build a queue
            (e.g., DNS, Voice over IP (VoIP), game sync datagrams, etc.).<a class="pilcrow" href="#section-1.2-2.8.3">¶</a></p>
</dd>
          <dd class="break"></dd>
<dt id="section-1.2-2.9">Reno-friendly:</dt>
          <dd id="section-1.2-2.10" style="margin-left: 1.5em">The subset of Classic traffic that is
            friendly to the standard Reno congestion control defined for TCP
            in <span>[<a class="cite xref" href="#RFC5681">RFC5681</a>]</span>. The TFRC spec <span>[<a class="cite xref" href="#RFC5348">RFC5348</a>]</span> indirectly implies that 'friendly' is defined
            as "generally within a factor of two of the sending rate of a TCP
            flow under the same conditions". Reno-friendly is used here in
            place of 'TCP-friendly', given the latter has become imprecise,
            because the TCP protocol is now used with so many different
            congestion control behaviours, and Reno is used in non-TCP
            transports, such as QUIC <span>[<a class="cite xref" href="#RFC9000">RFC9000</a>]</span>.<a class="pilcrow" href="#section-1.2-2.10">¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-1.2-2.11">Classic ECN:</dt>
          <dd id="section-1.2-2.12" style="margin-left: 1.5em">
            <p id="section-1.2-2.12.1">The original Explicit Congestion Notification (ECN) protocol <span>[<a class="cite xref" href="#RFC3168">RFC3168</a>]</span> that
            requires ECN signals to be treated as equivalent to drops, both when
            generated in the network and when responded to by the sender.<a class="pilcrow" href="#section-1.2-2.12.1">¶</a></p>
<p id="section-1.2-2.12.2">For L4S, the names used for the
     four codepoints of the 2-bit IP-ECN field are unchanged from those
     defined in the ECN spec <span>[<a class="cite xref" href="#RFC3168">RFC3168</a>]</span>, i.e., Not-ECT,
     ECT(0), ECT(1), and CE, where ECT stands for ECN-Capable
     Transport and CE stands for Congestion Experienced. A packet
     marked with the CE codepoint is termed 'ECN-marked' or sometimes
     just 'marked' where the context makes ECN obvious.<a class="pilcrow" href="#section-1.2-2.12.2">¶</a></p>
</dd>
          <dd class="break"></dd>
<dt id="section-1.2-2.13">Site:</dt>
          <dd id="section-1.2-2.14" style="margin-left: 1.5em">A home, mobile device, small enterprise, or
            campus where the network bottleneck is typically the access link
            to the site. Not all network arrangements fit this model, but it is
            a useful, widely applicable generalization.<a class="pilcrow" href="#section-1.2-2.14">¶</a>
</dd>
        <dd class="break"></dd>
</dl>
</section>
</div>
<section id="section-1.3">
        <h3 id="name-scope">
<a class="section-number selfRef" href="#section-1.3">1.3. </a><a class="section-name selfRef" href="#name-scope">Scope</a>
        </h3>
<p id="section-1.3-1">The new L4S identifier defined in this specification is applicable
        for IPv4 and IPv6 packets (as is Classic ECN <span>[<a class="cite xref" href="#RFC3168">RFC3168</a>]</span>). It is applicable for the unicast, multicast, and
        anycast forwarding modes.<a class="pilcrow" href="#section-1.3-1">¶</a></p>
<p id="section-1.3-2">The L4S identifier is an orthogonal packet classification to the
        Differentiated Services Code Point (DSCP) <span>[<a class="cite xref" href="#RFC2474">RFC2474</a>]</span>. <a class="auto internal xref" href="#l4sid_other_IDs">Section 5.4</a> explains what
        this means in practice.<a class="pilcrow" href="#section-1.3-2">¶</a></p>
<p id="section-1.3-3">This document is Experimental, so it does not
        update any Standards Track RFCs. Therefore, it depends on <span>[<a class="cite xref" href="#RFC8311">RFC8311</a>]</span>, which is a Standards Track specification
        that:<a class="pilcrow" href="#section-1.3-3">¶</a></p>
<ul class="normal">
<li class="normal" id="section-1.3-4.1">updates the ECN Proposed Standard <span>[<a class="cite xref" href="#RFC3168">RFC3168</a>]</span>
            to allow Experimental RFCs to relax the requirement that an
            ECN mark must be equivalent to a drop (when the network applies
            markings and/or when the sender responds to them). 
            For instance,
            in the Alternative Backoff with ECN (ABE) experiment <span>[<a class="cite xref" href="#RFC8511">RFC8511</a>]</span>, this relaxation permits a
            sender to respond less to ECN marks than to drops;<a class="pilcrow" href="#section-1.3-4.1">¶</a>
</li>
          <li class="normal" id="section-1.3-4.2">changes the status of the Experimental ECN nonce spec <span>[<a class="cite xref" href="#RFC3540">RFC3540</a>]</span> to Historic; and<a class="pilcrow" href="#section-1.3-4.2">¶</a>
</li>
          <li class="normal" id="section-1.3-4.3">
            <p id="section-1.3-4.3.1">makes consequent updates to the following additional Proposed
            Standard RFCs to reflect the above two bullets:<a class="pilcrow" href="#section-1.3-4.3.1">¶</a></p>
<ul class="normal">
<li class="normal" id="section-1.3-4.3.2.1">ECN for RTP <span>[<a class="cite xref" href="#RFC6679">RFC6679</a>]</span> and<a class="pilcrow" href="#section-1.3-4.3.2.1">¶</a>
</li>
              <li class="normal" id="section-1.3-4.3.2.2">the congestion control specifications of various DCCP
                Congestion Control Identifier (CCID) profiles <span>[<a class="cite xref" href="#RFC4341">RFC4341</a>]</span> <span>[<a class="cite xref" href="#RFC4342">RFC4342</a>]</span> <span>[<a class="cite xref" href="#RFC5622">RFC5622</a>]</span>.<a class="pilcrow" href="#section-1.3-4.3.2.2">¶</a>
</li>
            </ul>
</li>
        </ul>
<p id="section-1.3-5">This document is about identifiers that are used for interoperation
        between hosts and networks. So the audience is broad, covering
        developers of host transports and network AQMs, as well as covering
        how operators might wish to combine various identifiers, which would
        require flexibility from equipment developers.<a class="pilcrow" href="#section-1.3-5">¶</a></p>
</section>
</section>
</div>
<div id="l4sid_identification">
<section id="section-2">
      <h2 id="name-l4s-packet-identification-d">
<a class="section-number selfRef" href="#section-2">2. </a><a class="section-name selfRef" href="#name-l4s-packet-identification-d">L4S Packet Identification: Document Roadmap</a>
      </h2>
<p id="section-2-1">The L4S ECN marking treatment is an experimental alternative 
      to the Classic ECN treatment in <span>[<a class="cite xref" href="#RFC3168">RFC3168</a>]</span>,
      which has been updated by <span>[<a class="cite xref" href="#RFC8311">RFC8311</a>]</span> to allow experiments
      such as the one defined in the present specification. <span>[<a class="cite xref" href="#RFC4774">RFC4774</a>]</span> discusses some of the issues and evaluation criteria
      when defining alternative ECN semantics, which are further discussed in
      <a class="auto internal xref" href="#l4sid_congestion_response_rfcs">Section 4.3.1</a>.<a class="pilcrow" href="#section-2-1">¶</a></p>
<p id="section-2-2">The L4S architecture <span>[<a class="cite xref" href="#RFC9330">RFC9330</a>]</span>
      describes the three main components of L4S: the sending host behaviour,
      the marking behaviour in the network, and the L4S ECN protocol that
      identifies L4S packets as they flow between the two.<a class="pilcrow" href="#section-2-2">¶</a></p>
<p id="section-2-3"><a class="auto internal xref" href="#l4sid_reqs">Section 3</a> of this document records the requirements that informed the choice
      of L4S identifier. Then, subsequent sections specify the L4S ECN
      protocol, which i) identifies packets that have been sent from hosts
      that are expected to comply with a broad type of sending behaviour and
      ii) identifies the marking treatment that network nodes are expected to
      apply to L4S packets.<a class="pilcrow" href="#section-2-3">¶</a></p>
<p id="section-2-4">For a packet to receive L4S treatment as it is forwarded, the sender
      sets the ECN field in the IP header to the ECT(1) codepoint. See <a class="auto internal xref" href="#l4sid_transport_req">Section 4</a> for full transport-layer behaviour
      requirements, including feedback and congestion response.<a class="pilcrow" href="#section-2-4">¶</a></p>
<p id="section-2-5">A network node that implements the L4S service always classifies
      arriving ECT(1) packets for L4S treatment and by default classifies CE
      packets for L4S treatment unless the heuristics described in <a class="auto internal xref" href="#l4sid_identification_transport_aware">Section 5.3</a> are employed. See <a class="auto internal xref" href="#l4sid_network_req">Section 5</a> for full network element behaviour
      requirements, including classification, ECN marking, and interaction of
      the L4S identifier with other identifiers and per-hop behaviours.<a class="pilcrow" href="#section-2-5">¶</a></p>
<p id="section-2-6">L4S ECN works with ECN tunnelling and encapsulation behaviour as is,
      except there is one known case where careful attention to configuration
      is required, which is detailed in <a class="auto internal xref" href="#l4sid_encaps">Section 6</a>.<a class="pilcrow" href="#section-2-6">¶</a></p>
<p id="section-2-7">This specification of L4S ECN currently has Experimental status. So <a class="auto internal xref" href="#l4sid_expts">Section 7</a> collects the general questions and
      issues that remain open for investigation during L4S experimentation.
      Open issues or questions specific to particular components are called
      out in the specifications of each component part, such as the DualQ
      <span>[<a class="cite xref" href="#RFC9332">RFC9332</a>]</span>.<a class="pilcrow" href="#section-2-7">¶</a></p>
<p id="section-2-8">The IANA assignment of the L4S identifier is specified in <a class="auto internal xref" href="#l4sid_IANA">Section 8</a>. And <a class="auto internal xref" href="#l4sid_Security_Considerations">Section 9</a> covers security considerations
      specific to the L4S identifier. System security aspects, such as
      policing and privacy, are covered in the L4S architecture <span>[<a class="cite xref" href="#RFC9330">RFC9330</a>]</span>.<a class="pilcrow" href="#section-2-8">¶</a></p>
</section>
</div>
<div id="l4sid_reqs">
<section id="section-3">
      <h2 id="name-choice-of-l4s-packet-identi">
<a class="section-number selfRef" href="#section-3">3. </a><a class="section-name selfRef" href="#name-choice-of-l4s-packet-identi">Choice of L4S Packet Identifier: Requirements</a>
      </h2>
<p id="section-3-1">This subsection briefly records the process that led to the chosen
      L4S identifier.<a class="pilcrow" href="#section-3-1">¶</a></p>
<p id="section-3-2">The identifier for packets using the L4S service needs to meet the following requirements:<a class="pilcrow" href="#section-3-2">¶</a></p>
<ul class="normal">
<li class="normal" id="section-3-3.1">it <span class="bcp14">SHOULD</span> survive end to end between source and destination
          endpoints: across the boundary between host and network, between
          interconnected networks, and through middleboxes;<a class="pilcrow" href="#section-3-3.1">¶</a>
</li>
        <li class="normal" id="section-3-3.2">it <span class="bcp14">SHOULD</span> be visible at the IP layer;<a class="pilcrow" href="#section-3-3.2">¶</a>
</li>
        <li class="normal" id="section-3-3.3">it <span class="bcp14">SHOULD</span> be common to IPv4 and IPv6 and be transport-agnostic;<a class="pilcrow" href="#section-3-3.3">¶</a>
</li>
        <li class="normal" id="section-3-3.4">it <span class="bcp14">SHOULD</span> be incrementally deployable;<a class="pilcrow" href="#section-3-3.4">¶</a>
</li>
        <li class="normal" id="section-3-3.5">it <span class="bcp14">SHOULD</span> enable an AQM to classify packets encapsulated by outer
          IP or lower-layer headers;<a class="pilcrow" href="#section-3-3.5">¶</a>
</li>
        <li class="normal" id="section-3-3.6">it <span class="bcp14">SHOULD</span> consume minimal extra codepoints; and<a class="pilcrow" href="#section-3-3.6">¶</a>
</li>
        <li class="normal" id="section-3-3.7">it <span class="bcp14">SHOULD</span> be consistent on all the packets of a transport-layer
          flow, so that some packets of a flow are not served by a different
          queue to others.<a class="pilcrow" href="#section-3-3.7">¶</a>
</li>
      </ul>
<p id="section-3-4">Whether the identifier would be recoverable if the experiment failed
      is a factor that could be taken into account. However, this has not been
      made a requirement, because that would favour schemes that would be
      easier to fail rather than more likely to succeed.<a class="pilcrow" href="#section-3-4">¶</a></p>
<p id="section-3-5">It is recognized that any choice of identifier is unlikely to satisfy
      all these requirements, particularly given the limited space left in the
      IP header. Therefore, a compromise will always be necessary, which is
      why all the above requirements are expressed with the word "<span class="bcp14">SHOULD</span>" not
      "<span class="bcp14">MUST</span>".<a class="pilcrow" href="#section-3-5">¶</a></p>
<p id="section-3-6">After extensive assessment of alternative schemes, "ECT(1) and CE
      codepoints" was chosen as the best compromise. Therefore, this scheme is
      defined in detail in the following sections, while <a class="auto internal xref" href="#l4sid_ECT1_CE">Appendix B</a> records its pros and cons against the above
      requirements.<a class="pilcrow" href="#section-3-6">¶</a></p>
</section>
</div>
<div id="l4sid_transport_req">
<section id="section-4">
      <h2 id="name-transport-layer-behaviour-t">
<a class="section-number selfRef" href="#section-4">4. </a><a class="section-name selfRef" href="#name-transport-layer-behaviour-t">Transport-Layer Behaviour (the 'Prague L4S Requirements')</a>
      </h2>
<p id="section-4-1">This section defines L4S behaviour at the transport layer, also known
      as the 'Prague L4S Requirements' (see <a class="auto internal xref" href="#l4sps_tcp-prague-reqs">Appendix A</a> for the origin of the name).<a class="pilcrow" href="#section-4-1">¶</a></p>
<div id="l4sid_codepoint">
<section id="section-4.1">
        <h3 id="name-codepoint-setting">
<a class="section-number selfRef" href="#section-4.1">4.1. </a><a class="section-name selfRef" href="#name-codepoint-setting">Codepoint Setting</a>
        </h3>
<p id="section-4.1-1">A sender that wishes a packet to receive L4S treatment as it is
        forwarded <span class="bcp14">MUST</span> set the ECN field in the IP header (v4 or v6) to the
        ECT(1) codepoint.<a class="pilcrow" href="#section-4.1-1">¶</a></p>
</section>
</div>
<div id="l4sid_feedback">
<section id="section-4.2">
        <h3 id="name-prerequisite-transport-feed">
<a class="section-number selfRef" href="#section-4.2">4.2. </a><a class="section-name selfRef" href="#name-prerequisite-transport-feed">Prerequisite Transport Feedback</a>
        </h3>
<p id="section-4.2-1">For a transport protocol to provide Scalable congestion control
        (<a class="auto internal xref" href="#l4sid_congestion_response">Section 4.3</a>), it <span class="bcp14">MUST</span> provide feedback
        of the extent of CE marking on the forward path. When ECN was added to
        TCP <span>[<a class="cite xref" href="#RFC3168">RFC3168</a>]</span>, the feedback method reported no
        more than one CE mark per round trip. Some transport protocols derived
        from TCP mimic this behaviour while others report the accurate extent
        of ECN marking. This means that some transport protocols will need to
        be updated as a prerequisite for Scalable congestion control. The
        position for a few well-known transport protocols is given below.<a class="pilcrow" href="#section-4.2-1">¶</a></p>
<span class="break"></span><dl class="dlParallel" id="section-4.2-2">
          <dt id="section-4.2-2.1">TCP:</dt>
          <dd id="section-4.2-2.2" style="margin-left: 1.5em">Support for the accurate ECN feedback
            requirements <span>[<a class="cite xref" href="#RFC7560">RFC7560</a>]</span> (such as that provided
            by AccECN <span>[<a class="cite xref" href="#I-D.ietf-tcpm-accurate-ecn">ACCECN</a>]</span>) by
            both ends is a prerequisite for Scalable congestion control in
            TCP. Therefore, the presence of ECT(1) in the IP headers even in
            one direction of a TCP connection will imply that both ends
            support accurate ECN feedback. However, the converse does not
            apply.
     So even if both ends support AccECN, either of the two ends
            can choose not to use a Scalable congestion control, whatever the
            other end's choice is.<a class="pilcrow" href="#section-4.2-2.2">¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-4.2-2.3">SCTP:</dt>
          <dd id="section-4.2-2.4" style="margin-left: 1.5em">A suitable ECN feedback mechanism for SCTP
            could add a chunk to report the number of received CE marks (as
            described in a long-expired document <span>[<a class="cite xref" href="#I-D.stewart-tsvwg-sctpecn">SCTP-ECN</a>]</span> or as sketched out in
            Appendix <a class="relref" href="https://www.rfc-editor.org/rfc/rfc4960#appendix-A">A</a> of the now-obsolete second Standards Track
            specification of SCTP <span>[<a class="cite xref" href="#RFC4960">RFC4960</a>]</span>).<a class="pilcrow" href="#section-4.2-2.4">¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-4.2-2.5">RTP over UDP:</dt>
          <dd id="section-4.2-2.6" style="margin-left: 1.5em">A prerequisite for Scalable congestion
            control is for both (all) ends of one media-level hop to signal
            ECN support <span>[<a class="cite xref" href="#RFC6679">RFC6679</a>]</span> and use the new generic
            RTCP feedback format of <span>[<a class="cite xref" href="#RFC8888">RFC8888</a>]</span>. The presence of
            ECT(1) implies that both (all) ends of that media-level hop
            support ECN. However, the converse does not apply. So each end of
            a media-level hop can independently choose not to use a Scalable
            congestion control, even if both ends support ECN.<a class="pilcrow" href="#section-4.2-2.6">¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-4.2-2.7">QUIC:</dt>
          <dd id="section-4.2-2.8" style="margin-left: 1.5em">Support for sufficiently fine-grained ECN
            feedback is provided by IETF QUIC transport v1 <span>[<a class="cite xref" href="#RFC9000">RFC9000</a>]</span>.<a class="pilcrow" href="#section-4.2-2.8">¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-4.2-2.9">DCCP:</dt>
          <dd id="section-4.2-2.10" style="margin-left: 1.5em">The Acknowledgement (ACK) vector in DCCP <span>[<a class="cite xref" href="#RFC4340">RFC4340</a>]</span> is already sufficient to report the extent of
            CE marking as needed by a Scalable congestion control.<a class="pilcrow" href="#section-4.2-2.10">¶</a>
</dd>
        <dd class="break"></dd>
</dl>
</section>
</div>
<div id="l4sid_congestion_response">
<section id="section-4.3">
        <h3 id="name-prerequisite-congestion-res">
<a class="section-number selfRef" href="#section-4.3">4.3. </a><a class="section-name selfRef" href="#name-prerequisite-congestion-res">Prerequisite Congestion Response</a>
        </h3>
<p id="section-4.3-1">As a condition for a host to send packets with the L4S identifier
        (ECT(1)), it <span class="bcp14">SHOULD</span> implement a congestion control behaviour that
        ensures that, in steady state, the average duration between induced
        ECN marks does not increase as flow rate scales up, all other factors
        being equal. This is termed a Scalable congestion control. This
        invariant duration ensures that, as flow rate scales, the average
        period with no feedback information about capacity does not become
        excessive. It also ensures that queue variations remain small, without
        having to sacrifice utilization.<a class="pilcrow" href="#section-4.3-1">¶</a></p>
<p id="section-4.3-2">With a congestion control that sawtooths to probe capacity, this
        duration is called the recovery time, because each time the sawtooth
        yields, on average it takes this time to recover to its previous high
        point. A Scalable congestion control does not have to sawtooth, but it
        has to coexist with Scalable congestion controls that do.<a class="pilcrow" href="#section-4.3-2">¶</a></p>
<p id="section-4.3-3">For instance, for DCTCP <span>[<a class="cite xref" href="#RFC8257">RFC8257</a>]</span>, TCP Prague
        <span>[<a class="cite xref" href="#I-D.briscoe-iccrg-prague-congestion-control">PRAGUE-CC</a>]</span> <span>[<a class="cite xref" href="#PragueLinux">PragueLinux</a>]</span>, and the L4S variant of SCReAM <span>[<a class="cite xref" href="#SCReAM-L4S">SCReAM-L4S</a>]</span> <span>[<a class="cite xref" href="#RFC8298">RFC8298</a>]</span>, the average recovery
        time is always half a round trip (or half a reference round trip),
        whatever the flow rate.<a class="pilcrow" href="#section-4.3-3">¶</a></p>
<p id="section-4.3-4">As with all transport behaviours, a detailed specification
        (probably an Experimental RFC) is expected for each congestion
        control, following the guidelines for specifying new congestion
        control algorithms in <span>[<a class="cite xref" href="#RFC5033">RFC5033</a>]</span>. In addition, it
        is expected that these L4S-specific matters will be documented, specifically the
        timescale over which the proportionality is averaged and the control of
        burstiness. The recovery time requirement above is worded as a
        "<span class="bcp14">SHOULD</span>" rather than a "<span class="bcp14">MUST</span>" to allow reasonable flexibility for such
        implementations.<a class="pilcrow" href="#section-4.3-4">¶</a></p>
<p id="section-4.3-5">The condition 'all other factors being equal' allows the recovery
        time to be different for different round-trip times, as long as it
        does not increase with flow rate for any particular RTT.<a class="pilcrow" href="#section-4.3-5">¶</a></p>
<p id="section-4.3-6">Saying that the recovery time remains roughly invariant is
        equivalent to saying that the number of ECN CE marks per round trip
        remains invariant as flow rate scales, all other factors being equal.
        For instance, an average recovery time of half of 1 RTT is equivalent
        to 2 ECN marks per round trip. For those familiar with steady-state
        congestion response functions, it is also equivalent to say that the
        congestion window is inversely proportional to the proportion of bytes
        in packets marked with the CE codepoint (see Section 2 of <span>[<a class="cite xref" href="#PI2">PI2</a>]</span>).<a class="pilcrow" href="#section-4.3-6">¶</a></p>
<p id="section-4.3-7">In order to coexist safely with other Internet traffic, a Scalable
        congestion control is not allowed to tag its packets with the ECT(1)
        codepoint unless it complies with the following numbered requirements
        and recommendations:<a class="pilcrow" href="#section-4.3-7">¶</a></p>
<ol class="normal type-1" id="section-4.3-8" start="1" type="1">
<li id="section-4.3-8.1">
<div id="l4sid_Prague_req-replaceable">A Scalable congestion control <span class="bcp14">MUST</span> be capable of being replaced
            by a Classic congestion control (by application and/or by
            administrative control). If a Classic congestion control is
            activated, it will not tag its packets with the ECT(1) codepoint
            (see <a class="auto internal xref" href="#l4sid_sec_replaceable">Appendix A.1.3</a> for rationale).<a class="pilcrow" href="#l4sid_Prague_req-replaceable">¶</a>
</div>
          </li>
<li id="section-4.3-8.2">
<div id="l4sid_Prague_req-loss-response">As well as responding to ECN markings, a Scalable congestion
            control <span class="bcp14">MUST</span> react to packet loss in a way that will coexist
            safely with Classic congestion controls 
     such as standard Reno <span>[<a class="cite xref" href="#RFC5681">RFC5681</a>]</span>, as required by <span>[<a class="cite xref" href="#RFC5033">RFC5033</a>]</span> (see <a class="auto internal xref" href="#l4sid_sec_fallback_on_loss">Appendix A.1.4</a> for rationale).<a class="pilcrow" href="#l4sid_Prague_req-loss-response">¶</a>
</div>
          </li>
<li id="section-4.3-8.3">
<div id="l4sid_Prague_req-classic-ecn-response">
            <p id="section-4.3-8.3.1">In uncontrolled environments, monitoring <span class="bcp14">MUST</span> be implemented to
            support detection of problems with an ECN-capable AQM at the path
            bottleneck that appears not to support L4S and that might be in a
            shared queue. Such monitoring <span class="bcp14">SHOULD</span> be applied to live traffic
            that is using Scalable congestion control. Alternatively,
            monitoring need not be applied to live traffic, if monitoring with
            test traffic has been arranged to cover the paths that live
            traffic takes through uncontrolled environments.<a class="pilcrow" href="#section-4.3-8.3.1">¶</a></p>
<p id="section-4.3-8.3.2">A function to detect the above problems with an
            ECN-capable AQM <span class="bcp14">MUST</span> also be implemented and used. The detection
            function <span class="bcp14">SHOULD</span> be capable of making the congestion control adapt
            its ECN-marking response in real time to coexist safely with
            Classic congestion controls such as standard Reno <span>[<a class="cite xref" href="#RFC5681">RFC5681</a>]</span>, as required by <span>[<a class="cite xref" href="#RFC5033">RFC5033</a>]</span>. This
            could be complemented by more detailed offline detection of
            potential problems. If only offline detection is used and
            potential problems with such an AQM are detected on certain paths,
            the Scalable congestion control <span class="bcp14">MUST</span> be replaced by a Classic
            congestion control, at least for the problem paths.<a class="pilcrow" href="#section-4.3-8.3.2">¶</a></p>
<p id="section-4.3-8.3.3">See <a class="auto internal xref" href="#l4sid_congestion_response_rfcs">Section 4.3.1</a>, <a class="auto internal xref" href="#l4sid_sec_fallback_on_classic_CE">Appendix A.1.5</a>, and the L4S
            operational guidance <span>[<a class="cite xref" href="#I-D.ietf-tsvwg-l4sops">L4SOPS</a>]</span>
            for rationale and explanation.<a class="pilcrow" href="#section-4.3-8.3.3">¶</a></p>
<p id="section-4.3-8.3.4" style="margin-left: 1.5em">Note that a
            Scalable congestion control is not expected to change to setting
            ECT(0) while it transiently adapts to coexist with Classic
            congestion controls, whereas a replacement congestion control that
            solely behaves in the Classic way will set ECT(0).<a class="pilcrow" href="#section-4.3-8.3.4">¶</a></p>
</div>
          </li>
<li id="section-4.3-8.4">
<div id="l4sid_Prague_req-rtt-independence">In the range between the minimum likely RTT and typical RTTs
            expected in the intended deployment scenario, a Scalable
            congestion control <span class="bcp14">MUST</span> converge towards a rate that is as
            independent of RTT as is possible without compromising stability
            or utilization (see <a class="auto internal xref" href="#l4sid_sec_RTT_dependence">Appendix A.1.6</a> for
            rationale).<a class="pilcrow" href="#l4sid_Prague_req-rtt-independence">¶</a>
</div>
          </li>
<li id="section-4.3-8.5">
<div id="l4sid_Prague_req-fractional-window">A Scalable congestion control <span class="bcp14">SHOULD</span> remain responsive to
            congestion when typical RTTs over the public Internet are
            significantly smaller because they are no longer inflated by
            queuing delay. It would be preferable for the minimum window of a
            Scalable congestion control to be lower than 1 segment rather than
            use the timeout approach described for TCP in
            <span><a class="relref" href="https://www.rfc-editor.org/rfc/rfc3168#section-6.1.2">Section 6.1.2</a> of the ECN spec [<a class="cite xref" href="#RFC3168">RFC3168</a>]</span> (or an equivalent for other
            transports). However, a lower minimum is not set as a formal
            requirement for L4S experiments (see <a class="auto internal xref" href="#l4sid_sec_min_cwnd">Appendix A.1.7</a> for rationale).<a class="pilcrow" href="#l4sid_Prague_req-fractional-window">¶</a>
</div>
          </li>
<li id="section-4.3-8.6">
<div id="l4sid_Prague_req-reordering">A Scalable congestion control's loss detection <span class="bcp14">SHOULD</span> be
            resilient to reordering over an adaptive time interval that scales
            with throughput and adapts to reordering (as in Recent ACK (RACK) <span>[<a class="cite xref" href="#RFC8985">RFC8985</a>]</span>), as opposed to counting only in fixed units of
            packets (as in the 3 Duplicate ACK (DupACK) rule of NewReno <span>[<a class="cite xref" href="#RFC5681">RFC5681</a>]</span> <span>[<a class="cite xref" href="#RFC6675">RFC6675</a>]</span>, which is not
            scalable). As data rates increase (e.g., due to new and/or
            improved technology), congestion controls that detect loss by
            counting in units of packets become more likely to incorrectly
            treat reordering events as congestion-caused loss events (see
            <a class="auto internal xref" href="#l4sid_sec_reordering_tolerance">Appendix A.1.8</a> for further
            rationale). This requirement does not apply to congestion controls
            that are solely used in controlled environments where the network
            introduces hardly any reordering.<a class="pilcrow" href="#l4sid_Prague_req-reordering">¶</a>
</div>
          </li>
<li id="section-4.3-8.7">
<div id="l4sid_Prague_req-burstiness">A Scalable congestion control is expected to limit the queue
            caused by bursts of packets. It would not seem necessary to set
            the limit any lower than 10% of the minimum RTT expected in a
            typical deployment (e.g., additional queuing of roughly 250 us
            for the public Internet). This would be converted to a number of
            packets by multiplying by the current average packet rate. Then,
            the queue caused by each burst at the bottleneck link would not
            exceed 250 us (under the worst-case assumption that the flow is
            filling the capacity). No normative requirement to limit bursts is
            given here, and until there is more industry experience from the
            L4S experiment, it is not even known whether one is needed -- it
            seems to be in an L4S sender's self-interest to limit bursts.<a class="pilcrow" href="#l4sid_Prague_req-burstiness">¶</a>
</div>
        </li>
</ol>
<p id="section-4.3-9">Each sender in a session can use a Scalable congestion control
        independently of the congestion control used by the receiver(s) when
        they send data. Therefore, there might be ECT(1) packets in one
        direction and ECT(0) or Not-ECT in the other.<a class="pilcrow" href="#section-4.3-9">¶</a></p>
<p id="section-4.3-10">Later, this document
        discusses the conditions for mixing other "'Safe' Unresponsive
        Traffic" (e.g., DNS, Lightweight Directory Access Protocol (LDAP), NTP, voice, and game sync packets) with L4S
        traffic; see <a class="auto internal xref" href="#l4sid_inclusion_dualq">Section 5.4.1.1</a>. To be clear, although such traffic can share the same queue
        as L4S traffic, it is not appropriate for the sender to tag it as
        ECT(1), except in the (unlikely) case that it satisfies the above
        conditions.<a class="pilcrow" href="#section-4.3-10">¶</a></p>
<div id="l4sid_congestion_response_rfcs">
<section id="section-4.3.1">
          <h4 id="name-guidance-on-congestion-resp">
<a class="section-number selfRef" href="#section-4.3.1">4.3.1. </a><a class="section-name selfRef" href="#name-guidance-on-congestion-resp">Guidance on Congestion Response in the RFC Series</a>
          </h4>
<p id="section-4.3.1-1"><span>[<a class="cite xref" href="#RFC3168">RFC3168</a>]</span> requires the congestion responses to a CE-marked
          packet and a dropped packet to be the same. <span>[<a class="cite xref" href="#RFC8311">RFC8311</a>]</span> is a
          Standards Track update to <span>[<a class="cite xref" href="#RFC3168">RFC3168</a>]</span> that is intended to enable
          experimentation with ECN, including the L4S experiment.
          <span>[<a class="cite xref" href="#RFC8311">RFC8311</a>]</span> allows an experimental congestion control's response
          to a CE-marked packet to differ from the response to a dropped
          packet, provided that the differences are documented in an
          Experimental RFC, such as the present document.<a class="pilcrow" href="#section-4.3.1-1">¶</a></p>
<p id="section-4.3.1-2">BCP 124 <span>[<a class="cite xref" href="#RFC4774">RFC4774</a>]</span> gives guidance
          to protocol designers, when specifying alternative semantics for the
          IP-ECN field. <span>[<a class="cite xref" href="#RFC8311">RFC8311</a>]</span> explained that it did not need to update the
          best current practice in BCP 124 in order to relax the 'equivalence
          with drop' requirement because, although BCP 124 quotes the same
          requirement from <span>[<a class="cite xref" href="#RFC3168">RFC3168</a>]</span>, the BCP does not impose requirements
          based on it.

   BCP 124 <span>[<a class="cite xref" href="#RFC4774">RFC4774</a>]</span> describes three options for incremental
          deployment, with Option 3 (in <span><a class="relref" href="https://www.rfc-editor.org/rfc/rfc4774#section-4.3">Section 4.3</a> of BCP 124 [<a class="cite xref" href="#RFC4774">RFC4774</a>]</span>) best matching the L4S
          case. Option 3's requirement for end-nodes is that they respond to
          CE marks "in a way that is friendly to flows using IETF-conformant
          congestion control." This echoes other general congestion control
          requirements in the RFC Series, for example, <span>[<a class="cite xref" href="#RFC5033">RFC5033</a>]</span> states that "...congestion controllers that have
          a significantly negative impact on traffic using standard congestion
          control may be suspect" and <span>[<a class="cite xref" href="#RFC8085">RFC8085</a>]</span>, which concerns UDP congestion control, states that
  
          "Bulk-transfer applications that choose not to implement TFRC or
          TCP-like windowing <span class="bcp14">SHOULD</span> implement a congestion
          control scheme that results in bandwidth (capacity) use that
          competes fairly with TCP within an order of magnitude."<a class="pilcrow" href="#section-4.3.1-2">¶</a></p>
<p id="section-4.3.1-3">The normative Item <a class="auto internal xref" href="#l4sid_Prague_req-classic-ecn-response">3</a> in <a class="auto internal xref" href="#l4sid_congestion_response">Section 4.3</a> above (which concerns L4S
          response to congestion from a Classic ECN AQM) aims to ensure that
          these 'coexistence' requirements are satisfied, but it makes some
          compromises. This subsection highlights and justifies those
          compromises, and <a class="auto internal xref" href="#l4sid_sec_fallback_on_classic_CE">Appendix A.1.5</a>
          and the L4S operational guidance <span>[<a class="cite xref" href="#I-D.ietf-tsvwg-l4sops">L4SOPS</a>]</span> give detailed analysis, examples,
          and references (the normative text in that bullet takes precedence
          if any informative elaboration leads to ambiguity). The approach is
          based on an assessment of the risk of harm, which is a combination
          of the prevalence of the conditions necessary for harm to occur, and
          the potential severity of the harm if they do.<a class="pilcrow" href="#section-4.3.1-3">¶</a></p>
<span class="break"></span><dl class="dlParallel" id="section-4.3.1-4">
            <dt id="section-4.3.1-4.1">Prevalence:</dt>
            <dd id="section-4.3.1-4.2" style="margin-left: 1.5em">
              <p id="section-4.3.1-4.2.1">There are three cases:<a class="pilcrow" href="#section-4.3.1-4.2.1">¶</a></p>
<ul class="normal">
<li class="normal" id="section-4.3.1-4.2.2.1">Drop Tail: Coexistence between L4S and Classic flows is
                  not in doubt where the bottleneck does not support any form
                  of ECN, which has remained by far the most prevalent case
                  since the ECN spec <span>[<a class="cite xref" href="#RFC3168">RFC3168</a>]</span> was published in 2001.<a class="pilcrow" href="#section-4.3.1-4.2.2.1">¶</a>
</li>
                <li class="normal" id="section-4.3.1-4.2.2.2">L4S: Coexistence is not in doubt if the bottleneck
                  supports L4S.<a class="pilcrow" href="#section-4.3.1-4.2.2.2">¶</a>
</li>
                <li class="normal" id="section-4.3.1-4.2.2.3">
                  <p id="section-4.3.1-4.2.2.3.1">Classic ECN: The
                  compromises centre around cases where the bottleneck
                  supports Classic ECN <span>[<a class="cite xref" href="#RFC3168">RFC3168</a>]</span> but not L4S.
   But it depends on which sub-case:<a class="pilcrow" href="#section-4.3.1-4.2.2.3.1">¶</a></p>
<ul class="normal">
<li class="normal" id="section-4.3.1-4.2.2.3.2.1">Shared Queue with Classic ECN: At the time of
                      writing, the members of the Transport Working Group are
                      not aware of any current deployments of single-queue
                      Classic ECN bottlenecks in the Internet. Nonetheless, at
                      the scale of the Internet, rarity need not imply small
                      numbers nor that there will be rarity in the
                      future.<a class="pilcrow" href="#section-4.3.1-4.2.2.3.2.1">¶</a>
</li>
                    <li class="normal" id="section-4.3.1-4.2.2.3.2.2">
                      <p id="section-4.3.1-4.2.2.3.2.2.1">Per-Flow Queues with Classic ECN: Most AQMs with
                      per-flow queuing deployed from 2012 onwards had
                      Classic ECN enabled by default, specifically
                      FQ-CoDel <span>[<a class="cite xref" href="#RFC8290">RFC8290</a>]</span> and
                      COBALT <span>[<a class="cite xref" href="#COBALT">COBALT</a>]</span>. But the compromises
                      only apply to the second of two further sub-cases:<a class="pilcrow" href="#section-4.3.1-4.2.2.3.2.2.1">¶</a></p>
<ul class="normal">
<li class="normal" id="section-4.3.1-4.2.2.3.2.2.2.1">With per-flow queuing, coexistence between
                          Classic and L4S flows is not normally a problem,
                          because different flows are not meant to be in the
                          same queue (BCP 124 <span>[<a class="cite xref" href="#RFC4774">RFC4774</a>]</span> did not foresee the introduction
                          of per-flow queuing, which appeared as a potential
                          isolation technique some eight years after the BCP
                          was published).<a class="pilcrow" href="#section-4.3.1-4.2.2.3.2.2.2.1">¶</a>
</li>
                        <li class="normal" id="section-4.3.1-4.2.2.3.2.2.2.2">However, the isolation between L4S and Classic
                          flows is not perfect in cases where the hashes of
                          flow identifiers (IDs) collide or where multiple flows within a
                          Layer 3 VPN are encapsulated within one flow ID.<a class="pilcrow" href="#section-4.3.1-4.2.2.3.2.2.2.2">¶</a>
</li>
                      </ul>
</li>
                  </ul>
</li>
              </ul>
<p id="section-4.3.1-4.2.3">To summarize, the coexistence problem is confined to
              cases of imperfect flow isolation in an FQ or in potential
              cases where a Classic ECN AQM has been deployed in a shared
              queue (see the L4S operational guidance <span>[<a class="cite xref" href="#I-D.ietf-tsvwg-l4sops">L4SOPS</a>]</span> for further details including
              recent surveys attempting to quantify prevalence). Further, if
              one of these cases does occur, the coexistence problem does not
              arise unless sources of Classic and L4S flows are simultaneously
              sharing the same bottleneck queue (e.g., different
              applications in the same household), and flows of each type have
              to be large enough to coincide for long enough for any
              throughput imbalance to have developed. Therefore, how often the
              coexistence problem arises in practice is listed in <a class="auto internal xref" href="#l4sid_expts">Section 7</a> as an open question that L4S experiments
              will need to answer.<a class="pilcrow" href="#section-4.3.1-4.2.3">¶</a></p>
</dd>
            <dd class="break"></dd>
<dt id="section-4.3.1-4.3">Severity:</dt>
            <dd id="section-4.3.1-4.4" style="margin-left: 1.5em">Where long-running L4S and Classic flows
              coincide in a shared queue, testing of one L4S congestion
              control (TCP Prague) has found that the imbalance in average
              throughput between an L4S and a Classic flow can reach 25:1 in
              favour of L4S in the worst case <span>[<a class="cite xref" href="#ecn-fallback">ecn-fallback</a>]</span>. However, when capacity is most scarce,
              the Classic flow gets a higher proportion of the link, for
              instance, over a 4 Mb/s link the throughput ratio is below ~10:1
              over paths with a base RTT below 100 ms, and it falls below ~5:1
              for base RTTs below 20 ms.<a class="pilcrow" href="#section-4.3.1-4.4">¶</a>
</dd>
          <dd class="break"></dd>
</dl>
<p id="section-4.3.1-5">These throughput ratios can clearly fall well outside current RFC
          guidance on coexistence. However, the tendency towards leaving a
          greater share for Classic flows at lower link rate and the very
          limited prevalence of the conditions necessary for harm to occur led
          to the possibility of allowing the RFC requirements to be
          compromised, albeit briefly:<a class="pilcrow" href="#section-4.3.1-5">¶</a></p>
<ul class="normal">
<li class="normal" id="section-4.3.1-6.1">The recommended approach is still to detect and adapt to a
              Classic ECN AQM in real time, which is fully consistent with all
              the RFCs on coexistence. In other words, the "<span class="bcp14">SHOULD</span>"s in 
              Item <a class="auto internal xref" href="#l4sid_Prague_req-classic-ecn-response">3</a> of <a class="auto internal xref" href="#l4sid_congestion_response">Section 4.3</a> above
              expect the sender to implement something similar to the proof-of-concept
              code that detects the presence of a Classic ECN AQM and
              falls back to a Classic congestion response within a few round
              trips <span>[<a class="cite xref" href="#ecn-fallback">ecn-fallback</a>]</span>. However, although this
              code reliably detects a Classic ECN AQM, the current code can
              also wrongly categorize an L4S AQM as Classic, most often in
              cases when link rate is low or RTT is high. Although this is the
              safe way round, and although implementers are expected to be
              able to improve on this proof of concept, concerns have been
              raised that implementers might lose faith in such detection and
              disable it.<a class="pilcrow" href="#section-4.3.1-6.1">¶</a>
</li>
            <li class="normal" id="section-4.3.1-6.2">Item <a class="auto internal xref" href="#l4sid_Prague_req-classic-ecn-response">3</a> in <a class="auto internal xref" href="#l4sid_congestion_response">Section 4.3</a> above therefore allows a compromise
              where coexistence could briefly diverge from the requirements in the RFC
              Series, but mandatory monitoring is required in order
              to detect such cases and trigger remedial action. This approach
              tolerates a brief divergence from the RFCs given the likely low
              prevalence and given harm here means a flow progresses more
              slowly than it would otherwise, but it does progress. The L4S operational
              guidance <span>[<a class="cite xref" href="#I-D.ietf-tsvwg-l4sops">L4SOPS</a>]</span> outlines a
              range of example remedial actions that include alterations to
              either the sender or the network. However, the final
              normative requirement in Item <a class="auto internal xref" href="#l4sid_Prague_req-classic-ecn-response">3</a> of <a class="auto internal xref" href="#l4sid_congestion_response">Section 4.3</a> above places ultimate
              responsibility for remedial action on the sender. If coexistence
              problems with a Classic ECN AQM are detected (implying they have
              not been resolved by the network), it states that the sender "<span class="bcp14">MUST</span>"
              revert to a Classic congestion control.<a class="pilcrow" href="#section-4.3.1-6.2">¶</a>
</li>
          </ul>
<p id="section-4.3.1-7"><span>[<a class="cite xref" href="#I-D.ietf-tsvwg-l4sops">L4SOPS</a>]</span> also gives example
          ways in which L4S congestion controls can be rolled out initially in
          lower-risk scenarios.<a class="pilcrow" href="#section-4.3.1-7">¶</a></p>
</section>
</div>
</section>
</div>
<section id="section-4.4">
        <h3 id="name-filtering-or-smoothing-of-e">
<a class="section-number selfRef" href="#section-4.4">4.4. </a><a class="section-name selfRef" href="#name-filtering-or-smoothing-of-e">Filtering or Smoothing of ECN Feedback</a>
        </h3>
<p id="section-4.4-1"><a class="auto internal xref" href="#l4sid_Semantics">Section 5.2</a> below specifies that an L4S AQM is
        expected to signal L4S ECN immediately, to avoid introducing delay due
        to filtering or smoothing. This contrasts with a Classic AQM, which
        filters out variations in the queue before signalling ECN marking or
        drop. In the L4S architecture <span>[<a class="cite xref" href="#RFC9330">RFC9330</a>]</span>, responsibility for smoothing out
        these variations shifts to the sender's congestion control.<a class="pilcrow" href="#section-4.4-1">¶</a></p>
<p id="section-4.4-2">This shift of responsibility has the advantage that each sender can
        smooth variations over a timescale proportionate to its own RTT.
        Whereas, in the Classic approach, the network doesn't know the RTTs of
        any of the flows, so it has to smooth out variations for a worst-case
        RTT to ensure stability. For all the typical flows with shorter RTTs
        than the worst-case, this makes congestion control unnecessarily
        sluggish.<a class="pilcrow" href="#section-4.4-2">¶</a></p>
<p id="section-4.4-3">This also gives an L4S sender the choice not to smooth, depending
        on its context (start-up, congestion avoidance, etc.). Therefore, this
        document places no requirement on an L4S congestion control to smooth
        out variations in any particular way. Implementers are encouraged to
        openly publish the approach they take to smoothing as well as results
        and experience they gain during the L4S experiment.<a class="pilcrow" href="#section-4.4-3">¶</a></p>
</section>
</section>
</div>
<div id="l4sid_network_req">
<section id="section-5">
      <h2 id="name-network-node-behaviour">
<a class="section-number selfRef" href="#section-5">5. </a><a class="section-name selfRef" href="#name-network-node-behaviour">Network Node Behaviour</a>
      </h2>
<section id="section-5.1">
        <h3 id="name-classification-and-re-marki">
<a class="section-number selfRef" href="#section-5.1">5.1. </a><a class="section-name selfRef" href="#name-classification-and-re-marki">Classification and Re-Marking Behaviour</a>
        </h3>
<p id="section-5.1-1">A network node that implements the L4S service:<a class="pilcrow" href="#section-5.1-1">¶</a></p>
<ul class="normal">
<li class="normal" id="section-5.1-2.1">
            <span class="bcp14">MUST</span> classify arriving ECT(1) packets for L4S treatment, unless
            overridden by another classifier (e.g., see <a class="auto internal xref" href="#l4sid_exclusion_dualq">Section 5.4.1.2</a>).<a class="pilcrow" href="#section-5.1-2.1">¶</a>
</li>
          <li class="normal" id="section-5.1-2.2">
            <p id="section-5.1-2.2.1"><span class="bcp14">MUST</span> classify arriving CE packets for L4S treatment as well,
            unless overridden by another classifier or unless the exception
            referred to next applies.<a class="pilcrow" href="#section-5.1-2.2.1">¶</a></p>
<p id="section-5.1-2.2.2">CE packets might
            have originated as ECT(1) or ECT(0), but the above rule to
            classify them as if they originated as ECT(1) is the safe choice
            (see <a class="auto internal xref" href="#l4sid_ECT1_CE">Appendix B</a> for rationale). The exception
            is where some flow-aware in-network mechanism happens to be
            available for distinguishing CE packets that originated as ECT(0),
            as described in <a class="auto internal xref" href="#l4sid_identification_transport_aware">Section 5.3</a>, but there is no
            implication that such a mechanism is necessary.<a class="pilcrow" href="#section-5.1-2.2.2">¶</a></p>
</li>
        </ul>
<p id="section-5.1-3">An L4S AQM treatment follows similar codepoint transition rules to
        those in <span>[<a class="cite xref" href="#RFC3168">RFC3168</a>]</span>. Specifically, the ECT(1) codepoint <span class="bcp14">MUST NOT</span> be
        changed to any codepoint other than CE, and CE <span class="bcp14">MUST NOT</span> be changed to
        any other codepoint. An ECT(1) packet is classified as 'ECN-capable',
        and if congestion increases, an L4S AQM algorithm will increasingly
        mark the IP-ECN field as CE, otherwise forwarding packets unchanged as
        ECT(1). Necessary conditions for an L4S marking treatment are defined
        in <a class="auto internal xref" href="#l4sid_Semantics">Section 5.2</a>.<a class="pilcrow" href="#section-5.1-3">¶</a></p>
<p id="section-5.1-4">Under persistent overload, an L4S marking treatment
        <span class="bcp14">MUST</span> begin applying drop to L4S traffic until the
        overload episode has subsided, as recommended for all AQM methods in
        <span><a class="relref" href="https://www.rfc-editor.org/rfc/rfc7567#section-4.2.1">Section 4.2.1</a> of [<a class="cite xref" href="#RFC7567">RFC7567</a>]</span>, which
        follows the similar advice in <span><a class="relref" href="https://www.rfc-editor.org/rfc/rfc3168#section-7">Section 7</a> of [<a class="cite xref" href="#RFC3168">RFC3168</a>]</span>.  During overload, it
        <span class="bcp14">MUST</span> apply the same drop probability to L4S traffic as
        it would to Classic traffic.<a class="pilcrow" href="#section-5.1-4">¶</a></p>
<p id="section-5.1-5">Where an L4S AQM is transport-aware, this requirement could be
        satisfied by using drop in only the most overloaded individual
        per-flow AQMs. In a DualQ with flow-aware queue protection
        (e.g., <span>[<a class="cite xref" href="#I-D.briscoe-docsis-q-protection">DOCSIS-QPROT</a>]</span>), this
        could be achieved by redirecting packets in those flows contributing
        most to the overload out of the L4S queue so that they are subjected
        to drop in the Classic queue.<a class="pilcrow" href="#section-5.1-5">¶</a></p>
<p id="section-5.1-6">For backward compatibility in uncontrolled environments, a network
        node that implements the L4S treatment <span class="bcp14">MUST</span> also implement an AQM
        treatment for the Classic service as defined in <a class="auto internal xref" href="#l4sid_Terminology">Section 1.2</a>. This Classic AQM treatment need not mark
        ECT(0) packets, but if it does, see <a class="auto internal xref" href="#l4sid_Semantics">Section 5.2</a>
        for the strengths of the markings relative to drop. It <span class="bcp14">MUST</span> classify
        arriving ECT(0) and Not-ECT packets for treatment by this Classic AQM
        (for the DualQ Coupled AQM; see the extensive discussion on
        classification in Sections <a class="relref" href="https://www.rfc-editor.org/rfc/rfc9332#section-2.3">2.3</a> and <a class="relref" href="https://www.rfc-editor.org/rfc/rfc9332#section-2.5.1.1">2.5.1.1</a> of <span>[<a class="cite xref" href="#RFC9332">RFC9332</a>]</span>).<a class="pilcrow" href="#section-5.1-6">¶</a></p>
<p id="section-5.1-7">In case unforeseen problems arise with the L4S experiment, it <span class="bcp14">MUST</span>
        be possible to configure an L4S implementation to disable the L4S
        treatment. 
        Once disabled, ECT(1) packets <span class="bcp14">MUST</span> be treated as if
        they were Not-ECT.<a class="pilcrow" href="#section-5.1-7">¶</a></p>
</section>
<div id="l4sid_Semantics">
<section id="section-5.2">
        <h3 id="name-the-strength-of-l4s-ce-mark">
<a class="section-number selfRef" href="#section-5.2">5.2. </a><a class="section-name selfRef" href="#name-the-strength-of-l4s-ce-mark">The Strength of L4S CE Marking Relative to Drop</a>
        </h3>
<p id="section-5.2-1">The relative strengths of L4S CE and drop are irrelevant where AQMs
        are implemented in separate queues per application-flow, which are
        then explicitly scheduled (e.g., with an FQ scheduler as in
        FQ-CoDel <span>[<a class="cite xref" href="#RFC8290">RFC8290</a>]</span>). Nonetheless, the relationship
        between them needs to be defined for the coupling between L4S and
        Classic congestion signals in a DualQ Coupled AQM <span>[<a class="cite xref" href="#RFC9332">RFC9332</a>]</span>, as indicated below.<a class="pilcrow" href="#section-5.2-1">¶</a></p>
<p id="section-5.2-2">Unless an AQM node schedules application flows explicitly, the
        likelihood that the AQM drops a Not-ECT Classic packet (p_C) <span class="bcp14">MUST</span> be
        roughly proportional to the square of the likelihood that it would
        have marked it if it had been an L4S packet (p_L). That is:<a class="pilcrow" href="#section-5.2-2">¶</a></p>
<p id="section-5.2-3" style="margin-left: 1.5em">p_C ~= (p_L / k)<sup>2</sup><a class="pilcrow" href="#section-5.2-3">¶</a></p>
<p id="section-5.2-4">The constant of proportionality (k) does not have to be
        standardized for interoperability, but a value of 2 is <span class="bcp14">RECOMMENDED</span>.
        The term 'likelihood' is used above to allow for marking and dropping
        to be either probabilistic or deterministic.<a class="pilcrow" href="#section-5.2-4">¶</a></p>
<p id="section-5.2-5">This formula ensures that Scalable and Classic flows will converge
        to roughly equal congestion windows, for the worst case of Reno
        congestion control. This is because the congestion windows of Scalable
        and Classic congestion controls are inversely proportional to p_L and
        sqrt(p_C), respectively. So squaring p_C in the above formula
        counterbalances the square root that characterizes Reno-friendly
        flows.<a class="pilcrow" href="#section-5.2-5">¶</a></p>
<aside id="section-5.2-6">
          <p id="section-5.2-6.1">Note that, contrary to <span>[<a class="cite xref" href="#RFC3168">RFC3168</a>]</span>, an AQM implementing the L4S
        and Classic treatments does not mark an ECT(1) packet under the same
        conditions that it would have dropped a Not-ECT packet, as allowed by
        <span>[<a class="cite xref" href="#RFC8311">RFC8311</a>]</span>, which updates <span>[<a class="cite xref" href="#RFC3168">RFC3168</a>]</span>.
 However, if it
        marks ECT(0) packets, it does so under the same conditions that it would have dropped a
 Not-ECT packet <span>[<a class="cite xref" href="#RFC3168">RFC3168</a>]</span>.<a class="pilcrow" href="#section-5.2-6.1">¶</a></p>
</aside>
<p id="section-5.2-7">Also, in the L4S architecture <span>[<a class="cite xref" href="#RFC9330">RFC9330</a>]</span>, the sender, not the network, is
        responsible for smoothing out variations in the queue. So an L4S AQM
        <span class="bcp14">MUST</span> signal congestion as soon as possible. Then, an L4S sender
        generally interprets CE marking as an unsmoothed signal.<a class="pilcrow" href="#section-5.2-7">¶</a></p>
<p id="section-5.2-8">This requirement does not prevent an L4S AQM from mixing in
        additional congestion signals that are smoothed, such as the signals
        from a Classic smoothed AQM that are coupled with unsmoothed L4S
        signals in the coupled DualQ <span>[<a class="cite xref" href="#RFC9332">RFC9332</a>]</span>, but only as long as the
        onset of congestion can be signalled immediately and can be
        interpreted by the sender as if it has been signalled immediately,
        which is important for interoperability<a class="pilcrow" href="#section-5.2-8">¶</a></p>
</section>
</div>
<div id="l4sid_identification_transport_aware">
<section id="section-5.3">
        <h3 id="name-exception-for-l4s-packet-id">
<a class="section-number selfRef" href="#section-5.3">5.3. </a><a class="section-name selfRef" href="#name-exception-for-l4s-packet-id">Exception for L4S Packet Identification by Network Nodes with Transport-Layer Awareness</a>
        </h3>
<p id="section-5.3-1">To implement L4S packet classification, a network node does not
        need to identify transport-layer flows. Nonetheless, if an L4S network
        node classifies packets by their transport-layer flow ID and their ECN
        field, and if all the ECT packets in a flow have been ECT(0), the node
        <span class="bcp14">MAY</span> classify any CE packets in the same flow as if they were Classic
        ECT(0) packets. In all other cases, a network node <span class="bcp14">MUST</span> classify all
        CE packets as if they were ECT(1) packets. Examples of such other
        cases are: i) if no ECT packets have yet been identified in a flow;
        ii) if it is not desirable for a network node to identify
        transport-layer flows; or iii) if some ECT packets in a flow have been
        ECT(1) (this advice will need to be verified as part of L4S
        experiments).<a class="pilcrow" href="#section-5.3-1">¶</a></p>
</section>
</div>
<div id="l4sid_other_IDs">
<section id="section-5.4">
        <h3 id="name-interaction-of-the-l4s-iden">
<a class="section-number selfRef" href="#section-5.4">5.4. </a><a class="section-name selfRef" href="#name-interaction-of-the-l4s-iden">Interaction of the L4S Identifier with Other Identifiers</a>
        </h3>
<p id="section-5.4-1">The examples in this section concern how additional identifiers
        might complement the L4S identifier to classify packets between
        class-based queues. Firstly, <a class="auto internal xref" href="#l4sid_iother_IDs_dualq">Section 5.4.1</a>
        considers two queues, L4S and Classic, as in the DualQ Coupled
        AQM <span>[<a class="cite xref" href="#RFC9332">RFC9332</a>]</span>, either
        alone (<a class="auto internal xref" href="#l4sid_inclusion_dualq">Section 5.4.1.1</a>) or within a larger
        queuing hierarchy (<a class="auto internal xref" href="#l4sid_exclusion_dualq">Section 5.4.1.2</a>). Then, <a class="auto internal xref" href="#l4sid_iother_IDs_fq">Section 5.4.2</a> considers schemes that might combine
        per-flow 5-tuples with other identifiers.<a class="pilcrow" href="#section-5.4-1">¶</a></p>
<div id="l4sid_iother_IDs_dualq">
<section id="section-5.4.1">
          <h4 id="name-dualq-examples-of-other-ide">
<a class="section-number selfRef" href="#section-5.4.1">5.4.1. </a><a class="section-name selfRef" href="#name-dualq-examples-of-other-ide">DualQ Examples of Other Identifiers Complementing L4S Identifiers</a>
          </h4>
<div id="l4sid_inclusion_dualq">
<section id="section-5.4.1.1">
            <h5 id="name-inclusion-of-additional-tra">
<a class="section-number selfRef" href="#section-5.4.1.1">5.4.1.1. </a><a class="section-name selfRef" href="#name-inclusion-of-additional-tra">Inclusion of Additional Traffic with L4S</a>
            </h5>
<p id="section-5.4.1.1-1">In a typical case for the public Internet, a network element
            that implements L4S in a shared queue might want to classify some
            low-rate but unresponsive traffic (e.g., DNS, LDAP, NTP,
            voice, and game sync packets) into the low-latency queue to mix with
            L4S traffic. In this case, it would not be appropriate to call the
            queue an L4S queue, because it is shared by L4S and non-L4S
            traffic. Instead, it will be called the low-latency or L queue.
            The L queue then offers two different treatments:<a class="pilcrow" href="#section-5.4.1.1-1">¶</a></p>
<ul class="normal">
<li class="normal" id="section-5.4.1.1-2.1">the L4S treatment, which is a combination of the L4S AQM
                treatment and a priority scheduling treatment, and<a class="pilcrow" href="#section-5.4.1.1-2.1">¶</a>
</li>
              <li class="normal" id="section-5.4.1.1-2.2">the low-latency treatment, which is solely the priority
                scheduling treatment, without ECN marking by the AQM.<a class="pilcrow" href="#section-5.4.1.1-2.2">¶</a>
</li>
            </ul>
<p id="section-5.4.1.1-3">To identify packets for just the scheduling treatment, it would
            be inappropriate to use the L4S ECT(1) identifier, because such
            traffic is unresponsive to ECN marking. Examples of relevant
            non-ECN identifiers are:<a class="pilcrow" href="#section-5.4.1.1-3">¶</a></p>
<ul class="normal">
<li class="normal" id="section-5.4.1.1-4.1">address ranges of specific applications or hosts configured
                to be, or known to be, safe, e.g., hard-coded Internet of Things (IoT) devices
                sending low-intensity traffic;<a class="pilcrow" href="#section-5.4.1.1-4.1">¶</a>
</li>
              <li class="normal" id="section-5.4.1.1-4.2">certain low data-volume applications or protocols
              (e.g., ARP and DNS); and<a class="pilcrow" href="#section-5.4.1.1-4.2">¶</a>
</li>
              <li class="normal" id="section-5.4.1.1-4.3">specific Diffserv codepoints that indicate traffic with
                limited burstiness such as the EF <span>[<a class="cite xref" href="#RFC3246">RFC3246</a>]</span>,
                VOICE-ADMIT <span>[<a class="cite xref" href="#RFC5865">RFC5865</a>]</span>, or proposed
                Non-Queue-Building (NQB) <span>[<a class="cite xref" href="#I-D.ietf-tsvwg-nqb">NQB-PHB</a>]</span>
                service classes or equivalent Local-use DSCPs (see <span>[<a class="cite xref" href="#I-D.briscoe-tsvwg-l4s-diffserv">L4S-DIFFSERV</a>]</span>).<a class="pilcrow" href="#section-5.4.1.1-4.3">¶</a>
</li>
            </ul>
<p id="section-5.4.1.1-5">To be clear, classifying into the L queue based on application-layer
            identification (e.g., DNS) is an example of a local
            optimization, not a recommendation. Applications will not be able
            to rely on such unsolicited optimization. A more reliable approach
            would be for the sender to set an appropriate IP-layer identifier,
            such as one of the above Diffserv codepoints.<a class="pilcrow" href="#section-5.4.1.1-5">¶</a></p>
<p id="section-5.4.1.1-6">In summary, a network element that implements L4S in a shared
            queue <span class="bcp14">MAY</span> classify additional types of packets into the L queue
            based on identifiers other than the IP-ECN field, but the types
            <span class="bcp14">SHOULD</span> be 'safe' to mix with L4S traffic, where 'safe' is
            explained in <a class="auto internal xref" href="#l4sid_safe_unresponsive">Section 5.4.1.1.1</a>.<a class="pilcrow" href="#section-5.4.1.1-6">¶</a></p>
<p id="section-5.4.1.1-7">A packet that carries one of these non-ECN identifiers to
            classify it into the L queue would not be subject to the L4S ECN-marking
            treatment, unless it also carried an ECT(1) or CE
            codepoint. 
            The specification of an L4S AQM <span class="bcp14">MUST</span> define the
            behaviour for packets with unexpected combinations of codepoints,
            e.g., a non-ECN-based classifier for the L queue but with ECT(0)
            in the IP-ECN field (for examples with appropriate behaviours, see Section <a class="relref" href="https://www.rfc-editor.org/rfc/rfc9332#section-2.5.1.1">2.5.1.1</a> of the DualQ
            spec <span>[<a class="cite xref" href="#RFC9332">RFC9332</a>]</span>).<a class="pilcrow" href="#section-5.4.1.1-7">¶</a></p>
<p id="section-5.4.1.1-8">For clarity, non-ECN identifiers, such as the examples itemized
            above, might be used by some network operators who believe they
            identify non-L4S traffic that would be safe to mix with L4S
            traffic. They are not alternative ways for a host to indicate that
            it is sending L4S packets. 
            Only the ECT(1) ECN codepoint indicates
            to a network element that a host is sending L4S packets (and CE
            indicates that it could have originated as ECT(1)). Specifically,
            ECT(1) indicates that the host claims its behaviour satisfies the
            prerequisite transport requirements in <a class="auto internal xref" href="#l4sid_transport_req">Section 4</a>.<a class="pilcrow" href="#section-5.4.1.1-8">¶</a></p>
<p id="section-5.4.1.1-9">In order to include non-L4S packets in the L queue, a network
            node <span class="bcp14">MUST NOT</span> change Not-ECT or ECT(0) in the IP-ECN field into an
            L4S identifier. This ensures that these codepoints survive for any
            potential use later on the network path. If a non-compliant or
            malicious network node did swap ECT(0) to ECT(1), the packet could
            subsequently be ECN-marked by a downstream L4S AQM, but the sender
            would respond to congestion indications thinking it had sent a
            Classic packet. This could result in the flow yielding excessively
            to other L4S flows sharing the downstream bottleneck.<a class="pilcrow" href="#section-5.4.1.1-9">¶</a></p>
<div id="l4sid_safe_unresponsive">
<section id="section-5.4.1.1.1">
              <h6 id="name-safe-unresponsive-traffic">
<a class="section-number selfRef" href="#section-5.4.1.1.1">5.4.1.1.1. </a><a class="section-name selfRef" href="#name-safe-unresponsive-traffic">'Safe' Unresponsive Traffic</a>
              </h6>
<p id="section-5.4.1.1.1-1">The above section requires unresponsive traffic to be 'safe'
              to mix with L4S traffic. Ideally, this means that the sender
              never sends any sequence of packets at a rate that exceeds the
              available capacity of the bottleneck link. However, typically an
              unresponsive transport does not even know the bottleneck
              capacity of the path, let alone its available capacity. 
              Nonetheless, an application can be considered safe enough if it
              paces packets out (not necessarily with absolute regularity) such
              that its maximum instantaneous rate from packet to packet stays
              well below a typical broadband access rate.<a class="pilcrow" href="#section-5.4.1.1.1-1">¶</a></p>
<p id="section-5.4.1.1.1-2">This is a vague but useful definition, because many low-latency
              applications of interest, such as DNS, voice, game sync
              packets, RPC, ACKs, and keep-alives, could match this
              description.<a class="pilcrow" href="#section-5.4.1.1.1-2">¶</a></p>
<p id="section-5.4.1.1.1-3">Low-rate streams, such as voice and game sync packets, might
              not use continuously adapting ECN-based congestion control, but
              they ought to at least use a 'circuit-breaker' style of
              congestion response <span>[<a class="cite xref" href="#RFC8083">RFC8083</a>]</span>. If the volume
              of traffic from unresponsive applications is high enough to
              overload the link, this will at least protect the capacity
              available to responsive applications. However, queuing delay in
              the L queue would probably then rise to the typically higher level targeted by 
              a Classic (drop-based) AQM. If a network operator considers that such
              self-restraint is not enough, it might want to police the L
              queue (see Section <a class="relref" href="https://www.rfc-editor.org/rfc/rfc9330#section-8.2">8.2</a> of the L4S architecture <span>[<a class="cite xref" href="#RFC9330">RFC9330</a>]</span>).<a class="pilcrow" href="#section-5.4.1.1.1-3">¶</a></p>
</section>
</div>
</section>
</div>
<div id="l4sid_exclusion_dualq">
<section id="section-5.4.1.2">
            <h5 id="name-exclusion-of-traffic-from-l">
<a class="section-number selfRef" href="#section-5.4.1.2">5.4.1.2. </a><a class="section-name selfRef" href="#name-exclusion-of-traffic-from-l">Exclusion of Traffic from L4S Treatment</a>
            </h5>
<p id="section-5.4.1.2-1">To extend the above example, an operator might want to exclude
            some traffic from the L4S treatment for a policy reason,
            e.g., security (traffic from malicious sources) or commercial
            (e.g., the operator may wish to initially confine the benefits
            of L4S to business customers).<a class="pilcrow" href="#section-5.4.1.2-1">¶</a></p>
<p id="section-5.4.1.2-2">In this exclusion case, the classifier <span class="bcp14">MUST</span> classify on the
            relevant locally used identifiers (e.g., source addresses)
            before classifying the non-matching traffic on the end-to-end L4S
            ECN identifier.<a class="pilcrow" href="#section-5.4.1.2-2">¶</a></p>
<p id="section-5.4.1.2-3">A network node <span class="bcp14">MUST NOT</span> alter the end-to-end L4S ECN identifier
            from L4S to Classic, because an operator decision to exclude
            certain traffic from L4S treatment is local-only. The end-to-end
            L4S identifier then survives for other operators to use, or
            indeed, they can apply their own policy, independently based on
            their own choice of locally used identifiers. This approach also
            allows any operator to remove its locally applied exclusions in
            future, e.g., if it wishes to widen the benefit of the L4S
            treatment to all its customers. If a non-compliant or malicious
            network node did swap ECT(1) to ECT(0), the packet could
            subsequently be ECN-marked by a downstream Classic ECN AQM. L4S
            senders are required to detect and handle such treatment (see Item <a class="auto internal xref" href="#l4sid_Prague_req-classic-ecn-response">3</a> in <a class="auto internal xref" href="#l4sid_congestion_response">Section 4.3</a>), but that does not
            make this swap OK, because such detection is not known to be
            perfect or immediate.<a class="pilcrow" href="#section-5.4.1.2-3">¶</a></p>
<p id="section-5.4.1.2-4">A network node that supports L4S but excludes certain packets
            carrying the L4S identifier from L4S treatment <span class="bcp14">MUST</span> still apply
            marking or dropping that is compatible with an L4S congestion
            response. 
            For instance, it could either drop such packets with the
            same likelihood as Classic packets or ECN-mark them with
            a likelihood appropriate to L4S traffic (e.g., the coupled
            probability in a DualQ Coupled AQM) but aiming for the Classic
            delay target. It <span class="bcp14">MUST NOT</span> ECN-mark such packets with a Classic
            marking probability, which could confuse the sender.<a class="pilcrow" href="#section-5.4.1.2-4">¶</a></p>
</section>
</div>
<section id="section-5.4.1.3">
            <h5 id="name-generalized-combination-of-">
<a class="section-number selfRef" href="#section-5.4.1.3">5.4.1.3. </a><a class="section-name selfRef" href="#name-generalized-combination-of-">Generalized Combination of L4S and Other Identifiers</a>
            </h5>
<p id="section-5.4.1.3-1">L4S concerns low latency, which it can provide for all traffic
            without differentiation and without <em>necessarily</em>
            affecting bandwidth allocation. Diffserv provides for
            differentiation of both bandwidth and low latency, but its control
            of latency depends on its control of bandwidth. 
            L4S and Diffserv can be
            combined if a network operator wants to control bandwidth
            allocation but also wants to provide low latency, i.e., for any
            amount of traffic within one of these allocations of bandwidth
            (rather than only providing low latency by limiting bandwidth)
            <span>[<a class="cite xref" href="#I-D.briscoe-tsvwg-l4s-diffserv">L4S-DIFFSERV</a>]</span>.<a class="pilcrow" href="#section-5.4.1.3-1">¶</a></p>
<p id="section-5.4.1.3-2">The DualQ examples so far have been framed in the context of
            providing the default Best Effort Per-Hop Behaviour (PHB) using
            two queues -- a low-latency (L) queue and a Classic (C) queue. This
            single DualQ structure is expected to be the most common and
            useful arrangement. But, more generally, an operator might choose
            to control bandwidth allocation through a hierarchy of Diffserv
            PHBs at a node and to offer one (or more) of these PHBs using a
            pair of queues for a low latency and a Classic variant of the
            PHB.<a class="pilcrow" href="#section-5.4.1.3-2">¶</a></p>
<p id="section-5.4.1.3-3">In the first case, if we assume that a network element provides
            no PHBs except the DualQ, if a packet carries ECT(1) or CE, the
            network element would classify it for the L4S treatment
            irrespective of its DSCP. And, if a packet carried (for example) the EF
            DSCP, the network element could classify it into the L queue
            irrespective of its ECN codepoint. However, where the DualQ is in
            a hierarchy of other PHBs, the classifier would classify some
            traffic into other PHBs based on DSCP before classifying between
            the low-latency and Classic queues (based on ECT(1), CE, and
            perhaps also the EF DSCP or other identifiers as in the above
            example). <span>[<a class="cite xref" href="#I-D.briscoe-tsvwg-l4s-diffserv">L4S-DIFFSERV</a>]</span> gives a
            number of examples of such arrangements to address various
            requirements.<a class="pilcrow" href="#section-5.4.1.3-3">¶</a></p>
<p id="section-5.4.1.3-4"><span>[<a class="cite xref" href="#I-D.briscoe-tsvwg-l4s-diffserv">L4S-DIFFSERV</a>]</span> describes how
            an operator might use L4S to offer low latency as well as
            Diffserv for bandwidth differentiation. It identifies two main
            types of approach, which can be combined: the operator might split
            certain Diffserv PHBs between L4S and a corresponding Classic
            service. Or it might split the L4S and/or the Classic service into
            multiple Diffserv PHBs. In either of these cases, a packet would
            have to be classified on its Diffserv and ECN codepoints.<a class="pilcrow" href="#section-5.4.1.3-4">¶</a></p>
<p id="section-5.4.1.3-5">In summary, there are numerous ways in which the L4S ECN
            identifier (ECT(1) and CE) could be combined with other
            identifiers to achieve particular objectives. The following
            categorization articulates those that are valid, but it is not
            necessarily exhaustive. Those tagged as 'Recommended-standard-use'
            could be set by the sending host or a network. Those tagged
            as 'Local-use' would only be set by a network:<a class="pilcrow" href="#section-5.4.1.3-5">¶</a></p>
<ol class="normal type-1" id="section-5.4.1.3-6" start="1" type="1">
<li id="section-5.4.1.3-6.1">
                <p id="section-5.4.1.3-6.1.1">Identifiers Complementing the L4S Identifier<a class="pilcrow" href="#section-5.4.1.3-6.1.1">¶</a></p>
<ol class="normal type-a" id="section-5.4.1.3-6.1.2" start="1" type="a">
<li id="section-5.4.1.3-6.1.2.1">
                    <p id="section-5.4.1.3-6.1.2.1.1">Including More Traffic in the L Queue<a class="pilcrow" href="#section-5.4.1.3-6.1.2.1.1">¶</a></p>
<p id="section-5.4.1.3-6.1.2.1.2">(could use Recommended-standard-use or
                    Local-use identifiers)<a class="pilcrow" href="#section-5.4.1.3-6.1.2.1.2">¶</a></p>
</li>
                  <li id="section-5.4.1.3-6.1.2.2">
                    <p id="section-5.4.1.3-6.1.2.2.1">Excluding Certain Traffic from the L Queue<a class="pilcrow" href="#section-5.4.1.3-6.1.2.2.1">¶</a></p>
<p id="section-5.4.1.3-6.1.2.2.2">(Local-use only)<a class="pilcrow" href="#section-5.4.1.3-6.1.2.2.2">¶</a></p>
</li>
                </ol>
</li>
              <li id="section-5.4.1.3-6.2">
                <p id="section-5.4.1.3-6.2.1">Identifiers to Place L4S Classification in a PHB
                Hierarchy<a class="pilcrow" href="#section-5.4.1.3-6.2.1">¶</a></p>
<p id="section-5.4.1.3-6.2.2">(could use
                Recommended-standard-use or Local-use identifiers)<a class="pilcrow" href="#section-5.4.1.3-6.2.2">¶</a></p>
<ol class="normal type-a" id="section-5.4.1.3-6.2.3" start="1" type="a">
<li id="section-5.4.1.3-6.2.3.1">PHBs before L4S ECN Classification<a class="pilcrow" href="#section-5.4.1.3-6.2.3.1">¶</a>
</li>
                  <li id="section-5.4.1.3-6.2.3.2">PHBs after L4S ECN Classification<a class="pilcrow" href="#section-5.4.1.3-6.2.3.2">¶</a>
</li>
                </ol>
</li>
            </ol>
</section>
</section>
</div>
<div id="l4sid_iother_IDs_fq">
<section id="section-5.4.2">
          <h4 id="name-per-flow-queuing-examples-o">
<a class="section-number selfRef" href="#section-5.4.2">5.4.2. </a><a class="section-name selfRef" href="#name-per-flow-queuing-examples-o">Per-flow Queuing Examples of Other Identifiers Complementing L4S Identifiers</a>
          </h4>
<p id="section-5.4.2-1">At a node with per-flow queuing (e.g., FQ-CoDel <span>[<a class="cite xref" href="#RFC8290">RFC8290</a>]</span>), the L4S identifier could complement the transport-layer
          flow ID as a further level of flow granularity (i.e., Not-ECT
          and ECT(0) queued separately from ECT(1) and CE packets).
          In <a class="auto internal xref" href="#l4sid_ECT1_CE">Appendix B</a>, the "Risk of
          reordering Classic CE packets within a flow" discusses the resulting 
          ambiguity if packets originally set to
          ECT(0) are marked CE by an upstream AQM before they arrive at a node
          that classifies CE as L4S. It argues that the risk of reordering is
          vanishingly small, and the consequence of such a low level of
          reordering is minimal.<a class="pilcrow" href="#section-5.4.2-1">¶</a></p>
<p id="section-5.4.2-2">Alternatively, it could be assumed that it is not in a flow's own
          interest to mix Classic and L4S identifiers. Then, the AQM could use
          the IP-ECN field to switch itself between a Classic and an L4S AQM
          behaviour within one per-flow queue. For instance, for ECN-capable
          packets, the AQM might consist of a simple marking threshold, and an
          L4S ECN identifier might simply select a shallower threshold than a
          Classic ECN identifier would.<a class="pilcrow" href="#section-5.4.2-2">¶</a></p>
</section>
</div>
</section>
</div>
<div id="l4sid_bursts_links">
<section id="section-5.5">
        <h3 id="name-limiting-packet-bursts-from">
<a class="section-number selfRef" href="#section-5.5">5.5. </a><a class="section-name selfRef" href="#name-limiting-packet-bursts-from">Limiting Packet Bursts from Links</a>
        </h3>
<p id="section-5.5-1">As well as senders needing to limit packet bursts (<a class="auto internal xref" href="#l4sid_congestion_response">Section 4.3</a>), links need to limit the degree
        of burstiness they introduce. In both cases (senders and links), this
        is a trade-off, because batch-handling of packets is done for good
        reason, e.g., for processing efficiency or to make efficient use of
        medium acquisition delay. Some take the attitude that there is no
        point reducing burst delay at the sender below that introduced by
        links (or vice versa). However, delay reduction proceeds by cutting
        down 'the longest pole in the tent', which turns the spotlight on the
        next longest, and so on.<a class="pilcrow" href="#section-5.5-1">¶</a></p>
<p id="section-5.5-2">This document does not set any quantified requirements for links to
        limit burst delay, primarily because link technologies are outside the
        remit of L4S specifications. Nonetheless, the following two
        subsections outline opportunities for addressing bursty links in the
        process of L4S implementation and deployment.<a class="pilcrow" href="#section-5.5-2">¶</a></p>
<div id="l4sid_bursts_links_l4s">
<section id="section-5.5.1">
          <h4 id="name-limiting-packet-bursts-from-">
<a class="section-number selfRef" href="#section-5.5.1">5.5.1. </a><a class="section-name selfRef" href="#name-limiting-packet-bursts-from-">Limiting Packet Bursts from Links Fed by an L4S AQM</a>
          </h4>
<p id="section-5.5.1-1">It would not make sense to implement an L4S AQM that feeds into a
          particular link technology without also reviewing opportunities to
          reduce any form of burst delay introduced by that link technology.
          This would at least limit the bursts that the link would otherwise
          introduce into the onward traffic, which would cause jumpy feedback
          to the sender as well as potential extra queuing delay downstream.
          This document does not presume to even give guidance on an
          appropriate target for such burst delay until there is more industry
          experience of L4S. However, as suggested in <a class="auto internal xref" href="#l4sid_congestion_response">Section 4.3</a>, it would not seem necessary to
          limit bursts lower than roughly 10% of the minimum base RTT expected
          in the typical deployment scenario (e.g., 250 us burst duration
          for links within the public Internet).<a class="pilcrow" href="#section-5.5.1-1">¶</a></p>
</section>
</div>
<div id="l4sid_bursts_links_l4s_upstream">
<section id="section-5.5.2">
          <h4 id="name-limiting-packet-bursts-from-l">
<a class="section-number selfRef" href="#section-5.5.2">5.5.2. </a><a class="section-name selfRef" href="#name-limiting-packet-bursts-from-l">Limiting Packet Bursts from Links Upstream of an L4S AQM</a>
          </h4>
<p id="section-5.5.2-1">The initial scope of the L4S experiment is to deploy L4S AQMs at
          bottlenecks and L4S congestion controls at senders. This is expected
          to highlight interactions with the most bursty upstream links and
          lead operators to tune down the burstiness of those links in their
          networks that are configurable or, failing that, to have to
          compromise on the delay target of some L4S AQMs. It might also
          require specific redesign work relevant to the most problematic link
          types. Such knock-on effects of initial L4S deployment would all be a
          part of the learning from the L4S experiment.<a class="pilcrow" href="#section-5.5.2-1">¶</a></p>
<p id="section-5.5.2-2">The details of such link changes are beyond the scope of the
          present document. 
          Nonetheless, where L4S technology is being
          implemented on an outgoing interface of a device, it would make
          sense to consider opportunities for reducing bursts arriving at
          other incoming interfaces. For instance, where an L4S AQM is
          implemented to feed into the upstream WAN interface of a home
          gateway, there would be opportunities to alter the Wi-Fi profiles
          sent out of any Wi-Fi interfaces from the same device, in order to
          mitigate incoming bursts of aggregated Wi-Fi frames from other Wi-Fi
          stations.<a class="pilcrow" href="#section-5.5.2-2">¶</a></p>
</section>
</div>
</section>
</div>
</section>
</div>
<div id="l4sid_encaps">
<section id="section-6">
      <h2 id="name-behaviour-of-tunnels-and-en">
<a class="section-number selfRef" href="#section-6">6. </a><a class="section-name selfRef" href="#name-behaviour-of-tunnels-and-en">Behaviour of Tunnels and Encapsulations</a>
      </h2>
<div id="l4sid_encaps_no_change">
<section id="section-6.1">
        <h3 id="name-no-change-to-ecn-tunnels-an">
<a class="section-number selfRef" href="#section-6.1">6.1. </a><a class="section-name selfRef" href="#name-no-change-to-ecn-tunnels-an">No Change to ECN Tunnels and Encapsulations in General</a>
        </h3>
<p id="section-6.1-1">The L4S identifier is expected to work through and within any
        tunnel without modification, as long as the tunnel propagates the ECN
        field in any of the ways that have been defined since the first
        variant in the year 2001 <span>[<a class="cite xref" href="#RFC3168">RFC3168</a>]</span>. L4S will also
        work with (but does not rely on) any of the more recent updates to ECN
        propagation in <span>[<a class="cite xref" href="#RFC4301">RFC4301</a>]</span>, <span>[<a class="cite xref" href="#RFC6040">RFC6040</a>]</span>, or
        <span>[<a class="cite xref" href="#I-D.ietf-tsvwg-rfc6040update-shim">ECN-SHIM</a>]</span>. However, it is
        likely that some tunnels still do not implement ECN propagation at
        all. In these cases, L4S will work through such tunnels, but within
        them the outer header of L4S traffic will appear as Classic.<a class="pilcrow" href="#section-6.1-1">¶</a></p>
<p id="section-6.1-2">AQMs are typically implemented where an IP-layer buffer feeds into
        a lower layer, so they are agnostic to link-layer encapsulations.
        Where a bottleneck link is not IP-aware, the L4S identifier is still
        expected to work within any lower-layer encapsulation without
        modification, as long it propagates the IP-ECN field as defined for the
        link technology, for example, for MPLS <span>[<a class="cite xref" href="#RFC5129">RFC5129</a>]</span> or Transparent 
        Interconnection of Lots of Links (TRILL) <span>[<a class="cite xref" href="#I-D.ietf-trill-ecn-support">TRILL-ECN-SUPPORT</a>]</span>. In some of
        these cases, e.g., Layer 3 Ethernet switches, the AQM accesses the
        IP-layer header within the outer encapsulation, so again the L4S
        identifier is expected to work without modification. Nonetheless, the
        programme to define ECN for other lower layers is still in
        progress <span>[<a class="cite xref" href="#I-D.ietf-tsvwg-ecn-encap-guidelines">ECN-ENCAP</a>]</span>.<a class="pilcrow" href="#section-6.1-2">¶</a></p>
</section>
</div>
<div id="l4sid_VPN_anti-replay">
<section id="section-6.2">
        <h3 id="name-vpn-behaviour-to-avoid-limi">
<a class="section-number selfRef" href="#section-6.2">6.2. </a><a class="section-name selfRef" href="#name-vpn-behaviour-to-avoid-limi">VPN Behaviour to Avoid Limitations of Anti-Replay</a>
        </h3>
<p id="section-6.2-1">If a mix of L4S and Classic packets is sent into the same security
        association (SA) of a VPN, and if the VPN
        egress is employing the optional anti-replay feature, it could
        inappropriately discard Classic packets (or discard the records in
        Classic packets) by mistaking their greater queuing delay for a replay
        attack (see "Dropped Packets for Tunnels with Replay Protection
        Enabled" in <span>[<a class="cite xref" href="#Heist21">Heist21</a>]</span> for the potential performance
        impact). This known problem is common to both IPsec <span>[<a class="cite xref" href="#RFC4301">RFC4301</a>]</span> and DTLS <span>[<a class="cite xref" href="#RFC9147">RFC9147</a>]</span> VPNs, given
        they use similar anti-replay window mechanisms. The mechanism used can
        only check for replay within its window, so if the window is smaller
        than the degree of reordering, it can only assume there might be a
        replay attack and discard all the packets behind the trailing edge of
        the window. The specifications of IPsec Authentication Header (AH) 
        <span>[<a class="cite xref" href="#RFC4302">RFC4302</a>]</span> and Encapsulating Security Payload (ESP) <span>[<a class="cite xref" href="#RFC4303">RFC4303</a>]</span> suggest that
        an implementer scales the size of the anti-replay window with
        interface speed, and DTLS v1.3 <span>[<a class="cite xref" href="#RFC9147">RFC9147</a>]</span> states that "The
        receiver <span class="bcp14">SHOULD</span> pick a window large enough to handle any plausible
        reordering, which depends on the data rate." However, in practice, the
        size of a VPN's anti-replay window is not always scaled
        appropriately.<a class="pilcrow" href="#section-6.2-1">¶</a></p>
<p id="section-6.2-2">If a VPN carrying traffic participating in the L4S experiment
        experiences inappropriate replay detection, the foremost remedy would
        be to ensure that the egress is configured to comply with the above
        window-sizing requirements.<a class="pilcrow" href="#section-6.2-2">¶</a></p>
<p id="section-6.2-3">If an implementation of a VPN egress does not support a
        sufficiently large anti-replay window, e.g., due to hardware
        limitations, one of the temporary alternatives listed in order of
        preference below might be feasible instead:<a class="pilcrow" href="#section-6.2-3">¶</a></p>
<ul class="normal">
<li class="normal" id="section-6.2-4.1">If the VPN can be configured to classify packets into different
            SAs indexed by DSCP, apply the appropriate locally defined DSCPs
            to Classic and L4S packets. The DSCPs could be applied by the
            network (based on the least-significant bit of the IP-ECN field), or
            by the sending host. Such DSCPs would only need to survive as far
            as the VPN ingress.<a class="pilcrow" href="#section-6.2-4.1">¶</a>
</li>
          <li class="normal" id="section-6.2-4.2">
            <p id="section-6.2-4.2.1">If the above is not possible and it is necessary to use L4S,
            either of the following might be appropriate as a last
            resort:<a class="pilcrow" href="#section-6.2-4.2.1">¶</a></p>
<ul class="normal">
<li class="normal" id="section-6.2-4.2.2.1">disable anti-replay protection at the VPN egress, after
                considering the security implications (it is mandatory to
                allow the anti-replay facility to be disabled in both IPsec
                and DTLS), or<a class="pilcrow" href="#section-6.2-4.2.2.1">¶</a>
</li>
              <li class="normal" id="section-6.2-4.2.2.2">configure the tunnel ingress not to propagate ECN to the
                outer, which would lose the benefits of L4S and Classic ECN
                over the VPN.<a class="pilcrow" href="#section-6.2-4.2.2.2">¶</a>
</li>
            </ul>
</li>
        </ul>
<p id="section-6.2-5">Modification to VPN implementations is outside the present scope,
        which is why this section has so far focused on reconfiguration.
        Although this document does not define any requirements for VPN
        implementations, determining whether there is a need for such
        requirements could be one aspect of L4S experimentation.<a class="pilcrow" href="#section-6.2-5">¶</a></p>
</section>
</div>
</section>
</div>
<div id="l4sid_expts">
<section id="section-7">
      <h2 id="name-l4s-experiments">
<a class="section-number selfRef" href="#section-7">7. </a><a class="section-name selfRef" href="#name-l4s-experiments">L4S Experiments</a>
      </h2>
<p id="section-7-1">This section describes open questions that L4S experiments ought to
      focus on. This section also documents outstanding open issues that will
      need to be investigated as part of L4S experimentation, given they could
      not be fully resolved during the working group phase. It also lists metrics that
      will need to be monitored during experiments (summarizing text elsewhere
      in L4S documents) and finally lists some potential future directions
      that researchers might wish to investigate.<a class="pilcrow" href="#section-7-1">¶</a></p>
<p id="section-7-2">In addition to this section, i) the DualQ spec <span>[<a class="cite xref" href="#RFC9332">RFC9332</a>]</span> sets operational and
      management requirements for experiments with DualQ Coupled AQMs, and
      ii) general operational and management requirements for experiments with L4S
      congestion controls are given in Sections <a class="auto internal xref" href="#l4sid_transport_req">4</a>
      and <a class="auto internal xref" href="#l4sid_network_req">5</a> above, e.g., coexistence and
      scaling requirements and incremental deployment arrangements.<a class="pilcrow" href="#section-7-2">¶</a></p>
<p id="section-7-3">The specification of each Scalable congestion control will need to
      include protocol-specific requirements for configuration and monitoring
      performance during experiments. 

      <span><a class="relref" href="https://www.rfc-editor.org/rfc/rfc5706#appendix-A">Appendix A</a> of [<a class="cite xref" href="#RFC5706">RFC5706</a>]</span> provides a helpful checklist.<a class="pilcrow" href="#section-7-3">¶</a></p>
<section id="section-7.1">
        <h3 id="name-open-questions">
<a class="section-number selfRef" href="#section-7.1">7.1. </a><a class="section-name selfRef" href="#name-open-questions">Open Questions</a>
        </h3>
<p id="section-7.1-1">L4S experiments would be expected to answer the following
        questions:<a class="pilcrow" href="#section-7.1-1">¶</a></p>
<ul class="normal">
<li class="normal" id="section-7.1-2.1">
            <p id="section-7.1-2.1.1">Have all the parts of L4S been deployed, and if so, what
            proportion of paths support it?<a class="pilcrow" href="#section-7.1-2.1.1">¶</a></p>
<ul class="normal">
<li class="normal" id="section-7.1-2.1.2.1">What types of L4S AQMs were deployed, e.g., FQ, coupled
                DualQ, uncoupled DualQ, other? And how prevalent was each?<a class="pilcrow" href="#section-7.1-2.1.2.1">¶</a>
</li>
              <li class="normal" id="section-7.1-2.1.2.2">Are the signalling patterns emitted by the deployed AQMs in
                any way different from those expected when the Prague
                requirements for endpoints were written?<a class="pilcrow" href="#section-7.1-2.1.2.2">¶</a>
</li>
            </ul>
</li>
          <li class="normal" id="section-7.1-2.2">Does use of L4S over the Internet result in a significantly
            improved user experience?<a class="pilcrow" href="#section-7.1-2.2">¶</a>
</li>
          <li class="normal" id="section-7.1-2.3">Has L4S enabled novel interactive applications?<a class="pilcrow" href="#section-7.1-2.3">¶</a>
</li>
          <li class="normal" id="section-7.1-2.4">
            <p id="section-7.1-2.4.1">Did use of L4S over the Internet result in improvements to the
            following metrics:<a class="pilcrow" href="#section-7.1-2.4.1">¶</a></p>
<ul class="normal">
<li class="normal" id="section-7.1-2.4.2.1">queue delay (mean and 99th percentile) under various
                loads;<a class="pilcrow" href="#section-7.1-2.4.2.1">¶</a>
</li>
              <li class="normal" id="section-7.1-2.4.2.2">utilization;<a class="pilcrow" href="#section-7.1-2.4.2.2">¶</a>
</li>
              <li class="normal" id="section-7.1-2.4.2.3">starvation / fairness; and<a class="pilcrow" href="#section-7.1-2.4.2.3">¶</a>
</li>
              <li class="normal" id="section-7.1-2.4.2.4">scaling range of flow rates and RTTs?<a class="pilcrow" href="#section-7.1-2.4.2.4">¶</a>
</li>
            </ul>
</li>
          <li class="normal" id="section-7.1-2.5">How dependent was the performance of L4S service on the
            bottleneck bandwidth or the path RTT?<a class="pilcrow" href="#section-7.1-2.5">¶</a>
</li>
          <li class="normal" id="section-7.1-2.6">How much do bursty links in the Internet affect L4S performance
            (see "Underutilization with Bursty Links" in <span>[<a class="cite xref" href="#Heist21">Heist21</a>]</span>) and how prevalent are they? How much
            limitation of burstiness from upstream links was needed and/or was
            realized -- both at senders and at links, especially radio links -- or
            how much did L4S target delay have to be increased to accommodate
            the bursts (see Item <a class="auto internal xref" href="#l4sid_Prague_req-burstiness">7</a> in <a class="auto internal xref" href="#l4sid_congestion_response">Section 4.3</a> and see <a class="auto internal xref" href="#l4sid_bursts_links_l4s_upstream">Section 5.5.2</a>)?<a class="pilcrow" href="#section-7.1-2.6">¶</a>
</li>
          <li class="normal" id="section-7.1-2.7">Is the initial experiment with mis-identified bursty traffic at
            high RTT (see "Underutilization with Bursty Traffic" in <span>[<a class="cite xref" href="#Heist21">Heist21</a>]</span>) indicative of similar problems at lower RTTs,
            and if so, how effective is the suggested remedy in <span><a class="relref" href="https://www.rfc-editor.org/rfc/rfc9332#appendix-A.1">Appendix A.1</a> of the DualQ spec [<a class="cite xref" href="#RFC9332">RFC9332</a>]</span> (or possible other
            remedies)?<a class="pilcrow" href="#section-7.1-2.7">¶</a>
</li>
          <li class="normal" id="section-7.1-2.8">
            <p id="section-7.1-2.8.1">Was per-flow queue protection typically (un)necessary?<a class="pilcrow" href="#section-7.1-2.8.1">¶</a></p>
<ul class="normal">
<li class="normal" id="section-7.1-2.8.2.1">How well did overload protection or queue protection
                work?<a class="pilcrow" href="#section-7.1-2.8.2.1">¶</a>
</li>
            </ul>
</li>
          <li class="normal" id="section-7.1-2.9">
            <p id="section-7.1-2.9.1">How well did L4S flows coexist with Classic flows when sharing
            a bottleneck?<a class="pilcrow" href="#section-7.1-2.9.1">¶</a></p>
<ul class="normal">
<li class="normal" id="section-7.1-2.9.2.1">How frequently did problems arise?<a class="pilcrow" href="#section-7.1-2.9.2.1">¶</a>
</li>
              <li class="normal" id="section-7.1-2.9.2.2">What caused any coexistence problems, and were any problems
                due to single-queue Classic ECN AQMs (this assumes
                single-queue Classic ECN AQMs can be distinguished from FQ
                ones)?<a class="pilcrow" href="#section-7.1-2.9.2.2">¶</a>
</li>
            </ul>
</li>
          <li class="normal" id="section-7.1-2.10">How prevalent were problems with the L4S service due to tunnels/encapsulations
            that do not support ECN decapsulation?<a class="pilcrow" href="#section-7.1-2.10">¶</a>
</li>
          <li class="normal" id="section-7.1-2.11">How easy was it to implement a fully compliant L4S congestion
            control, over various different transport protocols (TCP, QUIC,
            RMCAT, etc.)?<a class="pilcrow" href="#section-7.1-2.11">¶</a>
</li>
        </ul>
<p id="section-7.1-3">Monitoring for harm to other traffic, specifically bandwidth
        starvation or excess queuing delay, will need to be conducted
        alongside all early L4S experiments. It is hard, if not impossible,
        for an individual flow to measure its impact on other traffic. So such
        monitoring will need to be conducted using bespoke monitoring across
        flows and/or across classes of traffic.<a class="pilcrow" href="#section-7.1-3">¶</a></p>
</section>
<section id="section-7.2">
        <h3 id="name-open-issues">
<a class="section-number selfRef" href="#section-7.2">7.2. </a><a class="section-name selfRef" href="#name-open-issues">Open Issues</a>
        </h3>
<ul class="normal">
<li class="normal" id="section-7.2-1.1">What is the best way forward to deal with L4S over single-queue
            Classic ECN AQM bottlenecks, given current problems with
            misdetecting L4S AQMs as Classic ECN AQMs? See the L4S operational
            guidance <span>[<a class="cite xref" href="#I-D.ietf-tsvwg-l4sops">L4SOPS</a>]</span>.<a class="pilcrow" href="#section-7.2-1.1">¶</a>
</li>
          <li class="normal" id="section-7.2-1.2">Fixing the poor interaction between current L4S congestion
            controls and CoDel with only Classic ECN support during flow
            startup.
            Originally, this was due to a bug in the initialization
            of the congestion average in the
     Linux implementation of TCP Prague.
            That was quickly fixed, which removed the main performance impact,
            but further improvement would be useful (by modifying either
            CoDel or Scalable congestion controls, or both).<a class="pilcrow" href="#section-7.2-1.2">¶</a>
</li>
        </ul>
</section>
<section id="section-7.3">
        <h3 id="name-future-potential">
<a class="section-number selfRef" href="#section-7.3">7.3. </a><a class="section-name selfRef" href="#name-future-potential">Future Potential</a>
        </h3>
<p id="section-7.3-1">Researchers might find that L4S opens up the following interesting
        areas for investigation:<a class="pilcrow" href="#section-7.3-1">¶</a></p>
<ul class="normal">
<li class="normal" id="section-7.3-2.1">potential for faster convergence time and tracking of available
            capacity;<a class="pilcrow" href="#section-7.3-2.1">¶</a>
</li>
          <li class="normal" id="section-7.3-2.2">potential for improvements to particular link technologies and
            cross-layer interactions with them;<a class="pilcrow" href="#section-7.3-2.2">¶</a>
</li>
          <li class="normal" id="section-7.3-2.3">potential for using virtual queues, e.g., to further reduce
            latency jitter or to leave headroom for capacity variation in
            radio networks;<a class="pilcrow" href="#section-7.3-2.3">¶</a>
</li>
          <li class="normal" id="section-7.3-2.4">development and specification of reverse path congestion
            control using L4S building blocks (e.g., AccECN or QUIC);<a class="pilcrow" href="#section-7.3-2.4">¶</a>
</li>
          <li class="normal" id="section-7.3-2.5">once queuing delay is cut down, what becomes the
            'second-longest pole in the tent' (other than the speed of
            light)?<a class="pilcrow" href="#section-7.3-2.5">¶</a>
</li>
          <li class="normal" id="section-7.3-2.6">novel alternatives to the existing set of L4S AQMs; and<a class="pilcrow" href="#section-7.3-2.6">¶</a>
</li>
          <li class="normal" id="section-7.3-2.7">novel applications enabled by L4S.<a class="pilcrow" href="#section-7.3-2.7">¶</a>
</li>
        </ul>
</section>
</section>
</div>
<div id="l4sid_IANA">
<section id="section-8">
      <h2 id="name-iana-considerations">
<a class="section-number selfRef" href="#section-8">8. </a><a class="section-name selfRef" href="#name-iana-considerations">IANA Considerations</a>
      </h2>
<p id="section-8-1">The semantics of the 01 codepoint of the ECN field of the IP header are specified by
      this Experimental RFC. The process for an Experimental RFC to
      assign this codepoint in the IP header (v4 and v6) is documented in
      Proposed Standard <span>[<a class="cite xref" href="#RFC8311">RFC8311</a>]</span>, which updates the Proposed
      Standard <span>[<a class="cite xref" href="#RFC3168">RFC3168</a>]</span>.<a class="pilcrow" href="#section-8-1">¶</a></p>
<p id="section-8-2">IANA has updated the 01 entry in the "ECN Field (Bits 6-7)" registry (see <span>&lt;<a href="https://www.iana.org/assignments/dscp-registry/">https://www.iana.org/assignments/dscp-registry/</a>&gt;</span>) as
      follows:<a class="pilcrow" href="#section-8-2">¶</a></p>
<span id="name-ecn-field-bits-6-7-registry"></span><table class="center" id="table-1">
        <caption>
<a class="selfRef" href="#table-1">Table 1</a>:
<a class="selfRef" href="#name-ecn-field-bits-6-7-registry">ECN Field (Bits 6-7) Registry</a>
        </caption>
<thead>
          <tr>
            <th class="text-left" colspan="1" rowspan="1">Binary</th>
            <th class="text-left" colspan="1" rowspan="1">Keyword</th>
            <th class="text-left" colspan="1" rowspan="1">Reference</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td class="text-left" colspan="1" rowspan="1">01</td>
            <td class="text-left" colspan="1" rowspan="1">ECT(1) (ECN-Capable Transport(1))[1]</td>
            <td class="text-left" colspan="1" rowspan="1">
              <span>[<a class="cite xref" href="#RFC8311">RFC8311</a>]</span> [RFC Errata 5399]
        RFC 9331</td>
          </tr>
        </tbody>
      </table>
<p id="section-8-4">[1]  ECT(1) is for experimental use only <span>[<a class="cite xref" href="#RFC8311">RFC8311</a>], <a class="relref" href="https://www.rfc-editor.org/rfc/rfc8311#section-4.2">Section 4.2</a></span><a class="pilcrow" href="#section-8-4">¶</a></p>
</section>
</div>
<div id="l4sid_Security_Considerations">
<section id="section-9">
      <h2 id="name-security-considerations">
<a class="section-number selfRef" href="#section-9">9. </a><a class="section-name selfRef" href="#name-security-considerations">Security Considerations</a>
      </h2>
<p id="section-9-1">Approaches to assure the integrity of signals using the new
      identifier are introduced in <a class="auto internal xref" href="#l4sid_competing_integrity">Appendix C.1</a>. See the security considerations in
      the L4S architecture <span>[<a class="cite xref" href="#RFC9330">RFC9330</a>]</span> for
      further discussion of misuse of the identifier, as well as extensive
      discussion of policing rate and latency in regard to L4S.<a class="pilcrow" href="#section-9-1">¶</a></p>
<p id="section-9-2">Defining ECT(1) as the L4S identifier introduces a difference between
      the effects of ECT(0) and ECT(1) that <span>[<a class="cite xref" href="#RFC3168">RFC3168</a>]</span> previously defined as
      distinct but with equivalent effect. For L4S ECN, a network node is
      still required not to swap one to the other, even if the network
      operator chooses to locally apply the treatment associated with the
      opposite codepoint (see Sections <a class="auto internal xref" href="#l4sid_inclusion_dualq">5.4.1.1</a> and <a class="auto internal xref" href="#l4sid_exclusion_dualq">5.4.1.2</a>). These sections also describe the
      potential effects if a non-compliant or malicious network node does swap
      one to the other. The present specification does not change the effects
      of other unexpected transitions of the IP-ECN field, which are still as
      described in <span><a class="relref" href="https://www.rfc-editor.org/rfc/rfc3168#section-18">Section 18</a> of [<a class="cite xref" href="#RFC3168">RFC3168</a>]</span>.<a class="pilcrow" href="#section-9-2">¶</a></p>
<p id="section-9-3">If the anti-replay window of a VPN egress is too small, it will
      mistake deliberate delay differences as a replay attack and discard
      higher-delay packets (e.g., Classic) carried within the same
      security association (SA) as low-delay packets (e.g., L4S). <a class="auto internal xref" href="#l4sid_VPN_anti-replay">Section 6.2</a> recommends that VPNs used in L4S
      experiments are configured with a sufficiently large anti-replay window,
      as required by the relevant specifications. It also discusses other
      alternatives.<a class="pilcrow" href="#section-9-3">¶</a></p>
<p id="section-9-4">If a user taking part in the L4S experiment sets up a VPN without
      being aware of the above advice, and if the user allows anyone to send
      traffic into their VPN, they would open up a DoS vulnerability in which
      an attacker could induce the VPN's anti-replay mechanism to discard
      enough of the user's Classic (C) traffic (if they are receiving any) to
      cause a significant rate reduction. While the user is actively
      downloading C traffic, the attacker sends C traffic into the VPN to fill
      the remainder of the bottleneck link, then sends intermittent L4S
      packets to maximize the chance of exceeding the VPN's replay window. The
      user can prevent this attack by following the recommendations in <a class="auto internal xref" href="#l4sid_VPN_anti-replay">Section 6.2</a>.<a class="pilcrow" href="#section-9-4">¶</a></p>
<p id="section-9-5">The recommendation to detect loss in time units prevents the
      ACK-splitting attacks described in <span>[<a class="cite xref" href="#Savage-TCP">Savage-TCP</a>]</span>.<a class="pilcrow" href="#section-9-5">¶</a></p>
</section>
</div>
<section id="section-10">
      <h2 id="name-references">
<a class="section-number selfRef" href="#section-10">10. </a><a class="section-name selfRef" href="#name-references">References</a>
      </h2>
<section id="section-10.1">
        <h3 id="name-normative-references">
<a class="section-number selfRef" href="#section-10.1">10.1. </a><a class="section-name selfRef" href="#name-normative-references">Normative References</a>
        </h3>
<dl class="references">
<dt id="RFC2119">[RFC2119]</dt>
        <dd>
<span class="refAuthor">Bradner, S.</span>, <span class="refTitle">"Key words for use in RFCs to Indicate Requirement Levels"</span>, <span class="seriesInfo">BCP 14</span>, <span class="seriesInfo">RFC 2119</span>, <span class="seriesInfo">DOI 10.17487/RFC2119</span>, <time class="refDate" datetime="1997-03">March 1997</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc2119">https://www.rfc-editor.org/info/rfc2119</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC3168">[RFC3168]</dt>
        <dd>
<span class="refAuthor">Ramakrishnan, K.</span>, <span class="refAuthor">Floyd, S.</span>, and <span class="refAuthor">D. Black</span>, <span class="refTitle">"The Addition of Explicit Congestion Notification (ECN) to IP"</span>, <span class="seriesInfo">RFC 3168</span>, <span class="seriesInfo">DOI 10.17487/RFC3168</span>, <time class="refDate" datetime="2001-09">September 2001</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc3168">https://www.rfc-editor.org/info/rfc3168</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC4774">[RFC4774]</dt>
        <dd>
<span class="refAuthor">Floyd, S.</span>, <span class="refTitle">"Specifying Alternate Semantics for the Explicit Congestion Notification (ECN) Field"</span>, <span class="seriesInfo">BCP 124</span>, <span class="seriesInfo">RFC 4774</span>, <span class="seriesInfo">DOI 10.17487/RFC4774</span>, <time class="refDate" datetime="2006-11">November 2006</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc4774">https://www.rfc-editor.org/info/rfc4774</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC6679">[RFC6679]</dt>
      <dd>
<span class="refAuthor">Westerlund, M.</span>, <span class="refAuthor">Johansson, I.</span>, <span class="refAuthor">Perkins, C.</span>, <span class="refAuthor">O'Hanlon, P.</span>, and <span class="refAuthor">K. Carlberg</span>, <span class="refTitle">"Explicit Congestion Notification (ECN) for RTP over UDP"</span>, <span class="seriesInfo">RFC 6679</span>, <span class="seriesInfo">DOI 10.17487/RFC6679</span>, <time class="refDate" datetime="2012-08">August 2012</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc6679">https://www.rfc-editor.org/info/rfc6679</a>&gt;</span>. </dd>
<dd class="break"></dd>
</dl>
</section>
<section id="section-10.2">
        <h3 id="name-informative-references">
<a class="section-number selfRef" href="#section-10.2">10.2. </a><a class="section-name selfRef" href="#name-informative-references">Informative References</a>
        </h3>
<dl class="references">
<dt id="A2DTCP">[A2DTCP]</dt>
        <dd>
<span class="refAuthor">Zhang, T.</span>, <span class="refAuthor">Wang, J.</span>, <span class="refAuthor">Huang, J.</span>, <span class="refAuthor">Huang, Y.</span>, <span class="refAuthor">Chen, J.</span>, and <span class="refAuthor">Y. Pan</span>, <span class="refTitle">"Adaptive-Acceleration Data Center TCP"</span>, <span class="refContent">IEEE Transactions on Computers, Volume 64, Issue 6, pp. 1522-1533</span>, <span class="seriesInfo">DOI 10.1109/TC.2014.2345393</span>, <time class="refDate" datetime="2015-06">June 2015</time>, <span>&lt;<a href="https://ieeexplore.ieee.org/xpl/articleDetails.jsp?arnumber=6871352">https://ieeexplore.ieee.org/xpl/articleDetails.jsp?arnumber=6871352</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="I-D.ietf-tcpm-accurate-ecn">[ACCECN]</dt>
        <dd>
<span class="refAuthor">Briscoe, B.</span>, <span class="refAuthor">Kühlewind, M.</span>, and <span class="refAuthor">R. Scheffenegger</span>, <span class="refTitle">"More Accurate ECN Feedback in TCP"</span>, <span class="refContent">Work in Progress</span>, <span class="seriesInfo">Internet-Draft, draft-ietf-tcpm-accurate-ecn-22</span>, <time class="refDate" datetime="2022-11-09">9 November 2022</time>, <span>&lt;<a href="https://datatracker.ietf.org/doc/html/draft-ietf-tcpm-accurate-ecn-22">https://datatracker.ietf.org/doc/html/draft-ietf-tcpm-accurate-ecn-22</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="Ahmed19">[Ahmed19]</dt>
        <dd>
<span class="refAuthor">Ahmed, A.S.</span>, <span class="refTitle">"Extending TCP for Low Round Trip Delay"</span>, <span class="refContent">Master's Thesis, University of Oslo</span>, <time class="refDate" datetime="2019-08">August 2019</time>, <span>&lt;<a href="https://www.duo.uio.no/handle/10852/70966">https://www.duo.uio.no/handle/10852/70966</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="Alizadeh-stability">[Alizadeh-stability]</dt>
        <dd>
<span class="refAuthor">Alizadeh, M.</span>, <span class="refAuthor">Javanmard, A.</span>, and <span class="refAuthor">B. Prabhakar</span>, <span class="refTitle">"Analysis of DCTCP: Stability, Convergence, and Fairness"</span>, <span class="refContent">SIGMETRICS '11: Proceedings of the ACM SIGMETRICS Joint International Conference on Measurement and Modeling of Computer Systems, pp. 73-84</span>, <span class="seriesInfo">DOI 10.1145/1993744.1993753</span>, <time class="refDate" datetime="2011-06">June 2011</time>, <span>&lt;<a href="https://dl.acm.org/doi/10.1145/1993744.1993753">https://dl.acm.org/doi/10.1145/1993744.1993753</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="ARED01">[ARED01]</dt>
        <dd>
<span class="refAuthor">Floyd, S.</span>, <span class="refAuthor">Gummadi, R.</span>, and <span class="refAuthor">S. Shenker</span>, <span class="refTitle">"Adaptive RED: An Algorithm for Increasing the Robustness of RED's Active Queue Management"</span>, <span class="refContent">ACIRI Technical Report 301</span>, <time class="refDate" datetime="2001-08">August 2001</time>, <span>&lt;<a href="https://www.icsi.berkeley.edu/icsi/node/2032">https://www.icsi.berkeley.edu/icsi/node/2032</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="I-D.cardwell-iccrg-bbr-congestion-control">[BBR-CC]</dt>
        <dd>
<span class="refAuthor">Cardwell, N.</span>, <span class="refAuthor">Cheng, Y.</span>, <span class="refAuthor">Hassas Yeganeh, S.</span>, <span class="refAuthor">Swett, I.</span>, and <span class="refAuthor">V. Jacobson</span>, <span class="refTitle">"BBR Congestion Control"</span>, <span class="refContent">Work in Progress</span>, <span class="seriesInfo">Internet-Draft, draft-cardwell-iccrg-bbr-congestion-control-02</span>, <time class="refDate" datetime="2022-03-07">7 March 2022</time>, <span>&lt;<a href="https://datatracker.ietf.org/doc/html/draft-cardwell-iccrg-bbr-congestion-control-02">https://datatracker.ietf.org/doc/html/draft-cardwell-iccrg-bbr-congestion-control-02</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="BBRv2">[BBRv2]</dt>
        <dd>
<span class="refTitle">"TCP BBR v2 Alpha/Preview Release"</span>, <span class="refContent">commit 17700ca</span>, <time class="refDate" datetime="2022-06">June 2022</time>, <span>&lt;<a href="https://github.com/google/bbr">https://github.com/google/bbr</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="Bufferbloat">[Bufferbloat]</dt>
        <dd>
<span class="refAuthor">The Bufferbloat community</span>, <span class="refTitle">"Bufferbloat"</span>, <span>&lt;<a href="https://bufferbloat.net/">https://bufferbloat.net/</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="COBALT">[COBALT]</dt>
        <dd>
<span class="refAuthor">Palmei, J.</span>, <span class="refAuthor">Gupta, S.</span>, <span class="refAuthor">Imputato, P.</span>, <span class="refAuthor">Morton, J.</span>, <span class="refAuthor">Tahiliani, M. P.</span>, <span class="refAuthor">Avallone, S.</span>, and <span class="refAuthor">D. Täht</span>, <span class="refTitle">"Design and Evaluation of COBALT Queue Discipline"</span>, <span class="refContent">IEEE International Symposium on Local and Metropolitan Area Networks (LANMAN)</span>, <span class="seriesInfo">DOI 10.1109/LANMAN.2019.8847054</span>, <time class="refDate" datetime="2019-07">July 2019</time>, <span>&lt;<a href="https://ieeexplore.ieee.org/abstract/document/8847054">https://ieeexplore.ieee.org/abstract/document/8847054</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="I-D.sridharan-tcpm-ctcp">[CTCP]</dt>
        <dd>
<span class="refAuthor">Sridharan, M.</span>, <span class="refAuthor">Tan, K.</span>, <span class="refAuthor">Bansal, D.</span>, and <span class="refAuthor">D. Thaler</span>, <span class="refTitle">"Compound TCP: A New TCP Congestion Control for High-Speed and Long Distance Networks"</span>, <span class="refContent">Work in Progress</span>, <span class="seriesInfo">Internet-Draft, draft-sridharan-tcpm-ctcp-02</span>, <time class="refDate" datetime="2008-11-03">3 November 2008</time>, <span>&lt;<a href="https://datatracker.ietf.org/doc/html/draft-sridharan-tcpm-ctcp-02">https://datatracker.ietf.org/doc/html/draft-sridharan-tcpm-ctcp-02</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="DCttH19">[DCttH19]</dt>
        <dd>
<span class="refAuthor">De Schepper, K.</span>, <span class="refAuthor">Bondarenko, O.</span>, <span class="refAuthor">Tilmans, O.</span>, and <span class="refAuthor">B. Briscoe</span>, <span class="refTitle">"'Data Centre to the Home': Ultra-Low Latency for All"</span>, <span class="refContent">Updated RITE project Technical Report</span>, <time class="refDate" datetime="2019-07">July 2019</time>, <span>&lt;<a href="https://bobbriscoe.net/projects/latency/dctth_journal_draft20190726.pdf">https://bobbriscoe.net/projects/latency/dctth_journal_draft20190726.pdf</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="I-D.briscoe-docsis-q-protection">[DOCSIS-QPROT]</dt>
        <dd>
<span class="refAuthor">Briscoe, B., Ed.</span> and <span class="refAuthor">G. White</span>, <span class="refTitle">"The DOCSIS® Queue Protection Algorithm to Preserve Low Latency"</span>, <span class="refContent">Work in Progress</span>, <span class="seriesInfo">Internet-Draft, draft-briscoe-docsis-q-protection-06</span>, <time class="refDate" datetime="2022-05-13">13 May 2022</time>, <span>&lt;<a href="https://datatracker.ietf.org/doc/html/draft-briscoe-docsis-q-protection-06">https://datatracker.ietf.org/doc/html/draft-briscoe-docsis-q-protection-06</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="DualPI2Linux">[DualPI2Linux]</dt>
        <dd>
<span class="refAuthor">Albisser, O.</span>, <span class="refAuthor">De Schepper, K.</span>, <span class="refAuthor">Briscoe, B.</span>, <span class="refAuthor">Tilmans, O.</span>, and <span class="refAuthor">H. Steen</span>, <span class="refTitle">"DUALPI2 - Low Latency, Low Loss and Scalable (L4S) AQM"</span>, <span class="refContent">Proceedings of Linux Netdev 0x13</span>, <time class="refDate" datetime="2019-03">March 2019</time>, <span>&lt;<a href="https://www.netdevconf.org/0x13/session.html?talk-DUALPI2-AQM">https://www.netdevconf.org/0x13/session.html?talk-DUALPI2-AQM</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="Dukkipati06">[Dukkipati06]</dt>
        <dd>
<span class="refAuthor">Dukkipati, N.</span> and <span class="refAuthor">N. McKeown</span>, <span class="refTitle">"Why Flow-Completion Time is the Right Metric for Congestion Control"</span>, <span class="refContent">ACM SIGCOMM Computer Communication Review, Volume 36, Issue 1, pp. 59-62</span>, <span class="seriesInfo">DOI 10.1145/1111322.1111336</span>, <time class="refDate" datetime="2006-01">January 2006</time>, <span>&lt;<a href="https://dl.acm.org/doi/10.1145/1111322.1111336">https://dl.acm.org/doi/10.1145/1111322.1111336</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="I-D.ietf-tcpm-generalized-ecn">[ECN++]</dt>
        <dd>
<span class="refAuthor">Bagnulo, M.</span> and <span class="refAuthor">B. Briscoe</span>, <span class="refTitle">"ECN++: Adding Explicit Congestion Notification (ECN) to TCP Control Packets"</span>, <span class="refContent">Work in Progress</span>, <span class="seriesInfo">Internet-Draft, draft-ietf-tcpm-generalized-ecn-10</span>, <time class="refDate" datetime="2022-07-27">27 July 2022</time>, <span>&lt;<a href="https://datatracker.ietf.org/doc/html/draft-ietf-tcpm-generalized-ecn-10">https://datatracker.ietf.org/doc/html/draft-ietf-tcpm-generalized-ecn-10</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="I-D.ietf-tsvwg-ecn-encap-guidelines">[ECN-ENCAP]</dt>
        <dd>
<span class="refAuthor">Briscoe, B.</span> and <span class="refAuthor">J. Kaippallimalil</span>, <span class="refTitle">"Guidelines for Adding Congestion Notification to Protocols that Encapsulate IP"</span>, <span class="refContent">Work in Progress</span>, <span class="seriesInfo">Internet-Draft, draft-ietf-tsvwg-ecn-encap-guidelines-17</span>, <time class="refDate" datetime="2022-07-11">11 July 2022</time>, <span>&lt;<a href="https://datatracker.ietf.org/doc/html/draft-ietf-tsvwg-ecn-encap-guidelines-17">https://datatracker.ietf.org/doc/html/draft-ietf-tsvwg-ecn-encap-guidelines-17</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="ecn-fallback">[ecn-fallback]</dt>
        <dd>
<span class="refAuthor">Briscoe, B.</span> and <span class="refAuthor">A. Ahmed</span>, <span class="refTitle">"TCP Prague Fall-back on Detection of a Classic ECN AQM"</span>, <span class="refContent">Technical Report: TR-BB-2019-002</span>, <span class="seriesInfo">DOI 10.48550/arXiv.1911.00710</span>, <time class="refDate" datetime="2021-02">February 2021</time>, <span>&lt;<a href="https://arxiv.org/abs/1911.00710">https://arxiv.org/abs/1911.00710</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="I-D.ietf-tsvwg-rfc6040update-shim">[ECN-SHIM]</dt>
        <dd>
<span class="refAuthor">Briscoe, B.</span>, <span class="refTitle">"Propagating Explicit Congestion Notification Across IP Tunnel Headers Separated by a Shim"</span>, <span class="refContent">Work in Progress</span>, <span class="seriesInfo">Internet-Draft, draft-ietf-tsvwg-rfc6040update-shim-15</span>, <time class="refDate" datetime="2022-07-11">11 July 2022</time>, <span>&lt;<a href="https://datatracker.ietf.org/doc/html/draft-ietf-tsvwg-rfc6040update-shim-15">https://datatracker.ietf.org/doc/html/draft-ietf-tsvwg-rfc6040update-shim-15</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="Heist21">[Heist21]</dt>
        <dd>
<span class="refTitle">"L4S Tests"</span>, <span class="refContent">commit e21cd91</span>, <time class="refDate" datetime="2021-08">August 2021</time>, <span>&lt;<a href="https://github.com/heistp/l4s-tests">https://github.com/heistp/l4s-tests</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="I-D.briscoe-tsvwg-l4s-diffserv">[L4S-DIFFSERV]</dt>
        <dd>
<span class="refAuthor">Briscoe, B.</span>, <span class="refTitle">"Interactions between Low Latency, Low Loss, Scalable Throughput (L4S) and Differentiated Services"</span>, <span class="refContent">Work in Progress</span>, <span class="seriesInfo">Internet-Draft, draft-briscoe-tsvwg-l4s-diffserv-02</span>, <time class="refDate" datetime="2018-11-01">1 November 2018</time>, <span>&lt;<a href="https://datatracker.ietf.org/doc/html/draft-briscoe-tsvwg-l4s-diffserv-02">https://datatracker.ietf.org/doc/html/draft-briscoe-tsvwg-l4s-diffserv-02</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="L4Seval22">[L4Seval22]</dt>
        <dd>
<span class="refAuthor">De Schepper, K.</span>, <span class="refAuthor">Albisser, O.</span>, <span class="refAuthor">Tilmans, O.</span>, and <span class="refAuthor">B. Briscoe</span>, <span class="refTitle">"Dual Queue Coupled AQM: Deployable Very Low Queuing Delay for All"</span>, <span class="refContent">Preprint submitted to IEEE/ACM Transactions on Networking</span>, <span class="seriesInfo">DOI 10.48550/arXiv.2209.01078</span>, <time class="refDate" datetime="2022-09">September 2022</time>, <span>&lt;<a href="https://arxiv.org/abs/2209.01078">https://arxiv.org/abs/2209.01078</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="I-D.ietf-tsvwg-l4sops">[L4SOPS]</dt>
        <dd>
<span class="refAuthor">White, G., Ed.</span>, <span class="refTitle">"Operational Guidance for Deployment of L4S in the Internet"</span>, <span class="refContent">Work in Progress</span>, <span class="seriesInfo">Internet-Draft, draft-ietf-tsvwg-l4sops-03</span>, <time class="refDate" datetime="2022-04-28">28 April 2022</time>, <span>&lt;<a href="https://datatracker.ietf.org/doc/html/draft-ietf-tsvwg-l4sops-03">https://datatracker.ietf.org/doc/html/draft-ietf-tsvwg-l4sops-03</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="LinuxPacedChirping">[LinuxPacedChirping]</dt>
        <dd>
<span class="refAuthor">Misund, J.</span> and <span class="refAuthor">B. Briscoe</span>, <span class="refTitle">"Paced Chirping - Rethinking TCP start-up"</span>, <span class="refContent">Proceedings of Linux Netdev 0x13</span>, <time class="refDate" datetime="2019-03">March 2019</time>, <span>&lt;<a href="https://legacy.netdevconf.info/0x13/session.html?talk-chirp">https://legacy.netdevconf.info/0x13/session.html?talk-chirp</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="I-D.ietf-tsvwg-nqb">[NQB-PHB]</dt>
        <dd>
<span class="refAuthor">White, G.</span> and <span class="refAuthor">T. Fossati</span>, <span class="refTitle">"A Non-Queue-Building Per-Hop Behavior (NQB PHB) for Differentiated Services"</span>, <span class="refContent">Work in Progress</span>, <span class="seriesInfo">Internet-Draft, draft-ietf-tsvwg-nqb-15</span>, <time class="refDate" datetime="2023-01-11">11 January 2023</time>, <span>&lt;<a href="https://datatracker.ietf.org/doc/html/draft-ietf-tsvwg-nqb-15">https://datatracker.ietf.org/doc/html/draft-ietf-tsvwg-nqb-15</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="PI2">[PI2]</dt>
        <dd>
<span class="refAuthor">De Schepper, K.</span>, <span class="refAuthor">Bondarenko, O.</span>, <span class="refAuthor">Tsang, I.</span>, and <span class="refAuthor">B. Briscoe</span>, <span class="refTitle">"PI^2: A Linearized AQM for both Classic and Scalable TCP"</span>, <span class="refContent">Proceedings of ACM CoNEXT 2016, pp. 105-119</span>, <span class="seriesInfo">DOI 10.1145/2999572.2999578</span>, <time class="refDate" datetime="2016-12">December 2016</time>, <span>&lt;<a href="https://dl.acm.org/citation.cfm?doid=2999572.2999578">https://dl.acm.org/citation.cfm?doid=2999572.2999578</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="I-D.briscoe-iccrg-prague-congestion-control">[PRAGUE-CC]</dt>
        <dd>
<span class="refAuthor">De Schepper, K.</span>, <span class="refAuthor">Tilmans, O.</span>, and <span class="refAuthor">B. Briscoe, Ed.</span>, <span class="refTitle">"Prague Congestion Control"</span>, <span class="refContent">Work in Progress</span>, <span class="seriesInfo">Internet-Draft, draft-briscoe-iccrg-prague-congestion-control-01</span>, <time class="refDate" datetime="2022-07-11">11 July 2022</time>, <span>&lt;<a href="https://datatracker.ietf.org/doc/html/draft-briscoe-iccrg-prague-congestion-control-01">https://datatracker.ietf.org/doc/html/draft-briscoe-iccrg-prague-congestion-control-01</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="PragueLinux">[PragueLinux]</dt>
        <dd>
<span class="refAuthor">Briscoe, B.</span>, <span class="refAuthor">De Schepper, K.</span>, <span class="refAuthor">Albisser, O.</span>, <span class="refAuthor">Misund, J.</span>, <span class="refAuthor">Tilmans, O.</span>, <span class="refAuthor">Kühlewind, M.</span>, and <span class="refAuthor">A. Ahmed</span>, <span class="refTitle">"Implementing the 'TCP Prague' Requirements for L4S"</span>, <span class="refContent">Proceedings of Linux Netdev 0x13</span>, <time class="refDate" datetime="2019-03">March 2019</time>, <span>&lt;<a href="https://www.netdevconf.org/0x13/session.html?talk-tcp-prague-l4s">https://www.netdevconf.org/0x13/session.html?talk-tcp-prague-l4s</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="QV">[QV]</dt>
        <dd>
<span class="refAuthor">Briscoe, B.</span> and <span class="refAuthor">P. Hurtig</span>, <span class="refTitle">"Report on Prototype Development and Evaluation of Network and Interaction Techniques"</span>, <span class="refContent">RITE Technical Report, Deliverable 2.3, Appendix C.2: "Up to Speed with Queue View"</span>, <time class="refDate" datetime="2015-09">September 2015</time>, <span>&lt;<a href="https://riteproject.files.wordpress.com/2015/12/rite-deliverable-2-3.pdf">https://riteproject.files.wordpress.com/2015/12/rite-deliverable-2-3.pdf</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="I-D.mathis-iccrg-relentless-tcp">[RELENTLESS]</dt>
        <dd>
<span class="refAuthor">Mathis, M.</span>, <span class="refTitle">"Relentless Congestion Control"</span>, <span class="refContent">Work in Progress</span>, <span class="seriesInfo">Internet-Draft, draft-mathis-iccrg-relentless-tcp-00</span>, <time class="refDate" datetime="2009-03-04">4 March 2009</time>, <span>&lt;<a href="https://datatracker.ietf.org/doc/html/draft-mathis-iccrg-relentless-tcp-00">https://datatracker.ietf.org/doc/html/draft-mathis-iccrg-relentless-tcp-00</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC2474">[RFC2474]</dt>
        <dd>
<span class="refAuthor">Nichols, K.</span>, <span class="refAuthor">Blake, S.</span>, <span class="refAuthor">Baker, F.</span>, and <span class="refAuthor">D. Black</span>, <span class="refTitle">"Definition of the Differentiated Services Field (DS Field) in the IPv4 and IPv6 Headers"</span>, <span class="seriesInfo">RFC 2474</span>, <span class="seriesInfo">DOI 10.17487/RFC2474</span>, <time class="refDate" datetime="1998-12">December 1998</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc2474">https://www.rfc-editor.org/info/rfc2474</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC3246">[RFC3246]</dt>
        <dd>
<span class="refAuthor">Davie, B.</span>, <span class="refAuthor">Charny, A.</span>, <span class="refAuthor">Bennet, J.C.R.</span>, <span class="refAuthor">Benson, K.</span>, <span class="refAuthor">Le Boudec, J.Y.</span>, <span class="refAuthor">Courtney, W.</span>, <span class="refAuthor">Davari, S.</span>, <span class="refAuthor">Firoiu, V.</span>, and <span class="refAuthor">D. Stiliadis</span>, <span class="refTitle">"An Expedited Forwarding PHB (Per-Hop Behavior)"</span>, <span class="seriesInfo">RFC 3246</span>, <span class="seriesInfo">DOI 10.17487/RFC3246</span>, <time class="refDate" datetime="2002-03">March 2002</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc3246">https://www.rfc-editor.org/info/rfc3246</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC3540">[RFC3540]</dt>
        <dd>
<span class="refAuthor">Spring, N.</span>, <span class="refAuthor">Wetherall, D.</span>, and <span class="refAuthor">D. Ely</span>, <span class="refTitle">"Robust Explicit Congestion Notification (ECN) Signaling with Nonces"</span>, <span class="seriesInfo">RFC 3540</span>, <span class="seriesInfo">DOI 10.17487/RFC3540</span>, <time class="refDate" datetime="2003-06">June 2003</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc3540">https://www.rfc-editor.org/info/rfc3540</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC3649">[RFC3649]</dt>
        <dd>
<span class="refAuthor">Floyd, S.</span>, <span class="refTitle">"HighSpeed TCP for Large Congestion Windows"</span>, <span class="seriesInfo">RFC 3649</span>, <span class="seriesInfo">DOI 10.17487/RFC3649</span>, <time class="refDate" datetime="2003-12">December 2003</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc3649">https://www.rfc-editor.org/info/rfc3649</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC4301">[RFC4301]</dt>
        <dd>
<span class="refAuthor">Kent, S.</span> and <span class="refAuthor">K. Seo</span>, <span class="refTitle">"Security Architecture for the Internet Protocol"</span>, <span class="seriesInfo">RFC 4301</span>, <span class="seriesInfo">DOI 10.17487/RFC4301</span>, <time class="refDate" datetime="2005-12">December 2005</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc4301">https://www.rfc-editor.org/info/rfc4301</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC4302">[RFC4302]</dt>
        <dd>
<span class="refAuthor">Kent, S.</span>, <span class="refTitle">"IP Authentication Header"</span>, <span class="seriesInfo">RFC 4302</span>, <span class="seriesInfo">DOI 10.17487/RFC4302</span>, <time class="refDate" datetime="2005-12">December 2005</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc4302">https://www.rfc-editor.org/info/rfc4302</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC4303">[RFC4303]</dt>
        <dd>
<span class="refAuthor">Kent, S.</span>, <span class="refTitle">"IP Encapsulating Security Payload (ESP)"</span>, <span class="seriesInfo">RFC 4303</span>, <span class="seriesInfo">DOI 10.17487/RFC4303</span>, <time class="refDate" datetime="2005-12">December 2005</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc4303">https://www.rfc-editor.org/info/rfc4303</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC4340">[RFC4340]</dt>
        <dd>
<span class="refAuthor">Kohler, E.</span>, <span class="refAuthor">Handley, M.</span>, and <span class="refAuthor">S. Floyd</span>, <span class="refTitle">"Datagram Congestion Control Protocol (DCCP)"</span>, <span class="seriesInfo">RFC 4340</span>, <span class="seriesInfo">DOI 10.17487/RFC4340</span>, <time class="refDate" datetime="2006-03">March 2006</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc4340">https://www.rfc-editor.org/info/rfc4340</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC4341">[RFC4341]</dt>
        <dd>
<span class="refAuthor">Floyd, S.</span> and <span class="refAuthor">E. Kohler</span>, <span class="refTitle">"Profile for Datagram Congestion Control Protocol (DCCP) Congestion Control ID 2: TCP-like Congestion Control"</span>, <span class="seriesInfo">RFC 4341</span>, <span class="seriesInfo">DOI 10.17487/RFC4341</span>, <time class="refDate" datetime="2006-03">March 2006</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc4341">https://www.rfc-editor.org/info/rfc4341</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC4342">[RFC4342]</dt>
        <dd>
<span class="refAuthor">Floyd, S.</span>, <span class="refAuthor">Kohler, E.</span>, and <span class="refAuthor">J. Padhye</span>, <span class="refTitle">"Profile for Datagram Congestion Control Protocol (DCCP) Congestion Control ID 3: TCP-Friendly Rate Control (TFRC)"</span>, <span class="seriesInfo">RFC 4342</span>, <span class="seriesInfo">DOI 10.17487/RFC4342</span>, <time class="refDate" datetime="2006-03">March 2006</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc4342">https://www.rfc-editor.org/info/rfc4342</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC4960">[RFC4960]</dt>
        <dd>
<span class="refAuthor">Stewart, R., Ed.</span>, <span class="refTitle">"Stream Control Transmission Protocol"</span>, <span class="seriesInfo">RFC 4960</span>, <span class="seriesInfo">DOI 10.17487/RFC4960</span>, <time class="refDate" datetime="2007-09">September 2007</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc4960">https://www.rfc-editor.org/info/rfc4960</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC5033">[RFC5033]</dt>
        <dd>
<span class="refAuthor">Floyd, S.</span> and <span class="refAuthor">M. Allman</span>, <span class="refTitle">"Specifying New Congestion Control Algorithms"</span>, <span class="seriesInfo">BCP 133</span>, <span class="seriesInfo">RFC 5033</span>, <span class="seriesInfo">DOI 10.17487/RFC5033</span>, <time class="refDate" datetime="2007-08">August 2007</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc5033">https://www.rfc-editor.org/info/rfc5033</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC5129">[RFC5129]</dt>
        <dd>
<span class="refAuthor">Davie, B.</span>, <span class="refAuthor">Briscoe, B.</span>, and <span class="refAuthor">J. Tay</span>, <span class="refTitle">"Explicit Congestion Marking in MPLS"</span>, <span class="seriesInfo">RFC 5129</span>, <span class="seriesInfo">DOI 10.17487/RFC5129</span>, <time class="refDate" datetime="2008-01">January 2008</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc5129">https://www.rfc-editor.org/info/rfc5129</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC5348">[RFC5348]</dt>
        <dd>
<span class="refAuthor">Floyd, S.</span>, <span class="refAuthor">Handley, M.</span>, <span class="refAuthor">Padhye, J.</span>, and <span class="refAuthor">J. Widmer</span>, <span class="refTitle">"TCP Friendly Rate Control (TFRC): Protocol Specification"</span>, <span class="seriesInfo">RFC 5348</span>, <span class="seriesInfo">DOI 10.17487/RFC5348</span>, <time class="refDate" datetime="2008-09">September 2008</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc5348">https://www.rfc-editor.org/info/rfc5348</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC5562">[RFC5562]</dt>
        <dd>
<span class="refAuthor">Kuzmanovic, A.</span>, <span class="refAuthor">Mondal, A.</span>, <span class="refAuthor">Floyd, S.</span>, and <span class="refAuthor">K. Ramakrishnan</span>, <span class="refTitle">"Adding Explicit Congestion Notification (ECN) Capability to TCP's SYN/ACK Packets"</span>, <span class="seriesInfo">RFC 5562</span>, <span class="seriesInfo">DOI 10.17487/RFC5562</span>, <time class="refDate" datetime="2009-06">June 2009</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc5562">https://www.rfc-editor.org/info/rfc5562</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC5622">[RFC5622]</dt>
        <dd>
<span class="refAuthor">Floyd, S.</span> and <span class="refAuthor">E. Kohler</span>, <span class="refTitle">"Profile for Datagram Congestion Control Protocol (DCCP) Congestion ID 4: TCP-Friendly Rate Control for Small Packets (TFRC-SP)"</span>, <span class="seriesInfo">RFC 5622</span>, <span class="seriesInfo">DOI 10.17487/RFC5622</span>, <time class="refDate" datetime="2009-08">August 2009</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc5622">https://www.rfc-editor.org/info/rfc5622</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC5681">[RFC5681]</dt>
        <dd>
<span class="refAuthor">Allman, M.</span>, <span class="refAuthor">Paxson, V.</span>, and <span class="refAuthor">E. Blanton</span>, <span class="refTitle">"TCP Congestion Control"</span>, <span class="seriesInfo">RFC 5681</span>, <span class="seriesInfo">DOI 10.17487/RFC5681</span>, <time class="refDate" datetime="2009-09">September 2009</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc5681">https://www.rfc-editor.org/info/rfc5681</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC5706">[RFC5706]</dt>
        <dd>
<span class="refAuthor">Harrington, D.</span>, <span class="refTitle">"Guidelines for Considering Operations and Management of New Protocols and Protocol Extensions"</span>, <span class="seriesInfo">RFC 5706</span>, <span class="seriesInfo">DOI 10.17487/RFC5706</span>, <time class="refDate" datetime="2009-11">November 2009</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc5706">https://www.rfc-editor.org/info/rfc5706</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC5865">[RFC5865]</dt>
        <dd>
<span class="refAuthor">Baker, F.</span>, <span class="refAuthor">Polk, J.</span>, and <span class="refAuthor">M. Dolly</span>, <span class="refTitle">"A Differentiated Services Code Point (DSCP) for Capacity-Admitted Traffic"</span>, <span class="seriesInfo">RFC 5865</span>, <span class="seriesInfo">DOI 10.17487/RFC5865</span>, <time class="refDate" datetime="2010-05">May 2010</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc5865">https://www.rfc-editor.org/info/rfc5865</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC5925">[RFC5925]</dt>
        <dd>
<span class="refAuthor">Touch, J.</span>, <span class="refAuthor">Mankin, A.</span>, and <span class="refAuthor">R. Bonica</span>, <span class="refTitle">"The TCP Authentication Option"</span>, <span class="seriesInfo">RFC 5925</span>, <span class="seriesInfo">DOI 10.17487/RFC5925</span>, <time class="refDate" datetime="2010-06">June 2010</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc5925">https://www.rfc-editor.org/info/rfc5925</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC6040">[RFC6040]</dt>
        <dd>
<span class="refAuthor">Briscoe, B.</span>, <span class="refTitle">"Tunnelling of Explicit Congestion Notification"</span>, <span class="seriesInfo">RFC 6040</span>, <span class="seriesInfo">DOI 10.17487/RFC6040</span>, <time class="refDate" datetime="2010-11">November 2010</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc6040">https://www.rfc-editor.org/info/rfc6040</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC6077">[RFC6077]</dt>
        <dd>
<span class="refAuthor">Papadimitriou, D., Ed.</span>, <span class="refAuthor">Welzl, M.</span>, <span class="refAuthor">Scharf, M.</span>, and <span class="refAuthor">B. Briscoe</span>, <span class="refTitle">"Open Research Issues in Internet Congestion Control"</span>, <span class="seriesInfo">RFC 6077</span>, <span class="seriesInfo">DOI 10.17487/RFC6077</span>, <time class="refDate" datetime="2011-02">February 2011</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc6077">https://www.rfc-editor.org/info/rfc6077</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC6660">[RFC6660]</dt>
        <dd>
<span class="refAuthor">Briscoe, B.</span>, <span class="refAuthor">Moncaster, T.</span>, and <span class="refAuthor">M. Menth</span>, <span class="refTitle">"Encoding Three Pre-Congestion Notification (PCN) States in the IP Header Using a Single Diffserv Codepoint (DSCP)"</span>, <span class="seriesInfo">RFC 6660</span>, <span class="seriesInfo">DOI 10.17487/RFC6660</span>, <time class="refDate" datetime="2012-07">July 2012</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc6660">https://www.rfc-editor.org/info/rfc6660</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC6675">[RFC6675]</dt>
        <dd>
<span class="refAuthor">Blanton, E.</span>, <span class="refAuthor">Allman, M.</span>, <span class="refAuthor">Wang, L.</span>, <span class="refAuthor">Jarvinen, I.</span>, <span class="refAuthor">Kojo, M.</span>, and <span class="refAuthor">Y. Nishida</span>, <span class="refTitle">"A Conservative Loss Recovery Algorithm Based on Selective Acknowledgment (SACK) for TCP"</span>, <span class="seriesInfo">RFC 6675</span>, <span class="seriesInfo">DOI 10.17487/RFC6675</span>, <time class="refDate" datetime="2012-08">August 2012</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc6675">https://www.rfc-editor.org/info/rfc6675</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC7560">[RFC7560]</dt>
        <dd>
<span class="refAuthor">Kuehlewind, M., Ed.</span>, <span class="refAuthor">Scheffenegger, R.</span>, and <span class="refAuthor">B. Briscoe</span>, <span class="refTitle">"Problem Statement and Requirements for Increased Accuracy in Explicit Congestion Notification (ECN) Feedback"</span>, <span class="seriesInfo">RFC 7560</span>, <span class="seriesInfo">DOI 10.17487/RFC7560</span>, <time class="refDate" datetime="2015-08">August 2015</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc7560">https://www.rfc-editor.org/info/rfc7560</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC7567">[RFC7567]</dt>
        <dd>
<span class="refAuthor">Baker, F., Ed.</span> and <span class="refAuthor">G. Fairhurst, Ed.</span>, <span class="refTitle">"IETF Recommendations Regarding Active Queue Management"</span>, <span class="seriesInfo">BCP 197</span>, <span class="seriesInfo">RFC 7567</span>, <span class="seriesInfo">DOI 10.17487/RFC7567</span>, <time class="refDate" datetime="2015-07">July 2015</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc7567">https://www.rfc-editor.org/info/rfc7567</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC7713">[RFC7713]</dt>
        <dd>
<span class="refAuthor">Mathis, M.</span> and <span class="refAuthor">B. Briscoe</span>, <span class="refTitle">"Congestion Exposure (ConEx) Concepts, Abstract Mechanism, and Requirements"</span>, <span class="seriesInfo">RFC 7713</span>, <span class="seriesInfo">DOI 10.17487/RFC7713</span>, <time class="refDate" datetime="2015-12">December 2015</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc7713">https://www.rfc-editor.org/info/rfc7713</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC8033">[RFC8033]</dt>
        <dd>
<span class="refAuthor">Pan, R.</span>, <span class="refAuthor">Natarajan, P.</span>, <span class="refAuthor">Baker, F.</span>, and <span class="refAuthor">G. White</span>, <span class="refTitle">"Proportional Integral Controller Enhanced (PIE): A Lightweight Control Scheme to Address the Bufferbloat Problem"</span>, <span class="seriesInfo">RFC 8033</span>, <span class="seriesInfo">DOI 10.17487/RFC8033</span>, <time class="refDate" datetime="2017-02">February 2017</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc8033">https://www.rfc-editor.org/info/rfc8033</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC8083">[RFC8083]</dt>
        <dd>
<span class="refAuthor">Perkins, C.</span> and <span class="refAuthor">V. Singh</span>, <span class="refTitle">"Multimedia Congestion Control: Circuit Breakers for Unicast RTP Sessions"</span>, <span class="seriesInfo">RFC 8083</span>, <span class="seriesInfo">DOI 10.17487/RFC8083</span>, <time class="refDate" datetime="2017-03">March 2017</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc8083">https://www.rfc-editor.org/info/rfc8083</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC8085">[RFC8085]</dt>
        <dd>
<span class="refAuthor">Eggert, L.</span>, <span class="refAuthor">Fairhurst, G.</span>, and <span class="refAuthor">G. Shepherd</span>, <span class="refTitle">"UDP Usage Guidelines"</span>, <span class="seriesInfo">BCP 145</span>, <span class="seriesInfo">RFC 8085</span>, <span class="seriesInfo">DOI 10.17487/RFC8085</span>, <time class="refDate" datetime="2017-03">March 2017</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc8085">https://www.rfc-editor.org/info/rfc8085</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC8174">[RFC8174]</dt>
        <dd>
<span class="refAuthor">Leiba, B.</span>, <span class="refTitle">"Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words"</span>, <span class="seriesInfo">BCP 14</span>, <span class="seriesInfo">RFC 8174</span>, <span class="seriesInfo">DOI 10.17487/RFC8174</span>, <time class="refDate" datetime="2017-05">May 2017</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc8174">https://www.rfc-editor.org/info/rfc8174</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC8257">[RFC8257]</dt>
        <dd>
<span class="refAuthor">Bensley, S.</span>, <span class="refAuthor">Thaler, D.</span>, <span class="refAuthor">Balasubramanian, P.</span>, <span class="refAuthor">Eggert, L.</span>, and <span class="refAuthor">G. Judd</span>, <span class="refTitle">"Data Center TCP (DCTCP): TCP Congestion Control for Data Centers"</span>, <span class="seriesInfo">RFC 8257</span>, <span class="seriesInfo">DOI 10.17487/RFC8257</span>, <time class="refDate" datetime="2017-10">October 2017</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc8257">https://www.rfc-editor.org/info/rfc8257</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC8290">[RFC8290]</dt>
        <dd>
<span class="refAuthor">Hoeiland-Joergensen, T.</span>, <span class="refAuthor">McKenney, P.</span>, <span class="refAuthor">Taht, D.</span>, <span class="refAuthor">Gettys, J.</span>, and <span class="refAuthor">E. Dumazet</span>, <span class="refTitle">"The Flow Queue CoDel Packet Scheduler and Active Queue Management Algorithm"</span>, <span class="seriesInfo">RFC 8290</span>, <span class="seriesInfo">DOI 10.17487/RFC8290</span>, <time class="refDate" datetime="2018-01">January 2018</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc8290">https://www.rfc-editor.org/info/rfc8290</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC8298">[RFC8298]</dt>
        <dd>
<span class="refAuthor">Johansson, I.</span> and <span class="refAuthor">Z. Sarker</span>, <span class="refTitle">"Self-Clocked Rate Adaptation for Multimedia"</span>, <span class="seriesInfo">RFC 8298</span>, <span class="seriesInfo">DOI 10.17487/RFC8298</span>, <time class="refDate" datetime="2017-12">December 2017</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc8298">https://www.rfc-editor.org/info/rfc8298</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC8311">[RFC8311]</dt>
        <dd>
<span class="refAuthor">Black, D.</span>, <span class="refTitle">"Relaxing Restrictions on Explicit Congestion Notification (ECN) Experimentation"</span>, <span class="seriesInfo">RFC 8311</span>, <span class="seriesInfo">DOI 10.17487/RFC8311</span>, <time class="refDate" datetime="2018-01">January 2018</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc8311">https://www.rfc-editor.org/info/rfc8311</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC8312">[RFC8312]</dt>
        <dd>
<span class="refAuthor">Rhee, I.</span>, <span class="refAuthor">Xu, L.</span>, <span class="refAuthor">Ha, S.</span>, <span class="refAuthor">Zimmermann, A.</span>, <span class="refAuthor">Eggert, L.</span>, and <span class="refAuthor">R. Scheffenegger</span>, <span class="refTitle">"CUBIC for Fast Long-Distance Networks"</span>, <span class="seriesInfo">RFC 8312</span>, <span class="seriesInfo">DOI 10.17487/RFC8312</span>, <time class="refDate" datetime="2018-02">February 2018</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc8312">https://www.rfc-editor.org/info/rfc8312</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC8511">[RFC8511]</dt>
        <dd>
<span class="refAuthor">Khademi, N.</span>, <span class="refAuthor">Welzl, M.</span>, <span class="refAuthor">Armitage, G.</span>, and <span class="refAuthor">G. Fairhurst</span>, <span class="refTitle">"TCP Alternative Backoff with ECN (ABE)"</span>, <span class="seriesInfo">RFC 8511</span>, <span class="seriesInfo">DOI 10.17487/RFC8511</span>, <time class="refDate" datetime="2018-12">December 2018</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc8511">https://www.rfc-editor.org/info/rfc8511</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC8888">[RFC8888]</dt>
        <dd>
<span class="refAuthor">Sarker, Z.</span>, <span class="refAuthor">Perkins, C.</span>, <span class="refAuthor">Singh, V.</span>, and <span class="refAuthor">M. Ramalho</span>, <span class="refTitle">"RTP Control Protocol (RTCP) Feedback for Congestion Control"</span>, <span class="seriesInfo">RFC 8888</span>, <span class="seriesInfo">DOI 10.17487/RFC8888</span>, <time class="refDate" datetime="2021-01">January 2021</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc8888">https://www.rfc-editor.org/info/rfc8888</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC8985">[RFC8985]</dt>
        <dd>
<span class="refAuthor">Cheng, Y.</span>, <span class="refAuthor">Cardwell, N.</span>, <span class="refAuthor">Dukkipati, N.</span>, and <span class="refAuthor">P. Jha</span>, <span class="refTitle">"The RACK-TLP Loss Detection Algorithm for TCP"</span>, <span class="seriesInfo">RFC 8985</span>, <span class="seriesInfo">DOI 10.17487/RFC8985</span>, <time class="refDate" datetime="2021-02">February 2021</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc8985">https://www.rfc-editor.org/info/rfc8985</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC9000">[RFC9000]</dt>
        <dd>
<span class="refAuthor">Iyengar, J., Ed.</span> and <span class="refAuthor">M. Thomson, Ed.</span>, <span class="refTitle">"QUIC: A UDP-Based Multiplexed and Secure Transport"</span>, <span class="seriesInfo">RFC 9000</span>, <span class="seriesInfo">DOI 10.17487/RFC9000</span>, <time class="refDate" datetime="2021-05">May 2021</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc9000">https://www.rfc-editor.org/info/rfc9000</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC9001">[RFC9001]</dt>
        <dd>
<span class="refAuthor">Thomson, M., Ed.</span> and <span class="refAuthor">S. Turner, Ed.</span>, <span class="refTitle">"Using TLS to Secure QUIC"</span>, <span class="seriesInfo">RFC 9001</span>, <span class="seriesInfo">DOI 10.17487/RFC9001</span>, <time class="refDate" datetime="2021-05">May 2021</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc9001">https://www.rfc-editor.org/info/rfc9001</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC9147">[RFC9147]</dt>
        <dd>
<span class="refAuthor">Rescorla, E.</span>, <span class="refAuthor">Tschofenig, H.</span>, and <span class="refAuthor">N. Modadugu</span>, <span class="refTitle">"The Datagram Transport Layer Security (DTLS) Protocol Version 1.3"</span>, <span class="seriesInfo">RFC 9147</span>, <span class="seriesInfo">DOI 10.17487/RFC9147</span>, <time class="refDate" datetime="2022-04">April 2022</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc9147">https://www.rfc-editor.org/info/rfc9147</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC9330">[RFC9330]</dt>
        <dd>
<span class="refAuthor">Briscoe, B., Ed.</span>, <span class="refAuthor">De Schepper, K.</span>, <span class="refAuthor">Bagnulo, M.</span>, and <span class="refAuthor">G. White</span>, <span class="refTitle">"Low Latency, Low Loss, and Scalable Throughput (L4S) Internet Service: Architecture"</span>, <span class="seriesInfo">RFC 9330</span>, <span class="seriesInfo">DOI 10.17487/RFC9330</span>, <time class="refDate" datetime="2023-01">January 2023</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc9330">https://www.rfc-editor.org/info/rfc9330</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC9332">[RFC9332]</dt>
        <dd>
<span class="refAuthor">De Schepper, K.</span>, <span class="refAuthor">Briscoe, B., Ed.</span>, and <span class="refAuthor">G. White</span>, <span class="refTitle">"Dual-Queue Coupled Active Queue Management (AQM) for Low Latency, Low Loss, and Scalable Throughput (L4S)"</span>, <span class="seriesInfo">RFC 9332</span>, <span class="seriesInfo">DOI 10.17487/RFC9332</span>, <time class="refDate" datetime="2023-01">January 2023</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc9332">https://www.rfc-editor.org/info/rfc9332</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="Savage-TCP">[Savage-TCP]</dt>
        <dd>
<span class="refAuthor">Savage, S.</span>, <span class="refAuthor">Cardwell, N.</span>, <span class="refAuthor">Wetherall, D.</span>, and <span class="refAuthor">T. Anderson</span>, <span class="refTitle">"TCP Congestion Control with a Misbehaving Receiver"</span>, <span class="refContent">ACM SIGCOMM Computer Communication Review, Volume 29, Issue 5, pp. 71–78</span>, <span class="seriesInfo">DOI 10.1145/505696.505704</span>, <time class="refDate" datetime="1999-10">October 1999</time>, <span>&lt;<a href="https://dl.acm.org/doi/abs/10.1145/505696.505704">https://dl.acm.org/doi/abs/10.1145/505696.505704</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="SCReAM-L4S">[SCReAM-L4S]</dt>
        <dd>
<span class="refTitle">"SCReAM"</span>, <span class="refContent">commit 140e292</span>, <time class="refDate" datetime="2022-11">November 2022</time>, <span>&lt;<a href="https://github.com/EricssonResearch/scream">https://github.com/EricssonResearch/scream</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="I-D.stewart-tsvwg-sctpecn">[SCTP-ECN]</dt>
        <dd>
<span class="refAuthor">Stewart, R.</span>, <span class="refAuthor">Tüxen, M.</span>, and <span class="refAuthor">X. Dong</span>, <span class="refTitle">"ECN for Stream Control Transmission Protocol (SCTP)"</span>, <span class="refContent">Work in Progress</span>, <span class="seriesInfo">Internet-Draft, draft-stewart-tsvwg-sctpecn-05</span>, <time class="refDate" datetime="2014-01-15">15 January 2014</time>, <span>&lt;<a href="https://datatracker.ietf.org/doc/html/draft-stewart-tsvwg-sctpecn-05">https://datatracker.ietf.org/doc/html/draft-stewart-tsvwg-sctpecn-05</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="sub-mss-prob">[sub-mss-prob]</dt>
        <dd>
<span class="refAuthor">Briscoe, B.</span> and <span class="refAuthor">K. De Schepper</span>, <span class="refTitle">"Scaling TCP's Congestion Window for Small Round Trip Times"</span>, <span class="refContent">BT Technical Report: TR-TUB8-2015-002</span>, <span class="seriesInfo">DOI 10.48550/arXiv.1904.07598</span>, <time class="refDate" datetime="2015-05">May 2015</time>, <span>&lt;<a href="https://arxiv.org/abs/1904.07598">https://arxiv.org/abs/1904.07598</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="TCP-CA">[TCP-CA]</dt>
        <dd>
<span class="refAuthor">Jacobson, V.</span> and <span class="refAuthor">M. J. Karels</span>, <span class="refTitle">"Congestion Avoidance and Control"</span>, <span class="refContent">Laurence Berkeley Labs Technical Report</span>, <time class="refDate" datetime="1988-11">November 1988</time>, <span>&lt;<a href="https://ee.lbl.gov/papers/congavoid.pdf">https://ee.lbl.gov/papers/congavoid.pdf</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="TCPPrague">[TCPPrague]</dt>
        <dd>
<span class="refAuthor">Briscoe, B.</span>, <span class="refTitle">"Notes: DCTCP evolution 'bar BoF': Tue 21 Jul 2015, 17:40, Prague"</span>, <span class="refContent">message to the tcpPrague mailing list</span>, <time class="refDate" datetime="2015-07">July 2015</time>, <span>&lt;<a href="https://www.ietf.org/mail-archive/web/tcpprague/current/msg00001.html">https://www.ietf.org/mail-archive/web/tcpprague/current/msg00001.html</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="I-D.ietf-trill-ecn-support">[TRILL-ECN-SUPPORT]</dt>
        <dd>
<span class="refAuthor">Eastlake 3rd, D.</span> and <span class="refAuthor">B. Briscoe</span>, <span class="refTitle">"TRILL (TRansparent Interconnection of Lots of Links): ECN (Explicit Congestion Notification) Support"</span>, <span class="refContent">Work in Progress</span>, <span class="seriesInfo">Internet-Draft, draft-ietf-trill-ecn-support-07</span>, <time class="refDate" datetime="2018-02-25">25 February 2018</time>, <span>&lt;<a href="https://datatracker.ietf.org/doc/html/draft-ietf-trill-ecn-support-07">https://datatracker.ietf.org/doc/html/draft-ietf-trill-ecn-support-07</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="VCP">[VCP]</dt>
      <dd>
<span class="refAuthor">Xia, Y.</span>, <span class="refAuthor">Subramanian, L.</span>, <span class="refAuthor">Stoica, I.</span>, and <span class="refAuthor">S. Kalyanaraman</span>, <span class="refTitle">"One more bit is enough"</span>, <span class="refContent">SIGCOMM '05: Proceedings of the 2005 conference on Applications, technologies, architectures, and protocols for computer communications, pp. 37-48</span>, <span class="seriesInfo">DOI 10.1145/1080091.1080098</span>, <time class="refDate" datetime="2005-08">August 2005</time>, <span>&lt;<a href="https://doi.acm.org/10.1145/1080091.1080098">https://doi.acm.org/10.1145/1080091.1080098</a>&gt;</span>. </dd>
<dd class="break"></dd>
</dl>
</section>
</section>
<div id="l4sps_tcp-prague-reqs">
<section id="appendix-A">
      <h2 id="name-rationale-for-the-prague-l4">
<a class="section-number selfRef" href="#appendix-A">Appendix A. </a><a class="section-name selfRef" href="#name-rationale-for-the-prague-l4">Rationale for the 'Prague L4S Requirements'</a>
      </h2>
<p id="appendix-A-1">This appendix is informative, not normative. It gives a list of
      modifications to current Scalable congestion controls so that they can
      be deployed over the public Internet and coexist safely with existing
      traffic. The list complements the normative requirements in <a class="auto internal xref" href="#l4sid_transport_req">Section 4</a> that a sender has to comply with before
      it can set the L4S identifier in packets it sends into the Internet. As
      well as rationale for safety improvements (the requirements in <a class="auto internal xref" href="#l4sid_transport_req">Section 4</a>), this appendix also includes preferable
      performance improvements (optimizations).<a class="pilcrow" href="#appendix-A-1">¶</a></p>
<p id="appendix-A-2">The requirements and recommendations in <a class="auto internal xref" href="#l4sid_transport_req">Section 4</a> have become known as the 'Prague L4S
      Requirements', because they were originally identified at an ad hoc
      meeting during IETF 94 in Prague <span>[<a class="cite xref" href="#TCPPrague">TCPPrague</a>]</span>. They
      were originally called the 'TCP Prague Requirements', but they are not
      solely applicable to TCP, so the name and wording has been generalized
      for all transport protocols, and the name 'TCP Prague' is now used for a
      specific implementation of the requirements.<a class="pilcrow" href="#appendix-A-2">¶</a></p>
<p id="appendix-A-3">At the time of writing, DCTCP <span>[<a class="cite xref" href="#RFC8257">RFC8257</a>]</span> is the
      most widely used Scalable transport protocol. In its current form, DCTCP
      is specified to be deployable only in controlled environments. Deploying
      it in the public Internet would lead to a number of issues, from both
      the safety and the performance perspective. The modifications and
      additional mechanisms listed in this section will be necessary for its
      deployment over the global Internet. Where an example is needed, DCTCP
      is used as a base, but the requirements in <a class="auto internal xref" href="#l4sid_transport_req">Section 4</a> apply equally to other Scalable
      congestion controls, covering adaptive real-time media, etc., not just
      capacity-seeking behaviours.<a class="pilcrow" href="#appendix-A-3">¶</a></p>
<section id="appendix-A.1">
        <h3 id="name-rationale-for-the-requireme">
<a class="section-number selfRef" href="#appendix-A.1">A.1. </a><a class="section-name selfRef" href="#name-rationale-for-the-requireme">Rationale for the Requirements for Scalable Transport Protocols</a>
        </h3>
<section id="appendix-A.1.1">
          <h4 id="name-use-of-l4s-packet-identifie">
<a class="section-number selfRef" href="#appendix-A.1.1">A.1.1. </a><a class="section-name selfRef" href="#name-use-of-l4s-packet-identifie">Use of L4S Packet Identifier</a>
          </h4>
<p id="appendix-A.1.1-1">Description: A Scalable congestion control needs to distinguish
          the packets it sends from those sent by Classic congestion controls
          (see the precise normative requirement wording in <a class="auto internal xref" href="#l4sid_codepoint">Section 4.1</a>).<a class="pilcrow" href="#appendix-A.1.1-1">¶</a></p>
<p id="appendix-A.1.1-2">Motivation: It needs to be possible for a network node to
          classify L4S packets without flow state into a queue that applies an
          L4S ECN-marking behaviour and isolates L4S packets from the queuing
          delay of Classic packets.<a class="pilcrow" href="#appendix-A.1.1-2">¶</a></p>
</section>
<section id="appendix-A.1.2">
          <h4 id="name-accurate-ecn-feedback">
<a class="section-number selfRef" href="#appendix-A.1.2">A.1.2. </a><a class="section-name selfRef" href="#name-accurate-ecn-feedback">Accurate ECN Feedback</a>
          </h4>
<p id="appendix-A.1.2-1">Description: The transport protocol for a Scalable congestion
          control needs to provide timely, accurate feedback about the extent
          of ECN marking experienced by all packets (see the precise normative
          requirement wording in <a class="auto internal xref" href="#l4sid_feedback">Section 4.2</a>).<a class="pilcrow" href="#appendix-A.1.2-1">¶</a></p>
<p id="appendix-A.1.2-2">Motivation: Classic congestion controls only need feedback about
          the existence of a congestion episode within a round trip, not
          precisely how many packets were ECN-marked or dropped.
          Therefore, in 2001, when ECN feedback was added to TCP <span>[<a class="cite xref" href="#RFC3168">RFC3168</a>]</span>, it could not inform the sender of more than one
          ECN mark per RTT. 
          Since then, requirements for more accurate ECN
          feedback in TCP have been defined in <span>[<a class="cite xref" href="#RFC7560">RFC7560</a>]</span>, and
          <span>[<a class="cite xref" href="#I-D.ietf-tcpm-accurate-ecn">ACCECN</a>]</span> specifies a change to
          the TCP protocol to satisfy these requirements. Most other transport
          protocols already satisfy this requirement (see <a class="auto internal xref" href="#l4sid_feedback">Section 4.2</a>).<a class="pilcrow" href="#appendix-A.1.2-2">¶</a></p>
</section>
<div id="l4sid_sec_replaceable">
<section id="appendix-A.1.3">
          <h4 id="name-capable-of-replacement-by-c">
<a class="section-number selfRef" href="#appendix-A.1.3">A.1.3. </a><a class="section-name selfRef" href="#name-capable-of-replacement-by-c">Capable of Replacement by Classic Congestion Control</a>
          </h4>
<p id="appendix-A.1.3-1">Description: It needs to be possible to replace the
          implementation of a Scalable congestion control with a Classic
          control (see the precise normative requirement wording in <a class="auto internal xref" href="#l4sid_Prague_req-replaceable">Section 4.3, Paragraph 8, Item 1</a>).<a class="pilcrow" href="#appendix-A.1.3-1">¶</a></p>
<p id="appendix-A.1.3-2">Motivation: L4S is an experimental protocol; therefore, it seems
          prudent to be able to disable it at source in case of insurmountable
          problems, perhaps due to some unexpected interaction on a particular
          sender; over a particular path or network; or with a particular
          receiver, or even ultimately an insurmountable problem with the
          experiment as a whole.<a class="pilcrow" href="#appendix-A.1.3-2">¶</a></p>
</section>
</div>
<div id="l4sid_sec_fallback_on_loss">
<section id="appendix-A.1.4">
          <h4 id="name-fall-back-to-classic-conges">
<a class="section-number selfRef" href="#appendix-A.1.4">A.1.4. </a><a class="section-name selfRef" href="#name-fall-back-to-classic-conges">Fall Back to Classic Congestion Control on Packet Loss</a>
          </h4>
<p id="appendix-A.1.4-1">Description: As well as responding to ECN markings in a scalable
          way, a Scalable congestion control needs to react to packet loss in
          a way that will coexist safely with a Reno congestion
          control <span>[<a class="cite xref" href="#RFC5681">RFC5681</a>]</span> (see the precise normative
          requirement wording in <a class="auto internal xref" href="#l4sid_Prague_req-loss-response">Section 4.3, Paragraph 8, Item 2</a>).<a class="pilcrow" href="#appendix-A.1.4-1">¶</a></p>
<p id="appendix-A.1.4-2">Motivation: Part of the safety conditions for deploying a
          Scalable congestion control on the public Internet is to make sure
          that it behaves properly when it builds a queue at a network
          bottleneck that has not been upgraded to support L4S. Packet loss
          can have many causes, but it usually has to be conservatively
          assumed that it is a sign of congestion. Therefore, on detecting
          packet loss, a Scalable congestion control will need to fall back to
          Classic congestion control behaviour. If it does not comply, it
          could starve Classic traffic.<a class="pilcrow" href="#appendix-A.1.4-2">¶</a></p>
<p id="appendix-A.1.4-3">A Scalable congestion control can be used for different types of
          transport, e.g., for real-time media or for reliable transport
          like TCP. Therefore, the particular Classic congestion control
          behaviour to fall back on will need to be dependent on the specific
          congestion control implementation.
   In the particular case of DCTCP,
          the DCTCP specification <span>[<a class="cite xref" href="#RFC8257">RFC8257</a>]</span> states that
          "A DCTCP sender <span class="bcp14">MUST</span> react to loss episodes in 
          the same way as conventional TCP,...".  To ensure any Scalable congestion control is safe to deploy over the public Internet, Item
          <a class="auto internal xref" href="#l4sid_Prague_req-loss-response">2</a> of <a class="auto internal xref" href="#l4sid_congestion_response">Section 4.3</a> in the present spec 
          does not require precisely the same response as Reno TCP, but it does 
          require a response that will coexist safely with Classic congestion controls 
          like Reno.<a class="pilcrow" href="#appendix-A.1.4-3">¶</a></p>
<p id="appendix-A.1.4-4">Even though a bottleneck is L4S capable, it might still become
          overloaded and have to drop packets. In this case, the sender may
          receive a high proportion of packets marked with the CE codepoint and
          also experience loss. Current DCTCP implementations each react
          differently to this situation. One approach is to react only to the drop 
          signal (e.g., by halving the cwnd); another approach is to react to both 
          signals, which reduces cwnd by more than half. A compromise 
          between these two has been proposed where the loss response is adjusted to
          result in a halving when combined with any ECN response earlier in the same 
          round. We believe
          that further experimentation is needed to understand what is the
          best behaviour for the public Internet, which may or may not be one of
          these existing approaches.<a class="pilcrow" href="#appendix-A.1.4-4">¶</a></p>
</section>
</div>
<div id="l4sid_sec_fallback_on_classic_CE">
<section id="appendix-A.1.5">
          <h4 id="name-coexistence-with-classic-co">
<a class="section-number selfRef" href="#appendix-A.1.5">A.1.5. </a><a class="section-name selfRef" href="#name-coexistence-with-classic-co">Coexistence with Classic Congestion Control at Classic ECN Bottlenecks</a>
          </h4>
<p id="appendix-A.1.5-1">Description: Monitoring has to be in place so that a non-L4S but
          ECN-capable AQM can be detected at path bottlenecks. This is in case
          such an AQM has been implemented in a shared queue, in which case
          any long-running Scalable flow would predominate over any
          simultaneous long-running Classic flow sharing the queue. The
          precise requirement wording in <a class="auto internal xref" href="#l4sid_Prague_req-classic-ecn-response">Section 4.3, Paragraph 8, Item 3</a> is written so that such a
          problem could be resolved either in real time or via administrative
          intervention.<a class="pilcrow" href="#appendix-A.1.5-1">¶</a></p>
<p id="appendix-A.1.5-2">Motivation: Similarly to the discussion in <a class="auto internal xref" href="#l4sid_sec_fallback_on_loss">Appendix A.1.4</a>, this requirement in <a class="auto internal xref" href="#l4sid_congestion_response">Section 4.3</a> is a safety condition to ensure
          an L4S congestion control coexists well with Classic flows when it
          builds a queue at a shared network bottleneck that has not been
          upgraded to support L4S. Nonetheless, if necessary, it is considered
          reasonable to resolve such problems over management timescales
          (possibly involving human intervention) because:<a class="pilcrow" href="#appendix-A.1.5-2">¶</a></p>
<ul class="normal">
<li class="normal" id="appendix-A.1.5-3.1">although a Classic flow can considerably reduce its
              throughput in the face of a competing Scalable flow, it still
              makes progress and does not starve;<a class="pilcrow" href="#appendix-A.1.5-3.1">¶</a>
</li>
            <li class="normal" id="appendix-A.1.5-3.2">implementations of a Classic ECN AQM in a queue that is
              intended to be shared are believed to be rare; and<a class="pilcrow" href="#appendix-A.1.5-3.2">¶</a>
</li>
            <li class="normal" id="appendix-A.1.5-3.3">detection of such AQMs is not always clear-cut; so focused
              out-of-band testing (or even contacting the relevant network
              operator) would improve certainty.<a class="pilcrow" href="#appendix-A.1.5-3.3">¶</a>
</li>
          </ul>
<p id="appendix-A.1.5-4">The relevant normative requirement (<a class="auto internal xref" href="#l4sid_congestion_response">Section 4.3</a>) is therefore divided into three stages:
          monitoring, detection, and action:<a class="pilcrow" href="#appendix-A.1.5-4">¶</a></p>
<span class="break"></span><dl class="dlParallel" id="appendix-A.1.5-5">
            <dt id="appendix-A.1.5-5.1">Monitoring:</dt>
            <dd id="appendix-A.1.5-5.2" style="margin-left: 1.5em">Monitoring involves collection of the
              measurement data to be analysed. Monitoring is expressed as a
              "<span class="bcp14">MUST</span>" for uncontrolled environments, although the placement of
              the monitoring function is left open. Whether monitoring has to
              be applied in real time is expressed as a "<span class="bcp14">SHOULD</span>". 
              This allows
              for the possibility that the operator of an L4S sender
              (e.g., a Content Distribution Network (CDN)) might prefer to test out-of-band for signs of
              Classic ECN AQMs, perhaps to avoid continually consuming
              resources to monitor live traffic.<a class="pilcrow" href="#appendix-A.1.5-5.2">¶</a>
</dd>
            <dd class="break"></dd>
<dt id="appendix-A.1.5-5.3">Detection:</dt>
            <dd id="appendix-A.1.5-5.4" style="margin-left: 1.5em">Detection involves analysis of the
              monitored data to detect the likelihood of a Classic ECN AQM.
              Detection can either directly detect actual coexistence problems
              between flows or aim to identify AQM technologies that
              are likely to present coexistence problems, based on knowledge
              of AQMs deployed at the time. The requirements recommend that
              detection occurs live in real time. However, detection is
              allowed to be deferred (e.g., it might involve further
              testing targeted at candidate AQMs).<a class="pilcrow" href="#appendix-A.1.5-5.4">¶</a>
</dd>
            <dd class="break"></dd>
<dt id="appendix-A.1.5-5.5">Action:</dt>
            <dd id="appendix-A.1.5-5.6" style="margin-left: 1.5em">
              <p id="appendix-A.1.5-5.6.1">This involves the act of switching the
              sender to a Classic congestion control. This might occur in
              real time within the congestion control for the subsequent
              duration of a flow, or it might involve administrative action to
              switch to Classic congestion control for a specific interface or
              for a certain set of destination addresses.<a class="pilcrow" href="#appendix-A.1.5-5.6.1">¶</a></p>
<p id="appendix-A.1.5-5.6.2">Instead of the sender taking action itself, the
              operator of the sender (e.g., a CDN) might prefer to ask the
              network operator to modify the Classic AQM's treatment of L4S
              packets; ensure L4S packets bypass the AQM; or upgrade
              the AQM to support L4S (see the L4S operational
              guidance <span>[<a class="cite xref" href="#I-D.ietf-tsvwg-l4sops">L4SOPS</a>]</span>). 
              If L4S
              flows then no longer shared the Classic ECN AQM, they would obviously
              no longer detect it, and the requirement to act on it would no
              longer apply.<a class="pilcrow" href="#appendix-A.1.5-5.6.2">¶</a></p>
</dd>
          <dd class="break"></dd>
</dl>
<p id="appendix-A.1.5-6">The whole set of normative requirements concerning Classic ECN
          AQMs in <a class="auto internal xref" href="#l4sid_congestion_response">Section 4.3</a> is worded so that
          it does not apply in controlled environments, such as private
          networks or data-centre networks. CDN servers placed within an
          access ISP's network can be considered as a single controlled
          environment, but any onward networks served by the access network,
          including all the attached customer networks, would be unlikely to
          fall under the same degree of coordinated control. Monitoring is
          expressed as a "<span class="bcp14">MUST</span>" for these uncontrolled segments of paths
          (e.g., beyond the access ISP in a home network), because there
          is a possibility that there might be a shared queue Classic ECN AQM
          in that segment. Nonetheless, the intent of the wording is to only
          require occasional monitoring of these uncontrolled regions and not
          to burden CDN operators if monitoring never uncovers any potential
          problems.<a class="pilcrow" href="#appendix-A.1.5-6">¶</a></p>
<p id="appendix-A.1.5-7">More detailed discussion of all the above options and
          alternatives can be found in the L4S operational guidance <span>[<a class="cite xref" href="#I-D.ietf-tsvwg-l4sops">L4SOPS</a>]</span>.<a class="pilcrow" href="#appendix-A.1.5-7">¶</a></p>
<p id="appendix-A.1.5-8">Having said all the above, the approach recommended in <a class="auto internal xref" href="#l4sid_congestion_response">Section 4.3</a> is to monitor, detect, and act
          in real time on live traffic. A passive monitoring algorithm to
          detect a Classic ECN AQM at the bottleneck and fall back to Classic
          congestion control is described in an extensive technical
          report <span>[<a class="cite xref" href="#ecn-fallback">ecn-fallback</a>]</span>, which also provides a
          link to Linux source code and a large online visualization of its
          evaluation results. Very briefly, the algorithm primarily monitors
          RTT variation using the same algorithm that maintains the mean
          deviation of TCP's smoothed RTT, but it smooths over a duration of
          the order of a Classic sawtooth.
          The outcome is also conditioned on
          other metrics such as the presence of CE marking and congestion
          avoidance phase having stabilized. The report also identifies
          further work to improve the approach, for instance, improvements with
          low-capacity links and combining the measurements with a cache of
          what had been learned about a path in previous connections. The
          report also suggests alternative approaches.<a class="pilcrow" href="#appendix-A.1.5-8">¶</a></p>
<p id="appendix-A.1.5-9">Although using passive measurements within live traffic (as
          above) can detect a Classic ECN AQM, it is much harder (perhaps
          impossible) to determine whether or not the AQM is in a shared
          queue. Nonetheless, this is much easier using active test traffic
          out-of-band because two flows can be used. Section 4 of the same
          report <span>[<a class="cite xref" href="#ecn-fallback">ecn-fallback</a>]</span> describes a simple
          technique to detect a Classic ECN AQM and determine whether it is in
          a shared queue, which is summarized here.<a class="pilcrow" href="#appendix-A.1.5-9">¶</a></p>
<p id="appendix-A.1.5-10">An L4S-enabled test server could be set up so that, when a test
          client accesses it, it serves a script that gets the client to open
          two parallel long-running flows. It could serve one with a Classic
          congestion control (C, that sets ECT(0)) and one with a Scalable CC
          (L, that sets ECT(1)). If neither flow induces any ECN marks, it can
          be presumed that the path does not contain a Classic ECN AQM. If either
          flow induces some ECN marks, the server could measure the relative
          flow rates and round-trip times of the two flows. 
          <a class="auto internal xref" href="#l4sid_tab_active_AQN_test">Table 2</a> shows the AQM that can be
          inferred for various cases (presuming no more types of AQM behaviour than those known at
          the time of writing).<a class="pilcrow" href="#appendix-A.1.5-10">¶</a></p>
<span id="name-out-of-band-testing-with-tw"></span><div id="l4sid_tab_active_AQN_test">
<table class="center" id="table-2">
            <caption>
<a class="selfRef" href="#table-2">Table 2</a>:
<a class="selfRef" href="#name-out-of-band-testing-with-tw">Out-of-Band Testing with Two Parallel Flows</a>
            </caption>
<thead>
              <tr>
                <th class="text-left" colspan="1" rowspan="1">Rate</th>
                <th class="text-left" colspan="1" rowspan="1">RTT</th>
                <th class="text-left" colspan="1" rowspan="1">Inferred AQM</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td class="text-left" colspan="1" rowspan="1">L &gt; C</td>
                <td class="text-left" colspan="1" rowspan="1">L = C</td>
                <td class="text-left" colspan="1" rowspan="1">Classic ECN AQM (FIFO)</td>
              </tr>
              <tr>
                <td class="text-left" colspan="1" rowspan="1">L = C</td>
                <td class="text-left" colspan="1" rowspan="1">L = C</td>
                <td class="text-left" colspan="1" rowspan="1">Classic ECN AQM (FQ)</td>
              </tr>
              <tr>
                <td class="text-left" colspan="1" rowspan="1">L = C</td>
                <td class="text-left" colspan="1" rowspan="1">L &lt; C</td>
                <td class="text-left" colspan="1" rowspan="1">FQ-L4S AQM</td>
              </tr>
              <tr>
                <td class="text-left" colspan="1" rowspan="1">L ~= C</td>
                <td class="text-left" colspan="1" rowspan="1">L &lt; C</td>
                <td class="text-left" colspan="1" rowspan="1">DualQ Coupled AQM</td>
              </tr>
            </tbody>
            <tfoot>
              <tr>
                <th class="text-center" colspan="3" rowspan="1">L = L4S; C = Classic</th>
              </tr>
            </tfoot>
          </table>
</div>
<p id="appendix-A.1.5-12">Finally, we motivate the recommendation in <a class="auto internal xref" href="#l4sid_congestion_response">Section 4.3</a> that a Scalable congestion
          control is not expected to change to setting ECT(0) while it adapts
          its behaviour to coexist with Classic flows. This is because the
          sender needs to continue to check whether it made the right decision
          and switch back if it was wrong, or if a different link becomes
          the bottleneck:<a class="pilcrow" href="#appendix-A.1.5-12">¶</a></p>
<ul class="normal">
<li class="normal" id="appendix-A.1.5-13.1">If, as recommended, the sender changes only its behaviour but
              not its codepoint to Classic, its codepoint will still be
              compatible with either an L4S or a Classic AQM. If the
              bottleneck does actually support both, it will still classify
              ECT(1) into the same L4S queue, where the sender can measure
              that switching to Classic behaviour was wrong so that it can
              switch back.<a class="pilcrow" href="#appendix-A.1.5-13.1">¶</a>
</li>
            <li class="normal" id="appendix-A.1.5-13.2">In contrast, if the sender changes both its behaviour and its
              codepoint to Classic, even if the bottleneck supports both, it
              will classify ECT(0) into the Classic queue, reinforcing the
            sender's incorrect decision so that it never switches back.<a class="pilcrow" href="#appendix-A.1.5-13.2">¶</a>
</li>
            <li class="normal" id="appendix-A.1.5-13.3">Also, not changing its codepoint avoids the risk of being flipped
              to a different path by a load balancer or multipath routing that
              hashes on the whole of the former Type-of-Service (ToS) byte (which is unfortunately still a
              common pathology).<a class="pilcrow" href="#appendix-A.1.5-13.3">¶</a>
</li>
          </ul>
<aside id="appendix-A.1.5-14">
            <p id="appendix-A.1.5-14.1">Note that if a flow is configured to <em>only</em>
          use a Classic congestion control, it is then entirely appropriate
          not to use ECT(1).<a class="pilcrow" href="#appendix-A.1.5-14.1">¶</a></p>
</aside>
</section>
</div>
<div id="l4sid_sec_RTT_dependence">
<section id="appendix-A.1.6">
          <h4 id="name-reduce-rtt-dependence">
<a class="section-number selfRef" href="#appendix-A.1.6">A.1.6. </a><a class="section-name selfRef" href="#name-reduce-rtt-dependence">Reduce RTT Dependence</a>
          </h4>
<p id="appendix-A.1.6-1">Description: A Scalable congestion control needs to reduce RTT
          bias as much as possible at least over the low-to-typical range of
          RTTs that will interact in the intended deployment scenario (see the
          precise normative requirement wording in <a class="auto internal xref" href="#l4sid_Prague_req-rtt-independence">Section 4.3, Paragraph 8, Item 4</a>).<a class="pilcrow" href="#appendix-A.1.6-1">¶</a></p>
<p id="appendix-A.1.6-2">Motivation: The throughput of Classic congestion controls is
          known to be inversely proportional to RTT, so one would expect flows
          over very low RTT paths to nearly starve flows over larger RTTs.
          However, Classic congestion controls have never allowed a very low
          RTT path to exist because they induce a large queue. For instance,
          consider two paths with base RTT 1 ms and 100 ms. If a
          Classic congestion control induces a 100 ms queue, it turns
          these RTTs into 101 ms and 200 ms, leading to a throughput
          ratio of about 2:1. Whereas if a Scalable congestion control induces
          only a 1 ms queue, the ratio is 2:101, leading to a throughput
          ratio of about 50:1.<a class="pilcrow" href="#appendix-A.1.6-2">¶</a></p>
<p id="appendix-A.1.6-3">Therefore, with very small queues, long RTT flows will
          essentially starve, unless Scalable congestion controls comply with
          the requirement in <a class="auto internal xref" href="#l4sid_congestion_response">Section 4.3</a>.<a class="pilcrow" href="#appendix-A.1.6-3">¶</a></p>
<p id="appendix-A.1.6-4">Over higher than typical RTTs, L4S flows can use the same RTT
          bias as in current Classic congestion controls and still work
          satisfactorily. So there is no additional requirement in <a class="auto internal xref" href="#l4sid_congestion_response">Section 4.3</a> for high RTT L4S flows to
          remove RTT bias -- they can, but they don't have to.<a class="pilcrow" href="#appendix-A.1.6-4">¶</a></p>
<p id="appendix-A.1.6-5">One way for a Scalable congestion control to satisfy these
          requirements is to make its additive increase behave as if it were a
          standard Reno flow but over a larger RTT by using a virtual RTT
          (rtt_virt) that is a function of the actual RTT (rtt). Example
          functions might be:<a class="pilcrow" href="#appendix-A.1.6-5">¶</a></p>
<ul class="normal ulEmpty">
<li class="normal ulEmpty" id="appendix-A.1.6-6.1">
              <code>rtt_virt = max(rtt, 25 ms)</code><a class="pilcrow" href="#appendix-A.1.6-6.1">¶</a>
</li>
            <li class="normal ulEmpty" id="appendix-A.1.6-6.2">
              <code>rtt_virt = rtt + 10 ms</code><a class="pilcrow" href="#appendix-A.1.6-6.2">¶</a>
</li>
          </ul>
<p id="appendix-A.1.6-7">These example functions are chosen so that, as the actual
          RTT reduces from high to low, the virtual RTT reduces less (see
          <span>[<a class="cite xref" href="#I-D.briscoe-iccrg-prague-congestion-control">PRAGUE-CC</a>]</span> for
          details).<a class="pilcrow" href="#appendix-A.1.6-7">¶</a></p>
<p id="appendix-A.1.6-8">However, short RTT flows can more rapidly respond to changes in
          available capacity, whether due to other flows arriving and
          departing or radio capacity varying. So it would be wrong to require
          short RTT flows to be as sluggish as long RTT flows, which would
          unnecessarily underutilize capacity and result in unnecessary
          overshoots and undershoots (instability). Therefore, rather than
          requiring strict RTT independence, the wording in Item <a class="auto internal xref" href="#l4sid_Prague_req-rtt-independence">4</a> of <a class="auto internal xref" href="#l4sid_congestion_response">Section 4.3</a> is "as independent
          of RTT as possible without compromising stability or utilization".
          This allows shorter RTT flows to exploit their agility
          advantage.<a class="pilcrow" href="#appendix-A.1.6-8">¶</a></p>
</section>
</div>
<div id="l4sid_sec_min_cwnd">
<section id="appendix-A.1.7">
          <h4 id="name-scaling-down-to-fractional-">
<a class="section-number selfRef" href="#appendix-A.1.7">A.1.7. </a><a class="section-name selfRef" href="#name-scaling-down-to-fractional-">Scaling Down to Fractional Congestion Windows</a>
          </h4>
<p id="appendix-A.1.7-1">Description: A Scalable congestion control needs to remain
          responsive to congestion when typical RTTs over the public Internet
          are significantly smaller because they are no longer inflated by
          queuing delay (see the precise normative requirement wording in
          <a class="auto internal xref" href="#l4sid_Prague_req-fractional-window">Section 4.3, Paragraph 8, Item 5</a>).<a class="pilcrow" href="#appendix-A.1.7-1">¶</a></p>
<p id="appendix-A.1.7-2">Motivation: As currently specified, the minimum congestion window
          of ECN-capable TCP (and its derivatives) is expected to be 2 sender
          maximum segment sizes (SMSS), or 1 SMSS after a retransmission
          timeout. Once the congestion window reaches this minimum, if there
          is further ECN marking, TCP is meant to wait for a retransmission
          timeout before sending another segment (see <span><a class="relref" href="https://www.rfc-editor.org/rfc/rfc3168#section-6.1.2">Section 6.1.2</a> of the ECN spec [<a class="cite xref" href="#RFC3168">RFC3168</a>]</span>). In
          practice, most known window-based congestion control algorithms
          become unresponsive to ECN congestion signals at this point. No
          matter how much ECN marking, the congestion window no longer
          reduces. Instead, the sender's lack of any further congestion
          response forces the queue to grow, overriding any AQM and increasing
          queuing delay (making the window large enough to become responsive
          again). This can result in a stable but deeper queue, or it might
          drive the queue to loss, in which case the retransmission timeout mechanism
          acts as a backstop.<a class="pilcrow" href="#appendix-A.1.7-2">¶</a></p>
<p id="appendix-A.1.7-3">Most window-based congestion controls for other transport
          protocols have a similar minimum window, albeit when measured in
          bytes for those that use smaller packets.<a class="pilcrow" href="#appendix-A.1.7-3">¶</a></p>
<p id="appendix-A.1.7-4">L4S mechanisms significantly reduce queuing delay so, over the
          same path, the RTT becomes lower. Then, this problem becomes
          surprisingly common <span>[<a class="cite xref" href="#sub-mss-prob">sub-mss-prob</a>]</span>. This is
          because, for the same link capacity, smaller RTT implies a smaller
          window. For instance, consider a residential setting with an
          upstream broadband Internet access of 8 Mb/s, assuming a max
          segment size of 1500 B. Two upstream flows will each have the
          minimum window of 2 SMSS if the RTT is 6 ms or less, which
          is quite common when accessing a nearby data centre. So any more
          than two such parallel TCP flows will become unresponsive to ECN and
          increase queuing delay.<a class="pilcrow" href="#appendix-A.1.7-4">¶</a></p>
<p id="appendix-A.1.7-5">Unless Scalable congestion controls address the requirement in
          <a class="auto internal xref" href="#l4sid_congestion_response">Section 4.3</a> from the start, they will
          frequently become unresponsive to ECN, negating the low-latency
          benefit of L4S, for themselves and for others.<a class="pilcrow" href="#appendix-A.1.7-5">¶</a></p>
<p id="appendix-A.1.7-6">That would seem to imply that Scalable congestion controllers
          ought to be required to be able work with a congestion window less
          than 1 SMSS. For instance, if an ECN-capable TCP gets an
          ECN mark when it is already sitting at a window of 1 SMSS,
          <span>[<a class="cite xref" href="#RFC3168">RFC3168</a>]</span> requires it to defer sending for a retransmission
          timeout. A less drastic but more complex mechanism can maintain a
          congestion window less than 1 SMSS (significantly less if
          necessary), as described in <span>[<a class="cite xref" href="#Ahmed19">Ahmed19</a>]</span>. Other
          approaches are likely to be feasible.<a class="pilcrow" href="#appendix-A.1.7-6">¶</a></p>
<p id="appendix-A.1.7-7">However, the requirement in <a class="auto internal xref" href="#l4sid_congestion_response">Section 4.3</a> is worded as a "<span class="bcp14">SHOULD</span>" because
          it is believed that the existence of a minimum window is not all
          bad. When competing with an unresponsive flow, a minimum window
          naturally protects the flow from starvation by at least keeping some
          data flowing.<a class="pilcrow" href="#appendix-A.1.7-7">¶</a></p>
<p id="appendix-A.1.7-8">By stating the requirement to go lower than 1 SMSS as a
          "<span class="bcp14">SHOULD</span>", while the requirement in <span>[<a class="cite xref" href="#RFC3168">RFC3168</a>]</span> still stands as
          well, we shall be able to watch the choices of minimum window evolve
          in different Scalable congestion controllers.<a class="pilcrow" href="#appendix-A.1.7-8">¶</a></p>
</section>
</div>
<div id="l4sid_sec_reordering_tolerance">
<section id="appendix-A.1.8">
          <h4 id="name-measuring-reordering-tolera">
<a class="section-number selfRef" href="#appendix-A.1.8">A.1.8. </a><a class="section-name selfRef" href="#name-measuring-reordering-tolera">Measuring Reordering Tolerance in Time Units</a>
          </h4>
<p id="appendix-A.1.8-1">Description: When detecting loss, a Scalable congestion control
          needs to be tolerant to reordering over an adaptive time interval,
          which scales with throughput, rather than counting only in fixed
          units of packets, which does not scale (see the precise normative
          requirement wording in <a class="auto internal xref" href="#l4sid_Prague_req-reordering">Section 4.3, Paragraph 8, Item 6</a>).<a class="pilcrow" href="#appendix-A.1.8-1">¶</a></p>
<p id="appendix-A.1.8-2">Motivation: A primary purpose of L4S is scalable throughput (it's
          in the name). Scalability in all dimensions is, of course, also a
          goal of all IETF technology. The inverse linear congestion response
          in <a class="auto internal xref" href="#l4sid_congestion_response">Section 4.3</a> is necessary, but not
          sufficient, to solve the congestion control scalability problem
          identified in <span>[<a class="cite xref" href="#RFC3649">RFC3649</a>]</span>. As well as maintaining
          frequent ECN signals as rate scales, it is also important to ensure
          that a potentially false perception of loss does not limit
          throughput scaling.<a class="pilcrow" href="#appendix-A.1.8-2">¶</a></p>
<p id="appendix-A.1.8-3">End systems cannot know whether a missing packet is due to loss
          or reordering, except in hindsight -- if it appears later. So they
          can only deem that there has been a loss if a gap in the sequence
          space has not been filled, either after a certain number of
          subsequent packets has arrived (e.g., the 3 DupACK rule of
          standard TCP congestion control <span>[<a class="cite xref" href="#RFC5681">RFC5681</a>]</span>) or
          after a certain amount of time (e.g., the RACK
          approach <span>[<a class="cite xref" href="#RFC8985">RFC8985</a>]</span>).<a class="pilcrow" href="#appendix-A.1.8-3">¶</a></p>
<p id="appendix-A.1.8-4">As we attempt to scale packet rate over the years:<a class="pilcrow" href="#appendix-A.1.8-4">¶</a></p>
<ul class="normal">
<li class="normal" id="appendix-A.1.8-5.1">Even if only <em>some</em> sending hosts
              still deem that loss has occurred by counting reordered packets,
              <em>all</em> networks will have to keep
              reducing the time over which they keep packets in order. If some
              link technologies keep the time within which reordering occurs
              roughly unchanged, then loss over these links, as perceived by
              these hosts, will appear to continually rise over the years.<a class="pilcrow" href="#appendix-A.1.8-5.1">¶</a>
</li>
            <li class="normal" id="appendix-A.1.8-5.2">In contrast, if all senders detect loss in units of time, the
              time over which the network has to keep packets in order stays
              roughly invariant.<a class="pilcrow" href="#appendix-A.1.8-5.2">¶</a>
</li>
          </ul>
<p id="appendix-A.1.8-6">Therefore, hosts have an incentive to detect loss in time
          units (so as not to fool themselves too often into detecting losses
          when there are none). And for hosts that are changing their
          congestion control implementation to L4S, there is no downside to
          including time-based loss detection code in the change (loss
          recovery implemented in hardware is an exception, which is covered later).
          Therefore, requiring L4S hosts to detect loss in time-based units
          would not be a burden.<a class="pilcrow" href="#appendix-A.1.8-6">¶</a></p>
<p id="appendix-A.1.8-7">If the requirement in <a class="auto internal xref" href="#l4sid_congestion_response">Section 4.3</a>
          were not placed on L4S hosts, even though it would be no burden on
          hosts to comply, all networks would face unnecessary uncertainty
          over whether some L4S hosts might be detecting loss by counting
          packets. Then, <em>all</em> link technologies would
          have to unnecessarily keep reducing the time within which reordering
          occurs. That is not a problem for some link technologies, but it
          becomes increasingly challenging for other link technologies to
          continue to scale, particularly those relying on channel bonding for
          scaling, such as LTE, 5G, and Data Over Cable Service Interface Specification (DOCSIS).<a class="pilcrow" href="#appendix-A.1.8-7">¶</a></p>
<p id="appendix-A.1.8-8">Given Internet paths traverse many link technologies, any scaling
          limit for these more challenging access link technologies would
          become a scaling limit for the Internet as a whole.<a class="pilcrow" href="#appendix-A.1.8-8">¶</a></p>
<p id="appendix-A.1.8-9">It might be asked how it helps to place this loss detection
          requirement only on L4S hosts, because networks will still face
          uncertainty over whether non-L4S flows are detecting loss by
          counting DupACKs. The answer is that those link technologies for
          which it is challenging to keep squeezing the reordering time will
          only need to do so for non-L4S traffic (which they can do because
          the L4S identifier is visible at the IP layer). Therefore, they can
          focus their processing and memory resources into scaling non-L4S
          (Classic) traffic. Then, the higher the proportion of L4S traffic,
          the less of a scaling challenge they will have.<a class="pilcrow" href="#appendix-A.1.8-9">¶</a></p>
<p id="appendix-A.1.8-10">To summarize, there is no reason for L4S hosts not to be part of
          the solution instead of part of the problem.<a class="pilcrow" href="#appendix-A.1.8-10">¶</a></p>
<p id="appendix-A.1.8-11">Requirement ("<span class="bcp14">MUST</span>") or recommendation ("<span class="bcp14">SHOULD</span>")? As explained
          above, this is a subtle interoperability issue between hosts and
          networks, which seems to need a "<span class="bcp14">MUST</span>". Unless networks can be
          certain that all L4S hosts follow the time-based approach, they
          still have to cater for the worst case -- continually squeeze
          reordering into a smaller and smaller duration -- just for hosts that
          might be using the counting approach. However, it was decided to
          express this as a recommendation, using "<span class="bcp14">SHOULD</span>". The main
          justification was that networks can still be fairly certain that L4S
          hosts will follow this recommendation, because following it offers
          only gain and no pain.<a class="pilcrow" href="#appendix-A.1.8-11">¶</a></p>
<p id="appendix-A.1.8-12">Details:<a class="pilcrow" href="#appendix-A.1.8-12">¶</a></p>
<p id="appendix-A.1.8-13">The time spent recovering a loss is much more significant for short
          flows than long; therefore, a good compromise is to adapt the
          reordering window from a small fraction of the RTT at the start of
          a flow to a larger fraction of the RTT for flows that continue for
          many round trips.<a class="pilcrow" href="#appendix-A.1.8-13">¶</a></p>
<p id="appendix-A.1.8-14">This is broadly the approach adopted by RACK <span>[<a class="cite xref" href="#RFC8985">RFC8985</a>]</span>. However, RACK
          starts with the 3 DupACK approach, because the RTT estimate is not
          necessarily stable. As long as the initial window is paced, such
          initial use of 3 DupACK counting would amount to time-based loss
          detection and therefore would satisfy the time-based loss detection
          recommendation of <a class="auto internal xref" href="#l4sid_congestion_response">Section 4.3</a>. This
          is because pacing of the initial window would ensure that 3 DupACKs
          early in the connection would be spread over a small fraction of the
          round trip.<a class="pilcrow" href="#appendix-A.1.8-14">¶</a></p>
<p id="appendix-A.1.8-15">As mentioned above, hardware implementations of loss recovery
          using DupACK counting exist (e.g., some implementations of
          Remote Direct Memory Access over Converged Ethernet version 2 (RoCEv2)).
   For low latency, these implementations can change
          their congestion control to implement L4S, because the congestion
          control (as distinct from loss recovery) is implemented in software.
          But they cannot easily satisfy this loss recovery requirement.
          However, it is believed they do not need to, because such
          implementations are believed to solely exist in controlled
          environments, where the network technology keeps reordering
          extremely low anyway. This is why controlled environments with
          hardly any reordering are excluded from the scope of the normative
          recommendation in <a class="auto internal xref" href="#l4sid_congestion_response">Section 4.3</a>.<a class="pilcrow" href="#appendix-A.1.8-15">¶</a></p>
<p id="appendix-A.1.8-16">Detecting loss in time units also prevents the ACK-splitting
          attacks described in <span>[<a class="cite xref" href="#Savage-TCP">Savage-TCP</a>]</span>.<a class="pilcrow" href="#appendix-A.1.8-16">¶</a></p>
</section>
</div>
</section>
<section id="appendix-A.2">
        <h3 id="name-scalable-transport-protocol">
<a class="section-number selfRef" href="#appendix-A.2">A.2. </a><a class="section-name selfRef" href="#name-scalable-transport-protocol">Scalable Transport Protocol Optimizations</a>
        </h3>
<section id="appendix-A.2.1">
          <h4 id="name-setting-ect-in-control-pack">
<a class="section-number selfRef" href="#appendix-A.2.1">A.2.1. </a><a class="section-name selfRef" href="#name-setting-ect-in-control-pack">Setting ECT in Control Packets and Retransmissions</a>
          </h4>
<p id="appendix-A.2.1-1">Description: This item concerns TCP and its derivatives
          (e.g., SCTP) as well as RTP/RTCP <span>[<a class="cite xref" href="#RFC6679">RFC6679</a>]</span>.
          The original specification of ECN for TCP precluded the use of ECN
          on control packets and retransmissions. Similarly, <span>[<a class="cite xref" href="#RFC6679">RFC6679</a>]</span>
          precludes the use of ECT on RTCP datagrams, in case the path changes
          after it has been checked for ECN traversal. To improve performance,
          Scalable transport protocols ought to enable ECN at the IP layer in
          TCP control packets (SYN, SYN-ACK, pure ACKs, etc.) and in
          retransmitted packets. The same is true for other transports,
          e.g., SCTP and RTCP.<a class="pilcrow" href="#appendix-A.2.1-1">¶</a></p>
<p id="appendix-A.2.1-2">Motivation (TCP): <span>[<a class="cite xref" href="#RFC3168">RFC3168</a>]</span> prohibits the use of ECN on these
          types of TCP packets, based on a number of arguments. This means
          these packets are not protected from congestion loss by ECN, which
          considerably harms performance, particularly for short flows.
          ECN++ <span>[<a class="cite xref" href="#I-D.ietf-tcpm-generalized-ecn">ECN++</a>]</span> proposes
          experimental use of ECN on all types of TCP packets as long as AccECN
          feedback <span>[<a class="cite xref" href="#I-D.ietf-tcpm-accurate-ecn">ACCECN</a>]</span> is
          available (which itself satisfies the accurate feedback requirement
          in <a class="auto internal xref" href="#l4sid_feedback">Section 4.2</a> for using a Scalable congestion
          control).<a class="pilcrow" href="#appendix-A.2.1-2">¶</a></p>
<p id="appendix-A.2.1-3">Motivation (RTCP): L4S experiments in general will need to
          observe the rule in the RTP ECN spec <span>[<a class="cite xref" href="#RFC6679">RFC6679</a>]</span>
          that precludes ECT on RTCP datagrams. Nonetheless, as ECN usage
          becomes more widespread, it would be useful to conduct specific
          experiments with ECN-capable RTCP to gather data on whether such
          caution is necessary.<a class="pilcrow" href="#appendix-A.2.1-3">¶</a></p>
</section>
<section id="appendix-A.2.2">
          <h4 id="name-faster-than-additive-increa">
<a class="section-number selfRef" href="#appendix-A.2.2">A.2.2. </a><a class="section-name selfRef" href="#name-faster-than-additive-increa">Faster than Additive Increase</a>
          </h4>
<p id="appendix-A.2.2-1">Description: It would improve performance if Scalable congestion
          controls did not limit their congestion window increase to the
          standard additive increase of 1 SMSS per round trip <span>[<a class="cite xref" href="#RFC5681">RFC5681</a>]</span> during congestion avoidance. The same is true for
          derivatives of TCP congestion control, including similar approaches
          used for real-time media.<a class="pilcrow" href="#appendix-A.2.2-1">¶</a></p>
<p id="appendix-A.2.2-2">Motivation: As currently defined <span>[<a class="cite xref" href="#RFC8257">RFC8257</a>]</span>,
          DCTCP uses the conventional Reno additive increase in the congestion
          avoidance phase. When the available capacity suddenly increases
          (e.g., when another flow finishes or if radio capacity
          increases) it can take very many round trips to take advantage of
          the new capacity. TCP CUBIC <span>[<a class="cite xref" href="#RFC8312">RFC8312</a>]</span> was
          designed to solve this problem, but as flow rates have continued to
          increase, the delay accelerating into available capacity has become
          prohibitive. See, for instance, the examples in Section <a class="relref" href="https://www.rfc-editor.org/rfc/rfc9330#section-5.1">5.1</a> of the
          L4S architecture <span>[<a class="cite xref" href="#RFC9330">RFC9330</a>]</span>. Even
          when out of its Reno-friendly mode, every 8 times scaling of CUBIC's flow 
          rate leads to 2 times more acceleration delay.<a class="pilcrow" href="#appendix-A.2.2-2">¶</a></p>
<p id="appendix-A.2.2-3">In the steady state, DCTCP induces about 2 ECN marks per round
          trip, so it is possible to quickly detect when these signals have
          disappeared and seek available capacity more rapidly, while
          minimizing the impact on other flows (Classic and
          Scalable) <span>[<a class="cite xref" href="#LinuxPacedChirping">LinuxPacedChirping</a>]</span>. Alternatively,
          approaches such as Adaptive-Acceleration Data Center TCP (A2DTCP) <span>[<a class="cite xref" href="#A2DTCP">A2DTCP</a>]</span>) have been proposed to address this problem in
          data centres, which might be deployable over the public
          Internet.<a class="pilcrow" href="#appendix-A.2.2-3">¶</a></p>
</section>
<section id="appendix-A.2.3">
          <h4 id="name-faster-convergence-at-flow-">
<a class="section-number selfRef" href="#appendix-A.2.3">A.2.3. </a><a class="section-name selfRef" href="#name-faster-convergence-at-flow-">Faster Convergence at Flow Start</a>
          </h4>
<p id="appendix-A.2.3-1">Description: It would improve performance if Scalable congestion
          controls converged (reached their steady-state share of the
          capacity) faster than Classic congestion controls or at least no
          slower. This affects the flow start behaviour of any L4S congestion
          control derived from a Classic transport that uses TCP slow start,
          including those for real-time media.<a class="pilcrow" href="#appendix-A.2.3-1">¶</a></p>
<p id="appendix-A.2.3-2">Motivation: As an example, a new DCTCP flow takes longer than a
          Classic congestion control to obtain its share of the capacity of
          the bottleneck when there are already ongoing flows using the
          bottleneck capacity. 
          In a data-centre environment, DCTCP takes about
          1.5 to 2 times longer to converge due to the much higher
          typical level of ECN marking that DCTCP background traffic induces,
          which causes new flows to exit slow start early <span>[<a class="cite xref" href="#Alizadeh-stability">Alizadeh-stability</a>]</span>. In testing for use over the public
          Internet, the convergence time of DCTCP relative to a regular
          loss-based TCP slow start is even less favourable <span>[<a class="cite xref" href="#LinuxPacedChirping">LinuxPacedChirping</a>]</span> due to the shallow ECN-marking threshold
          needed for L4S. It is exacerbated by the typically greater mismatch
          between the link rate of the sending host and typical Internet
          access bottlenecks. This problem is detrimental in general but
          would particularly harm the performance of short flows relative to
          Classic congestion controls.<a class="pilcrow" href="#appendix-A.2.3-2">¶</a></p>
</section>
</section>
</section>
</div>
<div id="l4sid_ECT1_CE">
<section id="appendix-B">
      <h2 id="name-compromises-in-the-choice-o">
<a class="section-number selfRef" href="#appendix-B">Appendix B. </a><a class="section-name selfRef" href="#name-compromises-in-the-choice-o">Compromises in the Choice of L4S Identifier</a>
      </h2>
<p id="appendix-B-1">This appendix is informative, not normative. As explained in <a class="auto internal xref" href="#l4sid_reqs">Section 3</a>, there is insufficient space in the IP header (v4
      or v6) to fully accommodate every requirement. So the choice of L4S
      identifier involves trade-offs. This appendix records the pros and cons
      of the choice that was made.<a class="pilcrow" href="#appendix-B-1">¶</a></p>
<p id="appendix-B-2">Non-normative recap of the chosen codepoint scheme:<a class="pilcrow" href="#appendix-B-2">¶</a></p>
<ul class="normal ulEmpty">
<li class="normal ulEmpty" id="appendix-B-3.1">
          <p id="appendix-B-3.1.1">Packets with ECT(1) and conditionally packets with CE signify L4S
          semantics as an alternative to the semantics of Classic
          ECN <span>[<a class="cite xref" href="#RFC3168">RFC3168</a>]</span>, specifically:<a class="pilcrow" href="#appendix-B-3.1.1">¶</a></p>
<ul class="normal">
<li class="normal" id="appendix-B-3.1.2.1">The ECT(1) codepoint signifies that the packet was sent by an
              L4S-capable sender.<a class="pilcrow" href="#appendix-B-3.1.2.1">¶</a>
</li>
            <li class="normal" id="appendix-B-3.1.2.2">Given the shortage of codepoints, both the L4S and Classic ECN sides
              of an AQM have to use the same CE codepoint to indicate that a
              packet has experienced congestion. If a packet that had already
              been marked CE in an upstream buffer arrived at a subsequent
              AQM, this AQM would then have to guess whether to classify CE
              packets as L4S or Classic ECN. 
              Choosing the L4S treatment is a
              safer choice, because then a few Classic packets might arrive
              early rather than a few L4S packets arriving late.<a class="pilcrow" href="#appendix-B-3.1.2.2">¶</a>
</li>
            <li class="normal" id="appendix-B-3.1.2.3">Additional information might be available if the classifier
              were transport-aware. Then, it could classify a CE packet for
              Classic ECN treatment if the most recent ECT packet in the same
              flow had been set to ECT(0). However, the L4S service ought not
              need transport-layer awareness.<a class="pilcrow" href="#appendix-B-3.1.2.3">¶</a>
</li>
          </ul>
</li>
      </ul>
<p id="appendix-B-4">Cons:<a class="pilcrow" href="#appendix-B-4">¶</a></p>
<span class="break"></span><dl class="dlParallel" id="appendix-B-5">
        <dt id="appendix-B-5.1">Consumes the last ECN codepoint:</dt>
        <dd id="appendix-B-5.2" style="margin-left: 1.5em">The L4S service could
          potentially supersede the service provided by Classic ECN; therefore,
          using ECT(1) to identify L4S packets could ultimately mean that the
          ECT(0) codepoint was 'wasted' purely to distinguish one form of ECN
          from its successor.<a class="pilcrow" href="#appendix-B-5.2">¶</a>
</dd>
        <dd class="break"></dd>
<dt id="appendix-B-5.3">ECN hard in some lower layers:</dt>
        <dd id="appendix-B-5.4" style="margin-left: 1.5em">It is not always
          possible to support the equivalent of an IP-ECN field in an AQM
          acting in a buffer below the IP layer <span>[<a class="cite xref" href="#I-D.ietf-tsvwg-ecn-encap-guidelines">ECN-ENCAP</a>]</span>. Then, depending on
          the lower-layer scheme, the L4S service might have to drop rather
          than mark frames even though they might encapsulate an ECN-capable
          packet.<a class="pilcrow" href="#appendix-B-5.4">¶</a>
</dd>
        <dd class="break"></dd>
<dt id="appendix-B-5.5">Risk of reordering Classic CE packets within a flow:</dt>
        <dd id="appendix-B-5.6" style="margin-left: 1.5em">
<div id="l4sid_CE_reordering">
          <p id="appendix-B-5.6.1">Classifying
          all CE packets into the L4S queue risks any CE packets that were
          originally ECT(0) being incorrectly classified as L4S. If there were
          delay in the Classic queue, these incorrectly classified CE packets
          would arrive early, which is a form of reordering. Reordering within
          a microflow can cause TCP senders (and senders of similar
          transports) to retransmit spuriously. However, the risk of spurious
          retransmissions would be extremely low for the following
          reasons:<a class="pilcrow" href="#appendix-B-5.6.1">¶</a></p>
<ol class="normal type-1" id="appendix-B-5.6.2" start="1" type="1">
<li id="appendix-B-5.6.2.1">It is quite unusual to experience queuing at more than one
              bottleneck on the same path (the available capacities have to be
              identical).<a class="pilcrow" href="#appendix-B-5.6.2.1">¶</a>
</li>
            <li id="appendix-B-5.6.2.2">In only a subset of these unusual cases would the first
              bottleneck support Classic ECN marking and the second
              L4S ECN marking. This would be the only scenario
              where some ECT(0) packets could be CE marked by an AQM
              supporting Classic ECN while subsequently the remaining ECT(0) packets would experience further
              delay through the Classic side of a subsequent L4S DualQ
              AQM.<a class="pilcrow" href="#appendix-B-5.6.2.2">¶</a>
</li>
            <li id="appendix-B-5.6.2.3">
              <p id="appendix-B-5.6.2.3.1">Even then, when a few packets are delivered early, it takes
              very unusual conditions to cause a spurious retransmission, in
              contrast to when some packets are delivered late. The first
              bottleneck has to apply CE marks to at least N contiguous
              packets, and the second bottleneck has to inject an uninterrupted
              sequence of at least N of these packets between two packets
              earlier in the stream (where N is the reordering window that the
              transport protocol allows before it considers a packet is
              lost).<a class="pilcrow" href="#appendix-B-5.6.2.3.1">¶</a></p>
<ul class="normal ulEmpty">
<li class="normal ulEmpty" id="appendix-B-5.6.2.3.2.1">For example, consider N=3, and consider the sequence of
                  packets 100, 101, 102, 103,... Imagine that packets
                  150, 151, 152 from later in the flow are injected as follows:
                  100, 150, 151, 101, 152, 102, 103,... If this were late
                  reordering, even one packet arriving out of sequence would
                  trigger a spurious retransmission, but there is no spurious
                  retransmission here with early reordering, because packet
                  101 moves the cumulative ACK counter forward before 3
                  packets have arrived out of order. 
                  Later, when packets 148,
                  149, 153,... arrive, even though there is a 3-packet hole,
                  there will be no problem, because the packets to fill the
                  hole are already in the receive buffer.<a class="pilcrow" href="#appendix-B-5.6.2.3.2.1">¶</a>
</li>
              </ul>
</li>
            <li id="appendix-B-5.6.2.4">Even with the current TCP recommendation of N=3 <span>[<a class="cite xref" href="#RFC5681">RFC5681</a>]</span>, spurious retransmissions will be unlikely for
              all the above reasons. As RACK <span>[<a class="cite xref" href="#RFC8985">RFC8985</a>]</span> is
              becoming widely deployed, it tends to adapt its reordering
              window to a larger value of N, which will make the chance of a
              contiguous sequence of N early arrivals vanishingly small.<a class="pilcrow" href="#appendix-B-5.6.2.4">¶</a>
</li>
            <li id="appendix-B-5.6.2.5">Even a run of 2 CE marks within a Classic ECN flow is
              unlikely, given FQ-CoDel is the only known widely deployed AQM
              that supports Classic ECN marking, and it takes great care to
              separate out flows and to space any markings evenly along each
              flow.<a class="pilcrow" href="#appendix-B-5.6.2.5">¶</a>
</li>
          </ol>
<p id="appendix-B-5.6.3">It is extremely unlikely that the above set of 5
          eventualities that are each unusual in themselves would all happen
          simultaneously. But, even if they did, the consequences would hardly
          be dire: the odd spurious fast retransmission. Whenever the traffic
          source (a Classic congestion control) mistakes the reordering of a
          string of CE marks for a loss, one might think that it will reduce
          its congestion window as well as emitting a spurious retransmission.
          However, it would have already reduced its congestion window when
          the CE markings arrived early. If it is using ABE <span>[<a class="cite xref" href="#RFC8511">RFC8511</a>]</span>, it might reduce cwnd a little more for a loss
          than for a CE mark. But it will revert that reduction once it
          detects that the retransmission was spurious.<a class="pilcrow" href="#appendix-B-5.6.3">¶</a></p>
<p id="appendix-B-5.6.4">In conclusion, the impact of early reordering on
          spurious retransmissions due to CE being ambiguous will generally be
          vanishingly small.<a class="pilcrow" href="#appendix-B-5.6.4">¶</a></p>
</div>
        </dd>
<dd class="break"></dd>
<dt id="appendix-B-5.7">Insufficient anti-replay window in some pre-existing VPNs:</dt>
        <dd id="appendix-B-5.8" style="margin-left: 1.5em">If
          delay is reduced for a subset of the flows within a VPN, the
          anti-replay feature of some VPNs is known to potentially mistake the
          difference in delay for a replay attack. <a class="auto internal xref" href="#l4sid_VPN_anti-replay">Section 6.2</a> recommends that the anti-replay
          window at the VPN egress is sufficiently sized, as required by the
          relevant specifications.
   However, in some VPN implementations, the
          maximum anti-replay window is insufficient to cater for a large
          delay difference at prevailing packet rates. <a class="auto internal xref" href="#l4sid_VPN_anti-replay">Section 6.2</a> suggests alternative work-rounds
          for such cases, but end users using L4S over a VPN will need to be
          able to recognize the symptoms of this problem, in order to seek out
          these work-rounds.<a class="pilcrow" href="#appendix-B-5.8">¶</a>
</dd>
        <dd class="break"></dd>
<dt id="appendix-B-5.9">Hard to distinguish Classic ECN AQM:</dt>
        <dd id="appendix-B-5.10" style="margin-left: 1.5em">
          <p id="appendix-B-5.10.1">With this scheme,
          when a source receives ECN feedback, it is not explicitly clear
          which type of AQM generated the CE markings. This is not a problem
          for Classic ECN sources that send ECT(0) packets, because an L4S AQM
          will recognize the ECT(0) packets as Classic and apply the
          appropriate Classic ECN-marking behaviour.<a class="pilcrow" href="#appendix-B-5.10.1">¶</a></p>
<p id="appendix-B-5.10.2">However, in the absence of explicit disambiguation
          of the CE markings, an L4S source needs to use heuristic techniques
          to work out which type of congestion response to apply (see <a class="auto internal xref" href="#l4sid_sec_fallback_on_classic_CE">Appendix A.1.5</a>). 
          Otherwise, if
          long-running Classic flows are sharing a Classic ECN AQM
          bottleneck with long-running L4S flows, and the L4S flows apply an L4S
          response to the Classic CE signals, they would then outcompete the
          Classic flows. Experiments have shown that L4S flows can take
          about 20 times more capacity share than equivalent Classic flows.
          Nonetheless, as link capacity reduces (e.g., to 4 Mb/s), the
          inequality reduces. So Classic flows always make progress and are
          not starved.<a class="pilcrow" href="#appendix-B-5.10.2">¶</a></p>
<p id="appendix-B-5.10.3">When L4S was first proposed (in
          2015, 14 years after the Classic ECN spec <span>[<a class="cite xref" href="#RFC3168">RFC3168</a>]</span> was published), it was believed that Classic ECN
          AQMs had failed to be deployed because research measurements had
          found little or no evidence of CE marking. 
          In subsequent years,
          Classic ECN was included in FQ deployments;
          however, an FQ scheduler stops an L4S flow outcompeting Classic,
          because it enforces equality between flow rates. It is not known
          whether there have been any non-FQ deployments of Classic ECN AQMs
          in the subsequent years or whether there will be any in future.<a class="pilcrow" href="#appendix-B-5.10.3">¶</a></p>
<p id="appendix-B-5.10.4">An algorithm for detecting a Classic ECN AQM as soon
          as a flow stabilizes after start-up has been proposed <span>[<a class="cite xref" href="#ecn-fallback">ecn-fallback</a>]</span> (see <a class="auto internal xref" href="#l4sid_sec_fallback_on_classic_CE">Appendix A.1.5</a> for a brief summary).
          Testbed evaluations of v2 of the algorithm have shown detection is
          reasonably good for Classic ECN AQMs, in a wide range of
          circumstances. 
          However, although it can correctly detect an L4S ECN
          AQM in many circumstances, it is often incorrect at low link
          capacities and/or high RTTs. Although this is the safe way round,
          there is a danger that it will discourage use of the algorithm.<a class="pilcrow" href="#appendix-B-5.10.4">¶</a></p>
</dd>
        <dd class="break"></dd>
<dt id="appendix-B-5.11">Non-L4S service for control packets:</dt>
        <dd id="appendix-B-5.12" style="margin-left: 1.5em">Solely for the
          case of TCP, the Classic ECN RFCs <span>[<a class="cite xref" href="#RFC3168">RFC3168</a>]</span> and
          <span>[<a class="cite xref" href="#RFC5562">RFC5562</a>]</span> require a sender to clear the IP-ECN field to
          Not-ECT on retransmissions and on certain control packets,
          specifically pure ACKs, window probes, and SYNs. When L4S packets are
          classified by the IP-ECN field, these TCP control packets would not be
          classified into an L4S queue and could therefore be delayed
          relative to the other packets in the flow. This would not cause
          reordering (because retransmissions are already out of order, and
          these control packets typically carry no data). However, it would
          make critical TCP control packets more vulnerable to loss and delay.
          To address this problem, ECN++ <span>[<a class="cite xref" href="#I-D.ietf-tcpm-generalized-ecn">ECN++</a>]</span> proposes an experiment in
          which all TCP control packets and retransmissions are ECN-capable as
          long as appropriate ECN feedback is available in each case.<a class="pilcrow" href="#appendix-B-5.12">¶</a>
</dd>
      <dd class="break"></dd>
</dl>
<p id="appendix-B-6">Pros:<a class="pilcrow" href="#appendix-B-6">¶</a></p>
<span class="break"></span><dl class="dlParallel" id="appendix-B-7">
        <dt id="appendix-B-7.1">Should work end to end:</dt>
        <dd id="appendix-B-7.2" style="margin-left: 1.5em">The IP-ECN field generally propagates
          end to end across the Internet without being wiped or mangled, at
          least over fixed networks. Unlike the DSCP, the setting of the ECN
          field is at least meant to be forwarded unchanged by networks that
          do not support ECN.<a class="pilcrow" href="#appendix-B-7.2">¶</a>
</dd>
        <dd class="break"></dd>
<dt id="appendix-B-7.3">Should work in tunnels:</dt>
        <dd id="appendix-B-7.4" style="margin-left: 1.5em">The L4S identifiers work
          across and within any tunnel that propagates the IP-ECN field in any of
          the variant ways it has been defined since ECN-tunneling was first
          specified in the year 2001 <span>[<a class="cite xref" href="#RFC3168">RFC3168</a>]</span>. However,
          it is likely that some tunnels still do not implement ECN
          propagation at all.<a class="pilcrow" href="#appendix-B-7.4">¶</a>
</dd>
        <dd class="break"></dd>
<dt id="appendix-B-7.5">Should work for many link technologies:</dt>
        <dd id="appendix-B-7.6" style="margin-left: 1.5em">At most, but
          not all, path bottlenecks there is IP awareness, so that L4S AQMs
          can be located where the IP-ECN field can be manipulated.
          Bottlenecks at lower-layer nodes without IP awareness have to either use
          drop to signal congestion or have a specific congestion notification
          facility defined for that link technology, including
          propagation to and from IP-ECN. The programme to define these is
          progressing, and in each case so far, the scheme already defined for
          ECN inherently supports L4S as well (see <a class="auto internal xref" href="#l4sid_encaps_no_change">Section 6.1</a>).<a class="pilcrow" href="#appendix-B-7.6">¶</a>
</dd>
        <dd class="break"></dd>
<dt id="appendix-B-7.7">Could migrate to one codepoint:</dt>
        <dd id="appendix-B-7.8" style="margin-left: 1.5em">If all Classic ECN
          senders eventually evolve to use the L4S service, the ECT(0)
          codepoint could be reused for some future purpose but only once use
          of ECT(0) packets has reduced to zero, or near zero, which might
          never happen.<a class="pilcrow" href="#appendix-B-7.8">¶</a>
</dd>
        <dd class="break"></dd>
<dt id="appendix-B-7.9">L4 not required:</dt>
        <dd id="appendix-B-7.10" style="margin-left: 1.5em">Being based on the IP-ECN field, this
          scheme does not need the network to access transport-layer flow
          IDs. Nonetheless, it does not preclude solutions that
          do.<a class="pilcrow" href="#appendix-B-7.10">¶</a>
</dd>
      <dd class="break"></dd>
</dl>
</section>
</div>
<section id="appendix-C">
      <h2 id="name-potential-competing-uses-fo">
<a class="section-number selfRef" href="#appendix-C">Appendix C. </a><a class="section-name selfRef" href="#name-potential-competing-uses-fo">Potential Competing Uses for the ECT(1) Codepoint</a>
      </h2>
<p id="appendix-C-1">The ECT(1) codepoint of the IP-ECN field has already been assigned once
      for the ECN nonce spec <span>[<a class="cite xref" href="#RFC3540">RFC3540</a>]</span>, which has now been
      categorized as Historic <span>[<a class="cite xref" href="#RFC8311">RFC8311</a>]</span>. ECN is probably
      the only remaining field in the Internet Protocol that is common to IPv4
      and IPv6 and still has potential to work end to end, with tunnels and
      with lower layers. Therefore, ECT(1) should not be reassigned to a
      different experimental use (L4S) without carefully assessing competing
      potential uses. 
      These fall into the categories described below.<a class="pilcrow" href="#appendix-C-1">¶</a></p>
<div id="l4sid_competing_integrity">
<section id="appendix-C.1">
        <h3 id="name-integrity-of-congestion-fee">
<a class="section-number selfRef" href="#appendix-C.1">C.1. </a><a class="section-name selfRef" href="#name-integrity-of-congestion-fee">Integrity of Congestion Feedback</a>
        </h3>
<p id="appendix-C.1-1">Receiving hosts can fool a sender into downloading faster by
        suppressing feedback of ECN marks (or of losses if retransmissions are
        not necessary or available otherwise).<a class="pilcrow" href="#appendix-C.1-1">¶</a></p>
<p id="appendix-C.1-2">The Historic ECN nonce spec <span>[<a class="cite xref" href="#RFC3540">RFC3540</a>]</span>
        proposed that a TCP sender could set either ECT(0) or ECT(1) in
        each packet of a flow and remember the sequence it had set. If any
        packet was lost or congestion marked, the receiver would miss that bit
        of the sequence. An ECN nonce receiver had to feed back the least-significant
        bit of the sum, so it could not suppress feedback of a
        loss or mark without a 50-50 chance of guessing the sum
        incorrectly.<a class="pilcrow" href="#appendix-C.1-2">¶</a></p>
<p id="appendix-C.1-3">It is highly unlikely that ECT(1) will be needed as a nonce for
        integrity protection of congestion notifications in future. The ECN
        nonce spec <span>[<a class="cite xref" href="#RFC3540">RFC3540</a>]</span> has been reclassified as
        Historic, partly because other ways (that do not consume a codepoint
        in the IP header) have been developed to protect feedback integrity of
        TCP and other transports <span>[<a class="cite xref" href="#RFC8311">RFC8311</a>]</span>. For
        instance:<a class="pilcrow" href="#appendix-C.1-3">¶</a></p>
<ul class="normal">
<li class="normal" id="appendix-C.1-4.1">The sender can test the integrity of a small random sample of
            the receiver's feedback by occasionally setting the IP-ECN field
            to a value normally only set by the network. 
            Then, it can test
            whether the receiver's feedback faithfully reports what it expects
            (see Paragraph 2 of <span><a class="relref" href="https://www.rfc-editor.org/rfc/rfc3168#section-20.2">Section 20.2</a> of the ECN spec [<a class="cite xref" href="#RFC3168">RFC3168</a>]</span>. This works for loss, and it will work for the
            accurate ECN feedback <span>[<a class="cite xref" href="#RFC7560">RFC7560</a>]</span> intended for
            L4S. Like the (Historic) ECN nonce spec, this technique does not
            protect against a misbehaving sender. But it allows a well-behaved
            sender to check that each receiver is correctly feeding back
            congestion notifications.<a class="pilcrow" href="#appendix-C.1-4.1">¶</a>
</li>
          <li class="normal" id="appendix-C.1-4.2">A network can check that its ECN markings (or packet losses)
            have been passed correctly around the full feedback loop by
            auditing Congestion Exposure (ConEx) <span>[<a class="cite xref" href="#RFC7713">RFC7713</a>]</span>. This assures that the integrity of congestion
            notifications and feedback messages must have both been preserved.
            ConEx information is also available anywhere along the network
            path, so it can be used to enforce a congestion response. Whether
            the receiver or a downstream network is suppressing congestion
            feedback or the sender is unresponsive to the feedback, or both,
            ConEx is intended to neutralize any advantage that any of these
            three parties would otherwise gain.<a class="pilcrow" href="#appendix-C.1-4.2">¶</a>
</li>
          <li class="normal" id="appendix-C.1-4.3">Congestion feedback fields in transport-layer headers are
            immutable end to end and therefore amenable to end-to-end
            integrity protection. This preserves the integrity of a receiver's
            feedback messages to the sender, but it does not protect against
            misbehaving receivers or misbehaving senders. The TCP
            Authentication Option (TCP-AO) <span>[<a class="cite xref" href="#RFC5925">RFC5925</a>]</span>,
            QUIC's end-to-end protection <span>[<a class="cite xref" href="#RFC9001">RFC9001</a>]</span>, or
            end-to-end IPsec integrity protection <span>[<a class="cite xref" href="#RFC4303">RFC4303</a>]</span> can
            be used to detect any tampering with congestion feedback (whether
            malicious or accidental), respectively, in TCP, QUIC, or any
            transport. TCP-AO covers the main TCP header and TCP options by
            default, but it is often too brittle to use on many end-to-end
            paths, where middleboxes can make verification fail in their
            attempts to improve performance or security, e.g., by
            resegmentation or shifting the sequence space.<a class="pilcrow" href="#appendix-C.1-4.3">¶</a>
</li>
        </ul>
<p id="appendix-C.1-5">At the time of writing, it is becoming common to protect the
        integrity of transport feedback using QUIC. However, it is still not
        common to protect the integrity of the wider congestion feedback loop,
        whether based on loss or Classic ECN. If this position changes during
        the L4S experiment, one or more of the above techniques might need to
        be developed and deployed.<a class="pilcrow" href="#appendix-C.1-5">¶</a></p>
</section>
</div>
<section id="appendix-C.2">
        <h3 id="name-notification-of-less-severe">
<a class="section-number selfRef" href="#appendix-C.2">C.2. </a><a class="section-name selfRef" href="#name-notification-of-less-severe">Notification of Less Severe Congestion than CE</a>
        </h3>
<p id="appendix-C.2-1">Various researchers have proposed to use ECT(1) as a less severe
        congestion notification than CE, particularly to enable flows to fill
        available capacity more quickly after an idle period, when another
        flow departs or when a flow starts, e.g., the Variable-structure congestion Control Protocol (VCP) <span>[<a class="cite xref" href="#VCP">VCP</a>]</span> and Queue View (QV) <span>[<a class="cite xref" href="#QV">QV</a>]</span>.<a class="pilcrow" href="#appendix-C.2-1">¶</a></p>
<p id="appendix-C.2-2">Before assigning ECT(1) as an identifier for L4S, we must carefully
        consider whether it might be better to hold ECT(1) in reserve for
        future standardization of rapid flow acceleration, which is an
        important and enduring problem <span>[<a class="cite xref" href="#RFC6077">RFC6077</a>]</span>.<a class="pilcrow" href="#appendix-C.2-2">¶</a></p>
<p id="appendix-C.2-3">Pre-Congestion Notification (PCN) is another scheme that assigns
        alternative semantics to the IP-ECN field. It uses ECT(1) to signify a
        less severe level of pre-congestion notification than CE <span>[<a class="cite xref" href="#RFC6660">RFC6660</a>]</span>. However, the IP-ECN field only takes on the PCN
        semantics if packets carry a Diffserv codepoint defined to indicate
        PCN marking within a controlled environment. PCN is required to be
        applied solely to the outer header of a tunnel across the controlled
        region in order not to interfere with any end-to-end use of the ECN
        field. Therefore, a PCN region on the path would not interfere with
        the L4S service identifier defined in <a class="auto internal xref" href="#l4sid_identification">Section 2</a>.<a class="pilcrow" href="#appendix-C.2-3">¶</a></p>
</section>
</section>
<section id="appendix-D">
      <h2 id="name-acknowledgements">
<a class="section-name selfRef" href="#name-acknowledgements">Acknowledgements</a>
      </h2>
<p id="appendix-D-1">Thanks to <span class="contact-name">Richard Scheffenegger</span>, <span class="contact-name">John Leslie</span>, <span class="contact-name">David Täht</span>, <span class="contact-name">Jonathan Morton</span>, <span class="contact-name">Gorry Fairhurst</span>,
    <span class="contact-name">Michael Welzl</span>, <span class="contact-name">Mikael     Abrahamsson</span>, and <span class="contact-name">Andrew McGregor</span> for the
    discussions that led to this specification.  <span class="contact-name">Ing-jyh     (Inton) Tsang</span> was a contributor to the early draft versions of this
    document. Thanks to <span class="contact-name">Mikael Abrahamsson</span>, <span class="contact-name">Lloyd Wood</span>, <span class="contact-name">Nicolas Kuhn</span>, <span class="contact-name">Greg White</span>, <span class="contact-name">Tom Henderson</span>, <span class="contact-name">David Black</span>, <span class="contact-name">Gorry Fairhurst</span>, <span class="contact-name">Brian Carpenter</span>, <span class="contact-name">Jake Holland</span>, <span class="contact-name">Rod Grimes</span>, <span class="contact-name">Richard Scheffenegger</span>,
    <span class="contact-name">Sebastian Moeller</span>, <span class="contact-name">Neal     Cardwell</span>, <span class="contact-name">Praveen Balasubramanian</span>, <span class="contact-name">Reza Marandian Hagh</span>, <span class="contact-name">Pete Heist</span>,
    <span class="contact-name">Stuart Cheshire</span>, <span class="contact-name">Vidhi Goel</span>,
    <span class="contact-name">Mirja Kühlewind</span>, <span class="contact-name">Ermin Sakic</span>,
    and <span class="contact-name">Martin Duke</span> for providing help and reviewing
    this document. And thanks to <span class="contact-name">Ingemar Johansson</span> for
    reviewing and providing substantial text. Thanks also to the area
    reviewers: <span class="contact-name">Valery Smyslov</span>, <span class="contact-name">Maria     Ines Robles</span>, <span class="contact-name">Bernard Aboba</span>, <span class="contact-name">Lars Eggert</span>, <span class="contact-name">Roman Danyliw</span>, and <span class="contact-name">Éric Vyncke</span>.  Thanks to <span class="contact-name">Sebastian     Moeller</span> for identifying the interaction with VPN anti-replay and to
    <span class="contact-name">Jonathan Morton</span> for identifying the attack based on
    this. Particular thanks to tsvwg chairs <span class="contact-name">Gorry     Fairhurst</span>, <span class="contact-name">David Black</span>, and <span class="contact-name">Wes     Eddy</span> for patiently helping this and the other L4S documents through the
    IETF process. <a class="auto internal xref" href="#l4sps_tcp-prague-reqs">Appendix A</a>, which lists the Prague L4S Requirements, is based on text authored by <span class="contact-name">Marcelo Bagnulo Braun</span> that was originally an appendix to
    <span>[<a class="cite xref" href="#RFC9330">RFC9330</a>]</span>.  That text was in turn based on
    the collective output of the attendees listed in the minutes of a 'bar
    BoF' on DCTCP Evolution during IETF 94 <span>[<a class="cite xref" href="#TCPPrague">TCPPrague</a>]</span>.<a class="pilcrow" href="#appendix-D-1">¶</a></p>
<p id="appendix-D-2">The authors' contributions were partly funded by
    the European Community under its Seventh Framework Programme through the
    Reducing Internet Transport Latency (RITE) project (ICT-317700). The
    contribution of <span class="contact-name">Koen De Schepper</span> was also
    partly funded by the 5Growth and DAEMON EU H2020 projects. <span class="contact-name">Bob Briscoe</span> was partly funded by the Research Council of
    Norway through the TimeIn project, CableLabs, and the
    Comcast Innovation Fund. The views expressed here are solely those of the
    authors.<a class="pilcrow" href="#appendix-D-2">¶</a></p>
</section>
<div id="authors-addresses">
<section id="appendix-E">
      <h2 id="name-authors-addresses">
<a class="section-name selfRef" href="#name-authors-addresses">Authors' Addresses</a>
      </h2>
<address class="vcard">
        <div class="left" dir="auto"><span class="fn nameRole">Koen De Schepper</span></div>
<div class="left" dir="auto"><span class="org">Nokia Bell Labs</span></div>
<div class="left" dir="auto"><span class="locality">Antwerp</span></div>
<div class="left" dir="auto"><span class="country-name">Belgium</span></div>
<div class="email">
<span>Email:</span>
<a class="email" href="mailto:koen.de_schepper@nokia.com">koen.de_schepper@nokia.com</a>
</div>
<div class="url">
<span>URI:</span>
<a class="url" href="https://www.bell-labs.com/about/researcher-profiles/koende_schepper/">https://www.bell-labs.com/about/researcher-profiles/koende_schepper/</a>
</div>
</address>
<address class="vcard">
        <div class="left" dir="auto"><span class="fn nameRole">Bob Briscoe (<span class="role">editor</span>)</span></div>
<div class="left" dir="auto"><span class="org">Independent</span></div>
<div class="left" dir="auto"><span class="country-name">United Kingdom</span></div>
<div class="email">
<span>Email:</span>
<a class="email" href="mailto:ietf@bobbriscoe.net">ietf@bobbriscoe.net</a>
</div>
<div class="url">
<span>URI:</span>
<a class="url" href="https://bobbriscoe.net/">https://bobbriscoe.net/</a>
</div>
</address>
</section>
</div>
<script>const toc = document.getElementById("toc");
toc.querySelector("h2").addEventListener("click", e => {
  toc.classList.toggle("active");
});
toc.querySelector("nav").addEventListener("click", e => {
  toc.classList.remove("active");
});
</script>


</body></html>