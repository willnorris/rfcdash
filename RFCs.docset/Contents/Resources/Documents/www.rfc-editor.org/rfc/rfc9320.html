<!DOCTYPE html>
<html class="RFC" lang="en"><head>
<meta charset="utf-8"/>
<meta content="Common,Latin" name="scripts"/>
<meta content="initial-scale=1.0" name="viewport"/>
<title>RFC 9320: Deterministic Networking (DetNet) Bounded Latency</title>
<meta content="Norman Finn" name="author"/>
<meta content="Jean-Yves Le Boudec" name="author"/>
<meta content="Ehsan Mohammadpour" name="author"/>
<meta content="Jiayi Zhang" name="author"/>
<meta content="Balázs Varga" name="author"/>
<meta content="
       
        This document presents a timing model for sources, destinations, and Deterministic Networking (DetNet) transit nodes. Using the model, it provides a methodology to compute end-to-end latency and backlog bounds for various queuing methods. The methodology can be used by the management and control planes and by resource reservation algorithms to provide bounded latency and zero congestion loss for the DetNet service. 
       
    " name="description"/>
<meta content="xml2rfc 3.15.2" name="generator"/>
<meta content="DetNet" name="keyword"/>
<meta content="bounded latency" name="keyword"/>
<meta content="zero congestion loss" name="keyword"/>
<meta content="9320" name="rfc.number"/>
<!-- Generator version information:
  xml2rfc 3.15.2
    Python 3.9.14
    appdirs 1.4.4
    ConfigArgParse 1.5.3
    google-i18n-address 2.5.1
    html5lib 1.1
    intervaltree 3.1.0
    Jinja2 3.1.2
    lxml 4.9.0
    MarkupSafe 2.1.1
    pycountry 22.3.5
    PyYAML 6.0
    requests 2.28.0
    setuptools 44.1.1
    six 1.16.0
    wcwidth 0.2.5
    weasyprint 56.1
-->
<link href="rfc9320.xml" rel="alternate" type="application/rfc+xml"/>
<link href="#copyright" rel="license"/>
<style type="text/css">/*

  NOTE: Changes at the bottom of this file overrides some earlier settings.

  Once the style has stabilized and has been adopted as an official RFC style,
  this can be consolidated so that style settings occur only in one place, but
  for now the contents of this file consists first of the initial CSS work as
  provided to the RFC Formatter (xml2rfc) work, followed by itemized and
  commented changes found necessary during the development of the v3
  formatters.

*/

/* fonts */
@import url('https://fonts.googleapis.com/css?family=Noto+Sans'); /* Sans-serif */
@import url('https://fonts.googleapis.com/css?family=Noto+Serif'); /* Serif (print) */
@import url('https://fonts.googleapis.com/css?family=Roboto+Mono'); /* Monospace */

@viewport {
  zoom: 1.0;
  width: extend-to-zoom;
}
@-ms-viewport {
  width: extend-to-zoom;
  zoom: 1.0;
}
/* general and mobile first */
html {
}
body {
  max-width: 90%;
  margin: 1.5em auto;
  color: #222;
  background-color: #fff;
  font-size: 14px;
  font-family: 'Noto Sans', Arial, Helvetica, sans-serif;
  line-height: 1.6;
  scroll-behavior: smooth;
}
.ears {
  display: none;
}

/* headings */
#title, h1, h2, h3, h4, h5, h6 {
  margin: 1em 0 0.5em;
  font-weight: bold;
  line-height: 1.3;
}
#title {
  clear: both;
  border-bottom: 1px solid #ddd;
  margin: 0 0 0.5em 0;
  padding: 1em 0 0.5em;
}
.author {
  padding-bottom: 4px;
}
h1 {
  font-size: 26px;
  margin: 1em 0;
}
h2 {
  font-size: 22px;
  margin-top: -20px;  /* provide offset for in-page anchors */
  padding-top: 33px;
}
h3 {
  font-size: 18px;
  margin-top: -36px;  /* provide offset for in-page anchors */
  padding-top: 42px;
}
h4 {
  font-size: 16px;
  margin-top: -36px;  /* provide offset for in-page anchors */
  padding-top: 42px;
}
h5, h6 {
  font-size: 14px;
}
#n-copyright-notice {
  border-bottom: 1px solid #ddd;
  padding-bottom: 1em;
  margin-bottom: 1em;
}
/* general structure */
p {
  padding: 0;
  margin: 0 0 1em 0;
  text-align: left;
}
div, span {
  position: relative;
}
div {
  margin: 0;
}
.alignRight.art-text {
  background-color: #f9f9f9;
  border: 1px solid #eee;
  border-radius: 3px;
  padding: 1em 1em 0;
  margin-bottom: 1.5em;
}
.alignRight.art-text pre {
  padding: 0;
}
.alignRight {
  margin: 1em 0;
}
.alignRight > *:first-child {
  border: none;
  margin: 0;
  float: right;
  clear: both;
}
.alignRight > *:nth-child(2) {
  clear: both;
  display: block;
  border: none;
}
svg {
  display: block;
}
.alignCenter.art-text {
  background-color: #f9f9f9;
  border: 1px solid #eee;
  border-radius: 3px;
  padding: 1em 1em 0;
  margin-bottom: 1.5em;
}
.alignCenter.art-text pre {
  padding: 0;
}
.alignCenter {
  margin: 1em 0;
}
.alignCenter > *:first-child {
  display: table;
  border: none;
  margin: 0 auto;
}

/* lists */
ol, ul {
  padding: 0;
  margin: 0 0 1em 2em;
}
ol ol, ul ul, ol ul, ul ol {
  margin-left: 1em;
}
li {
  margin: 0 0 0.25em 0;
}
.ulCompact li {
  margin: 0;
}
ul.empty, .ulEmpty {
  list-style-type: none;
}
ul.empty li, .ulEmpty li {
  margin-top: 0.5em;
}
ul.ulBare, li.ulBare {
  margin-left: 0em !important;
}
ul.compact, .ulCompact,
ol.compact, .olCompact {
  line-height: 100%;
  margin: 0 0 0 2em;
}

/* definition lists */
dl {
}
dl > dt {
  float: left;
  margin-right: 1em;
}
/* 
dl.nohang > dt {
  float: none;
}
*/
dl > dd {
  margin-bottom: .8em;
  min-height: 1.3em;
}
dl.compact > dd, .dlCompact > dd {
  margin-bottom: 0em;
}
dl > dd > dl {
  margin-top: 0.5em;
  margin-bottom: 0em;
}

/* links */
a {
  text-decoration: none;
}
a[href] {
  color: #22e; /* Arlen: WCAG 2019 */
}
a[href]:hover {
  background-color: #f2f2f2;
}
figcaption a[href],
a[href].selfRef {
  color: #222;
}
/* XXX probably not this:
a.selfRef:hover {
  background-color: transparent;
  cursor: default;
} */

/* Figures */
tt, code, pre {
  background-color: #f9f9f9;
  font-family: 'Roboto Mono', monospace;
}
pre {
  border: 1px solid #eee;
  margin: 0;
  padding: 1em;
}
img {
  max-width: 100%;
}
figure {
  margin: 0;
}
figure blockquote {
  margin: 0.8em 0.4em 0.4em;
}
figcaption {
  font-style: italic;
  margin: 0 0 1em 0;
}
@media screen {
  pre {
    overflow-x: auto;
    max-width: 100%;
    max-width: calc(100% - 22px);
  }
}

/* aside, blockquote */
aside, blockquote {
  margin-left: 0;
  padding: 1.2em 2em;
}
blockquote {
  background-color: #f9f9f9;
  color: #111; /* Arlen: WCAG 2019 */
  border: 1px solid #ddd;
  border-radius: 3px;
  margin: 1em 0;
}
cite {
  display: block;
  text-align: right;
  font-style: italic;
}

/* tables */
table {
  width: 100%;
  margin: 0 0 1em;
  border-collapse: collapse;
  border: 1px solid #eee;
}
th, td {
  text-align: left;
  vertical-align: top;
  padding: 0.5em 0.75em;
}
th {
  text-align: left;
  background-color: #e9e9e9;
}
tr:nth-child(2n+1) > td {
  background-color: #f5f5f5;
}
table caption {
  font-style: italic;
  margin: 0;
  padding: 0;
  text-align: left;
}
table p {
  /* XXX to avoid bottom margin on table row signifiers. If paragraphs should
     be allowed within tables more generally, it would be far better to select on a class. */
  margin: 0;
}

/* pilcrow */
a.pilcrow {
  color: #666; /* Arlen: AHDJ 2019 */
  text-decoration: none;
  visibility: hidden;
  user-select: none;
  -ms-user-select: none;
  -o-user-select:none;
  -moz-user-select: none;
  -khtml-user-select: none;
  -webkit-user-select: none;
  -webkit-touch-callout: none;
}
@media screen {
  aside:hover > a.pilcrow,
  p:hover > a.pilcrow,
  blockquote:hover > a.pilcrow,
  div:hover > a.pilcrow,
  li:hover > a.pilcrow,
  pre:hover > a.pilcrow {
    visibility: visible;
  }
  a.pilcrow:hover {
    background-color: transparent;
  }
}

/* misc */
hr {
  border: 0;
  border-top: 1px solid #eee;
}
.bcp14 {
  font-variant: small-caps;
}

.role {
  font-variant: all-small-caps;
}

/* info block */
#identifiers {
  margin: 0;
  font-size: 0.9em;
}
#identifiers dt {
  width: 3em;
  clear: left;
}
#identifiers dd {
  float: left;
  margin-bottom: 0;
}
/* Fix PDF info block run off issue */
@media print {
  #identifiers dd {
    float: none;
  }
}
#identifiers .authors .author {
  display: inline-block;
  margin-right: 1.5em;
}
#identifiers .authors .org {
  font-style: italic;
}

/* The prepared/rendered info at the very bottom of the page */
.docInfo {
  color: #666; /* Arlen: WCAG 2019 */
  font-size: 0.9em;
  font-style: italic;
  margin-top: 2em;
}
.docInfo .prepared {
  float: left;
}
.docInfo .prepared {
  float: right;
}

/* table of contents */
#toc  {
  padding: 0.75em 0 2em 0;
  margin-bottom: 1em;
}
nav.toc ul {
  margin: 0 0.5em 0 0;
  padding: 0;
  list-style: none;
}
nav.toc li {
  line-height: 1.3em;
  margin: 0.75em 0;
  padding-left: 1.2em;
  text-indent: -1.2em;
}
/* references */
.references dt {
  text-align: right;
  font-weight: bold;
  min-width: 7em;
}
.references dd {
  margin-left: 8em;
  overflow: auto;
}

.refInstance {
  margin-bottom: 1.25em;
}

.references .ascii {
  margin-bottom: 0.25em;
}

/* index */
.index ul {
  margin: 0 0 0 1em;
  padding: 0;
  list-style: none;
}
.index ul ul {
  margin: 0;
}
.index li {
  margin: 0;
  text-indent: -2em;
  padding-left: 2em;
  padding-bottom: 5px;
}
.indexIndex {
  margin: 0.5em 0 1em;
}
.index a {
  font-weight: 700;
}
/* make the index two-column on all but the smallest screens */
@media (min-width: 600px) {
  .index ul {
    -moz-column-count: 2;
    -moz-column-gap: 20px;
  }
  .index ul ul {
    -moz-column-count: 1;
    -moz-column-gap: 0;
  }
}

/* authors */
address.vcard {
  font-style: normal;
  margin: 1em 0;
}

address.vcard .nameRole {
  font-weight: 700;
  margin-left: 0;
}
address.vcard .label {
  font-family: "Noto Sans",Arial,Helvetica,sans-serif;
  margin: 0.5em 0;
}
address.vcard .type {
  display: none;
}
.alternative-contact {
  margin: 1.5em 0 1em;
}
hr.addr {
  border-top: 1px dashed;
  margin: 0;
  color: #ddd;
  max-width: calc(100% - 16px);
}

/* temporary notes */
.rfcEditorRemove::before {
  position: absolute;
  top: 0.2em;
  right: 0.2em;
  padding: 0.2em;
  content: "The RFC Editor will remove this note";
  color: #9e2a00; /* Arlen: WCAG 2019 */
  background-color: #ffd; /* Arlen: WCAG 2019 */
}
.rfcEditorRemove {
  position: relative;
  padding-top: 1.8em;
  background-color: #ffd; /* Arlen: WCAG 2019 */
  border-radius: 3px;
}
.cref {
  background-color: #ffd; /* Arlen: WCAG 2019 */
  padding: 2px 4px;
}
.crefSource {
  font-style: italic;
}
/* alternative layout for smaller screens */
@media screen and (max-width: 1023px) {
  body {
    padding-top: 2em;
  }
  #title {
    padding: 1em 0;
  }
  h1 {
    font-size: 24px;
  }
  h2 {
    font-size: 20px;
    margin-top: -18px;  /* provide offset for in-page anchors */
    padding-top: 38px;
  }
  #identifiers dd {
    max-width: 60%;
  }
  #toc {
    position: fixed;
    z-index: 2;
    top: 0;
    right: 0;
    padding: 0;
    margin: 0;
    background-color: inherit;
    border-bottom: 1px solid #ccc;
  }
  #toc h2 {
    margin: -1px 0 0 0;
    padding: 4px 0 4px 6px;
    padding-right: 1em;
    min-width: 190px;
    font-size: 1.1em;
    text-align: right;
    background-color: #444;
    color: white;
    cursor: pointer;
  }
  #toc h2::before { /* css hamburger */
    float: right;
    position: relative;
    width: 1em;
    height: 1px;
    left: -164px;
    margin: 6px 0 0 0;
    background: white none repeat scroll 0 0;
    box-shadow: 0 4px 0 0 white, 0 8px 0 0 white;
    content: "";
  }
  #toc nav {
    display: none;
    padding: 0.5em 1em 1em;
    overflow: auto;
    height: calc(100vh - 48px);
    border-left: 1px solid #ddd;
  }
}

/* alternative layout for wide screens */
@media screen and (min-width: 1024px) {
  body {
    max-width: 724px;
    margin: 42px auto;
    padding-left: 1.5em;
    padding-right: 29em;
  }
  #toc {
    position: fixed;
    top: 42px;
    right: 42px;
    width: 25%;
    margin: 0;
    padding: 0 1em;
    z-index: 1;
  }
  #toc h2 {
    border-top: none;
    border-bottom: 1px solid #ddd;
    font-size: 1em;
    font-weight: normal;
    margin: 0;
    padding: 0.25em 1em 1em 0;
  }
  #toc nav {
    display: block;
    height: calc(90vh - 84px);
    bottom: 0;
    padding: 0.5em 0 0;
    overflow: auto;
  }
  img { /* future proofing */
    max-width: 100%;
    height: auto;
  }
}

/* pagination */
@media print {
  body {

    width: 100%;
  }
  p {
    orphans: 3;
    widows: 3;
  }
  #n-copyright-notice {
    border-bottom: none;
  }
  #toc, #n-introduction {
    page-break-before: always;
  }
  #toc {
    border-top: none;
    padding-top: 0;
  }
  figure, pre {
    page-break-inside: avoid;
  }
  figure {
    overflow: scroll;
  }
  pre.breakable {
    break-inside: auto;
  }
  h1, h2, h3, h4, h5, h6 {
    page-break-after: avoid;
  }
  h2+*, h3+*, h4+*, h5+*, h6+* {
    page-break-before: avoid;
  }
  pre {
    white-space: pre-wrap;
    word-wrap: break-word;
    font-size: 10pt;
  }
  table {
    border: 1px solid #ddd;
  }
  td {
    border-top: 1px solid #ddd;
  }
}

/* This is commented out here, as the string-set: doesn't
   pass W3C validation currently */
/*
.ears thead .left {
  string-set: ears-top-left content();
}

.ears thead .center {
  string-set: ears-top-center content();
}

.ears thead .right {
  string-set: ears-top-right content();
}

.ears tfoot .left {
  string-set: ears-bottom-left content();
}

.ears tfoot .center {
  string-set: ears-bottom-center content();
}

.ears tfoot .right {
  string-set: ears-bottom-right content();
}
*/

@page :first {
  padding-top: 0;
  @top-left {
    content: normal;
    border: none;
  }
  @top-center {
    content: normal;
    border: none;
  }
  @top-right {
    content: normal;
    border: none;
  }
}

@page {
  size: A4;
  margin-bottom: 45mm;
  padding-top: 20px;
  /* The following is commented out here, but set appropriately by in code, as
     the content depends on the document */
  /*
  @top-left {
    content: 'Internet-Draft';
    vertical-align: bottom;
    border-bottom: solid 1px #ccc;
  }
  @top-left {
    content: string(ears-top-left);
    vertical-align: bottom;
    border-bottom: solid 1px #ccc;
  }
  @top-center {
    content: string(ears-top-center);
    vertical-align: bottom;
    border-bottom: solid 1px #ccc;
  }
  @top-right {
    content: string(ears-top-right);
    vertical-align: bottom;
    border-bottom: solid 1px #ccc;
  }
  @bottom-left {
    content: string(ears-bottom-left);
    vertical-align: top;
    border-top: solid 1px #ccc;
  }
  @bottom-center {
    content: string(ears-bottom-center);
    vertical-align: top;
    border-top: solid 1px #ccc;
  }
  @bottom-right {
      content: '[Page ' counter(page) ']';
      vertical-align: top;
      border-top: solid 1px #ccc;
  }
  */

}

/* Changes introduced to fix issues found during implementation */
/* Make sure links are clickable even if overlapped by following H* */
a {
  z-index: 2;
}
/* Separate body from document info even without intervening H1 */
section {
  clear: both;
}


/* Top align author divs, to avoid names without organization dropping level with org names */
.author {
  vertical-align: top;
}

/* Leave room in document info to show Internet-Draft on one line */
#identifiers dt {
  width: 8em;
}

/* Don't waste quite as much whitespace between label and value in doc info */
#identifiers dd {
  margin-left: 1em;
}

/* Give floating toc a background color (needed when it's a div inside section */
#toc {
  background-color: white;
}

/* Make the collapsed ToC header render white on gray also when it's a link */
@media screen and (max-width: 1023px) {
  #toc h2 a,
  #toc h2 a:link,
  #toc h2 a:focus,
  #toc h2 a:hover,
  #toc a.toplink,
  #toc a.toplink:hover {
    color: white;
    background-color: #444;
    text-decoration: none;
  }
}

/* Give the bottom of the ToC some whitespace */
@media screen and (min-width: 1024px) {
  #toc {
    padding: 0 0 1em 1em;
  }
}

/* Style section numbers with more space between number and title */
.section-number {
  padding-right: 0.5em;
}

/* prevent monospace from becoming overly large */
tt, code, pre {
  font-size: 95%;
}

/* Fix the height/width aspect for ascii art*/
pre.sourcecode,
.art-text pre {
  line-height: 1.12;
}


/* Add styling for a link in the ToC that points to the top of the document */
a.toplink {
  float: right;
  margin-right: 0.5em;
}

/* Fix the dl styling to match the RFC 7992 attributes */
dl > dt,
dl.dlParallel > dt {
  float: left;
  margin-right: 1em;
}
dl.dlNewline > dt {
  float: none;
}

/* Provide styling for table cell text alignment */
table td.text-left,
table th.text-left {
  text-align: left;
}
table td.text-center,
table th.text-center {
  text-align: center;
}
table td.text-right,
table th.text-right {
  text-align: right;
}

/* Make the alternative author contact information look less like just another
   author, and group it closer with the primary author contact information */
.alternative-contact {
  margin: 0.5em 0 0.25em 0;
}
address .non-ascii {
  margin: 0 0 0 2em;
}

/* With it being possible to set tables with alignment
  left, center, and right, { width: 100%; } does not make sense */
table {
  width: auto;
}

/* Avoid reference text that sits in a block with very wide left margin,
   because of a long floating dt label.*/
.references dd {
  overflow: visible;
}

/* Control caption placement */
caption {
  caption-side: bottom;
}

/* Limit the width of the author address vcard, so names in right-to-left
   script don't end up on the other side of the page. */

address.vcard {
  max-width: 30em;
  margin-right: auto;
}

/* For address alignment dependent on LTR or RTL scripts */
address div.left {
  text-align: left;
}
address div.right {
  text-align: right;
}

/* Provide table alignment support.  We can't use the alignX classes above
   since they do unwanted things with caption and other styling. */
table.right {
 margin-left: auto;
 margin-right: 0;
}
table.center {
 margin-left: auto;
 margin-right: auto;
}
table.left {
 margin-left: 0;
 margin-right: auto;
}

/* Give the table caption label the same styling as the figcaption */
caption a[href] {
  color: #222;
}

@media print {
  .toplink {
    display: none;
  }

  /* avoid overwriting the top border line with the ToC header */
  #toc {
    padding-top: 1px;
  }

  /* Avoid page breaks inside dl and author address entries */
  .vcard {
    page-break-inside: avoid;
  }

}
/* Tweak the bcp14 keyword presentation */
.bcp14 {
  font-variant: small-caps;
  font-weight: bold;
  font-size: 0.9em;
}
/* Tweak the invisible space above H* in order not to overlay links in text above */
 h2 {
  margin-top: -18px;  /* provide offset for in-page anchors */
  padding-top: 31px;
 }
 h3 {
  margin-top: -18px;  /* provide offset for in-page anchors */
  padding-top: 24px;
 }
 h4 {
  margin-top: -18px;  /* provide offset for in-page anchors */
  padding-top: 24px;
 }
/* Float artwork pilcrow to the right */
@media screen {
  .artwork a.pilcrow {
    display: block;
    line-height: 0.7;
    margin-top: 0.15em;
  }
}
/* Make pilcrows on dd visible */
@media screen {
  dd:hover > a.pilcrow {
    visibility: visible;
  }
}
/* Make the placement of figcaption match that of a table's caption
   by removing the figure's added bottom margin */
.alignLeft.art-text,
.alignCenter.art-text,
.alignRight.art-text {
   margin-bottom: 0;
}
.alignLeft,
.alignCenter,
.alignRight {
  margin: 1em 0 0 0;
}
/* In print, the pilcrow won't show on hover, so prevent it from taking up space,
   possibly even requiring a new line */
@media print {
  a.pilcrow {
    display: none;
  }
}
/* Styling for the external metadata */
div#external-metadata {
  background-color: #eee;
  padding: 0.5em;
  margin-bottom: 0.5em;
  display: none;
}
div#internal-metadata {
  padding: 0.5em;                       /* to match the external-metadata padding */
}
/* Styling for title RFC Number */
h1#rfcnum {
  clear: both;
  margin: 0 0 -1em;
  padding: 1em 0 0 0;
}
/* Make .olPercent look the same as <ol><li> */
dl.olPercent > dd {
  margin-bottom: 0.25em;
  min-height: initial;
}
/* Give aside some styling to set it apart */
aside {
  border-left: 1px solid #ddd;
  margin: 1em 0 1em 2em;
  padding: 0.2em 2em;
}
aside > dl,
aside > ol,
aside > ul,
aside > table,
aside > p {
  margin-bottom: 0.5em;
}
/* Additional page break settings */
@media print {
  figcaption, table caption {
    page-break-before: avoid;
  }
}
/* Font size adjustments for print */
@media print {
  body  { font-size: 10pt;      line-height: normal; max-width: 96%; }
  h1    { font-size: 1.72em;    padding-top: 1.5em; } /* 1*1.2*1.2*1.2 */
  h2    { font-size: 1.44em;    padding-top: 1.5em; } /* 1*1.2*1.2 */
  h3    { font-size: 1.2em;     padding-top: 1.5em; } /* 1*1.2 */
  h4    { font-size: 1em;       padding-top: 1.5em; }
  h5, h6 { font-size: 1em;      margin: initial; padding: 0.5em 0 0.3em; }
}
/* Sourcecode margin in print, when there's no pilcrow */
@media print {
  .artwork,
  .artwork > pre,
  .sourcecode {
    margin-bottom: 1em;
  }
}
/* Avoid narrow tables forcing too narrow table captions, which may render badly */
table {
  min-width: 20em;
}
/* ol type a */
ol.type-a { list-style-type: lower-alpha; }
ol.type-A { list-style-type: upper-alpha; }
ol.type-i { list-style-type: lower-roman; }
ol.type-I { list-style-type: lower-roman; }
/* Apply the print table and row borders in general, on request from the RPC,
and increase the contrast between border and odd row background slightly */
table {
  border: 1px solid #ddd;
}
td {
  border-top: 1px solid #ddd;
}
tr {
  break-inside: avoid;
}
tr:nth-child(2n+1) > td {
  background-color: #f8f8f8;
}
/* Use style rules to govern display of the TOC. */
@media screen and (max-width: 1023px) {
  #toc nav { display: none; }
  #toc.active nav { display: block; }
}
/* Add support for keepWithNext */
.keepWithNext {
  break-after: avoid-page;
  break-after: avoid-page;
}
/* Add support for keepWithPrevious */
.keepWithPrevious {
  break-before: avoid-page;
}
/* Change the approach to avoiding breaks inside artwork etc. */
figure, pre, table, .artwork, .sourcecode  {
  break-before: auto;
  break-after: auto;
}
/* Avoid breaks between <dt> and <dd> */
dl {
  break-before: auto;
  break-inside: auto;
}
dt {
  break-before: auto;
  break-after: avoid-page;
}
dd {
  break-before: avoid-page;
  break-after: auto;
  orphans: 3;
  widows: 3
}
span.break, dd.break {
  margin-bottom: 0;
  min-height: 0;
  break-before: auto;
  break-inside: auto;
  break-after: auto;
}
/* Undo break-before ToC */
@media print {
  #toc {
    break-before: auto;
  }
}
/* Text in compact lists should not get extra bottom margin space,
   since that would makes the list not compact */
ul.compact p, .ulCompact p,
ol.compact p, .olCompact p {
 margin: 0;
}
/* But the list as a whole needs the extra space at the end */
section ul.compact,
section .ulCompact,
section ol.compact,
section .olCompact {
  margin-bottom: 1em;                    /* same as p not within ul.compact etc. */
}
/* The tt and code background above interferes with for instance table cell
   backgrounds.  Changed to something a bit more selective. */
tt, code {
  background-color: transparent;
}
p tt, p code, li tt, li code {
  background-color: #f8f8f8;
}
/* Tweak the pre margin -- 0px doesn't come out well */
pre {
   margin-top: 0.5px;
}
/* Tweak the compact list text */
ul.compact, .ulCompact,
ol.compact, .olCompact,
dl.compact, .dlCompact {
  line-height: normal;
}
/* Don't add top margin for nested lists */
li > ul, li > ol, li > dl,
dd > ul, dd > ol, dd > dl,
dl > dd > dl {
  margin-top: initial;
}
/* Elements that should not be rendered on the same line as a <dt> */
/* This should match the element list in writer.text.TextWriter.render_dl() */
dd > div.artwork:first-child,
dd > aside:first-child,
dd > figure:first-child,
dd > ol:first-child,
dd > div:first-child > pre.sourcecode,
dd > table:first-child,
dd > ul:first-child {
  clear: left;
}
/* fix for weird browser behaviour when <dd/> is empty */
dt+dd:empty::before{
  content: "\00a0";
}
/* Make paragraph spacing inside <li> smaller than in body text, to fit better within the list */
li > p {
  margin-bottom: 0.5em
}
/* Don't let p margin spill out from inside list items */
li > p:last-of-type {
  margin-bottom: 0;
}
</style>
<link href="rfc-local.css" rel="stylesheet" type="text/css"/>
<link href="https://dx.doi.org/10.17487/rfc9320" rel="alternate"/>
  <link href="urn:issn:2070-1721" rel="alternate"/>
  <link href="https://datatracker.ietf.org/doc/draft-ietf-detnet-bounded-latency-10" rel="prev"/>
  </head>
<body class="xml2rfc">
<script src="https://www.rfc-editor.org/js/metadata.min.js"></script>
<table class="ears">
<thead><tr>
<td class="left">RFC 9320</td>
<td class="center">DetNet Bounded Latency</td>
<td class="right">November 2022</td>
</tr></thead>
<tfoot><tr>
<td class="left">Finn, et al.</td>
<td class="center">Informational</td>
<td class="right">[Page]</td>
</tr></tfoot>
</table>
<div class="document-information" id="external-metadata"></div>
<div class="document-information" id="internal-metadata">
<dl id="identifiers">
<dt class="label-stream">Stream:</dt>
<dd class="stream">Internet Engineering Task Force (IETF)</dd>
<dt class="label-rfc">RFC:</dt>
<dd class="rfc"><a class="eref" href="https://www.rfc-editor.org/rfc/rfc9320">9320</a></dd>
<dt class="label-category">Category:</dt>
<dd class="category">Informational</dd>
<dt class="label-published">Published:</dt>
<dd class="published">
<time class="published" datetime="2022-11">November 2022</time>
    </dd>
<dt class="label-issn">ISSN:</dt>
<dd class="issn">2070-1721</dd>
<dt class="label-authors">Authors:</dt>
<dd class="authors">
<div class="author">
      <div class="author-name">N. Finn</div>
<div class="org">Huawei Technologies Co. Ltd</div>
</div>
<div class="author">
      <div class="author-name">J.-Y. Le Boudec</div>
<div class="org">EPFL</div>
</div>
<div class="author">
      <div class="author-name">E. Mohammadpour</div>
<div class="org">EPFL</div>
</div>
<div class="author">
      <div class="author-name">J. Zhang</div>
<div class="org">Huawei Technologies Co. Ltd</div>
</div>
<div class="author">
      <div class="author-name">B. Varga</div>
<div class="org">Ericsson</div>
</div>
</dd>
</dl>
</div>
<h1 id="rfcnum">RFC 9320</h1>
<h1 id="title">Deterministic Networking (DetNet) Bounded Latency</h1>
<section id="section-abstract">
      <h2 id="abstract"><a class="selfRef" href="#abstract">Abstract</a></h2>
<p id="section-abstract-1">
        This document presents a timing model for sources, destinations, and Deterministic Networking (DetNet) transit nodes. Using the model, it provides a methodology to compute end-to-end latency and backlog bounds for various queuing methods. The methodology can be used by the management and control planes and by resource reservation algorithms to provide bounded latency and zero congestion loss for the DetNet service.<a class="pilcrow" href="#section-abstract-1">¶</a></p>
</section>
<div id="status-of-memo">
<section id="section-boilerplate.1">
        <h2 id="name-status-of-this-memo">
<a class="section-name selfRef" href="#name-status-of-this-memo">Status of This Memo</a>
        </h2>
<p id="section-boilerplate.1-1">
            This document is not an Internet Standards Track specification; it is
            published for informational purposes.<a class="pilcrow" href="#section-boilerplate.1-1">¶</a></p>
<p id="section-boilerplate.1-2">
            This document is a product of the Internet Engineering Task Force
            (IETF).  It represents the consensus of the IETF community.  It has
            received public review and has been approved for publication by the
            Internet Engineering Steering Group (IESG).  Not all documents
            approved by the IESG are candidates for any level of Internet
            Standard; see Section 2 of RFC 7841.<a class="pilcrow" href="#section-boilerplate.1-2">¶</a></p>
<p id="section-boilerplate.1-3">
            Information about the current status of this document, any
            errata, and how to provide feedback on it may be obtained at
            <span><a href="https://www.rfc-editor.org/info/rfc9320">https://www.rfc-editor.org/info/rfc9320</a></span>.<a class="pilcrow" href="#section-boilerplate.1-3">¶</a></p>
</section>
</div>
<div id="copyright">
<section id="section-boilerplate.2">
        <h2 id="name-copyright-notice">
<a class="section-name selfRef" href="#name-copyright-notice">Copyright Notice</a>
        </h2>
<p id="section-boilerplate.2-1">
            Copyright (c) 2022 IETF Trust and the persons identified as the
            document authors. All rights reserved.<a class="pilcrow" href="#section-boilerplate.2-1">¶</a></p>
<p id="section-boilerplate.2-2">
            This document is subject to BCP 78 and the IETF Trust's Legal
            Provisions Relating to IETF Documents
            (<span><a href="https://trustee.ietf.org/license-info">https://trustee.ietf.org/license-info</a></span>) in effect on the date of
            publication of this document. Please review these documents
            carefully, as they describe your rights and restrictions with
            respect to this document. Code Components extracted from this
            document must include Revised BSD License text as described in
            Section 4.e of the Trust Legal Provisions and are provided without
            warranty as described in the Revised BSD License.<a class="pilcrow" href="#section-boilerplate.2-2">¶</a></p>
</section>
</div>
<div id="toc">
<section id="section-toc.1">
        <a class="toplink" href="#" onclick="scroll(0,0)">▲</a><h2 id="name-table-of-contents">
<a class="section-name selfRef" href="#name-table-of-contents">Table of Contents</a>
        </h2>
<nav class="toc"><ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.1">
            <p class="keepWithNext" id="section-toc.1-1.1.1"><a class="auto internal xref" href="#section-1">1</a>.  <a class="internal xref" href="#name-introduction">Introduction</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.2">
            <p class="keepWithNext" id="section-toc.1-1.2.1"><a class="auto internal xref" href="#section-2">2</a>.  <a class="internal xref" href="#name-terminology-and-definitions">Terminology and Definitions</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.3">
            <p id="section-toc.1-1.3.1"><a class="auto internal xref" href="#section-3">3</a>.  <a class="internal xref" href="#name-detnet-bounded-latency-mode">DetNet Bounded Latency Model</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.3.2.1">
                <p id="section-toc.1-1.3.2.1.1"><a class="auto internal xref" href="#section-3.1">3.1</a>.  <a class="internal xref" href="#name-flow-admission">Flow Admission</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.3.2.1.2.1">
                    <p class="keepWithNext" id="section-toc.1-1.3.2.1.2.1.1"><a class="auto internal xref" href="#section-3.1.1">3.1.1</a>.  <a class="internal xref" href="#name-static-latency-calculation">Static Latency Calculation</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.3.2.1.2.2">
                    <p id="section-toc.1-1.3.2.1.2.2.1"><a class="auto internal xref" href="#section-3.1.2">3.1.2</a>.  <a class="internal xref" href="#name-dynamic-latency-calculation">Dynamic Latency Calculation</a></p>
</li>
                </ul>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.3.2.2">
                <p id="section-toc.1-1.3.2.2.1"><a class="auto internal xref" href="#section-3.2">3.2</a>.  <a class="internal xref" href="#name-relay-node-model">Relay Node Model</a></p>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4">
            <p id="section-toc.1-1.4.1"><a class="auto internal xref" href="#section-4">4</a>.  <a class="internal xref" href="#name-computing-end-to-end-delay-">Computing End-to-End Delay Bounds</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.1">
                <p id="section-toc.1-1.4.2.1.1"><a class="auto internal xref" href="#section-4.1">4.1</a>.  <a class="internal xref" href="#name-non-queuing-delay-bound">Non-queuing Delay Bound</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.2">
                <p id="section-toc.1-1.4.2.2.1"><a class="auto internal xref" href="#section-4.2">4.2</a>.  <a class="internal xref" href="#name-queuing-delay-bound">Queuing Delay Bound</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.2.2.1">
                    <p id="section-toc.1-1.4.2.2.2.1.1"><a class="auto internal xref" href="#section-4.2.1">4.2.1</a>.  <a class="internal xref" href="#name-per-flow-queuing-mechanisms">Per-Flow Queuing Mechanisms</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.2.2.2">
                    <p id="section-toc.1-1.4.2.2.2.2.1"><a class="auto internal xref" href="#section-4.2.2">4.2.2</a>.  <a class="internal xref" href="#name-aggregate-queuing-mechanism">Aggregate Queuing Mechanisms</a></p>
</li>
                </ul>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.3">
                <p id="section-toc.1-1.4.2.3.1"><a class="auto internal xref" href="#section-4.3">4.3</a>.  <a class="internal xref" href="#name-ingress-considerations">Ingress Considerations</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.4">
                <p id="section-toc.1-1.4.2.4.1"><a class="auto internal xref" href="#section-4.4">4.4</a>.  <a class="internal xref" href="#name-interspersed-detnet-unaware">Interspersed DetNet-Unaware Transit Nodes</a></p>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.5">
            <p id="section-toc.1-1.5.1"><a class="auto internal xref" href="#section-5">5</a>.  <a class="internal xref" href="#name-achieving-zero-congestion-l">Achieving Zero Congestion Loss</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.6">
            <p id="section-toc.1-1.6.1"><a class="auto internal xref" href="#section-6">6</a>.  <a class="internal xref" href="#name-queuing-techniques">Queuing Techniques</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.6.2.1">
                <p id="section-toc.1-1.6.2.1.1"><a class="auto internal xref" href="#section-6.1">6.1</a>.  <a class="internal xref" href="#name-queuing-data-model">Queuing Data Model</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.6.2.2">
                <p id="section-toc.1-1.6.2.2.1"><a class="auto internal xref" href="#section-6.2">6.2</a>.  <a class="internal xref" href="#name-frame-preemption">Frame Preemption</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.6.2.3">
                <p id="section-toc.1-1.6.2.3.1"><a class="auto internal xref" href="#section-6.3">6.3</a>.  <a class="internal xref" href="#name-time-aware-shaper">Time-Aware Shaper</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.6.2.4">
                <p id="section-toc.1-1.6.2.4.1"><a class="auto internal xref" href="#section-6.4">6.4</a>.  <a class="internal xref" href="#name-credit-based-shaper-with-as">Credit-Based Shaper with Asynchronous Traffic Shaping</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.6.2.4.2.1">
                    <p id="section-toc.1-1.6.2.4.2.1.1"><a class="auto internal xref" href="#section-6.4.1">6.4.1</a>.  <a class="internal xref" href="#name-delay-bound-calculation">Delay Bound Calculation</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.6.2.4.2.2">
                    <p id="section-toc.1-1.6.2.4.2.2.1"><a class="auto internal xref" href="#section-6.4.2">6.4.2</a>.  <a class="internal xref" href="#name-flow-admission-2">Flow Admission</a></p>
</li>
                </ul>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.6.2.5">
                <p id="section-toc.1-1.6.2.5.1"><a class="auto internal xref" href="#section-6.5">6.5</a>.  <a class="internal xref" href="#name-guaranteed-service">Guaranteed Service</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.6.2.6">
                <p id="section-toc.1-1.6.2.6.1"><a class="auto internal xref" href="#section-6.6">6.6</a>.  <a class="internal xref" href="#name-cyclic-queuing-and-forwardi">Cyclic Queuing and Forwarding</a></p>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.7">
            <p id="section-toc.1-1.7.1"><a class="auto internal xref" href="#section-7">7</a>.  <a class="internal xref" href="#name-example-application-on-detn">Example Application on DetNet IP Network</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.8">
            <p id="section-toc.1-1.8.1"><a class="auto internal xref" href="#section-8">8</a>.  <a class="internal xref" href="#name-security-considerations">Security Considerations</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.9">
            <p id="section-toc.1-1.9.1"><a class="auto internal xref" href="#section-9">9</a>.  <a class="internal xref" href="#name-iana-considerations">IANA considerations</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.10">
            <p id="section-toc.1-1.10.1"><a class="auto internal xref" href="#section-10">10</a>. <a class="internal xref" href="#name-references">References</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.10.2.1">
                <p id="section-toc.1-1.10.2.1.1"><a class="auto internal xref" href="#section-10.1">10.1</a>.  <a class="internal xref" href="#name-normative-references">Normative References</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.10.2.2">
                <p id="section-toc.1-1.10.2.2.1"><a class="auto internal xref" href="#section-10.2">10.2</a>.  <a class="internal xref" href="#name-informative-references">Informative References</a></p>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.11">
            <p id="section-toc.1-1.11.1"><a class="auto internal xref" href="#appendix-A"></a><a class="internal xref" href="#name-acknowledgments">Acknowledgments</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.12">
            <p id="section-toc.1-1.12.1"><a class="auto internal xref" href="#appendix-B"></a><a class="internal xref" href="#name-contributors">Contributors</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.13">
            <p id="section-toc.1-1.13.1"><a class="auto internal xref" href="#appendix-C"></a><a class="internal xref" href="#name-authors-addresses">Authors' Addresses</a></p>
</li>
        </ul>
</nav>
</section>
</div>
<section id="section-1">
      <h2 id="name-introduction">
<a class="section-number selfRef" href="#section-1">1. </a><a class="section-name selfRef" href="#name-introduction">Introduction</a>
      </h2>
<p id="section-1-1">The ability for IETF Deterministic Networking (DetNet) or IEEE 802.1 Time-Sensitive
        Networking <span>[<a class="cite xref" href="#IEEE8021TSN">IEEE8021TSN</a>]</span> to provide the DetNet services of bounded latency and zero congestion
        loss depends upon<a class="pilcrow" href="#section-1-1">¶</a></p>
<ol class="normal type-A" id="section-1-2" start="1" type="A">
        <li id="section-1-2.1">configuring and allocating network resources for the exclusive use of DetNet flows;<a class="pilcrow" href="#section-1-2.1">¶</a>
</li>
        <li id="section-1-2.2">identifying, in the data plane, the resources to be utilized by any given packet; and<a class="pilcrow" href="#section-1-2.2">¶</a>
</li>
        <li id="section-1-2.3">the detailed behavior of those resources, especially transmission queue selection, so that latency bounds can be reliably assured.<a class="pilcrow" href="#section-1-2.3">¶</a>
</li>
      </ol>
<p id="section-1-3">
        As explained in <span>[<a class="cite xref" href="#RFC8655">RFC8655</a>]</span>, DetNet
        flows are notably characterized by<a class="pilcrow" href="#section-1-3">¶</a></p>
<ol class="normal type-1" id="section-1-4" start="1" type="1">
 <li id="section-1-4.1">a maximum bandwidth, guaranteed either by the transmitter or by strict input metering, and<a class="pilcrow" href="#section-1-4.1">¶</a>
</li>
        <li id="section-1-4.2">a requirement for a guaranteed worst-case end-to-end latency.<a class="pilcrow" href="#section-1-4.2">¶</a>
</li>
      </ol>
<p id="section-1-5">  That latency guarantee,
        in turn, provides the opportunity for the network to supply enough buffer
        space to guarantee zero congestion loss.
        In this document, it is assumed  that the paths of DetNet flows are fixed. Before the transmission of a DetNet flow, it is possible to calculate 
        end-to-end latency bounds and the amount of buffer space required at each hop to ensure zero congestion loss; this can be used by the applications identified in <span>[<a class="cite xref" href="#RFC8578">RFC8578</a>]</span>.<a class="pilcrow" href="#section-1-5">¶</a></p>
<p id="section-1-6">
        This document presents a timing model for sources, destinations, and the
        DetNet transit nodes; using this model, it provides a methodology to compute end-to-end latency and backlog bounds for various queuing mechanisms that can be used by the management and control planes to provide DetNet qualities of service. The methodology used in this document accounts for the possibility of packet reordering within a DetNet node. The bounds on the amount of packet reordering is out of the scope of this document and can be found in <span>[<a class="cite xref" href="#PacketReorderingBounds">PacketReorderingBounds</a>]</span>. Moreover, this document references specific queuing mechanisms, mentioned in <span>[<a class="cite xref" href="#RFC8655">RFC8655</a>]</span>, as proofs of concept that can be used to control packet transmission at each output port and achieve the DetNet quality of service (QoS).<a class="pilcrow" href="#section-1-6">¶</a></p>
<p id="section-1-7">
        Using the model presented in this document, it is possible for an
        implementer, user, or standards development organization to select
        a set of queuing mechanisms for each device in a DetNet network
        and to select a resource reservation algorithm for that network so that
        those elements can work together to provide the DetNet service. <a class="auto internal xref" href="#example">Section 7</a> provides an example application of the timing model introduced in this document on a DetNet IP network with a combination of different queuing mechanisms.<a class="pilcrow" href="#section-1-7">¶</a></p>
<p id="section-1-8">
        This document does not specify any resource reservation protocol or control plane function.
        It does not describe all of the requirements for that protocol or control plane function.
        It does describe requirements for such resource reservation methods
        and for queuing mechanisms that, if met, will enable them to work together.<a class="pilcrow" href="#section-1-8">¶</a></p>
</section>
<section id="section-2">
      <h2 id="name-terminology-and-definitions">
<a class="section-number selfRef" href="#section-2">2. </a><a class="section-name selfRef" href="#name-terminology-and-definitions">Terminology and Definitions</a>
      </h2>
<p id="section-2-1">
    This document uses the terms defined in <span>[<a class="cite xref" href="#RFC8655">RFC8655</a>]</span>. Moreover, the following terms are used in this document:<a class="pilcrow" href="#section-2-1">¶</a></p>
<span class="break"></span><dl class="dlNewline" id="section-2-2">
        <dt id="section-2-2.1">T-SPEC</dt>
        <dd id="section-2-2.2" style="margin-left: 1.5em">TrafficSpecification, as defined in <span><a class="relref" href="https://www.rfc-editor.org/rfc/rfc9016#section-5.5">Section 5.5</a> of [<a class="cite xref" href="#RFC9016">RFC9016</a>]</span>.<a class="pilcrow" href="#section-2-2.2">¶</a>
</dd>
        <dd class="break"></dd>
<dt id="section-2-2.3">arrival curve</dt>
        <dd id="section-2-2.4" style="margin-left: 1.5em">An arrival curve function alpha(t) is an upper bound on the number of bits seen at an observation point within any time interval t.<a class="pilcrow" href="#section-2-2.4">¶</a>
</dd>
        <dd class="break"></dd>
<dt id="section-2-2.5">CQF</dt>
        <dd id="section-2-2.6" style="margin-left: 1.5em">Cyclic Queuing and Forwarding.<a class="pilcrow" href="#section-2-2.6">¶</a>
</dd>
        <dd class="break"></dd>
<dt id="section-2-2.7">CBS</dt>
        <dd id="section-2-2.8" style="margin-left: 1.5em">Credit-Based Shaper.<a class="pilcrow" href="#section-2-2.8">¶</a>
</dd>
        <dd class="break"></dd>
<dt id="section-2-2.9">TSN</dt>
        <dd id="section-2-2.10" style="margin-left: 1.5em">Time-Sensitive Networking.<a class="pilcrow" href="#section-2-2.10">¶</a>
</dd>
        <dd class="break"></dd>
<dt id="section-2-2.11">PREOF</dt>
        <dd id="section-2-2.12" style="margin-left: 1.5em">A collective name for Packet Replication, Elimination, and Ordering Functions.<a class="pilcrow" href="#section-2-2.12">¶</a>
</dd>
        <dd class="break"></dd>
<dt id="section-2-2.13">POF</dt>
        <dd id="section-2-2.14" style="margin-left: 1.5em">A Packet Ordering Function is a function that reorders packets within a DetNet flow that are received out of order.  This function can be implemented by a DetNet edge node, a DetNet relay node, or an end system.<a class="pilcrow" href="#section-2-2.14">¶</a>
</dd>
      <dd class="break"></dd>
</dl>
</section>
<section id="section-3">
      <h2 id="name-detnet-bounded-latency-mode">
<a class="section-number selfRef" href="#section-3">3. </a><a class="section-name selfRef" href="#name-detnet-bounded-latency-mode">DetNet Bounded Latency Model</a>
      </h2>
<div id="flow-admission">
<section id="section-3.1">
        <h3 id="name-flow-admission">
<a class="section-number selfRef" href="#section-3.1">3.1. </a><a class="section-name selfRef" href="#name-flow-admission">Flow Admission</a>
        </h3>
<p id="section-3.1-1">
            This document assumes that the following paradigm is used to admit DetNet flows:<a class="pilcrow" href="#section-3.1-1">¶</a></p>
<ol class="normal type-1" id="section-3.1-2" start="1" type="1">
   <li id="section-3.1-2.1">
                    Perform any configuration required by the DetNet transit nodes in the network for aggregates of DetNet flows.
                    This configuration is done beforehand and not tied to any particular DetNet flow.<a class="pilcrow" href="#section-3.1-2.1">¶</a>
</li>
          <li id="section-3.1-2.2">
                    Characterize the new DetNet flow, particularly in terms of required bandwidth.<a class="pilcrow" href="#section-3.1-2.2">¶</a>
</li>
          <li id="section-3.1-2.3">
                    Establish the path that the DetNet flow will take through the network
                    from the source to the destination(s).  This can be a point-to-point
                    or a point-to-multipoint path.<a class="pilcrow" href="#section-3.1-2.3">¶</a>
</li>
          <li id="section-3.1-2.4">
                    Compute the worst-case end-to-end latency for the DetNet flow using one
                    of the methods below (Sections <a class="auto internal xref" href="#static-calculation">3.1.1</a> and
                    <a class="auto internal xref" href="#dynamic-calculation">3.1.2</a>).  In the process,
                    determine whether sufficient resources are available for the DetNet flow to
                    guarantee the required latency and to provide zero congestion loss.<a class="pilcrow" href="#section-3.1-2.4">¶</a>
</li>
          <li id="section-3.1-2.5">
                    Assuming that the resources are available, commit those resources to the
                    DetNet flow.  This may require adjusting the parameters that control
                    the filtering and/or queuing mechanisms at each hop along the DetNet flow's path.<a class="pilcrow" href="#section-3.1-2.5">¶</a>
</li>
        </ol>
<p id="section-3.1-3">
            This paradigm can be implemented using peer-to-peer protocols or using a
            central controller.  In some situations, a lack of resources can require
            backtracking and recursing through the above list.<a class="pilcrow" href="#section-3.1-3">¶</a></p>
<p id="section-3.1-4">
            Issues, such as service preemption of a DetNet flow in favor of another, when
            resources are scarce, are not considered here. Also not addressed is the question of
            how to choose the path to be taken by a DetNet flow.<a class="pilcrow" href="#section-3.1-4">¶</a></p>
<div id="static-calculation">
<section id="section-3.1.1">
          <h4 id="name-static-latency-calculation">
<a class="section-number selfRef" href="#section-3.1.1">3.1.1. </a><a class="section-name selfRef" href="#name-static-latency-calculation">Static Latency Calculation</a>
          </h4>
<span class="break"></span><dl class="dlNewline" id="section-3.1.1-1">
            <dt id="section-3.1.1-1.1">The static problem:</dt>
            <dd id="section-3.1.1-1.2" style="margin-left: 4.0em">
                        Given a network and a set of DetNet flows, compute an
                        end-to-end latency bound (if computable) for each DetNet flow and compute
                        the resources, particularly buffer space, required in each DetNet transit node
                        to achieve zero congestion loss.<a class="pilcrow" href="#section-3.1.1-1.2">¶</a>
</dd>
          <dd class="break"></dd>
</dl>
<p id="section-3.1.1-2">
                In this calculation, all of the DetNet flows are known before the
                calculation commences.  This problem is of interest to relatively
                static networks or static parts of larger networks. It provides 
                bounds on latency and buffer size.  The calculations can be extended
                to provide global optimizations, such as altering the path of one
                DetNet flow in order to make resources available to another DetNet
                flow with tighter constraints.<a class="pilcrow" href="#section-3.1.1-2">¶</a></p>
<p id="section-3.1.1-3">
                This calculation may be more difficult to perform than the
                dynamic calculation (<a class="auto internal xref" href="#dynamic-calculation">Section 3.1.2</a>) because the
                DetNet flows passing through one port on a DetNet transit node affect each other's
                latency.  The effects can even be circular, from node A to B to C
                and back to A.  On the other hand, the static calculation can often
                accommodate queuing methods, such as transmission selection by
                strict priority, that are unsuitable for the dynamic calculation.<a class="pilcrow" href="#section-3.1.1-3">¶</a></p>
</section>
</div>
<div id="dynamic-calculation">
<section id="section-3.1.2">
          <h4 id="name-dynamic-latency-calculation">
<a class="section-number selfRef" href="#section-3.1.2">3.1.2. </a><a class="section-name selfRef" href="#name-dynamic-latency-calculation">Dynamic Latency Calculation</a>
          </h4>
<span class="break"></span><dl class="dlNewline" id="section-3.1.2-1">
            <dt id="section-3.1.2-1.1">The dynamic problem:</dt>
            <dd id="section-3.1.2-1.2" style="margin-left: 4.0em">
                        Given a network whose maximum capacity for DetNet flows is
                        bounded by a set of static configuration parameters applied to the
                        DetNet transit nodes and given just one DetNet flow, compute the worst-case
                        end-to-end latency that can be experienced by that flow, no
                        matter what other DetNet flows (within the network's configured parameters)
                        might be created or deleted in the future.  Also, compute the resources,
                        particularly buffer space, required in each DetNet transit node
                        to achieve zero congestion loss.<a class="pilcrow" href="#section-3.1.2-1.2">¶</a>
</dd>
          <dd class="break"></dd>
</dl>
<p id="section-3.1.2-2">
                This calculation is dynamic, in the sense that DetNet flows can be added or deleted
                at any time, with a minimum of computation effort and without affecting
                the guarantees already given to other DetNet flows.<a class="pilcrow" href="#section-3.1.2-2">¶</a></p>
<p id="section-3.1.2-3">
                Dynamic latency calculation can be done based on the static one described in <a class="auto internal xref" href="#static-calculation">Section 3.1.1</a>;
                when a new DetNet flow is created or deleted, the entire calculation for all DetNet flows is
                repeated.  If an already-established DetNet flow would be pushed beyond its latency
                requirements by the new DetNet flow request, then the new DetNet flow request can be refused
                or some other suitable action can be taken.<a class="pilcrow" href="#section-3.1.2-3">¶</a></p>
<p id="section-3.1.2-4">
                The choice of queuing methods is critical to the applicability of the
                dynamic calculation.  Some queuing methods (e.g., CQF, <a class="auto internal xref" href="#cqf">Section 6.6</a>) make
                it easy to configure bounds on the network's capacity and to make
                independent calculations for each DetNet flow. Some other queuing methods (e.g., strict priority with the credit-based shaper
                defined in Section 8.6.8.2 of <span>[<a class="cite xref" href="#IEEE8021Q">IEEE8021Q</a>]</span>) can be used for dynamic DetNet flow creation
                but yield poorer latency and buffer space guarantees than when that same
                queuing method is used for static DetNet flow creation
                (<a class="auto internal xref" href="#static-calculation">Section 3.1.1</a>).<a class="pilcrow" href="#section-3.1.2-4">¶</a></p>
</section>
</div>
</section>
</div>
<div id="relay_model">
<section id="section-3.2">
        <h3 id="name-relay-node-model">
<a class="section-number selfRef" href="#section-3.2">3.2. </a><a class="section-name selfRef" href="#name-relay-node-model">Relay Node Model</a>
        </h3>
<p id="section-3.2-1">A model for the operation of a DetNet transit node is required in order to
            define the latency and buffer calculations.
            In <a class="auto internal xref" href="#fig_timing_model">Figure 1</a>, we see a breakdown of the per-hop latency experienced by a packet passing through a DetNet transit node in
        terms that are suitable for computing both hop-by-hop latency and per-hop buffer requirements.<a class="pilcrow" href="#section-3.2-1">¶</a></p>
<span id="name-timing-model-for-detnet-or-"></span><div id="fig_timing_model">
<figure id="figure-1">
          <div class="alignCenter art-text artwork" id="section-3.2-2.1">
<pre>      DetNet transit node A            DetNet transit node B
   +-------------------------+       +------------------------+
   |              Queuing    |       |              Queuing   |
   |   Regulator subsystem   |       |   Regulator subsystem  |
   |   +-+-+-+-+ +-+-+-+-+   |       |   +-+-+-+-+ +-+-+-+-+  |
--&gt;+   | | | | | | | | | +   +------&gt;+   | | | | | | | | | +  +---&gt;
   |   +-+-+-+-+ +-+-+-+-+   |       |   +-+-+-+-+ +-+-+-+-+  |
   |                         |       |                        |
   +-------------------------+       +------------------------+
   |&lt;-&gt;|&lt;------&gt;|&lt;-------&gt;|&lt;-&gt;|&lt;----&gt;|&lt;-&gt;|&lt;------&gt;|&lt;------&gt;|&lt;-&gt;|&lt;--
2,3  4      5        6      1    2,3   4      5        6     1   2,3
          1: Output delay             4: Processing delay
          2: Link delay               5: Regulation delay
          3: Frame preemption delay   6: Queuing subsystem delay
</pre>
</div>
<figcaption><a class="selfRef" href="#figure-1">Figure 1</a>:
<a class="selfRef" href="#name-timing-model-for-detnet-or-">Timing Model for DetNet or TSN</a>
          </figcaption></figure>
</div>
<p id="section-3.2-3">In <a class="auto internal xref" href="#fig_timing_model">Figure 1</a>, we see two DetNet transit nodes that are connected via a link. In this model, the only queues that we deal
                with explicitly are attached to the output port; other queues are modeled as variations
                in the other delay times (e.g., an input queue could be modeled as either a variation
                in the link delay (2) or the processing delay (4)).  There are six delays that a packet
                can experience from hop to hop.<a class="pilcrow" href="#section-3.2-3">¶</a></p>
<ol class="normal type-1" id="section-3.2-4" start="1" type="1">
          <li id="section-3.2-4.1">
            <p id="section-3.2-4.1.1">Output delay<a class="pilcrow" href="#section-3.2-4.1.1">¶</a></p>
<p id="section-3.2-4.1.2">
            This is the time taken from the selection of a packet for output from
     a queue to the
                    transmission of the first bit of the packet on the physical link.  If the
                    queue is directly attached to the physical port, output delay can be a constant.
     However, in many implementations, a multiplexed connection separates the queuing mechanism from a multi-port Network Interface Card (NIC).
                    This causes variations in the output delay that are hard for the forwarding node
                    to predict or control.<a class="pilcrow" href="#section-3.2-4.1.2">¶</a></p>
</li>
          <li id="section-3.2-4.2">
            <p id="section-3.2-4.2.1">Link delay<a class="pilcrow" href="#section-3.2-4.2.1">¶</a></p>
<p id="section-3.2-4.2.2">
            This is the time taken from the transmission of the first bit of the
     packet to the
                    reception of the last bit, assuming that the transmission is not suspended by
                    a frame preemption event.  This delay has two components: the first-bit-out to first-bit-in delay and the first-bit-in to last-bit-in delay that varies with packet  size.  The former is typically constant.  However,
                    a virtual "link" could exhibit a variable link delay.<a class="pilcrow" href="#section-3.2-4.2.2">¶</a></p>
</li>
          <li id="section-3.2-4.3">
            <p id="section-3.2-4.3.1">Frame preemption delay<a class="pilcrow" href="#section-3.2-4.3.1">¶</a></p>
<p id="section-3.2-4.3.2">
            If the packet is interrupted in order to transmit another packet or packets
     (e.g., frame preemption, as in <span>[<a class="cite xref" href="#IEEE8023">IEEE8023</a>]</span>, clause 99),
                    an arbitrary delay can result.<a class="pilcrow" href="#section-3.2-4.3.2">¶</a></p>
</li>
          <li id="section-3.2-4.4">
            <p id="section-3.2-4.4.1">Processing delay<a class="pilcrow" href="#section-3.2-4.4.1">¶</a></p>
<p id="section-3.2-4.4.2">
                    This delay covers the time from the reception of the last bit of the packet to the
                    time the packet is enqueued in the regulator (queuing subsystem if there is no regulator), as shown in <a class="auto internal xref" href="#fig_timing_model">Figure 1</a>.
                    This delay can be variable and depends on the details of the operation of the forwarding node.<a class="pilcrow" href="#section-3.2-4.4.2">¶</a></p>
</li>
          <li id="section-3.2-4.5">
            <p id="section-3.2-4.5.1">Regulator queuing delay<a class="pilcrow" href="#section-3.2-4.5.1">¶</a></p>
<p id="section-3.2-4.5.2">
                    A regulator, also known as shaper in <span>[<a class="cite xref" href="#RFC2475">RFC2475</a>]</span>, delays some or all of the packets in a traffic stream in order to bring the stream into compliance with an arrival curve; an arrival curve 'alpha(t)' is an upper bound on the number of bits observed within any interval t. The regulator delay is the time spent from the insertion of the last bit of a packet into a regulation queue until the time the packet is declared eligible according to its regulation constraints. We assume that this time can be calculated based on the details of regulation policy. If there is no regulation, this time is zero.<a class="pilcrow" href="#section-3.2-4.5.2">¶</a></p>
</li>
          <li id="section-3.2-4.6">
            <p id="section-3.2-4.6.1">Queuing subsystem delay<a class="pilcrow" href="#section-3.2-4.6.1">¶</a></p>
<p id="section-3.2-4.6.2">
                    This is the time spent for a packet from being declared eligible until being
                    selected for output on the next link.  We assume that this time is
                    calculable based on the details of the queuing mechanism. If there is no regulation, this time is from the insertion 
                    of the packet into a queue until it is selected for output on the next link.<a class="pilcrow" href="#section-3.2-4.6.2">¶</a></p>
</li>
        </ol>
<p id="section-3.2-5">Not shown in <a class="auto internal xref" href="#fig_timing_model">Figure 1</a> are the other output queues that we
                presume are also attached to that same output port as the queue shown, and against
                which this shown queue competes for transmission opportunities.<a class="pilcrow" href="#section-3.2-5">¶</a></p>
<p id="section-3.2-6">In this analysis, the measurement is from the point at which a packet is selected for output in a node to the point at which it is selected for output in the next downstream node (i.e., the definition of a "hop").  In general,
                any queue selection method that is suitable for use in a DetNet network includes
                a detailed specification as to exactly when packets are selected for transmission.
                Any variations in any of the delay times 1-4 result in a need for additional
                buffers in the queue.  If all delays 1-4 are constant, then any variation in the
                time at which packets are inserted into a queue depends entirely on the timing
                of packet selection in the previous node.  If delays 1-4 are not constant,
                then additional buffers are required in the queue to absorb these variations.
                Thus:<a class="pilcrow" href="#section-3.2-6">¶</a></p>
<ul class="normal">
<li class="normal" id="section-3.2-7.1">Variations in the output delay (1) require buffers to absorb that variation
                        in the next hop, so the output delay variations of the previous hop (on each
                        input port) must be known in order to calculate the buffer space required
                        on this hop.<a class="pilcrow" href="#section-3.2-7.1">¶</a>
</li>
          <li class="normal" id="section-3.2-7.2">Variations in the processing delay (4) require additional output buffers
                        in the queues of that same DetNet transit node.  Depending on the details
                        of the queuing subsystem delay (6) calculations, these variations need not be
                        visible outside the DetNet transit node.<a class="pilcrow" href="#section-3.2-7.2">¶</a>
</li>
        </ul>
</section>
</div>
</section>
<div id="e2eLatency">
<section id="section-4">
      <h2 id="name-computing-end-to-end-delay-">
<a class="section-number selfRef" href="#section-4">4. </a><a class="section-name selfRef" href="#name-computing-end-to-end-delay-">Computing End-to-End Delay Bounds</a>
      </h2>
<div id="nonqueuing">
<section id="section-4.1">
        <h3 id="name-non-queuing-delay-bound">
<a class="section-number selfRef" href="#section-4.1">4.1. </a><a class="section-name selfRef" href="#name-non-queuing-delay-bound">Non-queuing Delay Bound</a>
        </h3>
<p id="section-4.1-1">End-to-end latency bounds can be computed using the delay model in <a class="auto internal xref" href="#relay_model">Section 3.2</a>. Here, it is important
        to be aware that, for several queuing mechanisms, the end-to-end latency bound is less than the sum of the
        per-hop latency bounds.
        An end-to-end latency bound for one DetNet flow
        can be computed as<a class="pilcrow" href="#section-4.1-1">¶</a></p>
<p id="section-4.1-2" style="margin-left: 1.5em"> end_to_end_delay_bound = non_queuing_delay_bound + queuing_delay_bound<a class="pilcrow" href="#section-4.1-2">¶</a></p>
<p id="section-4.1-3">The two terms in the above formula are computed as follows.<a class="pilcrow" href="#section-4.1-3">¶</a></p>
<p id="section-4.1-4">
        First, at the h-th hop along the path of this DetNet flow, obtain an upper-bound
        per-hop_non_queuing_delay_bound[h] on the sum of the bounds over delays
        1, 2, 3, and 4
        of  <a class="auto internal xref" href="#fig_timing_model">Figure 1</a>. These upper bounds are expected to
        depend on the specific technology of the DetNet transit node at the h-th hop but not on
        the T-SPEC of this DetNet flow <span>[<a class="cite xref" href="#RFC9016">RFC9016</a>]</span>. Then, set non_queuing_delay_bound = the sum
        of per-hop_non_queuing_delay_bound[h] over all hops h.<a class="pilcrow" href="#section-4.1-4">¶</a></p>
<p id="section-4.1-5">
        Second, compute queuing_delay_bound as an upper bound to the sum of the
        queuing delays along the path. The value of queuing_delay_bound depends
        on the information on the arrival curve of this DetNet flow and possibly
        of other flows in the network, as well as the specifics of the queuing
        mechanisms deployed along the path of this DetNet flow. Note that arrival curve of the DetNet flow at the source is immediately specified by the T-SPEC of this flow. The computation of queuing_delay_bound 
        is described in <a class="auto internal xref" href="#queuing">Section 4.2</a> as a separate section.<a class="pilcrow" href="#section-4.1-5">¶</a></p>
</section>
</div>
<div id="queuing">
<section id="section-4.2">
        <h3 id="name-queuing-delay-bound">
<a class="section-number selfRef" href="#section-4.2">4.2. </a><a class="section-name selfRef" href="#name-queuing-delay-bound">Queuing Delay Bound</a>
        </h3>
<p id="section-4.2-1">
        For several queuing mechanisms, queuing_delay_bound is less than the sum of upper bounds on the queuing delays (5 and 6)
        at every hop.  This occurs with (1) per-flow queuing and (2) aggregate queuing with regulators, as explained in Sections <a class="auto internal xref" href="#perflow">4.2.1</a>, <a class="auto internal xref" href="#perclass">4.2.2</a>, and <a class="auto internal xref" href="#queue_model">6</a>. For other queuing mechanisms, the only available value of queuing_delay_bound
        is the sum of the per-hop queuing delay bounds.<a class="pilcrow" href="#section-4.2-1">¶</a></p>
<p id="section-4.2-2">
        The computation of per-hop queuing delay bounds must account for the fact that the arrival curve of a DetNet flow is no longer satisfied at the ingress of a hop, since burstiness increases as one flow traverses one DetNet transit node. If a regulator is placed at a hop, an arrival curve of a DetNet flow at the entrance of the queuing subsystem of this hop is the one configured at the regulator (also called shaping curve in <span>[<a class="cite xref" href="#NetCalBook">NetCalBook</a>]</span>); otherwise, an arrival curve of the flow can be derived using the delay jitter of the flow from the last regulation point (the last regulator in the path of the flow if there is any, otherwise the source of the flow) to the ingress of the hop; more formally, assume a DetNet flow has an arrival curve at the last regulation point equal to 'alpha(t)' and the delay jitter from the last regulation point to the ingress of the hop is 'V'. Then, the arrival curve at the ingress of the hop is 'alpha(t+V)'.<a class="pilcrow" href="#section-4.2-2">¶</a></p>
<p id="section-4.2-3">
        For example, consider a DetNet flow with T-SPEC "Interval: tau, MaxPacketsPerInterval: K, MaxPayloadSize: L" at the source. Then, a leaky-bucket arrival curve for such flow at the source is alpha(t)=r * t+ b, t&gt;0; alpha(0)=0, where r is the rate and b is the bucket size, computed as<a class="pilcrow" href="#section-4.2-3">¶</a></p>
<p id="section-4.2-4" style="margin-left: 1.5em">r =  K * (L+L') / tau,<a class="pilcrow" href="#section-4.2-4">¶</a></p>
<p id="section-4.2-5" style="margin-left: 1.5em">b = K * (L+L').<a class="pilcrow" href="#section-4.2-5">¶</a></p>
<p id="section-4.2-6"> 
        where L' is the size of any added networking technology-specific encapsulation (e.g., MPLS label(s), UDP, or IP headers). Now, if the flow has a delay jitter of 'V' from the last regulation point to the ingress of a hop, an arrival curve at this point is r * t + b + r * V, implying that the burstiness is increased by r*V. More detailed information on arrival curves is available in <span>[<a class="cite xref" href="#NetCalBook">NetCalBook</a>]</span>.<a class="pilcrow" href="#section-4.2-6">¶</a></p>
<div id="perflow">
<section id="section-4.2.1">
          <h4 id="name-per-flow-queuing-mechanisms">
<a class="section-number selfRef" href="#section-4.2.1">4.2.1. </a><a class="section-name selfRef" href="#name-per-flow-queuing-mechanisms">Per-Flow Queuing Mechanisms</a>
          </h4>
<p id="section-4.2.1-1">
            With such mechanisms, each flow uses a separate queue inside every node. The service for each queue is abstracted with a guaranteed rate and a latency. For every DetNet flow, a per-node latency bound, as well as an end-to-end latency bound, can be computed from the traffic specification of this DetNet flow at its source and from the values of rates and latencies at all nodes along its path. An instance of per-flow queuing is Guaranteed Service <span>[<a class="cite xref" href="#RFC2212">RFC2212</a>]</span>, for which the details of latency bound calculation are presented in <a class="auto internal xref" href="#intserv">Section 6.5</a>.<a class="pilcrow" href="#section-4.2.1-1">¶</a></p>
</section>
</div>
<div id="perclass">
<section id="section-4.2.2">
          <h4 id="name-aggregate-queuing-mechanism">
<a class="section-number selfRef" href="#section-4.2.2">4.2.2. </a><a class="section-name selfRef" href="#name-aggregate-queuing-mechanism">Aggregate Queuing Mechanisms</a>
          </h4>
<p id="section-4.2.2-1">
                With such mechanisms, multiple flows are aggregated into macro-flows and there is one FIFO queue per macro-flow. A practical example is the credit-based shaper defined in Section 8.6.8.2 of <span>[<a class="cite xref" href="#IEEE8021Q">IEEE8021Q</a>]</span>, where a macro-flow is called a "class".  One key issue in this context is how to deal with the burstiness cascade; individual flows that share a resource dedicated to a macro-flow may see their burstiness increase, which may in turn cause increased burstiness to other flows downstream of this resource. Computing delay upper bounds for such cases is difficult and, in some conditions, impossible <span>[<a class="cite xref" href="#CharnyDelay">CharnyDelay</a>]</span> <span>[<a class="cite xref" href="#BennettDelay">BennettDelay</a>]</span>. Also, when bounds are obtained, they depend on the complete configuration and must be recomputed when one flow is added (i.e., the dynamic calculation in <a class="auto internal xref" href="#dynamic-calculation">Section 3.1.2</a>).<a class="pilcrow" href="#section-4.2.2-1">¶</a></p>
<p id="section-4.2.2-2">
                A solution to deal with this issue for the DetNet flows is to reshape them at every hop. This can be done with per-flow regulators (e.g., leaky-bucket shapers), but this requires per-flow queuing and defeats the purpose of aggregate queuing. An alternative is the interleaved regulator, which reshapes individual DetNet flows without per-flow queuing <span>[<a class="cite xref" href="#SpechtUBS">SpechtUBS</a>]</span> <span>[<a class="cite xref" href="#IEEE8021Qcr">IEEE8021Qcr</a>]</span>. With  an interleaved regulator, the packet at the head of the queue is regulated based on
its (flow) regulation constraints; it is released at the earliest time at which this is possible without violating the constraint. One key feature of a per-flow or interleaved regulator is that it does not increase worst-case latency bounds <span>[<a class="cite xref" href="#LeBoudecTheory">LeBoudecTheory</a>]</span>. Specifically, when an interleaved regulator is appended to a FIFO subsystem, it does not increase the worst-case delay of the latter. In <a class="auto internal xref" href="#fig_timing_model">Figure 1</a>, when the order of packets from the output of a queuing subsystem at node A to the entrance of a regulator at node B is preserved, then the regulator does not increase the worst-case latency bounds. This is made possible if all the systems are FIFO or a DetNet Packet Ordering Function (POF) is implemented just before the regulator. This property does not hold if packet reordering occurs from the output of a queuing subsystem to the entrance of the next downstream interleaved regulator, e.g., at a non-FIFO switching fabric.<a class="pilcrow" href="#section-4.2.2-2">¶</a></p>
<p id="section-4.2.2-3">
                <a class="auto internal xref" href="#fig_detnet_e2e_example">Figure 2</a> shows an example of a network with 5 nodes, an aggregate queuing mechanism, and interleaved regulators, as in <a class="auto internal xref" href="#fig_timing_model">Figure 1</a>. 
                An end-to-end delay bound for DetNet flow f, traversing nodes 1 to 5, is calculated as follows:<a class="pilcrow" href="#section-4.2.2-3">¶</a></p>
<p id="section-4.2.2-4" style="margin-left: 1.5em"> end_to_end_latency_bound_of_flow_f = C12 + C23 + C34 + S4<a class="pilcrow" href="#section-4.2.2-4">¶</a></p>
<p id="section-4.2.2-5">
                In the above formula, Cij is a bound on the delay of the queuing subsystem in node i and interleaved regulator of node j, 
                and S4 is a bound on the delay of the queuing subsystem in node 4 for DetNet flow f. In fact, using the delay definitions in 
                <a class="auto internal xref" href="#relay_model">Section 3.2</a>, Cij is a bound on a sum of delays 1, 2, 3, and 6 of node i and delays 4 and 5 of node j. Similarly, S4 is a bound on 
                sum of delays 1, 2, 3, and 6 of node 4. A practical example of the queuing model and delay calculation is presented <a class="auto internal xref" href="#TSNwithATSmodel">Section 6.4</a>.<a class="pilcrow" href="#section-4.2.2-5">¶</a></p>
<span id="name-end-to-end-delay-computatio"></span><div id="fig_detnet_e2e_example">
<figure id="figure-2">
            <div class="alignCenter art-text artwork" id="section-4.2.2-6.1">
<pre>            f
  -----------------------------&gt;
+---+   +---+   +---+   +---+   +---+
| 1 |---| 2 |---| 3 |---| 4 |---| 5 |
+---+   +---+   +---+   +---+   +---+
   \__C12_/\__C23_/\__C34_/\_S4_/
</pre>
</div>
<figcaption><a class="selfRef" href="#figure-2">Figure 2</a>:
<a class="selfRef" href="#name-end-to-end-delay-computatio">End-to-End Delay Computation Example</a>
            </figcaption></figure>
</div>
<p id="section-4.2.2-7">
                If packet reordering does not occur, the end-to-end latency bound calculation provided here gives a tighter latency upper bound than would be obtained by adding the latency bounds of each node in the path of a DetNet flow <span>[<a class="cite xref" href="#TSNwithATS">TSNwithATS</a>]</span>.<a class="pilcrow" href="#section-4.2.2-7">¶</a></p>
</section>
</div>
</section>
</div>
<div id="ingress">
<section id="section-4.3">
        <h3 id="name-ingress-considerations">
<a class="section-number selfRef" href="#section-4.3">4.3. </a><a class="section-name selfRef" href="#name-ingress-considerations">Ingress Considerations</a>
        </h3>
<p id="section-4.3-1">
            A sender can be a DetNet node that uses exactly the same queuing methods as its adjacent DetNet transit node so that the latency and buffer bounds calculations at the first hop are indistinguishable from those at a later hop within the DetNet domain. On the other hand, the sender may be DetNet unaware; in which case, some conditioning of the DetNet flow may be necessary at the ingress DetNet transit node. The ingress conditioning typically consists of the regulators described in <a class="auto internal xref" href="#relay_model">Section 3.2</a>.<a class="pilcrow" href="#section-4.3-1">¶</a></p>
</section>
</div>
<div id="non-detnet-nodes">
<section id="section-4.4">
        <h3 id="name-interspersed-detnet-unaware">
<a class="section-number selfRef" href="#section-4.4">4.4. </a><a class="section-name selfRef" href="#name-interspersed-detnet-unaware">Interspersed DetNet-Unaware Transit Nodes</a>
        </h3>
<p id="section-4.4-1">
            It is sometimes desirable to build a network that has both DetNet-aware
            transit nodes and DetNet-unaware transit nodes and for a DetNet flow to
            traverse an island of DetNet-unaware transit nodes while still allowing the
            network to offer delay and congestion loss guarantees.  This is possible
            under certain conditions.<a class="pilcrow" href="#section-4.4-1">¶</a></p>
<p id="section-4.4-2">
            In general, when passing through a DetNet-unaware island, the island may cause
            delay variation in excess of what would be caused by DetNet nodes.  That
            is, the DetNet flow might be "lumpier" after traversing the DetNet-unaware island.
            DetNet guarantees for delay and buffer requirements can still be
            calculated and met if and only if the following are true:<a class="pilcrow" href="#section-4.4-2">¶</a></p>
<ol class="normal type-1" id="section-4.4-3" start="1" type="1">
   <li id="section-4.4-3.1">
                    The latency variation across the DetNet-unaware island must be
                    bounded and calculable.<a class="pilcrow" href="#section-4.4-3.1">¶</a>
</li>
          <li id="section-4.4-3.2">
                    An ingress conditioning function (<a class="auto internal xref" href="#ingress">Section 4.3</a>)
                    is required at the reentry to the DetNet-aware domain.
                    This will, at least, require some extra buffering to accommodate
                    the additional delay variation and thus further increases the
                    latency bound.<a class="pilcrow" href="#section-4.4-3.2">¶</a>
</li>
        </ol>
<p id="section-4.4-4">
            The ingress conditioning is exactly the same problem as that of a sender
            at the edge of the DetNet domain.  The requirement for bounds on the
            latency variation across the DetNet-unaware island is typically the most
            difficult to achieve.  Without such a bound, it is obvious that DetNet
            cannot deliver its guarantees, so a DetNet-unaware island that cannot
            offer bounded latency variation cannot be used to carry a DetNet flow.<a class="pilcrow" href="#section-4.4-4">¶</a></p>
</section>
</div>
</section>
</div>
<div id="achieving">
<section id="section-5">
      <h2 id="name-achieving-zero-congestion-l">
<a class="section-number selfRef" href="#section-5">5. </a><a class="section-name selfRef" href="#name-achieving-zero-congestion-l">Achieving Zero Congestion Loss</a>
      </h2>
<p id="section-5-1">
        When the input rate to an output queue exceeds the output rate for a sufficient
        length of time, the queue must overflow.  This is congestion loss, and this is
        what DetNet seeks to avoid.<a class="pilcrow" href="#section-5-1">¶</a></p>
<p id="section-5-2">
        To avoid congestion losses, an upper bound on the backlog present in the regulator and queuing subsystem of <a class="auto internal xref" href="#fig_timing_model">Figure 1</a>
    must be computed during resource reservation. This bound depends on the set of flows that use these queues, 
    the details of the specific queuing mechanism, and an 
    upper bound on the processing delay (4). The queue must contain the packet in transmission, plus all other packets that
    are waiting to be selected for output. A conservative backlog  bound that applies to all systems can be derived as follows.<a class="pilcrow" href="#section-5-2">¶</a></p>
<p id="section-5-3">
    The backlog bound is counted in data units (bytes or words of multiple bytes) that are relevant for buffer allocation.
    For every flow or an aggregate of flows, we need one buffer space for the packet in transmission, plus space for the packets that are waiting to be selected for output.<a class="pilcrow" href="#section-5-3">¶</a></p>
<p id="section-5-4">Let<a class="pilcrow" href="#section-5-4">¶</a></p>
<ul class="normal">
<li class="normal" id="section-5-5.1"> total_in_rate be the sum of the line rates of all input ports that send traffic to this output port. The value of total_in_rate
    is in data units (e.g., bytes) per second.<a class="pilcrow" href="#section-5-5.1">¶</a>
</li>
        <li class="normal" id="section-5-5.2">nb_input_ports be the number of input ports that send traffic to this output port.<a class="pilcrow" href="#section-5-5.2">¶</a>
</li>
        <li class="normal" id="section-5-5.3">max_packet_length be the maximum packet size for packets that may be sent to this output port. This is counted in data units.<a class="pilcrow" href="#section-5-5.3">¶</a>
</li>
        <li class="normal" id="section-5-5.4">max_delay456 be an upper bound, in seconds, on the sum of the processing delay (4) and the queuing delays (5 and 6) for any packet
     at this output port.<a class="pilcrow" href="#section-5-5.4">¶</a>
</li>
      </ul>
<p id="section-5-6">Then, a bound on the backlog of traffic in the queue at this output port is<a class="pilcrow" href="#section-5-6">¶</a></p>
<p id="section-5-7" style="margin-left: 1.5em"> backlog_bound = (nb_input_ports *  max_packet_length)  + (total_in_rate * max_delay456)<a class="pilcrow" href="#section-5-7">¶</a></p>
<p id="section-5-8">The above bound is over the backlog caused by the traffic entering the queue from the input ports of a DetNet node. If the DetNet node also generates packets (e.g., creation of new packets or replication of arriving packets), the bound must accordingly incorporate the introduced backlog.<a class="pilcrow" href="#section-5-8">¶</a></p>
</section>
</div>
<div id="queue_model">
<section id="section-6">
      <h2 id="name-queuing-techniques">
<a class="section-number selfRef" href="#section-6">6. </a><a class="section-name selfRef" href="#name-queuing-techniques">Queuing Techniques</a>
      </h2>
<p id="section-6-1">In this section, we present a general queuing data model, as well as some examples of queuing mechanisms. For simplicity of latency bound computation, we assume a leaky-bucket arrival curve for each DetNet flow at the source.
     Also, at each DetNet transit node, the service for each queue is abstracted with a minimum guaranteed rate and a latency <span>[<a class="cite xref" href="#NetCalBook">NetCalBook</a>]</span>.<a class="pilcrow" href="#section-6-1">¶</a></p>
<div id="data_model">
<section id="section-6.1">
        <h3 id="name-queuing-data-model">
<a class="section-number selfRef" href="#section-6.1">6.1. </a><a class="section-name selfRef" href="#name-queuing-data-model">Queuing Data Model</a>
        </h3>
<p id="section-6.1-1">Sophisticated queuing mechanisms are available in Layer 3 (L3) (e.g., see <span>[<a class="cite xref" href="#RFC7806">RFC7806</a>]</span> for an overview).
        In general, we assume that "Layer 3" queues, shapers, meters, etc., are precisely the "regulators"
        shown in <a class="auto internal xref" href="#fig_timing_model">Figure 1</a>. The "queuing subsystems" in this figure are FIFO. They are not the province solely of bridges;
        they are an essential part of any DetNet transit node.  As illustrated by numerous implementation examples, some of the
        "Layer 3" mechanisms described in documents, such as <span>[<a class="cite xref" href="#RFC7806">RFC7806</a>]</span>, are often integrated
        in an implementation, with the "Layer 2" mechanisms also implemented in the same node.  An integrated model
        is needed in order to successfully predict the interactions among the different queuing mechanisms
        needed in a network carrying both DetNet flows and non-DetNet flows.<a class="pilcrow" href="#section-6.1-1">¶</a></p>
<p id="section-6.1-2"><a class="auto internal xref" href="#fig_8021Q_data_model">Figure 3</a> shows the general model for the flow of packets through
    the queues of a DetNet transit node. The DetNet packets are mapped to a number of regulators. Here, we assume that the Packet Replication, Elimination, and Ordering Functions (PREOF) are performed before the DetNet packets enter the regulators.
     All packets are assigned to a set of queues.  Packets compete for the selection to be passed to queues in the queuing subsystem. Packets again are selected for output from the
    queuing subsystem.<a class="pilcrow" href="#section-6.1-2">¶</a></p>
<span id="name-ieee-8021q-queuing-model-da"></span><div id="fig_8021Q_data_model">
<figure id="figure-3">
          <div class="alignCenter art-text artwork" id="section-6.1-3.1">
<pre>                                 |
+--------------------------------V----------------------------------+
|                          Queue assignment                         |
+--+------+----------+---------+-----------+-----+-------+-------+--+
   |      |          |         |           |     |       |       |
+--V-+ +--V-+     +--V--+   +--V--+     +--V--+  |       |       |
|Flow| |Flow|     |Flow |   |Flow |     |Flow |  |       |       |
|  0 | |  1 | ... |  i  |   | i+1 | ... |  n  |  |       |       |
| reg| | reg|     | reg |   | reg |     | reg |  |       |       |
+--+-+ +--+-+     +--+--+   +--+--+     +--+--+  |       |       |
   |      |          |         |           |     |       |       |
+--V------V----------V--+   +--V-----------V--+  |       |       |
|  Trans.  selection    |   | Trans. select.  |  |       |       |
+----------+------------+   +-----+-----------+  |       |       |
           |                      |              |       |       |
        +--V--+                +--V--+        +--V--+ +--V--+ +--V--+
        | out |                | out |        | out | | out | | out |
        |queue|                |queue|        |queue| |queue| |queue|
        |  1  |                |  2  |        |  3  | |  4  | |  5  |
        +--+--+                +--+--+        +--+--+ +--+--+ +--+--+
           |                      |              |       |       |
+----------V----------------------V--------------V-------V-------V--+
|                      Transmission selection                       |
+---------------------------------+---------------------------------+
                                  |
                                  V
</pre>
</div>
<figcaption><a class="selfRef" href="#figure-3">Figure 3</a>:
<a class="selfRef" href="#name-ieee-8021q-queuing-model-da">IEEE 802.1Q Queuing Model: Data Flow</a>
          </figcaption></figure>
</div>
<p id="section-6.1-4">Some relevant mechanisms are hidden in this figure and are performed in the
        queue boxes:<a class="pilcrow" href="#section-6.1-4">¶</a></p>
<ul class="normal">
<li class="normal" id="section-6.1-5.1">discarding packets because a queue is full<a class="pilcrow" href="#section-6.1-5.1">¶</a>
</li>
          <li class="normal" id="section-6.1-5.2">
            discarding packets marked "yellow" by a metering function in preference
            to discarding "green" packets <span>[<a class="cite xref" href="#RFC2697">RFC2697</a>]</span><a class="pilcrow" href="#section-6.1-5.2">¶</a>
</li>
        </ul>
<p id="section-6.1-6">
        Ideally, neither of these actions are performed on DetNet packets.  Full queues
        for DetNet packets occur only when a DetNet flow is misbehaving, and the DetNet
        QoS does not include "yellow" service for packets in excess
 of a committed rate.<a class="pilcrow" href="#section-6.1-6">¶</a></p>
<p id="section-6.1-7">
        The queue assignment function can be quite complex, even in a
        bridge <span>[<a class="cite xref" href="#IEEE8021Q">IEEE8021Q</a>]</span>, because of the
        introduction of per-stream filtering and policing (<span>[<a class="cite xref" href="#IEEE8021Q">IEEE8021Q</a>]</span>, clause 8.6.5.1).
        In addition to the Layer 2 priority
        expressed in the 802.1Q VLAN tag, a DetNet transit node can utilize the information from the non-exhaustive list below to assign a packet to a particular queue:<a class="pilcrow" href="#section-6.1-7">¶</a></p>
<ul class="normal">
<li class="normal" id="section-6.1-8.1">
                input port<a class="pilcrow" href="#section-6.1-8.1">¶</a>
</li>
          <li class="normal" id="section-6.1-8.2">
                selector based on a rotating schedule that starts at regular, time-synchronized
                intervals and has nanosecond precision<a class="pilcrow" href="#section-6.1-8.2">¶</a>
</li>
          <li class="normal" id="section-6.1-8.3">
                MAC addresses, VLAN ID, IP addresses, Layer 4 port numbers, and Differentiated Services Code Point (DSCP) <span>[<a class="cite xref" href="#RFC8939">RFC8939</a>]</span> <span>[<a class="cite xref" href="#RFC8964">RFC8964</a>]</span><a class="pilcrow" href="#section-6.1-8.3">¶</a>
</li>
          <li class="normal" id="section-6.1-8.4">
                the queue assignment function can contain metering and policing
                functions<a class="pilcrow" href="#section-6.1-8.4">¶</a>
</li>
          <li class="normal" id="section-6.1-8.5">
                MPLS and/or pseudowire labels <span>[<a class="cite xref" href="#RFC6658">RFC6658</a>]</span><a class="pilcrow" href="#section-6.1-8.5">¶</a>
</li>
        </ul>
<p id="section-6.1-9">
        The "Transmission selection" function decides which queue is to transfer its
        oldest packet to the output port when a transmission opportunity arises.<a class="pilcrow" href="#section-6.1-9">¶</a></p>
</section>
</div>
<div id="preempt_intro">
<section id="section-6.2">
        <h3 id="name-frame-preemption">
<a class="section-number selfRef" href="#section-6.2">6.2. </a><a class="section-name selfRef" href="#name-frame-preemption">Frame Preemption</a>
        </h3>
<p id="section-6.2-1">
    In <span>[<a class="cite xref" href="#IEEE8021Q">IEEE8021Q</a>]</span> and <span>[<a class="cite xref" href="#IEEE8023">IEEE8023</a>]</span>, the transmission of a frame
    can be interrupted by one or more "express" frames; then, the interrupted frame can
    continue transmission.  The frame preemption is modeled as
    consisting of two MAC/PHY stacks: one for packets that
    can be interrupted and one for packets that can interrupt the interruptible packets.
    Only one layer of frame preemption is supported -- a transmitter cannot have more than one
    interrupted frame in progress.  DetNet flows typically pass through the interrupting
    MAC. For those DetNet flows with T-SPEC, latency bounds can be 
    calculated by the methods provided in the following sections that account for the effect of frame preemption, according to the specific 
    queuing mechanism that is used in DetNet nodes. Best-effort queues pass through the 
    interruptible MAC and can thus be preempted.<a class="pilcrow" href="#section-6.2-1">¶</a></p>
</section>
</div>
<div id="time_schedule_intro">
<section id="section-6.3">
        <h3 id="name-time-aware-shaper">
<a class="section-number selfRef" href="#section-6.3">6.3. </a><a class="section-name selfRef" href="#name-time-aware-shaper">Time-Aware Shaper</a>
        </h3>
<p id="section-6.3-1">
            In <span>[<a class="cite xref" href="#IEEE8021Q">IEEE8021Q</a>]</span>, the notion of time-scheduling queue gates is
            described in Section 8.6.8.4. On each node, the transmission selection for packets 
            is controlled by time-synchronized gates; each output queue is associated with a gate.
            The gates can be either open or closed. The states of the gates are
            determined by the gate control list (GCL). The GCL specifies the opening and closing
            times of the gates. The design of the GCL must satisfy the requirement of 
            latency upper bounds of all DetNet flows; therefore, those DetNet flows that traverse a 
            network that uses this kind of shaper must have bounded latency if the traffic and nodes are conformant.<a class="pilcrow" href="#section-6.3-1">¶</a></p>
<p id="section-6.3-2">
            Note that scheduled traffic service relies on a synchronized
            network and coordinated GCL configuration. Synthesis of the GCL on multiple
            nodes in a network is a scheduling problem considering all DetNet flows
            traversing the network, which is a nondeterministic polynomial-time hard
            (NP-hard) problem <span>[<a class="cite xref" href="#Sch8021Qbv">Sch8021Qbv</a>]</span>. Also, at the time of writing, scheduled traffic service
            supports no more than eight traffic queues, typically using up to seven
            priority queues and at least one best effort.<a class="pilcrow" href="#section-6.3-2">¶</a></p>
</section>
</div>
<div id="TSNwithATSmodel">
<section id="section-6.4">
        <h3 id="name-credit-based-shaper-with-as">
<a class="section-number selfRef" href="#section-6.4">6.4. </a><a class="section-name selfRef" href="#name-credit-based-shaper-with-as">Credit-Based Shaper with Asynchronous Traffic Shaping</a>
        </h3>
<p id="section-6.4-1">
            In this queuing model, it is assumed that the DetNet nodes are FIFO. We consider the four traffic classes (Definition 3.268 of <span>[<a class="cite xref" href="#IEEE8021Q">IEEE8021Q</a>]</span>): control-data traffic (CDT),
            class A, class B, and best effort (BE) in decreasing order of priority. Flows of classes A and B are DetNet flows that are less critical than CDT (such as studio audio and video traffic, as in IEEE 802.1BA Audio-Video-Bridging). This model is a subset of Time-Sensitive Networking, as described next.<a class="pilcrow" href="#section-6.4-1">¶</a></p>
<p id="section-6.4-2">
            Based on the timing model described in <a class="auto internal xref" href="#fig_timing_model">Figure 1</a>, contention occurs only at the output port of a DetNet transit node; therefore, the focus of the rest of this subsection is on the regulator and queuing subsystem in the output port of a DetNet transit node. The input flows are identified using the information in (<span><a class="relref" href="https://www.rfc-editor.org/rfc/rfc8939#section-5.1">Section 5.1</a> of [<a class="cite xref" href="#RFC8939">RFC8939</a>]</span>). Then, they are aggregated into eight macro-flows based
            on their service requirements; we refer to each macro-flow as a class.
             The output port performs aggregate scheduling with eight queues (queuing subsystems): one for CDT, one for class A flows, one for class B flows, and five for BE traffic denoted as BE0-BE4. The queuing policy for each queuing subsystem is FIFO. In addition, each node output port also performs per-flow regulation for 
            class A and B flows using an interleaved regulator (IR). This regulation is called 
   asynchronous traffic shaping <span>[<a class="cite xref" href="#IEEE8021Qcr">IEEE8021Qcr</a>]</span>. Thus, at each output port of a node, there is one interleaved regulator per input 
            port and per class; the interleaved regulator is mapped to the regulator depicted in <a class="auto internal xref" href="#fig_timing_model">Figure 1</a>. The detailed picture of scheduling and regulation architecture at a node output port is given by <a class="auto internal xref" href="#fig_TSN_node">Figure 4</a>. The packets received at a node input port for a given class are enqueued in the respective interleaved regulator at the output port.
            Then, the packets from all the flows, including CDT and BE flows, are enqueued in a queuing subsystem; there is no regulator for CDT and BE flows.<a class="pilcrow" href="#section-6.4-2">¶</a></p>
<span id="name-the-architecture-of-an-outp"></span><div id="fig_TSN_node">
<figure id="figure-4">
          <div class="alignLeft art-text artwork" id="section-6.4-3.1">
<pre>      +--+   +--+ +--+   +--+
      |  |   |  | |  |   |  |
      |IR|   |IR| |IR|   |IR|
      |  |   |  | |  |   |  |
      +-++XXX++-+ +-++XXX++-+
        |     |     |     |
        |     |     |     |
+---+ +-v-XXX-v-+ +-v-XXX-v-+ +-----+ +-----+ +-----+ +-----+ +-----+
|   | |         | |         | |Class| |Class| |Class| |Class| |Class|
|CDT| | Class A | | Class B | | BE4 | | BE3 | | BE2 | | BE1 | | BE0 |
|   | |         | |         | |     | |     | |     | |     | |     |
+-+-+ +----+----+ +----+----+ +--+--+ +--+--+ +--+--+ +--+--+ +--+--+
  |        |           |         |       |       |       |       |
  |      +-v-+       +-v-+       |       |       |       |       |
  |      |CBS|       |CBS|       |       |       |       |       |
  |      +-+-+       +-+-+       |       |       |       |       |
  |        |           |         |       |       |       |       |
+-v--------v-----------v---------v-------V-------v-------v-------v--+
|                     Strict Priority selection                     |
+--------------------------------+----------------------------------+
                                 |
                                 V
</pre>
</div>
<figcaption><a class="selfRef" href="#figure-4">Figure 4</a>:
<a class="selfRef" href="#name-the-architecture-of-an-outp">The Architecture of an Output Port inside a Relay Node with Interleaved Regulators (IRs) and a Credit-Based Shaper (CBS)</a>
          </figcaption></figure>
</div>
<p id="section-6.4-4">
            Each of the queuing subsystems for classes A and B contains a credit-based shaper (CBS). The CBS serves a packet from a class according to the available credit
            for that class. As described in Section 8.6.8.2 and Annex L.1 of <span>[<a class="cite xref" href="#IEEE8021Q">IEEE8021Q</a>]</span>, the credit for each class A or B increases based on the idle slope (as guaranteed rate) and decreases based on the sendslope (typically equal to the difference between the guaranteed and the output link rates), both of which 
            are parameters of the CBS. The CDT and BE0-BE4 flows are served by separate queuing subsystems. Then, packets from all flows are
            served by a transmission selection subsystem that serves packets from each class based on its priority. All subsystems are non-preemptive.
            Guarantees for class A and B traffic can be provided only if CDT is bounded. It is assumed that the CDT has a leaky-bucket arrival curve with two parameters: r_h as rate and b_h as bucket size. That is, the amount of bits entering a node within a time interval t is bounded by r_h * t + b_h.<a class="pilcrow" href="#section-6.4-4">¶</a></p>
<p id="section-6.4-5">
            Additionally, it is assumed that the class A and B flows are also regulated at their source according to a leaky-bucket arrival curve. At the source, the traffic satisfies its regulation constraint, i.e., the delay due to interleaved regulator at the source is ignored.<a class="pilcrow" href="#section-6.4-5">¶</a></p>
<p id="section-6.4-6">
            At each DetNet transit node implementing an interleaved regulator, packets of multiple flows are processed in one FIFO queue. The packet at the head
            of the queue is regulated based on its leaky-bucket parameters. It is released at the earliest time at which this is possible without violating 
            the constraint.<a class="pilcrow" href="#section-6.4-6">¶</a></p>
<p id="section-6.4-7">
                The regulation parameters for a flow (leaky-bucket rate and bucket size) are the same at its source and at all DetNet transit nodes along its path in the case where all clocks are perfect. However, in reality, there is clock non-ideality throughout the DetNet domain, even with clock synchronization. This phenomenon causes inaccuracy in the rates configured at the regulators that may lead to network instability. To avoid instability, the rates are set as the source rates with some positive margin when configuring regulators. <span>[<a class="cite xref" href="#ThomasTime">ThomasTime</a>]</span> describes and provides solutions to this issue.<a class="pilcrow" href="#section-6.4-7">¶</a></p>
<div id="delayTSNwithATS">
<section id="section-6.4.1">
          <h4 id="name-delay-bound-calculation">
<a class="section-number selfRef" href="#section-6.4.1">6.4.1. </a><a class="section-name selfRef" href="#name-delay-bound-calculation">Delay Bound Calculation</a>
          </h4>
<p id="section-6.4.1-1">
                A delay bound of the queuing subsystem ((4) in <a class="auto internal xref" href="#fig_timing_model">Figure 1</a>) of a given DetNet node for a flow of class A or B can be computed if the following condition holds:<a class="pilcrow" href="#section-6.4.1-1">¶</a></p>
<p id="section-6.4.1-2" style="margin-left: 1.5em">The sum of leaky-bucket rates of all flows of this class at this transit node &lt;= R, where R is given below for every class<a class="pilcrow" href="#section-6.4.1-2">¶</a></p>
<p id="section-6.4.1-3">If the condition holds, the delay bounds for a flow of class X (A or B) is d_X and calculated as:<a class="pilcrow" href="#section-6.4.1-3">¶</a></p>
<p id="section-6.4.1-4" style="margin-left: 1.5em"> d_X = T_X + (b_t_X-L_min_X)/R_X - L_min_X/c<a class="pilcrow" href="#section-6.4.1-4">¶</a></p>
<p id="section-6.4.1-5">
                where L_min_X is the minimum packet lengths of class X (A or B); c is the output link transmission rate; and b_t_X is the sum of the b term (bucket size) for all the flows of the class X. Parameters R_X and T_X are calculated as follows for class A and B, separately.<a class="pilcrow" href="#section-6.4.1-5">¶</a></p>
<p id="section-6.4.1-6">If the flow is of class A:<a class="pilcrow" href="#section-6.4.1-6">¶</a></p>
<p id="section-6.4.1-7" style="margin-left: 1.5em"> R_A = I_A * (c-r_h)/ c<a class="pilcrow" href="#section-6.4.1-7">¶</a></p>
<p id="section-6.4.1-8" style="margin-left: 1.5em">T_A = (L_nA + b_h + r_h * L_n/c)/(c-r_h)<a class="pilcrow" href="#section-6.4.1-8">¶</a></p>
<p id="section-6.4.1-9">where I_A is the idle slope for class A; L_nA is the maximum packet length of class B and BE packets; L_n is the maximum packet length of classes A, B, and BE; and r_h is the rate and b_h is the bucket size of CDT leaky-bucket arrival curve.<a class="pilcrow" href="#section-6.4.1-9">¶</a></p>
<p id="section-6.4.1-10">If the flow is of class B:<a class="pilcrow" href="#section-6.4.1-10">¶</a></p>
<p id="section-6.4.1-11" style="margin-left: 1.5em">R_B = I_B * (c-r_h)/ c<a class="pilcrow" href="#section-6.4.1-11">¶</a></p>
<p id="section-6.4.1-12" style="margin-left: 1.5em">T_B = (L_BE + L_A + L_nA * I_A/(c_h-I_A) + b_h + r_h * L_n/c)/(c-r_h)<a class="pilcrow" href="#section-6.4.1-12">¶</a></p>
<p id="section-6.4.1-13">
                where I_B is the idle slope for class B; L_A is the maximum packet length of class A; and L_BE is the maximum packet length of class BE.<a class="pilcrow" href="#section-6.4.1-13">¶</a></p>
<p id="section-6.4.1-14">Then, as discussed in <a class="auto internal xref" href="#perclass">Section 4.2.2</a>, an interleaved regulator does not increase the delay bound of the upstream queuing subsystem; therefore, an end-to-end delay bound for a DetNet flow of class X (A or B) is the sum of d_X_i for all node i in the path of the flow, where d_X_i is the delay bound of queuing subsystem in node i, which is computed as above. According to the notation in <a class="auto internal xref" href="#perclass">Section 4.2.2</a>, the delay bound of the queuing subsystem in a node i and interleaved regulator in node j, i.e., Cij, is:<a class="pilcrow" href="#section-6.4.1-14">¶</a></p>
<p id="section-6.4.1-15" style="margin-left: 1.5em">Cij = d_X_i<a class="pilcrow" href="#section-6.4.1-15">¶</a></p>
<p id="section-6.4.1-16">More information of delay analysis in such a DetNet transit node is described in <span>[<a class="cite xref" href="#TSNwithATS">TSNwithATS</a>]</span>.<a class="pilcrow" href="#section-6.4.1-16">¶</a></p>
</section>
</div>
<div id="admissionTSNwithATS">
<section id="section-6.4.2">
          <h4 id="name-flow-admission-2">
<a class="section-number selfRef" href="#section-6.4.2">6.4.2. </a><a class="section-name selfRef" href="#name-flow-admission-2">Flow Admission</a>
          </h4>
<p id="section-6.4.2-1"> 
                The delay bound calculation requires some information about each node. For each node, it is required to know the idle slope of the CBS for each class A and B (I_A and I_B), as well as the transmission rate of the output link (c). Besides, it is necessary to have the information on each class, i.e., maximum packet length of classes A, B, and BE. Moreover, the leaky-bucket parameters of CDT (r_h, b_h) must be known. To admit a flow or flows of classes A and B, their delay requirements must be guaranteed not to be violated. As described in <a class="auto internal xref" href="#flow-admission">Section 3.1</a>, the two problems (static and dynamic) are addressed separately. In either of the problems, the rate and delay must be guaranteed. Thus,<a class="pilcrow" href="#section-6.4.2-1">¶</a></p>
<span class="break"></span><dl class="dlNewline" id="section-6.4.2-2">
            <dt id="section-6.4.2-2.1">The static admission control:</dt>
            <dd id="section-6.4.2-2.2" style="margin-left: 4.0em">
                    The leaky-bucket parameters of all class A or B flows are known; therefore, for each flow f of either class A or B, a delay bound
           can be calculated.  The computed delay bound for every flow
           of class A or B must not be more than its delay requirement. Moreover, the sum of the rate of each flow (r_f) must not be more than the rate allocated to each class (R). If these two conditions hold, the configuration is declared admissible.<a class="pilcrow" href="#section-6.4.2-2.2">¶</a>
</dd>
            <dd class="break"></dd>
<dt id="section-6.4.2-2.3">The dynamic admission control:</dt>
            <dd id="section-6.4.2-2.4" style="margin-left: 4.0em">
              <span class="break"></span><dl class="dlNewline" id="section-6.4.2-2.4.1">
                <dt id="section-6.4.2-2.4.1.1">  For dynamic admission control, we allocate 
          a static value for rate (R) and a maximum bucket
          size (b_t) to every node and each class A or B.  
          In addition, for every node and each class A
          or B, two counters are maintained:
                </dt>
                <dd id="section-6.4.2-2.4.1.2" style="margin-left: 1.5em">
                  <p id="section-6.4.2-2.4.1.2.1">R_acc is equal to the sum of the leaky-bucket rates of all flows of this class already admitted at this node; at all times, we must have:<a class="pilcrow" href="#section-6.4.2-2.4.1.2.1">¶</a></p>
<p id="section-6.4.2-2.4.1.2.2">R_acc &lt;= R, (Eq. 1)<a class="pilcrow" href="#section-6.4.2-2.4.1.2.2">¶</a></p>
<p id="section-6.4.2-2.4.1.2.3">b_acc is equal to the sum of the bucket sizes of all flows of this class already admitted at this node; at all times, we must have:<a class="pilcrow" href="#section-6.4.2-2.4.1.2.3">¶</a></p>
<p id="section-6.4.2-2.4.1.2.4">b_acc &lt;= b_t.  (Eq. 2)<a class="pilcrow" href="#section-6.4.2-2.4.1.2.4">¶</a></p>
</dd>
              <dd class="break"></dd>
</dl>
<p id="section-6.4.2-2.4.2">
              A new class A or B flow is admitted at this node if Eqs. (1) and (2) continue to be satisfied after adding its leaky-bucket rate and bucket size to R_acc and b_acc. A class A or B flow is admitted in the network if it is admitted at all nodes along its path. When this happens, all variables R_acc and b_acc along its path must be incremented to reflect the addition of the flow. Similarly, when a class A or B flow leaves the network, all variables R_acc and b_acc along its path must be decremented to reflect the removal of the flow.<a class="pilcrow" href="#section-6.4.2-2.4.2">¶</a></p>
</dd>
          <dd class="break"></dd>
</dl>
<p id="section-6.4.2-3">
                The choice of the static values of R and b_t at all nodes and classes must be done in a prior configuration phase: R controls the bandwidth allocated to this class at this node, and b_t affects the delay bound and the buffer requirement. The value of R must be set such that<a class="pilcrow" href="#section-6.4.2-3">¶</a></p>
<p id="section-6.4.2-4" style="margin-left: 1.5em">R &lt;= I_X*(c-r_h)/c<a class="pilcrow" href="#section-6.4.2-4">¶</a></p>
<p id="section-6.4.2-5">
                where I_X is the idleslope of credit-based shaper for class X={A,B}, c is the transmission rate of the output link, and r_h is the leaky-bucket rate of the CDT class.<a class="pilcrow" href="#section-6.4.2-5">¶</a></p>
</section>
</div>
</section>
</div>
<div id="intserv">
<section id="section-6.5">
        <h3 id="name-guaranteed-service">
<a class="section-number selfRef" href="#section-6.5">6.5. </a><a class="section-name selfRef" href="#name-guaranteed-service">Guaranteed Service</a>
        </h3>
<p id="section-6.5-1">The Guaranteed Service is defined in <span>[<a class="cite xref" href="#RFC2212">RFC2212</a>]</span>. The flow, at the source, has a leaky-bucket arrival curve with two parameters: r as rate and b as bucket size, i.e., the amount of bits entering a node within a time interval t is bounded by r * t + b.<a class="pilcrow" href="#section-6.5-1">¶</a></p>
<p id="section-6.5-2">If a resource reservation on a path is applied, a node provides a guaranteed rate R and maximum service latency of T. This can be interpreted in a way that the bits might have to wait up to T before being served with a rate greater or equal to R. The delay bound of the flow traversing the node is T + b / R.<a class="pilcrow" href="#section-6.5-2">¶</a></p>
<p id="section-6.5-3">Consider a Guaranteed Service <span>[<a class="cite xref" href="#RFC2212">RFC2212</a>]</span> path including a sequence of nodes, where the i-th node provides a guaranteed rate R_i and maximum service latency of T_i. 
 Then, the end-to-end delay bound for a flow on this can be calculated as sum(T_i) + b / min(R_i).<a class="pilcrow" href="#section-6.5-3">¶</a></p>
<p id="section-6.5-4">The provided delay bound is based on a simple case of Guaranteed Service, where only a guaranteed rate and maximum service latency and a leaky-bucket arrival curve are available.  If more information about the flow is known, e.g., the peak rate, the delay bound is more complicated; the details are available in <span>[<a class="cite xref" href="#RFC2212">RFC2212</a>]</span> and Section 1.4.1 of <span>[<a class="cite xref" href="#NetCalBook">NetCalBook</a>]</span>.<a class="pilcrow" href="#section-6.5-4">¶</a></p>
</section>
</div>
<div id="cqf">
<section id="section-6.6">
        <h3 id="name-cyclic-queuing-and-forwardi">
<a class="section-number selfRef" href="#section-6.6">6.6. </a><a class="section-name selfRef" href="#name-cyclic-queuing-and-forwardi">Cyclic Queuing and Forwarding</a>
        </h3>
<p id="section-6.6-1">
         Annex T of <span>[<a class="cite xref" href="#IEEE8021Q">IEEE8021Q</a>]</span> describes Cyclic Queuing
         and Forwarding (CQF), which provides bounded latency and zero congestion loss using
         the time-scheduled gates of Section 8.6.8.4 of <span>[<a class="cite xref" href="#IEEE8021Q">IEEE8021Q</a>]</span>.  For a given class of DetNet
         flows, a set of two or more buffers is provided at the output queue layer of
         <a class="auto internal xref" href="#fig_8021Q_data_model">Figure 3</a>.  A cycle time T_c is configured for each class of DetNet
         flows c, and all of the buffer sets in a class of DetNet
         flows swap buffers simultaneously throughout the DetNet domain
         at that cycle rate, all in phase. In such a mechanism, the regulator, as mentioned in <a class="auto internal xref" href="#fig_timing_model">Figure 1</a>, is not required.<a class="pilcrow" href="#section-6.6-1">¶</a></p>
<p id="section-6.6-2">
        In the case of two-buffer CQF, each class of DetNet flows c has two buffers, namely buffer1 and buffer2. In a cycle (i) when buffer1 accumulates received packets from the node's reception ports, buffer2 transmits the already stored packets from the previous cycle (i-1). In the next cycle (i+1), buffer2 stores the received packets and buffer1 transmits the packets received in cycle (i). The duration of each cycle is T_c.<a class="pilcrow" href="#section-6.6-2">¶</a></p>
<p id="section-6.6-3">
        The cycle time T_c must be carefully chosen; it needs to be large enough to accommodate all the DetNet traffic, plus at least one maximum packet (or fragment) size from lower priority queues, which might be received within a cycle. 
        Also, the value of T_c includes a time interval, called dead time (DT), which is the sum of delays 1, 2, 3, and 4 defined in <a class="auto internal xref" href="#fig_timing_model">Figure 1</a>. The value of DT guarantees that the last packet of one cycle in a node is fully delivered to a buffer of the next node in the same cycle. A two-buffer CQF is recommended if DT is small compared to T_c. For a large DT, CQF with more buffers can be used, and a cycle identification label can be added to the packets.<a class="pilcrow" href="#section-6.6-3">¶</a></p>
<p id="section-6.6-4">
        The per-hop latency is determined by the cycle time T_c: a packet transmitted from a node at a cycle (i) is transmitted from the next node at cycle (i+1). Then, if the packet traverses h hops, the maximum latency experienced by the packet is from 
         the beginning of cycle (i) to the end of cycle (i+h); also, the minimum latency is from the end of cycle (i), before the DT, to the beginning of cycle (i+h). Then, the maximum latency is:<a class="pilcrow" href="#section-6.6-4">¶</a></p>
<p id="section-6.6-5" style="margin-left: 1.5em">(h+1) T_c<a class="pilcrow" href="#section-6.6-5">¶</a></p>
<p id="section-6.6-6"> and the minimum latency is:<a class="pilcrow" href="#section-6.6-6">¶</a></p>
<p id="section-6.6-7" style="margin-left: 1.5em">(h-1) T_c + DT.<a class="pilcrow" href="#section-6.6-7">¶</a></p>
<p id="section-6.6-8">
         Ingress conditioning (<a class="auto internal xref" href="#ingress">Section 4.3</a>) may be required if the source of a DetNet flow does not itself employ CQF. Since there are no per-flow parameters in the CQF technique, per-hop configuration is not required in the CQF forwarding nodes.<a class="pilcrow" href="#section-6.6-8">¶</a></p>
</section>
</div>
</section>
</div>
<div id="example">
<section id="section-7">
      <h2 id="name-example-application-on-detn">
<a class="section-number selfRef" href="#section-7">7. </a><a class="section-name selfRef" href="#name-example-application-on-detn">Example Application on DetNet IP Network</a>
      </h2>
<p id="section-7-1">
        This section provides an example application of the timing model presented in this document to control the admission of a DetNet flow on a DetNet-enabled IP network. Consider <a class="auto internal xref" href="#fig_ip_detnet_simple">Figure 5</a>, taken from <span><a class="relref" href="https://www.rfc-editor.org/rfc/rfc8939#section-3">Section 3</a> of [<a class="cite xref" href="#RFC8939">RFC8939</a>]</span>, which shows a simple IP network:<a class="pilcrow" href="#section-7-1">¶</a></p>
<ul class="normal">
<li class="normal" id="section-7-2.1">
          End system 1 implements Guaranteed Service <span>[<a class="cite xref" href="#RFC2212">RFC2212</a>]</span>, as in <a class="auto internal xref" href="#intserv">Section 6.5</a>, between itself and relay node 1.<a class="pilcrow" href="#section-7-2.1">¶</a>
</li>
        <li class="normal" id="section-7-2.2">
                Sub-network 1 is a TSN network. The nodes in sub-network 1 implement credit-based shapers with asynchronous traffic shaping, as in <a class="auto internal xref" href="#TSNwithATSmodel">Section 6.4</a>.<a class="pilcrow" href="#section-7-2.2">¶</a>
</li>
        <li class="normal" id="section-7-2.3">
                Sub-network 2 is a TSN network. The nodes in sub-network 2 implement Cyclic Queuing and Forwarding with two buffers, as in <a class="auto internal xref" href="#cqf">Section 6.6</a>.<a class="pilcrow" href="#section-7-2.3">¶</a>
</li>
        <li class="normal" id="section-7-2.4">
                The relay nodes 1 and 2 implement credit-based shapers with asynchronous traffic shaping, as in <a class="auto internal xref" href="#TSNwithATSmodel">Section 6.4</a>. They also perform the aggregation and mapping of IP DetNet flows to TSN streams (<span><a class="relref" href="https://www.rfc-editor.org/rfc/rfc9023#section-4.4">Section 4.4</a> of [<a class="cite xref" href="#RFC9023">RFC9023</a>]</span>).<a class="pilcrow" href="#section-7-2.4">¶</a>
</li>
      </ul>
<span id="name-a-simple-detnet-enabled-ip-"></span><div id="fig_ip_detnet_simple">
<figure id="figure-5">
        <div class="alignLeft art-text artwork" id="section-7-3.1">
<pre> DetNet IP       Relay                        Relay       DetNet IP
 End System      Node 1                       Node 2      End System
     1                                                        2
+----------+                                             +----------+
|   Appl.  |&lt;------------ End-to-End Service -----------&gt;|   Appl.  |
+----------+  ............                 ...........   +----------+
| Service  |&lt;-: Service  :-- DetNet flow --: Service  :-&gt;| Service  |
+----------+  +----------+                 +----------+  +----------+
|Forwarding|  |Forwarding|                 |Forwarding|  |Forwarding|
+--------.-+  +-.------.-+                 +-.---.----+  +-------.--+
         : Link :       \      ,-----.      /     \   ,-----.   /
         +......+        +----[  Sub- ]----+       +-[  Sub- ]-+
                              [Network]              [Network]
                               `--1--'                `--2--'

         |&lt;--------------------- DetNet IP ---------------------&gt;|

|&lt;--- d1 ---&gt;|&lt;--------------- d2_p ---------------&gt;|&lt;-- d3_p --&gt;|
</pre>
</div>
<figcaption><a class="selfRef" href="#figure-5">Figure 5</a>:
<a class="selfRef" href="#name-a-simple-detnet-enabled-ip-">A Simple DetNet-Enabled IP Network, Taken from RFC 8939</a>
        </figcaption></figure>
</div>
<p id="section-7-4">Consider a fully centralized control plane for the network of <a class="auto internal xref" href="#fig_ip_detnet_simple">Figure 5</a>, as described in <span><a class="relref" href="https://datatracker.ietf.org/doc/html/draft-ietf-detnet-controller-plane-framework-02#section-3.2">Section 3.2</a> of [<a class="cite xref" href="#I-D.ietf-detnet-controller-plane-framework">DETNET-CONTROL-PLANE</a>]</span>. Suppose end system 1 wants to create a DetNet flow with a traffic specification destined to end system 2 with end-to-end delay bound requirement D. Therefore, the control plane receives a flow establishment request and calculates a number of valid paths through the network (<span><a class="relref" href="https://datatracker.ietf.org/doc/html/draft-ietf-detnet-controller-plane-framework-02#section-3.2">Section 3.2</a> of [<a class="cite xref" href="#I-D.ietf-detnet-controller-plane-framework">DETNET-CONTROL-PLANE</a>]</span>). To select a proper path, the control plane needs to compute an end-to-end delay bound at every node of each selected path p.<a class="pilcrow" href="#section-7-4">¶</a></p>
<p id="section-7-5">
    The end-to-end delay bound is d1 + d2_p + d3_p, where d1 is the delay bound from end system 1 to the entrance of relay node 1, d2_p is the delay bound for path p from relay node 1 to the entrance of the first node in sub-network 2, and d3_p is the delay bound of path p from the first node in sub-network 2 to end system 2. The computation of d1 is explained in <a class="auto internal xref" href="#intserv">Section 6.5</a>. Since the relay node 1, sub-network 1, and relay node 2 implement aggregate queuing, we use the results in Sections <a class="auto internal xref" href="#perclass">4.2.2</a> and <a class="auto internal xref" href="#TSNwithATSmodel">6.4</a> to compute d2_p for the path p. Finally, d3_p is computed using the delay bound computation of <a class="auto internal xref" href="#cqf">Section 6.6</a>. Any path p, such that d1 + d2_p + d3_p &lt;= D, satisfies the delay bound requirement of the flow. If there is no such path, the control plane may compute a new set of valid paths and redo the delay bound computation or reject the DetNet flow.<a class="pilcrow" href="#section-7-5">¶</a></p>
<p id="section-7-6">
    As soon as the control plane selects a path that satisfies the delay bound constraint, it allocates and reserves the resources in the path for the DetNet flow (<span><a class="relref" href="https://datatracker.ietf.org/doc/html/draft-ietf-detnet-controller-plane-framework-02#section-4.2">Section 4.2</a> of [<a class="cite xref" href="#I-D.ietf-detnet-controller-plane-framework">DETNET-CONTROL-PLANE</a>]</span>).<a class="pilcrow" href="#section-7-6">¶</a></p>
</section>
</div>
<section id="section-8">
      <h2 id="name-security-considerations">
<a class="section-number selfRef" href="#section-8">8. </a><a class="section-name selfRef" href="#name-security-considerations">Security Considerations</a>
      </h2>
<p id="section-8-1">
    Detailed security considerations for DetNet are cataloged in <span>[<a class="cite xref" href="#RFC9055">RFC9055</a>]</span>, and more general security considerations are described in <span>[<a class="cite xref" href="#RFC8655">RFC8655</a>]</span>.<a class="pilcrow" href="#section-8-1">¶</a></p>
<p id="section-8-2">
        Security aspects that are unique to DetNet are those whose aim is to provide the specific QoS aspects of DetNet, specifically bounded end-to-end delivery latency and zero congestion loss. Achieving such loss rates and bounded latency may not be possible in the face of a highly capable adversary, such as the one envisioned by the Internet Threat Model of BCP 72 <span>[<a class="cite xref" href="#RFC3552">RFC3552</a>]</span>, which can arbitrarily drop or delay any or all traffic. In order to present meaningful security considerations, we consider a somewhat weaker attacker who does not control the physical links of the DetNet domain but may have the ability to control or change the behavior of some resources within the boundary of the DetNet domain.<a class="pilcrow" href="#section-8-2">¶</a></p>
<p id="section-8-3">
        Latency bound calculations use parameters that reflect physical quantities. If an attacker finds a way to change the physical quantities, unknown to the control and management planes, the latency calculations fail and may result in latency violation and/or congestion losses. An example of such attacks is to make some traffic sources under the control of the attacker send more traffic than their assumed T-SPECs. This type of attack is typically avoided by ingress conditioning at the edge of a DetNet domain. However, it must be insured that such ingress conditioning is done per flow and that the buffers are segregated such that if one flow exceeds its T-SPEC, it does not cause buffer overflow for other flows.<a class="pilcrow" href="#section-8-3">¶</a></p>
<p id="section-8-4">
        Some queuing mechanisms require time synchronization and operate correctly only if the time synchronization works correctly. In the case of CQF, the correct alignments of cycles can fail if an attack against time synchronization fools a node into having an incorrect offset. Some of these attacks can be prevented by cryptographic authentication as in Annex K of <span>[<a class="cite xref" href="#IEEE1588">IEEE1588</a>]</span> for the Precision Time Protocol (PTP). However, the attacks that change the physical latency of the links used by the time synchronization protocol are still possible even if the time synchronization protocol is protected by authentication and cryptography <span>[<a class="cite xref" href="#DelayAttack">DelayAttack</a>]</span>. Such attacks can be detected only by their effects on latency bound violations and congestion losses, which do not occur in normal DetNet operation.<a class="pilcrow" href="#section-8-4">¶</a></p>
</section>
<section id="section-9">
      <h2 id="name-iana-considerations">
<a class="section-number selfRef" href="#section-9">9. </a><a class="section-name selfRef" href="#name-iana-considerations">IANA considerations</a>
      </h2>
<p id="section-9-1">
 This document has no IANA actions.<a class="pilcrow" href="#section-9-1">¶</a></p>
</section>
<section id="section-10">
      <h2 id="name-references">
<a class="section-number selfRef" href="#section-10">10. </a><a class="section-name selfRef" href="#name-references">References</a>
      </h2>
<section id="section-10.1">
        <h3 id="name-normative-references">
<a class="section-number selfRef" href="#section-10.1">10.1. </a><a class="section-name selfRef" href="#name-normative-references">Normative References</a>
        </h3>
<dl class="references">
<dt id="IEEE8021Q">[IEEE8021Q]</dt>
        <dd>
<span class="refAuthor">IEEE</span>, <span class="refTitle">"IEEE Standard for Local and Metropolitan Area Networks--Bridges and Bridged Networks"</span>, <span class="seriesInfo">IEEE Std 802.1Q-2018</span>, <span class="seriesInfo">DOI 10.1109/IEEESTD.2018.8403927</span>, <time class="refDate" datetime="2018-07">July 2018</time>, <span>&lt;<a href="https://ieeexplore.ieee.org/document/8403927">https://ieeexplore.ieee.org/document/8403927</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC2212">[RFC2212]</dt>
        <dd>
<span class="refAuthor">Shenker, S.</span>, <span class="refAuthor">Partridge, C.</span>, and <span class="refAuthor">R. Guerin</span>, <span class="refTitle">"Specification of Guaranteed Quality of Service"</span>, <span class="seriesInfo">RFC 2212</span>, <span class="seriesInfo">DOI 10.17487/RFC2212</span>, <time class="refDate" datetime="1997-09">September 1997</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc2212">https://www.rfc-editor.org/info/rfc2212</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC2475">[RFC2475]</dt>
        <dd>
<span class="refAuthor">Blake, S.</span>, <span class="refAuthor">Black, D.</span>, <span class="refAuthor">Carlson, M.</span>, <span class="refAuthor">Davies, E.</span>, <span class="refAuthor">Wang, Z.</span>, and <span class="refAuthor">W. Weiss</span>, <span class="refTitle">"An Architecture for Differentiated Services"</span>, <span class="seriesInfo">RFC 2475</span>, <span class="seriesInfo">DOI 10.17487/RFC2475</span>, <time class="refDate" datetime="1998-12">December 1998</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc2475">https://www.rfc-editor.org/info/rfc2475</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC6658">[RFC6658]</dt>
        <dd>
<span class="refAuthor">Bryant, S., Ed.</span>, <span class="refAuthor">Martini, L.</span>, <span class="refAuthor">Swallow, G.</span>, and <span class="refAuthor">A. Malis</span>, <span class="refTitle">"Packet Pseudowire Encapsulation over an MPLS PSN"</span>, <span class="seriesInfo">RFC 6658</span>, <span class="seriesInfo">DOI 10.17487/RFC6658</span>, <time class="refDate" datetime="2012-07">July 2012</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc6658">https://www.rfc-editor.org/info/rfc6658</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC7806">[RFC7806]</dt>
        <dd>
<span class="refAuthor">Baker, F.</span> and <span class="refAuthor">R. Pan</span>, <span class="refTitle">"On Queuing, Marking, and Dropping"</span>, <span class="seriesInfo">RFC 7806</span>, <span class="seriesInfo">DOI 10.17487/RFC7806</span>, <time class="refDate" datetime="2016-04">April 2016</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc7806">https://www.rfc-editor.org/info/rfc7806</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC8655">[RFC8655]</dt>
        <dd>
<span class="refAuthor">Finn, N.</span>, <span class="refAuthor">Thubert, P.</span>, <span class="refAuthor">Varga, B.</span>, and <span class="refAuthor">J. Farkas</span>, <span class="refTitle">"Deterministic Networking Architecture"</span>, <span class="seriesInfo">RFC 8655</span>, <span class="seriesInfo">DOI 10.17487/RFC8655</span>, <time class="refDate" datetime="2019-10">October 2019</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc8655">https://www.rfc-editor.org/info/rfc8655</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC8939">[RFC8939]</dt>
        <dd>
<span class="refAuthor">Varga, B., Ed.</span>, <span class="refAuthor">Farkas, J.</span>, <span class="refAuthor">Berger, L.</span>, <span class="refAuthor">Fedyk, D.</span>, and <span class="refAuthor">S. Bryant</span>, <span class="refTitle">"Deterministic Networking (DetNet) Data Plane: IP"</span>, <span class="seriesInfo">RFC 8939</span>, <span class="seriesInfo">DOI 10.17487/RFC8939</span>, <time class="refDate" datetime="2020-11">November 2020</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc8939">https://www.rfc-editor.org/info/rfc8939</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC8964">[RFC8964]</dt>
        <dd>
<span class="refAuthor">Varga, B., Ed.</span>, <span class="refAuthor">Farkas, J.</span>, <span class="refAuthor">Berger, L.</span>, <span class="refAuthor">Malis, A.</span>, <span class="refAuthor">Bryant, S.</span>, and <span class="refAuthor">J. Korhonen</span>, <span class="refTitle">"Deterministic Networking (DetNet) Data Plane: MPLS"</span>, <span class="seriesInfo">RFC 8964</span>, <span class="seriesInfo">DOI 10.17487/RFC8964</span>, <time class="refDate" datetime="2021-01">January 2021</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc8964">https://www.rfc-editor.org/info/rfc8964</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC9016">[RFC9016]</dt>
      <dd>
<span class="refAuthor">Varga, B.</span>, <span class="refAuthor">Farkas, J.</span>, <span class="refAuthor">Cummings, R.</span>, <span class="refAuthor">Jiang, Y.</span>, and <span class="refAuthor">D. Fedyk</span>, <span class="refTitle">"Flow and Service Information Model for Deterministic Networking (DetNet)"</span>, <span class="seriesInfo">RFC 9016</span>, <span class="seriesInfo">DOI 10.17487/RFC9016</span>, <time class="refDate" datetime="2021-03">March 2021</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc9016">https://www.rfc-editor.org/info/rfc9016</a>&gt;</span>. </dd>
<dd class="break"></dd>
</dl>
</section>
<section id="section-10.2">
        <h3 id="name-informative-references">
<a class="section-number selfRef" href="#section-10.2">10.2. </a><a class="section-name selfRef" href="#name-informative-references">Informative References</a>
        </h3>
<dl class="references">
<dt id="BennettDelay">[BennettDelay]</dt>
        <dd>
<span class="refAuthor">Bennett, J. C. R.</span>, <span class="refAuthor">Benson, K.</span>, <span class="refAuthor">Charny, A.</span>, <span class="refAuthor">Courtney, W. F.</span>, and <span class="refAuthor">J.-Y. Le Boudec</span>, <span class="refTitle">"Delay jitter bounds and packet scale rate guarantee for expedited forwarding"</span>, <span class="seriesInfo">DOI 10.1109/TNET.2002.801404</span>, <time class="refDate" datetime="2002-08">August 2002</time>, <span>&lt;<a href="https://dl.acm.org/citation.cfm?id=581870">https://dl.acm.org/citation.cfm?id=581870</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="CharnyDelay">[CharnyDelay]</dt>
        <dd>
<span class="refAuthor">Charny, A.</span> and <span class="refAuthor">J.-Y. Le Boudec</span>, <span class="refTitle">"Delay Bounds in a Network with Aggregate Scheduling"</span>, <span class="seriesInfo">DOI 10.1007/3-540-39939-9_1</span>, <time class="refDate" datetime="2002-09">September 2002</time>, <span>&lt;<a href="https://link.springer.com/chapter/10.1007/3-540-39939-9_1">https://link.springer.com/chapter/10.1007/3-540-39939-9_1</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="DelayAttack">[DelayAttack]</dt>
        <dd>
<span class="refAuthor">Barreto, S.</span>, <span class="refAuthor">Suresh, A.</span>, and <span class="refAuthor">J. L. Boudec</span>, <span class="refTitle">"Cyber-attack on packet-based time synchronization protocols: The undetectable Delay Box"</span>, <span class="seriesInfo">DOI 10.1109/I2MTC.2016.7520408</span>, <time class="refDate" datetime="2016-05">May 2016</time>, <span>&lt;<a href="https://ieeexplore.ieee.org/document/7520408">https://ieeexplore.ieee.org/document/7520408</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="I-D.ietf-detnet-controller-plane-framework">[DETNET-CONTROL-PLANE]</dt>
        <dd>
<span class="refAuthor">Malis, A.</span>, <span class="refAuthor">Geng, A., Ed.</span>, <span class="refAuthor">Chen, M.</span>, <span class="refAuthor">Qin, F.</span>, and <span class="refAuthor">B. Varga</span>, <span class="refTitle">"Deterministic Networking (DetNet) Controller Plane Framework"</span>, <span class="refContent">Work in Progress</span>, <span class="seriesInfo">Internet-Draft, draft-ietf-detnet-controller-plane-framework-02</span>, <time class="refDate" datetime="2022-06-28">28 June 2022</time>, <span>&lt;<a href="https://datatracker.ietf.org/doc/html/draft-ietf-detnet-controller-plane-framework-02">https://datatracker.ietf.org/doc/html/draft-ietf-detnet-controller-plane-framework-02</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="IEEE1588">[IEEE1588]</dt>
        <dd>
<span class="refAuthor">IEEE</span>, <span class="refTitle">"IEEE Standard for a Precision Clock Synchronization Protocol for Networked Measurement and Control Systems"</span>, <span class="seriesInfo">IEEE Std 1588-2008</span>, <span class="seriesInfo">DOI 10.1109/IEEESTD.2008.4579760</span>, <time class="refDate" datetime="2008-07">July 2008</time>, <span>&lt;<a href="https://ieeexplore.ieee.org/document/4579760">https://ieeexplore.ieee.org/document/4579760</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="IEEE8021Qcr">[IEEE8021Qcr]</dt>
        <dd>
<span class="refAuthor">IEEE 802.1</span>, <span class="refTitle">"802.1Qcr-2020 - IEEE Standard for Local and Metropolitan Area Networks--Bridges and Bridged Networks Amendment 34:Asynchronous Traffic Shaping"</span>, <time class="refDate" datetime="2020-11">November 2020</time>, <span>&lt;<a href="https://ieeexplore.ieee.org/document/9253013">https://ieeexplore.ieee.org/document/9253013</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="IEEE8021TSN">[IEEE8021TSN]</dt>
        <dd>
<span class="refAuthor">IEEE 802.1</span>, <span class="refTitle">"802.1 Time-Sensitive Networking (TSN) Task Group"</span>, <span>&lt;<a href="https://1.ieee802.org/tsn/">https://1.ieee802.org/tsn/</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="IEEE8023">[IEEE8023]</dt>
        <dd>
<span class="refAuthor">IEEE</span>, <span class="refTitle">"IEEE Standard for Ethernet"</span>, <span class="seriesInfo">IEEE Std 802.3-2018</span>, <span class="seriesInfo">DOI 10.1109/IEEESTD.2018.8457469</span>, <time class="refDate" datetime="2018-08">August 2018</time>, <span>&lt;<a href="http://ieeexplore.ieee.org/document/8457469">http://ieeexplore.ieee.org/document/8457469</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="LeBoudecTheory">[LeBoudecTheory]</dt>
        <dd>
<span class="refAuthor">Le Boudec, J.-Y.</span>, <span class="refTitle">"A Theory of Traffic Regulators for Deterministic Networks With Application to Interleaved Regulators"</span>, <span class="seriesInfo">DOI 10.1109/TNET.2018.2875191</span>, <time class="refDate" datetime="2018-11">November 2018</time>, <span>&lt;<a href="https://ieeexplore.ieee.org/document/8519761">https://ieeexplore.ieee.org/document/8519761</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="NetCalBook">[NetCalBook]</dt>
        <dd>
<span class="refAuthor">Le Boudec, J.-Y.</span> and <span class="refAuthor">P. Thiran</span>, <span class="refTitle">"Network Calculus: A Theory of Deterministic Queuing Systems for the Internet"</span>, <span class="refContent">Springer Science &amp; Business Media, vol. 2050</span>, <time class="refDate" datetime="2001">2001</time>, <span>&lt;<a href="https://leboudec.github.io/netcal/latex/netCalBook.pdf">https://leboudec.github.io/netcal/latex/netCalBook.pdf</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="PacketReorderingBounds">[PacketReorderingBounds]</dt>
        <dd>
<span class="refAuthor">Mohammadpour, E.</span> and <span class="refAuthor">J.-Y. Le Boudec</span>, <span class="refTitle">"On Packet Reordering in Time-Sensitive Networks"</span>, <span class="seriesInfo">DOI 10.1109/TNET.2021.3129590</span>, <time class="refDate" datetime="2021-12">December 2021</time>, <span>&lt;<a href="https://ieeexplore.ieee.org/document/9640523">https://ieeexplore.ieee.org/document/9640523</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC2697">[RFC2697]</dt>
        <dd>
<span class="refAuthor">Heinanen, J.</span> and <span class="refAuthor">R. Guerin</span>, <span class="refTitle">"A Single Rate Three Color Marker"</span>, <span class="seriesInfo">RFC 2697</span>, <span class="seriesInfo">DOI 10.17487/RFC2697</span>, <time class="refDate" datetime="1999-09">September 1999</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc2697">https://www.rfc-editor.org/info/rfc2697</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC3552">[RFC3552]</dt>
        <dd>
<span class="refAuthor">Rescorla, E.</span> and <span class="refAuthor">B. Korver</span>, <span class="refTitle">"Guidelines for Writing RFC Text on Security Considerations"</span>, <span class="seriesInfo">BCP 72</span>, <span class="seriesInfo">RFC 3552</span>, <span class="seriesInfo">DOI 10.17487/RFC3552</span>, <time class="refDate" datetime="2003-07">July 2003</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc3552">https://www.rfc-editor.org/info/rfc3552</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC8578">[RFC8578]</dt>
        <dd>
<span class="refAuthor">Grossman, E., Ed.</span>, <span class="refTitle">"Deterministic Networking Use Cases"</span>, <span class="seriesInfo">RFC 8578</span>, <span class="seriesInfo">DOI 10.17487/RFC8578</span>, <time class="refDate" datetime="2019-05">May 2019</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc8578">https://www.rfc-editor.org/info/rfc8578</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC9023">[RFC9023]</dt>
        <dd>
<span class="refAuthor">Varga, B., Ed.</span>, <span class="refAuthor">Farkas, J.</span>, <span class="refAuthor">Malis, A.</span>, and <span class="refAuthor">S. Bryant</span>, <span class="refTitle">"Deterministic Networking (DetNet) Data Plane: IP over IEEE 802.1 Time-Sensitive Networking (TSN)"</span>, <span class="seriesInfo">RFC 9023</span>, <span class="seriesInfo">DOI 10.17487/RFC9023</span>, <time class="refDate" datetime="2021-06">June 2021</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc9023">https://www.rfc-editor.org/info/rfc9023</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC9055">[RFC9055]</dt>
        <dd>
<span class="refAuthor">Grossman, E., Ed.</span>, <span class="refAuthor">Mizrahi, T.</span>, and <span class="refAuthor">A. Hacker</span>, <span class="refTitle">"Deterministic Networking (DetNet) Security Considerations"</span>, <span class="seriesInfo">RFC 9055</span>, <span class="seriesInfo">DOI 10.17487/RFC9055</span>, <time class="refDate" datetime="2021-06">June 2021</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc9055">https://www.rfc-editor.org/info/rfc9055</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="Sch8021Qbv">[Sch8021Qbv]</dt>
        <dd>
<span class="refAuthor">Craciunas, S.</span>, <span class="refAuthor">Oliver, R.</span>, <span class="refAuthor">Chmelik, M.</span>, and <span class="refAuthor">W. Steiner</span>, <span class="refTitle">"Scheduling Real-Time Communication in IEEE 802.1Qbv Time Sensitive Networks"</span>, <span class="seriesInfo">DOI 10.1145/2997465.2997470</span>, <time class="refDate" datetime="2016-10">October 2016</time>, <span>&lt;<a href="https://dl.acm.org/doi/10.1145/2997465.2997470">https://dl.acm.org/doi/10.1145/2997465.2997470</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="SpechtUBS">[SpechtUBS]</dt>
        <dd>
<span class="refAuthor">Specht, J.</span> and <span class="refAuthor">S. Samii</span>, <span class="refTitle">"Urgency-Based Scheduler for Time-Sensitive Switched Ethernet Networks"</span>, <span class="seriesInfo">DOI 10.1109/ECRTS.2016.27</span>, <time class="refDate" datetime="2016-07">July 2016</time>, <span>&lt;<a href="https://ieeexplore.ieee.org/abstract/document/7557870">https://ieeexplore.ieee.org/abstract/document/7557870</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="ThomasTime">[ThomasTime]</dt>
        <dd>
<span class="refAuthor">Thomas, L.</span> and <span class="refAuthor">J.-Y. Le Boudec</span>, <span class="refTitle">"On Time Synchronization Issues in Time-Sensitive Networks with Regulators and Nonideal Clocks"</span>, <span class="seriesInfo">DOI 10.1145/3393691.339420</span>, <time class="refDate" datetime="2020-06">June 2020</time>, <span>&lt;<a href="https://dl.acm.org/doi/10.1145/3393691.3394206">https://dl.acm.org/doi/10.1145/3393691.3394206</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="TSNwithATS">[TSNwithATS]</dt>
      <dd>
<span class="refAuthor">Mohammadpour, E.</span>, <span class="refAuthor">Stai, E.</span>, <span class="refAuthor">Mohiuddin, M.</span>, and <span class="refAuthor">J.-Y. Le Boudec</span>, <span class="refTitle">"Latency and Backlog Bounds in Time-Sensitive Networking with Credit Based Shapers and Asynchronous Traffic Shaping"</span>, <span class="seriesInfo">DOI 10.1109/ITC30.2018.10053</span>, <time class="refDate" datetime="2018-09">September 2018</time>, <span>&lt;<a href="https://ieeexplore.ieee.org/document/8493026">https://ieeexplore.ieee.org/document/8493026</a>&gt;</span>. </dd>
<dd class="break"></dd>
</dl>
</section>
</section>
<section id="appendix-A">
      <h2 id="name-acknowledgments">
<a class="section-name selfRef" href="#name-acknowledgments">Acknowledgments</a>
      </h2>
<p id="appendix-A-1">We would like to thank <span class="contact-name">Lou Berger</span>, <span class="contact-name">Tony Przygienda</span>, <span class="contact-name">John Scudder</span>, <span class="contact-name">Watson Ladd</span>, <span class="contact-name">Yoshifumi Nishida</span>, <span class="contact-name">Ralf Weber</span>, <span class="contact-name">Robert Sparks</span>, <span class="contact-name">Gyan Mishra</span>, <span class="contact-name">Martin Duke</span>, <span class="contact-name">Éric Vyncke</span>, <span class="contact-name">Lars Eggert</span>, <span class="contact-name">Roman Danyliw</span>, and <span class="contact-name">Paul Wouters</span> for their useful feedback on this document.<a class="pilcrow" href="#appendix-A-1">¶</a></p>
</section>
<section id="appendix-B">
      <h2 id="name-contributors">
<a class="section-name selfRef" href="#name-contributors">Contributors</a>
      </h2>
<p id="appendix-B-1">RFC 7322 limits the number of authors listed on the front page to a maximum of 5. The editor wishes to thank and acknowledge the following author for contributing text to this document:<a class="pilcrow" href="#appendix-B-1">¶</a></p>
<address class="vcard">
        <div class="left" dir="auto"><span class="fn nameRole">Janos Farkas</span></div>
<div class="left" dir="auto"><span class="org">Ericsson</span></div>
<div class="email">
<span>Email:</span>
<a class="email" href="mailto:janos.farkas@ericsson.com">janos.farkas@ericsson.com</a>
</div>
</address>
</section>
<div id="authors-addresses">
<section id="appendix-C">
      <h2 id="name-authors-addresses">
<a class="section-name selfRef" href="#name-authors-addresses">Authors' Addresses</a>
      </h2>
<address class="vcard">
        <div class="left" dir="auto"><span class="fn nameRole">Norman Finn</span></div>
<div class="left" dir="auto"><span class="org">Huawei Technologies Co. Ltd</span></div>
<div class="left" dir="auto"><span class="street-address">3101 Rio Way</span></div>
<div class="left" dir="auto">
<span class="locality">Spring Valley</span>, <span class="region">California</span> <span class="postal-code">91977</span>
</div>
<div class="left" dir="auto"><span class="country-name">United States of America</span></div>
<div class="tel">
<span>Phone:</span>
<a class="tel" href="tel:+1%20925%20980%206430">+1 925 980 6430</a>
</div>
<div class="email">
<span>Email:</span>
<a class="email" href="mailto:nfinn@nfinnconsulting.com">nfinn@nfinnconsulting.com</a>
</div>
</address>
<address class="vcard">
        <div class="left" dir="auto"><span class="fn nameRole">Jean-Yves Le Boudec</span></div>
<div class="left" dir="auto"><span class="org">EPFL</span></div>
<div class="left" dir="auto"><span class="street-address">IC Station 14</span></div>
<div class="left" dir="auto">CH-<span class="postal-code">1015</span> <span class="locality">Lausanne</span>
</div>
<div class="left" dir="auto"><span class="country-name">Switzerland</span></div>
<div class="email">
<span>Email:</span>
<a class="email" href="mailto:jean-yves.leboudec@epfl.ch">jean-yves.leboudec@epfl.ch</a>
</div>
</address>
<address class="vcard">
        <div class="left" dir="auto"><span class="fn nameRole">Ehsan Mohammadpour</span></div>
<div class="left" dir="auto"><span class="org">EPFL</span></div>
<div class="left" dir="auto"><span class="street-address">IC Station 14</span></div>
<div class="left" dir="auto">CH-<span class="postal-code">1015</span> <span class="locality">Lausanne</span>
</div>
<div class="left" dir="auto"><span class="country-name">Switzerland</span></div>
<div class="email">
<span>Email:</span>
<a class="email" href="mailto:ehsan.mohammadpour@epfl.ch">ehsan.mohammadpour@epfl.ch</a>
</div>
</address>
<address class="vcard">
        <div class="left" dir="auto"><span class="fn nameRole">Jiayi Zhang</span></div>
<div class="left" dir="auto"><span class="org">Huawei Technologies Co. Ltd</span></div>
<div class="left" dir="auto"><span class="street-address">Q27, No.156 Beiqing Road</span></div>
<div class="left" dir="auto"><span class="locality">Beijing</span></div>
<div class="left" dir="auto"><span class="postal-code">100095</span></div>
<div class="left" dir="auto"><span class="country-name">China</span></div>
<div class="email">
<span>Email:</span>
<a class="email" href="mailto:zhangjiayi11@huawei.com">zhangjiayi11@huawei.com</a>
</div>
</address>
<address class="vcard">
        <div class="left" dir="auto"><span class="fn nameRole">Balázs Varga</span></div>
<div class="left" dir="auto"><span class="org">Ericsson</span></div>
<div class="left" dir="auto"><span class="locality">Budapest</span></div>
<div class="left" dir="auto"><span class="street-address">Konyves Kálmán krt. 11/B</span></div>
<div class="left" dir="auto"><span class="postal-code">1097</span></div>
<div class="left" dir="auto"><span class="country-name">Hungary</span></div>
<div class="email">
<span>Email:</span>
<a class="email" href="mailto:balazs.a.varga@ericsson.com">balazs.a.varga@ericsson.com</a>
</div>
</address>
</section>
</div>
<script>const toc = document.getElementById("toc");
toc.querySelector("h2").addEventListener("click", e => {
  toc.classList.toggle("active");
});
toc.querySelector("nav").addEventListener("click", e => {
  toc.classList.remove("active");
});
</script>


</body></html>