<html><head></head><body><pre>Internet Engineering Task Force (IETF)                      J. Dickinson
Request for Comments: 8618                                      J. Hague
Category: Standards Track                                   S. Dickinson
ISSN: 2070-1721                                               Sinodun IT
                                                            T. Manderson
                                                                   ICANN
                                                                 J. Bond
                                              Wikimedia Foundation, Inc.
                                                          September 2019


         <span class="h1">Compacted-DNS (C-DNS): A Format for DNS Packet Capture</span>

Abstract

   This document describes a data representation for collections of DNS
   messages.  The format is designed for efficient storage and
   transmission of large packet captures of DNS traffic; it attempts to
   minimize the size of such packet capture files but retain the full
   DNS message contents along with the most useful transport metadata.
   It is intended to assist with the development of DNS traffic-
   monitoring applications.

Status of This Memo

   This is an Internet Standards Track document.

   This document is a product of the Internet Engineering Task Force
   (IETF).  It represents the consensus of the IETF community.  It has
   received public review and has been approved for publication by the
   Internet Engineering Steering Group (IESG).  Further information on
   Internet Standards is available in <a href="./rfc7841#section-2">SectionÂ 2 of RFC 7841</a>.

   Information about the current status of this document, any errata,
   and how to provide feedback on it may be obtained at
   <a href="https://www.rfc-editor.org/info/rfc8618">https://www.rfc-editor.org/info/rfc8618</a>.















<span class="grey">Dickinson, et al.            Standards Track                    [Page 1]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-2"></span>
<span class="grey"><a href="./rfc8618">RFC 8618</a>         C-DNS: A Format for DNS Packet Capture   September 2019</span>


Copyright Notice

   Copyright (c) 2019 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to <a href="https://www.rfc-editor.org/bcp/bcp78">BCP 78</a> and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (<a href="https://trustee.ietf.org/license-info">https://trustee.ietf.org/license-info</a>) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.

Table of Contents

   <a href="#section-1">1</a>.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   <a href="#page-4">4</a>
   <a href="#section-2">2</a>.  Terminology . . . . . . . . . . . . . . . . . . . . . . . . .   <a href="#page-5">5</a>
   <a href="#section-3">3</a>.  Data Collection Use Cases . . . . . . . . . . . . . . . . . .   <a href="#page-5">5</a>
   <a href="#section-4">4</a>.  Design Considerations . . . . . . . . . . . . . . . . . . . .   <a href="#page-8">8</a>
   <a href="#section-5">5</a>.  Choice of CBOR  . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-10">10</a>
   <a href="#section-6">6</a>.  C-DNS Format Conceptual Overview  . . . . . . . . . . . . . .  <a href="#page-10">10</a>
     <a href="#section-6.1">6.1</a>.  Block Parameters  . . . . . . . . . . . . . . . . . . . .  <a href="#page-14">14</a>
     <a href="#section-6.2">6.2</a>.  Storage Parameters  . . . . . . . . . . . . . . . . . . .  <a href="#page-14">14</a>
       <a href="#section-6.2.1">6.2.1</a>.  Optional Data Items . . . . . . . . . . . . . . . . .  <a href="#page-15">15</a>
       <a href="#section-6.2.2">6.2.2</a>.  Optional RRs and OPCODEs  . . . . . . . . . . . . . .  <a href="#page-16">16</a>
       <a href="#section-6.2.3">6.2.3</a>.  Storage Flags . . . . . . . . . . . . . . . . . . . .  <a href="#page-17">17</a>
       <a href="#section-6.2.4">6.2.4</a>.  IP Address Storage  . . . . . . . . . . . . . . . . .  <a href="#page-17">17</a>
   <a href="#section-7">7</a>.  C-DNS Format Detailed Description . . . . . . . . . . . . . .  <a href="#page-18">18</a>
     <a href="#section-7.1">7.1</a>.  Map Quantities and Indexes  . . . . . . . . . . . . . . .  <a href="#page-18">18</a>
     <a href="#section-7.2">7.2</a>.  Tabular Representation  . . . . . . . . . . . . . . . . .  <a href="#page-18">18</a>
     <a href="#section-7.3">7.3</a>.  "File"  . . . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-19">19</a>
       <a href="#section-7.3.1">7.3.1</a>.  "FilePreamble"  . . . . . . . . . . . . . . . . . . .  <a href="#page-20">20</a>
         <a href="#section-7.3.1.1">7.3.1.1</a>.  "BlockParameters" . . . . . . . . . . . . . . . .  <a href="#page-20">20</a>
           <a href="#section-7.3.1.1.1">7.3.1.1.1</a>.  "StorageParameters" . . . . . . . . . . . . .  <a href="#page-21">21</a>
             <a href="#section-7.3.1.1.1.1">7.3.1.1.1.1</a>.  "StorageHints"  . . . . . . . . . . . . .  <a href="#page-22">22</a>
           <a href="#section-7.3.1.1.2">7.3.1.1.2</a>.  "CollectionParameters"  . . . . . . . . . . .  <a href="#page-24">24</a>
       <a href="#section-7.3.2">7.3.2</a>.  "Block" . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-25">25</a>
         <a href="#section-7.3.2.1">7.3.2.1</a>.  "BlockPreamble" . . . . . . . . . . . . . . . . .  <a href="#page-26">26</a>
         <a href="#section-7.3.2.2">7.3.2.2</a>.  "BlockStatistics" . . . . . . . . . . . . . . . .  <a href="#page-27">27</a>
         <a href="#section-7.3.2.3">7.3.2.3</a>.  "BlockTables" . . . . . . . . . . . . . . . . . .  <a href="#page-28">28</a>
           <a href="#section-7.3.2.3.1">7.3.2.3.1</a>.  "ClassType" . . . . . . . . . . . . . . . . .  <a href="#page-29">29</a>
           <a href="#section-7.3.2.3.2">7.3.2.3.2</a>.  "QueryResponseSignature"  . . . . . . . . . .  <a href="#page-30">30</a>
           <a href="#section-7.3.2.3.3">7.3.2.3.3</a>.  "Question"  . . . . . . . . . . . . . . . . .  <a href="#page-33">33</a>
           <a href="#section-7.3.2.3.4">7.3.2.3.4</a>.  "RR"  . . . . . . . . . . . . . . . . . . . .  <a href="#page-34">34</a>
           <a href="#section-7.3.2.3.5">7.3.2.3.5</a>.  "MalformedMessageData"  . . . . . . . . . . .  <a href="#page-34">34</a>




<span class="grey">Dickinson, et al.            Standards Track                    [Page 2]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-3"></span>
<span class="grey"><a href="./rfc8618">RFC 8618</a>         C-DNS: A Format for DNS Packet Capture   September 2019</span>


         <a href="#section-7.3.2.4">7.3.2.4</a>.  "QueryResponse" . . . . . . . . . . . . . . . . .  <a href="#page-35">35</a>
           <a href="#section-7.3.2.4.1">7.3.2.4.1</a>.  "ResponseProcessingData"  . . . . . . . . . .  <a href="#page-36">36</a>
           <a href="#section-7.3.2.4.2">7.3.2.4.2</a>.  "QueryResponseExtended" . . . . . . . . . . .  <a href="#page-37">37</a>
         <a href="#section-7.3.2.5">7.3.2.5</a>.  "AddressEventCount" . . . . . . . . . . . . . . .  <a href="#page-38">38</a>
         <a href="#section-7.3.2.6">7.3.2.6</a>.  "MalformedMessage"  . . . . . . . . . . . . . . .  <a href="#page-39">39</a>
   <a href="#section-8">8</a>.  Versioning  . . . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-39">39</a>
   <a href="#section-9">9</a>.  C-DNS to PCAP . . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-40">40</a>
     <a href="#section-9.1">9.1</a>.  Name Compression  . . . . . . . . . . . . . . . . . . . .  <a href="#page-42">42</a>
   <a href="#section-10">10</a>. Data Collection . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-42">42</a>
     <a href="#section-10.1">10.1</a>.  Matching Algorithm . . . . . . . . . . . . . . . . . . .  <a href="#page-43">43</a>
     <a href="#section-10.2">10.2</a>.  Message Identifiers  . . . . . . . . . . . . . . . . . .  <a href="#page-45">45</a>
       <a href="#section-10.2.1">10.2.1</a>.  Primary ID (Required)  . . . . . . . . . . . . . . .  <a href="#page-45">45</a>
       <a href="#section-10.2.2">10.2.2</a>.  Secondary ID (Optional)  . . . . . . . . . . . . . .  <a href="#page-46">46</a>
     <a href="#section-10.3">10.3</a>.  Algorithm Parameters . . . . . . . . . . . . . . . . . .  <a href="#page-46">46</a>
     <a href="#section-10.4">10.4</a>.  Algorithm Requirements . . . . . . . . . . . . . . . . .  <a href="#page-46">46</a>
     <a href="#section-10.5">10.5</a>.  Algorithm Limitations  . . . . . . . . . . . . . . . . .  <a href="#page-47">47</a>
     <a href="#section-10.6">10.6</a>.  Workspace  . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-47">47</a>
     <a href="#section-10.7">10.7</a>.  Output . . . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-47">47</a>
     <a href="#section-10.8">10.8</a>.  Post-Processing  . . . . . . . . . . . . . . . . . . . .  <a href="#page-47">47</a>
   <a href="#section-11">11</a>. Implementation Guidance . . . . . . . . . . . . . . . . . . .  <a href="#page-47">47</a>
     <a href="#section-11.1">11.1</a>.  Optional Data  . . . . . . . . . . . . . . . . . . . . .  <a href="#page-48">48</a>
     <a href="#section-11.2">11.2</a>.  Trailing Bytes . . . . . . . . . . . . . . . . . . . . .  <a href="#page-48">48</a>
     <a href="#section-11.3">11.3</a>.  Limiting Collection of RDATA . . . . . . . . . . . . . .  <a href="#page-49">49</a>
     <a href="#section-11.4">11.4</a>.  Timestamps . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-49">49</a>
   <a href="#section-12">12</a>. IANA Considerations . . . . . . . . . . . . . . . . . . . . .  <a href="#page-49">49</a>
     <a href="#section-12.1">12.1</a>.  Transport Types  . . . . . . . . . . . . . . . . . . . .  <a href="#page-49">49</a>
     <a href="#section-12.2">12.2</a>.  Data Storage Flags . . . . . . . . . . . . . . . . . . .  <a href="#page-50">50</a>
     <a href="#section-12.3">12.3</a>.  Response-Processing Flags  . . . . . . . . . . . . . . .  <a href="#page-51">51</a>
     <a href="#section-12.4">12.4</a>.  AddressEvent Types . . . . . . . . . . . . . . . . . . .  <a href="#page-51">51</a>
   <a href="#section-13">13</a>. Security Considerations . . . . . . . . . . . . . . . . . . .  <a href="#page-52">52</a>
   <a href="#section-14">14</a>. Privacy Considerations  . . . . . . . . . . . . . . . . . . .  <a href="#page-52">52</a>
   <a href="#section-15">15</a>. References  . . . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-53">53</a>
     <a href="#section-15.1">15.1</a>.  Normative References . . . . . . . . . . . . . . . . . .  <a href="#page-53">53</a>
     <a href="#section-15.2">15.2</a>.  Informative References . . . . . . . . . . . . . . . . .  <a href="#page-55">55</a>
   <a href="#appendix-A">Appendix A</a>.  CDDL . . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-58">58</a>
   <a href="#appendix-B">Appendix B</a>.  DNS Name Compression Example . . . . . . . . . . . .  <a href="#page-69">69</a>
     <a href="#appendix-B.1">B.1</a>.  NSD Compression Algorithm . . . . . . . . . . . . . . . .  <a href="#page-70">70</a>
     <a href="#appendix-B.2">B.2</a>.  Knot Authoritative Compression Algorithm  . . . . . . . .  <a href="#page-70">70</a>
     <a href="#appendix-B.3">B.3</a>.  Observed Differences  . . . . . . . . . . . . . . . . . .  <a href="#page-71">71</a>
   <a href="#appendix-C">Appendix C</a>.  Comparison of Binary Formats . . . . . . . . . . . .  <a href="#page-71">71</a>
     <a href="#appendix-C.1">C.1</a>.  Comparison with Full PCAP Files . . . . . . . . . . . . .  <a href="#page-74">74</a>
     <a href="#appendix-C.2">C.2</a>.  Simple versus Block Coding  . . . . . . . . . . . . . . .  <a href="#page-74">74</a>
     <a href="#appendix-C.3">C.3</a>.  Binary versus Text Formats  . . . . . . . . . . . . . . .  <a href="#page-75">75</a>
     <a href="#appendix-C.4">C.4</a>.  Performance . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-75">75</a>
     <a href="#appendix-C.5">C.5</a>.  Conclusions . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-75">75</a>
     <a href="#appendix-C.6">C.6</a>.  Block Size Choice . . . . . . . . . . . . . . . . . . . .  <a href="#page-76">76</a>





<span class="grey">Dickinson, et al.            Standards Track                    [Page 3]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-4"></span>
<span class="grey"><a href="./rfc8618">RFC 8618</a>         C-DNS: A Format for DNS Packet Capture   September 2019</span>


   <a href="#appendix-D">Appendix D</a>.  Data Fields for Traffic Regeneration . . . . . . . .  <a href="#page-77">77</a>
     <a href="#appendix-D.1">D.1</a>.  Recommended Fields for Traffic Regeneration . . . . . . .  <a href="#page-77">77</a>
     <a href="#appendix-D.2">D.2</a>.  Issues with Small Data Captures . . . . . . . . . . . . .  <a href="#page-77">77</a>
   Acknowledgements  . . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-78">78</a>
   Authors' Addresses  . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-79">79</a>

<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/1.%20%20Introduction"></a><a class="selflink" href="#section-1" id="section-1">1</a>.  Introduction</span>

   There has long been a need for server operators to collect DNS
   Queries and Responses on authoritative and recursive name servers for
   monitoring and analysis.  This data is used in a number of ways,
   including traffic monitoring, analyzing network attacks, and "day in
   the life" (DITL) [<a href="#ref-ditl" title='"DITL"'>ditl</a>] analysis.

   A wide variety of tools already exist that facilitate the collection
   of DNS traffic data, such as the DNS Statistics Collector (DSC)
   [<a href="#ref-dsc" title='"DSC"'>dsc</a>], packetq [<a href="#ref-packetq" title='"PacketQ"'>packetq</a>], dnscap [<a href="#ref-dnscap" title='"DNSCAP"'>dnscap</a>], and dnstap [<a href="#ref-dnstap" title='"dnstap"'>dnstap</a>].
   However, there is no standard exchange format for large DNS packet
   captures.  The PCAP ("packet capture") [<a href="#ref-pcap" title='"PCAP"'>pcap</a>] format or the PCAP Next
   Generation (PCAP-NG) [<a href="#ref-pcapng" title='"pcapng: PCAP next generation file format specification"'>pcapng</a>] format is typically used in practice
   for packet captures, but these file formats can contain a great deal
   of additional information that is not directly pertinent to DNS
   traffic analysis and thus unnecessarily increases the capture file
   size.  Additionally, these tools and formats typically have no filter
   mechanism to selectively record only certain fields at capture time,
   requiring post-processing for anonymization or pseudonymization of
   data to protect user privacy.

   There has also been work on using text-based formats to describe DNS
   packets (for example, see [<a href="#ref-dnsxml" title='"dnsxml - A standard XML representation of DNS data"'>dnsxml</a>] and [<a href="./rfc8427" title='"Representing DNS Messages in JSON"'>RFC8427</a>]), but this work is
   largely aimed at producing convenient representations of single
   messages.

   Many DNS operators may receive hundreds of thousands of Queries per
   second on a single name server instance, so a mechanism to minimize
   the storage and transmission size (and therefore upload overhead) of
   the data collected is highly desirable.

   The format described in this document, C-DNS (Compacted-DNS), focuses
   on the problem of capturing and storing large packet capture files of
   DNS traffic with the following goals in mind:

   o  Minimize the file size for storage and transmission.

   o  Minimize the overhead of producing the packet capture file and the
      cost of any further (general-purpose) compression of the file.





<span class="grey">Dickinson, et al.            Standards Track                    [Page 4]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-5"></span>
<span class="grey"><a href="./rfc8618">RFC 8618</a>         C-DNS: A Format for DNS Packet Capture   September 2019</span>


   This document contains:

   o  A discussion of some common use cases in which DNS data is
      collected; see <a href="#section-3">Section 3</a>.

   o  A discussion of the major design considerations in developing an
      efficient data representation for collections of DNS messages; see
      <a href="#section-4">Section 4</a>.

   o  A description of why the Concise Binary Object Representation
      (CBOR) [<a href="./rfc7049" title='"Concise Binary Object Representation (CBOR)"'>RFC7049</a>] was chosen for this format; see <a href="#section-5">Section 5</a>.

   o  A conceptual overview of the C-DNS format; see <a href="#section-6">Section 6</a>.

   o  The definition of the C-DNS format for the collection of DNS
      messages; see <a href="#section-7">Section 7</a>.

   o  Notes on converting C-DNS data to PCAP format; see <a href="#section-9">Section 9</a>.

   o  Some high-level implementation considerations for applications
      designed to produce C-DNS; see <a href="#section-10">Section 10</a>.

<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/2.%20%20Terminology"></a><a class="selflink" href="#section-2" id="section-2">2</a>.  Terminology</span>

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
   "OPTIONAL" in this document are to be interpreted as described in
   <a href="https://www.rfc-editor.org/bcp/bcp14">BCP 14</a> [<a href="./rfc2119" title='"Key words for use in RFCs to Indicate Requirement Levels"'>RFC2119</a>] [<a href="./rfc8174" title='"Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words"'>RFC8174</a>] when, and only when, they appear in all
   capitals, as shown here.

   "Packet" refers to an individual IPv4 or IPv6 packet.  Typically,
   packets are UDP datagrams, but such packets may also be part of a TCP
   data stream.  "Message", unless otherwise qualified, refers to a DNS
   payload extracted from a UDP datagram or a TCP data stream.

   The parts of DNS messages are named as they are in [<a href="./rfc1035" title='"Domain names - implementation and specification"'>RFC1035</a>].
   Specifically, the DNS message has five sections: Header, Question,
   Answer, Authority, and Additional.

<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/3.%20%20Data%20Collection%20Use%20Cases"></a><a class="selflink" href="#section-3" id="section-3">3</a>.  Data Collection Use Cases</span>

   From a purely server operator perspective, collecting full packet
   captures of all packets going into or out of a name server provides
   the most comprehensive picture of network activity.  However, there
   are several design choices or other limitations that are common to
   many DNS installations and operators.





<span class="grey">Dickinson, et al.            Standards Track                    [Page 5]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-6"></span>
<span class="grey"><a href="./rfc8618">RFC 8618</a>         C-DNS: A Format for DNS Packet Capture   September 2019</span>


   o  DNS servers are hosted in a variety of situations:

      *  Self-hosted servers

      *  Third-party hosting (including multiple third parties)

      *  Third-party hardware (including multiple third parties)

   o  Data is collected under different conditions:

      *  On well-provisioned servers running in a steady state

      *  On heavily loaded servers

      *  On virtualized servers

      *  On servers that are under DoS attack

      *  On servers that are unwitting intermediaries in DoS attacks

   o  Traffic can be collected via a variety of mechanisms:

      *  Within the name server implementation itself

      *  On the same hardware as the name server itself

      *  Using a network tap on an adjacent host to listen to DNS
         traffic

      *  Using port mirroring to listen from another host

   o  The capabilities of data collection (and upload) networks vary:

      *  Out-of-band networks with the same capacity as the in-band
         network

      *  Out-of-band networks with less capacity than the in-band
         network

      *  Everything being on the in-band network

   Thus, there is a wide range of use cases, from very limited data
   collection environments (third-party hardware, servers that are under
   attack, packet capture on the name server itself and no out-of-band
   network) to "limitless" environments (self-hosted, well-provisioned
   servers, using a network tap or port mirroring with out-of-band
   networks with the same capacity as the in-band network).  In the




<span class="grey">Dickinson, et al.            Standards Track                    [Page 6]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-7"></span>
<span class="grey"><a href="./rfc8618">RFC 8618</a>         C-DNS: A Format for DNS Packet Capture   September 2019</span>


   former case, it is infeasible to reliably collect full packet
   captures, especially if the server is under attack.  In the latter
   case, collection of full packet captures may be reasonable.

   As a result of these restrictions, the C-DNS data format is designed
   with the most limited use case in mind, such that:

   o  Data collection will occur on the same hardware as the name server
      itself

   o  Collected data will be stored on the same hardware as the name
      server itself, at least temporarily

   o  Collected data being returned to some central analysis system will
      use the same network interface as the DNS Queries and Responses

   o  There can be multiple third-party servers involved

   Because of these considerations, a major factor in the design of the
   format is minimal storage size of the capture files.

   Another significant consideration for any application that records
   DNS traffic is that the running of the name server software and the
   transmission of DNS Queries and Responses are the most important jobs
   of a name server; capturing data is not.  Any data collection system
   co-located with the name server needs to be intelligent enough to
   carefully manage its CPU, disk, memory, and network utilization.
   This leads to designing a format that requires a relatively low
   overhead to produce and minimizes the requirement for further
   potentially costly compression.

   However, it is also essential that interoperability with less
   restricted infrastructure is maintained.  In particular, it is highly
   desirable that the collection format should facilitate the
   re-creation of common formats (such as PCAP) that are as close to the
   original as is realistic, given the restrictions above.















<span class="grey">Dickinson, et al.            Standards Track                    [Page 7]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-8"></span>
<span class="grey"><a href="./rfc8618">RFC 8618</a>         C-DNS: A Format for DNS Packet Capture   September 2019</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/4.%20%20Design%20Considerations"></a><a class="selflink" href="#section-4" id="section-4">4</a>.  Design Considerations</span>

   This section presents some of the major design considerations used in
   the development of the C-DNS format.

   1.  The basic unit of data is a combined DNS Query and the associated
       Response (a "Query/Response (Q/R) data item").  The same
       structure will be used for unmatched Queries and Responses.
       Queries without Responses will be captured omitting the Response
       data.  Responses without Queries will be captured omitting the
       Query data (but using the Question section from the Response, if
       present, as an identifying QNAME).

       *  Rationale: A Query and the associated Response represent the
          basic level of a client's interaction with the server.  Also,
          combining the Query and Response into one item often reduces
          storage requirements due to commonality in the data of the two
          messages.

       In the context of generating a C-DNS file, it is assumed that
       only those DNS payloads that can be parsed to produce a
       well-formed DNS message are stored in the structured Query/
       Response data items of the C-DNS format and that all other
       messages will (optionally) be recorded as separate malformed
       messages.  Parsing a well-formed message means, at a minimum, the
       following:

       *  The packet has a well-formed 12-byte DNS Header with a
          recognized OPCODE.

       *  The section counts are consistent with the section contents.

       *  All of the Resource Records (RRs) can be fully parsed.

   2.  All top-level fields in each Query/Response data item will be
       optional.

       *  Rationale: Different operators will have different
          requirements for data to be available for analysis.  Operators
          with minimal requirements should not have to pay the cost of
          recording full data, though this will limit the ability to
          perform certain kinds of data analysis and also to reconstruct
          packet captures.  For example, omitting the RRs from a
          Response will reduce the C-DNS file size; in principle,
          Responses can be synthesized if there is enough context.
          Operators may have different policies for collecting user data
          and can choose to omit or anonymize certain fields at capture
          time, e.g., client address.



<span class="grey">Dickinson, et al.            Standards Track                    [Page 8]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-9"></span>
<span class="grey"><a href="./rfc8618">RFC 8618</a>         C-DNS: A Format for DNS Packet Capture   September 2019</span>


   3.  Multiple Query/Response data items will be collected into blocks
       in the format.  Common data in a block will be abstracted and
       referenced from individual Query/Response data items by indexing.
       The maximum number of Query/Response data items in a block will
       be configurable.

       *  Rationale: This blocking and indexing action provides a
          significant reduction in the volume of file data generated.
          Although this introduces complexity, it provides compression
          of the data that makes use of knowledge of the DNS message
          structure.

       *  It is anticipated that the files produced can be subject to
          further compression using general-purpose compression tools.
          Measurements show that blocking significantly reduces the CPU
          required to perform such strong compression.  See
          <a href="#appendix-C.2">Appendix C.2</a>.

       *  Examples of commonality between DNS messages are that in most
          cases the QUESTION RR is the same in the Query and Response
          and that there is a finite set of Query "signatures" (based on
          a subset of attributes).  For many authoritative servers,
          there is very likely to be a finite set of Responses that are
          generated, of which a large number are NXDOMAIN.

   4.  Traffic metadata can optionally be included in each block.
       Specifically, counts of some types of non-DNS packets (e.g.,
       ICMP, TCP resets) sent to the server may be of interest.

   5.  The wire-format content of malformed DNS messages may optionally
       be recorded.

       *  Rationale: Any structured capture format that does not capture
          the DNS payload byte for byte will be limited to some extent
          in that it cannot represent malformed DNS messages.  Only
          those messages that can be fully parsed and transformed into
          the structured format can be fully represented.  Note,
          however, that this can result in rather misleading statistics.
          For example, a malformed Query that cannot be represented in
          the C-DNS format will lead to the (well-formed) DNS Response
          with error code FORMERR appearing as "unmatched".  Therefore,
          it can greatly aid downstream analysis to have the wire format
          of the malformed DNS messages available directly in the
          C-DNS file.







<span class="grey">Dickinson, et al.            Standards Track                    [Page 9]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-10"></span>
<span class="grey"><a href="./rfc8618">RFC 8618</a>         C-DNS: A Format for DNS Packet Capture   September 2019</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/5.%20%20Choice%20of%20CBOR"></a><a class="selflink" href="#section-5" id="section-5">5</a>.  Choice of CBOR</span>

   This document presents a detailed format description for C-DNS.  The
   format uses CBOR [<a href="./rfc7049" title='"Concise Binary Object Representation (CBOR)"'>RFC7049</a>].

   The choice of CBOR was made taking a number of factors into account.

   o  CBOR is a binary representation and thus is economical in storage
      space.

   o  Other binary representations were investigated, and whilst all had
      attractive features, none had a significant advantage over CBOR.
      See <a href="#appendix-C">Appendix C</a> for some discussion of this.

   o  CBOR is an IETF specification and is familiar to IETF
      participants.  It is based on the now-common ideas of lists and
      objects and thus requires very little familiarization for those in
      the wider industry.

   o  CBOR is a simple format and can easily be implemented from scratch
      if necessary.  Formats that are more complex require library
      support, which may present problems on unusual platforms.

   o  CBOR can also be easily converted to text formats such as JSON
      [<a href="./rfc8259" title='"The JavaScript Object Notation (JSON) Data Interchange Format"'>RFC8259</a>] for debugging and other human inspection requirements.

   o  CBOR data schemas can be described using the Concise Data
      Definition Language (CDDL) [<a href="./rfc8610" title='"Concise Data Definition Language (CDDL): A Notational Convention to Express Concise Binary Object Representation (CBOR) and JSON Data Structures"'>RFC8610</a>].

<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/6.%20%20C-DNS%20Format%20Conceptual%20Overview"></a><a class="selflink" href="#section-6" id="section-6">6</a>.  C-DNS Format Conceptual Overview</span>

   The following figures show purely schematic representations of the
   C-DNS format to convey the high-level structure of the C-DNS format.
   <a href="#section-7">Section 7</a> provides a detailed discussion of the CBOR representation
   and individual elements.

   Figure 1 shows the C-DNS format at the top level, including the file
   header and data blocks.  The Query/Response data items, Address/Event
   Count data items, and Malformed Message data items link to various
   Block Tables.











<span class="grey">Dickinson, et al.            Standards Track                   [Page 10]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-11"></span>
<span class="grey"><a href="./rfc8618">RFC 8618</a>         C-DNS: A Format for DNS Packet Capture   September 2019</span>


                   +-------+
                   + C-DNS |
                   +-------+--------------------------+
                   | File Type Identifier             |
                   +----------------------------------+
                   | File Preamble                    |
                   | +--------------------------------+
                   | | Format Version                 |
                   | +--------------------------------+
                   | | Block Parameters               |
                   +-+--------------------------------+
                   | Block                            |
                   | +--------------------------------+
                   | | Block Preamble                 |
                   | +--------------------------------+
                   | | Block Statistics               |
                   | +--------------------------------+
                   | | Block Tables                   |
                   | +--------------------------------+
                   | | Query/Response data items      |
                   | +--------------------------------+
                   | | Address/Event Count data items |
                   | +--------------------------------+
                   | | Malformed Message data items   |
                   +-+--------------------------------+
                   | Block                            |
                   | +--------------------------------+
                   | | Block Preamble                 |
                   | +--------------------------------+
                   | | Block Statistics               |
                   | +--------------------------------+
                   | | Block Tables                   |
                   | +--------------------------------+
                   | | Query/Response data items      |
                   | +--------------------------------+
                   | | Address/Event Count data items |
                   | +--------------------------------+
                   | | Malformed Message data items   |
                   +-+--------------------------------+
                   | Further Blocks...                |
                   +----------------------------------+

                        Figure 1: The C-DNS Format

   Figure 2 shows some more-detailed relationships within each Block,
   specifically those between the Query/Response data item and the
   relevant Block Tables.  Some fields have been omitted for clarity.




<span class="grey">Dickinson, et al.            Standards Track                   [Page 11]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-12"></span>
<span class="grey"><a href="./rfc8618">RFC 8618</a>         C-DNS: A Format for DNS Packet Capture   September 2019</span>


   +----------------+
   | Query/Response |
   +-------------------------+
   | Time Offset             |
   +-------------------------+            +------------------+
   | Client Address          |---------+-&gt;| IP Address array |
   +-------------------------+         |  +------------------+
   | Client Port             |         |
   +-------------------------+         |  +------------------+
   | Transaction ID          |     +---)-&gt;| Name/RDATA array |&lt;--------+
   +-------------------------+     |   |  +------------------+         |
   | Query Signature         |--+  |   |                               |
   +-------------------------+  |  |   |  +-----------------+          |
   | Client Hoplimit (q)     |  +--)---)-&gt;| Query Signature |          |
   +-------------------------+     |   |  +-----------------+-------+  |
   | Response Delay (r)      |     |   +--| Server Address          |  |
   +-------------------------+     |      +-------------------------+  |
   | Query Name              |--+--+      | Server Port             |  |
   +-------------------------+  |         +-------------------------+  |
   | Query Size (q)          |  |         | Transport Flags         |  |
   +-------------------------+  |         +-------------------------+  |
   | Response Size (r)       |  |         | QR Type                 |  |
   +-------------------------+  |         +-------------------------+  |
   | Response Processing (r) |  |         | QR Signature Flags      |  |
   | +-----------------------+  |         +-------------------------+  |
   | | Bailiwick             |--+         | Query OPCODE (q)        |  |
   | +-----------------------+            +-------------------------+  |
   | | Flags                 |            | QR DNS Flags            |  |
   +-+-----------------------+            +-------------------------+  |
   | Extra Query Info (q)    |            | Query RCODE (q)         |  |
   | +-----------------------+            +-------------------------+  |
   | | Question              |--+---+  +--+-Query Class/Type (q)    |  |
   | +-----------------------+      |  |  +-------------------------+  |
   | | Answer                |--+   |  |  | Query QDCOUNT (q)       |  |
   | +-----------------------+  |   |  |  +-------------------------+  |
   | | Authority             |--+   |  |  | Query ANCOUNT (q)       |  |
   | +-----------------------+  |   |  |  +-------------------------+  |
   | | Additional            |--+   |  |  | Query NSCOUNT (q)       |  |













<span class="grey">Dickinson, et al.            Standards Track                   [Page 12]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-13"></span>
<span class="grey"><a href="./rfc8618">RFC 8618</a>         C-DNS: A Format for DNS Packet Capture   September 2019</span>


   +-+-----------------------+  |   |  |  +-------------------------+  |
   | Extra Response Info (r) |  |-+ |  |  | Query ARCOUNT (q)       |  |
   | +-----------------------+  | | |  |  +-------------------------+  |
   | | Answer                |--+ | |  |  | Query EDNS version (q)  |  |
   | +-----------------------+  | | |  |  +-------------------------+  |
   | | Authority             |--+ | |  |  | Query EDNS UDP Size (q) |  |
   | +-----------------------+  | | |  |  +-------------------------+  |
   | | Additional            |--+ | |  |  | Query OPT RDATA (q)     |--+
   +-+-----------------------+    | |  |  +-------------------------+  |
                                  | |  |  | Response RCODE (r)      |  |
                                  | |  |  +-------------------------+  |
   + -----------------------------+ |  +----------+                    |
   |                                |             |                    |
   | + -----------------------------+             |                    |
   | |  +---------------+  +----------+           |                    |
   | +-&gt;| Question List |-&gt;| Question |           |                    |
   |    | array         |  | array    |           |                    |
   |    +---------------+  +----------+--+        |                    |
   |                       | Name        |--+-----)--------------------+
   |                       +-------------+  |     |  +------------+
   |                       | Class/Type  |--)---+-+-&gt;| Class/Type |
   |                       +-------------+  |   |    | array      |
   |                                        |   |    +------------+--+
   |                                        |   |    | CLASS         |
   |    +---------------+  +----------+     |   |    +---------------+
   +---&gt;| RR List array |-&gt;| RR array |     |   |    | TYPE          |
        +---------+-----+  +----------+--+  |   |    +---------------+
                           | Name        |--+   |
                           +-------------+      |
                           | Class/Type  |------+
                           +-------------+

       Figure 2: The Query/Response Data Item and Subsidiary Tables

   In Figure 2, data items annotated (q) are only present when a
   Query/Response has a Query, and those annotated (r) are only present
   when a Query/Response Response is present.

   A C-DNS file begins with a file header containing a File Type
   Identifier and a File Preamble.  The File Preamble contains
   information on the file Format Version and an array of Block
   Parameters items (the contents of which include Collection and
   Storage Parameters used for one or more Blocks).

   The file header is followed by a series of Blocks.






<span class="grey">Dickinson, et al.            Standards Track                   [Page 13]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-14"></span>
<span class="grey"><a href="./rfc8618">RFC 8618</a>         C-DNS: A Format for DNS Packet Capture   September 2019</span>


   A Block consists of a Block Preamble item, some Block Statistics for
   the traffic stored within the Block, and then various arrays of
   common data collectively called the Block Tables.  This is then
   followed by an array of the Query/Response data items detailing the
   Queries and Responses stored within the Block.  The array of
   Query/Response data items is in turn followed by the Address/Event
   Count data items (an array of per-client counts of particular IP
   events) and then Malformed Message data items (an array of malformed
   messages that are stored in the Block).

   The exact nature of the DNS data will affect what Block size is the
   best fit; however, sample data for a root server indicated that Block
   sizes up to 10,000 Query/Response data items give good results.  See
   <a href="#appendix-C.6">Appendix C.6</a> for more details.

   This design exploits data commonality and block-based storage to
   minimize the C-DNS file size.  As a result, C-DNS cannot be streamed
   below the level of a Block.

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/6.1.%20%20Block%20Parameters"></a><a class="selflink" href="#section-6.1" id="section-6.1">6.1</a>.  Block Parameters</span>

   The details of the Block Parameters items are not shown in the
   diagrams but are discussed here for context.

   An array of Block Parameters items is stored in the File Preamble
   (with a minimum of one item at index 0); a Block Parameters item
   consists of a collection of Storage and Collection Parameters that
   applies to any given Block.  An array is used in order to support use
   cases such as wanting to merge C-DNS files from different sources.
   The Block Preamble item then contains an optional index for the Block
   Parameters item that applies for that Block; if not present, the
   index defaults to 0.  Hence, in effect, a global Block Parameters
   item is defined that can then be overridden per Block.

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/6.2.%20%20Storage%20Parameters"></a><a class="selflink" href="#section-6.2" id="section-6.2">6.2</a>.  Storage Parameters</span>

   The Block Parameters item includes a Storage Parameters item -- this
   contains information about the specific data fields stored in the
   C-DNS file.

   These parameters include:

   o  The sub-second timing resolution used by the data.

   o  Information (hints) on which optional data are omitted.  See
      <a href="#section-6.2.1">Section 6.2.1</a>.





<span class="grey">Dickinson, et al.            Standards Track                   [Page 14]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-15"></span>
<span class="grey"><a href="./rfc8618">RFC 8618</a>         C-DNS: A Format for DNS Packet Capture   September 2019</span>


   o  Recorded OPCODES [<a href="#ref-opcodes" title='"DNS OpCodes"'>opcodes</a>] and RR TYPEs [<a href="#ref-rrtypes" title='"Resource Record (RR) TYPEs"'>rrtypes</a>].  See
      <a href="#section-6.2.2">Section 6.2.2</a>.

   o  Flags indicating, for example, whether the data is sampled or
      anonymized.  See Sections <a href="#section-6.2.3">6.2.3</a> and <a href="#section-14">14</a>.

   o  Client and server IPv4 and IPv6 address prefixes.  See
      <a href="#section-6.2.4">Section 6.2.4</a>.

<span class="h4"><a class="dashAnchor" name="//apple_ref/cpp/Section/6.2.1.%20%20Optional%20Data%20Items"></a><a class="selflink" href="#section-6.2.1" id="section-6.2.1">6.2.1</a>.  Optional Data Items</span>

   To enable implementations to store data to their precise requirements
   in as space-efficient a manner as possible, all fields in the
   following arrays are optional:

   o  Query/Response

   o  Query Signature

   o  Malformed Messages

   In other words, an implementation can choose to omit any data item
   that is not required for its use case (whilst observing the
   restrictions relating to IP address storage described in
   <a href="#section-6.2.4">Section 6.2.4</a>).  In addition, implementations may be configured to
   not record all RRs or to only record messages with certain OPCODES.

   This does, however, mean that a consumer of a C-DNS file faces two
   problems:

   1.  How can it quickly determine if a file definitely does not
       contain the data items it requires to complete a particular task
       (e.g., reconstructing DNS traffic or performing a specific piece
       of data analysis)?

   2.  How can it determine whether a data item is not present because
       it was (1) explicitly not recorded or (2) not available/present?

   For example, capturing C-DNS data from within a name server
   implementation makes it unlikely that the Client Hoplimit can be
   recorded.  Or, if there is no Query ARCOUNT recorded and no Query OPT
   RDATA [<a href="./rfc6891" title='"Extension Mechanisms for DNS (EDNS(0))"'>RFC6891</a>] recorded, is that because no Query contained an OPT
   RR, or because that data was not stored?

   The Storage Parameters item therefore also contains a Storage Hints
   item, which specifies which items the encoder of the file omits from
   the stored data and will therefore never be present.  (This approach
   is taken because a flag that indicated which items were included for



<span class="grey">Dickinson, et al.            Standards Track                   [Page 15]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-16"></span>
<span class="grey"><a href="./rfc8618">RFC 8618</a>         C-DNS: A Format for DNS Packet Capture   September 2019</span>


   collection would not guarantee that the item was present -- only that
   it might be.)  An implementation decoding that file can then use
   these flags to quickly determine whether the input data is not rich
   enough for its needs.

   One scenario where this may be particularly important is the case of
   regenerating traffic.  It is possible to collect such a small set of
   data items that an implementation decoding the file cannot determine
   if a given Query/Response data item was generated from just a Query,
   just a Response, or a Query/Response pair.  This makes it impossible
   to reconstruct DNS traffic even if sensible defaults are provided for
   the missing data items.  This is discussed in more detail in
   <a href="#section-9">Section 9</a>.

<span class="h4"><a class="dashAnchor" name="//apple_ref/cpp/Section/6.2.2.%20%20Optional%20RRs%20and%20OPCODEs"></a><a class="selflink" href="#section-6.2.2" id="section-6.2.2">6.2.2</a>.  Optional RRs and OPCODEs</span>

   Also included in the Storage Parameters item are explicit arrays
   listing the RR TYPEs and the OPCODEs to be recorded.  These arrays
   remove any ambiguity over whether, for example, messages containing
   particular OPCODEs are not present because (1) certain OPCODEs did
   not occur or (2) the implementation is not configured to record them.

   In the case of OPCODEs, for a message to be fully parsable, the
   OPCODE must be known to the collecting implementation.  Any message
   with an OPCODE unknown to the collecting implementation cannot be
   validated as correctly formed and so must be treated as malformed.
   Messages with OPCODES known to the recording application but not
   listed in the Storage Parameters item are discarded by the recording
   application during C-DNS capture (regardless of whether they are
   malformed or not).

   In the case of RRs, each record in a message must be fully parsable,
   including parsing the record RDATA, as otherwise the message cannot
   be validated as correctly formed.  Any RR with an RR TYPE not known
   to the collecting implementation cannot be validated as correctly
   formed and so must be treated as malformed.

   Once a message is correctly parsed, an implementation is free to
   record only a subset of the RRs present.












<span class="grey">Dickinson, et al.            Standards Track                   [Page 16]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-17"></span>
<span class="grey"><a href="./rfc8618">RFC 8618</a>         C-DNS: A Format for DNS Packet Capture   September 2019</span>


<span class="h4"><a class="dashAnchor" name="//apple_ref/cpp/Section/6.2.3.%20%20Storage%20Flags"></a><a class="selflink" href="#section-6.2.3" id="section-6.2.3">6.2.3</a>.  Storage Flags</span>

   The Storage Parameters item contains flags that can be used to
   indicate if:

   o  the data is anonymized,

   o  the data is produced from sample data, or

   o  names in the data have been normalized (converted to uniform
      case).

   The Storage Parameters item also contains optional fields holding
   details of the sampling method used and the anonymization method
   used.  It is RECOMMENDED that these fields contain URIs [<a href="./rfc3986" title='"Uniform Resource Identifier (URI): Generic Syntax"'>RFC3986</a>]
   pointing to resources describing the methods used.  See <a href="#section-14">Section 14</a>
   for further discussion of anonymization and normalization.

<span class="h4"><a class="dashAnchor" name="//apple_ref/cpp/Section/6.2.4.%20%20IP%20Address%20Storage"></a><a class="selflink" href="#section-6.2.4" id="section-6.2.4">6.2.4</a>.  IP Address Storage</span>

   The format can store either full IP addresses or just IP prefixes;
   the Storage Parameters item contains fields to indicate if only IP
   prefixes were stored.

   If the IP address prefixes are absent, then full addresses are
   stored.  In this case, the IP version can be directly inferred from
   the stored address length and the fields "qr-transport-flags" in
   QueryResponseSignature, "ae-transport-flags" in AddressEventCount,
   and "mm-transport-flags" in MalformedMessageData (which contain the
   IP version bit) are optional.

   If IP address prefixes are given, only the prefix bits of addresses
   are stored.  In this case, in order to determine the IP version, the
   fields "qr-transport-flags" in QueryResponseSignature, "ae-transport-
   flags" in AddressEventCount, and "mm-transport-flags" in
   MalformedMessageData MUST be present.  See Sections <a href="#section-7.3.2.3.2">7.3.2.3.2</a> and
   7.3.2.3.5.

   As an example of storing only IP prefixes, if a client IPv6 prefix of
   48 is specified, a client address of 2001:db8:85a3::8a2e:370:7334
   will be stored as 0x20010db885a3, reducing address storage space
   requirements.  Similarly, if a client IPv4 prefix of 16 is specified,
   a client address of 192.0.2.1 will be stored as 0xc000 (192.0).








<span class="grey">Dickinson, et al.            Standards Track                   [Page 17]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-18"></span>
<span class="grey"><a href="./rfc8618">RFC 8618</a>         C-DNS: A Format for DNS Packet Capture   September 2019</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/7.%20%20C-DNS%20Format%20Detailed%20Description"></a><a class="selflink" href="#section-7" id="section-7">7</a>.  C-DNS Format Detailed Description</span>

   The CDDL definition for the C-DNS format is given in <a href="#appendix-A">Appendix A</a>.

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/7.1.%20%20Map%20Quantities%20and%20Indexes"></a><a class="selflink" href="#section-7.1" id="section-7.1">7.1</a>.  Map Quantities and Indexes</span>

   All map keys are integers with values specified in the CDDL.  String
   keys would significantly bloat the file size.

   All key values specified are positive integers under 24, so their
   CBOR representation is a single byte.  Positive integer values not
   currently used as keys in a map are reserved for use in future
   standard extensions.

   Implementations may choose to add additional implementation-specific
   entries to any map.  Negative integer map keys are reserved for these
   values.  Key values from -1 to -24 also have a single-byte CBOR
   representation, so such implementation-specific extensions are not at
   any space efficiency disadvantage.

   An item described as an index is the index of the data item in the
   referenced array.  Indexes are 0-based.

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/7.2.%20%20Tabular%20Representation"></a><a class="selflink" href="#section-7.2" id="section-7.2">7.2</a>.  Tabular Representation</span>

   The following sections present the C-DNS specification in tabular
   format with a detailed description of each item.

   In all quantities that contain bit flags, bit 0 indicates the least
   significant bit, i.e., flag "n" in quantity "q" is on if
   "(q &amp; (1 &lt;&lt; n)) != 0".

   For the sake of readability, all type and field names defined in the
   CDDL definition are shown in double quotes.  Type names are by
   convention camel case (e.g., "BlockTables"), and field names are
   lowercase with hyphens (e.g., "block-tables").

   For the sake of brevity, the following conventions are used in the
   tables:

   o  The column M marks whether items in a map are mandatory.

      *  X - Mandatory items.

      *  C - Conditionally mandatory items.  Such items are usually
         optional but may be mandatory in some configurations.

      *  If the column is empty, the item is optional.



<span class="grey">Dickinson, et al.            Standards Track                   [Page 18]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-19"></span>
<span class="grey"><a href="./rfc8618">RFC 8618</a>         C-DNS: A Format for DNS Packet Capture   September 2019</span>


   o  The column T gives the CBOR datatype of the item.

      *  U - Unsigned integer.

      *  I - Signed integer (i.e., either a CBOR unsigned integer or a
         CBOR negative integer).

      *  B - Boolean.

      *  S - Byte string.

      *  T - Text string.

      *  M - Map.

      *  A - Array.

   In the case of maps and arrays, more information on the type of each
   value, including the CDDL definition name if applicable, is given in
   the description.

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/7.3.%20%20%22File%22"></a><a class="selflink" href="#section-7.3" id="section-7.3">7.3</a>.  "File"</span>

   A C-DNS file has an outer structure "File", an array that contains
   the following:

   +---------------+---+---+-------------------------------------------+
   | Field         | M | T | Description                               |
   +---------------+---+---+-------------------------------------------+
   | file-type-id  | X | T | String "C-DNS" identifying the file type. |
   |               |   |   |                                           |
   | file-preamble | X | M | Version and parameter information for the |
   |               |   |   | whole file.  Map of type "FilePreamble";  |
   |               |   |   | see <a href="#section-7.3.1">Section 7.3.1</a>.                        |
   |               |   |   |                                           |
   | file-blocks   | X | A | Array of items of type "Block"; see       |
   |               |   |   | <a href="#section-7.3.2">Section 7.3.2</a>.  The array may be empty if |
   |               |   |   | the file contains no data.                |
   +---------------+---+---+-------------------------------------------+












<span class="grey">Dickinson, et al.            Standards Track                   [Page 19]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-20"></span>
<span class="grey"><a href="./rfc8618">RFC 8618</a>         C-DNS: A Format for DNS Packet Capture   September 2019</span>


<span class="h4"><a class="dashAnchor" name="//apple_ref/cpp/Section/7.3.1.%20%20%22FilePreamble%22"></a><a class="selflink" href="#section-7.3.1" id="section-7.3.1">7.3.1</a>.  "FilePreamble"</span>

   Information about data in the file.  A map containing the following:

   +----------------------+---+---+------------------------------------+
   | Field                | M | T | Description                        |
   +----------------------+---+---+------------------------------------+
   | major-format-version | X | U | Unsigned integer "1".  The major   |
   |                      |   |   | version of the format used in the  |
   |                      |   |   | file.  See <a href="#section-8">Section 8</a>.              |
   |                      |   |   |                                    |
   | minor-format-version | X | U | Unsigned integer "0".  The minor   |
   |                      |   |   | version of the format used in the  |
   |                      |   |   | file.  See <a href="#section-8">Section 8</a>.              |
   |                      |   |   |                                    |
   | private-version      |   | U | Version indicator available for    |
   |                      |   |   | private use by implementations.    |
   |                      |   |   |                                    |
   | block-parameters     | X | A | Array of items of type             |
   |                      |   |   | "BlockParameters".  See Section    |
   |                      |   |   | 7.3.1.1.  The array must contain   |
   |                      |   |   | at least one entry.  (The          |
   |                      |   |   | "block-parameters-index" item in   |
   |                      |   |   | each "BlockPreamble" indicates     |
   |                      |   |   | which array entry applies to that  |
   |                      |   |   | "Block".)                          |
   +----------------------+---+---+------------------------------------+

<span class="h5"><a class="dashAnchor" name="//apple_ref/cpp/Section/7.3.1.1.%20%20%22BlockParameters%22"></a><a class="selflink" href="#section-7.3.1.1" id="section-7.3.1.1">7.3.1.1</a>.  "BlockParameters"</span>

   Parameters relating to data storage and collection that apply to one
   or more items of type "Block".  A map containing the following:

   +-----------------------+---+---+-----------------------------------+
   | Field                 | M | T | Description                       |
   +-----------------------+---+---+-----------------------------------+
   | storage-parameters    | X | M | Parameters relating to data       |
   |                       |   |   | storage in a "Block" item.  Map   |
   |                       |   |   | of type "StorageParameters"; see  |
   |                       |   |   | <a href="#section-7.3.1.1.1">Section 7.3.1.1.1</a>.                |
   |                       |   |   |                                   |
   | collection-parameters |   | M | Parameters relating to collection |
   |                       |   |   | of the data in a "Block" item.    |
   |                       |   |   | Map of type                       |
   |                       |   |   | "CollectionParameters"; see       |
   |                       |   |   | <a href="#section-7.3.1.1.2">Section 7.3.1.1.2</a>.                |
   +-----------------------+---+---+-----------------------------------+




<span class="grey">Dickinson, et al.            Standards Track                   [Page 20]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-21"></span>
<span class="grey"><a href="./rfc8618">RFC 8618</a>         C-DNS: A Format for DNS Packet Capture   September 2019</span>


<span class="h6"><a class="dashAnchor" name="//apple_ref/cpp/Section/7.3.1.1.1.%20%20%22StorageParameters%22"></a><a class="selflink" href="#section-7.3.1.1.1" id="section-7.3.1.1.1">7.3.1.1.1</a>.  "StorageParameters"</span>

   Parameters relating to how data is stored in the items of type
   "Block".  A map containing the following:

   +------------------+---+---+----------------------------------------+
   | Field            | M | T | Description                            |
   +------------------+---+---+----------------------------------------+
   | ticks-per-second | X | U | Sub-second timing is recorded in       |
   |                  |   |   | ticks.  This specifies the number of   |
   |                  |   |   | ticks in a second.                     |
   |                  |   |   |                                        |
   | max-block-items  | X | U | The maximum number of items stored in  |
   |                  |   |   | any of the arrays in a "Block" item    |
   |                  |   |   | (Q/R, Address/Event Count, or          |
   |                  |   |   | Malformed Message data items).  An     |
   |                  |   |   | indication to a decoder of the         |
   |                  |   |   | resources needed to process the file.  |
   |                  |   |   |                                        |
   | storage-hints    | X | M | Collection of hints as to which fields |
   |                  |   |   | are omitted in the arrays that have    |
   |                  |   |   | optional fields.  Map of type          |
   |                  |   |   | "StorageHints".  See Section           |
   |                  |   |   | 7.3.1.1.1.1.                           |
   |                  |   |   |                                        |
   | opcodes          | X | A | Array of OPCODES [<a href="#ref-opcodes" title='"DNS OpCodes"'>opcodes</a>] (unsigned   |
   |                  |   |   | integers, each in the range 0 to 15    |
   |                  |   |   | inclusive) recorded by the collecting  |
   |                  |   |   | implementation.  See <a href="#section-6.2.2">Section 6.2.2</a>.    |
   |                  |   |   |                                        |
   | rr-types         | X | A | Array of RR TYPEs [<a href="#ref-rrtypes" title='"Resource Record (RR) TYPEs"'>rrtypes</a>] (unsigned  |
   |                  |   |   | integers, each in the range 0 to 65535 |
   |                  |   |   | inclusive) recorded by the collecting  |
   |                  |   |   | implementation.  See <a href="#section-6.2.2">Section 6.2.2</a>.    |
   |                  |   |   |                                        |
   | storage-flags    |   | U | Bit flags indicating attributes of     |
   |                  |   |   | stored data.                           |
   |                  |   |   | Bit 0.  1 if the data has been         |
   |                  |   |   | anonymized.                            |
   |                  |   |   | Bit 1.  1 if the data is sampled data. |
   |                  |   |   | Bit 2.  1 if the names have been       |
   |                  |   |   | normalized (converted to uniform       |
   |                  |   |   | case).                                 |
   |                  |   |   |                                        |
   | client-address   |   | U | IPv4 client address prefix length, in  |
   | -prefix-ipv4     |   |   | the range 1 to 32 inclusive.  If       |
   |                  |   |   | specified, only the address prefix     |
   |                  |   |   | bits are stored.                       |



<span class="grey">Dickinson, et al.            Standards Track                   [Page 21]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-22"></span>
<span class="grey"><a href="./rfc8618">RFC 8618</a>         C-DNS: A Format for DNS Packet Capture   September 2019</span>


   |                  |   |   |                                        |
   | client-address   |   | U | IPv6 client address prefix length, in  |
   | -prefix-ipv6     |   |   | the range 1 to 128 inclusive.  If      |
   |                  |   |   | specified, only the address prefix     |
   |                  |   |   | bits are stored.                       |
   |                  |   |   |                                        |
   | server-address   |   | U | IPv4 server address prefix length, in  |
   | -prefix-ipv4     |   |   | the range 1 to 32 inclusive.  If       |
   |                  |   |   | specified, only the address prefix     |
   |                  |   |   | bits are stored.                       |
   |                  |   |   |                                        |
   | server-address   |   | U | IPv6 server address prefix length, in  |
   | -prefix-ipv6     |   |   | the range 1 to 128 inclusive.  If      |
   |                  |   |   | specified, only the address prefix     |
   |                  |   |   | bits are stored.                       |
   |                  |   |   |                                        |
   | sampling-method  |   | T | Information on the sampling method     |
   |                  |   |   | used.  See <a href="#section-6.2.3">Section 6.2.3</a>.              |
   |                  |   |   |                                        |
   | anonymization    |   | T | Information on the anonymization       |
   | -method          |   |   | method used.  See <a href="#section-6.2.3">Section 6.2.3</a>.       |
   +------------------+---+---+----------------------------------------+

<span class="h6"><a class="dashAnchor" name="//apple_ref/cpp/Section/7.3.1.1.1.1.%20%20%22StorageHints%22"></a><a class="selflink" href="#section-7.3.1.1.1.1" id="section-7.3.1.1.1.1">7.3.1.1.1.1</a>.  "StorageHints"</span>

   An indicator of which fields the collecting implementation omits in
   the maps with optional fields.  Note that hints have a top-down
   precedence.  In other words, where a map contains another map, the
   hint on the containing map overrides any hints in the contained map
   and the contained map is omitted.  A map containing the following:

   +------------------+---+---+----------------------------------------+
   | Field            | M | T | Description                            |
   +------------------+---+---+----------------------------------------+
   | query-response   | X | U | Hints indicating which "QueryResponse" |
   | -hints           |   |   | fields are omitted; see Section        |
   |                  |   |   | 7.3.2.4.  If a bit is unset, the field |
   |                  |   |   | is omitted from the capture.           |
   |                  |   |   | Bit 0.  time-offset                    |
   |                  |   |   | Bit 1.  client-address-index           |
   |                  |   |   | Bit 2.  client-port                    |
   |                  |   |   | Bit 3.  transaction-id                 |
   |                  |   |   | Bit 4.  qr-signature-index             |
   |                  |   |   | Bit 5.  client-hoplimit                |
   |                  |   |   | Bit 6.  response-delay                 |
   |                  |   |   | Bit 7.  query-name-index               |
   |                  |   |   | Bit 8.  query-size                     |
   |                  |   |   | Bit 9.  response-size                  |



<span class="grey">Dickinson, et al.            Standards Track                   [Page 22]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-23"></span>
<span class="grey"><a href="./rfc8618">RFC 8618</a>         C-DNS: A Format for DNS Packet Capture   September 2019</span>


   |                  |   |   | Bit 10.  response-processing-data      |
   |                  |   |   | Bit 11.  query-question-sections       |
   |                  |   |   | Bit 12.  query-answer-sections         |
   |                  |   |   | Bit 13.  query-authority-sections      |
   |                  |   |   | Bit 14.  query-additional-sections     |
   |                  |   |   | Bit 15.  response-answer-sections      |
   |                  |   |   | Bit 16.  response-authority-sections   |
   |                  |   |   | Bit 17.  response-additional-sections  |
   |                  |   |   |                                        |
   | query-response   | X | U | Hints indicating which                 |
   | -signature-hints |   |   | "QueryResponseSignature" fields are    |
   |                  |   |   | omitted; see <a href="#section-7.3.2.3.2">Section 7.3.2.3.2</a>.  If a  |
   |                  |   |   | bit is unset, the field is omitted     |
   |                  |   |   | from the capture.                      |
   |                  |   |   | Bit 0.  server-address-index           |
   |                  |   |   | Bit 1.  server-port                    |
   |                  |   |   | Bit 2.  qr-transport-flags             |
   |                  |   |   | Bit 3.  qr-type                        |
   |                  |   |   | Bit 4.  qr-sig-flags                   |
   |                  |   |   | Bit 5.  query-opcode                   |
   |                  |   |   | Bit 6.  qr-dns-flags                   |
   |                  |   |   | Bit 7.  query-rcode                    |
   |                  |   |   | Bit 8.  query-classtype-index          |
   |                  |   |   | Bit 9.  query-qdcount                  |
   |                  |   |   | Bit 10.  query-ancount                 |
   |                  |   |   | Bit 11.  query-nscount                 |
   |                  |   |   | Bit 12.  query-arcount                 |
   |                  |   |   | Bit 13.  query-edns-version            |
   |                  |   |   | Bit 14.  query-udp-size                |
   |                  |   |   | Bit 15.  query-opt-rdata-index         |
   |                  |   |   | Bit 16.  response-rcode                |
   |                  |   |   |                                        |
   | rr-hints         | X | U | Hints indicating which optional "RR"   |
   |                  |   |   | fields are omitted; see Section        |
   |                  |   |   | 7.3.2.3.4.  If a bit is unset, the     |
   |                  |   |   | field is omitted from the capture.     |
   |                  |   |   | Bit 0.  ttl                            |
   |                  |   |   | Bit 1.  rdata-index                    |
   | other-data-hints | X | U | Hints indicating which other datatypes |
   |                  |   |   | are omitted.  If a bit is unset, the   |
   |                  |   |   | datatype is omitted from the capture.  |
   |                  |   |   | Bit 0.  malformed-messages             |
   |                  |   |   | Bit 1.  address-event-counts           |
   +------------------+---+---+----------------------------------------+







<span class="grey">Dickinson, et al.            Standards Track                   [Page 23]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-24"></span>
<span class="grey"><a href="./rfc8618">RFC 8618</a>         C-DNS: A Format for DNS Packet Capture   September 2019</span>


<span class="h6"><a class="dashAnchor" name="//apple_ref/cpp/Section/7.3.1.1.2.%20%20%22CollectionParameters%22"></a><a class="selflink" href="#section-7.3.1.1.2" id="section-7.3.1.1.2">7.3.1.1.2</a>.  "CollectionParameters"</span>

   Parameters providing information regarding how data in the file was
   collected (applicable for some, but not all, collection
   environments).  The values are informational only and serve as
   metadata to downstream analyzers as to the configuration of a
   collecting implementation.  They can provide context when
   interpreting what data is present/absent from the capture but cannot
   necessarily be validated against the data captured.

   These parameters have no default.  If they do not appear, nothing can
   be inferred about their value.

   A map containing the following items:

   +------------------+---+---+----------------------------------------+
   | Field            | M | T | Description                            |
   +------------------+---+---+----------------------------------------+
   | query-timeout    |   | U | To be matched with a Query, a Response |
   |                  |   |   | must arrive within this number of      |
   |                  |   |   | milliseconds.                          |
   |                  |   |   |                                        |
   | skew-timeout     |   | U | The network stack may report a         |
   |                  |   |   | Response before the corresponding      |
   |                  |   |   | Query.  A Response is not considered   |
   |                  |   |   | to be missing a Query until after this |
   |                  |   |   | many microseconds.                     |
   |                  |   |   |                                        |
   | snaplen          |   | U | Collect up to this many bytes per      |
   |                  |   |   | packet.                                |
   |                  |   |   |                                        |
   | promisc          |   | B | "true" if promiscuous mode             |
   |                  |   |   | [<a href="#ref-pcap-options">pcap-options</a>] was enabled on the      |
   |                  |   |   | interface, "false" otherwise.          |
   |                  |   |   |                                        |
   | interfaces       |   | A | Array of identifiers (of type text     |
   |                  |   |   | string) of the interfaces used for     |
   |                  |   |   | collection.                            |
   |                  |   |   |                                        |
   | server-addresses |   | A | Array of server collection IP          |
   |                  |   |   | addresses (of type byte string).       |
   |                  |   |   | Metadata for downstream analyzers;     |
   |                  |   |   | does not affect collection.            |
   |                  |   |   |                                        |







<span class="grey">Dickinson, et al.            Standards Track                   [Page 24]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-25"></span>
<span class="grey"><a href="./rfc8618">RFC 8618</a>         C-DNS: A Format for DNS Packet Capture   September 2019</span>


   | vlan-ids         |   | A | Array of identifiers (of type unsigned |
   |                  |   |   | integer, each in the range 1 to 4094   |
   |                  |   |   | inclusive) of VLANs [<a href="#ref-IEEE802.1Q">IEEE802.1Q</a>]       |
   |                  |   |   | selected for collection.  VLAN IDs are |
   |                  |   |   | unique only within an administrative   |
   |                  |   |   | domain.                                |
   |                  |   |   |                                        |
   | filter           |   | T | Filter for input, in "tcpdump"         |
   |                  |   |   | [<a href="#ref-pcap-filter">pcap-filter</a>] style.                   |
   |                  |   |   |                                        |
   | generator-id     |   | T | Implementation-specific human-readable |
   |                  |   |   | string identifying the collection      |
   |                  |   |   | method.                                |
   |                  |   |   |                                        |
   | host-id          |   | T | String identifying the collecting      |
   |                  |   |   | host.                                  |
   +------------------+---+---+----------------------------------------+

<span class="h4"><a class="dashAnchor" name="//apple_ref/cpp/Section/7.3.2.%20%20%22Block%22"></a><a class="selflink" href="#section-7.3.2" id="section-7.3.2">7.3.2</a>.  "Block"</span>

   Container for data with common collection and storage parameters.  A
   map containing the following:

   +--------------------+---+---+--------------------------------------+
   | Field              | M | T | Description                          |
   +--------------------+---+---+--------------------------------------+
   | block-preamble     | X | M | Overall information for the "Block"  |
   |                    |   |   | item.  Map of type "BlockPreamble";  |
   |                    |   |   | see <a href="#section-7.3.2.1">Section 7.3.2.1</a>.                 |
   |                    |   |   |                                      |
   | block-statistics   |   | M | Statistics about the "Block" item.   |
   |                    |   |   | Map of type "BlockStatistics"; see   |
   |                    |   |   | <a href="#section-7.3.2.2">Section 7.3.2.2</a>.                     |
   |                    |   |   |                                      |
   | block-tables       |   | M | The arrays containing data           |
   |                    |   |   | referenced by individual             |
   |                    |   |   | "QueryResponse" or                   |
   |                    |   |   | "MalformedMessage" items.  Map of    |
   |                    |   |   | type "BlockTables"; see Section      |
   |                    |   |   | 7.3.2.3.                             |
   |                    |   |   |                                      |
   | query-responses    |   | A | Details of individual C-DNS Q/R data |
   |                    |   |   | items.  Array of items of type       |
   |                    |   |   | "QueryResponse"; see Section         |
   |                    |   |   | 7.3.2.4.  If present, the array must |
   |                    |   |   | not be empty.                        |
   |                    |   |   |                                      |




<span class="grey">Dickinson, et al.            Standards Track                   [Page 25]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-26"></span>
<span class="grey"><a href="./rfc8618">RFC 8618</a>         C-DNS: A Format for DNS Packet Capture   September 2019</span>


   | address-event      |   | A | Per-client counts of ICMP messages   |
   | -counts            |   |   | and TCP resets.  Array of items of   |
   |                    |   |   | type "AddressEventCount"; see        |
   |                    |   |   | <a href="#section-7.3.2.5">Section 7.3.2.5</a>.  If present, the    |
   |                    |   |   | array must not be empty.             |
   |                    |   |   |                                      |
   | malformed-messages |   | A | Details of malformed DNS messages.   |
   |                    |   |   | Array of items of type               |
   |                    |   |   | "MalformedMessage"; see Section      |
   |                    |   |   | 7.3.2.6.  If present, the array must |
   |                    |   |   | not be empty.                        |
   +--------------------+---+---+--------------------------------------+

<span class="h5"><a class="dashAnchor" name="//apple_ref/cpp/Section/7.3.2.1.%20%20%22BlockPreamble%22"></a><a class="selflink" href="#section-7.3.2.1" id="section-7.3.2.1">7.3.2.1</a>.  "BlockPreamble"</span>

   Overall information for a "Block" item.  A map containing the
   following:

   +------------------+---+---+----------------------------------------+
   | Field            | M | T | Description                            |
   +------------------+---+---+----------------------------------------+
   | earliest-time    | C | A | A timestamp (two unsigned integers, of |
   |                  |   |   | type "Timestamp") for the earliest     |
   |                  |   |   | record in the "Block" item.  The first |
   |                  |   |   | integer is the number of seconds since |
   |                  |   |   | the POSIX epoch [<a href="#ref-posix-time">posix-time</a>]           |
   |                  |   |   | ("time_t"), excluding leap seconds.    |
   |                  |   |   | The second integer is the number of    |
   |                  |   |   | ticks (see <a href="#section-7.3.1.1.1">Section 7.3.1.1.1</a>) since    |
   |                  |   |   | the start of the second.  This field   |
   |                  |   |   | is mandatory unless all block items    |
   |                  |   |   | containing a time offset from the      |
   |                  |   |   | start of the Block also omit that time |
   |                  |   |   | offset.                                |
   |                  |   |   |                                        |
   | block-parameters |   | U | The index of the item in the           |
   | -index           |   |   | "block-parameters" array (in the       |
   |                  |   |   | "file-preamble" item) applicable to    |
   |                  |   |   | this block.  If not present, index 0   |
   |                  |   |   | is used.  See <a href="#section-7.3.1">Section 7.3.1</a>.           |
   +------------------+---+---+----------------------------------------+










<span class="grey">Dickinson, et al.            Standards Track                   [Page 26]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-27"></span>
<span class="grey"><a href="./rfc8618">RFC 8618</a>         C-DNS: A Format for DNS Packet Capture   September 2019</span>


<span class="h5"><a class="dashAnchor" name="//apple_ref/cpp/Section/7.3.2.2.%20%20%22BlockStatistics%22"></a><a class="selflink" href="#section-7.3.2.2" id="section-7.3.2.2">7.3.2.2</a>.  "BlockStatistics"</span>

   Basic statistical information about a "Block" item.  A map containing
   the following:

   +---------------------+---+---+-------------------------------------+
   | Field               | M | T | Description                         |
   +---------------------+---+---+-------------------------------------+
   | processed-messages  |   | U | Total number of well-formed DNS     |
   |                     |   |   | messages processed from the input   |
   |                     |   |   | traffic stream during collection of |
   |                     |   |   | data in this "Block" item.          |
   |                     |   |   |                                     |
   | qr-data-items       |   | U | Total number of Q/R data items in   |
   |                     |   |   | this "Block" item.                  |
   |                     |   |   |                                     |
   | unmatched-queries   |   | U | Number of unmatched Queries in this |
   |                     |   |   | "Block" item.                       |
   |                     |   |   |                                     |
   | unmatched-responses |   | U | Number of unmatched Responses in    |
   |                     |   |   | this "Block" item.                  |
   |                     |   |   |                                     |
   | discarded-opcode    |   | U | Number of DNS messages processed    |
   |                     |   |   | from the input traffic stream       |
   |                     |   |   | during collection of data in this   |
   |                     |   |   | "Block" item but not recorded       |
   |                     |   |   | because their OPCODE is not in the  |
   |                     |   |   | list to be collected.               |
   |                     |   |   |                                     |
   | malformed-items     |   | U | Number of malformed messages        |
   |                     |   |   | processed from the input traffic    |
   |                     |   |   | stream during collection of data in |
   |                     |   |   | this "Block" item.                  |
   +---------------------+---+---+-------------------------------------+

















<span class="grey">Dickinson, et al.            Standards Track                   [Page 27]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-28"></span>
<span class="grey"><a href="./rfc8618">RFC 8618</a>         C-DNS: A Format for DNS Packet Capture   September 2019</span>


<span class="h5"><a class="dashAnchor" name="//apple_ref/cpp/Section/7.3.2.3.%20%20%22BlockTables%22"></a><a class="selflink" href="#section-7.3.2.3" id="section-7.3.2.3">7.3.2.3</a>.  "BlockTables"</span>

   Map of arrays containing data referenced by individual
   "QueryResponse" or "MalformedMessage" items in this "Block".  Each
   element is an array that, if present, must not be empty.

   An item in the "qlist" array contains indexes to values in the "qrr"
   array.  Therefore, if "qlist" is present, "qrr" must also be present.
   Similarly, if "rrlist" is present, "rr" must also be present.

   The map contains the following items:

   +-------------------+---+---+---------------------------------------+
   | Field             | M | T | Description                           |
   +-------------------+---+---+---------------------------------------+
   | ip-address        |   | A | Array of IP addresses, in network     |
   |                   |   |   | byte order (of type byte string).  If |
   |                   |   |   | client or server address prefixes are |
   |                   |   |   | set, only the address prefix bits are |
   |                   |   |   | stored.  Each string is therefore up  |
   |                   |   |   | to 4 bytes long for an IPv4 address,  |
   |                   |   |   | or up to 16 bytes long for an IPv6    |
   |                   |   |   | address.  See <a href="#section-7.3.1.1.1">Section 7.3.1.1.1</a>.      |
   |                   |   |   |                                       |
   | classtype         |   | A | Array of RR CLASS and TYPE            |
   |                   |   |   | information.  Type is "ClassType".    |
   |                   |   |   | See <a href="#section-7.3.2.3.1">Section 7.3.2.3.1</a>.                |
   |                   |   |   |                                       |
   | name-rdata        |   | A | Array where each entry is the         |
   |                   |   |   | contents of a single NAME or RDATA in |
   |                   |   |   | wire format (of type byte string).    |
   |                   |   |   | Note that NAMEs, and labels within    |
   |                   |   |   | RDATA contents, are full domain names |
   |                   |   |   | or labels; no name compression (per   |
   |                   |   |   | [<a href="./rfc1035" title='"Domain names - implementation and specification"'>RFC1035</a>]) is used on the individual  |
   |                   |   |   | names/labels within the format.       |
   |                   |   |   |                                       |
   | qr-sig            |   | A | Array of Q/R data item signatures.    |
   |                   |   |   | Type is "QueryResponseSignature".     |
   |                   |   |   | See <a href="#section-7.3.2.3.2">Section 7.3.2.3.2</a>.                |
   |                   |   |   |                                       |
   | qlist             |   | A | Array of type "QuestionList".  A      |
   |                   |   |   | "QuestionList" is an array of         |
   |                   |   |   | unsigned integers, indexes to         |
   |                   |   |   | "Question" items in the "qrr" array.  |
   |                   |   |   |                                       |





<span class="grey">Dickinson, et al.            Standards Track                   [Page 28]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-29"></span>
<span class="grey"><a href="./rfc8618">RFC 8618</a>         C-DNS: A Format for DNS Packet Capture   September 2019</span>


   | qrr               |   | A | Array of type "Question".  Each entry |
   |                   |   |   | is the contents of a single Question, |
   |                   |   |   | where a Question is the second or     |
   |                   |   |   | subsequent Question in a Query.  See  |
   |                   |   |   | <a href="#section-7.3.2.3.3">Section 7.3.2.3.3</a>.                    |
   |                   |   |   |                                       |
   | rrlist            |   | A | Array of type "RRList".  An "RRList"  |
   |                   |   |   | is an array of unsigned integers,     |
   |                   |   |   | indexes to "RR" items in the "rr"     |
   |                   |   |   | array.                                |
   |                   |   |   |                                       |
   | rr                |   | A | Array of type "RR".  Each entry is    |
   |                   |   |   | the contents of a single RR.  See     |
   |                   |   |   | <a href="#section-7.3.2.3.4">Section 7.3.2.3.4</a>.                    |
   |                   |   |   |                                       |
   | malformed-message |   | A | Array of the contents of malformed    |
   | -data             |   |   | messages.  Array of type              |
   |                   |   |   | "MalformedMessageData".  See Section  |
   |                   |   |   | 7.3.2.3.5.                            |
   +-------------------+---+---+---------------------------------------+

<span class="h6"><a class="dashAnchor" name="//apple_ref/cpp/Section/7.3.2.3.1.%20%20%22ClassType%22"></a><a class="selflink" href="#section-7.3.2.3.1" id="section-7.3.2.3.1">7.3.2.3.1</a>.  "ClassType"</span>

   RR CLASS and TYPE information.  A map containing the following:

               +-------+---+---+--------------------------+
               | Field | M | T | Description              |
               +-------+---+---+--------------------------+
               | type  | X | U | TYPE value [<a href="#ref-rrtypes" title='"Resource Record (RR) TYPEs"'>rrtypes</a>].    |
               |       |   |   |                          |
               | class | X | U | CLASS value [<a href="#ref-rrclasses">rrclasses</a>]. |
               +-------+---+---+--------------------------+



















<span class="grey">Dickinson, et al.            Standards Track                   [Page 29]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-30"></span>
<span class="grey"><a href="./rfc8618">RFC 8618</a>         C-DNS: A Format for DNS Packet Capture   September 2019</span>


<span class="h6"><a class="dashAnchor" name="//apple_ref/cpp/Section/7.3.2.3.2.%20%20%22QueryResponseSignature%22"></a><a class="selflink" href="#section-7.3.2.3.2" id="section-7.3.2.3.2">7.3.2.3.2</a>.  "QueryResponseSignature"</span>

   Elements of a Q/R data item that are often common between multiple
   individual Q/R data items.  A map containing the following:

   +--------------------+---+---+--------------------------------------+
   | Field              | M | T | Description                          |
   +--------------------+---+---+--------------------------------------+
   | server-address     |   | U | The index in the "ip-address" array  |
   | -index             |   |   | of the server IP address.  See       |
   |                    |   |   | <a href="#section-7.3.2.3">Section 7.3.2.3</a>.                     |
   |                    |   |   |                                      |
   | server-port        |   | U | The server port.                     |
   |                    |   |   |                                      |
   | qr-transport-flags | C | U | Bit flags describing the transport   |
   |                    |   |   | used to service the Query.  Same     |
   |                    |   |   | definition as "mm-transport-flags"   |
   |                    |   |   | in <a href="#section-7.3.2.3.5">Section 7.3.2.3.5</a>, with an        |
   |                    |   |   | additional indicator for trailing    |
   |                    |   |   | bytes.  See <a href="#appendix-A">Appendix A</a>.              |
   |                    |   |   | Bit 0.  IP version.  0 if IPv4, 1 if |
   |                    |   |   | IPv6.  See <a href="#section-6.2.4">Section 6.2.4</a>.            |
   |                    |   |   | Bits 1-4.  Transport.  4-bit         |
   |                    |   |   | unsigned value where                 |
   |                    |   |   | 0 = UDP [<a href="./rfc1035" title='"Domain names - implementation and specification"'>RFC1035</a>]                    |
   |                    |   |   | 1 = TCP [<a href="./rfc1035" title='"Domain names - implementation and specification"'>RFC1035</a>]                    |
   |                    |   |   | 2 = TLS [<a href="./rfc7858" title='"Specification for DNS over Transport Layer Security (TLS)"'>RFC7858</a>]                    |
   |                    |   |   | 3 = DTLS [<a href="./rfc8094" title='"DNS over Datagram Transport Layer Security (DTLS)"'>RFC8094</a>]                   |
   |                    |   |   | 4 = HTTPS [<a href="./rfc8484" title='"DNS Queries over HTTPS (DoH)"'>RFC8484</a>]                  |
   |                    |   |   | 15 = Non-standard transport (see     |
   |                    |   |   | below)                               |
   |                    |   |   | Values 5-14 are reserved for future  |
   |                    |   |   | use.                                 |
   |                    |   |   | Bit 5.  1 if trailing bytes in Query |
   |                    |   |   | packet.  See <a href="#section-11.2">Section 11.2</a>.           |
   |                    |   |   |                                      |
   | qr-type            |   | U | Type of Query/Response transaction   |
   |                    |   |   | based on the definitions in the      |
   |                    |   |   | dnstap schema [<a href="#ref-dnstap-schema">dnstap-schema</a>].       |
   |                    |   |   | 0 = Stub.  A transaction between a   |
   |                    |   |   | stub resolver and a DNS server from  |
   |                    |   |   | the perspective of the stub          |
   |                    |   |   | resolver.                            |
   |                    |   |   | 1 = Client.  A transaction between a |
   |                    |   |   | client and a DNS server (a proxy or  |
   |                    |   |   | full recursive resolver) from the    |
   |                    |   |   | perspective of the DNS server.       |




<span class="grey">Dickinson, et al.            Standards Track                   [Page 30]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-31"></span>
<span class="grey"><a href="./rfc8618">RFC 8618</a>         C-DNS: A Format for DNS Packet Capture   September 2019</span>


   |                    |   |   | 2 = Resolver.  A transaction between |
   |                    |   |   | a recursive resolver and an          |
   |                    |   |   | authoritative server from the        |
   |                    |   |   | perspective of the recursive         |
   |                    |   |   | resolver.                            |
   |                    |   |   | 3 = Authoritative.  A transaction    |
   |                    |   |   | between a recursive resolver and an  |
   |                    |   |   | authoritative server from the        |
   |                    |   |   | perspective of the authoritative     |
   |                    |   |   | server.                              |
   |                    |   |   | 4 = Forwarder.  A transaction        |
   |                    |   |   | between a downstream forwarder and   |
   |                    |   |   | an upstream DNS server (a recursive  |
   |                    |   |   | resolver) from the perspective of    |
   |                    |   |   | the downstream forwarder.            |
   |                    |   |   | 5 = Tool.  A transaction between a   |
   |                    |   |   | DNS software tool and a DNS server,  |
   |                    |   |   | from the perspective of the tool.    |
   |                    |   |   |                                      |
   | qr-sig-flags       |   | U | Bit flags explicitly indicating      |
   |                    |   |   | attributes of the message pair       |
   |                    |   |   | represented by this Q/R data item    |
   |                    |   |   | (not all attributes may be recorded  |
   |                    |   |   | or deducible).                       |
   |                    |   |   | Bit 0.  1 if a Query was present.    |
   |                    |   |   | Bit 1.  1 if a Response was present. |
   |                    |   |   | Bit 2.  1 if a Query was present and |
   |                    |   |   | it had an OPT RR.                    |
   |                    |   |   | Bit 3.  1 if a Response was present  |
   |                    |   |   | and it had an OPT RR.                |
   |                    |   |   | Bit 4.  1 if a Query was present but |
   |                    |   |   | had no Question.                     |
   |                    |   |   | Bit 5.  1 if a Response was present  |
   |                    |   |   | but had no Question (only one        |
   |                    |   |   | query-name-index is stored per Q/R   |
   |                    |   |   | data item).                          |
   |                    |   |   |                                      |
   | query-opcode       |   | U | Query OPCODE.                        |
   |                    |   |   |                                      |
   | qr-dns-flags       |   | U | Bit flags with values from the Query |
   |                    |   |   | and Response DNS flags.  Flag values |
   |                    |   |   | are 0 if the Query or Response is    |
   |                    |   |   | not present.                         |
   |                    |   |   | Bit 0.  Query Checking Disabled      |
   |                    |   |   | (CD).                                |
   |                    |   |   | Bit 1.  Query Authenticated Data     |
   |                    |   |   | (AD).                                |
   |                    |   |   | Bit 2.  Query reserved (Z).          |



<span class="grey">Dickinson, et al.            Standards Track                   [Page 31]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-32"></span>
<span class="grey"><a href="./rfc8618">RFC 8618</a>         C-DNS: A Format for DNS Packet Capture   September 2019</span>


   |                    |   |   | Bit 3.  Query Recursion Available    |
   |                    |   |   | (RA).                                |
   |                    |   |   | Bit 4.  Query Recursion Desired      |
   |                    |   |   | (RD).                                |
   |                    |   |   | Bit 5.  Query TrunCation (TC).       |
   |                    |   |   | Bit 6.  Query Authoritative Answer   |
   |                    |   |   | (AA).                                |
   |                    |   |   | Bit 7.  Query DNSSEC answer OK (DO). |
   |                    |   |   | Bit 8.  Response Checking Disabled   |
   |                    |   |   | (CD).                                |
   |                    |   |   | Bit 9.  Response Authenticated Data  |
   |                    |   |   | (AD).                                |
   |                    |   |   | Bit 10.  Response reserved (Z).      |
   |                    |   |   | Bit 11.  Response Recursion          |
   |                    |   |   | Available (RA).                      |
   |                    |   |   | Bit 12.  Response Recursion Desired  |
   |                    |   |   | (RD).                                |
   |                    |   |   | Bit 13.  Response TrunCation (TC).   |
   |                    |   |   | Bit 14.  Response Authoritative      |
   |                    |   |   | Answer (AA).                         |
   |                    |   |   |                                      |
   | query-rcode        |   | U | Query RCODE.  If the Query contains  |
   |                    |   |   | an OPT RR [<a href="./rfc6891" title='"Extension Mechanisms for DNS (EDNS(0))"'>RFC6891</a>], this value      |
   |                    |   |   | incorporates any EXTENDED-RCODE      |
   |                    |   |   | value [<a href="#ref-rcodes" title='"DNS RCODEs"'>rcodes</a>].                      |
   |                    |   |   |                                      |
   | query-classtype    |   | U | The index in the "classtype" array   |
   | -index             |   |   | of the CLASS and TYPE of the first   |
   |                    |   |   | Question.  See <a href="#section-7.3.2.3">Section 7.3.2.3</a>.      |
   |                    |   |   |                                      |
   | query-qdcount      |   | U | The QDCOUNT in the Query, or         |
   |                    |   |   | Response if no Query present.        |
   |                    |   |   |                                      |
   | query-ancount      |   | U | Query ANCOUNT.                       |
   |                    |   |   |                                      |
   | query-nscount      |   | U | Query NSCOUNT.                       |
   |                    |   |   |                                      |
   | query-arcount      |   | U | Query ARCOUNT.                       |
   |                    |   |   |                                      |
   | query-edns-version |   | U | The Query EDNS version.  ("EDNS"     |
   |                    |   |   | stands for Extension Mechanisms for  |
   |                    |   |   | DNS.)                                |
   |                    |   |   |                                      |
   | query-udp-size     |   | U | The Query EDNS sender's UDP payload  |
   |                    |   |   | size.                                |
   |                    |   |   |                                      |





<span class="grey">Dickinson, et al.            Standards Track                   [Page 32]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-33"></span>
<span class="grey"><a href="./rfc8618">RFC 8618</a>         C-DNS: A Format for DNS Packet Capture   September 2019</span>


   | query-opt-rdata    |   | U | The index in the "name-rdata" array  |
   | -index             |   |   | of the OPT RDATA.  See Section       |
   |                    |   |   | 7.3.2.3.                             |
   |                    |   |   |                                      |
   | response-rcode     |   | U | Response RCODE.  If the Response     |
   |                    |   |   | contains an OPT RR [<a href="./rfc6891" title='"Extension Mechanisms for DNS (EDNS(0))"'>RFC6891</a>], this   |
   |                    |   |   | value incorporates any EXTENDED-     |
   |                    |   |   | RCODE value [<a href="#ref-rcodes" title='"DNS RCODEs"'>rcodes</a>].                |
   +--------------------+---+---+--------------------------------------+

   Version 1.0 of C-DNS supports transport values corresponding to DNS
   transports defined in IETF Standards Track documents at the time of
   writing.  There are numerous non-standard methods of sending DNS
   messages over various transports using a variety of protocols, but
   they are out of scope for this document.  With the current
   specification, these can be generically stored using value 15
   (Non-standard transport), or implementations are free to use the
   negative integer map keys to define their own mappings.  Such
   non-standard transports may also be the subject of a future extension
   to the specification.

<span class="h6"><a class="dashAnchor" name="//apple_ref/cpp/Section/7.3.2.3.3.%20%20%22Question%22"></a><a class="selflink" href="#section-7.3.2.3.3" id="section-7.3.2.3.3">7.3.2.3.3</a>.  "Question"</span>

   Details on individual Questions in a Question section.  A map
   containing the following:

   +-----------------+---+---+-----------------------------------------+
   | Field           | M | T | Description                             |
   +-----------------+---+---+-----------------------------------------+
   | name-index      | X | U | The index in the "name-rdata" array of  |
   |                 |   |   | the QNAME.  See <a href="#section-7.3.2.3">Section 7.3.2.3</a>.        |
   |                 |   |   |                                         |
   | classtype-index | X | U | The index in the "classtype" array of   |
   |                 |   |   | the CLASS and TYPE of the Question.     |
   |                 |   |   | See <a href="#section-7.3.2.3">Section 7.3.2.3</a>.                    |
   +-----------------+---+---+-----------------------------------------+















<span class="grey">Dickinson, et al.            Standards Track                   [Page 33]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-34"></span>
<span class="grey"><a href="./rfc8618">RFC 8618</a>         C-DNS: A Format for DNS Packet Capture   September 2019</span>


<span class="h6"><a class="dashAnchor" name="//apple_ref/cpp/Section/7.3.2.3.4.%20%20%22RR%22"></a><a class="selflink" href="#section-7.3.2.3.4" id="section-7.3.2.3.4">7.3.2.3.4</a>.  "RR"</span>

   Details on individual RRs in RR sections.  A map containing the
   following:

   +-----------------+---+---+-----------------------------------------+
   | Field           | M | T | Description                             |
   +-----------------+---+---+-----------------------------------------+
   | name-index      | X | U | The index in the "name-rdata" array of  |
   |                 |   |   | the NAME.  See <a href="#section-7.3.2.3">Section 7.3.2.3</a>.         |
   |                 |   |   |                                         |
   | classtype-index | X | U | The index in the "classtype" array of   |
   |                 |   |   | the CLASS and TYPE of the RR.  See      |
   |                 |   |   | <a href="#section-7.3.2.3">Section 7.3.2.3</a>.                        |
   |                 |   |   |                                         |
   | ttl             |   | U | The RR Time to Live.                    |
   |                 |   |   |                                         |
   | rdata-index     |   | U | The index in the "name-rdata" array of  |
   |                 |   |   | the RR RDATA.  See <a href="#section-7.3.2.3">Section 7.3.2.3</a>.     |
   +-----------------+---+---+-----------------------------------------+

<span class="h6"><a class="dashAnchor" name="//apple_ref/cpp/Section/7.3.2.3.5.%20%20%22MalformedMessageData%22"></a><a class="selflink" href="#section-7.3.2.3.5" id="section-7.3.2.3.5">7.3.2.3.5</a>.  "MalformedMessageData"</span>

   Details on malformed DNS messages stored in this "Block" item.  A map
   containing the following:

   +--------------------+---+---+--------------------------------------+
   | Field              | M | T | Description                          |
   +--------------------+---+---+--------------------------------------+
   | server-address     |   | U | The index in the "ip-address" array  |
   | -index             |   |   | of the server IP address.  See       |
   |                    |   |   | <a href="#section-7.3.2.3">Section 7.3.2.3</a>.                     |
   |                    |   |   |                                      |
   | server-port        |   | U | The server port.                     |
   |                    |   |   |                                      |
   | mm-transport-flags | C | U | Bit flags describing the transport   |
   |                    |   |   | used to service the Query.  See      |
   |                    |   |   | <a href="#section-6.2.4">Section 6.2.4</a>.                       |
   |                    |   |   | Bits 1-4.  Transport.  4-bit         |
   |                    |   |   | unsigned value where                 |
   |                    |   |   | 0 = UDP [<a href="./rfc1035" title='"Domain names - implementation and specification"'>RFC1035</a>]                    |
   |                    |   |   | 1 = TCP [<a href="./rfc1035" title='"Domain names - implementation and specification"'>RFC1035</a>]                    |
   |                    |   |   | 2 = TLS [<a href="./rfc7858" title='"Specification for DNS over Transport Layer Security (TLS)"'>RFC7858</a>]                    |
   |                    |   |   | 3 = DTLS [<a href="./rfc8094" title='"DNS over Datagram Transport Layer Security (DTLS)"'>RFC8094</a>]                   |
   |                    |   |   | 4 = HTTPS [<a href="./rfc8484" title='"DNS Queries over HTTPS (DoH)"'>RFC8484</a>]                  |
   |                    |   |   | 15 = Non-standard transport          |
   |                    |   |   | Values 5-14 are reserved for future  |
   |                    |   |   | use.                                 |



<span class="grey">Dickinson, et al.            Standards Track                   [Page 34]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-35"></span>
<span class="grey"><a href="./rfc8618">RFC 8618</a>         C-DNS: A Format for DNS Packet Capture   September 2019</span>


   |                    |   |   |                                      |
   | mm-payload         |   | S | The payload (raw bytes) of the DNS   |
   |                    |   |   | message.                             |
   +--------------------+---+---+--------------------------------------+

<span class="h5"><a class="dashAnchor" name="//apple_ref/cpp/Section/7.3.2.4.%20%20%22QueryResponse%22"></a><a class="selflink" href="#section-7.3.2.4" id="section-7.3.2.4">7.3.2.4</a>.  "QueryResponse"</span>

   Details on individual Q/R data items.

   Note that there is no requirement that the elements of the
   "query-responses" array are presented in strict chronological order.

   A map containing the following items:

   +----------------------+---+---+------------------------------------+
   | Field                | M | T | Description                        |
   +----------------------+---+---+------------------------------------+
   | time-offset          |   | U | Q/R timestamp as an offset in      |
   |                      |   |   | ticks (see <a href="#section-7.3.1.1.1">Section 7.3.1.1.1</a>) from |
   |                      |   |   | "earliest-time".  The timestamp is |
   |                      |   |   | the timestamp of the Query, or the |
   |                      |   |   | Response if there is no Query.     |
   |                      |   |   |                                    |
   | client-address-index |   | U | The index in the "ip-address"      |
   |                      |   |   | array of the client IP address.    |
   |                      |   |   | See <a href="#section-7.3.2.3">Section 7.3.2.3</a>.               |
   |                      |   |   |                                    |
   | client-port          |   | U | The client port.                   |
   |                      |   |   |                                    |
   | transaction-id       |   | U | DNS transaction identifier.        |
   |                      |   |   |                                    |
   | qr-signature-index   |   | U | The index in the "qr-sig" array of |
   |                      |   |   | the "QueryResponseSignature" item. |
   |                      |   |   | See <a href="#section-7.3.2.3">Section 7.3.2.3</a>.               |
   |                      |   |   |                                    |
   | client-hoplimit      |   | U | The IPv4 TTL or IPv6 Hoplimit from |
   |                      |   |   | the Query packet.                  |
   |                      |   |   |                                    |
   | response-delay       |   | I | The time difference between Query  |
   |                      |   |   | and Response, in ticks.  See       |
   |                      |   |   | <a href="#section-7.3.1.1.1">Section 7.3.1.1.1</a>.  Only present   |
   |                      |   |   | if there is a Query and a          |
   |                      |   |   | Response.  The delay can be        |
   |                      |   |   | negative if the network            |
   |                      |   |   | stack/capture library returns      |
   |                      |   |   | packets out of order.              |
   |                      |   |   |                                    |




<span class="grey">Dickinson, et al.            Standards Track                   [Page 35]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-36"></span>
<span class="grey"><a href="./rfc8618">RFC 8618</a>         C-DNS: A Format for DNS Packet Capture   September 2019</span>


   | query-name-index     |   | U | The index in the "name-rdata"      |
   |                      |   |   | array of the item containing the   |
   |                      |   |   | QNAME for the first Question.  See |
   |                      |   |   | <a href="#section-7.3.2.3">Section 7.3.2.3</a>.                   |
   |                      |   |   |                                    |
   | query-size           |   | U | DNS Query message size (see        |
   |                      |   |   | below).                            |
   |                      |   |   |                                    |
   | response-size        |   | U | DNS Response message size (see     |
   |                      |   |   | below).                            |
   |                      |   |   |                                    |
   | response-processing  |   | M | Data on Response processing.  Map  |
   | -data                |   |   | of type "ResponseProcessingData".  |
   |                      |   |   | See <a href="#section-7.3.2.4.1">Section 7.3.2.4.1</a>.             |
   |                      |   |   |                                    |
   | query-extended       |   | M | Extended Query data.  Map of type  |
   |                      |   |   | "QueryResponseExtended".  See      |
   |                      |   |   | <a href="#section-7.3.2.4.2">Section 7.3.2.4.2</a>.                 |
   |                      |   |   |                                    |
   | response-extended    |   | M | Extended Response data.  Map of    |
   |                      |   |   | type "QueryResponseExtended".  See |
   |                      |   |   | <a href="#section-7.3.2.4.2">Section 7.3.2.4.2</a>.                 |
   +----------------------+---+---+------------------------------------+

   The "query-size" and "response-size" fields hold the DNS message
   size.  For UDP, this is the size of the UDP payload that contained
   the DNS message.  For TCP, it is the size of the DNS message as
   specified in the two-byte message length header.  Trailing bytes in
   UDP Queries are routinely observed in traffic to authoritative
   servers, and this value allows a calculation of how many trailing
   bytes were present.

<span class="h6"><a class="dashAnchor" name="//apple_ref/cpp/Section/7.3.2.4.1.%20%20%22ResponseProcessingData%22"></a><a class="selflink" href="#section-7.3.2.4.1" id="section-7.3.2.4.1">7.3.2.4.1</a>.  "ResponseProcessingData"</span>

   Information on the server processing that produced the Response.  A
   map containing the following:

   +------------------+---+---+----------------------------------------+
   | Field            | M | T | Description                            |
   +------------------+---+---+----------------------------------------+
   | bailiwick-index  |   | U | The index in the "name-rdata" array of |
   |                  |   |   | the owner name for the Response        |
   |                  |   |   | bailiwick.  See <a href="#section-7.3.2.3">Section 7.3.2.3</a>.       |
   |                  |   |   |                                        |
   | processing-flags |   | U | Flags relating to Response processing. |
   |                  |   |   | Bit 0.  1 if the Response came from    |
   |                  |   |   | cache.                                 |
   +------------------+---+---+----------------------------------------+



<span class="grey">Dickinson, et al.            Standards Track                   [Page 36]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-37"></span>
<span class="grey"><a href="./rfc8618">RFC 8618</a>         C-DNS: A Format for DNS Packet Capture   September 2019</span>


<span class="h6"><a class="dashAnchor" name="//apple_ref/cpp/Section/7.3.2.4.2.%20%20%22QueryResponseExtended%22"></a><a class="selflink" href="#section-7.3.2.4.2" id="section-7.3.2.4.2">7.3.2.4.2</a>.  "QueryResponseExtended"</span>

   Extended data on the Q/R data item.

   Each item in the map is present only if collection of the relevant
   details is configured.

   A map containing the following items:

   +------------------+---+---+----------------------------------------+
   | Field            | M | T | Description                            |
   +------------------+---+---+----------------------------------------+
   | question-index   |   | U | The index in the "qlist" array of the  |
   |                  |   |   | entry listing any second and           |
   |                  |   |   | subsequent Questions in the Question   |
   |                  |   |   | section for the Query or Response.     |
   |                  |   |   | See <a href="#section-7.3.2.3">Section 7.3.2.3</a>.                   |
   |                  |   |   |                                        |
   | answer-index     |   | U | The index in the "rrlist" array of the |
   |                  |   |   | entry listing the Answer RR sections   |
   |                  |   |   | for the Query or Response.  See        |
   |                  |   |   | <a href="#section-7.3.2.3">Section 7.3.2.3</a>.                       |
   |                  |   |   |                                        |
   | authority-index  |   | U | The index in the "rrlist" array of the |
   |                  |   |   | entry listing the Authority RR         |
   |                  |   |   | sections for the Query or Response.    |
   |                  |   |   | See <a href="#section-7.3.2.3">Section 7.3.2.3</a>.                   |
   |                  |   |   |                                        |
   | additional-index |   | U | The index in the "rrlist" array of the |
   |                  |   |   | entry listing the Additional RR        |
   |                  |   |   | sections for the Query or Response.    |
   |                  |   |   | See <a href="#section-7.3.2.3">Section 7.3.2.3</a>.  Note that Query  |
   |                  |   |   | OPT RR data can optionally be stored   |
   |                  |   |   | in the QuerySignature.                 |
   +------------------+---+---+----------------------------------------+
















<span class="grey">Dickinson, et al.            Standards Track                   [Page 37]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-38"></span>
<span class="grey"><a href="./rfc8618">RFC 8618</a>         C-DNS: A Format for DNS Packet Capture   September 2019</span>


<span class="h5"><a class="dashAnchor" name="//apple_ref/cpp/Section/7.3.2.5.%20%20%22AddressEventCount%22"></a><a class="selflink" href="#section-7.3.2.5" id="section-7.3.2.5">7.3.2.5</a>.  "AddressEventCount"</span>

   Counts of various IP-related events relating to traffic with
   individual client addresses.  A map containing the following:

   +--------------------+---+---+--------------------------------------+
   | Field              | M | T | Description                          |
   +--------------------+---+---+--------------------------------------+
   | ae-type            | X | U | The type of event.  The following    |
   |                    |   |   | event types are currently defined:   |
   |                    |   |   | 0.  TCP reset.                       |
   |                    |   |   | 1.  ICMP time exceeded.              |
   |                    |   |   | 2.  ICMP destination unreachable.    |
   |                    |   |   | 3.  ICMPv6 time exceeded.            |
   |                    |   |   | 4.  ICMPv6 destination unreachable.  |
   |                    |   |   | 5.  ICMPv6 packet too big.           |
   |                    |   |   |                                      |
   | ae-code            |   | U | A code relating to the event.  For   |
   |                    |   |   | ICMP or ICMPv6 events, this MUST be  |
   |                    |   |   | the ICMP [<a href="./rfc792" title='"Internet Control Message Protocol"'>RFC792</a>] or ICMPv6          |
   |                    |   |   | [<a href="./rfc4443" title='"Internet Control Message Protocol (ICMPv6) for the Internet Protocol Version 6 (IPv6) Specification"'>RFC4443</a>] code.  For other events,   |
   |                    |   |   | the contents are undefined.          |
   |                    |   |   |                                      |
   | ae-transport-flags | C | U | Bit flags describing the transport   |
   |                    |   |   | used to service the event.  See      |
   |                    |   |   | <a href="#section-6.2.4">Section 6.2.4</a>.                       |
   |                    |   |   | Bit 0.  IP version.  0 if IPv4, 1 if |
   |                    |   |   | IPv6.                                |
   |                    |   |   | Bits 1-4.  Transport.  4-bit         |
   |                    |   |   | unsigned value where                 |
   |                    |   |   | 0 = UDP [<a href="./rfc1035" title='"Domain names - implementation and specification"'>RFC1035</a>]                    |
   |                    |   |   | 1 = TCP [<a href="./rfc1035" title='"Domain names - implementation and specification"'>RFC1035</a>]                    |
   |                    |   |   | 2 = TLS [<a href="./rfc7858" title='"Specification for DNS over Transport Layer Security (TLS)"'>RFC7858</a>]                    |
   |                    |   |   | 3 = DTLS [<a href="./rfc8094" title='"DNS over Datagram Transport Layer Security (DTLS)"'>RFC8094</a>]                   |
   |                    |   |   | 4 = HTTPS [<a href="./rfc8484" title='"DNS Queries over HTTPS (DoH)"'>RFC8484</a>]                  |
   |                    |   |   | 15 = Non-standard transport          |
   |                    |   |   | Values 5-14 are reserved for future  |
   |                    |   |   | use.                                 |
   |                    |   |   |                                      |
   | ae-address-index   | X | U | The index in the "ip-address" array  |
   |                    |   |   | of the client address.  See Section  |
   |                    |   |   | 7.3.2.3.                             |
   |                    |   |   |                                      |
   | ae-count           | X | U | The number of occurrences of this    |
   |                    |   |   | event during the Block collection    |
   |                    |   |   | period.                              |
   +--------------------+---+---+--------------------------------------+




<span class="grey">Dickinson, et al.            Standards Track                   [Page 38]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-39"></span>
<span class="grey"><a href="./rfc8618">RFC 8618</a>         C-DNS: A Format for DNS Packet Capture   September 2019</span>


<span class="h5"><a class="dashAnchor" name="//apple_ref/cpp/Section/7.3.2.6.%20%20%22MalformedMessage%22"></a><a class="selflink" href="#section-7.3.2.6" id="section-7.3.2.6">7.3.2.6</a>.  "MalformedMessage"</span>

   Details on Malformed Message data items.  A map containing the
   following:

   +----------------------+---+---+------------------------------------+
   | Field                | M | T | Description                        |
   +----------------------+---+---+------------------------------------+
   | time-offset          |   | U | Message timestamp as an offset in  |
   |                      |   |   | ticks (see <a href="#section-7.3.1.1.1">Section 7.3.1.1.1</a>) from |
   |                      |   |   | "earliest-time".                   |
   |                      |   |   |                                    |
   | client-address-index |   | U | The index in the "ip-address"      |
   |                      |   |   | array of the client IP address.    |
   |                      |   |   | See <a href="#section-7.3.2.3">Section 7.3.2.3</a>.               |
   |                      |   |   |                                    |
   | client-port          |   | U | The client port.                   |
   |                      |   |   |                                    |
   | message-data-index   |   | U | The index in the "malformed-       |
   |                      |   |   | message-data" array of the message |
   |                      |   |   | data for this message.  See        |
   |                      |   |   | <a href="#section-7.3.2.3">Section 7.3.2.3</a>.                   |
   +----------------------+---+---+------------------------------------+

<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/8.%20%20Versioning"></a><a class="selflink" href="#section-8" id="section-8">8</a>.  Versioning</span>

   The C-DNS File Preamble includes a file Format Version; a major and
   minor version number are required fields.  This document defines
   version 1.0 of the C-DNS specification.  This section describes the
   intended use of these version numbers in future specifications.

   It is noted that version 1.0 includes many optional fields;
   therefore, consumers of version 1.0 should be inherently robust to
   parsing files with variable data content.

   Within a major version, a new minor version MUST be a strict superset
   of the previous minor version, with no semantic changes to existing
   fields.  New keys MAY be added to existing maps, and new maps MAY be
   added.  A consumer capable of reading a particular major.minor
   version MUST also be capable of reading all previous minor versions
   of the same major version.  It SHOULD also be capable of parsing all
   subsequent minor versions, ignoring any keys or maps that it does not
   recognize.








<span class="grey">Dickinson, et al.            Standards Track                   [Page 39]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-40"></span>
<span class="grey"><a href="./rfc8618">RFC 8618</a>         C-DNS: A Format for DNS Packet Capture   September 2019</span>


   A new major version indicates changes to the format that are not
   backwards compatible with previous major versions.  A consumer
   capable of only reading a particular major version (greater than 1)
   is neither required nor expected to be capable of reading a previous
   major version.

<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/9.%20%20C-DNS%20to%20PCAP"></a><a class="selflink" href="#section-9" id="section-9">9</a>.  C-DNS to PCAP</span>

   It is usually possible to reconstruct PCAP files from the C-DNS
   format in a lossy fashion.  Some of the issues with reconstructing
   both the DNS payload and the full packet stream are outlined here.

   The reconstruction of well-formed DNS messages depends on two
   factors:

   1.  Whether or not a particular subset of the optional fields were
       captured in the C-DNS file, specifically the data fields
       necessary to reconstruct a valid IP header and DNS payload for
       both Query and Response (see <a href="#appendix-D.1">Appendix D.1</a>).  Clearly, if not all
       these data fields were captured, the reconstruction is likely to
       be imperfect even if reasonable defaults are provided for the
       reconstruction.

   2.  Whether or not at least one field was captured that unambiguously
       identifies the Query/Response data item as containing just a
       Query, just a Response, or a Query/Response pair.  Obviously, the
       qr-sig-flags defined in <a href="#section-7.3.2.3.2">Section 7.3.2.3.2</a> is such a field;
       however, this field is optional.  For more details, see
       <a href="#appendix-D.2">Appendix D.2</a>.

   It is noted again that simply having hints that indicate that certain
   data fields were not omitted does not guarantee that those data
   fields were actually captured.  Therefore, the ability to reconstruct
   PCAP data (in the absence of defaults) can in principle vary for each
   record captured in a C-DNS file, and between Blocks that have
   differing hints.

   Even if all sections of the Response were captured, one cannot
   reconstruct the DNS Response payload exactly, due to the fact that
   some DNS names in the message on the wire may have been compressed.
   <a href="#section-9.1">Section 9.1</a> discusses this in more detail.










<span class="grey">Dickinson, et al.            Standards Track                   [Page 40]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-41"></span>
<span class="grey"><a href="./rfc8618">RFC 8618</a>         C-DNS: A Format for DNS Packet Capture   September 2019</span>


   Some transport information is not captured in the C-DNS format.  For
   example, the following aspects of the original packet stream cannot
   be reconstructed from the C-DNS format:

   o  IP fragmentation

   o  TCP stream information:

      *  Multiple DNS messages may have been sent in a single TCP
         segment

      *  A DNS payload may have been split across multiple TCP segments

      *  Multiple DNS messages may have been sent on a single TCP
         session

   o  TLS session information:

      *  TLS version or cipher suites

      *  TLS-related features such as TCP Fast Open (TFO) [<a href="./rfc7413" title='"TCP Fast Open"'>RFC7413</a>] or
         TLS session resumption [<a href="./rfc5077" title='"Transport Layer Security (TLS) Session Resumption without Server-Side State"'>RFC5077</a>]

   o  DNS-over-HTTPS [<a href="./rfc8484" title='"DNS Queries over HTTPS (DoH)"'>RFC8484</a>] message details:

      *  Whether the message used POST or GET

      *  HTTPS Headers

   o  Malformed DNS messages if the wire format is not recorded

   o  Any non-DNS messages that were in the original packet stream,
      e.g., ICMP

   Simple assumptions can be made on the reconstruction: fragmented and
   DNS-over-TCP messages can be reconstructed into single packets, and a
   single TCP session can be constructed for each TCP packet.

   Additionally, if malformed messages and non-DNS packets are captured
   separately, they can be merged with packet captures reconstructed
   from C-DNS to produce a more complete packet stream.










<span class="grey">Dickinson, et al.            Standards Track                   [Page 41]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-42"></span>
<span class="grey"><a href="./rfc8618">RFC 8618</a>         C-DNS: A Format for DNS Packet Capture   September 2019</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/9.1.%20%20Name%20Compression"></a><a class="selflink" href="#section-9.1" id="section-9.1">9.1</a>.  Name Compression</span>

   All the names stored in the C-DNS format are full domain names; no
   name compression (per [<a href="./rfc1035" title='"Domain names - implementation and specification"'>RFC1035</a>]) is used on the individual names
   within the format.  Therefore, when reconstructing a packet, name
   compression must be used in order to reproduce the on-the-wire
   representation of the packet.

   Name compression per [<a href="./rfc1035" title='"Domain names - implementation and specification"'>RFC1035</a>] works by substituting trailing
   sections of a name with a reference back to the occurrence of those
   sections earlier in the message.  Not all name server software uses
   the same algorithm when compressing domain names within the
   Responses.  Some attempt maximum recompression at the expense of
   runtime resources, others use heuristics to balance compression and
   speed, and others use different rules for what is a valid compression
   target.

   This means that Responses to the same Query from different name
   server software that match in terms of DNS payload content (header,
   counts, RRs with name compression removed) do not necessarily match
   byte for byte on the wire.

   Therefore, it is not possible to ensure that the DNS Response payload
   is reconstructed byte for byte from C-DNS data.  However, it can at
   least, in principle, be reconstructed to have the correct payload
   length (since the original Response length is captured) if there is
   enough knowledge of the commonly implemented name compression
   algorithms.  For example, a simplistic approach would be to try each
   algorithm in turn to see if it reproduces the original length,
   stopping at the first match.  This would not guarantee that the
   correct algorithm has been used, as it is possible to match the
   length whilst still not matching the on-the-wire bytes; however,
   without further information added to the C-DNS data, this is the best
   that can be achieved.

   <a href="#appendix-B">Appendix B</a> presents an example of two different compression
   algorithms used by well-known name server software.

<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/10.%20%20Data%20Collection"></a><a class="selflink" href="#section-10" id="section-10">10</a>.  Data Collection</span>

   This section describes a non-normative proposed algorithm for the
   processing of a captured stream of DNS Queries and Responses and
   production of a stream of Q/R data items, matching Queries and
   Responses where possible.







<span class="grey">Dickinson, et al.            Standards Track                   [Page 42]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-43"></span>
<span class="grey"><a href="./rfc8618">RFC 8618</a>         C-DNS: A Format for DNS Packet Capture   September 2019</span>


   For the purposes of this discussion, it is assumed that the input has
   been preprocessed such that:

   1.  All IP fragmentation reassembly, TCP stream reassembly, and
       so on, have already been performed.

   2.  Each message is associated with transport metadata required to
       generate the Primary ID (see <a href="#section-10.2.1">Section 10.2.1</a>).

   3.  Each message has a well-formed DNS Header of 12 bytes, and (if
       present) the first Question in the Question section can be parsed
       to generate the Secondary ID (see below).  As noted earlier, this
       requirement can result in a malformed Query being removed in the
       preprocessing stage, but the correctly formed Response with RCODE
       of FORMERR being present.

   DNS messages are processed in the order they are delivered to the
   implementation.

   It should be noted that packet capture libraries do not necessarily
   provide packets in strict chronological order.  This can, for
   example, arise on multi-core platforms where packets arriving at a
   network device are processed by different cores.  On systems where
   this behavior has been observed, the timestamps associated with each
   packet are consistent; Queries always have a timestamp prior to the
   Response timestamp.  However, the order in which these packets appear
   in the packet capture stream is not necessarily strictly
   chronological; a Response can appear in the capture stream before the
   Query that provoked the Response.  For this discussion, this
   non-chronological delivery is termed "skew".

   In the presence of skew, Response packets can arrive for matching
   before the corresponding Query.  To avoid generating false instances
   of Responses without a matching Query, and Queries without a matching
   Response, the matching algorithm must take the possibility of skew
   into account.

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/10.1.%20%20Matching%20Algorithm"></a><a class="selflink" href="#section-10.1" id="section-10.1">10.1</a>.  Matching Algorithm</span>

   A schematic representation of the algorithm for matching Q/R data
   items is shown in Figure 3.  It takes individual DNS Query or
   Response messages as input, and it outputs matched Q/R data items.
   The numbers in the figure identify matching operations listed in
   Table 1.  Specific details of the algorithm -- for example, queues,
   timers, and identifiers -- are given in the following sections.






<span class="grey">Dickinson, et al.            Standards Track                   [Page 43]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-44"></span>
<span class="grey"><a href="./rfc8618">RFC 8618</a>         C-DNS: A Format for DNS Packet Capture   September 2019</span>


                       .----------------------.
                       | Process next message |&lt;------------------+
                       `----------------------'                   |
                                   |                              |
                   +------------------------------+               |
                   | Generate message identifiers |               |
                   +------------------------------+               |
                                   |                              |
                          Response | Query                        |
                   +--------------&lt; &gt;---------------+             |
                   |                                |             |
         +--------------------+           +--------------------+  |
         | Find earliest QR   |           | Create QR item (2) |  |
         | item in OFIFO (1)  |           +--------------------+  |
         +--------------------+                     |             |
                    |                        +---------------+    |
              Match | No match               | Append new QR |    |
          +--------&lt; &gt;------+                | item to OFIFO |    |
          |                 |                +---------------+    |
    +-----------+      +--------+                   |             |
    | Update QR |      | Add to |          +-------------------+  |
    | item (3)  |      | RFIFO  |          | Find earliest QR  |  |
    +-----------+      +--------+          | item in RFIFO (1) |  |
          |                 |              +-------------------+  |
          +-----------------+                       |             |
                    |                               |             |
                    |     +----------------+  Match | No match    |
                    |     | Remove R       |-------&lt; &gt;-----+      |
                    |     | from RFIFO (3) |               |      |
                    |     +----------------+               |      |
                    |              |                       |      |
                    +--------------+-----------------------+      |
                                   |                              |
            +----------------------------------------------+      |
            | Update all timed-out (QT) OFIFO QR items (4) |      |
            +----------------------------------------------+      |
                                   |                              |
                   +--------------------------------+             |
                   | Remove all timed-out (ST) R    |             |
                   | from RFIFO, create QR item (5) |             |
                   +--------------------------------+             |
               ____________________|_______________________       |
              /                                            /      |
             /  Remove all consecutive done entries from  /-------+
            /   front of OFIFO for further processing    /
           /____________________________________________/





<span class="grey">Dickinson, et al.            Standards Track                   [Page 44]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-45"></span>
<span class="grey"><a href="./rfc8618">RFC 8618</a>         C-DNS: A Format for DNS Packet Capture   September 2019</span>


           OFIFO = output FIFO containing Q/R data items (<a href="#section-10.6">Section 10.6</a>)
           RFIFO = Response FIFO containing unmatched Response items
                   (<a href="#section-10.6">Section 10.6</a>)
           QT = Query Timeout (<a href="#section-10.3">Section 10.3</a>)
           ST = Skew Timeout (<a href="#section-10.3">Section 10.3</a>)

                Figure 3: Query/Response Matching Algorithm

         +-----------+-------------------------------------------+
         | Reference | Operation                                 |
         +-----------+-------------------------------------------+
         | (1)       | Find earliest QR item in FIFO where:      |
         |           | * QR.done = false                         |
         |           | * QR.Q.PrimaryID == R.PrimaryID           |
         |           | and, if both QR.Q and R have SecondaryID: |
         |           | * QR.Q.SecondaryID == R.SecondaryID       |
         |           |                                           |
         | (2)       | Set:                                      |
         |           | QR.Q := Q                                 |
         |           | QR.R := nil                               |
         |           | QR.done := false                          |
         |           |                                           |
         | (3)       | Set:                                      |
         |           | QR.R := R                                 |
         |           | QR.done := true                           |
         |           |                                           |
         | (4)       | Set:                                      |
         |           | QR.done := true                           |
         |           |                                           |
         | (5)       | Set:                                      |
         |           | QR.Q := nil                               |
         |           | QR.R := R                                 |
         |           | QR.done := true                           |
         +-----------+-------------------------------------------+

            Table 1: Operations Used in the Matching Algorithm

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/10.2.%20%20Message%20Identifiers"></a><a class="selflink" href="#section-10.2" id="section-10.2">10.2</a>.  Message Identifiers</span>

<span class="h4"><a class="dashAnchor" name="//apple_ref/cpp/Section/10.2.1.%20%20Primary%20ID%20%28Required%29"></a><a class="selflink" href="#section-10.2.1" id="section-10.2.1">10.2.1</a>.  Primary ID (Required)</span>

   A Primary ID is constructed for each message.  It is composed of the
   following data:

   1.  Source IP Address

   2.  Destination IP Address




<span class="grey">Dickinson, et al.            Standards Track                   [Page 45]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-46"></span>
<span class="grey"><a href="./rfc8618">RFC 8618</a>         C-DNS: A Format for DNS Packet Capture   September 2019</span>


   3.  Source Port

   4.  Destination Port

   5.  Transport

   6.  DNS Message ID

<span class="h4"><a class="dashAnchor" name="//apple_ref/cpp/Section/10.2.2.%20%20Secondary%20ID%20%28Optional%29"></a><a class="selflink" href="#section-10.2.2" id="section-10.2.2">10.2.2</a>.  Secondary ID (Optional)</span>

   If present, the first Question in the Question section is used as a
   Secondary ID for each message.  Note that there may be well-formed
   DNS Queries that have a QDCOUNT of 0, and some Responses may have a
   QDCOUNT of 0 (for example, Responses with RCODE=FORMERR or NOTIMP).
   In this case, the Secondary ID is not used in matching.

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/10.3.%20%20Algorithm%20Parameters"></a><a class="selflink" href="#section-10.3" id="section-10.3">10.3</a>.  Algorithm Parameters</span>

   1.  Query Timeout (QT).  A Query arrives with timestamp t1.  If no
       Response matching that Query has arrived before other input
       arrives timestamped later than (t1 + QT), a Q/R data item
       containing only a Query is recorded.  The QT value is typically
       on the order of 5 seconds.

   2.  Skew Timeout (ST).  A Response arrives with timestamp t2.  If a
       Response has not been matched by a Query before input arrives
       timestamped later than (t2 + ST), a Q/R data item containing only
       a Response is recorded.  The ST value is typically a few
       microseconds.

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/10.4.%20%20Algorithm%20Requirements"></a><a class="selflink" href="#section-10.4" id="section-10.4">10.4</a>.  Algorithm Requirements</span>

   The algorithm is designed to handle the following input data:

   1.  Multiple Queries with the same Primary ID (but different
       Secondary ID) arriving before any Responses for these Queries
       are seen.

   2.  Multiple Queries with the same Primary and Secondary ID arriving
       before any Responses for these Queries are seen.

   3.  Queries for which no later Response can be found within the
       specified timeout.

   4.  Responses for which no previous Query can be found within the
       specified timeout.





<span class="grey">Dickinson, et al.            Standards Track                   [Page 46]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-47"></span>
<span class="grey"><a href="./rfc8618">RFC 8618</a>         C-DNS: A Format for DNS Packet Capture   September 2019</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/10.5.%20%20Algorithm%20Limitations"></a><a class="selflink" href="#section-10.5" id="section-10.5">10.5</a>.  Algorithm Limitations</span>

   For cases 1 and 2 listed in the above requirements, it is not
   possible to unambiguously match Queries with Responses.  This
   algorithm chooses to match to the earliest Query with the correct
   Primary and Secondary ID.

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/10.6.%20%20Workspace"></a><a class="selflink" href="#section-10.6" id="section-10.6">10.6</a>.  Workspace</span>

   The algorithm employs two FIFO queues:

   o  OFIFO: an output FIFO containing Q/R data items in chronological
      order.

   o  RFIFO: a FIFO holding Responses without a matching Query in order
      of arrival.

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/10.7.%20%20Output"></a><a class="selflink" href="#section-10.7" id="section-10.7">10.7</a>.  Output</span>

   The output is a list of Q/R data items.  Both the Query and Response
   elements are optional in these items; therefore, Q/R data items have
   one of three types of content:

   1.  A matched pair of Query and Response messages

   2.  A Query message with no Response

   3.  A Response message with no Query

   The timestamp of a list item is that of the Query for cases 1 and 2
   and that of the Response for case 3.

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/10.8.%20%20Post-Processing"></a><a class="selflink" href="#section-10.8" id="section-10.8">10.8</a>.  Post-Processing</span>

   When ending a capture, all items in the RFIFO are timed out
   immediately, generating Response only entries to the OFIFO.  These
   and all other remaining entries in the OFIFO should be treated as
   timed-out Queries.

<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/11.%20%20Implementation%20Guidance"></a><a class="selflink" href="#section-11" id="section-11">11</a>.  Implementation Guidance</span>

   Whilst this document makes no specific recommendations with respect
   to "Canonical CBOR" (see <a href="./rfc7049#section-3.9">SectionÂ 3.9 of [RFC7049]</a>), the following
   guidance may be of use to implementers.

   Adherence to the first two rules given in <a href="./rfc7049#section-3.9">SectionÂ 3.9 of [RFC7049]</a>
   will minimize file sizes.




<span class="grey">Dickinson, et al.            Standards Track                   [Page 47]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-48"></span>
<span class="grey"><a href="./rfc8618">RFC 8618</a>         C-DNS: A Format for DNS Packet Capture   September 2019</span>


   Adherence to the last two rules given in <a href="./rfc7049#section-3.9">SectionÂ 3.9 of [RFC7049]</a> for
   all maps and arrays would unacceptably constrain implementations --
   for example, in the use case of real-time data collection in
   constrained environments where outputting Block Tables after Q/R data
   items and allowing indefinite-length maps and arrays could reduce
   memory requirements.

   It is recommended that implementations that have fundamental
   restrictions on what data fields they can collect SHOULD always store
   hints with the bits unset for those fields, i.e., they unambiguously
   indicate that those data fields will be omitted from captured C-DNS.

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/11.1.%20%20Optional%20Data"></a><a class="selflink" href="#section-11.1" id="section-11.1">11.1</a>.  Optional Data</span>

   When decoding C-DNS data, some of the items required for a particular
   function that the consumer wishes to perform may be missing.
   Consumers should consider providing configurable default values to be
   used in place of the missing values in their output.

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/11.2.%20%20Trailing%20Bytes"></a><a class="selflink" href="#section-11.2" id="section-11.2">11.2</a>.  Trailing Bytes</span>

   A DNS Query message in a UDP or TCP payload can be followed by some
   additional (spurious) bytes, which are not stored in C-DNS.

   When DNS traffic is sent over TCP, each message is prefixed with a
   two-byte length field, which gives the message length, excluding the
   two-byte length field.  In this context, trailing bytes can occur in
   two circumstances, with different results:

   1.  The number of bytes consumed by fully parsing the message is less
       than the number of bytes given in the length field (i.e., the
       length field is incorrect and too large).  In this case, the
       surplus bytes are considered trailing bytes in a manner analogous
       to UDP and recorded as such.  If only this case occurs, it is
       possible to process a packet containing multiple DNS messages
       where one or more have trailing bytes.

   2.  There are surplus bytes between the end of a well-formed message
       and the start of the length field for the next message.  In this
       case, the first of the surplus bytes will be processed as the
       first byte of the next length field, and parsing will proceed
       from there, almost certainly leading to the next and any
       subsequent messages in the packet being considered malformed.
       This will not generate a trailing-bytes record for the processed
       well-formed message.






<span class="grey">Dickinson, et al.            Standards Track                   [Page 48]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-49"></span>
<span class="grey"><a href="./rfc8618">RFC 8618</a>         C-DNS: A Format for DNS Packet Capture   September 2019</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/11.3.%20%20Limiting%20Collection%20of%20RDATA"></a><a class="selflink" href="#section-11.3" id="section-11.3">11.3</a>.  Limiting Collection of RDATA</span>

   Implementations should consider providing a configurable maximum
   RDATA size for captures -- for example, to avoid memory issues when
   confronted with large zone transfer records.

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/11.4.%20%20Timestamps"></a><a class="selflink" href="#section-11.4" id="section-11.4">11.4</a>.  Timestamps</span>

   The preamble to each block includes a timestamp of the earliest
   record in the Block.  As described in <a href="#section-7.3.2.1">Section 7.3.2.1</a>, the timestamp
   is an array of two unsigned integers.  The first is a POSIX "time_t"
   [<a href="#ref-posix-time">posix-time</a>].  Consumers of C-DNS should be aware of this, as it
   excludes leap seconds and therefore may cause minor anomalies in the
   data, e.g., when calculating Query throughput.

<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/12.%20%20IANA%20Considerations"></a><a class="selflink" href="#section-12" id="section-12">12</a>.  IANA Considerations</span>

   IANA has created a registry "C-DNS DNS Capture Format" containing the
   subregistries defined in Sections <a href="#section-12.1">12.1</a> to <a href="#section-12.4">12.4</a> inclusive.

   In all cases, new entries may be added to the subregistries by Expert
   Review as defined in [<a href="./rfc8126" title="">RFC8126</a>].  Experts are expected to exercise
   their own expert judgment and should consider the following general
   guidelines in addition to any provided guidelines that are particular
   to a subregistry.

   o  There should be a real and compelling use for any new value.

   o  Values assigned should be carefully chosen to minimize storage
      requirements for common cases.

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/12.1.%20%20Transport%20Types"></a><a class="selflink" href="#section-12.1" id="section-12.1">12.1</a>.  Transport Types</span>

   IANA has created a registry "C-DNS Transports" of C-DNS transport
   type identifiers.  The primary purpose of this registry is to provide
   unique identifiers for all transports used for DNS Queries.

   The following note is included in this registry: "In version 1.0 of
   C-DNS [<a href="./rfc8618">RFC8618</a>], there is a field to identify the type of DNS
   transport.  This field is 4 bits in size."











<span class="grey">Dickinson, et al.            Standards Track                   [Page 49]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-50"></span>
<span class="grey"><a href="./rfc8618">RFC 8618</a>         C-DNS: A Format for DNS Packet Capture   September 2019</span>


   The initial contents of the registry are as follows.  See
   Sections <a href="#section-7.3.2.3.2">7.3.2.3.2</a>, <a href="#section-7.3.2.3.5">7.3.2.3.5</a>, and <a href="#section-7.3.2.5">7.3.2.5</a> of this document:

            +------------+------------------------+-----------+
            | Identifier | Name                   | Reference |
            +------------+------------------------+-----------+
            |     0      | UDP                    | <a href="./rfc8618">RFC 8618</a>  |
            |     1      | TCP                    | <a href="./rfc8618">RFC 8618</a>  |
            |     2      | TLS                    | <a href="./rfc8618">RFC 8618</a>  |
            |     3      | DTLS                   | <a href="./rfc8618">RFC 8618</a>  |
            |     4      | HTTPS                  | <a href="./rfc8618">RFC 8618</a>  |
            |    5-14    | Unassigned             |           |
            |     15     | Non-standard transport | <a href="./rfc8618">RFC 8618</a>  |
            +------------+------------------------+-----------+

   Expert reviewers should take the following point into consideration:
   Is the requested DNS transport described by a Standards Track RFC?

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/12.2.%20%20Data%20Storage%20Flags"></a><a class="selflink" href="#section-12.2" id="section-12.2">12.2</a>.  Data Storage Flags</span>

   IANA has created a registry "C-DNS Storage Flags" of C-DNS data
   storage flags.  The primary purpose of this registry is to provide
   indicators giving hints on processing of the data stored.

   The following note is included in this registry: "In version 1.0 of
   C-DNS [<a href="./rfc8618">RFC8618</a>], there is a field describing attributes of the data
   recorded.  The field is a CBOR [<a href="./rfc7049" title='"Concise Binary Object Representation (CBOR)"'>RFC7049</a>] unsigned integer holding bit
   flags."

   The initial contents of the registry are as follows.  See
   <a href="#section-7.3.1.1.1">Section 7.3.1.1.1</a> of this document:

   +------+------------------+-----------------------------+-----------+
   | Bit  | Name             | Description                 | Reference |
   +------+------------------+-----------------------------+-----------+
   |  0   | anonymized-data  | The data has been           | <a href="./rfc8618">RFC 8618</a>  |
   |      |                  | anonymized.                 |           |
   |      |                  |                             |           |
   |  1   | sampled-data     | The data is sampled data.   | <a href="./rfc8618">RFC 8618</a>  |
   |      |                  |                             |           |
   |  2   | normalized-names | Names in the data have been | <a href="./rfc8618">RFC 8618</a>  |
   |      |                  | normalized.                 |           |
   |      |                  |                             |           |
   | 3-63 | Unassigned       |                             |           |
   +------+------------------+-----------------------------+-----------+






<span class="grey">Dickinson, et al.            Standards Track                   [Page 50]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-51"></span>
<span class="grey"><a href="./rfc8618">RFC 8618</a>         C-DNS: A Format for DNS Packet Capture   September 2019</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/12.3.%20%20Response-Processing%20Flags"></a><a class="selflink" href="#section-12.3" id="section-12.3">12.3</a>.  Response-Processing Flags</span>

   IANA has created a registry "C-DNS Response Flags" of C-DNS response-
   processing flags.  The primary purpose of this registry is to provide
   indicators giving hints on the generation of a particular Response.

   The following note is included in this registry: "In version 1.0 of
   C-DNS [<a href="./rfc8618">RFC8618</a>], there is a field describing attributes of the
   Responses recorded.  The field is a CBOR [<a href="./rfc7049" title='"Concise Binary Object Representation (CBOR)"'>RFC7049</a>] unsigned integer
   holding bit flags."

   The initial contents of the registry are as follows.  See
   <a href="#section-7.3.2.4.1">Section 7.3.2.4.1</a> of this document:

     +------+------------+-------------------------------+-----------+
     | Bit  | Name       | Description                   | Reference |
     +------+------------+-------------------------------+-----------+
     |  0   | from-cache | The Response came from cache. | <a href="./rfc8618">RFC 8618</a>  |
     | 1-63 | Unassigned |                               |           |
     +------+------------+-------------------------------+-----------+

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/12.4.%20%20AddressEvent%20Types"></a><a class="selflink" href="#section-12.4" id="section-12.4">12.4</a>.  AddressEvent Types</span>

   IANA has created a registry "C-DNS Address Event Types" of C-DNS
   AddressEvent types.  The primary purpose of this registry is to
   provide unique identifiers of different types of C-DNS address events
   and so specify the contents of the optional companion field "ae-code"
   for each type.

   The following note is included in this registry: "In version 1.0 of
   C-DNS [<a href="./rfc8618">RFC8618</a>], there is a field identifying types of the events
   related to client addresses.  This field is a CBOR [<a href="./rfc7049" title='"Concise Binary Object Representation (CBOR)"'>RFC7049</a>] unsigned
   integer.  There is a related optional field "ae-code", which, if
   present, holds an additional CBOR unsigned integer giving additional
   information specific to the event type."
















<span class="grey">Dickinson, et al.            Standards Track                   [Page 51]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-52"></span>
<span class="grey"><a href="./rfc8618">RFC 8618</a>         C-DNS: A Format for DNS Packet Capture   September 2019</span>


   The initial contents of the registry are as follows.  See
   <a href="#section-7.3.2.5">Section 7.3.2.5</a> of this document:

   +------------------------+---------------+--------------+-----------+
   |       Identifier       | Event Type    | ae-code      | Reference |
   |                        |               | Contents     |           |
   +------------------------+---------------+--------------+-----------+
   |           0            | TCP reset     | None         | <a href="./rfc8618">RFC 8618</a>  |
   |                        |               |              |           |
   |           1            | ICMP time     | ICMP code    | <a href="./rfc8618">RFC 8618</a>  |
   |                        | exceeded      | [<a href="#ref-icmpcodes">icmpcodes</a>]  |           |
   |                        |               |              |           |
   |           2            | ICMP          | ICMP code    | <a href="./rfc8618">RFC 8618</a>  |
   |                        | destination   | [<a href="#ref-icmpcodes">icmpcodes</a>]  |           |
   |                        | unreachable   |              |           |
   |                        |               |              |           |
   |           3            | ICMPv6 time   | ICMPv6 code  | <a href="./rfc8618">RFC 8618</a>  |
   |                        | exceeded      | [<a href="#ref-icmp6codes">icmp6codes</a>] |           |
   |                        |               |              |           |
   |           4            | ICMPv6        | ICMPv6 code  | <a href="./rfc8618">RFC 8618</a>  |
   |                        | destination   | [<a href="#ref-icmp6codes">icmp6codes</a>] |           |
   |                        | unreachable   |              |           |
   |                        |               |              |           |
   |           5            | ICMPv6 packet | ICMPv6 code  | <a href="./rfc8618">RFC 8618</a>  |
   |                        | too big       | [<a href="#ref-icmp6codes">icmp6codes</a>] |           |
   |                        |               |              |           |
   | 6-18446744073709551615 | Unassigned    |              |           |
   +------------------------+---------------+--------------+-----------+

   Expert reviewers should take the following point into consideration:
   "ae-code" contents must be defined for a type or, if not appropriate,
   specified as "None".  A specification of "None" requires less storage
   and is therefore preferred.

<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/13.%20%20Security%20Considerations"></a><a class="selflink" href="#section-13" id="section-13">13</a>.  Security Considerations</span>

   Any control interface MUST perform authentication and encryption.

   Any data upload MUST be authenticated and encrypted.

<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/14.%20%20Privacy%20Considerations"></a><a class="selflink" href="#section-14" id="section-14">14</a>.  Privacy Considerations</span>

   Storage of DNS traffic by operators in PCAP and other formats is a
   long-standing and widespread practice.  Section 2.5 of
   [<a href="#ref-DNS-Priv-Cons">DNS-Priv-Cons</a>] provides an analysis of the risks to Internet users
   regarding the storage of DNS traffic data in servers (recursive
   resolvers, authoritative servers, and rogue servers).




<span class="grey">Dickinson, et al.            Standards Track                   [Page 52]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-53"></span>
<span class="grey"><a href="./rfc8618">RFC 8618</a>         C-DNS: A Format for DNS Packet Capture   September 2019</span>


   Section 5.2 of [<a href="#ref-DNS-Priv-Svc">DNS-Priv-Svc</a>] describes mitigations for those risks
   for data stored on recursive resolvers (but that could by extension
   apply to authoritative servers).  These include data-handling
   practices and methods for data minimization, IP address
   pseudonymization, and anonymization.  <a href="#appendix-C">Appendix C</a> of [<a href="#ref-DNS-Priv-Svc">DNS-Priv-Svc</a>]
   presents an analysis of seven published anonymization processes.  In
   addition, the ICANN Root Server System Advisory Committee (RSSAC)
   have recently published [<a href="#ref-RSSAC04" title='"Recommendations on Anonymization Processes for Source IP Addresses Submitted for Future Analysis"'>RSSAC04</a>] ("Recommendations on Anonymization
   Processes for Source IP Addresses Submitted for Future Analysis").

   The above analyses consider full data capture (e.g., using PCAP) as a
   baseline for privacy considerations; therefore, this format
   specification introduces no new user privacy issues beyond those of
   full data capture (which are quite severe).  It does provide
   mechanisms to selectively record only certain fields at the time of
   data capture, to improve user privacy and to explicitly indicate that
   data is sampled, anonymized, or both.  It also provides flags to
   indicate if data normalization has been performed; data normalization
   increases user privacy by reducing the potential for fingerprinting
   individuals.  However, a trade-off is the potential reduction of the
   capacity to identify attack traffic via Query name signatures.
   Operators should carefully consider their operational requirements
   and privacy policies and SHOULD capture at the source the minimum
   user data required to meet their needs.

<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/15.%20%20References"></a><a class="selflink" href="#section-15" id="section-15">15</a>.  References</span>

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/15.1.%20%20Normative%20References"></a><a class="selflink" href="#section-15.1" id="section-15.1">15.1</a>.  Normative References</span>

   [<a id="ref-pcap-filter">pcap-filter</a>]
              tcpdump.org, "Manpage of PCAP-FILTER", November 2017,
              &lt;<a href="https://www.tcpdump.org/manpages/pcap-filter.7.html">https://www.tcpdump.org/manpages/pcap-filter.7.html</a>&gt;.

   [<a id="ref-pcap-options">pcap-options</a>]
              tcpdump.org, "Manpage of PCAP", July 2018,
              &lt;<a href="https://www.tcpdump.org/manpages/pcap.3pcap.html">https://www.tcpdump.org/manpages/pcap.3pcap.html</a>&gt;.

   [<a id="ref-posix-time">posix-time</a>]
              The Open Group, "IEEE Standard for Information
              Technology--Portable Operating System Interface (POSIX(R))
              Base Specifications, Issue 7", IEEE Standard 1003.1-2017,
              <a href="#section-4.16">Section 4.16</a>, DOI 10.1109/IEEESTD.2018.8277153.

   [<a id="ref-RFC792">RFC792</a>]   Postel, J., "Internet Control Message Protocol", STD 5,
              <a href="./rfc792">RFC 792</a>, DOI 10.17487/RFC0792, September 1981,
              &lt;<a href="https://www.rfc-editor.org/info/rfc792">https://www.rfc-editor.org/info/rfc792</a>&gt;.





<span class="grey">Dickinson, et al.            Standards Track                   [Page 53]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-54"></span>
<span class="grey"><a href="./rfc8618">RFC 8618</a>         C-DNS: A Format for DNS Packet Capture   September 2019</span>


   [<a id="ref-RFC1035">RFC1035</a>]  Mockapetris, P., "Domain names - implementation and
              specification", STD 13, <a href="./rfc1035">RFC 1035</a>, DOI 10.17487/RFC1035,
              November 1987, &lt;<a href="https://www.rfc-editor.org/info/rfc1035">https://www.rfc-editor.org/info/rfc1035</a>&gt;.

   [<a id="ref-RFC2119">RFC2119</a>]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", <a href="https://www.rfc-editor.org/bcp/bcp14">BCP 14</a>, <a href="./rfc2119">RFC 2119</a>,
              DOI 10.17487/RFC2119, March 1997,
              &lt;<a href="https://www.rfc-editor.org/info/rfc2119">https://www.rfc-editor.org/info/rfc2119</a>&gt;.

   [<a id="ref-RFC3986">RFC3986</a>]  Berners-Lee, T., Fielding, R., and L. Masinter, "Uniform
              Resource Identifier (URI): Generic Syntax", STD 66,
              <a href="./rfc3986">RFC 3986</a>, DOI 10.17487/RFC3986, January 2005,
              &lt;<a href="https://www.rfc-editor.org/info/rfc3986">https://www.rfc-editor.org/info/rfc3986</a>&gt;.

   [<a id="ref-RFC4443">RFC4443</a>]  Conta, A., Deering, S., and M. Gupta, Ed., "Internet
              Control Message Protocol (ICMPv6) for the Internet
              Protocol Version 6 (IPv6) Specification", STD 89,
              <a href="./rfc4443">RFC 4443</a>, DOI 10.17487/RFC4443, March 2006,
              &lt;<a href="https://www.rfc-editor.org/info/rfc4443">https://www.rfc-editor.org/info/rfc4443</a>&gt;.

   [<a id="ref-RFC6891">RFC6891</a>]  Damas, J., Graff, M., and P. Vixie, "Extension Mechanisms
              for DNS (EDNS(0))", STD 75, <a href="./rfc6891">RFC 6891</a>,
              DOI 10.17487/RFC6891, April 2013,
              &lt;<a href="https://www.rfc-editor.org/info/rfc6891">https://www.rfc-editor.org/info/rfc6891</a>&gt;.

   [<a id="ref-RFC7049">RFC7049</a>]  Bormann, C. and P. Hoffman, "Concise Binary Object
              Representation (CBOR)", <a href="./rfc7049">RFC 7049</a>, DOI 10.17487/RFC7049,
              October 2013, &lt;<a href="https://www.rfc-editor.org/info/rfc7049">https://www.rfc-editor.org/info/rfc7049</a>&gt;.

   [<a id="ref-RFC7858">RFC7858</a>]  Hu, Z., Zhu, L., Heidemann, J., Mankin, A., Wessels, D.,
              and P. Hoffman, "Specification for DNS over Transport
              Layer Security (TLS)", <a href="./rfc7858">RFC 7858</a>, DOI 10.17487/RFC7858,
              May 2016, &lt;<a href="https://www.rfc-editor.org/info/rfc7858">https://www.rfc-editor.org/info/rfc7858</a>&gt;.

   [<a id="ref-RFC8094">RFC8094</a>]  Reddy, T., Wing, D., and P. Patil, "DNS over Datagram
              Transport Layer Security (DTLS)", <a href="./rfc8094">RFC 8094</a>,
              DOI 10.17487/RFC8094, February 2017,
              &lt;<a href="https://www.rfc-editor.org/info/rfc8094">https://www.rfc-editor.org/info/rfc8094</a>&gt;.

   [<a id="ref-RFC8126">RFC8126</a>]  Cotton, M., Leiba, B., and T. Narten, "Guidelines for
              Writing an IANA Considerations Section in RFCs", <a href="https://www.rfc-editor.org/bcp/bcp26">BCP 26</a>,
              <a href="./rfc8126">RFC 8126</a>, DOI 10.17487/RFC8126, June 2017,
              &lt;<a href="https://www.rfc-editor.org/info/rfc8126">https://www.rfc-editor.org/info/rfc8126</a>&gt;.

   [<a id="ref-RFC8174">RFC8174</a>]  Leiba, B., "Ambiguity of Uppercase vs Lowercase in
              <a href="./rfc2119">RFC 2119</a> Key Words", <a href="https://www.rfc-editor.org/bcp/bcp14">BCP 14</a>, <a href="./rfc8174">RFC 8174</a>,
              DOI 10.17487/RFC8174, May 2017,
              &lt;<a href="https://www.rfc-editor.org/info/rfc8174">https://www.rfc-editor.org/info/rfc8174</a>&gt;.



<span class="grey">Dickinson, et al.            Standards Track                   [Page 54]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-55"></span>
<span class="grey"><a href="./rfc8618">RFC 8618</a>         C-DNS: A Format for DNS Packet Capture   September 2019</span>


   [<a id="ref-RFC8484">RFC8484</a>]  Hoffman, P. and P. McManus, "DNS Queries over HTTPS
              (DoH)", <a href="./rfc8484">RFC 8484</a>, DOI 10.17487/RFC8484, October 2018,
              &lt;<a href="https://www.rfc-editor.org/info/rfc8484">https://www.rfc-editor.org/info/rfc8484</a>&gt;.

   [<a id="ref-RFC8610">RFC8610</a>]  Birkholz, H., Vigano, C., and C. Bormann, "Concise Data
              Definition Language (CDDL): A Notational Convention to
              Express Concise Binary Object Representation (CBOR) and
              JSON Data Structures", <a href="./rfc8610">RFC 8610</a>, DOI 10.17487/RFC8610,
              June 2019, &lt;<a href="https://www.rfc-editor.org/info/rfc8610">https://www.rfc-editor.org/info/rfc8610</a>&gt;.

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/15.2.%20%20Informative%20References"></a><a class="selflink" href="#section-15.2" id="section-15.2">15.2</a>.  Informative References</span>

   [<a id="ref-Avro">Avro</a>]     The Apache Software Foundation, "Apache Avro(TM)", 2019,
              &lt;<a href="https://avro.apache.org/">https://avro.apache.org/</a>&gt;.

   [<a id="ref-ditl">ditl</a>]     DNS-OARC, "DITL", 2018,
              &lt;<a href="https://www.dns-oarc.net/oarc/data/ditl">https://www.dns-oarc.net/oarc/data/ditl</a>&gt;.

   [<a id="ref-DNS-Priv-Cons">DNS-Priv-Cons</a>]
              Bortzmeyer, S. and S. Dickinson, "DNS Privacy
              Considerations", Work in Progress,
              <a href="./draft-ietf-dprive-rfc7626-bis-00">draft-ietf-dprive-rfc7626-bis-00</a>, July 2019.

   [<a id="ref-DNS-Priv-Svc">DNS-Priv-Svc</a>]
              Dickinson, S., Overeinder, B., van Rijswijk-Deij, R., and
              A. Mankin, "Recommendations for DNS Privacy Service
              Operators", Work in Progress, <a href="./draft-ietf-dprive-bcp-op-03">draft-ietf-dprive-bcp-op-03</a>,
              July 2019.

   [<a id="ref-dnscap">dnscap</a>]   DNS-OARC, "DNSCAP", 2018,
              &lt;<a href="https://www.dns-oarc.net/tools/dnscap">https://www.dns-oarc.net/tools/dnscap</a>&gt;.

   [<a id="ref-dnstap">dnstap</a>]   "dnstap", 2016, &lt;<a href="https://dnstap.info/">https://dnstap.info/</a>&gt;.

   [<a id="ref-dnstap-schema">dnstap-schema</a>]
              "dnstap schema", commit d860ec1, November 2016,
              &lt;<a href="https://github.com/dnstap/dnstap.pb/blob/master/dnstap.proto">https://github.com/dnstap/dnstap.pb/blob/master/</a>
              <a href="https://github.com/dnstap/dnstap.pb/blob/master/dnstap.proto">dnstap.proto</a>&gt;.

   [<a id="ref-dnsxml">dnsxml</a>]   Daley, J., Ed., Morris, S., and J. Dickinson, "dnsxml - A
              standard XML representation of DNS data", Work in
              Progress, <a href="./draft-daley-dnsxml-00">draft-daley-dnsxml-00</a>, July 2013.

   [<a id="ref-dsc">dsc</a>]      Wessels, D. and J. Lundstrom, "DSC", 2016,
              &lt;<a href="https://www.dns-oarc.net/tools/dsc">https://www.dns-oarc.net/tools/dsc</a>&gt;.

   [<a id="ref-gzip">gzip</a>]     "gzip", &lt;<a href="https://www.gzip.org/">https://www.gzip.org/</a>&gt;.




<span class="grey">Dickinson, et al.            Standards Track                   [Page 55]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-56"></span>
<span class="grey"><a href="./rfc8618">RFC 8618</a>         C-DNS: A Format for DNS Packet Capture   September 2019</span>


   [<a id="ref-icmp6codes">icmp6codes</a>]
              IANA, "ICMPv6 "Code" Fields",
              &lt;<a href="https://www.iana.org/assignments/icmpv6-parameters/">https://www.iana.org/assignments/icmpv6-parameters/</a>&gt;.

   [<a id="ref-icmpcodes">icmpcodes</a>]
              IANA, "Code Fields",
              &lt;<a href="https://www.iana.org/assignments/icmp-parameters/">https://www.iana.org/assignments/icmp-parameters/</a>&gt;.

   [<a id="ref-IEEE802.1Q">IEEE802.1Q</a>]
              IEEE, "IEEE Standard for Local and Metropolitan Area
              Networks--Bridges and Bridged Networks", IEEE
              Standard 802.1Q.

   [<a id="ref-Knot">Knot</a>]     "Knot DNS", &lt;<a href="https://www.knot-dns.cz/">https://www.knot-dns.cz/</a>&gt;.

   [<a id="ref-lz4">lz4</a>]      "LZ4", &lt;<a href="https://lz4.github.io/lz4/">https://lz4.github.io/lz4/</a>&gt;.

   [<a id="ref-mmark">mmark</a>]    Gieben, M., "mmark", commit de69698, May 2019,
              &lt;<a href="https://github.com/mmarkdown/mmark">https://github.com/mmarkdown/mmark</a>&gt;.

   [<a id="ref-NSD">NSD</a>]      NLnet Labs, "NSD", 2019,
              &lt;<a href="https://www.nlnetlabs.nl/projects/nsd/about/">https://www.nlnetlabs.nl/projects/nsd/about/</a>&gt;.

   [<a id="ref-opcodes">opcodes</a>]  IANA, "DNS OpCodes",
              &lt;<a href="https://www.iana.org/assignments/dns-parameters/">https://www.iana.org/assignments/dns-parameters/</a>&gt;.

   [<a id="ref-packetq">packetq</a>]  .SE - The Internet Infrastructure Foundation, "PacketQ",
              commit c9b2e89, February 2019,
              &lt;<a href="https://github.com/DNS-OARC/PacketQ">https://github.com/DNS-OARC/PacketQ</a>&gt;.

   [<a id="ref-pcap">pcap</a>]     "PCAP", 2019, &lt;<a href="https://www.tcpdump.org/">https://www.tcpdump.org/</a>&gt;.

   [<a id="ref-pcapng">pcapng</a>]   "pcapng: PCAP next generation file format specification",
              commit 3c35b6a, March 2019,
              &lt;<a href="https://github.com/pcapng/pcapng">https://github.com/pcapng/pcapng</a>&gt;.

   [<a id="ref-Protocol-Buffers">Protocol-Buffers</a>]
              Google LLC, "Protocol Buffers",
              &lt;<a href="https://developers.google.com/protocol-buffers/">https://developers.google.com/protocol-buffers/</a>&gt;.

   [<a id="ref-rcodes">rcodes</a>]   IANA, "DNS RCODEs",
              &lt;<a href="https://www.iana.org/assignments/dns-parameters/">https://www.iana.org/assignments/dns-parameters/</a>&gt;.

   [<a id="ref-RFC5077">RFC5077</a>]  Salowey, J., Zhou, H., Eronen, P., and H. Tschofenig,
              "Transport Layer Security (TLS) Session Resumption without
              Server-Side State", <a href="./rfc5077">RFC 5077</a>, DOI 10.17487/RFC5077,
              January 2008, &lt;<a href="https://www.rfc-editor.org/info/rfc5077">https://www.rfc-editor.org/info/rfc5077</a>&gt;.




<span class="grey">Dickinson, et al.            Standards Track                   [Page 56]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-57"></span>
<span class="grey"><a href="./rfc8618">RFC 8618</a>         C-DNS: A Format for DNS Packet Capture   September 2019</span>


   [<a id="ref-RFC7413">RFC7413</a>]  Cheng, Y., Chu, J., Radhakrishnan, S., and A. Jain, "TCP
              Fast Open", <a href="./rfc7413">RFC 7413</a>, DOI 10.17487/RFC7413, December 2014,
              &lt;<a href="https://www.rfc-editor.org/info/rfc7413">https://www.rfc-editor.org/info/rfc7413</a>&gt;.

   [<a id="ref-RFC8259">RFC8259</a>]  Bray, T., Ed., "The JavaScript Object Notation (JSON) Data
              Interchange Format", STD 90, <a href="./rfc8259">RFC 8259</a>,
              DOI 10.17487/RFC8259, December 2017,
              &lt;<a href="https://www.rfc-editor.org/info/rfc8259">https://www.rfc-editor.org/info/rfc8259</a>&gt;.

   [<a id="ref-RFC8427">RFC8427</a>]  Hoffman, P., "Representing DNS Messages in JSON",
              <a href="./rfc8427">RFC 8427</a>, DOI 10.17487/RFC8427, July 2018,
              &lt;<a href="https://www.rfc-editor.org/info/rfc8427">https://www.rfc-editor.org/info/rfc8427</a>&gt;.

   [<a id="ref-rrclasses">rrclasses</a>]
              IANA, "DNS CLASSes",
              &lt;<a href="https://www.iana.org/assignments/dns-parameters/">https://www.iana.org/assignments/dns-parameters/</a>&gt;.

   [<a id="ref-rrtypes">rrtypes</a>]  IANA, "Resource Record (RR) TYPEs",
              &lt;<a href="https://www.iana.org/assignments/dns-parameters/">https://www.iana.org/assignments/dns-parameters/</a>&gt;.

   [<a id="ref-RSSAC04">RSSAC04</a>]  ICANN, "Recommendations on Anonymization Processes for
              Source IP Addresses Submitted for Future Analysis",
              August 2018, &lt;<a href="https://www.icann.org/en/system/files/files/rssac-040-07aug18-en.pdf">https://www.icann.org/en/system/files/files/</a>
              <a href="https://www.icann.org/en/system/files/files/rssac-040-07aug18-en.pdf">rssac-040-07aug18-en.pdf</a>&gt;.

   [<a id="ref-snappy">snappy</a>]   "snappy", &lt;<a href="https://google.github.io/snappy/">https://google.github.io/snappy/</a>&gt;.

   [<a id="ref-snzip">snzip</a>]    "Snzip, a compression/decompression tool based on snappy",
              commit 809c6f2, October 2018,
              &lt;<a href="https://github.com/kubo/snzip">https://github.com/kubo/snzip</a>&gt;.

   [<a id="ref-xz">xz</a>]       "XZ Utils", &lt;<a href="https://tukaani.org/xz/">https://tukaani.org/xz/</a>&gt;.

   [<a id="ref-zstd">zstd</a>]     "Zstandard - Real-time data compression algorithm",
              &lt;<a href="https://facebook.github.io/zstd/">https://facebook.github.io/zstd/</a>&gt;.
















<span class="grey">Dickinson, et al.            Standards Track                   [Page 57]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-58"></span>
<span class="grey"><a href="./rfc8618">RFC 8618</a>         C-DNS: A Format for DNS Packet Capture   September 2019</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/Appendix%20A.%20%20CDDL"></a><a class="selflink" href="#appendix-A" id="appendix-A">Appendix A</a>.  CDDL</span>

   This appendix gives a CDDL [<a href="./rfc8610" title='"Concise Data Definition Language (CDDL): A Notational Convention to Express Concise Binary Object Representation (CBOR) and JSON Data Structures"'>RFC8610</a>] specification for C-DNS.

   CDDL does not permit a range of allowed values to be specified for a
   bitfield.  Where necessary, those values are given as a CDDL group,
   but the group definition is commented out to prevent CDDL tooling
   from warning that the group is unused.

   ; CDDL specification of the file format for C-DNS,
   ; which describes a collection of DNS messages and
   ; traffic metadata.

   ;
   ; The overall structure of a file.
   ;
   File = [
       file-type-id  : "C-DNS",
       file-preamble : FilePreamble,
       file-blocks   : [* Block],
   ]

   ;
   ; The File Preamble.
   ;
   FilePreamble = {
       major-format-version =&gt; 1,
       minor-format-version =&gt; 0,
       ? private-version    =&gt; uint,
       block-parameters     =&gt; [+ BlockParameters],
   }
   major-format-version = 0
   minor-format-version = 1
   private-version      = 2
   block-parameters     = 3

   BlockParameters = {
       storage-parameters      =&gt; StorageParameters,
       ? collection-parameters =&gt; CollectionParameters,
   }
   storage-parameters    = 0
   collection-parameters = 1

     IPv6PrefixLength = 1..128
     IPv4PrefixLength = 1..32
     OpcodeRange = 0..15
     RRTypeRange = 0..65535




<span class="grey">Dickinson, et al.            Standards Track                   [Page 58]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-59"></span>
<span class="grey"><a href="./rfc8618">RFC 8618</a>         C-DNS: A Format for DNS Packet Capture   September 2019</span>


     StorageParameters = {
         ticks-per-second             =&gt; uint,
         max-block-items              =&gt; uint,
         storage-hints                =&gt; StorageHints,
         opcodes                      =&gt; [+ OpcodeRange],
         rr-types                     =&gt; [+ RRTypeRange],
         ? storage-flags              =&gt; StorageFlags,
         ? client-address-prefix-ipv4 =&gt; IPv4PrefixLength,
         ? client-address-prefix-ipv6 =&gt; IPv6PrefixLength,
         ? server-address-prefix-ipv4 =&gt; IPv4PrefixLength,
         ? server-address-prefix-ipv6 =&gt; IPv6PrefixLength,
         ? sampling-method            =&gt; tstr,
         ? anonymization-method       =&gt; tstr,
     }
     ticks-per-second           = 0
     max-block-items            = 1
     storage-hints              = 2
     opcodes                    = 3
     rr-types                   = 4
     storage-flags              = 5
     client-address-prefix-ipv4 = 6
     client-address-prefix-ipv6 = 7
     server-address-prefix-ipv4 = 8
     server-address-prefix-ipv6 = 9
     sampling-method            = 10
     anonymization-method       = 11

       ; A hint indicates whether the collection method will always omit
       ; the item from the file.
       StorageHints = {
           query-response-hints           =&gt; QueryResponseHints,
           query-response-signature-hints =&gt;
               QueryResponseSignatureHints,
           rr-hints                       =&gt; RRHints,
           other-data-hints               =&gt; OtherDataHints,
       }
       query-response-hints           = 0
       query-response-signature-hints = 1
       rr-hints                       = 2
       other-data-hints               = 3

         QueryResponseHintValues = &amp;(
             time-offset                  : 0,
             client-address-index         : 1,
             client-port                  : 2,
             transaction-id               : 3,
             qr-signature-index           : 4,
             client-hoplimit              : 5,



<span class="grey">Dickinson, et al.            Standards Track                   [Page 59]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-60"></span>
<span class="grey"><a href="./rfc8618">RFC 8618</a>         C-DNS: A Format for DNS Packet Capture   September 2019</span>


             response-delay               : 6,
             query-name-index             : 7,
             query-size                   : 8,
             response-size                : 9,
             response-processing-data     : 10,
             query-question-sections      : 11,    ; Second &amp; subsequent
                                                   ; Questions
             query-answer-sections        : 12,
             query-authority-sections     : 13,
             query-additional-sections    : 14,
             response-answer-sections     : 15,
             response-authority-sections  : 16,
             response-additional-sections : 17,
         )
         QueryResponseHints = uint .bits QueryResponseHintValues

         QueryResponseSignatureHintValues = &amp;(
             server-address-index  : 0,
             server-port           : 1,
             qr-transport-flags    : 2,
             qr-type               : 3,
             qr-sig-flags          : 4,
             query-opcode          : 5,
             qr-dns-flags          : 6,
             query-rcode           : 7,
             query-classtype-index : 8,
             query-qdcount         : 9,
             query-ancount         : 10,
             query-nscount         : 11,
             query-arcount         : 12,
             query-edns-version    : 13,
             query-udp-size        : 14,
             query-opt-rdata-index : 15,
             response-rcode        : 16,
         )
         QueryResponseSignatureHints =
             uint .bits QueryResponseSignatureHintValues

         RRHintValues = &amp;(
             ttl         : 0,
             rdata-index : 1,
         )
         RRHints = uint .bits RRHintValues

         OtherDataHintValues = &amp;(
             malformed-messages   : 0,
             address-event-counts : 1,
         )



<span class="grey">Dickinson, et al.            Standards Track                   [Page 60]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-61"></span>
<span class="grey"><a href="./rfc8618">RFC 8618</a>         C-DNS: A Format for DNS Packet Capture   September 2019</span>


         OtherDataHints = uint .bits OtherDataHintValues

       StorageFlagValues = &amp;(
           anonymized-data      : 0,
           sampled-data         : 1,
           normalized-names     : 2,
       )
       StorageFlags = uint .bits StorageFlagValues

    ; Metadata about data collection
    VLANIdRange = 1..4094

    CollectionParameters = {
         ? query-timeout      =&gt; uint,             ; Milliseconds
         ? skew-timeout       =&gt; uint,             ; Microseconds
         ? snaplen            =&gt; uint,
         ? promisc            =&gt; bool,
         ? interfaces         =&gt; [+ tstr],
         ? server-addresses   =&gt; [+ IPAddress],
         ? vlan-ids           =&gt; [+ VLANIdRange],
         ? filter             =&gt; tstr,
         ? generator-id       =&gt; tstr,
         ? host-id            =&gt; tstr,
     }
     query-timeout      = 0
     skew-timeout       = 1
     snaplen            = 2
     promisc            = 3
     interfaces         = 4
     server-addresses   = 5
     vlan-ids           = 6
     filter             = 7
     generator-id       = 8
     host-id            = 9

   ;
   ; Data in the file is stored in Blocks.
   ;
   Block = {
       block-preamble          =&gt; BlockPreamble,
       ? block-statistics      =&gt; BlockStatistics, ; Much of this
                                                   ; could be derived
       ? block-tables          =&gt; BlockTables,
       ? query-responses       =&gt; [+ QueryResponse],
       ? address-event-counts  =&gt; [+ AddressEventCount],
       ? malformed-messages    =&gt; [+ MalformedMessage],
   }




<span class="grey">Dickinson, et al.            Standards Track                   [Page 61]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-62"></span>
<span class="grey"><a href="./rfc8618">RFC 8618</a>         C-DNS: A Format for DNS Packet Capture   September 2019</span>


   block-preamble        = 0
   block-statistics      = 1
   block-tables          = 2
   query-responses       = 3
   address-event-counts  = 4
   malformed-messages    = 5

   ;
   ; The (mandatory) preamble to a Block.
   ;
   BlockPreamble = {
       ? earliest-time          =&gt; Timestamp,
       ? block-parameters-index =&gt; uint .default 0,
   }
   earliest-time          = 0
   block-parameters-index = 1

   ; Ticks are sub-second intervals.  The number of ticks in a second is
   ; file/block metadata.  Signed and unsigned tick types are defined.
   ticks = int
   uticks = uint

   Timestamp = [
       timestamp-secs   : uint,      ; POSIX time
       timestamp-ticks  : uticks,
   ]

   ;
   ; Statistics about the Block contents.
   ;
   BlockStatistics = {
       ? processed-messages  =&gt; uint,
       ? qr-data-items       =&gt; uint,
       ? unmatched-queries   =&gt; uint,
       ? unmatched-responses =&gt; uint,
       ? discarded-opcode    =&gt; uint,
       ? malformed-items     =&gt; uint,
   }
   processed-messages  = 0
   qr-data-items       = 1
   unmatched-queries   = 2
   unmatched-responses = 3
   discarded-opcode    = 4
   malformed-items     = 5







<span class="grey">Dickinson, et al.            Standards Track                   [Page 62]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-63"></span>
<span class="grey"><a href="./rfc8618">RFC 8618</a>         C-DNS: A Format for DNS Packet Capture   September 2019</span>


   ;
   ; Tables of common data referenced from records in a Block.
   ;
   BlockTables = {
       ? ip-address             =&gt; [+ IPAddress],
       ? classtype              =&gt; [+ ClassType],
       ? name-rdata             =&gt; [+ bstr],    ; Holds both names
                                                ; and RDATA
       ? qr-sig                 =&gt; [+ QueryResponseSignature],
       ? QuestionTables,
       ? RRTables,
       ? malformed-message-data =&gt; [+ MalformedMessageData],
   }
   ip-address             = 0
   classtype              = 1
   name-rdata             = 2
   qr-sig                 = 3
   qlist                  = 4
   qrr                    = 5
   rrlist                 = 6
   rr                     = 7
   malformed-message-data = 8

   IPv4Address = bstr .size (0..4)
   IPv6Address = bstr .size (0..16)
   IPAddress = IPv4Address / IPv6Address

   ClassType = {
       type  =&gt; uint,
       class =&gt; uint,
   }
   type  = 0
   class = 1

   QueryResponseSignature = {
       ? server-address-index  =&gt; uint,
       ? server-port           =&gt; uint,
       ? qr-transport-flags    =&gt; QueryResponseTransportFlags,
       ? qr-type               =&gt; QueryResponseType,
       ? qr-sig-flags          =&gt; QueryResponseFlags,
       ? query-opcode          =&gt; uint,
       ? qr-dns-flags          =&gt; DNSFlags,
       ? query-rcode           =&gt; uint,
       ? query-classtype-index =&gt; uint,
       ? query-qdcount         =&gt; uint,
       ? query-ancount         =&gt; uint,
       ? query-nscount         =&gt; uint,
       ? query-arcount         =&gt; uint,



<span class="grey">Dickinson, et al.            Standards Track                   [Page 63]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-64"></span>
<span class="grey"><a href="./rfc8618">RFC 8618</a>         C-DNS: A Format for DNS Packet Capture   September 2019</span>


       ? query-edns-version    =&gt; uint,
       ? query-udp-size        =&gt; uint,
       ? query-opt-rdata-index =&gt; uint,
       ? response-rcode        =&gt; uint,
   }
   server-address-index  = 0
   server-port           = 1
   qr-transport-flags    = 2
   qr-type               = 3
   qr-sig-flags          = 4
   query-opcode          = 5
   qr-dns-flags          = 6
   query-rcode           = 7
   query-classtype-index = 8
   query-qdcount         = 9
   query-ancount         = 10
   query-nscount         = 11
   query-arcount         = 12
   query-edns-version    = 13
   query-udp-size        = 14
   query-opt-rdata-index = 15
   response-rcode        = 16

     ; Transport gives the values that may appear in bits 1..4 of
     ; TransportFlags.  There is currently no way to express this in
     ; CDDL, so Transport is unused.  To avoid confusion when used
     ; with CDDL tools, it is commented out.
     ;
     ; Transport = &amp;(
     ;     udp               : 0,
     ;     tcp               : 1,
     ;     tls               : 2,
     ;     dtls              : 3,
     ;     https             : 4,
     ;     non-standard      : 15,
     ; )

     TransportFlagValues = &amp;(
         ip-version         : 0,     ; 0=IPv4, 1=IPv6
     ) / (1..4)
     TransportFlags = uint .bits TransportFlagValues

     QueryResponseTransportFlagValues = &amp;(
         query-trailingdata : 5,
     ) / TransportFlagValues
     QueryResponseTransportFlags =
         uint .bits QueryResponseTransportFlagValues




<span class="grey">Dickinson, et al.            Standards Track                   [Page 64]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-65"></span>
<span class="grey"><a href="./rfc8618">RFC 8618</a>         C-DNS: A Format for DNS Packet Capture   September 2019</span>


     QueryResponseType = &amp;(
         stub      : 0,
         client    : 1,
         resolver  : 2,
         auth      : 3,
         forwarder : 4,
         tool      : 5,
     )

     QueryResponseFlagValues = &amp;(
         has-query               : 0,
         has-response            : 1,
         query-has-opt           : 2,
         response-has-opt        : 3,
         query-has-no-question   : 4,
         response-has-no-question: 5,
     )
     QueryResponseFlags = uint .bits QueryResponseFlagValues

     DNSFlagValues = &amp;(
         query-cd   : 0,
         query-ad   : 1,
         query-z    : 2,
         query-ra   : 3,
         query-rd   : 4,
         query-tc   : 5,
         query-aa   : 6,
         query-do   : 7,
         response-cd: 8,
         response-ad: 9,
         response-z : 10,
         response-ra: 11,
         response-rd: 12,
         response-tc: 13,
         response-aa: 14,
     )
     DNSFlags = uint .bits DNSFlagValues














<span class="grey">Dickinson, et al.            Standards Track                   [Page 65]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-66"></span>
<span class="grey"><a href="./rfc8618">RFC 8618</a>         C-DNS: A Format for DNS Packet Capture   September 2019</span>


   QuestionTables = (
       qlist =&gt; [+ QuestionList],
       qrr   =&gt; [+ Question]
   )

     QuestionList = [+ uint]           ; Index of Question

     Question = {                      ; Second and subsequent Questions
         name-index      =&gt; uint,      ; Index to a name in the
                                       ; name-rdata table
         classtype-index =&gt; uint,
     }
     name-index      = 0
     classtype-index = 1

   RRTables = (
       rrlist =&gt; [+ RRList],
       rr     =&gt; [+ RR]
   )

     RRList = [+ uint]                     ; Index of RR

     RR = {
         name-index      =&gt; uint,          ; Index to a name in the
                                           ; name-rdata table
         classtype-index =&gt; uint,
         ? ttl           =&gt; uint,
         ? rdata-index   =&gt; uint,          ; Index to RDATA in the
                                           ; name-rdata table
     }
     ; Other map key values already defined above.
     ttl         = 2
     rdata-index = 3

   MalformedMessageData = {
       ? server-address-index   =&gt; uint,
       ? server-port            =&gt; uint,
       ? mm-transport-flags     =&gt; TransportFlags,
       ? mm-payload             =&gt; bstr,
   }
   ; Other map key values already defined above.
   mm-transport-flags      = 2
   mm-payload              = 3








<span class="grey">Dickinson, et al.            Standards Track                   [Page 66]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-67"></span>
<span class="grey"><a href="./rfc8618">RFC 8618</a>         C-DNS: A Format for DNS Packet Capture   September 2019</span>


   ;
   ; A single Query/Response data item.
   ;
   QueryResponse = {
       ? time-offset              =&gt; uticks,     ; Time offset from
                                                 ; start of Block
       ? client-address-index     =&gt; uint,
       ? client-port              =&gt; uint,
       ? transaction-id           =&gt; uint,
       ? qr-signature-index       =&gt; uint,
       ? client-hoplimit          =&gt; uint,
       ? response-delay           =&gt; ticks,
       ? query-name-index         =&gt; uint,
       ? query-size               =&gt; uint,       ; DNS size of Query
       ? response-size            =&gt; uint,       ; DNS size of Response
       ? response-processing-data =&gt; ResponseProcessingData,
       ? query-extended           =&gt; QueryResponseExtended,
       ? response-extended        =&gt; QueryResponseExtended,
   }
   time-offset              = 0
   client-address-index     = 1
   client-port              = 2
   transaction-id           = 3
   qr-signature-index       = 4
   client-hoplimit          = 5
   response-delay           = 6
   query-name-index         = 7
   query-size               = 8
   response-size            = 9
   response-processing-data = 10
   query-extended           = 11
   response-extended        = 12

   ResponseProcessingData = {
       ? bailiwick-index  =&gt; uint,
       ? processing-flags =&gt; ResponseProcessingFlags,
   }
   bailiwick-index = 0
   processing-flags = 1

     ResponseProcessingFlagValues = &amp;(
         from-cache : 0,
     )
     ResponseProcessingFlags = uint .bits ResponseProcessingFlagValues







<span class="grey">Dickinson, et al.            Standards Track                   [Page 67]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-68"></span>
<span class="grey"><a href="./rfc8618">RFC 8618</a>         C-DNS: A Format for DNS Packet Capture   September 2019</span>


   QueryResponseExtended = {
       ? question-index   =&gt; uint,       ; Index of QuestionList
       ? answer-index     =&gt; uint,       ; Index of RRList
       ? authority-index  =&gt; uint,
       ? additional-index =&gt; uint,
   }
   question-index   = 0
   answer-index     = 1
   authority-index  = 2
   additional-index = 3

   ;
   ; Address event data.
   ;
   AddressEventCount = {
       ae-type              =&gt; &amp;AddressEventType,
       ? ae-code            =&gt; uint,
       ae-address-index     =&gt; uint,
       ? ae-transport-flags =&gt; TransportFlags,
       ae-count             =&gt; uint,
   }
   ae-type            = 0
   ae-code            = 1
   ae-address-index   = 2
   ae-transport-flags = 3
   ae-count           = 4

   AddressEventType = (
       tcp-reset              : 0,
       icmp-time-exceeded     : 1,
       icmp-dest-unreachable  : 2,
       icmpv6-time-exceeded   : 3,
       icmpv6-dest-unreachable: 4,
       icmpv6-packet-too-big  : 5,
   )

   ;
   ; Malformed messages.
   ;
   MalformedMessage = {
       ? time-offset           =&gt; uticks,   ; Time offset from
                                            ; start of Block
       ? client-address-index  =&gt; uint,
       ? client-port           =&gt; uint,
       ? message-data-index    =&gt; uint,
   }
   ; Other map key values already defined above.
   message-data-index = 3



<span class="grey">Dickinson, et al.            Standards Track                   [Page 68]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-69"></span>
<span class="grey"><a href="./rfc8618">RFC 8618</a>         C-DNS: A Format for DNS Packet Capture   September 2019</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/Appendix%20B.%20%20DNS%20Name%20Compression%20Example"></a><a class="selflink" href="#appendix-B" id="appendix-B">Appendix B</a>.  DNS Name Compression Example</span>

   The basic algorithm, which follows the guidance in [<a href="./rfc1035" title='"Domain names - implementation and specification"'>RFC1035</a>], is
   simply to collect each name, and the offset in the packet at which it
   starts, during packet construction.  As each name is added, it is
   offered to each of the collected names in order of collection,
   starting from the first name.  If (1) labels at the end of the name
   can be replaced with a reference back to part (or all) of the earlier
   name and (2) the uncompressed part of the name is shorter than any
   compression already found, the earlier name is noted as the
   compression target for the name.

   The following tables illustrate the step-by-step process of adding
   names and performing name compression.  In an example packet, the
   first name added is foo.example, which cannot be compressed.

          +---+-------------+--------------+--------------------+
          | N | Name        | Uncompressed | Compression Target |
          +---+-------------+--------------+--------------------+
          | 1 | foo.example | foo.example  | None               |
          +---+-------------+--------------+--------------------+

   The next name added is bar.example.  This is matched against
   foo.example.  The example part of this can be used as a compression
   target, with the remaining uncompressed part of the name being bar.

        +---+-------------+--------------+-----------------------+
        | N | Name        | Uncompressed | Compression Target    |
        +---+-------------+--------------+-----------------------+
        | 1 | foo.example | foo.example  | None                  |
        | 2 | bar.example | bar          | 1 + offset to example |
        +---+-------------+--------------+-----------------------+

   The third name added is www.bar.example.  This is first matched
   against foo.example, and as before this is recorded as a compression
   target, with the remaining uncompressed part of the name being
   www.bar.  It is then matched against the second name, which again can
   be a compression target.  Because the remaining uncompressed part of
   the name is www, this is an improved compression, and so it is
   adopted.

      +---+-----------------+--------------+-----------------------+
      | N | Name            | Uncompressed | Compression Target    |
      +---+-----------------+--------------+-----------------------+
      | 1 | foo.example     | foo.example  | None                  |
      | 2 | bar.example     | bar          | 1 + offset to example |
      | 3 | www.bar.example | www          | 2                     |
      +---+-----------------+--------------+-----------------------+



<span class="grey">Dickinson, et al.            Standards Track                   [Page 69]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-70"></span>
<span class="grey"><a href="./rfc8618">RFC 8618</a>         C-DNS: A Format for DNS Packet Capture   September 2019</span>


   As an optimization, if a name is already perfectly compressed (in
   other words, the uncompressed part of the name is empty), then no
   further names will be considered for compression.

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/B.1.%20%20NSD%20Compression%20Algorithm"></a><a class="selflink" href="#appendix-B.1" id="appendix-B.1">B.1</a>.  NSD Compression Algorithm</span>

   Using the above basic algorithm, the packet lengths of Responses
   generated by the Name Server Daemon (NSD) [<a href="#ref-NSD" title='"NSD"'>NSD</a>] can be matched almost
   exactly.  At the time of writing, a tiny number (&lt;.01%) of the
   reconstructed packets had incorrect lengths.

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/B.2.%20%20Knot%20Authoritative%20Compression%20Algorithm"></a><a class="selflink" href="#appendix-B.2" id="appendix-B.2">B.2</a>.  Knot Authoritative Compression Algorithm</span>

   The Knot Authoritative name server [<a href="#ref-Knot" title='"Knot DNS"'>Knot</a>] uses different compression
   behavior, which is the result of internal optimization designed to
   balance runtime speed with compression size gains.  In brief, and
   omitting complications, Knot Authoritative will only consider the
   QNAME and names in the immediately preceding RR section in an RRSET
   as compression targets.

   A set of smart heuristics as described below can be implemented to
   mimic this, and while not perfect, it produces output nearly, but not
   quite, as good a match as with NSD.  The heuristics are as follows:

   1.  A match is only perfect if the name is completely compressed AND
       the TYPE of the section in which the name occurs matches the TYPE
       of the name used as the compression target.

   2.  If the name occurs in RDATA:

       *  If the compression target name is in a Query, then only the
          first RR in an RRSET can use that name as a compression
          target.

       *  The compression target name MUST be in RDATA.

       *  The name section TYPE must match the compression target name
          section TYPE.

       *  The compression target name MUST be in the immediately
          preceding RR in the RRSET.

   Using this algorithm, less than 0.1% of the reconstructed packets had
   incorrect lengths.







<span class="grey">Dickinson, et al.            Standards Track                   [Page 70]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-71"></span>
<span class="grey"><a href="./rfc8618">RFC 8618</a>         C-DNS: A Format for DNS Packet Capture   September 2019</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/B.3.%20%20Observed%20Differences"></a><a class="selflink" href="#appendix-B.3" id="appendix-B.3">B.3</a>.  Observed Differences</span>

   In sample traffic collected on a root name server, around 2-4% of
   Responses generated by Knot had different packet lengths than those
   produced by NSD.

<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/Appendix%20C.%20%20Comparison%20of%20Binary%20Formats"></a><a class="selflink" href="#appendix-C" id="appendix-C">Appendix C</a>.  Comparison of Binary Formats</span>

   Several binary serialization formats were considered.  For
   completeness, they were also compared to JSON.

   o  Apache Avro [<a href="#ref-Avro" title='"Apache Avro(TM)"'>Avro</a>].  Data is stored according to a predefined
      schema.  The schema itself is always included in the data file.
      Data can therefore be stored untagged, for a smaller serialization
      size, and be written and read by an Avro library.

      *  At the time of writing, Avro libraries are available for C,
         C++, C#, Java, Python, Ruby, and PHP.  Optionally, tools are
         available for C++, Java, and C# to generate code for encoding
         and decoding.

   o  Google Protocol Buffers [<a href="#ref-Protocol-Buffers">Protocol-Buffers</a>].  Data is stored
      according to a predefined schema.  The schema is used by a
      generator to generate code for encoding and decoding the data.
      Data can therefore be stored untagged, for a smaller serialization
      size.  The schema is not stored with the data, so unlike Avro, it
      cannot be read with a generic library.

      *  Code must be generated for a particular data schema to read and
         write data using that schema.  At the time of writing, the
         Google code generator can currently generate code for encoding
         and decoding a schema for C++, Go, Java, Python, Ruby, C#,
         Objective-C, JavaScript, and PHP.

   o  CBOR [<a href="./rfc7049" title='"Concise Binary Object Representation (CBOR)"'>RFC7049</a>].  This serialization format is comparable to JSON
      but with a binary representation.  It does not use a predefined
      schema, so data is always stored tagged.  However, CBOR data
      schemas can be described using CDDL [<a href="./rfc8610" title='"Concise Data Definition Language (CDDL): A Notational Convention to Express Concise Binary Object Representation (CBOR) and JSON Data Structures"'>RFC8610</a>], and tools exist to
      verify that data files conform to the schema.

      *  CBOR is a simple format and is simple to implement.  At the
         time of writing, the CBOR website lists implementations for 16
         languages.








<span class="grey">Dickinson, et al.            Standards Track                   [Page 71]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-72"></span>
<span class="grey"><a href="./rfc8618">RFC 8618</a>         C-DNS: A Format for DNS Packet Capture   September 2019</span>


   Avro and Protocol Buffers both allow storage of untagged data, but
   because they rely on the data schema for this, their implementation
   is considerably more complex than CBOR.  Using Avro or Protocol
   Buffers in an unsupported environment would require notably greater
   development effort compared to CBOR.

   A test program was written that reads input from a PCAP file and
   writes output using one of two basic structures: either a simple
   structure, where each Query/Response pair is represented in a single
   record entry, or the C-DNS block structure.

   The resulting output files were then compressed using a variety of
   common general-purpose lossless compression tools to explore the
   compressibility of the formats.  The compression tools employed were:

   o  snzip [<a href="#ref-snzip" title='"Snzip, a compression/decompression tool based on snappy"'>snzip</a>].  A command-line compression tool based on the
      Google Snappy library [<a href="#ref-snappy" title='"snappy"'>snappy</a>].

   o  lz4 [<a href="#ref-lz4" title='"LZ4"'>lz4</a>].  The command-line compression tool from the reference C
      LZ4 implementation.

   o  gzip [<a href="#ref-gzip" title='"gzip"'>gzip</a>].  The ubiquitous GNU zip tool.

   o  zstd [<a href="#ref-zstd" title='"Zstandard - Real-time data compression algorithm"'>zstd</a>].  Compression using the Zstandard algorithm.

   o  xz [<a href="#ref-xz" title='"XZ Utils"'>xz</a>].  A popular compression tool noted for high compression.

   In all cases, the compression tools were run using their default
   settings.

   Note that this document does not mandate the use of compression, nor
   any particular compression scheme, but it anticipates that in
   practice output data will be subject to general-purpose compression,
   and so this should be taken into consideration.

   "test.pcap", a 662 MB capture of sample data from a root instance,
   was used for the comparison.  The following table shows the formatted
   size and size after compression (abbreviated to Comp. in the table
   headers), together with the task Resident Set Size (RSS) and the user
   time taken by the compression.  File sizes are in MB, RSS is in kB,
   and user time is in seconds.










<span class="grey">Dickinson, et al.            Standards Track                   [Page 72]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-73"></span>
<span class="grey"><a href="./rfc8618">RFC 8618</a>         C-DNS: A Format for DNS Packet Capture   September 2019</span>


   +-------------+-----------+-------+------------+-------+-----------+
   | Format      | File Size | Comp. | Comp. Size |   RSS | User Time |
   +-------------+-----------+-------+------------+-------+-----------+
   | PCAP        |    661.87 | snzip |     212.48 |  2696 |      1.26 |
   |             |           | lz4   |     181.58 |  6336 |      1.35 |
   |             |           | gzip  |     153.46 |  1428 |     18.20 |
   |             |           | zstd  |      87.07 |  3544 |      4.27 |
   |             |           | xz    |      49.09 | 97416 |    160.79 |
   |             |           |       |            |       |           |
   | JSON simple |   4113.92 | snzip |     603.78 |  2656 |      5.72 |
   |             |           | lz4   |     386.42 |  5636 |      5.25 |
   |             |           | gzip  |     271.11 |  1492 |     73.00 |
   |             |           | zstd  |     133.43 |  3284 |      8.68 |
   |             |           | xz    |      51.98 | 97412 |    600.74 |
   |             |           |       |            |       |           |
   | Avro simple |    640.45 | snzip |     148.98 |  2656 |      0.90 |
   |             |           | lz4   |     111.92 |  5828 |      0.99 |
   |             |           | gzip  |     103.07 |  1540 |     11.52 |
   |             |           | zstd  |      49.08 |  3524 |      2.50 |
   |             |           | xz    |      22.87 | 97308 |     90.34 |
   |             |           |       |            |       |           |
   | CBOR simple |    764.82 | snzip |     164.57 |  2664 |      1.11 |
   |             |           | lz4   |     120.98 |  5892 |      1.13 |
   |             |           | gzip  |     110.61 |  1428 |     12.88 |
   |             |           | zstd  |      54.14 |  3224 |      2.77 |
   |             |           | xz    |      23.43 | 97276 |    111.48 |
   |             |           |       |            |       |           |
   | PBuf simple |    749.51 | snzip |     167.16 |  2660 |      1.08 |
   |             |           | lz4   |     123.09 |  5824 |      1.14 |
   |             |           | gzip  |     112.05 |  1424 |     12.75 |
   |             |           | zstd  |      53.39 |  3388 |      2.76 |
   |             |           | xz    |      23.99 | 97348 |    106.47 |
   |             |           |       |            |       |           |
   | JSON block  |    519.77 | snzip |     106.12 |  2812 |      0.93 |
   |             |           | lz4   |     104.34 |  6080 |      0.97 |
   |             |           | gzip  |      57.97 |  1604 |     12.70 |
   |             |           | zstd  |      61.51 |  3396 |      3.45 |
   |             |           | xz    |      27.67 | 97524 |    169.10 |
   |             |           |       |            |       |           |
   | Avro block  |     60.45 | snzip |      48.38 |  2688 |      0.20 |
   |             |           | lz4   |      48.78 |  8540 |      0.22 |
   |             |           | gzip  |      39.62 |  1576 |      2.92 |
   |             |           | zstd  |      29.63 |  3612 |      1.25 |
   |             |           | xz    |      18.28 | 97564 |     25.81 |
   |             |           |       |            |       |           |






<span class="grey">Dickinson, et al.            Standards Track                   [Page 73]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-74"></span>
<span class="grey"><a href="./rfc8618">RFC 8618</a>         C-DNS: A Format for DNS Packet Capture   September 2019</span>


   | CBOR block  |     75.25 | snzip |      53.27 |  2684 |      0.24 |
   |             |           | lz4   |      51.88 |  8008 |      0.28 |
   |             |           | gzip  |      41.17 |  1548 |      4.36 |
   |             |           | zstd  |      30.61 |  3476 |      1.48 |
   |             |           | xz    |      18.15 | 97556 |     38.78 |
   |             |           |       |            |       |           |
   | PBuf block  |     67.98 | snzip |      51.10 |  2636 |      0.24 |
   |             |           | lz4   |      52.39 |  8304 |      0.24 |
   |             |           | gzip  |      40.19 |  1520 |      3.63 |
   |             |           | zstd  |      31.61 |  3576 |      1.40 |
   |             |           | xz    |      17.94 | 97440 |     33.99 |
   +-------------+-----------+-------+------------+-------+-----------+

   The above results are discussed in the following sections.

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/C.1.%20%20Comparison%20with%20Full%20PCAP%20Files"></a><a class="selflink" href="#appendix-C.1" id="appendix-C.1">C.1</a>.  Comparison with Full PCAP Files</span>

   An important first consideration is whether moving away from PCAP
   offers significant benefits.

   The simple binary formats are typically larger than PCAP, even though
   they omit some information such as Ethernet Media Access Control
   (MAC) addresses.  But not only do they require less CPU to compress
   than PCAP, the resulting compressed files are smaller than compressed
   PCAP.

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/C.2.%20%20Simple%20versus%20Block%20Coding"></a><a class="selflink" href="#appendix-C.2" id="appendix-C.2">C.2</a>.  Simple versus Block Coding</span>

   The intention of the block coding is to perform data deduplication on
   Query/Response records within the block.  The simple and block
   formats shown above store exactly the same information for each
   Query/Response record.  This information is parsed from the DNS
   traffic in the input PCAP file, and in all cases each field has an
   identifier and the field data is typed.

   The data deduplication on the block formats show an order-of-
   magnitude reduction in the size of the format file size against the
   simple formats.  As would be expected, the compression tools are able
   to find and exploit a lot of this duplication, but as the
   deduplication process uses knowledge of DNS traffic, it is able to
   retain a size advantage.  This advantage reduces as stronger
   compression is applied, as again would be expected, but even with the
   strongest compression applied the block-formatted data remains around
   75% of the size of the simple format and its compression requires
   roughly a third of the CPU time.






<span class="grey">Dickinson, et al.            Standards Track                   [Page 74]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-75"></span>
<span class="grey"><a href="./rfc8618">RFC 8618</a>         C-DNS: A Format for DNS Packet Capture   September 2019</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/C.3.%20%20Binary%20versus%20Text%20Formats"></a><a class="selflink" href="#appendix-C.3" id="appendix-C.3">C.3</a>.  Binary versus Text Formats</span>

   Text data formats offer many advantages over binary formats,
   particularly in the areas of ad hoc data inspection and extraction.
   It was therefore felt worthwhile to carry out a direct comparison,
   implementing JSON versions of the simple and block formats.

   Concentrating on JSON block format, the format files produced are a
   significant fraction of an order of magnitude larger than binary
   formats.  The impact on file size after compression is as might be
   expected from that starting point; the stronger compression produces
   files that are 150% of the size of similarly compressed binary format
   and require over 4x more CPU to compress.

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/C.4.%20%20Performance"></a><a class="selflink" href="#appendix-C.4" id="appendix-C.4">C.4</a>.  Performance</span>

   Concentrating again on the block formats, all three produce format
   files that are close to an order of magnitude smaller than the
   original "test.pcap" file.  CBOR produces the largest files and Avro
   the smallest, 20% smaller than CBOR.

   However, once compression is taken into account, the size difference
   narrows.  At medium compression (with gzip), the size difference is
   4%.  Using strong compression (with xz), the difference reduces to
   2%, with Avro the largest and Protocol Buffers the smallest, although
   CBOR and Protocol Buffers require slightly more compression CPU.

   The measurements presented above do not include data on the CPU
   required to generate the format files.  Measurements indicate that
   writing Avro requires 10% more CPU than CBOR or Protocol Buffers.  It
   appears, therefore, that Avro's advantage in compression CPU usage is
   probably offset by a larger CPU requirement in writing Avro.

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/C.5.%20%20Conclusions"></a><a class="selflink" href="#appendix-C.5" id="appendix-C.5">C.5</a>.  Conclusions</span>

   The above assessments lead us to the choice of a binary format file
   using blocking.

   As noted previously, this document anticipates that output data will
   be subject to compression.  There is no compelling case for one
   particular binary serialization format in terms of either final file
   size or machine resources consumed, so the choice must be largely
   based on other factors.  CBOR was therefore chosen as the binary
   serialization format for the reasons listed in <a href="#section-5">Section 5</a>.







<span class="grey">Dickinson, et al.            Standards Track                   [Page 75]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-76"></span>
<span class="grey"><a href="./rfc8618">RFC 8618</a>         C-DNS: A Format for DNS Packet Capture   September 2019</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/C.6.%20%20Block%20Size%20Choice"></a><a class="selflink" href="#appendix-C.6" id="appendix-C.6">C.6</a>.  Block Size Choice</span>

   Given the choice of a CBOR format using blocking, the question arises
   of what an appropriate default value for the maximum number of
   Query/Response pairs in a block should be.  This has two components:

   1.  What is the impact on performance of using different block sizes
       in the format file?

   2.  What is the impact on the size of the format file before and
       after compression?

   The following table addresses the performance question, showing the
   impact on the performance of a C++ program converting "test.pcap"
   to C-DNS.  File sizes are in MB, RSS is in kB, and user time is
   in seconds.

              +------------+-----------+--------+-----------+
              | Block Size | File Size |    RSS | User Time |
              +------------+-----------+--------+-----------+
              |      1,000 |    133.46 | 612.27 |     15.25 |
              |      5,000 |     89.85 | 676.82 |     14.99 |
              |     10,000 |     76.87 | 752.40 |     14.53 |
              |     20,000 |     67.86 | 750.75 |     14.49 |
              |     40,000 |     61.88 | 736.30 |     14.29 |
              |     80,000 |     58.08 | 694.16 |     14.28 |
              |    160,000 |     55.94 | 733.84 |     14.44 |
              |    320,000 |     54.41 | 799.20 |     13.97 |
              +------------+-----------+--------+-----------+

   Therefore, increasing block size tends to increase maximum RSS a
   little, with no significant effect (if anything, a small reduction)
   on CPU consumption.


















<span class="grey">Dickinson, et al.            Standards Track                   [Page 76]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-77"></span>
<span class="grey"><a href="./rfc8618">RFC 8618</a>         C-DNS: A Format for DNS Packet Capture   September 2019</span>


   The following table demonstrates the effect of increasing block size
   on output file size for different compressions.

      +------------+--------+-------+-------+-------+-------+-------+
      | Block Size |   None | snzip |   lz4 |  gzip |  zstd |    xz |
      +------------+--------+-------+-------+-------+-------+-------+
      |      1,000 | 133.46 | 90.52 | 90.03 | 74.65 | 44.78 | 25.63 |
      |      5,000 |  89.85 | 59.69 | 59.43 | 46.99 | 37.33 | 22.34 |
      |     10,000 |  76.87 | 50.39 | 50.28 | 38.94 | 33.62 | 21.09 |
      |     20,000 |  67.86 | 43.91 | 43.90 | 33.24 | 32.62 | 20.16 |
      |     40,000 |  61.88 | 39.63 | 39.69 | 29.44 | 28.72 | 19.52 |
      |     80,000 |  58.08 | 36.93 | 37.01 | 27.05 | 26.25 | 19.00 |
      |    160,000 |  55.94 | 35.10 | 35.06 | 25.44 | 24.56 | 19.63 |
      |    320,000 |  54.41 | 33.87 | 33.74 | 24.36 | 23.44 | 18.66 |
      +------------+--------+-------+-------+-------+-------+-------+

   There is obviously scope for tuning the default block size to the
   compression being employed, traffic characteristics, frequency of
   output file rollover, etc.  Using a strong compression scheme, block
   sizes over 10,000 Query/Response pairs would seem to offer limited
   improvements.

<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/Appendix%20D.%20%20Data%20Fields%20for%20Traffic%20Regeneration"></a><a class="selflink" href="#appendix-D" id="appendix-D">Appendix D</a>.  Data Fields for Traffic Regeneration</span>

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/D.1.%20%20Recommended%20Fields%20for%20Traffic%20Regeneration"></a><a class="selflink" href="#appendix-D.1" id="appendix-D.1">D.1</a>.  Recommended Fields for Traffic Regeneration</span>

   This section specifies the data fields that would need to be captured
   in order to perform the fullest PCAP traffic reconstruction for
   well-formed DNS messages that is possible with C-DNS.

   o  All data fields in the QueryResponse type except response-
      processing-data.

   o  All data fields in the QueryResponseSignature type except qr-type.

   o  All data fields in the RR TYPE.

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/D.2.%20%20Issues%20with%20Small%20Data%20Captures"></a><a class="selflink" href="#appendix-D.2" id="appendix-D.2">D.2</a>.  Issues with Small Data Captures</span>

   At the other extreme, an interesting corner case arises when opting
   to perform captures with a smaller data set than that recommended
   above.  The following list specifies a subset of the above data
   fields; if only these data fields are captured, then even a minimal
   traffic reconstruction is problematic because there is not enough
   information to determine if the Query/Response data item contained
   just a Query, just a Response, or a Query/Response pair.





<span class="grey">Dickinson, et al.            Standards Track                   [Page 77]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-78"></span>
<span class="grey"><a href="./rfc8618">RFC 8618</a>         C-DNS: A Format for DNS Packet Capture   September 2019</span>


   o  The following data fields from the QueryResponse type:

      *  time-offset

      *  client-address-index

      *  client-port

      *  transaction-id

      *  query-name-index

   o  The following data fields from the QueryResponseSignature type:

      *  server-address-index

      *  server-port

      *  qr-transport-flags

      *  query-classtype-index

   In this case, simply also capturing the qr-sig-flags will provide
   enough information to perform a minimal traffic reconstruction
   (assuming that suitable defaults for the remaining fields are
   provided).  Additionally, capturing response-delay, query-opcode, and
   response-rcode will avoid having to rely on potentially misleading
   defaults for these values and should result in a PCAP that represents
   the basics of the real traffic flow.

Acknowledgements

   The authors wish to thank CZ.NIC -- in particular, Tomas Gavenciak --
   for many useful discussions on binary formats, compression, and
   packet matching.  Thanks also to Jan Vcelak and Wouter Wijngaards for
   discussions on name compression, and Paul Hoffman for a detailed
   review of this document and the C-DNS CDDL.

   Thanks also to Robert Edmonds, Jerry Lundstrom, Richard Gibson,
   Stephane Bortzmeyer, and many other members of DNSOP for review.

   Also, thanks to Miek Gieben for [<a href="#ref-mmark" title='"mmark"'>mmark</a>].









<span class="grey">Dickinson, et al.            Standards Track                   [Page 78]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-79"></span>
<span class="grey"><a href="./rfc8618">RFC 8618</a>         C-DNS: A Format for DNS Packet Capture   September 2019</span>


Authors' Addresses

   John Dickinson
   Sinodun IT
   Magdalen Centre
   Oxford Science Park
   Oxford  OX4 4GA
   United Kingdom
   Email: jad@sinodun.com


   Jim Hague
   Sinodun IT
   Magdalen Centre
   Oxford Science Park
   Oxford  OX4 4GA
   United Kingdom
   Email: jim@sinodun.com


   Sara Dickinson
   Sinodun IT
   Magdalen Centre
   Oxford Science Park
   Oxford  OX4 4GA
   United Kingdom
   Email: sara@sinodun.com


   Terry Manderson
   ICANN
   12025 Waterfront Drive
   Suite 300
   Los Angeles, CA  90094-2536
   United States of America
   Email: terry.manderson@icann.org


   John Bond
   Wikimedia Foundation, Inc.
   1 Montgomery Street
   Suite 1600
   San Francisco, CA  94104
   United States of America
   Email: ietf-wikimedia@johnbond.org






Dickinson, et al.            Standards Track                   [Page 79]
</pre>
</body></html>