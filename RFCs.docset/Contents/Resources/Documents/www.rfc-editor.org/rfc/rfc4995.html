<html><head></head><body><pre>Network Working Group                                       L-E. Jonsson
Request for Comments: 4995                                  G. Pelletier
Category: Standards Track                                    K. Sandlund
                                                                Ericsson
                                                               July 2007


             <span class="h1">The RObust Header Compression (ROHC) Framework</span>

Status of This Memo

   This document specifies an Internet standards track protocol for the
   Internet community, and requests discussion and suggestions for
   improvements.  Please refer to the current edition of the "Internet
   Official Protocol Standards" (STD 1) for the standardization state
   and status of this protocol.  Distribution of this memo is unlimited.

Copyright Notice

   Copyright (C) The IETF Trust (2007).

Abstract

   The Robust Header Compression (ROHC) protocol provides an efficient,
   flexible, and future-proof header compression concept.  It is
   designed to operate efficiently and robustly over various link
   technologies with different characteristics.

   The ROHC framework, along with a set of compression profiles, was
   initially defined in <a href="./rfc3095">RFC 3095</a>.  To improve and simplify the ROHC
   specifications, this document explicitly defines the ROHC framework
   and the profile for uncompressed separately.  More specifically, the
   definition of the framework does not modify or update the definition
   of the framework specified by <a href="./rfc3095">RFC 3095</a>.

Table of Contents

   <a href="#section-1">1</a>. Introduction ....................................................<a href="#page-3">3</a>
   <a href="#section-2">2</a>. Terminology .....................................................<a href="#page-4">4</a>
      <a href="#section-2.1">2.1</a>. Acronyms ...................................................<a href="#page-4">4</a>
      <a href="#section-2.2">2.2</a>. ROHC Terminology ...........................................<a href="#page-4">4</a>
   <a href="#section-3">3</a>. Background (Informative) ........................................<a href="#page-7">7</a>
      <a href="#section-3.1">3.1</a>. Header Compression Fundamentals ............................<a href="#page-7">7</a>
      <a href="#section-3.2">3.2</a>. A Short History of Header Compression ......................<a href="#page-7">7</a>
   <a href="#section-4">4</a>. Overview of Robust Header Compression (ROHC) (Informative) ......<a href="#page-8">8</a>
      <a href="#section-4.1">4.1</a>. General Principles .........................................<a href="#page-8">8</a>
      <a href="#section-4.2">4.2</a>. Compression Efficiency, Robustness, and Transparency ......<a href="#page-10">10</a>
      <a href="#section-4.3">4.3</a>. Developing the ROHC Protocol ..............................<a href="#page-10">10</a>



<span class="grey">Jonsson, et al.             Standards Track                     [Page 1]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-2"></span>
<span class="grey"><a href="./rfc4995">RFC 4995</a>                   The ROHC Framework                  July 2007</span>


      <a href="#section-4.4">4.4</a>. Operational Characteristics of the ROHC Channel ...........<a href="#page-11">11</a>
      <a href="#section-4.5">4.5</a>. Compression and Master Sequence Number (MSN) ..............<a href="#page-13">13</a>
      <a href="#section-4.6">4.6</a>. Static and Dynamic Parts of a Context .....................<a href="#page-13">13</a>
   <a href="#section-5">5</a>. The ROHC Framework (Normative) .................................<a href="#page-14">14</a>
      <a href="#section-5.1">5.1</a>. The ROHC Channel ..........................................<a href="#page-14">14</a>
           <a href="#section-5.1.1">5.1.1</a>. Contexts and Context Identifiers ...................<a href="#page-14">14</a>
           <a href="#section-5.1.2">5.1.2</a>. Per-Channel Parameters .............................<a href="#page-15">15</a>
           <a href="#section-5.1.3">5.1.3</a>. Persistence of Decompressor Contexts ...............<a href="#page-16">16</a>
      <a href="#section-5.2">5.2</a>. ROHC Packets and Packet Types .............................<a href="#page-16">16</a>
           <a href="#section-5.2.1">5.2.1</a>. General Format of ROHC Packets .....................<a href="#page-17">17</a>
                  <a href="#section-5.2.1.1">5.2.1.1</a>. Format of the Padding Octet ...............<a href="#page-17">17</a>
                  <a href="#section-5.2.1.2">5.2.1.2</a>. Format of the Add-CID Octet ...............<a href="#page-18">18</a>
                  <a href="#section-5.2.1.3">5.2.1.3</a>. General Format of Header ..................<a href="#page-18">18</a>
           <a href="#section-5.2.2">5.2.2</a>. Initialization and Refresh (IR) Packet Types .......<a href="#page-19">19</a>
                  <a href="#section-5.2.2.1">5.2.2.1</a>. ROHC IR Packet Type .......................<a href="#page-20">20</a>
                  <a href="#section-5.2.2.2">5.2.2.2</a>. ROHC IR-DYN Packet Type ...................<a href="#page-20">20</a>
           <a href="#section-5.2.3">5.2.3</a>. ROHC Initial Decompressor Processing ...............<a href="#page-21">21</a>
           <a href="#section-5.2.4">5.2.4</a>. ROHC Feedback ......................................<a href="#page-22">22</a>
                  <a href="#section-5.2.4.1">5.2.4.1</a>. ROHC Feedback Format ......................<a href="#page-23">23</a>
           <a href="#section-5.2.5">5.2.5</a>. ROHC Segmentation ..................................<a href="#page-25">25</a>
                  <a href="#section-5.2.5.1">5.2.5.1</a>. Segmentation Usage Considerations .........<a href="#page-25">25</a>
                  <a href="#section-5.2.5.2">5.2.5.2</a>. Segmentation Protocol .....................<a href="#page-26">26</a>
      <a href="#section-5.3">5.3</a>. General Encoding Methods ..................................<a href="#page-27">27</a>
           <a href="#section-5.3.1">5.3.1</a>. Header Compression CRCs, Coverage and Polynomials ..27
                  <a href="#section-5.3.1.1">5.3.1.1</a>. 8-bit CRCs in IR and IR-DYN Headers .......<a href="#page-27">27</a>
                  <a href="#section-5.3.1.2">5.3.1.2</a>. 3-bit CRC in Compressed Headers ...........<a href="#page-27">27</a>
                  <a href="#section-5.3.1.3">5.3.1.3</a>. 7-bit CRC in Compressed Headers ...........<a href="#page-28">28</a>
                  <a href="#section-5.3.1.4">5.3.1.4</a>. 32-bit Segmentation CRC ...................<a href="#page-28">28</a>
           <a href="#section-5.3.2">5.3.2</a>. Self-Describing Variable-Length Values .............<a href="#page-29">29</a>
      <a href="#section-5.4">5.4</a>. ROHC UNCOMPRESSED -- No Compression  (Profile 0x0000) .....<a href="#page-29">29</a>
           <a href="#section-5.4.1">5.4.1</a>. IR Packet ..........................................<a href="#page-30">30</a>
           <a href="#section-5.4.2">5.4.2</a>. Normal Packet ......................................<a href="#page-31">31</a>
           <a href="#section-5.4.3">5.4.3</a>. Decompressor Operation .............................<a href="#page-31">31</a>
           <a href="#section-5.4.4">5.4.4</a>. Feedback ...........................................<a href="#page-32">32</a>
   <a href="#section-6">6</a>. Overview of a ROHC Profile (Informative) .......................<a href="#page-32">32</a>
   <a href="#section-7">7</a>. Security Considerations ........................................<a href="#page-33">33</a>
   <a href="#section-8">8</a>. IANA Considerations ............................................<a href="#page-34">34</a>
   <a href="#section-9">9</a>. Acknowledgments ................................................<a href="#page-35">35</a>
   <a href="#section-10">10</a>. References ....................................................<a href="#page-35">35</a>
      <a href="#section-10.1">10.1</a>. Normative References .....................................<a href="#page-35">35</a>
      <a href="#section-10.2">10.2</a>. Informative References ...................................<a href="#page-35">35</a>
   <a href="#appendix-A">Appendix A</a>.  CRC Algorithm ........................................<a href="#page-37">37</a>









<span class="grey">Jonsson, et al.             Standards Track                     [Page 2]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-3"></span>
<span class="grey"><a href="./rfc4995">RFC 4995</a>                   The ROHC Framework                  July 2007</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/1.%20%20Introduction"></a><a class="selflink" href="#section-1" id="section-1">1</a>.  Introduction</span>

   For many types of networks, reducing the deployment and operational
   costs by improving the usage of the bandwidth resources is of vital
   importance.  Header compression over a link is possible because some
   of the information carried within the header of a packet becomes
   compressible between packets belonging to the same flow.

   For links where the overhead of the IP header(s) is problematic, the
   total size of the header may be significant.  Applications carrying
   data carried within RTP [<a href="#ref-13" title='"RTP: A Transport Protocol for Real-Time Applications"'>13</a>] will then, in addition to link-layer
   framing, have an IPv4 [<a href="#ref-10" title='"Internet Protocol"'>10</a>] header (20 octets), a UDP [<a href="#ref-12" title='"User Datagram Protocol"'>12</a>] header (8
   octets), and an RTP header (12 octets), for a total of 40 octets.
   With IPv6 [<a href="#ref-11" title='"Internet Protocol, Version 6 (IPv6) Specification"'>11</a>], the IPv6 header is 40 octets for a total of 60
   octets.  Applications transferring data using TCP [<a href="#ref-14" title='"Transmission Control Protocol"'>14</a>] will have 20
   octets for the transport header, for a total size of 40 octets for
   IPv4 and 60 octets for IPv6.

   The relative gain for specific flows (or applications) depends on the
   size of the payload used in each packet.  For applications such as
   Voice-over-IP, where the size of the payload containing coded speech
   can be as small as 15-20 octets, this gain will be quite significant.
   Similarly, relative gains for TCP flows carrying large payloads (such
   as file transfers) will be less than for flows carrying smaller
   payloads (such as application signaling, e.g., session initiation).

   As more and more wireless link technologies are being deployed to
   carry IP traffic, care must be taken to address the specific
   characteristics of these technologies within the header compression
   algorithms.  Legacy header compression schemes, such as those defined
   in [<a href="#ref-16" title='"IP Header Compression"'>16</a>] and [<a href="#ref-17" title='"Compressing IP/UDP/RTP Headers for Low-Speed Serial Links"'>17</a>], have been shown to perform inadequately over links
   where both the lossy behavior and the round-trip times are non-
   negligible, such as those observed for example in wireless links and
   IP tunnels.

   In addition, a header compression scheme should handle the often
   non-trivial residual errors, i.e., where the lower layer may pass a
   packet that contains undetected bit errors to the decompressor.  It
   should also handle loss and reordering before the compression point,
   as well as on the link between the compression and decompression
   points [<a href="#ref-7" title='"RObust Header Compression (ROHC): ROHC over Channels That Can Reorder Packets"'>7</a>].

   The Robust Header Compression (ROHC) protocol provides an efficient,
   flexible, and future-proof header compression concept.  It is
   designed to operate efficiently and robustly over various link
   technologies with different characteristics.





<span class="grey">Jonsson, et al.             Standards Track                     [Page 3]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-4"></span>
<span class="grey"><a href="./rfc4995">RFC 4995</a>                   The ROHC Framework                  July 2007</span>


   <a href="./rfc3095">RFC 3095</a> [<a href="#ref-3" title='"RObust Header Compression (ROHC): Framework and four profiles: RTP, UDP, ESP, and uncompressed"'>3</a>] defines the ROHC framework along with an initial set of
   compression profiles.  To improve and simplify the specification, the
   framework and the profiles' parts have been split into separate
   documents.  This document explicitly defines the ROHC framework, but
   it does not modify or update the definition of the framework
   specified by <a href="./rfc3095">RFC 3095</a>; both documents can be used independently of
   each other.  This also implies that implementations based on either
   definition will be compatible and interoperable with each other.
   However, it is the intent to let this specification replace <a href="./rfc3095">RFC 3095</a>
   as the base specification for all profiles defined in the future.

<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/2.%20%20Terminology"></a><a class="selflink" href="#section-2" id="section-2">2</a>.  Terminology</span>

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in [<a href="#ref-1" title='"Key words for use in RFCs to Indicate Requirement Levels"'>1</a>].

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/2.1.%20%20Acronyms"></a><a class="selflink" href="#section-2.1" id="section-2.1">2.1</a>.  Acronyms</span>

   This section lists most acronyms used for reference.

      ACK    Acknowledgment.
      CID    Context Identifier.
      CO     Compressed Packet Format.
      CRC    Cyclic Redundancy Check.
      IR     Initialization and Refresh.
      IR-DYN Initialization and Refresh, Dynamic part.
      LSB    Least Significant Bit(s).
      MRRU   Maximum Reconstructed Reception Unit.
      MSB    Most Significant Bit(s).
      MSN    Master Sequence Number.
      NACK   Negative Acknowledgment.
      ROHC   RObust Header Compression.

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/2.2.%20ROHC%20Terminology"></a><a class="selflink" href="#section-2.2" id="section-2.2">2.2</a>. ROHC Terminology</span>

   Context

      The context of the compressor is the state it uses to compress a
      header.  The context of the decompressor is the state it uses to
      decompress a header.  Either of these or the two in combination
      are usually referred to as "context", when it is clear which is
      intended.  The context contains relevant information from previous
      headers in the packet flow, such as static fields and possible
      reference values for compression and decompression.  Moreover,
      additional information describing the packet flow is also part of





<span class="grey">Jonsson, et al.             Standards Track                     [Page 4]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-5"></span>
<span class="grey"><a href="./rfc4995">RFC 4995</a>                   The ROHC Framework                  July 2007</span>


      the context, for example, information about the change behavior of
      fields (e.g., the IP Identifier behavior, or the typical inter-
      packet increase in sequence numbers and timestamps).

   Context damage

      When the context of the decompressor is not consistent with the
      context of the compressor, decompression may fail to reproduce the
      original header.  This situation can occur when the context of the
      decompressor has not been initialized properly or when packets
      have been lost or damaged between the compressor and decompressor.

      Packets which cannot be decompressed due to inconsistent contexts
      are said to be lost due to context damage.  Packets that are
      decompressed but contain errors due to inconsistent contexts are
      said to be damaged due to context damage.

   Context repair mechanism

      Context repair mechanisms are used to resynchronize the contexts,
      an important task since context damage causes loss propagation.
      Examples of such mechanisms are NACK-based mechanisms, and the
      periodic refreshes of important context information, usually done
      in unidirectional operation.  There are also mechanisms that can
      reduce the context inconsistency probability, for example,
      repetition of the same type of information in multiple packets and
      CRCs that protect context-updating information.

   CRC-8 validation

      The CRC-8 validation refers to the validation of the integrity
      against bit error(s) in a received IR and IR-DYN header using the
      8-bit CRC included in the IR/IR-DYN header.

   CRC verification

      The CRC verification refers to the verification of the result of a
      decompression attempt using the 3-bit CRC or 7-bit CRC included in
      the header of a compressed packet format.

   Damage propagation

      Delivery of incorrect decompressed headers due to context damage,
      that is, due to errors in (i.e., loss of or damage to) previous
      header(s) or feedback.






<span class="grey">Jonsson, et al.             Standards Track                     [Page 5]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-6"></span>
<span class="grey"><a href="./rfc4995">RFC 4995</a>                   The ROHC Framework                  July 2007</span>


   Error detection

      Detection of errors by lower layers.  If error detection is not
      perfect, there will be residual errors.

   Error propagation

      Damage propagation or loss propagation.

   ROHC profile

      A ROHC profile is a compression protocol, which specifies how to
      compress specific header combinations.  A ROHC profile may be
      tailored to handle a specific set of link characteristics, e.g.,
      loss characteristics, reordering between compression points, etc.
      ROHC profiles provide the details of the header compression
      framework defined in this document, and each compression profile
      is associated with a unique ROHC profile identifier [<a href="#ref-21" title='"RObust Header Compression (ROHC) Profile Identifiers"'>21</a>].  When
      setting up a ROHC channel, the set of profiles supported by both
      endpoints of the channel is negotiated, and when initializing new
      contexts, a profile identifier from this negotiated set is used to
      associate each compression context with one specific profile.

   Link

      A physical transmission path that constitutes a single IP hop.

   Loss propagation

      Loss of headers, due to errors in (i.e., loss of or damage to)
      previous header(s) or feedback.

   Packet flow

      A sequence of packets where the field values and change patterns
      of field values are such that the headers can be compressed using
      the same context.

   Residual error

      Errors introduced during transmission and not detected by lower-
      layer error detection schemes.

   ROHC channel

      A logical unidirectional point-to-point channel carrying ROHC
      packets from one compressor to one decompressor, optionally
      carrying ROHC feedback information on the behalf of another



<span class="grey">Jonsson, et al.             Standards Track                     [Page 6]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-7"></span>
<span class="grey"><a href="./rfc4995">RFC 4995</a>                   The ROHC Framework                  July 2007</span>


      compressor-decompressor pair operating on a separate ROHC channel
      in the opposite direction.  See also [<a href="#ref-5" title='"RObust Header Compression (ROHC): Terminology and Channel Mapping Examples"'>5</a>].

   This document also makes use of the conceptual terminology defined by
   "ROHC Terminology and Channel Mapping Examples", <a href="./rfc3759">RFC 3759</a> [<a href="#ref-5" title='"RObust Header Compression (ROHC): Terminology and Channel Mapping Examples"'>5</a>].

<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/3.%20%20Background%20%28Informative%29"></a><a class="selflink" href="#section-3" id="section-3">3</a>.  Background (Informative)</span>

   This section provides a background to the subject of header
   compression.  The fundamental ideas are described together with a
   discussion about the history of header compression schemes.  The
   motivations driving the development of the various schemes are
   discussed and their drawbacks identified, thereby providing the
   foundations for the design of the ROHC framework and profiles [<a href="#ref-3" title='"RObust Header Compression (ROHC): Framework and four profiles: RTP, UDP, ESP, and uncompressed"'>3</a>].

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/3.1.%20%20Header%20Compression%20Fundamentals"></a><a class="selflink" href="#section-3.1" id="section-3.1">3.1</a>.  Header Compression Fundamentals</span>

   Header compression is possible because there is significant
   redundancy between header fields; within the headers of a single
   packet, but in particular between consecutive packets belonging to
   the same flow.  On the path end-to-end, the entire header information
   is necessary for all packets in the flow, but over a single link,
   some of this information becomes redundant and can be reduced, as
   long as it is transparently recovered at the receiving end of the
   link.  The header size can be reduced by first sending field
   information that is expected to remain static for (at least most of)
   the lifetime of the packet flow.  Further compression is achieved for
   the fields carrying information that changes more dynamically by
   using compression methods tailored to their respective assumed change
   behavior.

   To achieve compression and decompression, some necessary information
   from past packets is maintained in a context.  The compressor and the
   decompressor update their respective contexts upon certain, not
   necessarily synchronized, events.  Impairment events may lead to
   inconsistencies in the decompressor context (i.e., context damage),
   which in turn may cause incorrect decompression.  A Robust Header
   Compression scheme needs mechanisms to minimize the possibility of
   context damage, in combination with mechanisms for context repair.

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/3.2.%20%20A%20Short%20History%20of%20Header%20Compression"></a><a class="selflink" href="#section-3.2" id="section-3.2">3.2</a>.  A Short History of Header Compression</span>

   The first header compression scheme, compressed TCP (CTCP) [<a href="#ref-15" title='"Compressing TCP/IP headers for low-speed serial links"'>15</a>], was
   introduced by Van Jacobson.  CTCP, also often referred to as VJ
   compression, compresses the 40 octets of the TCP/IP header down to 4
   octets.  CTCP uses delta encoding for sequentially changing fields.
   The CTCP compressor detects transport-level retransmissions and sends
   a header that updates the entire context when they occur.  This



<span class="grey">Jonsson, et al.             Standards Track                     [Page 7]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-8"></span>
<span class="grey"><a href="./rfc4995">RFC 4995</a>                   The ROHC Framework                  July 2007</span>


   repair mechanism does not require any explicit signaling between the
   compressor and decompressor.

   A general IP header compression scheme, IP header compression [<a href="#ref-16" title='"IP Header Compression"'>16</a>],
   improves somewhat on CTCP.  IP Header Compression (IPHC) can compress
   arbitrary IP, TCP, and UDP headers.  When compressing non-TCP
   headers, IPHC does not use delta encoding and is robust.  The repair
   mechanism of CTCP is augmented with negative acknowledgments, called
   CONTEXT_STATE messages, which speeds up the repair.  This context
   repair mechanism is thus limited by the round-trip time of the link.
   IPHC does not compress RTP headers.

   CRTP [<a href="#ref-17" title='"Compressing IP/UDP/RTP Headers for Low-Speed Serial Links"'>17</a>] is an RTP extension to IPHC.  CRTP compresses the 40 octets
   of IPv4/UDP/RTP headers to a minimum of 2 octets when the UDP
   Checksum is not enabled.  If the UDP Checksum is enabled, the minimum
   CRTP header is 4 octets.

   On lossy links with long round-trip times, CRTP does not perform well
   [<a href="#ref-20" title='"Evaluation of CRTP Performance over Cellular Radio Networks"'>20</a>].  Each packet lost over the link causes decompression of several
   subsequent packets to fail, because the context becomes invalidated
   during at least one link round-trip time from the lost packet.
   Unfortunately, the large headers that CRTP sends when updating the
   context waste additional bandwidth.

   CRTP uses a local repair mechanism known as TWICE, which was
   introduced by IPHC.  TWICE derives its name from the observation that
   when the flow of compressed packets is regular, the correct guess
   when one packet is lost between the compression points is to apply
   the update in the current packet twice.  While TWICE improves CRTP
   performance significantly, [<a href="#ref-20" title='"Evaluation of CRTP Performance over Cellular Radio Networks"'>20</a>] also found that even with TWICE, CRTP
   doubled the number of lost packets.

   An enhanced variant of CRTP, called eCRTP [<a href="#ref-19" title='"Enhanced Compressed RTP (CRTP) for Links with High Delay, Packet Loss and Reordering"'>19</a>], means to improve the
   robustness of CRTP in the presence of reordering and packet losses,
   while keeping the protocol almost unchanged from CRTP.  As a result,
   eCRTP does provide better means to implement some degree of
   robustness, albeit at the expense of additional overhead, leading to
   a reduction in compression efficiency in comparison to CRTP.

<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/4.%20%20Overview%20of%20Robust%20Header%20Compression%20%28ROHC%29%20%28Informative%29"></a><a class="selflink" href="#section-4" id="section-4">4</a>.  Overview of Robust Header Compression (ROHC) (Informative)</span>

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/4.1.%20%20General%20Principles"></a><a class="selflink" href="#section-4.1" id="section-4.1">4.1</a>.  General Principles</span>

   As mentioned earlier, header compression is possible per-link due to
   the fact that there is much redundancy between header field values
   within packets, and especially between consecutive packets belonging
   to the same flow.  To utilize these properties for header
   compression, there are a few essential steps to consider.



<span class="grey">Jonsson, et al.             Standards Track                     [Page 8]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-9"></span>
<span class="grey"><a href="./rfc4995">RFC 4995</a>                   The ROHC Framework                  July 2007</span>


   The first step consists of identifying and grouping packets together
   into different "flows", so that packet-to-packet redundancy is
   maximized in order to improve the compression ratio.  Grouping
   packets into flows is usually based on source and destination host
   (IP) addresses, transport protocol type (e.g., UDP or TCP), process
   (port) numbers, and potentially additional unique application
   identifiers, such as the synchronization source (SSRC) in RTP [<a href="#ref-13" title='"RTP: A Transport Protocol for Real-Time Applications"'>13</a>].
   The compressor and decompressor each establish a context for the
   packet flow and identify the context with a Context Identifier (CID)
   included in each compressed header.

   The second step is to understand the change patterns of the various
   header fields.  On a high level, header fields fall into one of the
   following classes:

   INFERRED      These fields contain values that can be inferred from
                 other fields or external sources, for example, the size
                 of the frame carrying the packet can often be derived
                 from the link layer protocol, and thus does not have to
                 be transmitted by the compression scheme.

   STATIC        Fields classified as STATIC are assumed to be constant
                 throughout the lifetime of the packet flow.  The value
                 of each field is thus only communicated initially.

   STATIC-DEF    Fields classified as STATIC-DEF are used to define a
                 packet flow as discussed above.  Packets for which
                 respective values of these fields differ are treated as
                 belonging to different flows.  These fields are in
                 general compressed as STATIC fields.

   STATIC-KNOWN  Fields classified as STATIC-KNOWN are expected to have
                 well-known values, and therefore their values do not
                 need to be communicated.

   CHANGING      These fields are expected to vary randomly, either
                 within a limited value set or range, or in some other
                 manner.  CHANGING fields are usually handled in more
                 sophisticated ways based on a more detailed
                 classification of their expected change patterns.

   Finally, the last step is to choose the encoding method(s) that will
   be applied onto different fields based on classification.  The
   encoding methods, in combination with the identified field behavior,
   provide the input to the design of the compressed header formats.
   The analysis of the probability distribution of the identified change
   patterns then provides the means to optimize the packet formats,




<span class="grey">Jonsson, et al.             Standards Track                     [Page 9]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-10"></span>
<span class="grey"><a href="./rfc4995">RFC 4995</a>                   The ROHC Framework                  July 2007</span>


   where the most frequently occurring change patterns for a field
   should be encoded within the most efficient format(s).

   However, compression efficiency has to be traded against two other
   properties: the robustness of the encoding to losses and errors
   between the compressor and the decompressor, and the ability to
   detect and cope with errors in the decompression process.

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/4.2.%20%20Compression%20Efficiency%2C%20Robustness%2C%20and%20Transparency"></a><a class="selflink" href="#section-4.2" id="section-4.2">4.2</a>.  Compression Efficiency, Robustness, and Transparency</span>

   The performance of a header compression protocol can be described
   with three parameters: its compression efficiency, its robustness,
   and its compression transparency.

   Compression efficiency

      The compression efficiency is determined by how much the average
      header size is reduced by applying the compression protocol.

   Robustness

      A robust protocol tolerates packet losses, residual bit errors,
      and out-of-order delivery on the link over which header
      compression takes place, without losing additional packets or
      introducing additional errors in decompressed headers.

   Compression transparency

      The compression transparency is a measure of the extent to which
      the scheme maintains the semantics of the original headers.  If
      all decompressed headers are bitwise identical to the
      corresponding original headers, the scheme is transparent.

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/4.3.%20%20Developing%20the%20ROHC%20Protocol"></a><a class="selflink" href="#section-4.3" id="section-4.3">4.3</a>.  Developing the ROHC Protocol</span>

   The challenge in developing a header compression protocol is to
   conciliate compression efficiency and robustness while maintaining
   transparency, as increasing robustness will always come at the
   expense of a lower compression efficiency, and vice-versa.  The
   scheme should also be flexible enough in its design to minimize the
   impacts from the varying round-trip times and loss patterns of links
   where header compression will be used.

   To achieve this, the header compression scheme must provide
   facilities for the decompressor to verify decompression and detect
   potential context damage, as well as context recovery mechanisms such
   as feedback.  Header compression schemes prior to the ones developed




<span class="grey">Jonsson, et al.             Standards Track                    [Page 10]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-11"></span>
<span class="grey"><a href="./rfc4995">RFC 4995</a>                   The ROHC Framework                  July 2007</span>


   by the Robust Header Compression (ROHC) WG were not designed with the
   above high-level objectives in mind.

   The ROHC WG has developed header compression solutions to meet the
   needs of present and future link technologies.  While special
   attention has been put towards meeting the more stringent
   requirements stemming from the characteristics of wireless links, the
   results are equally applicable to many other link technologies.

   <a href="./rfc3095">RFC 3095</a> [<a href="#ref-3" title='"RObust Header Compression (ROHC): Framework and four profiles: RTP, UDP, ESP, and uncompressed"'>3</a>], "RObust Header Compression (ROHC): Framework and four
   profiles: RTP, UDP, ESP, and uncompressed", was published in 2001, as
   the first output of the ROHC WG.  ROHC is a general and extendable
   framework for header compression, on top of which profiles can be
   defined for compression of different protocols headers.  <a href="./rfc3095">RFC 3095</a>
   introduced a number of new compression techniques, and was successful
   at living up to the requirements placed on it, as described in [<a href="#ref-18" title='"Requirements for robust IP/UDP/RTP header compression"'>18</a>].

   Interoperability testing of <a href="./rfc3095">RFC 3095</a> confirms the capabilities of
   ROHC to meet its purposes, but feedback from implementers has also
   indicated that the protocol specification is complex and sometimes
   obscure.  Most importantly, a clear distinction between framework and
   profiles is not obvious in [<a href="#ref-3" title='"RObust Header Compression (ROHC): Framework and four profiles: RTP, UDP, ESP, and uncompressed"'>3</a>], which also makes development of
   additional profiles troublesome.  This document therefore aims at
   explicitly specifying the ROHC framework, while a companion document
   [<a href="#ref-8" title='"RObust Header Compression Version 2 (ROHCv2): Profiles for RTP, UDP, IP, ESP, and UDP Lite"'>8</a>] specifies revised versions of the compression profiles of <a href="./rfc3095">RFC</a>
   <a href="./rfc3095">3095</a>.

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/4.4.%20%20Operational%20Characteristics%20of%20the%20ROHC%20Channel"></a><a class="selflink" href="#section-4.4" id="section-4.4">4.4</a>.  Operational Characteristics of the ROHC Channel</span>

   Robust header compression can be used over many type of link
   technologies.  The ROHC framework provides flexibility for profiles
   to address a wide range of applications, and this section lists some
   of the operational characteristics of the ROHC channel (see also
   [<a href="#ref-5" title='"RObust Header Compression (ROHC): Terminology and Channel Mapping Examples"'>5</a>]).

   Multiplexing over a single logical channel

      The ROHC channel provides a mechanism to identify a context within
      the general ROHC packet format.  The CID makes it possible for a
      logical channel that supports ROHC to transport multiple header-
      compressed flows, while still making it possible for a channel to
      be dedicated to one single packet flow without any CID overhead.
      More specifically, ROHC uses a distinct context identifier space
      per logical channel, and the context identifier can be omitted for
      one of the flows over the ROHC channel when configured to use a
      small CID space.





<span class="grey">Jonsson, et al.             Standards Track                    [Page 11]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-12"></span>
<span class="grey"><a href="./rfc4995">RFC 4995</a>                   The ROHC Framework                  July 2007</span>


   Establishment of channel parameters

      A link layer defining support for the ROHC channel must provide
      the means to establish header compression channel parameters (see
      <a href="#section-5.1">Section 5.1</a>).  This can be achieved through a negotiation
      mechanism, static provisioning, or some out-of-band signaling.

   Packet type identification

      The ROHC channel defines a packet type identifier space, and puts
      restrictions with respect to the use of a number of identifiers
      that are common for all ROHC profiles.  Identifiers that have no
      restrictions, i.e., identifiers that are not defined by this
      document, are available to each profile.  The identifier is part
      of each compressed header, and this makes it possible for the link
      that supports the ROHC channel to allocate one single link layer
      payload type for ROHC.

   Out-of-order delivery between compression endpoints

      Each profile defines its own level of robustness, including
      tolerance to reordering of packets before but especially between
      compression endpoints, if any.

      For profiles specified in [<a href="#ref-3" title='"RObust Header Compression (ROHC): Framework and four profiles: RTP, UDP, ESP, and uncompressed"'>3</a>], the channel between the compressor
      and decompressor is required to maintain in-order delivery of the
      packets, i.e., the definition of these profiles assumes that the
      decompressor always receives packets in the same order as the
      compressor sent them.  The impacts of reordering on the
      performance of these profiles is described in [<a href="#ref-7" title='"RObust Header Compression (ROHC): ROHC over Channels That Can Reorder Packets"'>7</a>].  However,
      reordering before the compression point is handled, i.e., these
      profiles make no assumption that the compressor will receive
      packets in-order.

      For the ROHCv2 profiles specified in [<a href="#ref-8" title='"RObust Header Compression Version 2 (ROHCv2): Profiles for RTP, UDP, IP, ESP, and UDP Lite"'>8</a>], their definitions assume
      that the decompressor can receive packets out-of-order, i.e., not
      in the same order that the compressor sent them.  Reordering
      before the compression point is also dealt with.

   Duplication of packets

      The link supporting the ROHC channel is required to not duplicate
      packets (however, duplication of packets can occur before they
      reach the compressor, i.e., there is no assumption that the
      compressor will receive only one copy of each packet).






<span class="grey">Jonsson, et al.             Standards Track                    [Page 12]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-13"></span>
<span class="grey"><a href="./rfc4995">RFC 4995</a>                   The ROHC Framework                  July 2007</span>


   Framing

      The link layer must provide framing that makes it possible to
      distinguish frame boundaries and individual frames.

   Error detection/protection

      ROHC profiles should be designed to cope with residual errors in
      the headers delivered to the decompressor.  CRCs are used to
      detect decompression failures and to prevent or reduce damage
      propagation.  However, it is recommended that lower layers deploy
      error detection for ROHC headers and that ROHC headers with high
      residual error rates not be delivered.

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/4.5.%20%20Compression%20and%20Master%20Sequence%20Number%20%28MSN%29"></a><a class="selflink" href="#section-4.5" id="section-4.5">4.5</a>.  Compression and Master Sequence Number (MSN)</span>

   Compression of header fields is based on the establishment of a
   function to a sequence number, called the master sequence number
   (MSN).  This function describes the change pattern of the field with
   respect to a change in the MSN.

   Change patterns include, for example, fields that increase
   monotonically or by a small value, fields that seldom change,and
   fields that remain unchanging for the entire lifetime of the packet
   flow, in which case the function to the MSN is equivalent to a
   constant value.

   The compressor first establishes functions for each of the header
   fields, and then reliably communicates the MSN.  When the change
   pattern of the field does not match the established function, i.e.,
   the existing function gives a result that is different from the field
   in the header being compressed, additional information can be sent to
   update the parameters of that function.

   The MSN is defined per profile.  It can be either derived directly
   from one of the fields of the protocol being compressed (e.g., the
   RTP SN [<a href="#ref-8" title='"RObust Header Compression Version 2 (ROHCv2): Profiles for RTP, UDP, IP, ESP, and UDP Lite"'>8</a>]), or it can be created and maintained by the compressor
   (e.g., the MSN for compression of UDP in profile 0x0102 [<a href="#ref-8" title='"RObust Header Compression Version 2 (ROHCv2): Profiles for RTP, UDP, IP, ESP, and UDP Lite"'>8</a>] or the
   MSN in ROHC-TCP [<a href="#ref-9" title='"RObust Header Compression (ROHC): A Profile for TCP/IP (ROHC-TCP)"'>9</a>]).

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/4.6.%20%20Static%20and%20Dynamic%20Parts%20of%20a%20Context"></a><a class="selflink" href="#section-4.6" id="section-4.6">4.6</a>.  Static and Dynamic Parts of a Context</span>

   A compression context can be conceptually divided into two different
   parts, the static context and the dynamic context, each based on the
   properties of the fields that are being compressed.






<span class="grey">Jonsson, et al.             Standards Track                    [Page 13]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-14"></span>
<span class="grey"><a href="./rfc4995">RFC 4995</a>                   The ROHC Framework                  July 2007</span>


   The static part includes the information necessary to compress and
   decompress the fields whose change behavior is classified as STATIC,
   STATIC-KNOWN, or STATIC-DEF (as described in <a href="#section-4.1">Section 4.1</a> above).

   The dynamic part includes the state maintained for all the other
   fields, i.e., those that are classified as CHANGING.

<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/5.%20%20The%20ROHC%20Framework%20%28Normative%29"></a><a class="selflink" href="#section-5" id="section-5">5</a>.  The ROHC Framework (Normative)</span>

   This section normatively defines the parts common to all ROHC
   profiles, i.e., the framework.  The framework specifies the
   requirements and functionality of the ROHC channel, including how to
   handle multiple compressed packet flows over the same channel.

   Finally, this section specifies encoding methods used in the packet
   formats that are common to all profiles.  These encoding methods may
   be reused within profile specifications for encoding fields in
   profile-specific parts of a packet format, without requiring their
   redefinition.

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/5.1.%20%20The%20ROHC%20Channel"></a><a class="selflink" href="#section-5.1" id="section-5.1">5.1</a>.  The ROHC Channel</span>

<span class="h4"><a class="dashAnchor" name="//apple_ref/cpp/Section/5.1.1.%20%20Contexts%20and%20Context%20Identifiers"></a><a class="selflink" href="#section-5.1.1" id="section-5.1.1">5.1.1</a>.  Contexts and Context Identifiers</span>

   Associated with each compressed flow is a context.  The context is
   the state that the compressor and the decompressor maintain in order
   to correctly compress or decompress the headers of the packet in the
   flow.  Each context is identified using a CID.

   A context is considered to be a new context when the CID is
   associated with a profile for the first time since the creation of
   the ROHC channel, or when the CID gets associated from the reception
   of an IR (this does not apply to the IR-DYN) with a different profile
   than the profile in the context.

   Context information is conceptually kept in a table.  The context
   table is indexed using the CID, which is sent along with compressed
   headers and feedback information.

   The CID space can be either small, which means that CIDs can take the
   values 0 through 15, or large, which means that CIDs take values
   between 0 and 2^14 - 1 = 16383.  Whether the CID space is large or
   small MUST be established, possibly by negotiation, before any
   compressed packet may be sent over the ROHC channel.

   The CID space is distinct for each channel, i.e., CID 3 over channel
   A and CID 3 over channel B do not refer to the same context, even if
   the endpoints of A and B are the same nodes.  In particular, CIDs for



<span class="grey">Jonsson, et al.             Standards Track                    [Page 14]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-15"></span>
<span class="grey"><a href="./rfc4995">RFC 4995</a>                   The ROHC Framework                  July 2007</span>


   any pair of ROHC channels are not related (two associated ROHC
   channels serving as feedback channels for one another do not even
   need to have CID spaces of the same size).

<span class="h4"><a class="dashAnchor" name="//apple_ref/cpp/Section/5.1.2.%20%20Per-Channel%20Parameters"></a><a class="selflink" href="#section-5.1.2" id="section-5.1.2">5.1.2</a>.  Per-Channel Parameters</span>

   The ROHC channel is based on a number of parameters that form part of
   the established channel state and the per-context state.  The state
   of the ROHC channel MUST be established before the first ROHC packet
   may be sent, which may be achieved using negotiation protocols
   provided by the link layer (see also [<a href="#ref-4" title='"Robust Header Compression (ROHC) over PPP"'>4</a>], which describes an option
   for negotiation of ROHC parameters for PPP).  This section describes
   some of this channel state information in an abstract way:

   LARGE_CIDS: Boolean; if false, the small CID representation (0 octets
      or 1 prefix octet, covering CID 0 to 15) is used; if true, the
      large CID representation (1 or 2 embedded CID octets covering CID
      0 to 16383) is used.  See also 5.1.1 and 5.2.1.3.

   MAX_CID: Non-negative integer; highest CID number to be used by the
      compressor (note that this parameter is not coupled to, but in
      effect further constrained by, LARGE_CIDS).  This value represents
      an agreement by the decompressor that it can provide sufficient
      memory resources to host at least MAX_CID+1 contexts; the
      decompressor MUST maintain established contexts within this space
      until either the CID gets re-used by the establishment of a new
      context, or until the channel is taken down.

   PROFILES: Set of non-negative integers, where each integer indicates
      a profile supported by both the compressor and the decompressor.
      A profile is identified by a 16-bit value, where the 8 LSB bits
      indicate the actual profile, and the 8 MSB bits indicate the
      variant of that profile.  The ROHC compressed header format
      identifies the profile used with only the 8 LSB bits; this means
      that if multiple variants of the same profile are available for a
      ROHC channel, the PROFILES set after negotiation MUST NOT include
      more than one variant of the same profile.  The compressor MUST
      NOT compress using a profile that is not in PROFILES.

   FEEDBACK_FOR: Optional reference to a ROHC channel in the opposite
      direction between the same compression endpoints.  If provided,
      this parameter indicates to which other ROHC channel any feedback
      sent on this ROHC channel refers (see [<a href="#ref-5" title='"RObust Header Compression (ROHC): Terminology and Channel Mapping Examples"'>5</a>]).

   MRRU: Non-negative integer.  Maximum Reconstructed Reception Unit.
      This is the size of the largest reconstructed unit in octets that
      the decompressor is expected to reassemble from segments (see
      <a href="#section-5.2.5">Section 5.2.5</a>).  This size includes the segmentation CRC.  If MRRU



<span class="grey">Jonsson, et al.             Standards Track                    [Page 15]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-16"></span>
<span class="grey"><a href="./rfc4995">RFC 4995</a>                   The ROHC Framework                  July 2007</span>


      is negotiated to be 0, segmentation MUST NOT be used on the
      channel, and received segments MUST be discarded by the
      decompressor.

<span class="h4"><a class="dashAnchor" name="//apple_ref/cpp/Section/5.1.3.%20%20Persistence%20of%20Decompressor%20Contexts"></a><a class="selflink" href="#section-5.1.3" id="section-5.1.3">5.1.3</a>.  Persistence of Decompressor Contexts</span>

   As part of the negotiated channel parameters, the compressor and
   decompressor have through the MAX_CID parameter agreed on the highest
   context identification (CID) number to be used.  By agreeing on the
   MAX_CID, the decompressor also agrees to provide memory resources to
   host at least MAX_CID+1 contexts, and an established context with a
   CID within this negotiated space SHOULD be kept by the decompressor
   until either the CID gets re-used, or the channel is taken down or
   re-negotiated.

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/5.2.%20%20ROHC%20Packets%20and%20Packet%20Types"></a><a class="selflink" href="#section-5.2" id="section-5.2">5.2</a>.  ROHC Packets and Packet Types</span>

   This section uses the following convention in the diagrams when
   representing various ROHC packet types, formats, and fields:

      - colons ":" indicate that the part is optional
      - slashes "/" indicate variable length

   The ROHC packet type indication scheme has been designed to provide
   optional padding, a feedback packet type, an optional Add-CID octet
   (which includes 4 bits of CID), and a simple segmentation and
   reassembly mechanism.

   The following packet types are reserved at the ROHC framework level:

      11100000 : Padding
      1110nnnn : Add-CID octet (nnnn=CID with values 0x1 through 0xF)
      11110    : Feedback
      11111000 : IR-DYN packet
      1111110  : IR packet
      1111111  : Segment

   Other packet types can be defined and used by individual profiles:

      0        : available (not reserved by ROHC framework)
      10       : available (not reserved by ROHC framework)
      110      : available (not reserved by ROHC framework)
      1111101  : available (not reserved by ROHC framework)
      11111001 : available (not reserved by ROHC framework)







<span class="grey">Jonsson, et al.             Standards Track                    [Page 16]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-17"></span>
<span class="grey"><a href="./rfc4995">RFC 4995</a>                   The ROHC Framework                  July 2007</span>


<span class="h4"><a class="dashAnchor" name="//apple_ref/cpp/Section/5.2.1.%20%20General%20Format%20of%20ROHC%20Packets"></a><a class="selflink" href="#section-5.2.1" id="section-5.2.1">5.2.1</a>.  General Format of ROHC Packets</span>

   A ROHC packet has the following general format:

    --- --- --- --- --- --- --- ---
   :           Padding             :
    --- --- --- --- --- --- --- ---
   :           Feedback            :
    --- --- --- --- --- --- --- ---
   :            Header             :
    --- --- --- --- --- --- --- ---
   :           Payload             :
    --- --- --- --- --- --- --- ---

   Padding: Any number (zero or more) of padding octets, where the
      format of a padding octet is as defined in <a href="#section-5.2.1.1">Section 5.2.1.1</a>.

   Feedback: Any number (zero or more) of feedback elements, where the
      format of a feedback element is as defined in <a href="#section-5.2.4.1">Section 5.2.4.1</a>.

   Header: Either a profile-specific CO header (see <a href="#section-5.2.1.3">Section 5.2.1.3</a>), an
      IR or IR-DYN header (see <a href="#section-5.2.2">Section 5.2.2</a>), or a ROHC Segment (see
      <a href="#section-5.2.5">Section 5.2.5</a>).  There can be at most one Header in a ROHC packet,
      but it may also be omitted (if the packet contains Feedback only).

   Payload: Corresponds to zero or more octets of payload from the
      uncompressed packet, starting with the first octet in the
      uncompressed packet after the last header compressible by the
      current profile.

   At least one of Feedback or Header MUST be present.

<span class="h5"><a class="dashAnchor" name="//apple_ref/cpp/Section/5.2.1.1.%20%20Format%20of%20the%20Padding%20Octet"></a><a class="selflink" href="#section-5.2.1.1" id="section-5.2.1.1">5.2.1.1</a>.  Format of the Padding Octet</span>

   Padding octet:

     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   | 1   1   1   0   0   0   0   0 |
   +---+---+---+---+---+---+---+---+

   Note: The Padding octet MUST NOT be interpreted as an Add-CID octet
   for CID 0.








<span class="grey">Jonsson, et al.             Standards Track                    [Page 17]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-18"></span>
<span class="grey"><a href="./rfc4995">RFC 4995</a>                   The ROHC Framework                  July 2007</span>


<span class="h5"><a class="dashAnchor" name="//apple_ref/cpp/Section/5.2.1.2.%20%20Format%20of%20the%20Add-CID%20Octet"></a><a class="selflink" href="#section-5.2.1.2" id="section-5.2.1.2">5.2.1.2</a>.  Format of the Add-CID Octet</span>

   Add-CID octet:

     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   | 1   1   1   0 |      CID      |
   +---+---+---+---+---+---+---+---+

   CID: 0x1 through 0xF indicates CIDs 1 through 15.

   Note: The Padding octet looks like an Add-CID octet for CID 0.

<span class="h5"><a class="dashAnchor" name="//apple_ref/cpp/Section/5.2.1.3.%20%20General%20Format%20of%20Header"></a><a class="selflink" href="#section-5.2.1.3" id="section-5.2.1.3">5.2.1.3</a>.  General Format of Header</span>

   All ROHC packet types have the following general Header format:

     0              x-1  x       7
    --- --- --- --- --- --- --- ---
   :         Add-CID octet         :  if CID 1-15 and small CIDs
   +--- --- --- --- ---+--- --- ---+
   | type indication   |   body    |  1 octet (8-x bits of body)
   +--- --- --- --- ---+--- --- ---+
   :                               :
   /    0, 1, or 2 octets of CID   /  1 or 2 octets if large CIDs
   :                               :
   +---+---+---+---+---+---+---+---+
   /             body              /  variable length
   +---+---+---+---+---+---+---+---+

   type indication: ROHC packet type.

   body: Interpreted according to the packet type indication and CID
      information, as defined by individual profiles.

   Thus, the header either starts with a packet type indication or has a
   packet type indication immediately following an Add-CID octet.

   When the ROHC channel is configured with a small CID space:

      o  If an Add-CID immediately precedes the packet type indication,
         the packet has the CID of the Add-CID; otherwise, it has CID 0.

      o  A small CID with the value 0 is represented using zero bits;
         therefore, a flow associated with CID 0 has no CID overhead in
         the compressed header.  In such case, Header starts with a
         packet type indication.




<span class="grey">Jonsson, et al.             Standards Track                    [Page 18]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-19"></span>
<span class="grey"><a href="./rfc4995">RFC 4995</a>                   The ROHC Framework                  July 2007</span>


      o  A small CID with a value from 1 to 15 is represented using the
         Add-CID octet as described above.  The Header starts with the
         Add-CID octet, followed by a packet type indication.

      o  There is no large CID in the Header.

   When the ROHC channel is configured with a large CID space:

      o  The large CID is always present and is represented using the
         encoding scheme of <a href="#section-5.3.2">Section 5.3.2</a>, limited to two octets.  In
         this case, the Header starts with a packet type indication.

<span class="h4"><a class="dashAnchor" name="//apple_ref/cpp/Section/5.2.2.%20%20Initialization%20and%20Refresh%20%28IR%29%20Packet%20Types"></a><a class="selflink" href="#section-5.2.2" id="section-5.2.2">5.2.2</a>.  Initialization and Refresh (IR) Packet Types</span>

   IR packet types contain a profile identifier, which determines how
   the rest of the header is to be interpreted.  They also associate a
   profile with a context.  The stored profile parameter further
   determines the syntax and semantics of the packet type identifiers
   and packet types used with a specific context.

   The IR and IR-DYN packets always update the context for all context-
   updating fields carried in the header.  They never clear the context,
   except when initializing a new context (see <a href="#section-5.1.1">Section 5.1.1</a>), or unless
   the profile indicated in the Profile field specifies otherwise.



























<span class="grey">Jonsson, et al.             Standards Track                    [Page 19]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-20"></span>
<span class="grey"><a href="./rfc4995">RFC 4995</a>                   The ROHC Framework                  July 2007</span>


<span class="h5"><a class="dashAnchor" name="//apple_ref/cpp/Section/5.2.2.1.%20%20ROHC%20IR%20Packet%20Type"></a><a class="selflink" href="#section-5.2.2.1" id="section-5.2.2.1">5.2.2.1</a>.  ROHC IR Packet Type</span>

   The IR header associates a CID with a profile, and typically also
   initializes the context.  It can typically also refresh all (or parts
   of) the context.  For IR, Header has the following general format:

     0   1   2   3   4   5   6   7
    --- --- --- --- --- --- --- ---
   :         Add-CID octet         :  if CID 1-15 and small CID
   +---+---+---+---+---+---+---+---+
   | 1   1   1   1   1   1   0 | x |  IR type octet
   +---+---+---+---+---+---+---+---+
   :                               :
   /      0-2 octets of CID        /  1 or 2 octets if large CIDs
   :                               :
   +---+---+---+---+---+---+---+---+
   |            Profile            |  1 octet
   +---+---+---+---+---+---+---+---+
   |              CRC              |  1 octet
   +---+---+---+---+---+---+---+---+
   |                               |
   / profile specific information  /  variable length
   |                               |
   +---+---+---+---+---+---+---+---+

   x: Profile specific information.  Interpreted according to the
      profile indicated in the Profile field of the IR header.

   Profile: The profile associated with the CID.  In the IR header, the
      profile identifier is abbreviated to the 8 least significant bits
      (see <a href="#section-5.1.2">Section 5.1.2</a>).

   CRC: 8-bit CRC (see <a href="#section-5.3.1.1">Section 5.3.1.1</a>).

   Profile specific information: The content of this part of the IR
      header is defined by the individual profiles.  It is interpreted
      according to the profile indicated in the Profile field.

<span class="h5"><a class="dashAnchor" name="//apple_ref/cpp/Section/5.2.2.2.%20%20ROHC%20IR-DYN%20Packet%20Type"></a><a class="selflink" href="#section-5.2.2.2" id="section-5.2.2.2">5.2.2.2</a>.  ROHC IR-DYN Packet Type</span>

   In contrast to the IR header, the IR-DYN header can never initialize
   a non-initialized context.  However, it can redefine what profile is
   associated with a context, if the profile indicated in the IR-DYN
   header allows this.  Thus, this packet type is also reserved at the
   framework level.  The IR-DYN header typically also initializes or
   refreshes parts of a context.  For IR-DYN, Header has the following
   general format:




<span class="grey">Jonsson, et al.             Standards Track                    [Page 20]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-21"></span>
<span class="grey"><a href="./rfc4995">RFC 4995</a>                   The ROHC Framework                  July 2007</span>


     0   1   2   3   4   5   6   7
    --- --- --- --- --- --- --- ---
   :         Add-CID octet         :  if CID 1-15 and small CID
   +---+---+---+---+---+---+---+---+
   | 1   1   1   1   1   0   0   0 |  IR-DYN type octet
   +---+---+---+---+---+---+---+---+
   :                               :
   /      0-2 octets of CID        /  1 or 2 octets if large CIDs
   :                               :
   +---+---+---+---+---+---+---+---+
   |            Profile            |  1 octet
   +---+---+---+---+---+---+---+---+
   |              CRC              |  1 octet
   +---+---+---+---+---+---+---+---+
   |                               |
   / profile specific information  /  variable length
   |                               |
   +---+---+---+---+---+---+---+---+

   Profile: The profile associated with the CID.  This is abbreviated in
      the same way as in IR packets.

   CRC: 8-bit CRC (see <a href="#section-5.3.1.1">Section 5.3.1.1</a>).

   Profile specific information: The content of this part of the IR-DYN
      header is defined by the individual profiles.  It is interpreted
      according to the profile indicated in the Profile field.

<span class="h4"><a class="dashAnchor" name="//apple_ref/cpp/Section/5.2.3.%20%20ROHC%20Initial%20Decompressor%20Processing"></a><a class="selflink" href="#section-5.2.3" id="section-5.2.3">5.2.3</a>.  ROHC Initial Decompressor Processing</span>

   Initially, all contexts are in no context state.  Thus, all packets
   referencing a non-initialized context, except packets that have
   enough information on the static fields, cannot be decompressed by
   the decompressor.

   When the decompressor receives a packet of type IR, the profile
   indicated in the IR packet determines how it is to be processed.

      o  If the 8-bit CRC fails to verify the integrity of the Header,
         the packet MUST NOT be decompressed and delivered to upper
         layers.  If a profile is indicated in the context, the logic of
         that profile determines what, if any, feedback is to be sent.
         If no profile is noted in the context, the logic used to
         determine what, if any, feedback to send is up to the
         implementation.  However, it may be suitable to take no further
         actions, as any part of the IR header covered by the CRC may
         have caused the failure.




<span class="grey">Jonsson, et al.             Standards Track                    [Page 21]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-22"></span>
<span class="grey"><a href="./rfc4995">RFC 4995</a>                   The ROHC Framework                  July 2007</span>


   When the decompressor receives a packet of type IR-DYN, the profile
   indicated in the IR-DYN packet determines how it is to be processed.

      o  If the 8-bit CRC fails to verify the integrity of the header,
         the packet MUST NOT be decompressed and delivered to upper
         layers.  If a profile is indicated in the context, the logic of
         that profile determines what, if any, feedback is to be sent.
         If no profile is noted in the context, the logic used to
         determine what, if any, feedback to send is up to the
         implementation.  However, it may be suitable to take no further
         actions, as any part of the IR-DYN header covered by the CRC
         may have caused the failure.

      o  If the context has not already been initialized, the packet
         MUST NOT be decompressed and delivered to upper layers.  The
         logic of the profile indicated in the IR-DYN header (if
         verified by the 8-bit CRC), determines what, if any, feedback
         is to be sent.

   If a parsing error occurs for any packet type, the decompressor MUST
   discard the packet without further processing.  For example, a CID
   field is present in the compressed header when the large CID space is
   used for the ROHC channel, and the field is coded using the self-
   describing variable-length encoding of <a href="#section-5.3.2">Section 5.3.2</a>; if the field
   starts with 110 or 111, this would generate a parsing error for the
   decompressor because this field must not be encoded with a size
   larger than 2 octets.

   It is RECOMMENDED that profiles disallow the decompressor to make a
   decompression attempt for packets carrying only a 3-bit CRC after it
   has invalidated some or all of the entire dynamic context, until a
   packet that contains sufficient information on the dynamic fields is
   received, decompressed, and successfully verified by a 7- or 8-bit
   CRC.

<span class="h4"><a class="dashAnchor" name="//apple_ref/cpp/Section/5.2.4.%20%20ROHC%20Feedback"></a><a class="selflink" href="#section-5.2.4" id="section-5.2.4">5.2.4</a>.  ROHC Feedback</span>

   Feedback carries information from the decompressor to compressor.
   Feedback can be sent over a ROHC channel that operates in the same
   direction as the feedback.

   The general ROHC packet format allows transport of feedback using
   interspersion or piggybacking (see [<a href="#ref-5" title='"RObust Header Compression (ROHC): Terminology and Channel Mapping Examples"'>5</a>]), or a combination of both,
   over a ROHC channel.  This is facilitated by the following
   properties:






<span class="grey">Jonsson, et al.             Standards Track                    [Page 22]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-23"></span>
<span class="grey"><a href="./rfc4995">RFC 4995</a>                   The ROHC Framework                  July 2007</span>


   Reserved packet type:

      A feedback packet type is reserved at the framework level.  The
      packet type can carry variable-length feedback information.

   CID information:

      The feedback information sent on a particular channel is passed
      to, and interpreted by, the compressor associated with feedback on
      that channel.  Thus, each feedback element contains CID
      information from the channel for which the feedback is sent.  The
      ROHC feedback scheme thus requires that a channel carries feedback
      to at most one compressor.  How a compressor is associated with
      the feedback for a particular channel is outside the scope of this
      specification.  See also [<a href="#ref-5" title='"RObust Header Compression (ROHC): Terminology and Channel Mapping Examples"'>5</a>].

   Length information:

      The length of a feedback element can be determined by examining
      the first few octets of the feedback.  This enables piggybacking
      of feedback, and also the concatenation of more than one feedback
      element in a packet.  The length information thus decouples the
      decompressor from the associated same-side compressor, as the
      decompressor can extract the feedback information from the
      compressed header without parsing its content and hand over the
      extracted information.

   The association between compressor-decompressor pairs operating in
   opposite directions, for the purpose of exchanging piggyback and/or
   interspersed feedback, SHOULD be maintained for the lifetime of the
   ROHC channel.  Otherwise, it is RECOMMENDED that the compressor be
   notified if the feedback channel is no longer available: the
   compressor SHOULD then restart compression by creating a new context
   for each packet flow, and SHOULD use a CID value that was not
   previously associated with the profile used to compress the flow.

<span class="h5"><a class="dashAnchor" name="//apple_ref/cpp/Section/5.2.4.1.%20%20ROHC%20Feedback%20Format"></a><a class="selflink" href="#section-5.2.4.1" id="section-5.2.4.1">5.2.4.1</a>.  ROHC Feedback Format</span>

   ROHC defines three different categories of feedback messages:
   acknowledgment (ACK), negative ACK (NACK), and NACK for the entire
   context (STATIC-NACK).  Other types of information may be defined in
   profile-specific feedback information.

   ACK         : Acknowledges successful decompression of a packet.
                 Indicates that the decompressor considers its context
                 to be valid.





<span class="grey">Jonsson, et al.             Standards Track                    [Page 23]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-24"></span>
<span class="grey"><a href="./rfc4995">RFC 4995</a>                   The ROHC Framework                  July 2007</span>


   NACK        : Indicates that the decompressor considers some or all
                 of the dynamic part of its context invalid.

   STATIC-NACK : Indicates that the decompressor considers its entire
                 static context invalid, or that it has not been
                 established.

   Feedback sent on a ROHC channel consists of one or more concatenated
   feedback elements, where each feedback element has the following
   format:

     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   | 1   1   1   1   0 |   Code    |  feedback type
   +---+---+---+---+---+---+---+---+
   :             Size              :  if Code = 0
   +---+---+---+---+---+---+---+---+
   :         Add-CID octet         :  if for small CIDs and (CID != 0)
   +---+---+---+---+---+---+---+---+
   :                               :
   /  large CID (5.3.2 encoding)   /  1-2 octets if for large CIDs
   :                               :
   +---+---+---+---+---+---+---+---+
   /         FEEDBACK data         /  variable length
   +---+---+---+---+---+---+---+---+

   Code: 0 indicates that a Size octet is present.
         1-7 indicates the size of the feedback data field, in octets.

   Size: Indicates the size of the feedback data field, in octets.

   FEEDBACK data: FEEDBACK-1 or FEEDBACK-2 (see below).

   CID information in a feedback element indicates the context for which
   feedback is sent.  The LARGE_CIDS parameter that controls whether a
   large CID is present is taken from the channel state of the receiving
   compressor's channel, not from the state of the channel carrying the
   feedback.

   The large CID field, if present, is encoded according to <a href="#section-5.3.2">Section</a>
   <a href="#section-5.3.2">5.3.2</a>, and it MUST NOT be encoded using more than 2 octets.










<span class="grey">Jonsson, et al.             Standards Track                    [Page 24]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-25"></span>
<span class="grey"><a href="./rfc4995">RFC 4995</a>                   The ROHC Framework                  July 2007</span>


   The FEEDBACK data field can have either of the following two formats:

   FEEDBACK-1:

     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   | profile specific information  |  1 octet
   +---+---+---+---+---+---+---+---+

   FEEDBACK-2:

     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   |Acktype|                       |
   +---+---+   profile specific    /  at least 2 octets
   /             information       |
   +---+---+---+---+---+---+---+---+

   Acktype:  0 = ACK
             1 = NACK
             2 = STATIC-NACK
             3 is reserved (MUST NOT be used.  Otherwise unparseable.)

<span class="h4"><a class="dashAnchor" name="//apple_ref/cpp/Section/5.2.5.%20%20ROHC%20Segmentation"></a><a class="selflink" href="#section-5.2.5" id="section-5.2.5">5.2.5</a>.  ROHC Segmentation</span>

   ROHC defines a simple segmentation protocol.  The compressor may
   perform segmentation, e.g., to accommodate packets that are larger
   than a specific size configured for the channel.

<span class="h5"><a class="dashAnchor" name="//apple_ref/cpp/Section/5.2.5.1.%20%20Segmentation%20Usage%20Considerations"></a><a class="selflink" href="#section-5.2.5.1" id="section-5.2.5.1">5.2.5.1</a>.  Segmentation Usage Considerations</span>

   The ROHC segmentation protocol is not particularly efficient.  It is
   not intended to replace link layer segmentation functions; these
   SHOULD be used whenever available and efficient for the task at hand.

   The ROHC segmentation protocol has been designed with an assumption
   of in-order delivery of packets between the compressor and the
   decompressor, using only a CRC for error detection, and no sequence
   numbers.  If in-order delivery cannot be guaranteed, ROHC
   segmentation MUST NOT be used.

   The segmentation protocol also assumes that all segments of a ROHC
   packet corresponding to one context are received without interference
   from other ROHC packets over the channel, including any ROHC packet
   corresponding to a different context.  Based on this assumption,
   segments do not carry CID information, and therefore cannot be
   associated with a specific context until all segments have been
   received and the whole unit has been reconstructed.



<span class="grey">Jonsson, et al.             Standards Track                    [Page 25]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-26"></span>
<span class="grey"><a href="./rfc4995">RFC 4995</a>                   The ROHC Framework                  July 2007</span>


<span class="h5"><a class="dashAnchor" name="//apple_ref/cpp/Section/5.2.5.2.%20%20Segmentation%20Protocol"></a><a class="selflink" href="#section-5.2.5.2" id="section-5.2.5.2">5.2.5.2</a>.  Segmentation Protocol</span>

   ROHC segmentation is applied to the combination of the Header and the
   Payload fields of the ROHC packet, as defined in <a href="#section-5.2.1">Section 5.2.1</a>.

   Segment format:

     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   | 1   1   1   1   1   1   1 | F |  segment type
   +---+---+---+---+---+---+---+---+
   /           Segment             /  variable length
   +---+---+---+---+---+---+---+---+

   F: Final bit.  If set, it indicates that this is the last segment of
      a reconstructed unit.

   Padding and/or Feedback may precede the segment type octet.  There is
   no per-segment CID, but CID information is of course part of the
   reconstructed unit.  The reconstructed unit MUST NOT contain padding,
   segments, or feedback.

   When a final segment is received, the decompressor reassembles the
   segment carried in this packet and any non-final segments that
   immediately preceded it into a single reconstructed unit, in the
   order they were received.  All segments for one reconstructed unit
   have to be received consecutively and in the correct order by the
   decompressor.  If a non-segment ROHC packet directly follows a non-
   final segment, the reassembly of the current reconstructed unit is
   aborted and the decompressor MUST discard the non-final segments so
   far received on this channel.

   Reconstructed unit:

     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   /            Header             /  (see <a href="#section-5.2.1">Section 5.2.1</a>)
   +---+---+---+---+---+---+---+---+
   :            Payload            :  (see <a href="#section-5.2.1">Section 5.2.1</a>)
   +---+---+---+---+---+---+---+---+
   /              CRC              /  4 octets
   +---+---+---+---+---+---+---+---+

   CRC: 32-bit CRC computed using the polynomial of <a href="#section-5.3.1.4">Section 5.3.1.4</a>.

   If the reconstructed unit is 4 octets or less, or if the CRC fails,
   or if it is larger than the channel parameter MRRU (see Section




<span class="grey">Jonsson, et al.             Standards Track                    [Page 26]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-27"></span>
<span class="grey"><a href="./rfc4995">RFC 4995</a>                   The ROHC Framework                  July 2007</span>


   5.1.2), the reconstructed unit MUST be discarded by the decompressor.
   If the CRC succeeds, the reconstructed unit can be further processed.

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/5.3.%20%20General%20Encoding%20Methods"></a><a class="selflink" href="#section-5.3" id="section-5.3">5.3</a>.  General Encoding Methods</span>

<span class="h4"><a class="dashAnchor" name="//apple_ref/cpp/Section/5.3.1.%20%20Header%20Compression%20CRCs%2C%20Coverage%20and%20Polynomials"></a><a class="selflink" href="#section-5.3.1" id="section-5.3.1">5.3.1</a>.  Header Compression CRCs, Coverage and Polynomials</span>

   This section describes how to calculate the CRCs used by ROHC.  For
   all CRCs, the algorithm used to calculate the CRC is the same as the
   one used in [<a href="#ref-2" title='"PPP in HDLC-like Framing"'>2</a>], defined in <a href="#appendix-A">Appendix A</a> of this document, with the
   polynomials specified in subsequent sections.

<span class="h5"><a class="dashAnchor" name="//apple_ref/cpp/Section/5.3.1.1.%20%208-bit%20CRCs%20in%20IR%20and%20IR-DYN%20Headers"></a><a class="selflink" href="#section-5.3.1.1" id="section-5.3.1.1">5.3.1.1</a>.  8-bit CRCs in IR and IR-DYN Headers</span>

   The coverage for the 8-bit CRC in the IR and IR-DYN headers is
   profile-dependent, but it MUST cover at least the initial part of the
   header ending with the Profile field, including the CID or an Add-CID
   octet.  Feedback and padding are not part of Header (<a href="#section-5.2.1">Section 5.2.1</a>)
   and are thus not included in the CRC calculation.  As a rule of thumb
   for profile specifications, any other information that initializes
   the decompressor context SHOULD also be covered by a CRC.

   More specifically, the 8-bit CRC does not cover only and entirely the
   original uncompressed header; therefore, it does not provide the
   means for the decompressor to verify a decompression attempt, or the
   means to verify the correctness of the entire decompressor context.
   However, when successful, it does provide enough robustness for the
   decompressor to update its context with the information carried
   within the IR or the IR-DYN header.

   The CRC polynomial for the 8-bit CRC is:

      C(x) = 1 + x + x^2 + x^8

   When computing the CRC, the CRC field in the header is set to zero,
   and the initial content of the CRC register is set to all 1's.

<span class="h5"><a class="dashAnchor" name="//apple_ref/cpp/Section/5.3.1.2.%20%203-bit%20CRC%20in%20Compressed%20Headers"></a><a class="selflink" href="#section-5.3.1.2" id="section-5.3.1.2">5.3.1.2</a>.  3-bit CRC in Compressed Headers</span>

   The 3-bit CRC in compressed headers is calculated over all octets of
   the entire original header, before compression, in the following
   manner.

   The initial content of the CRC register is set to all 1's.

   The polynomial for the 3-bit CRC is:

      C(x) = 1 + x + x^3



<span class="grey">Jonsson, et al.             Standards Track                    [Page 27]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-28"></span>
<span class="grey"><a href="./rfc4995">RFC 4995</a>                   The ROHC Framework                  July 2007</span>


   The purpose of the 3-bit CRC is to provide the means for the
   decompressor to verify the outcome of a decompression attempt for
   small compressed headers, and to detect context damage based on
   aggregated probability over a number of decompression attempts.  It
   is however too weak to provide enough success guarantees from the
   decompression of one single header.  Therefore, compressed headers
   carrying a 3-bit CRC are normally not suitable to perform context
   repairs at the decompressor; hence, profiles should refrain from
   allowing decompression of such a header when some or the entire
   decompressor context is assumed invalid.

<span class="h5"><a class="dashAnchor" name="//apple_ref/cpp/Section/5.3.1.3.%20%207-bit%20CRC%20in%20Compressed%20Headers"></a><a class="selflink" href="#section-5.3.1.3" id="section-5.3.1.3">5.3.1.3</a>.  7-bit CRC in Compressed Headers</span>

   The 7-bit CRC in compressed headers is calculated over all octets of
   the entire original header, before compression, in the following
   manner.

   The initial content of the CRC register is set to all 1's.

   The polynomial for the 7-bit CRC is:

      C(x) = 1 + x + x^2 + x^3 + x^6 + x^7

   The purpose of the 7-bit CRC is to provide the means for the
   decompressor to verify the outcome of a decompression attempt for a
   larger compressed header, and to provide enough protection to
   validate a context repair at the decompressor.  The 7-bit CRC is
   strong enough to assume a repair to be successful from the
   decompression of one single header; hence, profiles may allow
   decompression of a header carrying a 7-bit CRC when some of the
   decompressor context is assumed invalid.

<span class="h5"><a class="dashAnchor" name="//apple_ref/cpp/Section/5.3.1.4.%20%2032-bit%20Segmentation%20CRC"></a><a class="selflink" href="#section-5.3.1.4" id="section-5.3.1.4">5.3.1.4</a>.  32-bit Segmentation CRC</span>

   The 32-bit CRC is used by the segmentation scheme to verify the
   reconstructed unit, and it is thus calculated over the segmented
   unit, i.e., over the Header and the Payload fields of the ROHC
   packet.

   The initial content of the CRC register is set to all 1's.

   The polynomial for the 32-bit CRC is:

      C(x) = x^0 + x^1 + x^2 + x^4 + x^5 + x^7 + x^8 + x^10 +
             x^11 + x^12 + x^16 + x^22 + x^23 + x^26 + x^32.

   The purpose of the 32-bit CRC is to verify the reconstructed unit.




<span class="grey">Jonsson, et al.             Standards Track                    [Page 28]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-29"></span>
<span class="grey"><a href="./rfc4995">RFC 4995</a>                   The ROHC Framework                  July 2007</span>


<span class="h4"><a class="dashAnchor" name="//apple_ref/cpp/Section/5.3.2.%20%20Self-Describing%20Variable-Length%20Values"></a><a class="selflink" href="#section-5.3.2" id="section-5.3.2">5.3.2</a>.  Self-Describing Variable-Length Values</span>

   The values of many fields and compression parameters can vary widely.
   To optimize the transfer of such values, a variable number of octets
   are used to encode them.  The first few bits of the first octet
   determine the number of octets used:

   First bit is 0: 1 octet.
            7 bits transferred.
            Up to 127 decimal.
            Encoded octets in hexadecimal: 00 to 7F

   First bits are 10: 2 octets.
            14 bits transferred.
            Up to 16 383 decimal.
            Encoded octets in hexadecimal: 80 00 to BF FF

   First bits are 110: 3 octets.
            21 bits transferred.
            Up to 2 097 151 decimal.
            Encoded octets in hexadecimal: C0 00 00 to DF FF FF

   First bits are 111: 4 octets.
            29 bits transferred.
            Up to 536 870 911 decimal.
            Encoded octets in hexadecimal: E0 00 00 00 to FF FF FF FF

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/5.4.%20%20ROHC%20UNCOMPRESSED%20--%20No%20Compression"></a><a class="selflink" href="#section-5.4" id="section-5.4">5.4</a>.  ROHC UNCOMPRESSED -- No Compression  </span>(Profile 0x0000)

   This section describes the uncompressed ROHC profile.  The profile
   identifier for this profile is 0x0000.

   Profile 0x0000 provides a way to send IP packets without compressing
   them.  This can be used for any packet for which a compression
   profile is not available in the set of profiles supported by the ROHC
   channel, or for which compression is not desirable for some reason.

   After initialization, the only overhead for sending packets using
   Profile 0x0000 is the size of the CID.  When uncompressed packets are
   frequent, Profile 0x0000 should be associated with a CID the size of
   zero or one octet.  Profile 0x0000 SHOULD be associated with at most
   one CID.









<span class="grey">Jonsson, et al.             Standards Track                    [Page 29]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-30"></span>
<span class="grey"><a href="./rfc4995">RFC 4995</a>                   The ROHC Framework                  July 2007</span>


<span class="h4"><a class="dashAnchor" name="//apple_ref/cpp/Section/5.4.1.%20%20IR%20Packet"></a><a class="selflink" href="#section-5.4.1" id="section-5.4.1">5.4.1</a>.  IR Packet</span>

   The initialization and refresh packet (IR packet) for Profile 0x0000
   has the following Header format:

     0   1   2   3   4   5   6   7
    --- --- --- --- --- --- --- ---
   :         Add-CID octet         : if for small CIDs and (CID != 0)
   +---+---+---+---+---+---+---+---+
   | 1   1   1   1   1   1   0 |res|
   +---+---+---+---+---+---+---+---+
   :                               :
   /    0-2 octets of CID info     / 1-2 octets if for large CIDs
   :                               :
   +---+---+---+---+---+---+---+---+
   |         Profile = 0x00        | 1 octet
   +---+---+---+---+---+---+---+---+
   |              CRC              | 1 octet
   +---+---+---+---+---+---+---+---+

   res: MUST be set to zero; otherwise, the decompressor MUST discard
        the packet.

   Profile: 0x00

   CRC: 8-bit CRC, computed using the polynomial of <a href="#section-5.3.1.1">Section 5.3.1.1</a>.
        The CRC covers the first octet of the IR Header through the
        Profile octet of the IR Header, i.e., it does not cover the CRC
        itself.  Neither does it cover any preceding Padding or
        Feedback, nor the Payload.

   For the IR packet, Payload has the following format:

    --- --- --- --- --- --- --- ---
   :                               : (optional)
   /           IP packet           / variable length
   :                               :
    --- --- --- --- --- --- --- ---

   IP packet: An uncompressed IP packet may be included in the IR
      packet.  The decompressor determines if the IP packet is present
      by considering the length of the IR packet.









<span class="grey">Jonsson, et al.             Standards Track                    [Page 30]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-31"></span>
<span class="grey"><a href="./rfc4995">RFC 4995</a>                   The ROHC Framework                  July 2007</span>


<span class="h4"><a class="dashAnchor" name="//apple_ref/cpp/Section/5.4.2.%20%20Normal%20Packet"></a><a class="selflink" href="#section-5.4.2" id="section-5.4.2">5.4.2</a>.  Normal Packet</span>

   A Normal packet is a normal IP packet plus CID information.  For the
   Normal Packet, the following format corresponds to the Header and
   Payload (as defined in <a href="#section-5.2.1">Section 5.2.1</a>):

     0   1   2   3   4   5   6   7
    --- --- --- --- --- --- --- ---
   :         Add-CID octet         : if for small CIDs and (CID != 0)
   +---+---+---+---+---+---+---+---+
   |   first octet of IP packet    |
   +---+---+---+---+---+---+---+---+
   :                               :
   /    0-2 octets of CID info     / 1-2 octets if for large CIDs
   :                               :
   +---+---+---+---+---+---+---+---+
   |                               |
   /       rest of IP packet       / variable length
   |                               |
   +---+---+---+---+---+---+---+---+

   Note that the first octet of the IP packet starts with the bit
   pattern 0100 (IPv4) or 0110 (IPv6).  This does not conflict with any
   reserved packet types.

   When the channel uses small CIDs, and profile 0x0000 is associated
   with a CID &gt; 0, an Add-CID octet precedes the IP packet.  When the
   channel uses large CIDs, the CID is placed so that it starts at the
   second octet of the combined Header/Payload format above.

   A Normal Packet may carry Padding and/or Feedback as any other ROHC
   packet, preceding the combined Header/Payload.

<span class="h4"><a class="dashAnchor" name="//apple_ref/cpp/Section/5.4.3.%20%20Decompressor%20Operation"></a><a class="selflink" href="#section-5.4.3" id="section-5.4.3">5.4.3</a>.  Decompressor Operation</span>

   When an IR packet is received, the decompressor first validates its
   header using the 8-bit CRC.

   o  If the header fails validation, the decompressor MUST NOT deliver
      the IP packet to upper layers.

   o  If the header is successfully validated, the decompressor

         1) initializes the context if it has no valid context for the
            given CID already associated to the specified profile,

         2) delivers the IP packet to upper layers if present,




<span class="grey">Jonsson, et al.             Standards Track                    [Page 31]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-32"></span>
<span class="grey"><a href="./rfc4995">RFC 4995</a>                   The ROHC Framework                  July 2007</span>


         3) MAY send an ACK.

   When any other packet is received while the decompressor has no
   context, it is discarded without further action.

   When a Normal packet is received and the decompressor has a valid
   context, the IP packet is extracted and delivered to upper layers.

<span class="h4"><a class="dashAnchor" name="//apple_ref/cpp/Section/5.4.4.%20%20Feedback"></a><a class="selflink" href="#section-5.4.4" id="section-5.4.4">5.4.4</a>.  Feedback</span>

   The only kind of feedback defined by Profile 0x0000 is ACK, using the
   FEEDBACK-1 format of <a href="#section-5.2.4.1">Section 5.2.4.1</a>, where the value of the profile-
   specific octet in the FEEDBACK-1 is 0 (zero).  The FEEDBACK-2 format
   is thus not defined for Profile 0x0000.

<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/6.%20%20Overview%20of%20a%20ROHC%20Profile%20%28Informative%29"></a><a class="selflink" href="#section-6" id="section-6">6</a>.  Overview of a ROHC Profile (Informative)</span>

   The ROHC protocol consists of a framework part and a profile part.
   The framework defines the mechanisms common to all profiles, while
   the profile defines the compression algorithm and profile specific
   packet formats.

   <a href="#section-5">Section 5</a> specifies the details of the ROHC framework.  This section
   provides an informative overview of the elements that make a profile
   specification.  The normative specification of individual profiles is
   outside the scope of this document.

   A ROHC profile defines the elements that build up the compression
   protocol.  A ROHC profile consists of:

   Packet formats:

   o  Bits-on-the-wire

      The profile defines the layout of the bits for profile-specific
      packet types that it defines, and for the profile-specific parts
      of packet types common to all profiles (e.g., IR and IR-DYN).

   o  Field encodings

      Bits and groups of bits from the packet format layout, referred to
      as Compressed fields, represents the result of an encoding method
      specific for that compressed field within a specific packet
      format.  The profile defines these encoding methods.







<span class="grey">Jonsson, et al.             Standards Track                    [Page 32]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-33"></span>
<span class="grey"><a href="./rfc4995">RFC 4995</a>                   The ROHC Framework                  July 2007</span>


   o  Updating properties

      The profile-specific packet formats may update the state of the
      decompressor, and may do so in different ways.  The profile
      defines how individual profile-specific fields, or entire
      profile-specific packet types, update the decompressor context.

   o  Verification

      Packets that update the state of the decompressor are verified to
      prevent incorrect updates to the decompressor context.  The
      profile defines the mechanisms used to verify the decompression of
      a packet.

   Context management:

   o  Robustness logic

      Packets may be lost or reordered between the compressor and the
      decompressor.  The profile defines mechanism to minimize the
      impacts of such events and prevent damage propagation.

   o  Repair mechanism

      Despite the robustness logic, impairment events may still lead to
      decompression failure(s), and even to context damage at the
      decompressor.  The profile defines context repair mechanisms,
      including feedback logic if used.

<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/7.%20%20Security%20Considerations"></a><a class="selflink" href="#section-7" id="section-7">7</a>.  Security Considerations</span>

   Because encryption eliminates the redundancy that header compression
   schemes try to exploit, there is some inducement to forego encryption
   of headers in order to enable operation over low-bandwidth links.

   A malfunctioning or malicious header compressor could cause the
   header decompressor to reconstitute packets that do not match the
   original packets but still have valid headers and possibly also valid
   transport checksums.  Such corruption may be detected with end-to-end
   authentication and integrity mechanisms, which will not be affected
   by the compression.  Moreover, the ROHC header compression scheme
   uses an internal checksum for verification of reconstructed headers,
   which reduces the probability of producing decompressed headers not
   matching the original ones without this being noticed.

   Denial-of-service attacks are possible if an intruder can introduce,
   for example, bogus IR, IR-DYN, or FEEDBACK packets onto the link and
   thereby cause compression efficiency to be reduced.  However, an



<span class="grey">Jonsson, et al.             Standards Track                    [Page 33]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-34"></span>
<span class="grey"><a href="./rfc4995">RFC 4995</a>                   The ROHC Framework                  July 2007</span>


   intruder having the ability to inject arbitrary packets at the link
   layer in this manner raises additional security issues that dwarf
   those related to the use of header compression.

<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/8.%20%20IANA%20Considerations"></a><a class="selflink" href="#section-8" id="section-8">8</a>.  IANA Considerations</span>

   An IANA registry for "RObust Header Compression (ROHC) Profile
   Identifiers" [<a href="#ref-21" title='"RObust Header Compression (ROHC) Profile Identifiers"'>21</a>] was created by <a href="./rfc3095">RFC 3095</a> [<a href="#ref-3" title='"RObust Header Compression (ROHC): Framework and four profiles: RTP, UDP, ESP, and uncompressed"'>3</a>].  The assignment
   policy, as outlined by <a href="./rfc3095">RFC 3095</a>, is the following:

   The ROHC profile identifier is a non-negative integer.  In many
   negotiation protocols, it will be represented as a 16-bit value.  Due
   to the way the profile identifier is abbreviated in ROHC packets, the
   8 least significant bits of the profile identifier have a special
   significance: Two profile identifiers with identical 8 LSBs should be
   assigned only if the higher-numbered one is intended to supersede the
   lower-numbered one.  To highlight this relationship, profile
   identifiers should be given in hexadecimal (as in 0x1234, which would
   for example supersede 0x0A34).

   Following the policies outlined in [<a href="#ref-22" title="">22</a>], the IANA policy for
   assigning new values for the profile identifier shall be
   Specification Required: values and their meanings must be documented
   in an RFC or in some other permanent and readily available reference,
   in sufficient detail that interoperability between independent
   implementations is possible.  In the 8 LSBs, the range 0 to 127 is
   reserved for IETF standard-track specifications; the range 128 to 254
   is available for other specifications that meet this requirement
   (such as Informational RFCs).  The LSB value 255 is reserved for
   future extensibility of the present specification.

   The following profile identifiers have so far been allocated:

   Profile Identifier    Usage                      Reference
   ------------------    ----------------------     ---------
   0x0000                ROHC uncompressed          <a href="./rfc4995">RFC 4995</a>
   0x0001                ROHC RTP                   <a href="./rfc3095">RFC 3095</a>
   0x0002                ROHC UDP                   <a href="./rfc3095">RFC 3095</a>
   0x0003                ROHC ESP                   <a href="./rfc3095">RFC 3095</a>
   0x0004                ROHC IP                    <a href="./rfc3843">RFC 3843</a>
   0x0005                ROHC LLA                   <a href="./rfc3242">RFC 3242</a>
   0x0105                ROHC LLA with R-mode       <a href="./rfc3408">RFC 3408</a>
   0x0006                ROHC TCP                   <a href="./rfc4996">RFC 4996</a>
   0x0007                ROHC RTP/UDP-Lite          <a href="./rfc4019">RFC 4019</a>
   0x0008                ROHC UDP-Lite              <a href="./rfc4019">RFC 4019</a>

   New profiles will need new identifiers to be assigned by the IANA,
   but this document does not require any additional IANA action.



<span class="grey">Jonsson, et al.             Standards Track                    [Page 34]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-35"></span>
<span class="grey"><a href="./rfc4995">RFC 4995</a>                   The ROHC Framework                  July 2007</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/9.%20%20Acknowledgments"></a><a class="selflink" href="#section-9" id="section-9">9</a>.  Acknowledgments</span>

   The authors would like to acknowledge all who have contributed to
   previous ROHC work, and especially to the authors of <a href="./rfc3095">RFC 3095</a> [<a href="#ref-3" title='"RObust Header Compression (ROHC): Framework and four profiles: RTP, UDP, ESP, and uncompressed"'>3</a>],
   which is the technical basis for this document.  Thanks also to the
   various individuals who contributed to the <a href="./rfc3095">RFC 3095</a> corrections and
   clarifications document [<a href="#ref-6" title='"RObust Header Compression (ROHC): Corrections and Clarifications to RFC 3095"'>6</a>], from which technical contents, when
   applicable, have been incorporated into this document.  Committed WG
   document reviewers were Carl Knutsson and Biplab Sarkar, who reviewed
   the document during working group last-call.

<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/10.%20%20References"></a><a class="selflink" href="#section-10" id="section-10">10</a>.  References</span>

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/10.1.%20%20Normative%20References"></a><a class="selflink" href="#section-10.1" id="section-10.1">10.1</a>.  Normative References</span>

   [<a id="ref-1">1</a>]  Bradner, S., "Key words for use in RFCs to Indicate Requirement
        Levels", <a href="https://www.rfc-editor.org/bcp/bcp14">BCP 14</a>, <a href="./rfc2119">RFC 2119</a>, March 1997.

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/10.2.%20%20Informative%20References"></a><a class="selflink" href="#section-10.2" id="section-10.2">10.2</a>.  Informative References</span>

   [<a id="ref-2">2</a>]  Simpson, W., "PPP in HDLC-like Framing", STD 51, <a href="./rfc1662">RFC 1662</a>, July
        1994.

   [<a id="ref-3">3</a>]  Bormann, C., Burmeister, C., Degermark, M., Fukushima, H.,
        Hannu, H., Jonsson, L-E., Hakenberg, R., Koren, T., Le, K., Liu,
        Z., Martensson, A., Miyazaki, A., Svanbro, K., Wiebke, T.,
        Yoshimura, T., and H. Zheng, "RObust Header Compression (ROHC):
        Framework and four profiles: RTP, UDP, ESP, and uncompressed",
        <a href="./rfc3095">RFC 3095</a>, July 2001.

   [<a id="ref-4">4</a>]  Bormann, C., "Robust Header Compression (ROHC) over PPP", <a href="./rfc3241">RFC</a>
        <a href="./rfc3241">3241</a>, April 2002.

   [<a id="ref-5">5</a>]  Jonsson, L-E., "RObust Header Compression (ROHC): Terminology
        and Channel Mapping Examples", <a href="./rfc3759">RFC 3759</a>, April 2004.

   [<a id="ref-6">6</a>]  Jonsson, L-E., Sandlund, K., Pelletier, G., and P. Kremer,
        "RObust Header Compression (ROHC): Corrections and
        Clarifications to <a href="./rfc3095">RFC 3095</a>", <a href="./rfc4815">RFC 4815</a>, February 2007.

   [<a id="ref-7">7</a>]  Pelletier, G., Jonsson, L-E., and K. Sandlund, "RObust Header
        Compression (ROHC): ROHC over Channels That Can Reorder
        Packets", <a href="./rfc4224">RFC 4224</a>, January 2006.

   [<a id="ref-8">8</a>]  Pelletier, G. and K. Sandlund, "RObust Header Compression
        Version 2 (ROHCv2): Profiles for RTP, UDP, IP, ESP, and UDP
        Lite", Work in Progress, September 2006.




<span class="grey">Jonsson, et al.             Standards Track                    [Page 35]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-36"></span>
<span class="grey"><a href="./rfc4995">RFC 4995</a>                   The ROHC Framework                  July 2007</span>


   [<a id="ref-9">9</a>]  Pelletier, G., Sandlund, K., Jonsson, L-E., and M. West, "RObust
        Header Compression (ROHC): A Profile for TCP/IP (ROHC-TCP)", <a href="./rfc4996">RFC</a>
        <a href="./rfc4996">4996</a>, July 2007.

   [<a id="ref-10">10</a>] Postel, J., "Internet Protocol", STD 5, <a href="./rfc791">RFC 791</a>, September 1981.

   [<a id="ref-11">11</a>] Deering, S. and R. Hinden, "Internet Protocol, Version 6 (IPv6)
        Specification", <a href="./rfc2460">RFC 2460</a>, December 1998.

   [<a id="ref-12">12</a>] Postel, J., "User Datagram Protocol", STD 6, <a href="./rfc768">RFC 768</a>, August
        1980.

   [<a id="ref-13">13</a>] Schulzrinne, H., Casner, S., Frederick, R., and V. Jacobson,
        "RTP: A Transport Protocol for Real-Time Applications", STD 64,
        <a href="./rfc3550">RFC 3550</a>, July 2003.

   [<a id="ref-14">14</a>] Postel, J., "Transmission Control Protocol", STD 7, <a href="./rfc793">RFC 793</a>,
        September 1981.

   [<a id="ref-15">15</a>] Jacobson, V., "Compressing TCP/IP headers for low-speed serial
        links", <a href="./rfc1144">RFC 1144</a>, February 1990.

   [<a id="ref-16">16</a>] Degermark, M., Nordgren, B., and S. Pink, "IP Header
        Compression", <a href="./rfc2507">RFC 2507</a>, February 1999.

   [<a id="ref-17">17</a>] Casner, S. and V. Jacobson, "Compressing IP/UDP/RTP Headers for
        Low-Speed Serial Links", <a href="./rfc2508">RFC 2508</a>, February 1999.

   [<a id="ref-18">18</a>] Degermark, M., "Requirements for robust IP/UDP/RTP header
        compression", <a href="./rfc3096">RFC 3096</a>, July 2001.

   [<a id="ref-19">19</a>] Koren, T., Casner, S., Geevarghese, J., Thompson, B., and P.
        Ruddy, "Enhanced Compressed RTP (CRTP) for Links with High
        Delay, Packet Loss and Reordering", <a href="./rfc3545">RFC 3545</a>, July 2003.

   [<a id="ref-20">20</a>] Degermark, M., Hannu, H., Jonsson, L.E., and K. Svanbro,
        "Evaluation of CRTP Performance over Cellular Radio Networks",
        IEEE Personal Communication Magazine, Volume 7, number 4, pp.
        20-25, August 2000.

   [<a id="ref-21">21</a>] IANA registry, "RObust Header Compression (ROHC) Profile
        Identifiers", <a href="http://www.iana.org/assignments/rohc-pro-ids">http://www.iana.org/assignments/rohc-pro-ids</a>

   [<a id="ref-22">22</a>] Narten, T. and H. Alvestrand, "Guidelines for Writing an IANA
        Considerations Section in RFCs", <a href="https://www.rfc-editor.org/bcp/bcp26">BCP 26</a>, <a href="./rfc2434">RFC 2434</a>, October 1998.






<span class="grey">Jonsson, et al.             Standards Track                    [Page 36]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-37"></span>
<span class="grey"><a href="./rfc4995">RFC 4995</a>                   The ROHC Framework                  July 2007</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/Appendix%20A.%20%20CRC%20Algorithm"></a><a class="selflink" href="#appendix-A" id="appendix-A">Appendix A</a>.  CRC Algorithm</span>

   #!/usr/bin/perl -w
   use strict;
   #=================================
   #
   # ROHC CRC demo - Carsten Bormann cabo@tzi.org 2001-08-02
   #
   # This little demo shows the four types of CRC in use in <a href="./rfc3095">RFC 3095</a>,
   # the specification for robust header compression.  Type your data in
   # hexadecimal form and then press Control+D.
   #
   #---------------------------------
   #
   # utility
   #
   sub dump_bytes($) {
       my $x = shift;
       my $i;
       for ($i = 0; $i &lt; length($x); ) {
     printf("%02x ", ord(substr($x, $i, 1)));
     printf("\n") if (++$i % 16 == 0);
       }
       printf("\n") if ($i % 16 != 0);
   }

   #---------------------------------
   #
   # The CRC calculation algorithm.
   #
   sub do_crc($$$) {
       my $nbits = shift;
       my $poly = shift;
       my $string = shift;

       my $crc = ($nbits == 32 ? 0xffffffff : (1 &lt;&lt; $nbits) - 1);
       for (my $i = 0; $i &lt; length($string); ++$i) {
         my $byte = ord(substr($string, $i, 1));
         for( my $b = 0; $b &lt; 8; $b++ ) {
           if (($crc &amp; 1) ^ ($byte &amp; 1)) {
             $crc &gt;&gt;= 1;
             $crc ^= $poly;
           } else {
           $crc &gt;&gt;= 1;
           }
           $byte &gt;&gt;= 1;
         }
       }



<span class="grey">Jonsson, et al.             Standards Track                    [Page 37]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-38"></span>
<span class="grey"><a href="./rfc4995">RFC 4995</a>                   The ROHC Framework                  July 2007</span>


       printf "%2d bits, ", $nbits;
       printf "CRC: %02x\n", $crc;
   }

   #---------------------------------
   #
   # Test harness
   #
   $/ = undef;
   $_ = &lt;&gt;;         # read until EOF
   my $string = ""; # extract all that looks hex:
   s/([0-9a-fA-F][0-9a-fA-F])/$string .= chr(hex($1)), ""/eg;
   dump_bytes($string);

   #---------------------------------
   #
   # 32-bit segmentation CRC
   # Note that the text implies this is complemented like for PPP
   # (this differs from 8, 7, and 3-bit CRC)
   #
   #      C(x) = x^0 + x^1 + x^2 + x^4 + x^5 + x^7 + x^8 + x^10 +
   #             x^11 + x^12 + x^16 + x^22 + x^23 + x^26 + x^32
   #
   do_crc(32, 0xedb88320, $string);

   #---------------------------------
   #
   # 8-bit IR/IR-DYN CRC
   #
   #      C(x) = x^0 + x^1 + x^2 + x^8
   #
   do_crc(8, 0xe0, $string);

   #---------------------------------
   #
   # 7-bit FO/SO CRC
   #
   #      C(x) = x^0 + x^1 + x^2 + x^3 + x^6 + x^7
   #
   do_crc(7, 0x79, $string);

   #---------------------------------
   #
   # 3-bit FO/SO CRC
   #
   #      C(x) = x^0 + x^1 + x^3
   #
   do_crc(3, 0x6, $string);



<span class="grey">Jonsson, et al.             Standards Track                    [Page 38]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-39"></span>
<span class="grey"><a href="./rfc4995">RFC 4995</a>                   The ROHC Framework                  July 2007</span>


Authors' Addresses

   Lars-Erik Jonsson
   Optand 737
   SE-831 92 Ostersund, Sweden

   Phone: +46 70 365 20 58
   EMail: lars-erik@lejonsson.com


   Ghyslain Pelletier
   Ericsson AB
   Box 920
   SE-971 28 Lulea, Sweden

   Phone: +46 8 404 29 43
   Fax:   +46 920 996 21
   EMail: ghyslain.pelletier@ericsson.com


   Kristofer Sandlund
   Ericsson AB
   Box 920
   SE-971 28 Lulea, Sweden

   Phone: +46 8 404 41 58
   Fax:   +46 920 996 21
   EMail: kristofer.sandlund@ericsson.com























<span class="grey">Jonsson, et al.             Standards Track                    [Page 39]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-40"></span>
<span class="grey"><a href="./rfc4995">RFC 4995</a>                   The ROHC Framework                  July 2007</span>


Full Copyright Statement

   Copyright (C) The IETF Trust (2007).

   This document is subject to the rights, licenses and restrictions
   contained in <a href="https://www.rfc-editor.org/bcp/bcp78">BCP 78</a>, and except as set forth therein, the authors
   retain all their rights.

   This document and the information contained herein are provided on an
   "AS IS" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS
   OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST AND
   THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS
   OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF
   THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED
   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.

Intellectual Property

   The IETF takes no position regarding the validity or scope of any
   Intellectual Property Rights or other rights that might be claimed to
   pertain to the implementation or use of the technology described in
   this document or the extent to which any license under such rights
   might or might not be available; nor does it represent that it has
   made any independent effort to identify any such rights.  Information
   on the procedures with respect to rights in RFC documents can be
   found in <a href="https://www.rfc-editor.org/bcp/bcp78">BCP 78</a> and <a href="https://www.rfc-editor.org/bcp/bcp79">BCP 79</a>.

   Copies of IPR disclosures made to the IETF Secretariat and any
   assurances of licenses to be made available, or the result of an
   attempt made to obtain a general license or permission for the use of
   such proprietary rights by implementers or users of this
   specification can be obtained from the IETF on-line IPR repository at
   <a href="http://www.ietf.org/ipr">http://www.ietf.org/ipr</a>.

   The IETF invites any interested party to bring to its attention any
   copyrights, patents or patent applications, or other proprietary
   rights that may cover technology that may be required to implement
   this standard.  Please address the information to the IETF at
   ietf-ipr@ietf.org.

Acknowledgement

   Funding for the RFC Editor function is currently provided by the
   Internet Society.







Jonsson, et al.             Standards Track                    [Page 40]
</pre>
</body></html>