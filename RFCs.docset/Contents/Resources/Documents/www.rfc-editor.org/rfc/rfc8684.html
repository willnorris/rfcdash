<!DOCTYPE html>
<html class="RFC" lang="en"><head>
<meta charset="utf-8"/>
<meta content="Common,Latin" name="scripts"/>
<meta content="initial-scale=1.0" name="viewport"/>
<title>RFC 8684: TCP Extensions for Multipath Operation with Multiple Addresses</title>
<meta content="Alan Ford" name="author"/>
<meta content="Costin Raiciu" name="author"/>
<meta content="Mark Handley" name="author"/>
<meta content="Olivier Bonaventure" name="author"/>
<meta content="Christoph Paasch" name="author"/>
<meta content="
       TCP/IP communication is currently restricted to a single path per connection, yet multiple paths often exist between peers. The simultaneous use of these multiple paths for a TCP/IP session would improve resource usage within the network and thus improve user experience through higher throughput and improved resilience to network failure. 
       Multipath TCP provides the ability to simultaneously use multiple
      paths between peers. This document presents a set of extensions to
      traditional TCP to support multipath operation. The protocol offers the
      same type of service to applications as TCP (i.e., a reliable bytestream), and it provides the components necessary to establish and use multiple TCP flows across potentially disjoint paths. 
       This document specifies v1 of Multipath TCP, obsoleting v0 as
      specified in RFC 6824, through clarifications and modifications primarily driven by deployment experience. 
    " name="description"/>
<meta content="xml2rfc 2.41.0" name="generator"/>
<meta content="tcp" name="keyword"/>
<meta content="extensions" name="keyword"/>
<meta content="multipath" name="keyword"/>
<meta content="multihomed" name="keyword"/>
<meta content="subflow" name="keyword"/>
<meta content="8684" name="rfc.number"/>
<link href="rfc8684.xml" rel="alternate" type="application/rfc+xml"/>
<link href="#copyright" rel="license"/>
<style type="text/css">/*

  NOTE: Changes at the bottom of this file overrides some earlier settings.

  Once the style has stabilized and has been adopted as an official RFC style,
  this can be consolidated so that style settings occur only in one place, but
  for now the contents of this file consists first of the initial CSS work as
  provided to the RFC Formatter (xml2rfc) work, followed by itemized and
  commented changes found necssary during the development of the v3
  formatters.

*/

/* fonts */
@import url('https://fonts.googleapis.com/css?family=Noto+Sans'); /* Sans-serif */
@import url('https://fonts.googleapis.com/css?family=Noto+Serif'); /* Serif (print) */
@import url('https://fonts.googleapis.com/css?family=Roboto+Mono'); /* Monospace */

@viewport {
  zoom: 1.0;
  width: extend-to-zoom;
}
@-ms-viewport {
  width: extend-to-zoom;
  zoom: 1.0;
}
/* general and mobile first */
html {
}
body {
  max-width: 90%;
  margin: 1.5em auto;
  color: #222;
  background-color: #fff;
  font-size: 14px;
  font-family: 'Noto Sans', Arial, Helvetica, sans-serif;
  line-height: 1.6;
  scroll-behavior: smooth;
}
.ears {
  display: none;
}

/* headings */
#title, h1, h2, h3, h4, h5, h6 {
  margin: 1em 0 0.5em;
  font-weight: bold;
  line-height: 1.3;
}
#title {
  clear: both;
  border-bottom: 1px solid #ddd;
  margin: 0 0 0.5em 0;
  padding: 1em 0 0.5em;
}
.author {
  padding-bottom: 4px;
}
h1 {
  font-size: 26px;
  margin: 1em 0;
}
h2 {
  font-size: 22px;
  margin-top: -20px;  /* provide offset for in-page anchors */
  padding-top: 33px;
}
h3 {
  font-size: 18px;
  margin-top: -36px;  /* provide offset for in-page anchors */
  padding-top: 42px;
}
h4 {
  font-size: 16px;
  margin-top: -36px;  /* provide offset for in-page anchors */
  padding-top: 42px;
}
h5, h6 {
  font-size: 14px;
}
#n-copyright-notice {
  border-bottom: 1px solid #ddd;
  padding-bottom: 1em;
  margin-bottom: 1em;
}
/* general structure */
p {
  padding: 0;
  margin: 0 0 1em 0;
  text-align: left;
}
div, span {
  position: relative;
}
div {
  margin: 0;
}
.alignRight.art-text {
  background-color: #f9f9f9;
  border: 1px solid #eee;
  border-radius: 3px;
  padding: 1em 1em 0;
  margin-bottom: 1.5em;
}
.alignRight.art-text pre {
  padding: 0;
}
.alignRight {
  margin: 1em 0;
}
.alignRight > *:first-child {
  border: none;
  margin: 0;
  float: right;
  clear: both;
}
.alignRight > *:nth-child(2) {
  clear: both;
  display: block;
  border: none;
}
svg {
  display: block;
}
.alignCenter.art-text {
  background-color: #f9f9f9;
  border: 1px solid #eee;
  border-radius: 3px;
  padding: 1em 1em 0;
  margin-bottom: 1.5em;
}
.alignCenter.art-text pre {
  padding: 0;
}
.alignCenter {
  margin: 1em 0;
}
.alignCenter > *:first-child {
  border: none;
  /* this isn't optimal, but it's an existence proof.  PrinceXML doesn't
     support flexbox yet.
  */
  display: table;
  margin: 0 auto;
}

/* lists */
ol, ul {
  padding: 0;
  margin: 0 0 1em 2em;
}
ol ol, ul ul, ol ul, ul ol {
  margin-left: 1em;
}
li {
  margin: 0 0 0.25em 0;
}
.ulCompact li {
  margin: 0;
}
ul.empty, .ulEmpty {
  list-style-type: none;
}
ul.empty li, .ulEmpty li {
  margin-top: 0.5em;
}
ul.compact, .ulCompact,
ol.compact, .olCompact {
  line-height: 100%;
  margin: 0 0 0 2em;
}

/* definition lists */
dl {
}
dl > dt {
  float: left;
  margin-right: 1em;
}
/* 
dl.nohang > dt {
  float: none;
}
*/
dl > dd {
  margin-bottom: .8em;
  min-height: 1.3em;
}
dl.compact > dd, .dlCompact > dd {
  margin-bottom: 0em;
}
dl > dd > dl {
  margin-top: 0.5em;
  margin-bottom: 0em;
}

/* links */
a {
  text-decoration: none;
}
a[href] {
  color: #22e; /* Arlen: WCAG 2019 */
}
a[href]:hover {
  background-color: #f2f2f2;
}
figcaption a[href],
a[href].selfRef {
  color: #222;
}
/* XXX probably not this:
a.selfRef:hover {
  background-color: transparent;
  cursor: default;
} */

/* Figures */
tt, code, pre, code {
  background-color: #f9f9f9;
  font-family: 'Roboto Mono', monospace;
}
pre {
  border: 1px solid #eee;
  margin: 0;
  padding: 1em;
}
img {
  max-width: 100%;
}
figure {
  margin: 0;
}
figure blockquote {
  margin: 0.8em 0.4em 0.4em;
}
figcaption {
  font-style: italic;
  margin: 0 0 1em 0;
}
@media screen {
  pre {
    overflow-x: auto;
    max-width: 100%;
    max-width: calc(100% - 22px);
  }
}

/* aside, blockquote */
aside, blockquote {
  margin-left: 0;
  padding: 1.2em 2em;
}
blockquote {
  background-color: #f9f9f9;
  color: #111; /* Arlen: WCAG 2019 */
  border: 1px solid #ddd;
  border-radius: 3px;
  margin: 1em 0;
}
cite {
  display: block;
  text-align: right;
  font-style: italic;
}

/* tables */
table {
  width: 100%;
  margin: 0 0 1em;
  border-collapse: collapse;
  border: 1px solid #eee;
}
th, td {
  text-align: left;
  vertical-align: top;
  padding: 0.5em 0.75em;
}
th {
  text-align: left;
  background-color: #e9e9e9;
}
tr:nth-child(2n+1) > td {
  background-color: #f5f5f5;
}
table caption {
  font-style: italic;
  margin: 0;
  padding: 0;
  text-align: left;
}
table p {
  /* XXX to avoid bottom margin on table row signifiers. If paragraphs should
     be allowed within tables more generally, it would be far better to select on a class. */
  margin: 0;
}

/* pilcrow */
a.pilcrow {
  color: #666; /* Arlen: AHDJ 2019 */
  text-decoration: none;
  visibility: hidden;
  user-select: none;
  -ms-user-select: none;
  -o-user-select:none;
  -moz-user-select: none;
  -khtml-user-select: none;
  -webkit-user-select: none;
  -webkit-touch-callout: none;
}
@media screen {
  aside:hover > a.pilcrow,
  p:hover > a.pilcrow,
  blockquote:hover > a.pilcrow,
  div:hover > a.pilcrow,
  li:hover > a.pilcrow,
  pre:hover > a.pilcrow {
    visibility: visible;
  }
  a.pilcrow:hover {
    background-color: transparent;
  }
}

/* misc */
hr {
  border: 0;
  border-top: 1px solid #eee;
}
.bcp14 {
  font-variant: small-caps;
}

.role {
  font-variant: all-small-caps;
}

/* info block */
#identifiers {
  margin: 0;
  font-size: 0.9em;
}
#identifiers dt {
  width: 3em;
  clear: left;
}
#identifiers dd {
  float: left;
  margin-bottom: 0;
}
#identifiers .authors .author {
  display: inline-block;
  margin-right: 1.5em;
}
#identifiers .authors .org {
  font-style: italic;
}

/* The prepared/rendered info at the very bottom of the page */
.docInfo {
  color: #666; /* Arlen: WCAG 2019 */
  font-size: 0.9em;
  font-style: italic;
  margin-top: 2em;
}
.docInfo .prepared {
  float: left;
}
.docInfo .prepared {
  float: right;
}

/* table of contents */
#toc  {
  padding: 0.75em 0 2em 0;
  margin-bottom: 1em;
}
nav.toc ul {
  margin: 0 0.5em 0 0;
  padding: 0;
  list-style: none;
}
nav.toc li {
  line-height: 1.3em;
  margin: 0.75em 0;
  padding-left: 1.2em;
  text-indent: -1.2em;
}
/* references */
.references dt {
  text-align: right;
  font-weight: bold;
  min-width: 7em;
}
.references dd {
  margin-left: 8em;
  overflow: auto;
}

.refInstance {
  margin-bottom: 1.25em;
}

.references .ascii {
  margin-bottom: 0.25em;
}

/* index */
.index ul {
  margin: 0 0 0 1em;
  padding: 0;
  list-style: none;
}
.index ul ul {
  margin: 0;
}
.index li {
  margin: 0;
  text-indent: -2em;
  padding-left: 2em;
  padding-bottom: 5px;
}
.indexIndex {
  margin: 0.5em 0 1em;
}
.index a {
  font-weight: 700;
}
/* make the index two-column on all but the smallest screens */
@media (min-width: 600px) {
  .index ul {
    -moz-column-count: 2;
    -moz-column-gap: 20px;
  }
  .index ul ul {
    -moz-column-count: 1;
    -moz-column-gap: 0;
  }
}

/* authors */
address.vcard {
  font-style: normal;
  margin: 1em 0;
}

address.vcard .nameRole {
  font-weight: 700;
  margin-left: 0;
}
address.vcard .label {
  font-family: "Noto Sans",Arial,Helvetica,sans-serif;
  margin: 0.5em 0;
}
address.vcard .type {
  display: none;
}
.alternative-contact {
  margin: 1.5em 0 1em;
}
hr.addr {
  border-top: 1px dashed;
  margin: 0;
  color: #ddd;
  max-width: calc(100% - 16px);
}

/* temporary notes */
.rfcEditorRemove::before {
  position: absolute;
  top: 0.2em;
  right: 0.2em;
  padding: 0.2em;
  content: "The RFC Editor will remove this note";
  color: #9e2a00; /* Arlen: WCAG 2019 */
  background-color: #ffd; /* Arlen: WCAG 2019 */
}
.rfcEditorRemove {
  position: relative;
  padding-top: 1.8em;
  background-color: #ffd; /* Arlen: WCAG 2019 */
  border-radius: 3px;
}
.cref {
  background-color: #ffd; /* Arlen: WCAG 2019 */
  padding: 2px 4px;
}
.crefSource {
  font-style: italic;
}
/* alternative layout for smaller screens */
@media screen and (max-width: 1023px) {
  body {
    padding-top: 2em;
  }
  #title {
    padding: 1em 0;
  }
  h1 {
    font-size: 24px;
  }
  h2 {
    font-size: 20px;
    margin-top: -18px;  /* provide offset for in-page anchors */
    padding-top: 38px;
  }
  #identifiers dd {
    max-width: 60%;
  }
  #toc {
    position: fixed;
    z-index: 2;
    top: 0;
    right: 0;
    padding: 0;
    margin: 0;
    background-color: inherit;
    border-bottom: 1px solid #ccc;
  }
  #toc h2 {
    margin: -1px 0 0 0;
    padding: 4px 0 4px 6px;
    padding-right: 1em;
    min-width: 190px;
    font-size: 1.1em;
    text-align: right;
    background-color: #444;
    color: white;
    cursor: pointer;
  }
  #toc h2::before { /* css hamburger */
    float: right;
    position: relative;
    width: 1em;
    height: 1px;
    left: -164px;
    margin: 6px 0 0 0;
    background: white none repeat scroll 0 0;
    box-shadow: 0 4px 0 0 white, 0 8px 0 0 white;
    content: "";
  }
  #toc nav {
    display: none;
    padding: 0.5em 1em 1em;
    overflow: auto;
    height: calc(100vh - 48px);
    border-left: 1px solid #ddd;
  }
}

/* alternative layout for wide screens */
@media screen and (min-width: 1024px) {
  body {
    max-width: 724px;
    margin: 42px auto;
    padding-left: 1.5em;
    padding-right: 29em;
  }
  #toc {
    position: fixed;
    top: 42px;
    right: 42px;
    width: 25%;
    margin: 0;
    padding: 0 1em;
    z-index: 1;
  }
  #toc h2 {
    border-top: none;
    border-bottom: 1px solid #ddd;
    font-size: 1em;
    font-weight: normal;
    margin: 0;
    padding: 0.25em 1em 1em 0;
  }
  #toc nav {
    display: block;
    height: calc(90vh - 84px);
    bottom: 0;
    padding: 0.5em 0 0;
    overflow: auto;
  }
  img { /* future proofing */
    max-width: 100%;
    height: auto;
  }
}

/* pagination */
@media print {
  body {

    width: 100%;
  }
  p {
    orphans: 3;
    widows: 3;
  }
  #n-copyright-notice {
    border-bottom: none;
  }
  #toc, #n-introduction {
    page-break-before: always;
  }
  #toc {
    border-top: none;
    padding-top: 0;
  }
  figure, pre {
    page-break-inside: avoid;
  }
  figure {
    overflow: scroll;
  }
  h1, h2, h3, h4, h5, h6 {
    page-break-after: avoid;
  }
  h2+*, h3+*, h4+*, h5+*, h6+* {
    page-break-before: avoid;
  }
  pre {
    white-space: pre-wrap;
    word-wrap: break-word;
    font-size: 10pt;
  }
  table {
    border: 1px solid #ddd;
  }
  td {
    border-top: 1px solid #ddd;
  }
}

/* This is commented out here, as the string-set: doesn't
   pass W3C validation currently */
/*
.ears thead .left {
  string-set: ears-top-left content();
}

.ears thead .center {
  string-set: ears-top-center content();
}

.ears thead .right {
  string-set: ears-top-right content();
}

.ears tfoot .left {
  string-set: ears-bottom-left content();
}

.ears tfoot .center {
  string-set: ears-bottom-center content();
}

.ears tfoot .right {
  string-set: ears-bottom-right content();
}
*/

@page :first {
  padding-top: 0;
  @top-left {
    content: normal;
    border: none;
  }
  @top-center {
    content: normal;
    border: none;
  }
  @top-right {
    content: normal;
    border: none;
  }
}

@page {
  size: A4;
  margin-bottom: 45mm;
  padding-top: 20px;
  /* The follwing is commented out here, but set appropriately by in code, as
     the content depends on the document */
  /*
  @top-left {
    content: 'Internet-Draft';
    vertical-align: bottom;
    border-bottom: solid 1px #ccc;
  }
  @top-left {
    content: string(ears-top-left);
    vertical-align: bottom;
    border-bottom: solid 1px #ccc;
  }
  @top-center {
    content: string(ears-top-center);
    vertical-align: bottom;
    border-bottom: solid 1px #ccc;
  }
  @top-right {
    content: string(ears-top-right);
    vertical-align: bottom;
    border-bottom: solid 1px #ccc;
  }
  @bottom-left {
    content: string(ears-bottom-left);
    vertical-align: top;
    border-top: solid 1px #ccc;
  }
  @bottom-center {
    content: string(ears-bottom-center);
    vertical-align: top;
    border-top: solid 1px #ccc;
  }
  @bottom-right {
      content: '[Page ' counter(page) ']';
      vertical-align: top;
      border-top: solid 1px #ccc;
  }
  */

}

/* Changes introduced to fix issues found during implementation */
/* Make sure links are clickable even if overlapped by following H* */
a {
  z-index: 2;
}
/* Separate body from document info even without intervening H1 */
section {
  clear: both;
}


/* Top align author divs, to avoid names without organization dropping level with org names */
.author {
  vertical-align: top;
}

/* Leave room in document info to show Internet-Draft on one line */
#identifiers dt {
  width: 8em;
}

/* Don't waste quite as much whitespace between label and value in doc info */
#identifiers dd {
  margin-left: 1em;
}

/* Give floating toc a background color (needed when it's a div inside section */
#toc {
  background-color: white;
}

/* Make the collapsed ToC header render white on gray also when it's a link */
@media screen and (max-width: 1023px) {
  #toc h2 a,
  #toc h2 a:link,
  #toc h2 a:focus,
  #toc h2 a:hover,
  #toc a.toplink,
  #toc a.toplink:hover {
    color: white;
    background-color: #444;
    text-decoration: none;
  }
}

/* Give the bottom of the ToC some whitespace */
@media screen and (min-width: 1024px) {
  #toc {
    padding: 0 0 1em 1em;
  }
}

/* Style section numbers with more space between number and title */
.section-number {
  padding-right: 0.5em;
}

/* prevent monospace from becoming overly large */
tt, code, pre, code {
  font-size: 95%;
}

/* Fix the height/width aspect for ascii art*/
pre.sourcecode,
.art-text pre {
  line-height: 1.12;
}


/* Add styling for a link in the ToC that points to the top of the document */
a.toplink {
  float: right;
  margin-right: 0.5em;
}

/* Fix the dl styling to match the RFC 7992 attributes */
dl > dt,
dl.dlParallel > dt {
  float: left;
  margin-right: 1em;
}
dl.dlNewline > dt {
  float: none;
}

/* Provide styling for table cell text alignment */
table td.text-left,
table th.text-left {
  text-align: left;
}
table td.text-center,
table th.text-center {
  text-align: center;
}
table td.text-right,
table th.text-right {
  text-align: right;
}

/* Make the alternative author contact informatio look less like just another
   author, and group it closer with the primary author contact information */
.alternative-contact {
  margin: 0.5em 0 0.25em 0;
}
address .non-ascii {
  margin: 0 0 0 2em;
}

/* With it being possible to set tables with alignment
  left, center, and right, { width: 100%; } does not make sense */
table {
  width: auto;
}

/* Avoid reference text that sits in a block with very wide left margin,
   because of a long floating dt label.*/
.references dd {
  overflow: visible;
}

/* Control caption placement */
caption {
  caption-side: bottom;
}

/* Limit the width of the author address vcard, so names in right-to-left
   script don't end up on the other side of the page. */

address.vcard {
  max-width: 30em;
  margin-right: auto;
}

/* For address alignment dependent on LTR or RTL scripts */
address div.left {
  text-align: left;
}
address div.right {
  text-align: right;
}

/* Provide table alignment support.  We can't use the alignX classes above
   since they do unwanted things with caption and other styling. */
table.right {
 margin-left: auto;
 margin-right: 0;
}
table.center {
 margin-left: auto;
 margin-right: auto;
}
table.left {
 margin-left: 0;
 margin-right: auto;
}

/* Give the table caption label the same styling as the figcaption */
caption a[href] {
  color: #222;
}

@media print {
  .toplink {
    display: none;
  }

  /* avoid overwriting the top border line with the ToC header */
  #toc {
    padding-top: 1px;
  }

  /* Avoid page breaks inside dl and author address entries */
  .vcard {
    page-break-inside: avoid;
  }

}
/* Avoid wrapping of URLs in references */
@media screen {
  .references a {
    white-space: nowrap;
  }
}
/* Tweak the bcp14 keyword presentation */
.bcp14 {
  font-variant: small-caps;
  font-weight: bold;
  font-size: 0.9em;
}
/* Tweak the invisible space above H* in order not to overlay links in text above */
 h2 {
  margin-top: -18px;  /* provide offset for in-page anchors */
  padding-top: 31px;
 }
 h3 {
  margin-top: -18px;  /* provide offset for in-page anchors */
  padding-top: 24px;
 }
 h4 {
  margin-top: -18px;  /* provide offset for in-page anchors */
  padding-top: 24px;
 }
/* Float artwork pilcrow to the right */
@media screen {
  .artwork a.pilcrow {
    display: block;
    line-height: 0.7;
    margin-top: 0.15em;
  }
}
/* Make pilcrows on dd visible */
@media screen {
  dd:hover > a.pilcrow {
    visibility: visible;
  }
}
/* Make the placement of figcaption match that of a table's caption
   by removing the figure's added bottom margin */
.alignLeft.art-text,
.alignCenter.art-text,
.alignRight.art-text {
   margin-bottom: 0;
}
.alignLeft,
.alignCenter,
.alignRight {
  margin: 1em 0 0 0;
}
/* In print, the pilcrow won't show on hover, so prevent it from taking up space,
   possibly even requiring a new line */
@media print {
  a.pilcrow {
    display: none;
  }
}
/* Styling for the external metadata */
div#external-metadata {
  background-color: #eee;
  padding: 0.5em;
  margin-bottom: 0.5em;
  display: none;
}
div#internal-metadata {
  padding: 0.5em;                       /* to match the external-metadata padding */
}
/* Styling for title RFC Number */
h1#rfcnum {
  clear: both;
  margin: 0 0 -1em;
  padding: 1em 0 0 0;
}
/* Make .olPercent look the same as <ol><li> */
dl.olPercent > dd {
  margin-bottom: 0.25em;
  min-height: initial;
}
/* Give aside some styling to set it apart */
aside {
  border-left: 1px solid #ddd;
  margin: 1em 0 1em 2em;
  padding: 0.2em 2em;
}
aside > dl,
aside > ol,
aside > ul,
aside > table,
aside > p {
  margin-bottom: 0.5em;
}
/* Additional page break settings */
@media print {
  figcaption, table caption {
    page-break-before: avoid;
  }
}
/* Font size adjustments for print */
@media print {
  body  { font-size: 10pt;      line-height: normal; max-width: 96%; }
  h1    { font-size: 1.72em;    padding-top: 1.5em; } /* 1*1.2*1.2*1.2 */
  h2    { font-size: 1.44em;    padding-top: 1.5em; } /* 1*1.2*1.2 */
  h3    { font-size: 1.2em;     padding-top: 1.5em; } /* 1*1.2 */
  h4    { font-size: 1em;       padding-top: 1.5em; }
  h5, h6 { font-size: 1em;      margin: initial; padding: 0.5em 0 0.3em; }
}
/* Sourcecode margin in print, when there's no pilcrow */
@media print {
  .artwork,
  .sourcecode {
    margin-bottom: 1em;
  }
}
/* Avoid narrow tables forcing too narrow table captions, which may render badly */
table {
  min-width: 20em;
}
/* ol type a */
ol.type-a { list-style-type: lower-alpha; }
ol.type-A { list-style-type: upper-alpha; }
ol.type-i { list-style-type: lower-roman; }
ol.type-I { list-style-type: lower-roman; }
/* Apply the print table and row borders in general, on request from the RPC,
and increase the contrast between border and odd row background sligthtly */
table {
  border: 1px solid #ddd;
}
td {
  border-top: 1px solid #ddd;
}
tr:nth-child(2n+1) > td {
  background-color: #f8f8f8;
}
/* Use style rules to govern display of the TOC. */
@media screen and (max-width: 1023px) {
  #toc nav { display: none; }
  #toc.active nav { display: block; }
}
</style>
<link href="rfc-local.css" rel="stylesheet" type="text/css"/>
<link href="https://dx.doi.org/10.17487/rfc8684" rel="alternate"/>
  <link href="urn:issn:2070-1721" rel="alternate"/>
  <link href="https://datatracker.ietf.org/doc/draft-ietf-mptcp-rfc6824bis-18" rel="prev"/>
  </head>
<body>
<script src="https://www.rfc-editor.org/js/metadata.min.js"></script>
<table class="ears">
<thead><tr>
<td class="left">RFC 8684</td>
<td class="center">Multipath TCP</td>
<td class="right">March 2020</td>
</tr></thead>
<tfoot><tr>
<td class="left">Ford, et al.</td>
<td class="center">Standards Track</td>
<td class="right">[Page]</td>
</tr></tfoot>
</table>
<div class="document-information" id="external-metadata"></div>
<div class="document-information" id="internal-metadata">
<dl id="identifiers">
<dt class="label-stream">Stream:</dt>
<dd class="stream">Internet Engineering Task Force (IETF)</dd>
<dt class="label-rfc">RFC:</dt>
<dd class="rfc"><a class="eref" href="https://www.rfc-editor.org/rfc/rfc8684">8684</a></dd>
<dt class="label-obsoletes">Obsoletes:</dt>
<dd class="obsoletes">
<a class="eref" href="https://www.rfc-editor.org/rfc/rfc6824">6824</a> </dd>
<dt class="label-category">Category:</dt>
<dd class="category">Standards Track</dd>
<dt class="label-published">Published:</dt>
<dd class="published">
<time class="published" datetime="2020-03">March 2020</time>
    </dd>
<dt class="label-issn">ISSN:</dt>
<dd class="issn">2070-1721</dd>
<dt class="label-authors">Authors:</dt>
<dd class="authors">
<div class="author">
      <div class="author-name">A. Ford</div>
<div class="org">Pexip</div>
</div>
<div class="author">
      <div class="author-name">C. Raiciu</div>
<div class="org">U. Politehnica of Bucharest</div>
</div>
<div class="author">
      <div class="author-name">M. Handley</div>
<div class="org">U. College London</div>
</div>
<div class="author">
      <div class="author-name">O. Bonaventure</div>
<div class="org">U. catholique de Louvain</div>
</div>
<div class="author">
      <div class="author-name">C. Paasch</div>
<div class="org">Apple, Inc.</div>
</div>
</dd>
</dl>
</div>
<h1 id="rfcnum">RFC 8684</h1>
<h1 id="title">TCP Extensions for Multipath Operation with Multiple Addresses</h1>
<section id="section-abstract">
      <h2 id="abstract"><a class="selfRef" href="#abstract">Abstract</a></h2>
<p id="section-abstract-1">TCP/IP communication is currently restricted to a single path per connection, yet multiple paths often exist between peers. The simultaneous use of these multiple paths for a TCP/IP session would improve resource usage within the network and thus improve user experience through higher throughput and improved resilience to network failure.<a class="pilcrow" href="#section-abstract-1">¶</a></p>
<p id="section-abstract-2">Multipath TCP provides the ability to simultaneously use multiple
      paths between peers. This document presents a set of extensions to
      traditional TCP to support multipath operation. The protocol offers the
      same type of service to applications as TCP (i.e., a reliable bytestream), and it provides the components necessary to establish and use multiple TCP flows across potentially disjoint paths.<a class="pilcrow" href="#section-abstract-2">¶</a></p>
<p id="section-abstract-3">This document specifies v1 of Multipath TCP, obsoleting v0 as
      specified in RFC 6824, through clarifications and modifications primarily driven by deployment experience.<a class="pilcrow" href="#section-abstract-3">¶</a></p>
</section>
<div id="status-of-memo">
<section id="section-boilerplate.1">
        <h2 id="name-status-of-this-memo">
<a class="section-name selfRef" href="#name-status-of-this-memo">Status of This Memo</a>
        </h2>
<p id="section-boilerplate.1-1">
            This is an Internet Standards Track document.<a class="pilcrow" href="#section-boilerplate.1-1">¶</a></p>
<p id="section-boilerplate.1-2">
            This document is a product of the Internet Engineering Task Force
            (IETF).  It represents the consensus of the IETF community.  It has
            received public review and has been approved for publication by
            the Internet Engineering Steering Group (IESG).  Further
            information on Internet Standards is available in Section 2 of 
            RFC 7841.<a class="pilcrow" href="#section-boilerplate.1-2">¶</a></p>
<p id="section-boilerplate.1-3">
            Information about the current status of this document, any
            errata, and how to provide feedback on it may be obtained at
            <span><a href="https://www.rfc-editor.org/info/rfc8684">https://www.rfc-editor.org/info/rfc8684</a></span>.<a class="pilcrow" href="#section-boilerplate.1-3">¶</a></p>
</section>
</div>
<div id="copyright">
<section id="section-boilerplate.2">
        <h2 id="name-copyright-notice">
<a class="section-name selfRef" href="#name-copyright-notice">Copyright Notice</a>
        </h2>
<p id="section-boilerplate.2-1">
            Copyright (c) 2020 IETF Trust and the persons identified as the
            document authors. All rights reserved.<a class="pilcrow" href="#section-boilerplate.2-1">¶</a></p>
<p id="section-boilerplate.2-2">
            This document is subject to BCP 78 and the IETF Trust's Legal
            Provisions Relating to IETF Documents
            (<span><a href="https://trustee.ietf.org/license-info">https://trustee.ietf.org/license-info</a></span>) in effect on the date of
            publication of this document. Please review these documents
            carefully, as they describe your rights and restrictions with
            respect to this document. Code Components extracted from this
            document must include Simplified BSD License text as described in
            Section 4.e of the Trust Legal Provisions and are provided without
            warranty as described in the Simplified BSD License.<a class="pilcrow" href="#section-boilerplate.2-2">¶</a></p>
</section>
</div>
<div id="toc">
<section id="section-toc.1">
        <a class="toplink" href="#" onclick="scroll(0,0)">▲</a><h2 id="name-table-of-contents">
<a class="section-name selfRef" href="#name-table-of-contents">Table of Contents</a>
        </h2>
<nav class="toc"><ul class="toc ulEmpty">
<li class="toc ulEmpty" id="section-toc.1-1.1">
            <p id="section-toc.1-1.1.1"><a class="xref" href="#section-1">1</a>.  <a class="xref" href="#name-introduction">Introduction</a><a class="pilcrow" href="#section-toc.1-1.1.1">¶</a></p>
<ul class="toc ulEmpty">
<li class="toc ulEmpty" id="section-toc.1-1.1.2.1">
                <p id="section-toc.1-1.1.2.1.1"><a class="xref" href="#section-1.1">1.1</a>.  <a class="xref" href="#name-design-assumptions">Design Assumptions</a><a class="pilcrow" href="#section-toc.1-1.1.2.1.1">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.1.2.2">
                <p id="section-toc.1-1.1.2.2.1"><a class="xref" href="#section-1.2">1.2</a>.  <a class="xref" href="#name-multipath-tcp-in-the-networ">Multipath TCP in the Networking Stack</a><a class="pilcrow" href="#section-toc.1-1.1.2.2.1">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.1.2.3">
                <p id="section-toc.1-1.1.2.3.1"><a class="xref" href="#section-1.3">1.3</a>.  <a class="xref" href="#name-terminology">Terminology</a><a class="pilcrow" href="#section-toc.1-1.1.2.3.1">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.1.2.4">
                <p id="section-toc.1-1.1.2.4.1"><a class="xref" href="#section-1.4">1.4</a>.  <a class="xref" href="#name-mptcp-concept">MPTCP Concept</a><a class="pilcrow" href="#section-toc.1-1.1.2.4.1">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.1.2.5">
                <p id="section-toc.1-1.1.2.5.1"><a class="xref" href="#section-1.5">1.5</a>.  <a class="xref" href="#name-requirements-language">Requirements Language</a><a class="pilcrow" href="#section-toc.1-1.1.2.5.1">¶</a></p>
</li>
</ul>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.2">
            <p id="section-toc.1-1.2.1"><a class="xref" href="#section-2">2</a>.  <a class="xref" href="#name-operation-overview">Operation Overview</a><a class="pilcrow" href="#section-toc.1-1.2.1">¶</a></p>
<ul class="toc ulEmpty">
<li class="toc ulEmpty" id="section-toc.1-1.2.2.1">
                <p id="section-toc.1-1.2.2.1.1"><a class="xref" href="#section-2.1">2.1</a>.  <a class="xref" href="#name-initiating-an-mptcp-connect">Initiating an MPTCP Connection</a><a class="pilcrow" href="#section-toc.1-1.2.2.1.1">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.2.2.2">
                <p id="section-toc.1-1.2.2.2.1"><a class="xref" href="#section-2.2">2.2</a>.  <a class="xref" href="#name-associating-a-new-subflow-w">Associating a New Subflow with an Existing MPTCP Connection</a><a class="pilcrow" href="#section-toc.1-1.2.2.2.1">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.2.2.3">
                <p id="section-toc.1-1.2.2.3.1"><a class="xref" href="#section-2.3">2.3</a>.  <a class="xref" href="#name-informing-the-other-host-ab">Informing the Other Host about Another Potential Address</a><a class="pilcrow" href="#section-toc.1-1.2.2.3.1">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.2.2.4">
                <p id="section-toc.1-1.2.2.4.1"><a class="xref" href="#section-2.4">2.4</a>.  <a class="xref" href="#name-data-transfer-using-mptcp">Data Transfer Using MPTCP</a><a class="pilcrow" href="#section-toc.1-1.2.2.4.1">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.2.2.5">
                <p id="section-toc.1-1.2.2.5.1"><a class="xref" href="#section-2.5">2.5</a>.  <a class="xref" href="#name-requesting-a-change-in-a-pa">Requesting a Change in a Path's Priority</a><a class="pilcrow" href="#section-toc.1-1.2.2.5.1">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.2.2.6">
                <p id="section-toc.1-1.2.2.6.1"><a class="xref" href="#section-2.6">2.6</a>.  <a class="xref" href="#name-closing-an-mptcp-connection">Closing an MPTCP Connection</a><a class="pilcrow" href="#section-toc.1-1.2.2.6.1">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.2.2.7">
                <p id="section-toc.1-1.2.2.7.1"><a class="xref" href="#section-2.7">2.7</a>.  <a class="xref" href="#name-notable-features">Notable Features</a><a class="pilcrow" href="#section-toc.1-1.2.2.7.1">¶</a></p>
</li>
</ul>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.3">
            <p id="section-toc.1-1.3.1"><a class="xref" href="#section-3">3</a>.  <a class="xref" href="#name-mptcp-operations-an-overvie">MPTCP Operations: An Overview</a><a class="pilcrow" href="#section-toc.1-1.3.1">¶</a></p>
<ul class="toc ulEmpty">
<li class="toc ulEmpty" id="section-toc.1-1.3.2.1">
                <p id="section-toc.1-1.3.2.1.1"><a class="xref" href="#section-3.1">3.1</a>.  <a class="xref" href="#name-connection-initiation">Connection Initiation</a><a class="pilcrow" href="#section-toc.1-1.3.2.1.1">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.3.2.2">
                <p id="section-toc.1-1.3.2.2.1"><a class="xref" href="#section-3.2">3.2</a>.  <a class="xref" href="#name-starting-a-new-subflow">Starting a New Subflow</a><a class="pilcrow" href="#section-toc.1-1.3.2.2.1">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.3.2.3">
                <p id="section-toc.1-1.3.2.3.1"><a class="xref" href="#section-3.3">3.3</a>.  <a class="xref" href="#name-mptcp-operation-and-data-tr">MPTCP Operation and Data Transfer</a><a class="pilcrow" href="#section-toc.1-1.3.2.3.1">¶</a></p>
<ul class="toc ulEmpty">
<li class="toc ulEmpty" id="section-toc.1-1.3.2.3.2.1">
                    <p id="section-toc.1-1.3.2.3.2.1.1"><a class="xref" href="#section-3.3.1">3.3.1</a>.  <a class="xref" href="#name-data-sequence-mapping">Data Sequence Mapping</a><a class="pilcrow" href="#section-toc.1-1.3.2.3.2.1.1">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.3.2.3.2.2">
                    <p id="section-toc.1-1.3.2.3.2.2.1"><a class="xref" href="#section-3.3.2">3.3.2</a>.  <a class="xref" href="#name-data-acknowledgments">Data Acknowledgments</a><a class="pilcrow" href="#section-toc.1-1.3.2.3.2.2.1">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.3.2.3.2.3">
                    <p id="section-toc.1-1.3.2.3.2.3.1"><a class="xref" href="#section-3.3.3">3.3.3</a>.  <a class="xref" href="#name-closing-a-connection">Closing a Connection</a><a class="pilcrow" href="#section-toc.1-1.3.2.3.2.3.1">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.3.2.3.2.4">
                    <p id="section-toc.1-1.3.2.3.2.4.1"><a class="xref" href="#section-3.3.4">3.3.4</a>.  <a class="xref" href="#name-receiver-considerations">Receiver Considerations</a><a class="pilcrow" href="#section-toc.1-1.3.2.3.2.4.1">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.3.2.3.2.5">
                    <p id="section-toc.1-1.3.2.3.2.5.1"><a class="xref" href="#section-3.3.5">3.3.5</a>.  <a class="xref" href="#name-sender-considerations">Sender Considerations</a><a class="pilcrow" href="#section-toc.1-1.3.2.3.2.5.1">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.3.2.3.2.6">
                    <p id="section-toc.1-1.3.2.3.2.6.1"><a class="xref" href="#section-3.3.6">3.3.6</a>.  <a class="xref" href="#name-reliability-and-retransmiss">Reliability and Retransmissions</a><a class="pilcrow" href="#section-toc.1-1.3.2.3.2.6.1">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.3.2.3.2.7">
                    <p id="section-toc.1-1.3.2.3.2.7.1"><a class="xref" href="#section-3.3.7">3.3.7</a>.  <a class="xref" href="#name-congestion-control-consider">Congestion Control Considerations</a><a class="pilcrow" href="#section-toc.1-1.3.2.3.2.7.1">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.3.2.3.2.8">
                    <p id="section-toc.1-1.3.2.3.2.8.1"><a class="xref" href="#section-3.3.8">3.3.8</a>.  <a class="xref" href="#name-subflow-policy">Subflow Policy</a><a class="pilcrow" href="#section-toc.1-1.3.2.3.2.8.1">¶</a></p>
</li>
</ul>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.3.2.4">
                <p id="section-toc.1-1.3.2.4.1"><a class="xref" href="#section-3.4">3.4</a>.  <a class="xref" href="#name-address-knowledge-exchange-">Address Knowledge Exchange (Path Management)</a><a class="pilcrow" href="#section-toc.1-1.3.2.4.1">¶</a></p>
<ul class="toc ulEmpty">
<li class="toc ulEmpty" id="section-toc.1-1.3.2.4.2.1">
                    <p id="section-toc.1-1.3.2.4.2.1.1"><a class="xref" href="#section-3.4.1">3.4.1</a>.  <a class="xref" href="#name-address-advertisement">Address Advertisement</a><a class="pilcrow" href="#section-toc.1-1.3.2.4.2.1.1">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.3.2.4.2.2">
                    <p id="section-toc.1-1.3.2.4.2.2.1"><a class="xref" href="#section-3.4.2">3.4.2</a>.  <a class="xref" href="#name-remove-address">Remove Address</a><a class="pilcrow" href="#section-toc.1-1.3.2.4.2.2.1">¶</a></p>
</li>
</ul>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.3.2.5">
                <p id="section-toc.1-1.3.2.5.1"><a class="xref" href="#section-3.5">3.5</a>.  <a class="xref" href="#name-fast-close">Fast Close</a><a class="pilcrow" href="#section-toc.1-1.3.2.5.1">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.3.2.6">
                <p id="section-toc.1-1.3.2.6.1"><a class="xref" href="#section-3.6">3.6</a>.  <a class="xref" href="#name-subflow-reset">Subflow Reset</a><a class="pilcrow" href="#section-toc.1-1.3.2.6.1">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.3.2.7">
                <p id="section-toc.1-1.3.2.7.1"><a class="xref" href="#section-3.7">3.7</a>.  <a class="xref" href="#name-fallback">Fallback</a><a class="pilcrow" href="#section-toc.1-1.3.2.7.1">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.3.2.8">
                <p id="section-toc.1-1.3.2.8.1"><a class="xref" href="#section-3.8">3.8</a>.  <a class="xref" href="#name-error-handling">Error Handling</a><a class="pilcrow" href="#section-toc.1-1.3.2.8.1">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.3.2.9">
                <p id="section-toc.1-1.3.2.9.1"><a class="xref" href="#section-3.9">3.9</a>.  <a class="xref" href="#name-heuristics">Heuristics</a><a class="pilcrow" href="#section-toc.1-1.3.2.9.1">¶</a></p>
<ul class="toc ulEmpty">
<li class="toc ulEmpty" id="section-toc.1-1.3.2.9.2.1">
                    <p id="section-toc.1-1.3.2.9.2.1.1"><a class="xref" href="#section-3.9.1">3.9.1</a>.  <a class="xref" href="#name-port-usage">Port Usage</a><a class="pilcrow" href="#section-toc.1-1.3.2.9.2.1.1">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.3.2.9.2.2">
                    <p id="section-toc.1-1.3.2.9.2.2.1"><a class="xref" href="#section-3.9.2">3.9.2</a>.  <a class="xref" href="#name-delayed-subflow-start-and-s">Delayed Subflow Start and Subflow Symmetry</a><a class="pilcrow" href="#section-toc.1-1.3.2.9.2.2.1">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.3.2.9.2.3">
                    <p id="section-toc.1-1.3.2.9.2.3.1"><a class="xref" href="#section-3.9.3">3.9.3</a>.  <a class="xref" href="#name-failure-handling">Failure Handling</a><a class="pilcrow" href="#section-toc.1-1.3.2.9.2.3.1">¶</a></p>
</li>
</ul>
</li>
</ul>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.4">
            <p id="section-toc.1-1.4.1"><a class="xref" href="#section-4">4</a>.  <a class="xref" href="#name-semantic-issues">Semantic Issues</a><a class="pilcrow" href="#section-toc.1-1.4.1">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.5">
            <p id="section-toc.1-1.5.1"><a class="xref" href="#section-5">5</a>.  <a class="xref" href="#name-security-considerations">Security Considerations</a><a class="pilcrow" href="#section-toc.1-1.5.1">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.6">
            <p id="section-toc.1-1.6.1"><a class="xref" href="#section-6">6</a>.  <a class="xref" href="#name-interactions-with-middlebox">Interactions with Middleboxes</a><a class="pilcrow" href="#section-toc.1-1.6.1">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.7">
            <p id="section-toc.1-1.7.1"><a class="xref" href="#section-7">7</a>.  <a class="xref" href="#name-iana-considerations">IANA Considerations</a><a class="pilcrow" href="#section-toc.1-1.7.1">¶</a></p>
<ul class="toc ulEmpty">
<li class="toc ulEmpty" id="section-toc.1-1.7.2.1">
                <p id="section-toc.1-1.7.2.1.1"><a class="xref" href="#section-7.1">7.1</a>.  <a class="xref" href="#name-tcp-option-kind-numbers">TCP Option Kind Numbers</a><a class="pilcrow" href="#section-toc.1-1.7.2.1.1">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.7.2.2">
                <p id="section-toc.1-1.7.2.2.1"><a class="xref" href="#section-7.2">7.2</a>.  <a class="xref" href="#name-mptcp-option-subtypes">MPTCP Option Subtypes</a><a class="pilcrow" href="#section-toc.1-1.7.2.2.1">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.7.2.3">
                <p id="section-toc.1-1.7.2.3.1"><a class="xref" href="#section-7.3">7.3</a>.  <a class="xref" href="#name-mptcp-handshake-algorithms">MPTCP Handshake Algorithms</a><a class="pilcrow" href="#section-toc.1-1.7.2.3.1">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.7.2.4">
                <p id="section-toc.1-1.7.2.4.1"><a class="xref" href="#section-7.4">7.4</a>.  <a class="xref" href="#name-mp_tcprst-reason-codes">MP_TCPRST Reason Codes</a><a class="pilcrow" href="#section-toc.1-1.7.2.4.1">¶</a></p>
</li>
</ul>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.8">
            <p id="section-toc.1-1.8.1"><a class="xref" href="#section-8">8</a>.  <a class="xref" href="#name-references">References</a><a class="pilcrow" href="#section-toc.1-1.8.1">¶</a></p>
<ul class="toc ulEmpty">
<li class="toc ulEmpty" id="section-toc.1-1.8.2.1">
                <p id="section-toc.1-1.8.2.1.1"><a class="xref" href="#section-8.1">8.1</a>.  <a class="xref" href="#name-normative-references">Normative References</a><a class="pilcrow" href="#section-toc.1-1.8.2.1.1">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.8.2.2">
                <p id="section-toc.1-1.8.2.2.1"><a class="xref" href="#section-8.2">8.2</a>.  <a class="xref" href="#name-informative-references">Informative References</a><a class="pilcrow" href="#section-toc.1-1.8.2.2.1">¶</a></p>
</li>
</ul>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.9">
            <p id="section-toc.1-1.9.1"><a class="xref" href="#section-appendix.a">Appendix A</a>.  <a class="xref" href="#name-notes-on-use-of-tcp-options">Notes on Use of TCP Options</a><a class="pilcrow" href="#section-toc.1-1.9.1">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.10">
            <p id="section-toc.1-1.10.1"><a class="xref" href="#section-appendix.b">Appendix B</a>.  <a class="xref" href="#name-tcp-fast-open-and-mptcp">TCP Fast Open and MPTCP</a><a class="pilcrow" href="#section-toc.1-1.10.1">¶</a></p>
<ul class="toc ulEmpty">
<li class="toc ulEmpty" id="section-toc.1-1.10.2.1">
                <p id="section-toc.1-1.10.2.1.1"><a class="xref" href="#section-b.1">B.1</a>.  <a class="xref" href="#name-tfo-cookie-request-with-mpt">TFO Cookie Request with MPTCP</a><a class="pilcrow" href="#section-toc.1-1.10.2.1.1">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.10.2.2">
                <p id="section-toc.1-1.10.2.2.1"><a class="xref" href="#section-b.2">B.2</a>.  <a class="xref" href="#name-data-sequence-mapping-under">Data Sequence Mapping under TFO</a><a class="pilcrow" href="#section-toc.1-1.10.2.2.1">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.10.2.3">
                <p id="section-toc.1-1.10.2.3.1"><a class="xref" href="#section-b.3">B.3</a>.  <a class="xref" href="#name-connection-establishment-ex">Connection Establishment Examples</a><a class="pilcrow" href="#section-toc.1-1.10.2.3.1">¶</a></p>
</li>
</ul>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.11">
            <p id="section-toc.1-1.11.1"><a class="xref" href="#section-appendix.c">Appendix C</a>.  <a class="xref" href="#name-control-blocks">Control Blocks</a><a class="pilcrow" href="#section-toc.1-1.11.1">¶</a></p>
<ul class="toc ulEmpty">
<li class="toc ulEmpty" id="section-toc.1-1.11.2.1">
                <p id="section-toc.1-1.11.2.1.1"><a class="xref" href="#section-c.1">C.1</a>.  <a class="xref" href="#name-mptcp-control-block">MPTCP Control Block</a><a class="pilcrow" href="#section-toc.1-1.11.2.1.1">¶</a></p>
<ul class="toc ulEmpty">
<li class="toc ulEmpty" id="section-toc.1-1.11.2.1.2.1">
                    <p id="section-toc.1-1.11.2.1.2.1.1"><a class="xref" href="#section-c.1.1">C.1.1</a>.  <a class="xref" href="#name-authentication-and-metadata">Authentication and Metadata</a><a class="pilcrow" href="#section-toc.1-1.11.2.1.2.1.1">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.11.2.1.2.2">
                    <p id="section-toc.1-1.11.2.1.2.2.1"><a class="xref" href="#section-c.1.2">C.1.2</a>.  <a class="xref" href="#name-sending-side">Sending Side</a><a class="pilcrow" href="#section-toc.1-1.11.2.1.2.2.1">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.11.2.1.2.3">
                    <p id="section-toc.1-1.11.2.1.2.3.1"><a class="xref" href="#section-c.1.3">C.1.3</a>.  <a class="xref" href="#name-receiving-side">Receiving Side</a><a class="pilcrow" href="#section-toc.1-1.11.2.1.2.3.1">¶</a></p>
</li>
</ul>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.11.2.2">
                <p id="section-toc.1-1.11.2.2.1"><a class="xref" href="#section-c.2">C.2</a>.  <a class="xref" href="#name-tcp-control-blocks">TCP Control Blocks</a><a class="pilcrow" href="#section-toc.1-1.11.2.2.1">¶</a></p>
<ul class="toc ulEmpty">
<li class="toc ulEmpty" id="section-toc.1-1.11.2.2.2.1">
                    <p id="section-toc.1-1.11.2.2.2.1.1"><a class="xref" href="#section-c.2.1">C.2.1</a>.  <a class="xref" href="#name-sending-side-2">Sending Side</a><a class="pilcrow" href="#section-toc.1-1.11.2.2.2.1.1">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.11.2.2.2.2">
                    <p id="section-toc.1-1.11.2.2.2.2.1"><a class="xref" href="#section-c.2.2">C.2.2</a>.  <a class="xref" href="#name-receiving-side-2">Receiving Side</a><a class="pilcrow" href="#section-toc.1-1.11.2.2.2.2.1">¶</a></p>
</li>
</ul>
</li>
</ul>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.12">
            <p id="section-toc.1-1.12.1"><a class="xref" href="#section-appendix.d">Appendix D</a>.  <a class="xref" href="#name-finite-state-machine">Finite State Machine</a><a class="pilcrow" href="#section-toc.1-1.12.1">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.13">
            <p id="section-toc.1-1.13.1"><a class="xref" href="#section-appendix.e">Appendix E</a>.  <a class="xref" href="#name-changes-from-rfc-6824">Changes from RFC 6824</a><a class="pilcrow" href="#section-toc.1-1.13.1">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.14">
            <p id="section-toc.1-1.14.1"><a class="xref" href="#section-appendix.f"></a><a class="xref" href="#name-acknowledgments">Acknowledgments</a><a class="pilcrow" href="#section-toc.1-1.14.1">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.15">
            <p id="section-toc.1-1.15.1"><a class="xref" href="#section-appendix.g"></a><a class="xref" href="#name-authors-addresses">Authors' Addresses</a><a class="pilcrow" href="#section-toc.1-1.15.1">¶</a></p>
</li>
</ul>
</nav>
</section>
</div>
<div id="sec_intro">
<section id="section-1">
      <h2 id="name-introduction">
<a class="section-number selfRef" href="#section-1">1. </a><a class="section-name selfRef" href="#name-introduction">Introduction</a>
      </h2>
<p id="section-1-1">Multipath TCP (MPTCP) is a set of extensions to regular TCP <span>[<a class="xref" href="#RFC0793">RFC0793</a>]</span> to provide a Multipath TCP service <span>[<a class="xref" href="#RFC6182">RFC6182</a>]</span>, which enables a transport connection to operate across multiple paths
simultaneously. This document presents the protocol changes required to add
multipath capability to TCP -- specifically, those for signaling and setting
up multiple paths ("subflows"), managing these subflows, reassembly of data,
and termination of sessions. This is not the only information required to create a Multipath TCP implementation, however. This document is complemented by three others:<a class="pilcrow" href="#section-1-1">¶</a></p>
<ul>
<li id="section-1-2.1">
          <span>[<a class="xref" href="#RFC6182">RFC6182</a>]</span> (MPTCP architecture), which
        explains the motivations behind Multipath TCP, contains a discussion
        of high-level design decisions on which this design is based, and provides an explanation of a functional separation through which an extensible MPTCP implementation can be developed.<a class="pilcrow" href="#section-1-2.1">¶</a>
</li>
<li id="section-1-2.2">
          <span>[<a class="xref" href="#RFC6356">RFC6356</a>]</span> (congestion control), which presents a safe congestion control algorithm for coupling the behavior of the multiple paths in order to "do no harm" to other network users.<a class="pilcrow" href="#section-1-2.2">¶</a>
</li>
<li id="section-1-2.3">
          <span>[<a class="xref" href="#RFC6897">RFC6897</a>]</span> (application considerations), which discusses what impact MPTCP will have on applications, what applications will want to do with MPTCP, and as a consequence of these factors, what API extensions an MPTCP implementation should present.<a class="pilcrow" href="#section-1-2.3">¶</a>
</li>
</ul>
<p id="section-1-3">
      This document obsoletes the v0 specification of
      Multipath TCP <span>[<a class="xref" href="#RFC6824">RFC6824</a>]</span>. This document specifies MPTCP v1, which is not backward compatible with MPTCP v0. This document additionally defines version negotiation procedures for implementations that support both versions.<a class="pilcrow" href="#section-1-3">¶</a></p>
<div id="sec_assum">
<section id="section-1.1">
        <h3 id="name-design-assumptions">
<a class="section-number selfRef" href="#section-1.1">1.1. </a><a class="section-name selfRef" href="#name-design-assumptions">Design Assumptions</a>
        </h3>
<p id="section-1.1-1">In order to limit the potentially huge design space, the
        MPTCP Working Group imposed two key constraints on the Multipath TCP design presented in this document:<a class="pilcrow" href="#section-1.1-1">¶</a></p>
<ul>
<li id="section-1.1-2.1">It must be backward compatible with current, regular TCP, to increase its chances of deployment.<a class="pilcrow" href="#section-1.1-2.1">¶</a>
</li>
<li id="section-1.1-2.2">It can be assumed that one or both hosts are multihomed and multiaddressed.<a class="pilcrow" href="#section-1.1-2.2">¶</a>
</li>
</ul>
<p id="section-1.1-3">To simplify the design, we assume that the presence of multiple
        addresses at a host is sufficient to indicate the existence of
        multiple paths. These paths need not be entirely disjoint: they may
        share one or many routers between them. Even in such a situation,
        making use of multiple paths is beneficial, improving resource
        utilization and resilience to a subset of node failures. The
        congestion control algorithm defined in <span>[<a class="xref" href="#RFC6356">RFC6356</a>]</span> ensures that the use of multiple paths does not act detrimentally.
 Furthermore, there may be some scenarios where different TCP ports on a
single host can provide disjoint paths (such as through certain
Equal-Cost Multipath (ECMP) implementations <span>[<a class="xref" href="#RFC2992">RFC2992</a>]</span>), and so the MPTCP design also supports the use of
ports in path identifiers.<a class="pilcrow" href="#section-1.1-3">¶</a></p>
<p id="section-1.1-4">There are three aspects to the backward compatibility listed above (discussed in more detail in <span>[<a class="xref" href="#RFC6182">RFC6182</a>]</span>):<a class="pilcrow" href="#section-1.1-4">¶</a></p>
<dl class="dlParallel" id="section-1.1-5">
          <dt id="section-1.1-5.1">External Constraints:</dt>
<dd id="section-1.1-5.2" style="margin-left: 1.5em"> The protocol must function through the vast majority of existing 
middleboxes such as NATs, firewalls, and proxies, and as such must resemble existing TCP as far as possible on the 
wire. Furthermore, the protocol must not assume that the segments it sends on the wire arrive unmodified at the destination:
they may be split or coalesced; TCP options may be removed or duplicated.<a class="pilcrow" href="#section-1.1-5.2">¶</a>
</dd>
<dt id="section-1.1-5.3">Application Constraints:</dt>
<dd id="section-1.1-5.4" style="margin-left: 1.5em"> The protocol must be usable with no change to existing applications that use the common TCP API (although it is reasonable that not all features would be available to such legacy applications). Furthermore, the protocol must provide the same service model as regular TCP to the application.<a class="pilcrow" href="#section-1.1-5.4">¶</a>
</dd>
<dt id="section-1.1-5.5">Fallback:</dt>
<dd id="section-1.1-5.6" style="margin-left: 1.5em"> The protocol should be able to fall back to standard TCP with no interference from the user, to be able to communicate with legacy hosts.<a class="pilcrow" href="#section-1.1-5.6">¶</a>
</dd>
</dl>
<p id="section-1.1-6">The complementary application considerations document <span>[<a class="xref" href="#RFC6897">RFC6897</a>]</span> discusses the necessary features
        of an API to provide backward compatibility, as well as API extensions to convey the behavior of MPTCP at a level of control and information equivalent to that available with regular, single-path TCP.<a class="pilcrow" href="#section-1.1-6">¶</a></p>
<p id="section-1.1-7">Further discussion of the design constraints and associated design decisions is given in the MPTCP architecture document <span>[<a class="xref" href="#RFC6182">RFC6182</a>]</span> and in <span>[<a class="xref" href="#howhard">howhard</a>]</span>.<a class="pilcrow" href="#section-1.1-7">¶</a></p>
</section>
</div>
<div id="sec_layers">
<section id="section-1.2">
        <h3 id="name-multipath-tcp-in-the-networ">
<a class="section-number selfRef" href="#section-1.2">1.2. </a><a class="section-name selfRef" href="#name-multipath-tcp-in-the-networ">Multipath TCP in the Networking Stack</a>
        </h3>
<p id="section-1.2-1">MPTCP operates at the transport layer and aims to be transparent to both higher and lower 
layers. It is a set of additional features on top of standard TCP; <a class="xref" href="#fig_arch">Figure 1</a> illustrates 
this layering. MPTCP is designed to be usable by legacy applications with no changes; detailed discussion 
of its interactions with applications is given in <span>[<a class="xref" href="#RFC6897">RFC6897</a>]</span>.<a class="pilcrow" href="#section-1.2-1">¶</a></p>
<span id="name-comparison-of-standard-tcp-"></span><div id="fig_arch">
<figure id="figure-1">
          <div class="artwork art-text alignLeft" id="section-1.2-2.1">
<pre>                                +-------------------------------+
                                |           Application         |
   +---------------+            +-------------------------------+
   |  Application  |            |             MPTCP             |
   +---------------+            + - - - - - - - + - - - - - - - +
   |      TCP      |            | Subflow (TCP) | Subflow (TCP) |
   +---------------+            +-------------------------------+
   |      IP       |            |       IP      |      IP       |
   +---------------+            +-------------------------------+</pre>
</div>
<figcaption><a class="selfRef" href="#figure-1">Figure 1</a>:
<a class="selfRef" href="#name-comparison-of-standard-tcp-">Comparison of Standard TCP and MPTCP Protocol Stacks</a>
          </figcaption></figure>
</div>
</section>
</div>
<section id="section-1.3">
        <h3 id="name-terminology">
<a class="section-number selfRef" href="#section-1.3">1.3. </a><a class="section-name selfRef" href="#name-terminology">Terminology</a>
        </h3>
<p id="section-1.3-1">This document makes use of a number of terms that are either MPTCP specific or have defined meaning in the context of MPTCP, as follows:<a class="pilcrow" href="#section-1.3-1">¶</a></p>
<dl class="dlParallel" id="section-1.3-2">
          <dt id="section-1.3-2.1">Path:</dt>
<dd id="section-1.3-2.2" style="margin-left: 1.5em"> A sequence of links between a sender and a receiver, defined in this context by a 4-tuple of source and destination address⁠/port pairs.<a class="pilcrow" href="#section-1.3-2.2">¶</a>
</dd>
<dt id="section-1.3-2.3">Subflow:</dt>
<dd id="section-1.3-2.4" style="margin-left: 1.5em"> A flow of TCP segments operating over an individual path, which forms part of a larger MPTCP connection. A subflow is started and terminated similarly to a regular TCP connection.<a class="pilcrow" href="#section-1.3-2.4">¶</a>
</dd>
<dt id="section-1.3-2.5">(MPTCP) Connection:</dt>
<dd id="section-1.3-2.6" style="margin-left: 1.5em"> A set of one or more subflows, over which an application can communicate between two hosts. There is a one‑to‑one mapping between a connection and an application socket.<a class="pilcrow" href="#section-1.3-2.6">¶</a>
</dd>
<dt id="section-1.3-2.7">Data-level:</dt>
<dd id="section-1.3-2.8" style="margin-left: 1.5em"> The payload data is nominally transferred over a connection, which in turn is transported over subflows.  Thus, the term "data-level" is synonymous with "connection-level", in contrast to "subflow-level", which refers to properties of an individual subflow.<a class="pilcrow" href="#section-1.3-2.8">¶</a>
</dd>
<dt id="section-1.3-2.9">Token:</dt>
<dd id="section-1.3-2.10" style="margin-left: 1.5em"> A locally unique identifier given to a multipath connection by a host. May also be referred to as a "Connection ID".<a class="pilcrow" href="#section-1.3-2.10">¶</a>
</dd>
<dt id="section-1.3-2.11">Host:</dt>
<dd id="section-1.3-2.12" style="margin-left: 1.5em"> An end host operating an MPTCP implementation, and either initiating or accepting an MPTCP connection.<a class="pilcrow" href="#section-1.3-2.12">¶</a>
</dd>
</dl>
<p id="section-1.3-3">
        In addition to these terms, note that MPTCP's interpretation of, and effect on, regular single-path TCP semantics are discussed in <a class="xref" href="#sec_semantics">Section 4</a>.<a class="pilcrow" href="#section-1.3-3">¶</a></p>
</section>
<div id="sec_operation">
<section id="section-1.4">
        <h3 id="name-mptcp-concept">
<a class="section-number selfRef" href="#section-1.4">1.4. </a><a class="section-name selfRef" href="#name-mptcp-concept">MPTCP Concept</a>
        </h3>
<p id="section-1.4-1">This section provides a high-level summary of normal 
operation of MPTCP; this type of scenario is illustrated in 
<a class="xref" href="#fig_scenario">Figure 2</a>. A detailed description of how
MPTCP operates is given in <a class="xref" href="#sec_protocol">Section 3</a>.<a class="pilcrow" href="#section-1.4-1">¶</a></p>
<span id="name-example-mptcp-usage-scenari"></span><div id="fig_scenario">
<figure id="figure-2">
          <div class="artwork art-text alignLeft" id="section-1.4-2.1">
<pre>            Host A                               Host B
   ------------------------             ------------------------
   Address A1    Address A2             Address B1    Address B2
   ----------    ----------             ----------    ----------
       |             |                      |             |
       |     (initial connection setup)     |             |
       |-----------------------------------&gt;|             |
       |&lt;-----------------------------------|             |
       |             |                      |             |
       |            (additional subflow setup)            |
       |             |---------------------&gt;|             |
       |             |&lt;---------------------|             |
       |             |                      |             |
       |             |                      |             |</pre>
</div>
<figcaption><a class="selfRef" href="#figure-2">Figure 2</a>:
<a class="selfRef" href="#name-example-mptcp-usage-scenari">Example MPTCP Usage Scenario</a>
          </figcaption></figure>
</div>
<ul>
<li id="section-1.4-3.1">To a non-MPTCP-aware application, MPTCP will behave the same as normal TCP. Extended APIs could provide 
additional control to MPTCP-aware applications <span>[<a class="xref" href="#RFC6897">RFC6897</a>]</span>. 
An application begins by opening a TCP socket in the normal way.
MPTCP signaling and operation are handled by the MPTCP implementation.<a class="pilcrow" href="#section-1.4-3.1">¶</a>
</li>
<li id="section-1.4-3.2">An MPTCP connection begins similarly to a regular TCP connection. This is 
illustrated in <a class="xref" href="#fig_scenario">Figure 2</a>, where an MPTCP connection is established between 
addresses A1 and B1 on Hosts A and B, respectively.<a class="pilcrow" href="#section-1.4-3.2">¶</a>
</li>
<li id="section-1.4-3.3">If extra paths are available, additional TCP sessions (termed MPTCP "subflows") 
are created on these paths and are combined with the existing session, which continues 
to appear as a single connection to the applications at both ends. The creation of the 
additional TCP session is illustrated between Address A2 on Host A and Address B1 on 
Host B.<a class="pilcrow" href="#section-1.4-3.3">¶</a>
</li>
<li id="section-1.4-3.4">MPTCP identifies multiple paths by the presence of multiple addresses 
at hosts. Combinations of these multiple addresses equate to the additional paths. 
In the example, other potential paths that could be set up are A1&lt;-&gt;B2 and A2&lt;-&gt;B2. 
Although this additional session is shown as being initiated from A2, it could equally have 
been initiated from B1 or B2.<a class="pilcrow" href="#section-1.4-3.4">¶</a>
</li>
<li id="section-1.4-3.5">The discovery and setup of additional subflows
will be achieved through a path management method; this document describes a mechanism 
by which a host can initiate new subflows by using its own additional addresses or by 
signaling its available addresses to the other host.<a class="pilcrow" href="#section-1.4-3.5">¶</a>
</li>
<li id="section-1.4-3.6">MPTCP adds connection-level sequence numbers to allow the reassembly of 
segments arriving on multiple subflows with differing network delays.<a class="pilcrow" href="#section-1.4-3.6">¶</a>
</li>
<li id="section-1.4-3.7">Subflows are terminated as regular TCP connections, with a four‑way FIN
handshake. The MPTCP connection is terminated by a connection-level FIN.<a class="pilcrow" href="#section-1.4-3.7">¶</a>
</li>
</ul>
</section>
</div>
<section id="section-1.5">
        <h3 id="name-requirements-language">
<a class="section-number selfRef" href="#section-1.5">1.5. </a><a class="section-name selfRef" href="#name-requirements-language">Requirements Language</a>
        </h3>
<p id="section-1.5-1">
    The key words "<span class="bcp14">MUST</span>", "<span class="bcp14">MUST NOT</span>",
    "<span class="bcp14">REQUIRED</span>", "<span class="bcp14">SHALL</span>", "<span class="bcp14">SHALL NOT</span>",
    "<span class="bcp14">SHOULD</span>", "<span class="bcp14">SHOULD NOT</span>",
    "<span class="bcp14">RECOMMENDED</span>", "<span class="bcp14">NOT RECOMMENDED</span>",
    "<span class="bcp14">MAY</span>", and "<span class="bcp14">OPTIONAL</span>" in this document are to be
    interpreted as described in BCP 14 <span>[<a class="xref" href="#RFC2119">RFC2119</a>]</span> <span>[<a class="xref" href="#RFC8174">RFC8174</a>]</span> when, and only when, they appear in all capitals, as
    shown here.<a class="pilcrow" href="#section-1.5-1">¶</a></p>
</section>
</section>
</div>
<div id="sec_overview">
<section id="section-2">
      <h2 id="name-operation-overview">
<a class="section-number selfRef" href="#section-2">2. </a><a class="section-name selfRef" href="#name-operation-overview">Operation Overview</a>
      </h2>
<p id="section-2-1">This section presents a single description of common MPTCP operation, with reference to the protocol operation. This is a high-level overview of the key functions; the full specification follows in <a class="xref" href="#sec_protocol">Section 3</a>. Extensibility and negotiated features are not discussed here. Considerable reference is made to symbolic names of MPTCP options throughout this section -- these are subtypes of the IANA‑assigned MPTCP option (see <a class="xref" href="#IANA">Section 7</a>), and their formats are defined in the detailed protocol specification provided in <a class="xref" href="#sec_protocol">Section 3</a>.<a class="pilcrow" href="#section-2-1">¶</a></p>
<p id="section-2-2">A Multipath TCP connection provides a bidirectional bytestream between two hosts communicating like normal TCP and thus does not require any change to the applications. However, Multipath TCP enables the hosts to use different paths with different IP addresses to exchange packets belonging to the MPTCP connection. A Multipath TCP connection appears like a normal TCP connection to an application. However, to the network layer, each MPTCP subflow looks like a regular TCP flow whose segments carry a new TCP option type. Multipath TCP manages the creation, removal, and utilization of these subflows to send data. The number of subflows that are managed within a Multipath TCP connection is not fixed, and it can fluctuate during the lifetime of the Multipath TCP connection.<a class="pilcrow" href="#section-2-2">¶</a></p>
<p id="section-2-3">All MPTCP operations are signaled with a TCP option -- a single numerical type for MPTCP, with "subtypes" for each MPTCP message. What follows is a summary of the purpose and rationale of these messages.<a class="pilcrow" href="#section-2-3">¶</a></p>
<section id="section-2.1">
        <h3 id="name-initiating-an-mptcp-connect">
<a class="section-number selfRef" href="#section-2.1">2.1. </a><a class="section-name selfRef" href="#name-initiating-an-mptcp-connect">Initiating an MPTCP Connection</a>
        </h3>
<p id="section-2.1-1">This is the same signaling as for initiating a normal TCP connection, but the SYN, SYN/ACK, and initial ACK (and data) packets also carry the MP_CAPABLE option. This option has a variable length and serves multiple purposes. Firstly, it verifies whether the remote host supports Multipath TCP; secondly, this option allows the hosts to exchange some information to authenticate the establishment of additional subflows. Further details are given in <a class="xref" href="#sec_init">Section 3.1</a>.<a class="pilcrow" href="#section-2.1-1">¶</a></p>
<div class="artwork art-text alignLeft" id="section-2.1-2">
<pre>   Host A                                  Host B
   ------                                  ------
   MP_CAPABLE                -&gt;
   [flags]
                             &lt;-            MP_CAPABLE
                                           [B's key, flags]
   ACK + MP_CAPABLE (+ data) -&gt;
   [A's key, B's key, flags, (data-level details)]</pre><a class="pilcrow" href="#section-2.1-2">¶</a>
</div>
<p id="section-2.1-3">Retransmission of the ACK + MP_CAPABLE can occur if it is not known if it has been received. The following diagrams show all possible exchanges for the initial subflow setup to ensure this reliability.<a class="pilcrow" href="#section-2.1-3">¶</a></p>
<div class="artwork art-text alignLeft" id="section-2.1-4">
<pre>   Host A (with data to send immediately)  Host B
   ------                                  ------
   MP_CAPABLE                -&gt;
   [flags]
                             &lt;-            MP_CAPABLE
                                           [B's key, flags]
   ACK + MP_CAPABLE + data   -&gt;
   [A's key, B's key, flags, data-level details]


   Host A (with data to send later)        Host B
   ------                                  ------
   MP_CAPABLE                -&gt;
   [flags]
                             &lt;-            MP_CAPABLE
                                           [B's key, flags]
   ACK + MP_CAPABLE          -&gt;
   [A's key, B's key, flags]

   ACK + MP_CAPABLE + data   -&gt;
   [A's key, B's key, flags, data-level details]


   Host A                                  Host B (sending first)
   ------                                  ------
   MP_CAPABLE                -&gt;
   [flags]
                             &lt;-            MP_CAPABLE
                                           [B's key, flags]
   ACK + MP_CAPABLE          -&gt;
   [A's key, B's key, flags]

                             &lt;-            ACK + DSS + data
                                           [data-level details]</pre><a class="pilcrow" href="#section-2.1-4">¶</a>
</div>
</section>
<section id="section-2.2">
        <h3 id="name-associating-a-new-subflow-w">
<a class="section-number selfRef" href="#section-2.2">2.2. </a><a class="section-name selfRef" href="#name-associating-a-new-subflow-w">Associating a New Subflow with an Existing MPTCP Connection</a>
        </h3>
<p id="section-2.2-1">The exchange of keys in the MP_CAPABLE handshake provides material that can be used to authenticate the endpoints when new subflows will be set up. 
Additional subflows begin in the same way as initiating a normal TCP connection, but the SYN, SYN/ACK, and ACK packets also carry the MP_JOIN option.<a class="pilcrow" href="#section-2.2-1">¶</a></p>
<p id="section-2.2-2">Host A initiates a new subflow between one of its addresses and one
        of Host B's addresses. The token -- generated from the key -- is used
        to identify which MPTCP connection it is joining, and the Hash‑based
        Message Authentication Code (HMAC) is used for authentication. The HMAC uses the keys exchanged in the MP_CAPABLE handshake and the random numbers (nonces) exchanged in these MP_JOIN options. MP_JOIN also contains flags and an Address ID that can be used to refer to the source address without the sender needing to know if it has been changed by a NAT. Further details are given in <a class="xref" href="#sec_join">Section 3.2</a>.<a class="pilcrow" href="#section-2.2-2">¶</a></p>
<div class="artwork art-text alignLeft" id="section-2.2-3">
<pre>   Host A                                  Host B
   ------                                  ------
   MP_JOIN               -&gt;
   [B's token, A's nonce,
    A's Address ID, flags]
                         &lt;-                MP_JOIN
                                           [B's HMAC, B's nonce,
                                            B's Address ID, flags]
   ACK + MP_JOIN         -&gt;
   [A's HMAC]

                         &lt;-                ACK</pre><a class="pilcrow" href="#section-2.2-3">¶</a>
</div>
</section>
<section id="section-2.3">
        <h3 id="name-informing-the-other-host-ab">
<a class="section-number selfRef" href="#section-2.3">2.3. </a><a class="section-name selfRef" href="#name-informing-the-other-host-ab">Informing the Other Host about Another Potential Address</a>
        </h3>
<p id="section-2.3-1">The set of IP addresses associated to a multihomed host may change during the lifetime of an MPTCP connection. MPTCP supports the addition and removal of addresses on a host both implicitly and explicitly. If Host A has established a subflow starting at address⁠/port pair IP#-A1 and wants to open a second subflow starting at address⁠/port pair IP#-A2, it simply initiates the establishment of the subflow as explained above. The remote host will then be implicitly informed about the new address.<a class="pilcrow" href="#section-2.3-1">¶</a></p>
<p id="section-2.3-2">In some circumstances, a host may want to advertise to the remote
        host the availability of an address without establishing a new subflow
 -- for example, when a NAT prevents setup in one direction.  In the example below, Host A informs Host B about its alternative IP address⁠/port pair (IP#-A2). Host B may later send an MP_JOIN to this new address. The ADD_ADDR option contains an HMAC to authenticate the address as having been sent from the originator of the connection. The receiver of this option echoes it back to the client to indicate successful receipt. Further details are given in <a class="xref" href="#sec_add_address">Section 3.4.1</a>.<a class="pilcrow" href="#section-2.3-2">¶</a></p>
<div class="artwork art-text alignLeft" id="section-2.3-3">
<pre>   Host A                                 Host B
   ------                                 ------
   ADD_ADDR                  -&gt;
   [Echo-flag=0,
    IP#-A2,
    IP#-A2's Address ID,
    HMAC of IP#-A2]

                             &lt;-          ADD_ADDR
                                         [Echo-flag=1,
                                          IP#-A2,
                                          IP#-A2's Address ID,
                                          HMAC of IP#-A2]</pre><a class="pilcrow" href="#section-2.3-3">¶</a>
</div>
<p id="section-2.3-4">There is a corresponding signal for address removal, making use of
        the Address ID that is signaled in the ADD_ADDR handshake.

 Further details are given in <a class="xref" href="#sec_remove_addr">Section 3.4.2</a>.<a class="pilcrow" href="#section-2.3-4">¶</a></p>
<div class="artwork art-text alignLeft" id="section-2.3-5">
<pre>   Host A                                 Host B
   ------                                 ------
   REMOVE_ADDR               -&gt;
   [IP#-A2's Address ID]</pre><a class="pilcrow" href="#section-2.3-5">¶</a>
</div>
</section>
<section id="section-2.4">
        <h3 id="name-data-transfer-using-mptcp">
<a class="section-number selfRef" href="#section-2.4">2.4. </a><a class="section-name selfRef" href="#name-data-transfer-using-mptcp">Data Transfer Using MPTCP</a>
        </h3>
<p id="section-2.4-1">To ensure reliable, in-order delivery of data over subflows that may appear and disappear at any time, MPTCP uses a 64-bit Data Sequence Number (DSN) to number all data sent over the MPTCP connection. Each subflow has its own 32-bit sequence number space, utilizing the regular TCP sequence number header, and an MPTCP option maps the subflow sequence space to the data sequence space. In this way, data can be retransmitted on different subflows (mapped to the same DSN) in the event of failure.<a class="pilcrow" href="#section-2.4-1">¶</a></p>
<p id="section-2.4-2">The Data Sequence Signal (DSS) carries the Data Sequence Mapping. The Data Sequence Mapping consists of the subflow sequence number, data sequence number, and length for which this mapping is valid. This option can also carry a connection-level acknowledgment (the "Data ACK") for the received DSN.<a class="pilcrow" href="#section-2.4-2">¶</a></p>
<p id="section-2.4-3">With MPTCP, all subflows share the same receive buffer and advertise the same receive window. There are two levels of acknowledgment in MPTCP. Regular TCP acknowledgments are used on each subflow to acknowledge the reception of the segments sent over the subflow independently of their DSN. In addition, there are connection-level acknowledgments for the data sequence space. These acknowledgments track the advancement of the bytestream and slide the receive window.<a class="pilcrow" href="#section-2.4-3">¶</a></p>
<p id="section-2.4-4">Further details are given in <a class="xref" href="#sec_generalop">Section 3.3</a>.<a class="pilcrow" href="#section-2.4-4">¶</a></p>
<div class="artwork art-text alignLeft" id="section-2.4-5">
<pre>   Host A                                 Host B
   ------                                 ------
   DSS                       -&gt;
   [Data Sequence Mapping]
   [Data ACK]
   [Checksum]</pre><a class="pilcrow" href="#section-2.4-5">¶</a>
</div>
</section>
<section id="section-2.5">
        <h3 id="name-requesting-a-change-in-a-pa">
<a class="section-number selfRef" href="#section-2.5">2.5. </a><a class="section-name selfRef" href="#name-requesting-a-change-in-a-pa">Requesting a Change in a Path's Priority</a>
        </h3>
<p id="section-2.5-1">Hosts can indicate at initial subflow setup whether they wish the subflow to be used as a regular or backup path -- a backup path only being used if there are no regular paths available. During a connection, Host A can request a change in the priority of a subflow through the MP_PRIO signal to Host B. Further details are given in <a class="xref" href="#sec_policy">Section 3.3.8</a>.<a class="pilcrow" href="#section-2.5-1">¶</a></p>
<div class="artwork art-text alignLeft" id="section-2.5-2">
<pre>   Host A                                 Host B
   ------                                 ------
   MP_PRIO                   -&gt;</pre><a class="pilcrow" href="#section-2.5-2">¶</a>
</div>
</section>
<section id="section-2.6">
        <h3 id="name-closing-an-mptcp-connection">
<a class="section-number selfRef" href="#section-2.6">2.6. </a><a class="section-name selfRef" href="#name-closing-an-mptcp-connection">Closing an MPTCP Connection</a>
        </h3>
<p id="section-2.6-1">When a host wants to close an existing subflow but not the whole connection, it can initiate a regular TCP FIN/ACK exchange.<a class="pilcrow" href="#section-2.6-1">¶</a></p>
<p id="section-2.6-2">When Host A wants to inform Host B that it has no more data to send, it signals this "Data FIN" as part of the DSS (see above). It has the same semantics and behavior as a regular TCP FIN, but at the connection level. Once all the data on the MPTCP connection has been successfully received, this message is acknowledged at the connection level with a Data ACK. Further details are given in <a class="xref" href="#sec_close">Section 3.3.3</a>.<a class="pilcrow" href="#section-2.6-2">¶</a></p>
<div class="artwork art-text alignLeft" id="section-2.6-3">
<pre>   Host A                                 Host B
   ------                                 ------
   DSS                       -&gt;
   [Data FIN]
                             &lt;-           DSS
                                          [Data ACK]</pre><a class="pilcrow" href="#section-2.6-3">¶</a>
</div>
<p id="section-2.6-4">There is an additional method of connection closure, referred to as
        "Fast Close", which is analogous to closing a single-path TCP
        connection with a RST signal. The MP_FASTCLOSE signal is used to
        indicate to the peer that the connection will be abruptly closed and
        no data will be accepted anymore. This can be used on an ACK (which
        ensures reliability of the signal) or a RST (which does not).
 Both examples are shown in the following diagrams. Further details are given in <a class="xref" href="#sec_fastclose">Section 3.5</a>.<a class="pilcrow" href="#section-2.6-4">¶</a></p>
<div class="artwork art-text alignLeft" id="section-2.6-5">
<pre>   Host A                                 Host B
   ------                                 ------
   ACK + MP_FASTCLOSE          -&gt;
   [B's key]

   [RST on all other subflows] -&gt;

                               &lt;-         [RST on all subflows]


   Host A                                 Host B
   ------                                 ------
   RST + MP_FASTCLOSE          -&gt;
   [B's key] [on all subflows]

                               &lt;-         [RST on all subflows]</pre><a class="pilcrow" href="#section-2.6-5">¶</a>
</div>
</section>
<section id="section-2.7">
        <h3 id="name-notable-features">
<a class="section-number selfRef" href="#section-2.7">2.7. </a><a class="section-name selfRef" href="#name-notable-features">Notable Features</a>
        </h3>
<p id="section-2.7-1">It is worth highlighting that MPTCP's signaling has been designed with several key requirements in mind:<a class="pilcrow" href="#section-2.7-1">¶</a></p>
<ul>
<li id="section-2.7-2.1">To cope with NATs on the path, addresses are referred to by Address IDs, in case the IP packet's source 
address gets changed by a NAT. Setting up a new TCP flow is not possible if the receiver of the SYN is behind a NAT; 
to allow subflows to be created when either end is behind a NAT, MPTCP uses the ADD_ADDR message.<a class="pilcrow" href="#section-2.7-2.1">¶</a>
</li>
<li id="section-2.7-2.2">MPTCP falls back to ordinary TCP if MPTCP operation is not
 possible -- for example, if one host is not MPTCP capable or if a middlebox alters the payload. This is discussed in <a class="xref" href="#sec_fallback">Section 3.7</a>.<a class="pilcrow" href="#section-2.7-2.2">¶</a>
</li>
<li id="section-2.7-2.3">To address the threats identified in <span>[<a class="xref" href="#RFC6181">RFC6181</a>]</span>, the following steps are taken: keys are sent in
          the clear in the MP_CAPABLE messages; MP_JOIN messages are secured
          with HMAC-SHA256 (<span>[<a class="xref" href="#RFC2104">RFC2104</a>]</span> using
          the algorithm in <span>[<a class="xref" href="#RFC6234">RFC6234</a>]</span>) using those keys; and standard
          TCP validity checks are made on the other messages (ensuring that
          sequence numbers are in‑window <span>[<a class="xref" href="#RFC5961">RFC5961</a>]</span>).
 Residual threats to MPTCP v0 were identified in <span>[<a class="xref" href="#RFC7430">RFC7430</a>]</span>, and those affecting the protocol (i.e., modifications to
 ADD_ADDR) have been incorporated in this document.
 Further discussion of security can be found in <a class="xref" href="#sec_security">Section 5</a>.<a class="pilcrow" href="#section-2.7-2.3">¶</a>
</li>
</ul>
</section>
</section>
</div>
<div id="sec_protocol">
<section id="section-3">
      <h2 id="name-mptcp-operations-an-overvie">
<a class="section-number selfRef" href="#section-3">3. </a><a class="section-name selfRef" href="#name-mptcp-operations-an-overvie">MPTCP Operations: An Overview</a>
      </h2>
<p id="section-3-1">This section describes the operation of MPTCP. The
      subsections below discuss each key part of the protocol operation.<a class="pilcrow" href="#section-3-1">¶</a></p>
<p id="section-3-2">All MPTCP operations are signaled using optional TCP header fields. A single TCP option number ("Kind") has been assigned by IANA for MPTCP (see <a class="xref" href="#IANA">Section 7</a>), and then individual messages will be determined by a "subtype", the values of which are also stored in an IANA registry (and are also listed in <a class="xref" href="#IANA">Section 7</a>). As with all TCP options, the Length field is specified in bytes and includes the 2 bytes of Kind and Length.<a class="pilcrow" href="#section-3-2">¶</a></p>
<p id="section-3-3">Throughout this document, when reference is made to an MPTCP option by symbolic name, such as "MP_CAPABLE", this refers to a TCP option with the single MPTCP option type, and with the subtype value of the symbolic name as defined in <a class="xref" href="#IANA">Section 7</a>. This subtype is a 4-bit field -- the first 4 bits of the option payload, as shown in <a class="xref" href="#fig_option">Figure 3</a>. The MPTCP messages are defined in the following sections.<a class="pilcrow" href="#section-3-3">¶</a></p>
<span id="name-mptcp-option-format"></span><div id="fig_option">
<figure id="figure-3">
        <div class="artwork art-text alignLeft" id="section-3-4.1">
<pre>                       1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +---------------+---------------+-------+-----------------------+
  |     Kind      |    Length     |Subtype|                       |
  +---------------+---------------+-------+                       |
  |                     Subtype-specific data                     |
  |                       (variable length)                       |
  +---------------------------------------------------------------+</pre>
</div>
<figcaption><a class="selfRef" href="#figure-3">Figure 3</a>:
<a class="selfRef" href="#name-mptcp-option-format">MPTCP Option Format</a>
        </figcaption></figure>
</div>
<p id="section-3-5">Those MPTCP options associated with subflow initiation are used on
      packets with the SYN flag set. Additionally, there is one MPTCP option
      for signaling metadata to ensure that segmented data can be recombined for delivery to the application.<a class="pilcrow" href="#section-3-5">¶</a></p>
<p id="section-3-6">The remaining options, however, are signals that do not need to be on
      a specific packet, such as those for signaling additional
      addresses. While an implementation may desire to send MPTCP options as
      soon as possible, it may not be possible to combine all desired options
      (both those for MPTCP and for regular TCP, such as SACK (selective
      acknowledgment) <span>[<a class="xref" href="#RFC2018">RFC2018</a>]</span>) on a single
      packet. Therefore, an implementation may choose to send duplicate ACKs
      containing the additional signaling information. This changes the
      semantics of a duplicate ACK; these are usually only sent as a signal of
      a lost segment <span>[<a class="xref" href="#RFC5681">RFC5681</a>]</span> in regular
      TCP. Therefore, an MPTCP implementation receiving a duplicate ACK that
      contains an MPTCP option <span class="bcp14">MUST NOT</span> treat it as a signal of
      congestion. Additionally, an MPTCP implementation <span class="bcp14">SHOULD NOT</span> send more than two duplicate ACKs in a row for the purposes
      of sending MPTCP options alone, in order to ensure that no middleboxes misinterpret this as a sign of congestion.<a class="pilcrow" href="#section-3-6">¶</a></p>
<p id="section-3-7">Furthermore, standard TCP validity checks (such as ensuring that the
      sequence number and acknowledgment number are within the window) <span class="bcp14">MUST</span> be undertaken before processing any MPTCP signals, as described in <span>[<a class="xref" href="#RFC5961">RFC5961</a>]</span>, and initial subflow sequence numbers <span class="bcp14">SHOULD</span> be generated according to the recommendations in <span>[<a class="xref" href="#RFC6528">RFC6528</a>]</span>.<a class="pilcrow" href="#section-3-7">¶</a></p>
<div id="sec_init">
<section id="section-3.1">
        <h3 id="name-connection-initiation">
<a class="section-number selfRef" href="#section-3.1">3.1. </a><a class="section-name selfRef" href="#name-connection-initiation">Connection Initiation</a>
        </h3>
<p id="section-3.1-1">Connection initiation begins with a SYN, SYN/ACK, ACK exchange
        on a single path. Each packet
        contains the Multipath Capable (MP_CAPABLE) MPTCP option
        (<a class="xref" href="#tcpm_capable">Figure 4</a>). This option declares its
        sender capable of performing Multipath TCP and wishes to do
        so on this particular connection.<a class="pilcrow" href="#section-3.1-1">¶</a></p>
<span id="name-multipath-capable-mp_capabl"></span><div id="tcpm_capable">
<figure id="figure-4">
          <div class="artwork art-text alignLeft" id="section-3.1-2.1">
<pre>                       1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +---------------+---------------+-------+-------+---------------+
  |     Kind      |    Length     |Subtype|Version|A|B|C|D|E|F|G|H|
  +---------------+---------------+-------+-------+---------------+
  |                   Option Sender's Key (64 bits)               |
  |                      (if option Length &gt; 4)                   |
  |                                                               |
  +---------------------------------------------------------------+
  |                  Option Receiver's Key (64 bits)              |
  |                      (if option Length &gt; 12)                  |
  |                                                               |
  +-------------------------------+-------------------------------+
  |  Data-Level Length (16 bits)  |  Checksum (16 bits, optional) |
  +-------------------------------+-------------------------------+</pre>
</div>
<figcaption><a class="selfRef" href="#figure-4">Figure 4</a>:
<a class="selfRef" href="#name-multipath-capable-mp_capabl">Multipath Capable (MP_CAPABLE) Option</a>
          </figcaption></figure>
</div>
<p id="section-3.1-3">The MP_CAPABLE exchange in this specification (v1) is different than
        that specified in v0.  If a host supports multiple versions
        of MPTCP, the sender of the MP_CAPABLE option <span class="bcp14">SHOULD</span> signal the
        highest version number it supports.  In return, in its MP_CAPABLE option,
        the receiver will signal the version number it wishes to use, which <span class="bcp14">MUST</span>
        be equal to or lower than the version number indicated in the initial
        MP_CAPABLE.
        There is a caveat, though, with respect to this version negotiation with
        old listeners that only support v0. A listener that supports v0 expects that
        the MP_CAPABLE option in the SYN segment will include the initiator's
        key. If, however,
        the initiator already upgraded to v1, it won't include the key in the
        SYN segment. Thus, the listener will ignore the MP_CAPABLE of this SYN segment
        and reply with a SYN/ACK that does not include an MP_CAPABLE. The initiator <span class="bcp14">MAY</span>
        choose to immediately fall back to TCP or <span class="bcp14">MAY</span> choose to attempt a connection
        using MPTCP v0 (if the initiator supports v0), in order to discover whether the
        listener supports the earlier version of MPTCP. In general, an MPTCP v0 connection
        will likely be preferred over a TCP connection; however, in a particular deployment scenario,
        it may be known that the listener is unlikely to support MPTCP v0 and so the
        initiator may prefer not to attempt a v0 connection. An initiator <span class="bcp14">MAY</span> cache 
        information for a peer about what version of MPTCP it supports, if any, and use
        this information for future connection attempts.<a class="pilcrow" href="#section-3.1-3">¶</a></p>
<p id="section-3.1-4">The MP_CAPABLE option is of variable length, with different fields
        included, depending on which packet the option is used on. The full 
        MP_CAPABLE option is shown in <a class="xref" href="#tcpm_capable">Figure 4</a>.<a class="pilcrow" href="#section-3.1-4">¶</a></p>
<p id="section-3.1-5">The MP_CAPABLE option is carried on the SYN, SYN/ACK, and ACK packets that start the first subflow of an MPTCP connection, as well as the first packet that carries data, if the initiator wishes to send first. The data carried by each option is as follows, where A = initiator and B = listener.<a class="pilcrow" href="#section-3.1-5">¶</a></p>
<ul>
<li id="section-3.1-6.1">SYN (A-&gt;B): only the first 4 octets (Length = 4).<a class="pilcrow" href="#section-3.1-6.1">¶</a>
</li>
<li id="section-3.1-6.2">SYN/ACK (B-&gt;A): B's key for this connection (Length = 12).<a class="pilcrow" href="#section-3.1-6.2">¶</a>
</li>
<li id="section-3.1-6.3">ACK (no data) (A-&gt;B): A's key followed by B's key (Length = 20).<a class="pilcrow" href="#section-3.1-6.3">¶</a>
</li>
<li id="section-3.1-6.4">ACK (with first data) (A-&gt;B): A's key followed by B's key followed by Data-Level Length, and optional Checksum (Length = 22 or 24).<a class="pilcrow" href="#section-3.1-6.4">¶</a>
</li>
</ul>
<p id="section-3.1-7">
        The contents of the option are determined by the SYN and ACK flags of the packet, along with the option's Length field. In <a class="xref" href="#tcpm_capable">Figure 4</a>, "Sender" and "Receiver" refer to the sender or receiver of the TCP packet (which can be either host).<a class="pilcrow" href="#section-3.1-7">¶</a></p>
<p id="section-3.1-8">The initial SYN, containing just the MP_CAPABLE header, is used
        to define the version of MPTCP being requested and also to exchange
        flags to negotiate connection features, as described later.<a class="pilcrow" href="#section-3.1-8">¶</a></p>
<p id="section-3.1-9">This option is used to declare the 64-bit keys that the end hosts
        have generated for this MPTCP connection. These keys are used to
        authenticate the addition of future subflows to this connection. This
        is the only time the key will be sent in the clear on the wire (unless "Fast Close" (<a class="xref" href="#sec_fastclose">Section 3.5</a>) is used); all future subflows will identify the connection using a 32-bit "token". This token is a cryptographic hash of this key. The algorithm for this process is dependent on the authentication algorithm selected; the method of selection is defined later in this section.<a class="pilcrow" href="#section-3.1-9">¶</a></p>
<p id="section-3.1-10">Upon reception of the initial SYN segment, a stateful server generates a random key and replies with a SYN/ACK. The key's method of generation is implementation specific. The key <span class="bcp14">MUST</span> be hard to guess, and it <span class="bcp14">MUST</span> be unique for the sending host across all its current MPTCP connections. Recommendations for generating random numbers for use in keys are given in <span>[<a class="xref" href="#RFC4086">RFC4086</a>]</span>. Connections will be indexed at each host by the token (a one-way hash of the key). Therefore, an implementation will require a mapping from each token to the corresponding connection, and in turn to the keys for the connection.<a class="pilcrow" href="#section-3.1-10">¶</a></p>
<p id="section-3.1-11">There is a risk that two different keys will hash to the same
        token. The risk of hash collisions is usually small, unless the host
        is handling many tens of thousands of connections. Therefore, an
        implementation <span class="bcp14">SHOULD</span> check its list of connection
        tokens to ensure that there is no collision before sending its key,
        and if there is, then it should generate a new key. This would,
        however, be costly for a server with thousands of connections. The
        subflow handshake mechanism (<a class="xref" href="#sec_join">Section 3.2</a>) will ensure that new subflows only join the
        correct connection, however, through the cryptographic handshake, as
        well as checking the connection tokens in both directions, and
        ensuring that sequence numbers are in-window. So, in the worst case, if there was a token collision, the new subflow would not succeed, but the MPTCP connection would continue to provide a regular TCP service.<a class="pilcrow" href="#section-3.1-11">¶</a></p>
<p id="section-3.1-12">Since key generation is implementation specific, there is no
        requirement that they simply be random numbers. An implementation is
        free to exchange cryptographic material out of band and generate these
        keys from this material, in order to provide additional mechanisms by which to verify the identity of the communicating entities. For example, an implementation could choose to link its MPTCP keys to those used in higher-layer TLS or SSH connections.<a class="pilcrow" href="#section-3.1-12">¶</a></p>
<p id="section-3.1-13">If the server behaves in a
        stateless manner, it has to generate its own key in a verifiable
        fashion.  This verifiable way of generating the key can be done by
        using a hash of the 4-tuple, sequence number, and a local secret
        (similar to what is done for the TCP sequence number <span>[<a class="xref" href="#RFC4987">RFC4987</a>]</span>).
        It will thus be able to verify whether it is indeed the originator of
        the key echoed back in the subsequent MP_CAPABLE option.  
        As for a stateful server, the tokens <span class="bcp14">SHOULD</span> be checked for uniqueness; however,
        if uniqueness is not met and there is no way to generate an alternative verifiable
        key, then the connection <span class="bcp14">MUST</span> fall back to using regular TCP by not sending an
        MP_CAPABLE in the SYN⁠/ACK.<a class="pilcrow" href="#section-3.1-13">¶</a></p>
<p id="section-3.1-14">The ACK carries both A's key and B's key. This is the first time that A's key is seen on the wire, although it is expected that A will have generated a key locally before the initial SYN. The echoing of B's key allows B to operate statelessly, as described above. Therefore, A's key must be delivered reliably to B, and in order to do this, the transmission of this packet must be made reliable.<a class="pilcrow" href="#section-3.1-14">¶</a></p>
<p id="section-3.1-15">If B has data to send first, then the reliable delivery of the
        ACK + MP_CAPABLE is ensured by the receipt of this data with an
        MPTCP Data Sequence Signal (DSS) option (<a class="xref" href="#sec_generalop">Section 3.3</a>) containing a DATA_ACK for the MP_CAPABLE (which is
 the first octet of the data sequence space). If, however, A wishes to send data first, it has
        two options to ensure the reliable delivery of the ACK + MP_CAPABLE. If
        it immediately has data to send, then the first ACK (with data) would
        also contain an MP_CAPABLE option with additional data parameters (the
        Data-Level Length and optional Checksum as shown in <a class="xref" href="#tcpm_capable">Figure 4</a>). If A does not immediately
        have data to send, it <span class="bcp14">MUST</span> include the MP_CAPABLE on
        the first ACK, but without the additional data parameters. When A does
        have data to send, it must repeat the sending of the MP_CAPABLE option
        from the first ACK, with additional data parameters. This MP_CAPABLE
        option is used in place of the DSS and simply specifies (1) the Data-Level
        Length of the payload and (2) the checksum (if the use of checksums is
        negotiated). This is the minimal data required to establish an MPTCP
        connection -- it allows validation of the payload, and given that it is the
        first data, the Initial Data Sequence Number (IDSN) is also known (as
        it is generated from the key, as described below). Conveying the keys
        on the first data packet allows the TCP reliability mechanisms to
        ensure that the packet is successfully delivered. The receiver will acknowledge this data at the connection level with a Data ACK, as if a DSS option has been received.<a class="pilcrow" href="#section-3.1-15">¶</a></p>
<p id="section-3.1-16">There could be situations where both A and B attempt to transmit
        initial data at the same time. For example, if A did not initially
        have data to send but then needed to transmit data before it had
        received anything from B, it would use an MP_CAPABLE option with data
        parameters (since it would not know if the MP_CAPABLE on the ACK was
        received). In such a situation, B may also have transmitted data with
        a DSS option, but it had not yet been received at A. Therefore, B has
        received data with an MP_CAPABLE mapping after it has sent data with a
        DSS option. To ensure that these situations can be handled, it follows that the data parameters in an MP_CAPABLE are semantically equivalent to those in a DSS option and can be used interchangeably. Similar situations could occur when the MP_CAPABLE with data is lost and retransmitted. Furthermore, in the case of TCP segmentation offloading, the MP_CAPABLE with data parameters may be duplicated across multiple packets, and implementations must also be able to cope with duplicate MP_CAPABLE mappings as well as duplicate DSS mappings.<a class="pilcrow" href="#section-3.1-16">¶</a></p>
<p id="section-3.1-17">Additionally, the MP_CAPABLE exchange allows the safe passage of
        MPTCP options on SYN packets to be determined. If any of these options
        are dropped, MPTCP will gracefully fall back to regular single-path
        TCP, as documented in <a class="xref" href="#sec_fallback">Section 3.7</a>.
        If at any point in the handshake either party thinks the MPTCP
        negotiation is compromised -- for example, by a middlebox corrupting
        the TCP options or by unexpected ACK numbers being present -- the host <span class="bcp14">MUST</span> stop using MPTCP and no longer include MPTCP options in future TCP packets. The other host will then also fall back to regular TCP using the fallback mechanism.  Note that new subflows <span class="bcp14">MUST NOT</span> be established (using the process documented in <a class="xref" href="#sec_join">Section 3.2</a>) until a DSS option has been successfully received across the path (as documented in <a class="xref" href="#sec_generalop">Section 3.3</a>).<a class="pilcrow" href="#section-3.1-17">¶</a></p>
<p id="section-3.1-18">Like all MPTCP options, the MP_CAPABLE option starts with the Kind
        and Length to specify the TCP option's kind and length. This
        information is followed by the MP_CAPABLE option. The first 4 bits of
        the first octet in the MP_CAPABLE option (<a class="xref" href="#tcpm_capable">Figure 4</a>) define the MPTCP Option Subtype (see <a class="xref" href="#IANA">Section 7</a>; for MP_CAPABLE, this value is
        0x0), and the remaining 4 bits of this octet specify the MPTCP
        version in use (for this specification, this value is 1).<a class="pilcrow" href="#section-3.1-18">¶</a></p>
<p id="section-3.1-19">The second octet is reserved for flags, allocated as follows:<a class="pilcrow" href="#section-3.1-19">¶</a></p>
<dl class="dlParallel" id="section-3.1-20">
          <dt id="section-3.1-20.1">A:</dt>
<dd id="section-3.1-20.2" style="margin-left: 7.0em"> The leftmost bit, labeled "A", <span class="bcp14">SHOULD</span> be set to 1 to indicate "Checksum required", unless the system administrator has decided that checksums are not required (for example, if the environment is controlled and no middleboxes exist that might adjust the payload).<a class="pilcrow" href="#section-3.1-20.2">¶</a>
</dd>
<dt id="section-3.1-20.3">B:</dt>
<dd id="section-3.1-20.4" style="margin-left: 7.0em"> The second bit, labeled "B", is an extensibility flag. It
          <span class="bcp14">MUST</span> be set to 0 for current implementations. This
          flag will be used for an extensibility mechanism in a future specification, and the impact of this flag will be defined at a later date. It is expected, but not mandated, that this flag would be used as part of an alternative security mechanism that does not require a full version upgrade of the protocol but does require redefining some elements of the handshake. If receiving a message with the "B" flag set to 1 and this is not understood, then the MP_CAPABLE in this SYN <span class="bcp14">MUST</span> be silently ignored, which triggers a fallback to regular TCP; the sender is expected to retry with a format compatible with this legacy specification. Note that the length of the MP_CAPABLE option, and the meanings of bits "D" through "H", may be altered by setting B=1.<a class="pilcrow" href="#section-3.1-20.4">¶</a>
</dd>
<dt id="section-3.1-20.5">C:</dt>
<dd id="section-3.1-20.6" style="margin-left: 7.0em"> The third bit, labeled "C", is set to 1 to indicate that the
          sender of this option will not accept additional MPTCP subflows to
          the source address and port, and therefore the receiver <span class="bcp14">MUST NOT</span> try to open any additional subflows toward this address
          and port. This improves efficiency in situations where the
          sender knows a restriction is in place -- for example, if the sender is behind a strict NAT or operating behind a legacy Layer 4 load balancer.<a class="pilcrow" href="#section-3.1-20.6">¶</a>
</dd>
<dt id="section-3.1-20.7">D through H:</dt>
<dd id="section-3.1-20.8" style="margin-left: 7.0em"> The remaining bits, labeled "D" through "H", are used for
          crypto algorithm negotiation.  In this specification, only the
          rightmost bit, labeled "H", is assigned.  Bit "H" indicates the use
          of HMAC-SHA256 (as defined in <a class="xref" href="#sec_join">Section 3.2</a>).  An implementation that only supports this
          method <span class="bcp14">MUST</span> set bit "H" to 1 and bits "D"
          through "G" to 0.<a class="pilcrow" href="#section-3.1-20.8">¶</a>
</dd>
</dl>
<p id="section-3.1-21">A crypto algorithm <span class="bcp14">MUST</span> be specified.  If flag bits "D" through "H" are all 0, the MP_CAPABLE option <span class="bcp14">MUST</span> be treated as invalid and ignored (that is, it must be treated as a regular TCP handshake).<a class="pilcrow" href="#section-3.1-21">¶</a></p>
<p id="section-3.1-22">The selection of the authentication algorithm also impacts the algorithm used to generate the token and the IDSN. In this specification, with only the SHA-256 algorithm (bit "H") specified and selected, the token <span class="bcp14">MUST</span> be a truncated (most significant 32 bits) SHA-256 hash <span>[<a class="xref" href="#RFC6234">RFC6234</a>]</span> of the key. A different, 64-bit truncation (the least significant 64 bits) of the SHA-256 hash of the key <span class="bcp14">MUST</span> be used as the IDSN. Note that the key <span class="bcp14">MUST</span> be hashed in network byte order. Also note that the "least significant" bits <span class="bcp14">MUST</span> be the rightmost bits of the SHA-256 digest, as per <span>[<a class="xref" href="#RFC6234">RFC6234</a>]</span>. Future specifications of the use of the crypto bits may choose to specify different algorithms for token and IDSN generation.<a class="pilcrow" href="#section-3.1-22">¶</a></p>
<p id="section-3.1-23">Both the crypto and checksum bits negotiate capabilities in similar
        ways. For the "Checksum required" bit (labeled "A"), if either host
        requires the use of checksums, checksums <span class="bcp14">MUST</span> be
        used. In other words, the only way for checksums not to be used is if
        both hosts in their SYNs set A=0. This decision is confirmed by the
        setting of the "A" bit in the third packet (the ACK) of the
        handshake. For example, if the initiator sets A=0 in the SYN but the
        responder sets A=1 in the SYN/ACK, checksums <span class="bcp14">MUST</span> be
        used in both directions, and the initiator will set A=1 in the
        ACK. The decision regarding whether to use checksums will be stored by an implementation in a per-connection binary state variable. If A=1 is received by a host that does not want to use checksums, it <span class="bcp14">MUST</span> fall back to regular TCP by ignoring the MP_CAPABLE option as if it was invalid.<a class="pilcrow" href="#section-3.1-23">¶</a></p>
<p id="section-3.1-24">For crypto negotiation, the responder has the choice. The initiator
        creates a proposal setting a bit for each algorithm it supports to 1
        (in this version of the specification, there is only one proposal, so
        bit "H" will always be set to 1). The responder responds with only 1 bit set -- this is the chosen algorithm. The rationale for this behavior is that the responder will typically be a server with potentially many thousands of connections, so it may wish to choose an algorithm with minimal computational complexity, depending on the load. If a responder does not support (or does not want to support) any of the initiator's proposals, it <span class="bcp14">MUST</span> respond without an MP_CAPABLE option, thus forcing a fallback to regular TCP.<a class="pilcrow" href="#section-3.1-24">¶</a></p>
<p id="section-3.1-25">The MP_CAPABLE option is only used in the first subflow of a
        connection, in order to identify the connection; all subsequent
        subflows will use the MP_JOIN option (see <a class="xref" href="#sec_join">Section 3.2</a>) to join the existing connection.<a class="pilcrow" href="#section-3.1-25">¶</a></p>
<p id="section-3.1-26">If a SYN contains an MP_CAPABLE option but the
        SYN/ACK does not, it is assumed that the sender of the SYN/ACK is not
        multipath capable; thus, the MPTCP session <span class="bcp14">MUST</span> operate as
        a regular, single-path TCP session. If a SYN does not contain an
        MP_CAPABLE option, the SYN/ACK <span class="bcp14">MUST NOT</span> contain one
        in response. If the third packet (the ACK) does not contain
        the MP_CAPABLE option, then the session <span class="bcp14">MUST</span> fall back to
        operating as a regular, single-path TCP session. This is done to maintain
        compatibility with middleboxes on the path that drop some 
        or all TCP options. Note that an implementation <span class="bcp14">MAY</span> choose
        to attempt sending MPTCP options more than one time before 
        making this decision to operate as regular TCP (see
        <a class="xref" href="#heuristics">Section 3.9</a>).<a class="pilcrow" href="#section-3.1-26">¶</a></p>
<p id="section-3.1-27">If the SYN packets are unacknowledged, it is up to local
        policy to decide how to respond. It is expected that a sender
        will eventually fall back to single-path TCP (i.e., without the
        MP_CAPABLE option) in order to work around middleboxes that
        may drop packets with unknown options; however, the number of
        multipath-capable attempts that are made first will be up to
        local policy.  
        It is possible that MPTCP and non-MPTCP SYNs could get reordered
        in the network. Therefore, the final state is inferred from the
        presence or absence of the MP_CAPABLE option in the third packet
        of the TCP handshake.  If this option is not present, the 
        connection <span class="bcp14">SHOULD</span> fall back to regular TCP, as documented in 
        <a class="xref" href="#sec_fallback">Section 3.7</a>.<a class="pilcrow" href="#section-3.1-27">¶</a></p>
<p id="section-3.1-28">The IDSN on an MPTCP connection 
        is generated from the key. The algorithm for IDSN generation is
        also determined from the negotiated authentication algorithm.
        In this specification, with only the SHA-256 algorithm specified and
        selected, the IDSN of a host <span class="bcp14">MUST</span> be the least significant 64 bits of the
        SHA-256 hash of its key, i.e., IDSN-A = Hash(Key-A) and IDSN-B = Hash(Key-B). 
        This deterministic generation of the IDSN allows a receiver to ensure 
        that there are no gaps in sequence space at the start of the connection. 
        The SYN with MP_CAPABLE occupies the first octet of data sequence space, 
        although this does not need to be acknowledged at the connection level 
        until the first data is sent (see <a class="xref" href="#sec_generalop">Section 3.3</a>).<a class="pilcrow" href="#section-3.1-28">¶</a></p>
</section>
</div>
<div id="sec_join">
<section id="section-3.2">
        <h3 id="name-starting-a-new-subflow">
<a class="section-number selfRef" href="#section-3.2">3.2. </a><a class="section-name selfRef" href="#name-starting-a-new-subflow">Starting a New Subflow</a>
        </h3>
<p id="section-3.2-1">Once an MPTCP connection has begun with the MP_CAPABLE
        exchange, further subflows can be added to the connection.
        Hosts have knowledge of their own address(es) and can
        become aware of the other host's addresses through
        signaling exchanges as described in
        <a class="xref" href="#sec_pm">Section 3.4</a>. Using this knowledge, a host
        can initiate a new subflow over a currently unused pair of
        addresses. It is permissible for either host in a connection
        to initiate the creation of a new subflow, but it is expected
        that this will normally be the original connection initiator
        (see <a class="xref" href="#heuristics">Section 3.9</a> for heuristics).<a class="pilcrow" href="#section-3.2-1">¶</a></p>
<p id="section-3.2-2">A new subflow is started as a normal TCP SYN/ACK
        exchange. The Join Connection (MP_JOIN) MPTCP option
        is used to identify the connection to be joined by the new subflow.  
        It uses keying material that was exchanged in the initial MP_CAPABLE
        handshake (<a class="xref" href="#sec_init">Section 3.1</a>), and that handshake also
        negotiates the crypto algorithm in use for the MP_JOIN handshake.<a class="pilcrow" href="#section-3.2-2">¶</a></p>
<p id="section-3.2-3">This section specifies the behavior of MP_JOIN using the HMAC-SHA256 
        algorithm. An MP_JOIN option is present in the SYN, SYN/ACK, 
        and ACK of the three-way handshake, although in each case with a 
        different format.<a class="pilcrow" href="#section-3.2-3">¶</a></p>
<p id="section-3.2-4">In the first MP_JOIN on the SYN packet, illustrated in 
        <a class="xref" href="#tcpm_join">Figure 5</a>, the initiator sends a token, random
        number, and Address ID.<a class="pilcrow" href="#section-3.2-4">¶</a></p>
<span id="name-join-connection-mp_join-opt"></span><div id="tcpm_join">
<figure id="figure-5">
          <div class="artwork art-text alignLeft" id="section-3.2-5.1">
<pre>                       1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +---------------+---------------+-------+-----+-+---------------+
  |     Kind      |  Length = 12  |Subtype|(rsv)|B|   Address ID  |
  +---------------+---------------+-------+-----+-+---------------+
  |                   Receiver's Token (32 bits)                  |
  +---------------------------------------------------------------+
  |                Sender's Random Number (32 bits)               |
  +---------------------------------------------------------------+</pre>
</div>
<figcaption><a class="selfRef" href="#figure-5">Figure 5</a>:
<a class="selfRef" href="#name-join-connection-mp_join-opt">Join Connection (MP_JOIN) Option (for Initial SYN)</a>
          </figcaption></figure>
</div>
<p id="section-3.2-6">The token is used to identify the MPTCP connection and is a
        cryptographic hash of the receiver's key, as exchanged 
        in the initial MP_CAPABLE handshake (<a class="xref" href="#sec_init">Section 3.1</a>).  
        In this specification, the tokens presented in this 
        option are generated by the SHA-256 algorithm <span>[<a class="xref" href="#RFC6234">RFC6234</a>]</span>, truncated to the most significant 32 bits.  The token
        included in the MP_JOIN option is the token that the receiver
        of the packet uses to identify this connection; i.e., Host A 
        will send Token-B (which is generated from Key-B). Note that the
        hash generation algorithm can be overridden by the choice of 
        cryptographic handshake algorithm, as defined in <a class="xref" href="#sec_init">Section 3.1</a>.<a class="pilcrow" href="#section-3.2-6">¶</a></p>
<p id="section-3.2-7">The MP_JOIN SYN sends not only the token (which is static for a 
        connection) but also random numbers (nonces) that are used to prevent 
        replay attacks on the authentication method. Recommendations for the 
        generation of random numbers for this purpose are given in <span>[<a class="xref" href="#RFC4086">RFC4086</a>]</span>.<a class="pilcrow" href="#section-3.2-7">¶</a></p>
<p id="section-3.2-8">The MP_JOIN option includes an "Address ID".  This is an identifier
        generated by the sender of the option, used to identify the source address
        of this packet, even if the IP header has been changed in transit by a middlebox.
        The numeric value of this field is generated by the sender and must map uniquely
        to a source IP address for the sending host.
        The Address ID allows address removal (<a class="xref" href="#sec_remove_addr">Section 3.4.2</a>) 
        without needing to know what the source address at the 
        receiver is, thus allowing address removal through NATs.
        The Address ID also allows correlation between new subflow setup attempts          
        and address signaling (<a class="xref" href="#sec_add_address">Section 3.4.1</a>),          
        to prevent setting up duplicate subflows on the same path, if an MP_JOIN
        and ADD_ADDR are sent at the same time.<a class="pilcrow" href="#section-3.2-8">¶</a></p>
<p id="section-3.2-9">The Address IDs of the subflow used in the initial SYN
        exchange of the first subflow in the connection are implicit
        and have the value zero. A host <span class="bcp14">MUST</span> store the mappings between
        Address IDs and addresses both for itself and the remote host.
        An implementation will also need to know which local and remote
        Address IDs are associated with which established subflows, for 
        when addresses are removed from a local or remote host.<a class="pilcrow" href="#section-3.2-9">¶</a></p>
<p id="section-3.2-10">The MP_JOIN option on packets with the SYN flag set also includes
        4 bits of flags, 3 of which are currently reserved and
        <span class="bcp14">MUST</span> be set to 0 by the sender. The final bit, labeled
        "B", indicates whether the sender of this option (1) wishes this
        subflow to be used as a backup path (B=1) in the event of failure of
        other paths or (2) wants the subflow to be used as part of the
        connection immediately. By setting B=1, the sender of the option is
        requesting that the other host only send data on this subflow if there
 are no available subflows where B=0. Subflow policy is discussed in more
 detail in <a class="xref" href="#sec_policy">Section 3.3.8</a>.<a class="pilcrow" href="#section-3.2-10">¶</a></p>
<p id="section-3.2-11">When receiving a SYN with an MP_JOIN option that contains
        a valid token for an existing MPTCP connection, the recipient
        <span class="bcp14">SHOULD</span> respond with a SYN/ACK also containing an MP_JOIN
        option containing a random number and a truncated (leftmost 64 bits) HMAC. This 
        version of the option is shown in <a class="xref" href="#tcpm_join2">Figure 6</a>. If the token is unknown or the host wants to refuse subflow
        establishment (for example, due to a limit on the number of
        subflows it will permit), the receiver will send back a reset 
        (RST) signal, analogous to an unknown port in TCP, containing an
        MP_TCPRST option (<a class="xref" href="#sec_reset">Section 3.6</a>) with an "MPTCP
        specific error" reason code. Although calculating an HMAC
        requires cryptographic operations, it is believed that the 
        32-bit token in the MP_JOIN SYN gives sufficient protection against blind state 
        exhaustion attacks; therefore, there is no need to provide
        mechanisms to allow a responder to operate statelessly at the 
        MP_JOIN stage.<a class="pilcrow" href="#section-3.2-11">¶</a></p>
<span id="name-join-connection-mp_join-opti"></span><div id="tcpm_join2">
<figure id="figure-6">
          <div class="artwork art-text alignLeft" id="section-3.2-12.1">
<pre>                       1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +---------------+---------------+-------+-----+-+---------------+
  |     Kind      |  Length = 16  |Subtype|(rsv)|B|   Address ID  |
  +---------------+---------------+-------+-----+-+---------------+
  |                                                               |
  |                Sender's Truncated HMAC (64 bits)              |
  |                                                               |
  +---------------------------------------------------------------+
  |                Sender's Random Number (32 bits)               |
  +---------------------------------------------------------------+</pre>
</div>
<figcaption><a class="selfRef" href="#figure-6">Figure 6</a>:
<a class="selfRef" href="#name-join-connection-mp_join-opti">Join Connection (MP_JOIN) Option (for Responding SYN/ACK)</a>
          </figcaption></figure>
</div>
<p id="section-3.2-13">An HMAC is sent by both hosts -- by the initiator (Host A)
        in the third packet (the ACK) and by the responder (Host B) in
        the second packet (the SYN/ACK). Doing the HMAC exchange at this
        stage allows both hosts to have first exchanged random data (in the 
        first two SYN packets) that is used as the "message". This
        specification defines that HMAC as defined in <span>[<a class="xref" href="#RFC2104">RFC2104</a>]</span>
        is used, along with the SHA-256 hash algorithm <span>[<a class="xref" href="#RFC6234">RFC6234</a>]</span>,
        and that the output is truncated to the leftmost 160 bits (20 octets).
        Due to option space limitations, the HMAC included in 
        the SYN/ACK is truncated to the leftmost 64 bits, but this is 
        acceptable, since random numbers are used; thus, an attacker 
        only has one chance to correctly guess the HMAC that matches the random
        number previously sent by the peer (if the HMAC is
        incorrect, the TCP connection is closed, so a new MP_JOIN negotiation 
        with a new random number is required).<a class="pilcrow" href="#section-3.2-13">¶</a></p>
<p id="section-3.2-14">The initiator's authentication information is sent in its 
        first ACK (the third packet of the handshake), as shown in
        <a class="xref" href="#tcpm_join3">Figure 7</a>. This data needs to be sent reliably,
        since it is the only time this HMAC is sent;
        therefore, receipt of this packet <span class="bcp14">MUST</span> trigger a regular TCP ACK 
        in response, and the packet <span class="bcp14">MUST</span> be retransmitted if this
        ACK is not received. In other words, sending the ACK/MP_JOIN 
        packet places the subflow in the PRE_ESTABLISHED state, and it 
        moves to the ESTABLISHED state only on receipt of an ACK from 
        the receiver. It is not permissible to send data while in the 
        PRE_ESTABLISHED state. The reserved bits in this option <span class="bcp14">MUST</span> be set 
        to 0 by the sender.<a class="pilcrow" href="#section-3.2-14">¶</a></p>
<span id="name-join-connection-mp_join-optio"></span><div id="tcpm_join3">
<figure id="figure-7">
          <div class="artwork art-text alignLeft" id="section-3.2-15.1">
<pre>                       1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +---------------+---------------+-------+-----------------------+
  |     Kind      |  Length = 24  |Subtype|      (reserved)       |
  +---------------+---------------+-------+-----------------------+
  |                                                               |
  |                                                               |
  |              Sender's Truncated HMAC (160 bits)               |
  |                                                               |
  |                                                               |
  +---------------------------------------------------------------+</pre>
</div>
<figcaption><a class="selfRef" href="#figure-7">Figure 7</a>:
<a class="selfRef" href="#name-join-connection-mp_join-optio">Join Connection (MP_JOIN) Option (for Initiator's First ACK)</a>
          </figcaption></figure>
</div>
<p id="section-3.2-16">The key for the HMAC algorithm, in the case of the message
        transmitted by Host A, will be Key-A followed by Key-B; and in the
        case of Host B, Key-B followed by Key-A. These are the keys that were
        exchanged in the original MP_CAPABLE handshake. The "message" for the
        HMAC algorithm in each case is the concatenations of random numbers for
        each host (denoted by R): for Host A, R-A followed by R-B; and for
        Host B, R-B followed by R-A.<a class="pilcrow" href="#section-3.2-16">¶</a></p>
<p id="section-3.2-17">These various MPTCP options fit together to enable authenticated subflow setup as illustrated in <a class="xref" href="#fig_tokens">Figure 8</a>.<a class="pilcrow" href="#section-3.2-17">¶</a></p>
<span id="name-example-use-of-mptcp-authen"></span><div id="fig_tokens">
<figure id="figure-8">
          <div class="artwork art-text alignLeft" id="section-3.2-18.1">
<pre>                Host A                                  Host B
       ------------------------                       ----------
       Address A1    Address A2                       Address B1
       ----------    ----------                       ----------
           |             |                                |
           |             |  SYN + MP_CAPABLE              |
           |---------------------------------------------&gt;|
           |&lt;---------------------------------------------|
           |          SYN/ACK + MP_CAPABLE(Key-B)         |
           |             |                                |
           |        ACK + MP_CAPABLE(Key-A, Key-B)        |
           |---------------------------------------------&gt;|
           |             |                                |
           |             |   SYN + MP_JOIN(Token-B, R-A)  |
           |             |-------------------------------&gt;|
           |             |&lt;-------------------------------|
           |             | SYN/ACK + MP_JOIN(HMAC-B, R-B) |
           |             |                                |
           |             |     ACK + MP_JOIN(HMAC-A)      |
           |             |-------------------------------&gt;|
           |             |&lt;-------------------------------|
           |             |             ACK                |

       HMAC-A = HMAC(Key=(Key-A + Key-B), Msg=(R-A + R-B))
       HMAC-B = HMAC(Key=(Key-B + Key-A), Msg=(R-B + R-A))</pre>
</div>
<figcaption><a class="selfRef" href="#figure-8">Figure 8</a>:
<a class="selfRef" href="#name-example-use-of-mptcp-authen">Example Use of MPTCP Authentication</a>
          </figcaption></figure>
</div>
<p id="section-3.2-19">If the token received at Host B is unknown or local policy 
        prohibits the acceptance of the new subflow, the recipient <span class="bcp14">MUST</span> 
        respond with a TCP RST for the subflow. If appropriate, an MP_TCPRST
        option with an "Administratively prohibited" reason code
        (<a class="xref" href="#sec_reset">Section 3.6</a>) should be included.<a class="pilcrow" href="#section-3.2-19">¶</a></p>
<p id="section-3.2-20">If the token is accepted at Host B but the HMAC returned to
        Host A does not match the one expected, Host A <span class="bcp14">MUST</span> close the 
        subflow with a TCP RST. In this and all subsequent cases of sending
        a RST as described in this section, the sender <span class="bcp14">SHOULD</span> send an MP_TCPRST option
        (<a class="xref" href="#sec_reset">Section 3.6</a>) on this RST packet with the reason
        code for an "MPTCP-specific error".<a class="pilcrow" href="#section-3.2-20">¶</a></p>
<p id="section-3.2-21">If Host B does not receive the expected HMAC or the MP_JOIN
        option is missing from the ACK, it <span class="bcp14">MUST</span> close the subflow with a 
        TCP RST.<a class="pilcrow" href="#section-3.2-21">¶</a></p>
<p id="section-3.2-22">If the HMACs are verified as correct, then both hosts have
        verified each other as being the same peers as those that existed at
        the start of the connection, and they have agreed of which 
        connection this subflow will become a part.<a class="pilcrow" href="#section-3.2-22">¶</a></p>
<p id="section-3.2-23">If the SYN/ACK as received at Host A does not have an MP_JOIN
        option, Host A <span class="bcp14">MUST</span> close the subflow with a TCP RST.<a class="pilcrow" href="#section-3.2-23">¶</a></p>
<p id="section-3.2-24">This covers all cases of the loss of an MP_JOIN. In more detail,
        if an MP_JOIN is stripped from the SYN on the path from A to
        B and Host B does not have a listener on the relevant
        port, it will respond with a RST in the normal way.  If in
        response to a SYN with an MP_JOIN option a SYN/ACK is
        received without the MP_JOIN option (because it was either
        stripped on the return path, or stripped on the
        outgoing path leading to Host B responding as if
        it was a new regular TCP session), then the subflow is
        unusable and Host A <span class="bcp14">MUST</span> close it with a RST.<a class="pilcrow" href="#section-3.2-24">¶</a></p>
<p id="section-3.2-25">Note that additional subflows can be created
        between any pair of ports (but see <a class="xref" href="#heuristics">Section 3.9</a> for
        heuristics); no explicit application-level accept calls or
        bind calls are required to open additional subflows. To
        associate a new subflow with an existing connection, the token
        supplied in the subflow's SYN exchange is used for
        demultiplexing.  This then binds the 5-tuple of the TCP
        subflow to the local token of the connection. One consequence is
        that it is possible to allow any port pairs to be used for a
        connection.<a class="pilcrow" href="#section-3.2-25">¶</a></p>
<p id="section-3.2-26">Demultiplexing subflow SYNs <span class="bcp14">MUST</span> be done using the token;
        this is unlike traditional TCP, where the destination port is
        used for demultiplexing SYN packets.  Once a subflow is set up,
        demultiplexing packets is done using the 5-tuple, as in
        traditional TCP. The 5-tuples will be mapped to the local
        connection identifier (token). Note that Host A will know its
        local token for the subflow even though it is not sent on the
        wire -- only the responder's token is sent.<a class="pilcrow" href="#section-3.2-26">¶</a></p>
</section>
</div>
<div id="sec_generalop">
<section id="section-3.3">
        <h3 id="name-mptcp-operation-and-data-tr">
<a class="section-number selfRef" href="#section-3.3">3.3. </a><a class="section-name selfRef" href="#name-mptcp-operation-and-data-tr">MPTCP Operation and Data Transfer</a>
        </h3>
<p id="section-3.3-1">This section discusses the operation of MPTCP for data transfer. At a high level, an MPTCP implementation will take one input data stream from an application and split it into one or more subflows, with sufficient control information to allow it to be reassembled and delivered reliably and in order to the recipient application. The following subsections define this behavior in detail.<a class="pilcrow" href="#section-3.3-1">¶</a></p>
<p id="section-3.3-2">The Data Sequence Mapping and the Data ACK are signaled in the DSS option (<a class="xref" href="#tcpm_dsn">Figure 9</a>). Either or both can be signaled in one DSS, depending on the flags set. The Data Sequence Mapping defines how the sequence space on the subflow maps to the connection level, and the Data ACK acknowledges receipt of data at the connection level. These functions are described in more detail in the following two subsections.<a class="pilcrow" href="#section-3.3-2">¶</a></p>
<span id="name-data-sequence-signal-dss-op"></span><div id="tcpm_dsn">
<figure id="figure-9">
          <div class="artwork art-text alignLeft" id="section-3.3-3.1">
<pre>                       1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +---------------+---------------+-------+----------------------+
  |     Kind      |    Length     |Subtype| (reserved) |F|m|M|a|A|
  +---------------+---------------+-------+----------------------+
  |           Data ACK (4 or 8 octets, depending on flags)       |
  +--------------------------------------------------------------+
  |   Data Sequence Number (4 or 8 octets, depending on flags)   |
  +--------------------------------------------------------------+
  |              Subflow Sequence Number (4 octets)              |
  +-------------------------------+------------------------------+
  |  Data-Level Length (2 octets) |      Checksum (2 octets)     |
  +-------------------------------+------------------------------+</pre>
</div>
<figcaption><a class="selfRef" href="#figure-9">Figure 9</a>:
<a class="selfRef" href="#name-data-sequence-signal-dss-op">Data Sequence Signal (DSS) Option</a>
          </figcaption></figure>
</div>
<p id="section-3.3-4">The flags, when set, define the contents of this option, as follows:<a class="pilcrow" href="#section-3.3-4">¶</a></p>
<ul>
<li id="section-3.3-5.1">A = Data ACK present<a class="pilcrow" href="#section-3.3-5.1">¶</a>
</li>
<li id="section-3.3-5.2">a = Data ACK is 8 octets (if not set, Data ACK is 4 octets)<a class="pilcrow" href="#section-3.3-5.2">¶</a>
</li>
<li id="section-3.3-5.3">M = Data Sequence Number (DSN), Subflow Sequence Number (SSN), Data-Level Length, and Checksum (if negotiated) present<a class="pilcrow" href="#section-3.3-5.3">¶</a>
</li>
<li id="section-3.3-5.4">m = Data Sequence Number is 8 octets (if not set, DSN is 4 octets)<a class="pilcrow" href="#section-3.3-5.4">¶</a>
</li>
</ul>
<p id="section-3.3-6">

        The flags "a" and "m" only have meaning if the corresponding "A" or "M" flags are set; otherwise, they will be ignored. The maximum length of this option, with all flags set, is 28 octets.<a class="pilcrow" href="#section-3.3-6">¶</a></p>
<p id="section-3.3-7">The "F" flag indicates "Data FIN". If present, this means that this
        mapping covers the final data from the sender. This is the
        connection-level equivalent of the FIN flag in single-path TCP. A connection is not closed unless there has been a Data FIN exchange, an MP_FASTCLOSE (<a class="xref" href="#sec_fastclose">Section 3.5</a>) message, or an implementation-specific connection-level send timeout. The purpose of the Data FIN and the interactions between this flag, the subflow-level FIN flag, and the Data Sequence Mapping are described in <a class="xref" href="#sec_close">Section 3.3.3</a>.
        The remaining reserved bits <span class="bcp14">MUST</span> be set to 0 by an implementation of this specification.<a class="pilcrow" href="#section-3.3-7">¶</a></p>
<p id="section-3.3-8">Note that the checksum is only present in this option if the use of
        MPTCP checksumming has been negotiated at the MP_CAPABLE handshake
        (see <a class="xref" href="#sec_init">Section 3.1</a>). The presence of the
        checksum can be inferred from the length of the option. If a checksum
        is present but its use had not been negotiated in the MP_CAPABLE
        handshake, the receiver <span class="bcp14">MUST</span> close the subflow with a
        RST, as it is not behaving as negotiated. If a checksum is not present when its use has been negotiated, the receiver <span class="bcp14">MUST</span> close the subflow with a RST, as it is considered broken. In both cases, this RST <span class="bcp14">SHOULD</span> be accompanied by an MP_TCPRST option (<a class="xref" href="#sec_reset">Section 3.6</a>) with the reason code for an "MPTCP-specific error".<a class="pilcrow" href="#section-3.3-8">¶</a></p>
<div id="sec_dsn">
<section id="section-3.3.1">
          <h4 id="name-data-sequence-mapping">
<a class="section-number selfRef" href="#section-3.3.1">3.3.1. </a><a class="section-name selfRef" href="#name-data-sequence-mapping">Data Sequence Mapping</a>
          </h4>
<p id="section-3.3.1-1">The data stream as a whole can be reassembled through the use of the Data Sequence Mapping components of the DSS option (<a class="xref" href="#tcpm_dsn">Figure 9</a>), which define the 
mapping from the subflow sequence number to the data sequence number. This is
          used by the receiver to ensure in-order delivery to the application
          layer. Meanwhile, the subflow-level sequence numbers (i.e., the
          regular sequence numbers in the TCP header) are only relevant to the subflow. It is expected (but not mandated) that SACK <span>[<a class="xref" href="#RFC2018">RFC2018</a>]</span> will be used at the subflow level to improve efficiency.<a class="pilcrow" href="#section-3.3.1-1">¶</a></p>
<p id="section-3.3.1-2">The Data Sequence Mapping specifies a mapping from the subflow
          sequence space to the data sequence space. This is expressed in terms of starting sequence numbers for the subflow and the data level, and a length of bytes for which this mapping is valid.
This explicit mapping for a range of data, rather than per‑packet signaling, was chosen to assist with compatibility with
          situations where TCP/IP segmentation or coalescing is undertaken
          separately from the stack that is generating the data flow (e.g.,
          through the use of TCP segmentation offloading on network interface
          cards, or by middleboxes such as Performance Enhancing Proxies
          (PEPs) <span>[<a class="xref" href="#RFC3135">RFC3135</a>]</span>). It
          also allows a single mapping to cover many packets; this may be useful in bulk‑transfer situations.<a class="pilcrow" href="#section-3.3.1-2">¶</a></p>
<p id="section-3.3.1-3">A mapping is fixed, in that the subflow sequence number is bound to the data sequence number after the mapping has been processed. A sender <span class="bcp14">MUST NOT</span> change this mapping
after it has been declared; however, the same data sequence number can be
          mapped to by different subflows for retransmission purposes (see
          <a class="xref" href="#sec_retransmit">Section 3.3.6</a>). This would also
          permit the same data to be sent simultaneously on multiple subflows
          for resilience or efficiency purposes, especially in the case of
          lossy links. Although the detailed specification of such operation
          is outside the scope of this document, an implementation
          <span class="bcp14">SHOULD</span> treat the first data that is received at a
          subflow for the data sequence space as the data that should be delivered to the application, and any subsequent data for that sequence space <span class="bcp14">SHOULD</span> be ignored.<a class="pilcrow" href="#section-3.3.1-3">¶</a></p>
<p id="section-3.3.1-4">The data sequence number is specified as an absolute value,
          whereas the subflow sequence numbering is relative (the SYN at the
          start of the subflow has a relative subflow sequence number of
          0). This is done to allow middleboxes to change the Initial Sequence
          Number (ISN) of a subflow, such as firewalls that undertake ISN randomization.<a class="pilcrow" href="#section-3.3.1-4">¶</a></p>
<p id="section-3.3.1-5">The Data Sequence Mapping also contains a checksum of the data
          that this mapping covers, if the use of checksums has been negotiated at
          the MP_CAPABLE exchange. Checksums are used to detect if the payload
          has been adjusted in any way by a non-MPTCP-aware middlebox. If this
          checksum fails, it will trigger a failure of the subflow, or a
          fallback to regular TCP, as documented in <a class="xref" href="#sec_fallback">Section 3.7</a>, since MPTCP can no longer
          reliably know the subflow sequence space at the receiver to build
          Data Sequence Mappings. Without checksumming enabled, corrupt data
          may be delivered to the application if a middlebox alters segment
          boundaries, alters content, or does not deliver all segments covered
          by a Data Sequence Mapping. It is therefore
          <span class="bcp14">RECOMMENDED</span> that checksumming be used, unless it is known
          that the network path contains no such devices.<a class="pilcrow" href="#section-3.3.1-5">¶</a></p>
<p id="section-3.3.1-6">The checksum algorithm used is the standard TCP checksum <span>[<a class="xref" href="#RFC0793">RFC0793</a>]</span>, operating over the data covered by this mapping, along with a pseudo‑header as shown in <a class="xref" href="#fig_pseudo">Figure 10</a>.<a class="pilcrow" href="#section-3.3.1-6">¶</a></p>
<span id="name-pseudo-header-for-dss-check"></span><div id="fig_pseudo">
<figure id="figure-10">
            <div class="artwork art-text alignLeft" id="section-3.3.1-7.1">
<pre>                       1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +--------------------------------------------------------------+
  |                                                              |
  |                Data Sequence Number (8 octets)               |
  |                                                              |
  +--------------------------------------------------------------+
  |              Subflow Sequence Number (4 octets)              |
  +-------------------------------+------------------------------+
  |  Data-Level Length (2 octets) |        Zeros (2 octets)      |
  +-------------------------------+------------------------------+</pre>
</div>
<figcaption><a class="selfRef" href="#figure-10">Figure 10</a>:
<a class="selfRef" href="#name-pseudo-header-for-dss-check">Pseudo-Header for DSS Checksum</a>
            </figcaption></figure>
</div>
<p id="section-3.3.1-8">Note that the data sequence number used in the pseudo-header is always the 64-bit value, irrespective of what length is used in the DSS option itself. The standard TCP checksum algorithm has been chosen, since it will be calculated anyway for the TCP subflow, and if calculated first over the data before adding the pseudo-headers, it only needs to be calculated once. Furthermore, since the TCP checksum is additive, the checksum for a DSN_MAP can be constructed by simply adding together the checksums for the data of each constituent TCP segment and adding the checksum for the DSS pseudo‑header.<a class="pilcrow" href="#section-3.3.1-8">¶</a></p>
<p id="section-3.3.1-9">Note that checksumming relies on the TCP subflow containing contiguous data; therefore, a TCP subflow <span class="bcp14">MUST NOT</span> use the Urgent Pointer to interrupt an existing mapping. Further note, however, that if Urgent data is received on a subflow, it <span class="bcp14">SHOULD</span> be mapped to the data sequence space and delivered to the application, analogous to Urgent data in regular TCP.<a class="pilcrow" href="#section-3.3.1-9">¶</a></p>
<p id="section-3.3.1-10">To avoid possible deadlock scenarios, subflow-level
        processing should be undertaken separately from processing at the
        connection level. Therefore, even if a mapping does not exist
        from the subflow space to the data‑level space, the data
        <span class="bcp14">SHOULD</span> still be ACKed at the subflow (if it is in-window). 
        This data cannot, however, be acknowledged at the data level
        (<a class="xref" href="#sec_dataack">Section 3.3.2</a>) because its data sequence
        numbers are unknown. Implementations <span class="bcp14">MAY</span> hold onto such
        unmapped data for a short while, in the expectation that a
        mapping will arrive shortly.  Such unmapped data cannot be
        counted as being within the connection-level receive window because this is
        relative to the data sequence numbers, so if the receiver runs
        out of memory to hold this data, it will have to be discarded.
        If a mapping for that subflow-level sequence space does not
        arrive within a receive window of data, that subflow <span class="bcp14">SHOULD</span> be
        treated as broken, closed with a RST, and any unmapped data
        silently discarded.<a class="pilcrow" href="#section-3.3.1-10">¶</a></p>
<p id="section-3.3.1-11">Data sequence numbers are always 64-bit quantities and
        <span class="bcp14">MUST</span> be maintained as such in implementations.  If a
        connection is progressing at a slow rate, so protection
        against wrapped sequence numbers is not required, 
        then an implementation <span class="bcp14">MAY</span> include just the lower 32
        bits of the data sequence number in the Data Sequence Mapping and⁠/or
        Data ACK as an optimization, and an implementation can make this choice
        independently for each packet. An implementation <span class="bcp14">MUST</span> be able to receive
        and process both 64-bit and 32-bit sequence number values, but it is not 
        required that an implementation be able to send both.<a class="pilcrow" href="#section-3.3.1-11">¶</a></p>
<p id="section-3.3.1-12">An implementation <span class="bcp14">MUST</span> send the full 64-bit data sequence number 
        if it is transmitting at a sufficiently high rate that the 32-bit value 
        could wrap within the Maximum Segment Lifetime 
        (MSL) <span>[<a class="xref" href="#RFC7323">RFC7323</a>]</span>. The lengths of the DSNs used in these
        values (which may be different) are declared with flags in the
        DSS option.  Implementations <span class="bcp14">MUST</span> accept a 32-bit DSN and implicitly
        promote it to a 64-bit quantity by incrementing the upper 32
        bits of the sequence number each time the lower 32
        bits wrap. A sanity check <span class="bcp14">MUST</span> be implemented to ensure that
        a wrap occurs at an expected time (e.g., the sequence number jumps
        from a very high number to a very low number) and is not triggered 
        by out‑of-order packets.<a class="pilcrow" href="#section-3.3.1-12">¶</a></p>
<p id="section-3.3.1-13">As with the standard TCP sequence number, the data sequence
        number should not start at zero, but at a random value to make
        blind session hijacking harder. This specification requires
        setting the IDSN of each host to the 
        least significant 64 bits of the SHA-256 hash of the host's key, as
        described in <a class="xref" href="#sec_init">Section 3.1</a>. This is also required in
        order for the receiver to know what the expected IDSN is and thus
        determine if any initial connection-level packets are missing; this 
        is particularly relevant if two subflows start transmitting simultaneously.<a class="pilcrow" href="#section-3.3.1-13">¶</a></p>
<p id="section-3.3.1-14">The mapping provided by a Data Sequence Mapping MUST apply to
   some or all of the subflow sequence space in the TCP segment that
   carries the option. It does not need to be included in
        every MPTCP packet, as long as the subflow sequence space in
        that packet is covered by a mapping known at the receiver. This
        can be used to reduce overhead in cases where the mapping is
        known in advance. One such case is when there is a single
        subflow between the hosts, and another is when segments of
        data are scheduled in larger-than-packet-sized chunks.<a class="pilcrow" href="#section-3.3.1-14">¶</a></p>
<p id="section-3.3.1-15">An "infinite" mapping can be used to fall back to regular TCP by
        mapping the subflow-level data to the connection-level data
        for the remainder of the connection (see
        <a class="xref" href="#sec_fallback">Section 3.7</a>). This is achieved by setting
        the Data-Level Length field of the DSS option to the reserved value of 0. The
        checksum, in such a case, will also be set to 0.<a class="pilcrow" href="#section-3.3.1-15">¶</a></p>
</section>
</div>
<div id="sec_dataack">
<section id="section-3.3.2">
          <h4 id="name-data-acknowledgments">
<a class="section-number selfRef" href="#section-3.3.2">3.3.2. </a><a class="section-name selfRef" href="#name-data-acknowledgments">Data Acknowledgments</a>
          </h4>
<p id="section-3.3.2-1">To provide full end-to-end resilience, MPTCP provides a
        connection-level acknowledgment, to act as a cumulative ACK for
        the connection as a whole. This is done via the "Data ACK" field of 
        the DSS option (<a class="xref" href="#tcpm_dsn">Figure 9</a>). The Data ACK
        is analogous to the behavior
        of the standard TCP cumulative ACK -- indicating
        how much data has been successfully received (with no
        holes). This can be compared to the subflow-level ACK, which
        acts in a fashion analogous to TCP SACK, given that there may still be
        holes in the data stream at the connection level.
        The Data ACK specifies the next data sequence number 
        it expects to receive.<a class="pilcrow" href="#section-3.3.2-1">¶</a></p>
<p id="section-3.3.2-2">The Data ACK, as for the DSN, can be sent as the full 64-bit
        value or as the lower 32 bits.  If data is received with a 64-bit DSN, 
        it <span class="bcp14">MUST</span> be acknowledged with a 64-bit Data ACK.  If the DSN received
        is 32 bits, an implementation can choose whether to send a 32-bit or
        64-bit Data ACK, and an implementation <span class="bcp14">MUST</span> accept either in this situation.<a class="pilcrow" href="#section-3.3.2-2">¶</a></p>
<p id="section-3.3.2-3">The Data ACK proves that the data, and all required MPTCP
        signaling, have been received and accepted by the remote end.
        One key use of the Data ACK signal is that it is used to indicate
        the left edge of the advertised receive window. As explained in
        <a class="xref" href="#sec_rwin">Section 3.3.4</a>, the receive window is shared by all
        subflows and is relative to the Data ACK. Because of this, an
        implementation <span class="bcp14">MUST NOT</span> use the RCV.WND field of a TCP segment
        at the connection level if it does not also carry a DSS option with
        a Data ACK field. Furthermore,
        separating the connection-level acknowledgments from the
        subflow level allows processing to be done separately, and
        a receiver has the freedom to drop segments after acknowledgment 
        at the subflow level -- for example, due to memory constraints
        when many segments arrive out of order.<a class="pilcrow" href="#section-3.3.2-3">¶</a></p>
<p id="section-3.3.2-4">An MPTCP sender <span class="bcp14">MUST NOT</span> free data from the send buffer until 
        it has been acknowledged by both a Data ACK received on any subflow 
        and at the subflow level by all subflows on which the data was sent.  
        The former condition ensures liveness of the
        connection, and the latter condition ensures liveness and
        self-consistence of a subflow when data needs to be
        retransmitted.
        Note, however, that if some data needs to be retransmitted multiple
        times over a subflow, there is a risk of blocking the send
        window. In this case, the MPTCP sender can decide to terminate the
        subflow that is behaving badly by sending a RST, using an appropriate
        MP_TCPRST (<a class="xref" href="#sec_reset">Section 3.6</a>) error code.<a class="pilcrow" href="#section-3.3.2-4">¶</a></p>
<p id="section-3.3.2-5">The Data ACK <span class="bcp14">MAY</span> be included in all segments; however, optimizations 
        <span class="bcp14">SHOULD</span> be considered in more advanced implementations, where the
        Data ACK is present in segments 
        only when the Data ACK value advances, and this behavior <span class="bcp14">MUST</span>
        be treated as valid. This behavior ensures that the send buffer 
        is freed, while reducing overhead when the data transfer is 
        unidirectional.<a class="pilcrow" href="#section-3.3.2-5">¶</a></p>
</section>
</div>
<div id="sec_close">
<section id="section-3.3.3">
          <h4 id="name-closing-a-connection">
<a class="section-number selfRef" href="#section-3.3.3">3.3.3. </a><a class="section-name selfRef" href="#name-closing-a-connection">Closing a Connection</a>
          </h4>
<p id="section-3.3.3-1">In regular TCP, a FIN announces to the receiver that the sender has no more data to send. 
In order to allow subflows to operate independently and to keep the appearance of TCP over the wire, 
a FIN in MPTCP only affects the subflow on which it is sent. This 
allows nodes to exercise considerable freedom over which paths are in use at any one time. 
The semantics of a FIN remain as for regular TCP; i.e., it is not until both sides have ACKed 
each other's FINs that the subflow is fully closed.<a class="pilcrow" href="#section-3.3.3-1">¶</a></p>
<p id="section-3.3.3-2">When an application calls close() on a socket, this indicates that it has no more 
data to send; for regular TCP, this would result in a FIN on the connection. For MPTCP, an 
equivalent mechanism is needed; this is referred to as the DATA_FIN.<a class="pilcrow" href="#section-3.3.3-2">¶</a></p>
<p id="section-3.3.3-3">A DATA_FIN is an indication that the sender has no more data to send, and 
        as such it can be used to verify that all data has been successfully received. A DATA_FIN, 
        as with the FIN on a regular TCP connection, is a unidirectional signal.<a class="pilcrow" href="#section-3.3.3-3">¶</a></p>
<p id="section-3.3.3-4">The DATA_FIN is signaled by setting the "F" flag in the DSS
          option (<a class="xref" href="#tcpm_dsn">Figure 9</a>)
          to 1. A DATA_FIN occupies 1 octet (the final octet) of the
          connection-level sequence space. Note that the
 DATA_FIN is included in the Data-Level Length but not at the subflow
 level: for example, a segment with a DSN value of 80 and a
 Data-Level Length of 11, with DATA_FIN set, would map 10 octets from
 the subflow into data sequence space 80-89, and the DATA_FIN would
 be DSN 90; therefore, this segment, including DATA_FIN, would be
 acknowledged with a DATA_ACK of 91.<a class="pilcrow" href="#section-3.3.3-4">¶</a></p>
<p id="section-3.3.3-5">Note that when the DATA_FIN is not attached to a TCP segment containing data, the DSS <span class="bcp14">MUST</span> have a subflow sequence number of 0, a Data-Level Length of 1, and the data sequence number that corresponds with the DATA_FIN itself. The checksum in this case will only cover the pseudo-header.<a class="pilcrow" href="#section-3.3.3-5">¶</a></p>
<p id="section-3.3.3-6">A DATA_FIN has the same semantics and behavior as a regular TCP FIN, but at the connection level. Notably, it is only DATA_ACKed once all data has been successfully received at the connection level. Note, therefore, that a DATA_FIN is decoupled from a subflow FIN. It is only permissible to combine these signals on one subflow if there is no data outstanding on other subflows. Otherwise, it may be necessary to retransmit data on different subflows. Essentially, a host <span class="bcp14">MUST NOT</span> close all functioning subflows unless it is safe to do so, i.e., until all outstanding data has been DATA_ACKed or until the segment with the DATA_FIN flag set is the only outstanding segment.<a class="pilcrow" href="#section-3.3.3-6">¶</a></p>
<p id="section-3.3.3-7">Once a DATA_FIN has been acknowledged, all remaining subflows
          <span class="bcp14">MUST</span> be closed with standard FIN exchanges. Both
          hosts <span class="bcp14">SHOULD</span> send FINs on all subflows, as a courtesy,
          to allow middleboxes to clean up state even if an individual subflow
          has failed. Reducing the timeouts (MSL) on subflows at end hosts after receiving a
          DATA_FIN is also encouraged. In particular, any subflows where there is still
          outstanding data queued (which has been retransmitted on other
          subflows in order to get the DATA_FIN acknowledged)
          <span class="bcp14">MAY</span> be closed with a RST with an MP_TCPRST (<a class="xref" href="#sec_reset">Section 3.6</a>) error code for "too much outstanding data".<a class="pilcrow" href="#section-3.3.3-7">¶</a></p>
<p id="section-3.3.3-8">A connection is considered closed once both hosts' DATA_FINs have been acknowledged by DATA_ACKs.<a class="pilcrow" href="#section-3.3.3-8">¶</a></p>
<p id="section-3.3.3-9">As specified above, a standard TCP FIN on an individual subflow
          only shuts down the subflow on which it was sent. If all subflows
          have been closed with a FIN exchange but no DATA_FIN has been
          received and acknowledged, the MPTCP connection is treated as closed
          only after a timeout. This implies that an implementation will have
          TIME_WAIT states at both the subflow level and the connection level (see <a class="xref" href="#app_fsm">Appendix D</a>). This permits "break-before-make" scenarios where connectivity is lost on all subflows before a new one can be re‑established.<a class="pilcrow" href="#section-3.3.3-9">¶</a></p>
</section>
</div>
<div id="sec_rwin">
<section id="section-3.3.4">
          <h4 id="name-receiver-considerations">
<a class="section-number selfRef" href="#section-3.3.4">3.3.4. </a><a class="section-name selfRef" href="#name-receiver-considerations">Receiver Considerations</a>
          </h4>
<p id="section-3.3.4-1">Regular TCP advertises a receive window in each packet, telling the sender how much data the receiver
is willing to accept past the cumulative ACK. The receive window is used to implement flow control, throttling
down fast senders when receivers cannot keep up.<a class="pilcrow" href="#section-3.3.4-1">¶</a></p>
<p id="section-3.3.4-2">MPTCP also uses a unique receive window, shared between the subflows. The idea is to allow any
subflow to send data as long as the receiver is willing to accept it. The
alternative -- maintaining per-subflow
receive windows -- could end up stalling some subflows while others would not use up their window.<a class="pilcrow" href="#section-3.3.4-2">¶</a></p>
<p id="section-3.3.4-3">The receive window is relative to the DATA_ACK. As in TCP, a receiver <span class="bcp14">MUST NOT</span> shrink the right edge of the receive window (i.e., DATA_ACK + receive window). The receiver will
use the data sequence number to tell if a packet should be accepted at the connection level.<a class="pilcrow" href="#section-3.3.4-3">¶</a></p>
<p id="section-3.3.4-4">When deciding to accept packets at the subflow level, regular TCP checks
the sequence number in the packet against the allowed receive window. 
With MPTCP, such a check is done using only the connection-level window. A sanity 
check <span class="bcp14">SHOULD</span> be performed at the subflow level to ensure that the subflow and mapped sequence
numbers meet the following test: SSN - SUBFLOW_ACK &lt;= DSN - DATA_ACK, where SSN is the subflow sequence number of the received packet and SUBFLOW_ACK is the RCV.NXT (next expected sequence number) of the subflow (with the equivalent connection-level definitions for DSN and DATA_ACK).<a class="pilcrow" href="#section-3.3.4-4">¶</a></p>
<p id="section-3.3.4-5">In regular TCP, once a segment is deemed in-window, it is put in either 
the in-order receive queue or the out-of-order queue. 
In Multipath TCP, the same thing happens, but at the connection level: a segment
is placed in the connection-level in-order or out-of-order queue if
it is in-window at both the connection level and the subflow level. 
The stack still has to remember, for each subflow, which segments were
received successfully so that it can ACK them at the subflow level appropriately.
Typically, this will be implemented by keeping per-subflow out-of-order
queues (containing only message headers -- not the payloads) and remembering 
the value of the cumulative ACK.<a class="pilcrow" href="#section-3.3.4-5">¶</a></p>
<p id="section-3.3.4-6">It is important for implementers to understand how large
          a receive buffer is appropriate. The lower bound for full
          network utilization is the maximum bandwidth-delay product
          of any one of the paths.  However, this might be insufficient
          when a packet is lost on a slower subflow and needs to be
          retransmitted (see <a class="xref" href="#sec_retransmit">Section 3.3.6</a>). A tight
          upper bound would be the maximum round-trip time (RTT) of any path multiplied
          by the total bandwidth available across all paths. This
          permits all subflows to continue at full speed while a
          packet is fast-retransmitted on the maximum RTT path. Even
          this might be insufficient to maintain full performance in
          the event of a retransmit timeout on the maximum RTT path.
          Determining the relationship between
          retransmission strategies and receive buffer sizing is left for future study.<a class="pilcrow" href="#section-3.3.4-6">¶</a></p>
</section>
</div>
<div id="sec_sender">
<section id="section-3.3.5">
          <h4 id="name-sender-considerations">
<a class="section-number selfRef" href="#section-3.3.5">3.3.5. </a><a class="section-name selfRef" href="#name-sender-considerations">Sender Considerations</a>
          </h4>
<p id="section-3.3.5-1">The sender remembers receive window advertisements from the
          receiver. It should only update its local receive window values when
          the largest sequence number allowed (i.e., DATA_ACK + receive
          window) increases on the receipt of a DATA_ACK. This is important
          for allowing the use of paths with different RTTs and thus different feedback loops.<a class="pilcrow" href="#section-3.3.5-1">¶</a></p>
<p id="section-3.3.5-2">MPTCP uses a single receive window across all subflows, and if
          the receive window was guaranteed to be unchanged end to end, a host could always read the most recent receive window value. However, some classes of middleboxes may alter the TCP-level receive window. Typically, these will 
shrink the offered window, although for short periods of time it may be possible for the window to be larger (however, 
note that this would not continue for long periods, since ultimately the middlebox must keep up with 
delivering data to the receiver). Therefore, if receive window sizes differ on multiple subflows, 
when sending data MPTCP <span class="bcp14">SHOULD</span> take the largest of the most recent window sizes as the one to use in calculations.
This rule is implicit in the requirement not to reduce the right edge of the window.<a class="pilcrow" href="#section-3.3.5-2">¶</a></p>
<p id="section-3.3.5-3">The sender <span class="bcp14">MUST</span> also remember the receive windows advertised by each subflow.
The allowed window for subflow i is (ack_i, ack_i + rcv_wnd_i), where ack_i is the
subflow-level cumulative ACK of subflow i. This ensures that data will not be sent to a middlebox
unless there is enough buffering for the data.<a class="pilcrow" href="#section-3.3.5-3">¶</a></p>
<p id="section-3.3.5-4">Putting the two rules together, we get the following: a sender is allowed to send 
data segments with data-level sequence numbers between (DATA_ACK, DATA_ACK + receive_window).
Each of these segments will be mapped onto subflows, as long as subflow sequence numbers
are in the allowed windows for those subflows. Note that subflow sequence numbers do not
generally affect flow control if the same receive window is advertised across all subflows. 
They will perform flow control for those subflows with a smaller advertised receive window.<a class="pilcrow" href="#section-3.3.5-4">¶</a></p>
<p id="section-3.3.5-5">The send buffer <span class="bcp14">MUST</span>, at a minimum, be as big as the receive buffer, to enable the sender to reach maximum throughput.<a class="pilcrow" href="#section-3.3.5-5">¶</a></p>
</section>
</div>
<div id="sec_retransmit">
<section id="section-3.3.6">
          <h4 id="name-reliability-and-retransmiss">
<a class="section-number selfRef" href="#section-3.3.6">3.3.6. </a><a class="section-name selfRef" href="#name-reliability-and-retransmiss">Reliability and Retransmissions</a>
          </h4>
<p id="section-3.3.6-1">The Data Sequence Mapping allows senders to resend data with the
          same data sequence number on a different subflow. When doing this, a
          host <span class="bcp14">MUST</span> still retransmit the original data on the
          original subflow, in order to preserve the subflow's integrity
          (middleboxes could replay old data and⁠/or could reject holes in
          subflows), and a receiver will ignore these retransmissions. While
          this is clearly suboptimal, for compatibility reasons this is
          sensible behavior. Optimizations could be negotiated in future
          versions of this protocol. Note also that this property would also permit a sender to always send the same data, with the same data sequence number, on multiple subflows, if desired for reliability reasons.<a class="pilcrow" href="#section-3.3.6-1">¶</a></p>
<p id="section-3.3.6-2">This protocol specification does not mandate any mechanisms for handling retransmissions, and much will be dependent upon local policy 
(as discussed in <a class="xref" href="#sec_policy">Section 3.3.8</a>). One can imagine aggressive connection-level retransmission policies where every packet lost at the subflow level is retransmitted on
a different subflow (hence wasting bandwidth but possibly reducing application-to-application delays) or conservative retransmission policies where connection-level retransmissions
are only used after a few subflow-level retransmission timeouts occur.<a class="pilcrow" href="#section-3.3.6-2">¶</a></p>
<p id="section-3.3.6-3">It is envisaged that a standard connection-level retransmission mechanism 
would be implemented around a connection-level data queue: all segments that haven't 
been DATA_ACKed are stored. A timer is set when 
the head of the connection level is ACKed at the subflow level but is not DATA_ACKed at the data level. This timer will guard against retransmission failures
by middleboxes that proactively ACK data.<a class="pilcrow" href="#section-3.3.6-3">¶</a></p>
<p id="section-3.3.6-4">The sender <span class="bcp14">MUST</span> keep data in its send buffer as
          long as the data has not been acknowledged both (1) at the
          connection level and (2) on all subflows on which it
has been sent. In this way, the sender can always retransmit the data if needed, on the same subflow or on a different one. A special case is when a subflow fails: the sender 
will typically resend the data on other working subflows after a timeout and will keep trying to retransmit the data 
on the failed subflow too. The sender will declare the subflow failed after a predefined upper bound on retransmissions is reached (which <span class="bcp14">MAY</span> be lower than the usual TCP limits of the MSL) or on the receipt of an ICMP error, and only then delete the outstanding data segments.<a class="pilcrow" href="#section-3.3.6-4">¶</a></p>
<p id="section-3.3.6-5">If multiple retransmissions that indicate that a
          subflow is performing badly are triggered, this <span class="bcp14">MAY</span> lead to a host resetting the subflow with a RST. However, additional research is required to understand the heuristics of how and when to reset underperforming subflows. For example, a highly asymmetric path may be misdiagnosed as underperforming. A RST for this purpose <span class="bcp14">SHOULD</span> be accompanied by an "Unacceptable performance" MP_TCPRST option (<a class="xref" href="#sec_reset">Section 3.6</a>).<a class="pilcrow" href="#section-3.3.6-5">¶</a></p>
</section>
</div>
<div id="sec_cc">
<section id="section-3.3.7">
          <h4 id="name-congestion-control-consider">
<a class="section-number selfRef" href="#section-3.3.7">3.3.7. </a><a class="section-name selfRef" href="#name-congestion-control-consider">Congestion Control Considerations</a>
          </h4>
<p id="section-3.3.7-1">Different subflows in an MPTCP connection have different congestion windows.   
To achieve fairness at bottlenecks and resource pooling, it is necessary to couple the 
congestion windows in use on each subflow, in order to push most traffic to uncongested links. 
One algorithm for achieving this is presented in <span>[<a class="xref" href="#RFC6356">RFC6356</a>]</span>; 
the algorithm does not achieve perfect resource pooling but is "safe" in that it is readily 
deployable in the current Internet. By this we mean that it does not take up more capacity
on any one path than if it was a single path flow using only that route, so this ensures
fair coexistence with single-path TCP at shared bottlenecks.<a class="pilcrow" href="#section-3.3.7-1">¶</a></p>
<p id="section-3.3.7-2">It is foreseeable that different congestion controllers will be
          implemented for MPTCP, each aiming to achieve different properties
          in the resource pooling / fairness / stability design space, as well as those for achieving different properties in quality of service, reliability, and resilience.<a class="pilcrow" href="#section-3.3.7-2">¶</a></p>
<p id="section-3.3.7-3">Regardless of the algorithm used,
the design of MPTCP aims to provide the congestion control
implementations with sufficient information 
to make the right decisions; this information includes, for each subflow, which packets were lost and when.<a class="pilcrow" href="#section-3.3.7-3">¶</a></p>
</section>
</div>
<div id="sec_policy">
<section id="section-3.3.8">
          <h4 id="name-subflow-policy">
<a class="section-number selfRef" href="#section-3.3.8">3.3.8. </a><a class="section-name selfRef" href="#name-subflow-policy">Subflow Policy</a>
          </h4>
<p id="section-3.3.8-1">Within a local MPTCP implementation, a host may use any local policy it wishes to decide how to share the traffic to be sent over the available paths.<a class="pilcrow" href="#section-3.3.8-1">¶</a></p>
<p id="section-3.3.8-2">In the typical use case, where the goal is to maximize throughput, all available paths will be used simultaneously for data transfer, using coupled congestion control as described in <span>[<a class="xref" href="#RFC6356">RFC6356</a>]</span>. It is expected, however, that other use cases will appear.<a class="pilcrow" href="#section-3.3.8-2">¶</a></p>
<p id="section-3.3.8-3">For instance, one possibility is an "all-or-nothing" approach, i.e., have a second path ready for use in the event of 
failure of the first path, but alternatives could include entirely saturating one path before using an additional 
path (the "overflow" case). Such choices would be most likely based on the monetary cost of links but may also be 
based on properties such as the delay or jitter of links, where stability (of delay or bandwidth) is more important than throughput. Application
requirements such as these are discussed in detail in <span>[<a class="xref" href="#RFC6897">RFC6897</a>]</span>.<a class="pilcrow" href="#section-3.3.8-3">¶</a></p>
<p id="section-3.3.8-4">The ability to make effective choices at the sender requires full knowledge of the path "cost", which 
is unlikely to be the case. It would be desirable for a receiver to be able to signal their own preferences for paths,
since they will often be the multihomed party and may have to pay for metered incoming bandwidth.<a class="pilcrow" href="#section-3.3.8-4">¶</a></p>
<p id="section-3.3.8-5">To enable this behavior, the MP_JOIN option (see <a class="xref" href="#sec_join">Section 3.2</a>) contains the "B" bit,
          which allows a host to indicate to its peer that this path should be
          treated as a backup path to use only in the event of failure of
          other working subflows (i.e., a subflow where the receiver has
          indicated that B=1 <span class="bcp14">SHOULD NOT</span> be used to send data unless there are no usable subflows where B=0).<a class="pilcrow" href="#section-3.3.8-5">¶</a></p>
<p id="section-3.3.8-6">In the event that the available set of paths changes, a host may
          wish to signal a change in priority of subflows to the peer (e.g., a
          subflow that was previously set as a backup should now take priority
          over all remaining subflows). Therefore, the MP_PRIO option, shown
          in <a class="xref" href="#tcpm_prio">Figure 11</a>, can be used to
          change the "B" flag of the subflow on which it is sent.<a class="pilcrow" href="#section-3.3.8-6">¶</a></p>
<span id="name-change-subflow-priority-mp_"></span><div id="tcpm_prio">
<figure id="figure-11">
            <div class="artwork art-text alignLeft" id="section-3.3.8-7.1">
<pre>                       1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +---------------+---------------+-------+-----+-+
  |     Kind      |     Length    |Subtype|(rsv)|B|
  +---------------+---------------+-------+-----+-+</pre>
</div>
<figcaption><a class="selfRef" href="#figure-11">Figure 11</a>:
<a class="selfRef" href="#name-change-subflow-priority-mp_">Change Subflow Priority (MP_PRIO) Option</a>
            </figcaption></figure>
</div>
<p id="section-3.3.8-8">Another use of the MP_PRIO option is to set the "B" flag on a
          subflow to cleanly "retire" its use before closing it and removing it
          with REMOVE_ADDR (<a class="xref" href="#sec_remove_addr">Section 3.4.2</a>) -- for example, to support make-before-break session continuity, where new subflows are added before the previously used subflows are closed.<a class="pilcrow" href="#section-3.3.8-8">¶</a></p>
<p id="section-3.3.8-9">It should be noted that the backup flag is a request from a data receiver to a data sender only, and the data sender <span class="bcp14">SHOULD</span> adhere to these requests. A host cannot assume that the data sender will do so, however, since local policies -- or technical difficulties -- may override MP_PRIO requests. Note also that this signal applies to a single direction, and so the sender of this option could choose to continue using the subflow to send data even if it has signaled B=1 to the other host.<a class="pilcrow" href="#section-3.3.8-9">¶</a></p>
</section>
</div>
</section>
</div>
<div id="sec_pm">
<section id="section-3.4">
        <h3 id="name-address-knowledge-exchange-">
<a class="section-number selfRef" href="#section-3.4">3.4. </a><a class="section-name selfRef" href="#name-address-knowledge-exchange-">Address Knowledge Exchange (Path Management)</a>
        </h3>
<p id="section-3.4-1">We use the term "path management" to refer to the exchange of information about additional paths between hosts, which in this design is managed by multiple addresses at hosts. For more details regarding the architectural thinking behind this design, see the MPTCP architecture document <span>[<a class="xref" href="#RFC6182">RFC6182</a>]</span>.<a class="pilcrow" href="#section-3.4-1">¶</a></p>
<p id="section-3.4-2">This design makes use of two methods of sharing such
        information, and both can be used on a connection. 
        The first is the direct
        setup of new subflows (described in
        <a class="xref" href="#sec_join">Section 3.2</a>), where the initiator has an
        additional address. The second method (described in the
        following subsections) signals addresses explicitly to the
        other host to allow it to initiate new subflows. The
        two mechanisms are complementary: the first is implicit and
        simple, while the second (explicit) is more complex but is more
        robust. Together, these mechanisms allow addresses to change in
        flight (and thus support operation through NATs, since the
        source address need not be known); they also allow the
        signaling of previously unknown addresses and of addresses
        belonging to other address families (e.g., both IPv4 and IPv6).<a class="pilcrow" href="#section-3.4-2">¶</a></p>
<p id="section-3.4-3">Here is an example of typical operation of the protocol:<a class="pilcrow" href="#section-3.4-3">¶</a></p>
<ul>
<li id="section-3.4-4.1">An MPTCP connection is initially set up between address⁠/port A1 of Host A 
              and address⁠/port B1 of Host B.  If Host A is multihomed and 
              multiaddressed, it can start an additional subflow from
              its address A2 to B1, by sending a SYN with an MP_JOIN
              option from A2 to B1, using B's previously declared
              token for this connection.  Alternatively, if B is
              multihomed, it can try to set up a new subflow from B2 to
              A1, using A's previously declared token.  In either
              case, the SYN will be sent to the port already in use
              for the original subflow on the receiving host.<a class="pilcrow" href="#section-3.4-4.1">¶</a>
</li>
<li id="section-3.4-4.2">Simultaneously (or after a timeout), an ADD_ADDR option 
(<a class="xref" href="#sec_add_address">Section 3.4.1</a>) is sent on an existing subflow, informing 
the receiver of the sender's alternative address(es). The recipient can use 
this information to open a new subflow to the sender's additional address(es). 
In our example, A will send the ADD_ADDR option informing B of address⁠/port A2.
The mix of using the SYN‑based option and the ADD_ADDR option, including 
timeouts, is implementation specific and can be tailored to agree with local policy.<a class="pilcrow" href="#section-3.4-4.2">¶</a>
</li>
<li id="section-3.4-4.3">If subflow A2-B1 is successfully set up, Host B can use the Address ID in 
the MP_JOIN option to correlate this source address with the ADD_ADDR option that will also arrive on 
an existing subflow; now B knows not to open A2-B1, ignoring the ADD_ADDR.
Otherwise, if B has not received the A2-B1 MP_JOIN SYN but received the ADD_ADDR, 
it can try to initiate a new subflow from one or more of its addresses to address 
A2. This permits new sessions to be opened if one host is behind a NAT.<a class="pilcrow" href="#section-3.4-4.3">¶</a>
</li>
</ul>
<p id="section-3.4-5">
       Other ways of using the two signaling mechanisms are possible; for instance, 
signaling addresses in other address families can only be done explicitly
using the Add Address (ADD_ADDR) option.<a class="pilcrow" href="#section-3.4-5">¶</a></p>
<div id="sec_add_address">
<section id="section-3.4.1">
          <h4 id="name-address-advertisement">
<a class="section-number selfRef" href="#section-3.4.1">3.4.1. </a><a class="section-name selfRef" href="#name-address-advertisement">Address Advertisement</a>
          </h4>
<p id="section-3.4.1-1">The ADD_ADDR MPTCP option announces additional addresses (and, optionally, ports) on which a 
host can be reached (<a class="xref" href="#tcpm_address">Figure 12</a>). 
This option can be used at any time during a connection, depending on when the 
sender wishes to enable multiple paths and⁠/or when paths become available. As with all MPTCP
signals, the receiver <span class="bcp14">MUST</span> undertake standard TCP validity
          checks, e.g., per <span>[<a class="xref" href="#RFC5961">RFC5961</a>]</span>, before
          acting upon it.<a class="pilcrow" href="#section-3.4.1-1">¶</a></p>
<span id="name-add-address-add_addr-option"></span><div id="tcpm_address">
<figure id="figure-12">
            <div class="artwork art-text alignLeft" id="section-3.4.1-2.1">
<pre>                       1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +---------------+---------------+-------+-------+---------------+
  |     Kind      |     Length    |Subtype|(rsv)|E|  Address ID   |
  +---------------+---------------+-------+-------+---------------+
  |           Address (IPv4: 4 octets / IPv6: 16 octets)          |
  +-------------------------------+-------------------------------+
  |   Port (2 octets, optional)   |                               |
  +-------------------------------+                               |
  |                Truncated HMAC (8 octets, if E=0)              |
  |                               +-------------------------------+
  |                               |
  +-------------------------------+</pre>
</div>
<figcaption><a class="selfRef" href="#figure-12">Figure 12</a>:
<a class="selfRef" href="#name-add-address-add_addr-option">Add Address (ADD_ADDR) Option</a>
            </figcaption></figure>
</div>
<p id="section-3.4.1-3">Every address has an Address ID that can be used for uniquely identifying the address within a connection for address removal. The Address ID is also 
used to identify MP_JOIN options (see <a class="xref" href="#sec_join">Section 3.2</a>) relating to 
the same address, even when address translators are in use. The Address ID <span class="bcp14">MUST</span> uniquely
identify the address for the sender of the option (within the scope of the connection); the mechanism for 
allocating such IDs is implementation specific.<a class="pilcrow" href="#section-3.4.1-3">¶</a></p>
<p id="section-3.4.1-4">All Address IDs learned via either MP_JOIN or ADD_ADDR
        <span class="bcp14">SHOULD</span> be stored by the receiver in a data structure
        that gathers all the Address-ID-to-address mappings for a connection
        (identified by a token pair). In this way, there is 
        a stored mapping between the Address ID, observed source address, and token pair for 
        future processing of control information for a connection. Note that an implementation
        <span class="bcp14">MAY</span> discard incoming address advertisements at will -- for example, to avoid updating 
        mapping state or because advertised addresses are of no use to it (for 
        example, IPv6 addresses when it has IPv4 only). Therefore, a host <span class="bcp14">MUST</span> treat address
        advertisements as soft state, and it <span class="bcp14">MAY</span> choose to refresh advertisements periodically.
        Note also that an implementation <span class="bcp14">MAY</span> choose to cache these address advertisements even
        if they are not currently relevant but may be relevant in the future, such as IPv4 
        addresses when IPv6 connectivity is available but IPv4 is awaiting DHCP.<a class="pilcrow" href="#section-3.4.1-4">¶</a></p>
<p id="section-3.4.1-5">This option is shown in <a class="xref" href="#tcpm_address">Figure 12</a>. The illustration is sized for
        IPv4 addresses. For IPv6, the length of the address will be 16 octets (instead of 4).<a class="pilcrow" href="#section-3.4.1-5">¶</a></p>
<p id="section-3.4.1-6">The 2 octets that specify the TCP port number to use are optional, and their presence
        can be inferred from the length of the option. Although it is expected that the majority of 
        use cases will use the same port pairs as those used for the initial subflow (e.g., port 
        80 remains port 80 on all subflows, as does the ephemeral port at the client), there 
        may be cases (such as port-based load balancing) where the explicit specification of 
        a different port is required. If no port is specified, MPTCP <span class="bcp14">SHOULD</span> attempt to 
        connect to the specified address on the same port as the port that is already in use by the subflow
        on which the ADD_ADDR signal was sent; this is discussed in more detail in <a class="xref" href="#heuristics">Section 3.9</a>.<a class="pilcrow" href="#section-3.4.1-6">¶</a></p>
<p id="section-3.4.1-7">The Truncated HMAC parameter present in this option is the rightmost 64 bits of an HMAC, negotiated and
        calculated in the same way as for MP_JOIN as described in <a class="xref" href="#sec_join">Section 3.2</a>. For this 
        specification of MPTCP, as there is only one hash algorithm option specified, this will be HMAC as 
        defined in <span>[<a class="xref" href="#RFC2104">RFC2104</a>]</span>, using the SHA-256 hash algorithm <span>[<a class="xref" href="#RFC6234">RFC6234</a>]</span>.
        In the same way as for MP_JOIN, the key for the HMAC
        algorithm, in the case of the message transmitted by Host A, will be Key-A followed by Key-B, and in 
        the case of Host B, Key-B followed by Key-A.  These are the keys that were exchanged in the original 
        MP_CAPABLE handshake. The message for the HMAC is the Address ID, IP address, and port that precede 
        the HMAC in the ADD_ADDR option. If the port is not present in the ADD_ADDR option, the HMAC message
        will nevertheless include 2 octets of value zero. The rationale for the HMAC is to
        prevent unauthorized entities from injecting ADD_ADDR signals in an attempt to hijack a connection.
        Note that, additionally, the presence of this HMAC prevents the
        address from being changed in flight unless 
        the key is known by an intermediary. If a host receives an ADD_ADDR option for which it cannot
        validate the HMAC, it <span class="bcp14">SHOULD</span> silently ignore the option.<a class="pilcrow" href="#section-3.4.1-7">¶</a></p>
<p id="section-3.4.1-8">A set of four flags is present after the subtype and before the Address ID. Only the rightmost 
        bit -- labeled "E" -- is assigned in this specification. The other
        bits are currently unassigned; they <span class="bcp14">MUST</span> 
        be set to 0 by a sender and <span class="bcp14">MUST</span> be ignored by the receiver.<a class="pilcrow" href="#section-3.4.1-8">¶</a></p>
<p id="section-3.4.1-9">The "E" flag exists to provide reliability for this option. Because this option will often be sent
        on pure ACKs, there is no guarantee of reliability. Therefore, a receiver receiving a fresh ADD_ADDR
        option (where E=0) will send the same option back to the sender, but not including the HMAC and 
        with E=1, to indicate receipt. According to local policy, the lack of
        this type of "echo" can indicate to the initial ADD_ADDR sender that the
        ADD_ADDR needs to be retransmitted.<a class="pilcrow" href="#section-3.4.1-9">¶</a></p>
<p id="section-3.4.1-10">Due to the proliferation of NATs, it is reasonably likely that
          one host may attempt to advertise private addresses <span>[<a class="xref" href="#RFC1918">RFC1918</a>]</span>. It is not desirable to prohibit
 this behavior, since there may be cases where both hosts have additional
          interfaces on the same private network, and a host
          <span class="bcp14">MAY</span> advertise such addresses. The MP_JOIN handshake
          to create a new subflow (<a class="xref" href="#sec_join">Section 3.2</a>)
          provides mechanisms to minimize security risks. The MP_JOIN message
          contains a 32-bit token that uniquely identifies the connection to
          the receiving host. If the token is unknown, the host will respond
          with a RST. In the unlikely event that the token is valid at the
          receiving host, subflow setup will continue, but the HMAC exchange
          must occur for authentication. The HMAC exchange
 will fail and will provide
          sufficient protection against two unconnected hosts accidentally
          setting up a new subflow upon the signal of a private address.
 Further security considerations around the issue of ADD_ADDR messages that accidentally misdirect, or maliciously direct, new MP_JOIN attempts are discussed in <a class="xref" href="#sec_security">Section 5</a>.<a class="pilcrow" href="#section-3.4.1-10">¶</a></p>
<p id="section-3.4.1-11">A host that receives an ADD_ADDR but finds that a connection set up to that IP address and port number is unsuccessful <span class="bcp14">SHOULD NOT</span> perform further connection attempts to this address⁠/port combination for this connection. A sender that wants to trigger a new incoming connection attempt on a previously advertised address⁠/port combination can therefore refresh ADD_ADDR information by sending the option again.<a class="pilcrow" href="#section-3.4.1-11">¶</a></p>
<p id="section-3.4.1-12">A host can therefore send an ADD_ADDR message with an
          already-assigned Address ID, but the address <span class="bcp14">MUST</span> be
          the same as the address previously assigned to this Address ID. A
          new ADD_ADDR may have the same port number or a different port number. If the port number is different, the receiving host <span class="bcp14">SHOULD</span> try to set up a new subflow to this new address⁠/port combination.<a class="pilcrow" href="#section-3.4.1-12">¶</a></p>
<p id="section-3.4.1-13">A host wishing to replace an existing Address ID <span class="bcp14">MUST</span> first remove the existing one (<a class="xref" href="#sec_remove_addr">Section 3.4.2</a>).<a class="pilcrow" href="#section-3.4.1-13">¶</a></p>
<p id="section-3.4.1-14">During normal MPTCP operation, it is unlikely that there will be sufficient TCP option space for ADD_ADDR to be included along with those for data sequence numbering (<a class="xref" href="#sec_dsn">Section 3.3.1</a>). Therefore, it is expected that an MPTCP implementation will send the ADD_ADDR option on separate ACKs. As discussed earlier, however, an MPTCP implementation <span class="bcp14">MUST NOT</span> treat duplicate ACKs with any MPTCP option, with the exception of the DSS option, as indications of congestion <span>[<a class="xref" href="#RFC5681">RFC5681</a>]</span>, and an MPTCP implementation <span class="bcp14">SHOULD NOT</span> send more than two duplicate ACKs in a row for signaling purposes.<a class="pilcrow" href="#section-3.4.1-14">¶</a></p>
</section>
</div>
<div id="sec_remove_addr">
<section id="section-3.4.2">
          <h4 id="name-remove-address">
<a class="section-number selfRef" href="#section-3.4.2">3.4.2. </a><a class="section-name selfRef" href="#name-remove-address">Remove Address</a>
          </h4>
<p id="section-3.4.2-1">If, during the lifetime of an MPTCP connection, a previously
          announced address becomes invalid (e.g., if the interface
          disappears or an IPv6 address is no longer preferred), the affected
          host <span class="bcp14">SHOULD</span> announce this situation so that the peer can remove
          subflows related to this address. Even if an address is not in use
          by an MPTCP connection, if it has been previously announced, an
          implementation <span class="bcp14">SHOULD</span> announce its removal. A host
          <span class="bcp14">MAY</span> also choose to announce that a valid IP address
          should not be used any longer -- for example, for make‑before-break session continuity.<a class="pilcrow" href="#section-3.4.2-1">¶</a></p>
<p id="section-3.4.2-2">This is achieved through the Remove Address (REMOVE_ADDR) option
          (<a class="xref" href="#tcpm_remove">Figure 13</a>), which will remove a
          previously added address (or list of addresses) from a connection
          and terminate any subflows currently using that address.<a class="pilcrow" href="#section-3.4.2-2">¶</a></p>
<span id="name-remove-address-remove_addr-"></span><div id="tcpm_remove">
<figure id="figure-13">
            <div class="artwork art-text alignLeft" id="section-3.4.2-3.1">
<pre>                     1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+---------------+---------------+-------+-------+---------------+
|     Kind      |Length = 3 + n |Subtype|(resvd)|   Address ID  | ...
+---------------+---------------+-------+-------+---------------+
                           (followed by n-1 Address IDs, if required)</pre>
</div>
<figcaption><a class="selfRef" href="#figure-13">Figure 13</a>:
<a class="selfRef" href="#name-remove-address-remove_addr-">Remove Address (REMOVE_ADDR) Option</a>
            </figcaption></figure>
</div>
<p id="section-3.4.2-4">For security purposes, if a host receives a REMOVE_ADDR option,
          it must ensure that the affected path or paths are no longer in use
          before it instigates closure. The receipt of REMOVE_ADDR
          <span class="bcp14">SHOULD</span> first trigger the sending of a TCP keepalive
          <span>[<a class="xref" href="#RFC1122">RFC1122</a>]</span> on the path, and if a
          response is received, the path <span class="bcp14">SHOULD NOT</span> be
          removed. If the path is found to still be alive, the receiving host
          <span class="bcp14">SHOULD</span> no longer use the specified address for future
          connections, but it is the responsibility of the host that sent the
          REMOVE_ADDR to shut down the subflow. Before the address is removed,
          the requesting host
          <span class="bcp14">MAY</span> also use MP_PRIO (<a class="xref" href="#sec_policy">Section 3.3.8</a>) to request that a path no longer be used. Typical TCP validity tests on the subflow (e.g., ensuring
          that sequence and ACK numbers are correct) <span class="bcp14">MUST</span> also be undertaken. An implementation can use indications of these test failures as part of intrusion detection or error logging.<a class="pilcrow" href="#section-3.4.2-4">¶</a></p>
<p id="section-3.4.2-5">The sending and receipt (if no keepalive response was received)
          of this message <span class="bcp14">SHOULD</span> trigger the sending of RSTs by
          both hosts on the affected subflow(s) (if possible), as a courtesy,
          to allow the cleanup of middlebox state before cleaning up any local state.<a class="pilcrow" href="#section-3.4.2-5">¶</a></p>
<p id="section-3.4.2-6">Address removal is undertaken according to the Address ID, so as to
 permit the use of NATs and other middleboxes that rewrite source
 addresses.  If an Address ID is not known, the receiver will
 silently ignore the request.<a class="pilcrow" href="#section-3.4.2-6">¶</a></p>
<p id="section-3.4.2-7">A subflow that is still functioning <span class="bcp14">MUST</span> be closed with a FIN exchange as in regular TCP, rather than using this option. For more information, see <a class="xref" href="#sec_close">Section 3.3.3</a>.<a class="pilcrow" href="#section-3.4.2-7">¶</a></p>
</section>
</div>
</section>
</div>
<div id="sec_fastclose">
<section id="section-3.5">
        <h3 id="name-fast-close">
<a class="section-number selfRef" href="#section-3.5">3.5. </a><a class="section-name selfRef" href="#name-fast-close">Fast Close</a>
        </h3>
<p id="section-3.5-1">Regular TCP has the means of sending a RST signal to abruptly 
        close a connection. With MPTCP, a regular RST only has the scope of
        the subflow; it
        will only close the applicable subflow and will not affect the remaining
        subflows. MPTCP's connection will stay alive at the data level, in order
        to permit break-before-make handover between subflows. It is therefore
        necessary to provide an MPTCP-level "reset" to allow the abrupt closure
        of the whole MPTCP connection; this is done via the MP_FASTCLOSE option.<a class="pilcrow" href="#section-3.5-1">¶</a></p>
<p id="section-3.5-2">MP_FASTCLOSE is used to indicate to the peer that the connection will be
        abruptly closed and no data will be accepted anymore. The reasons for
        triggering an MP_FASTCLOSE are implementation specific. Regular TCP does
        not allow the sending of a RST while the connection is in a synchronized
        state <span>[<a class="xref" href="#RFC0793">RFC0793</a>]</span>. Nevertheless, implementations allow
        the sending of a RST in this state if, for example, the operating
        system is running out of resources. In these cases, MPTCP should send
        the MP_FASTCLOSE. This option is illustrated in <a class="xref" href="#tcpm_fastclose">Figure 14</a>.<a class="pilcrow" href="#section-3.5-2">¶</a></p>
<span id="name-fast-close-mp_fastclose-opt"></span><div id="tcpm_fastclose">
<figure id="figure-14">
          <div class="artwork art-text alignLeft" id="section-3.5-3.1">
<pre>                       1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +---------------+---------------+-------+-----------------------+
  |     Kind      |    Length     |Subtype|      (reserved)       |
  +---------------+---------------+-------+-----------------------+
  |                      Option Receiver's Key                    |
  |                            (64 bits)                          |
  |                                                               |
  +---------------------------------------------------------------+</pre>
</div>
<figcaption><a class="selfRef" href="#figure-14">Figure 14</a>:
<a class="selfRef" href="#name-fast-close-mp_fastclose-opt">Fast Close (MP_FASTCLOSE) Option</a>
          </figcaption></figure>
</div>
<p id="section-3.5-4">If Host A wants to force the closure of an MPTCP connection, it can
        do so via two
        options:<a class="pilcrow" href="#section-3.5-4">¶</a></p>
<ul>
<li id="section-3.5-5.1">Option A (ACK): Host A sends an ACK containing the MP_FASTCLOSE
            option on one subflow, containing the key of Host B as declared in
            the initial connection handshake.  On all the other subflows, Host A
            sends a regular TCP RST to close these subflows and tears them down.
            Host A now enters FASTCLOSE_WAIT state.<a class="pilcrow" href="#section-3.5-5.1">¶</a>
</li>
<li id="section-3.5-5.2">Option R (RST): Host A sends a RST containing the MP_FASTCLOSE
            option on all subflows, containing the key of Host B as declared in
            the initial connection handshake.  Host A can tear down the subflows and
            the connection immediately.<a class="pilcrow" href="#section-3.5-5.2">¶</a>
</li>
</ul>
<p id="section-3.5-6">If Host A decides to force the closure by using Option A and sending
        an ACK with the MP_FASTCLOSE option, the connection shall proceed as follows:<a class="pilcrow" href="#section-3.5-6">¶</a></p>
<ul>
<li id="section-3.5-7.1">Upon receipt of an ACK with MP_FASTCLOSE by Host B, containing the valid key, Host B answers
            on the same subflow with a TCP RST and tears down all subflows
            also through sending TCP RST signals. Host B can
            now close the whole MPTCP connection (it transitions directly to CLOSED state).<a class="pilcrow" href="#section-3.5-7.1">¶</a>
</li>
<li id="section-3.5-7.2">As soon as Host A has received the TCP RST on the remaining subflow, it
            can close this subflow and tear down the whole connection (transition from
            FASTCLOSE_WAIT state to CLOSED state). If Host A receives an MP_FASTCLOSE instead
            of a TCP RST, both hosts attempted fast closure simultaneously. Host A should
            reply with a TCP RST and tear down the connection.<a class="pilcrow" href="#section-3.5-7.2">¶</a>
</li>
<li id="section-3.5-7.3">If Host A does not receive a TCP RST in reply to its MP_FASTCLOSE after one
            retransmission timeout (RTO) (the RTO of the subflow where the MP_FASTCLOSE has been sent), it <span class="bcp14">SHOULD</span>
            retransmit the MP_FASTCLOSE. To keep this connection from being
            retained for a long time, the number of retransmissions <span class="bcp14">SHOULD</span> be
            limited;
            this limit is implementation specific. A <span class="bcp14">RECOMMENDED</span> number is 3. If no TCP RST
            is received in response, Host A <span class="bcp14">SHOULD</span> send a TCP RST with the MP_FASTCLOSE option
            itself when it releases state in order to clear any remaining state at middleboxes.<a class="pilcrow" href="#section-3.5-7.3">¶</a>
</li>
</ul>
<p id="section-3.5-8">If, however, Host A decides to force the closure by using Option R and
        sending a RST with the MP_FASTCLOSE option, Host B will act as follows:
        upon receipt of a RST with MP_FASTCLOSE, containing the valid key,
        Host B tears down all subflows by sending a TCP RST. Host B can now close the whole MPTCP
        connection (it transitions directly to CLOSED state).<a class="pilcrow" href="#section-3.5-8">¶</a></p>
</section>
</div>
<div id="sec_reset">
<section id="section-3.6">
        <h3 id="name-subflow-reset">
<a class="section-number selfRef" href="#section-3.6">3.6. </a><a class="section-name selfRef" href="#name-subflow-reset">Subflow Reset</a>
        </h3>
<p id="section-3.6-1">An implementation of MPTCP may also need to send a regular TCP RST to force
        the closure of a subflow. A host sends a TCP RST in order to close a subflow
        or reject an attempt to open a subflow (MP_JOIN). In order to let the
        receiving host know why a subflow is being closed or rejected, the TCP RST packet
        <span class="bcp14">MAY</span> include the MP_TCPRST option (<a class="xref" href="#tcpm_reset">Figure 15</a>). The host <span class="bcp14">MAY</span> use this information to
        decide, for example, whether it tries to re-establish the subflow
        immediately, later, or never.<a class="pilcrow" href="#section-3.6-1">¶</a></p>
<span id="name-tcp-rst-reason-mp_tcprst-op"></span><div id="tcpm_reset">
<figure id="figure-15">
          <div class="artwork art-text alignLeft" id="section-3.6-2.1">
<pre>                       1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +---------------+---------------+-------+-----------------------+
  |     Kind      |    Length     |Subtype|U|V|W|T|    Reason     |
  +---------------+---------------+-------+-----------------------+</pre>
</div>
<figcaption><a class="selfRef" href="#figure-15">Figure 15</a>:
<a class="selfRef" href="#name-tcp-rst-reason-mp_tcprst-op">TCP RST Reason (MP_TCPRST) Option</a>
          </figcaption></figure>
</div>
<p id="section-3.6-3">The MP_TCPRST option contains a reason code that allows the
        sender of the option to provide more information about the reason for
        the termination of the subflow.  Using 12 bits of option space, the
        first 4 bits are reserved for flags (only one of which is currently
        defined), and the remaining octet is used to express a reason code for 
        this subflow termination, from which a receiver <span class="bcp14">MAY</span> infer information 
        about the usability of this path.<a class="pilcrow" href="#section-3.6-3">¶</a></p>
<p id="section-3.6-4">The "T" flag is used by the sender to indicate whether the error
        condition that is reported is Transient ("T" bit set to 1) or Permanent
        ("T" bit set to 0).  If the error condition is considered to be
        Transient by the sender of the RST segment, the recipient of this
        segment <span class="bcp14">MAY</span> try to re-establish a subflow for this connection over the 
        failed path.  The time at which a receiver may try to
 re‑establish this subflow
        is implementation specific but <span class="bcp14">SHOULD</span> take into account the properties
        of the failure as defined by the provided reason code.  If the error condition 
        is considered to be Permanent, the receiver of the RST segment <span class="bcp14">SHOULD NOT</span> try 
        to re‑establish a subflow for this connection over this path.  The "U", "V", 
        and "W" flags are not defined by this specification and are reserved for
        future use. An implementation of this specification <span class="bcp14">MUST</span> set these flags 
        to 0, and a receiver <span class="bcp14">MUST</span> ignore them.<a class="pilcrow" href="#section-3.6-4">¶</a></p>
<p id="section-3.6-5">"Reason" is an 8-bit field that indicates the reason code for
        the termination of the subflow.  The following codes are defined in
        this document:<a class="pilcrow" href="#section-3.6-5">¶</a></p>
<ul>
<li id="section-3.6-6.1">Unspecified error (code 0x00).  This is the default error;
 it implies that the
            subflow is no longer available.  The presence of this option shows
            that the RST was generated by an MPTCP-aware device.<a class="pilcrow" href="#section-3.6-6.1">¶</a>
</li>
<li id="section-3.6-6.2">MPTCP-specific error (code 0x01).  An error has been detected in the 
            processing of MPTCP options.  This is the usual reason code to return
            in the cases where a RST is being sent to close a subflow because
            of an invalid response.<a class="pilcrow" href="#section-3.6-6.2">¶</a>
</li>
<li id="section-3.6-6.3">Lack of resources (code 0x02).  This code indicates that the
            sending host does not have enough resources to support the
            terminated subflow.<a class="pilcrow" href="#section-3.6-6.3">¶</a>
</li>
<li id="section-3.6-6.4">Administratively prohibited (code 0x03).  This code indicates that
            the requested subflow is prohibited by the policies of the sending
            host.<a class="pilcrow" href="#section-3.6-6.4">¶</a>
</li>
<li id="section-3.6-6.5">Too much outstanding data (code 0x04).  This code indicates that 
            there is an excessive amount of data that needs to be transmitted
            over the terminated subflow while having already been acknowledged
            over one or more other subflows. This may occur if a path has been
            unavailable for a short period and it is more efficient to reset and
            start again than it is to retransmit the queued data.<a class="pilcrow" href="#section-3.6-6.5">¶</a>
</li>
<li id="section-3.6-6.6">Unacceptable performance (code 0x05).  This code indicates that
            the performance of this subflow was too low compared to the other
            subflows of this Multipath TCP connection.<a class="pilcrow" href="#section-3.6-6.6">¶</a>
</li>
<li id="section-3.6-6.7">Middlebox interference (code 0x06).  Middlebox interference has
            been detected over this subflow, making MPTCP signaling invalid.  For
            example, this may be sent if the checksum does not validate.<a class="pilcrow" href="#section-3.6-6.7">¶</a>
</li>
</ul>
</section>
</div>
<div id="sec_fallback">
<section id="section-3.7">
        <h3 id="name-fallback">
<a class="section-number selfRef" href="#section-3.7">3.7. </a><a class="section-name selfRef" href="#name-fallback">Fallback</a>
        </h3>
<p id="section-3.7-1">Sometimes, middleboxes will exist on a path that could prevent the
        operation of MPTCP. MPTCP has been designed to cope with many
        middlebox modifications (see <a class="xref" href="#sec_middleboxes">Section 6</a>), but there are still some cases where a subflow
        could fail to operate within the MPTCP requirements. Notably, these cases are the following: the loss of MPTCP options on a path and the modification of payload data. If such an event occurs, it is necessary to "fall back" to the previous, safe operation. This may be either falling back to regular TCP or removing a problematic subflow.<a class="pilcrow" href="#section-3.7-1">¶</a></p>
<p id="section-3.7-2">At the start of an MPTCP connection (i.e., the first subflow), it is important to ensure that the path is fully MPTCP capable and the necessary MPTCP options can reach each host. The handshake as described in <a class="xref" href="#sec_init">Section 3.1</a> <span class="bcp14">SHOULD</span> fall back to regular TCP if either of the SYN messages does not have the MPTCP options: this is the same, and desired, behavior in the case where a host is not MPTCP capable or the path does not support the MPTCP options. When attempting to join an existing MPTCP connection (<a class="xref" href="#sec_join">Section 3.2</a>), if a path is not MPTCP capable and the MPTCP options do not get through on the SYNs, the subflow will be closed according to the MP_JOIN logic.<a class="pilcrow" href="#section-3.7-2">¶</a></p>
<p id="section-3.7-3">There is, however, another corner case that should be addressed:
        the case where MPTCP options get through on the SYN but not on regular
        packets. If the subflow is the first subflow and thus all data in
        flight is contiguous, this situation can be resolved by using the following rules:<a class="pilcrow" href="#section-3.7-3">¶</a></p>
<ul>
<li id="section-3.7-4.1">A sender <span class="bcp14">MUST</span> include a DSS option with Data Sequence Mapping in every segment until one of the sent segments has been acknowledged with a DSS option containing a Data ACK. Upon reception of the acknowledgment, the sender has the confirmation that the DSS option passes in both directions and may choose to send fewer DSS options than once per segment.<a class="pilcrow" href="#section-3.7-4.1">¶</a>
</li>
<li id="section-3.7-4.2">If, however, an ACK is received for data (not just for the SYN)
        without a DSS option containing a Data ACK, the sender determines that the path is not MPTCP capable. In the case of this occurring on an additional subflow (i.e., one started with MP_JOIN), the host <span class="bcp14">MUST</span> close the subflow with a RST, which <span class="bcp14">SHOULD</span> contain an MP_TCPRST option (<a class="xref" href="#sec_reset">Section 3.6</a>) with a "Middlebox interference" reason code.<a class="pilcrow" href="#section-3.7-4.2">¶</a>
</li>
<li id="section-3.7-4.3">In the case of such an ACK being received on the first subflow
        (i.e., that started with MP_CAPABLE), before any additional subflows
        are added, the implementation <span class="bcp14">MUST</span> drop out of MPTCP
        mode and fall back to regular TCP. The sender will send one final Data Sequence Mapping, with the Data-Level Length value of 0 indicating an infinite mapping (to inform the other end in case the path drops options in one direction only), and then revert to sending data on the single subflow without any MPTCP options.<a class="pilcrow" href="#section-3.7-4.3">¶</a>
</li>
<li id="section-3.7-4.4">If a subflow breaks during operation, e.g., if it is rerouted and
        MPTCP options are no longer permitted, then once this is detected (by
        the subflow-level receive buffer filling up, since there is no mapping
        available in order to DATA_ACK this data), the subflow
        <span class="bcp14">SHOULD</span> be treated as broken and closed with a RST,
        since no data can be delivered to the application layer and no
        fallback signal can be reliably sent. This RST <span class="bcp14">SHOULD</span>
        include the MP_TCPRST option (<a class="xref" href="#sec_reset">Section 3.6</a>) with a "Middlebox interference" reason code.<a class="pilcrow" href="#section-3.7-4.4">¶</a>
</li>
</ul>
<p id="section-3.7-5">These rules should cover all cases where such a failure could
        happen -- whether it's on the forward or reverse path and whether the server or the client first sends data.<a class="pilcrow" href="#section-3.7-5">¶</a></p>
<p id="section-3.7-6">So far, this section has discussed the loss of MPTCP options,
        either initially or during the course of the connection. As described
        in <a class="xref" href="#sec_generalop">Section 3.3</a>, each portion of
        data for which there is a mapping is protected by a checksum, if
        checksums have been negotiated. This mechanism is used to detect if
        middleboxes have made any adjustments to the payload (added, removed,
        or changed data). A checksum will fail if the data has been changed in
        any way. The use of a checksum will also detect whether the length of data on the subflow is
        increased or decreased, and this means the Data Sequence Mapping is no
        longer valid. The sender no longer knows what subflow-level sequence
        number the receiver is genuinely operating at (the middlebox will be
        faking ACKs in return), and it cannot signal any further
        mappings. Furthermore, in addition to the possibility of payload
        modifications that are valid at the application layer, it is possible that such modifications could be triggered across MPTCP segment boundaries, corrupting the data. Therefore, all data from the start of the segment that failed the checksum onward is not trustworthy.<a class="pilcrow" href="#section-3.7-6">¶</a></p>
<p id="section-3.7-7">Note that if checksum usage has not been negotiated, this fallback mechanism cannot be used unless there is some higher-layer or lower‑layer signal to inform the MPTCP implementation that the payload has been tampered with.<a class="pilcrow" href="#section-3.7-7">¶</a></p>
<p id="section-3.7-8">When multiple subflows are in use, the data in flight on a subflow
        will likely involve data that is not contiguously part of the
        connection-level stream, since segments will be spread across the
        multiple subflows. Due to the problems identified above, it is not
        possible to determine what adjustments have been done to the data (notably,
        any changes to the subflow sequence numbering). Therefore, it is not
        possible to recover the subflow, and the affected subflow must be
        immediately closed with a RST that includes an MP_FAIL option (<a class="xref" href="#tcpm_fallback">Figure 16</a>), which defines the data sequence number at the start of the segment (defined by the Data Sequence Mapping) that had the checksum failure. Note that the MP_FAIL option requires the use of the full 64-bit sequence number, even if 32-bit sequence numbers are normally in use in the DSS signals on the path.<a class="pilcrow" href="#section-3.7-8">¶</a></p>
<span id="name-fallback-mp_fail-option"></span><div id="tcpm_fallback">
<figure id="figure-16">
          <div class="artwork art-text alignLeft" id="section-3.7-9.1">
<pre>                       1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +---------------+---------------+-------+----------------------+
  |     Kind      |   Length=12   |Subtype|      (reserved)      |
  +---------------+---------------+-------+----------------------+
  |                                                              |
  |                 Data Sequence Number (8 octets)              |
  |                                                              |
  +--------------------------------------------------------------+</pre>
</div>
<figcaption><a class="selfRef" href="#figure-16">Figure 16</a>:
<a class="selfRef" href="#name-fallback-mp_fail-option">Fallback (MP_FAIL) Option</a>
          </figcaption></figure>
</div>
<p id="section-3.7-10">The receiver of this option <span class="bcp14">MUST</span> discard all data following the data sequence number specified.
        Failed data <span class="bcp14">MUST NOT</span> be DATA_ACKed and so will be retransmitted on other subflows (<a class="xref" href="#sec_retransmit">Section 3.3.6</a>).<a class="pilcrow" href="#section-3.7-10">¶</a></p>
<p id="section-3.7-11">A special case is when there is a single subflow and it fails with a checksum error. If it is known that all unacknowledged data in
 flight is contiguous (which will usually be the case with a single
 subflow), an infinite mapping can be applied to the subflow without
 the need to close it first, essentially turning off all further
 MPTCP signaling.

 In this case, if a receiver identifies a checksum failure
when there is only one path, it will send back an MP_FAIL option on the subflow-level ACK, referring to the data-level sequence number of the start of the 
segment on which the checksum error was detected. The sender will receive
this information and, if all unacknowledged data in flight is contiguous, will signal an infinite mapping. 
This infinite mapping will be a DSS option (<a class="xref" href="#sec_generalop">Section 3.3</a>)
on the first new packet, containing a Data Sequence Mapping that acts retroactively, referring to the start of the subflow sequence 
number of the most recent segment that was known to be delivered intact (i.e., was successfully DATA_ACKed). From that point onward, data can be altered 
by a middlebox without affecting MPTCP, as the data stream is equivalent to a regular, legacy TCP session.
While in theory paths may only be damaged in one direction -- and the MP_FAIL
signal affects only one direction of traffic --
for simplicity of implementation, the receiver of an MP_FAIL <span class="bcp14">MUST</span> also respond with an MP_FAIL in the reverse direction and entirely revert to a regular TCP session.<a class="pilcrow" href="#section-3.7-11">¶</a></p>
<p id="section-3.7-12">In the rare case that the data is not contiguous (which could happen when there is only one subflow but it is retransmitting data from a subflow
that has recently been uncleanly closed), the receiver <span class="bcp14">MUST</span> close the subflow with a RST with MP_FAIL. The receiver <span class="bcp14">MUST</span> discard all data that follows the 
data sequence number specified. The sender <span class="bcp14">MAY</span> attempt to
create a new subflow belonging to the same connection and, if it chooses to do
so, <span class="bcp14">SHOULD</span> immediately place 
the single subflow in single-path mode by setting an infinite Data Sequence Mapping. This mapping will begin from the data-level sequence number 
that was declared in the MP_FAIL.<a class="pilcrow" href="#section-3.7-12">¶</a></p>
<p id="section-3.7-13">After a sender signals an infinite mapping, it <span class="bcp14">MUST</span> only use subflow ACKs to clear its send buffer.
This is because Data ACKs may become misaligned with the subflow ACKs when middleboxes insert or delete data. 
The receiver <span class="bcp14">SHOULD</span> stop generating Data ACKs after it receives
an infinite mapping.<a class="pilcrow" href="#section-3.7-13">¶</a></p>
<p id="section-3.7-14">When a connection has fallen back with an infinite mapping, only one subflow can send data; otherwise, the receiver would not know how to reorder the data. In practice, this means that all MPTCP subflows will have to be terminated except one. Once MPTCP falls back to regular TCP, it <span class="bcp14">MUST NOT</span> revert to MPTCP later in the connection.<a class="pilcrow" href="#section-3.7-14">¶</a></p>
<p id="section-3.7-15">It should be emphasized that MPTCP is not attempting to prevent the use of middleboxes that want to adjust the payload. An MPTCP-aware middlebox could provide such functionality by also rewriting checksums.<a class="pilcrow" href="#section-3.7-15">¶</a></p>
</section>
</div>
<div id="sec_errors">
<section id="section-3.8">
        <h3 id="name-error-handling">
<a class="section-number selfRef" href="#section-3.8">3.8. </a><a class="section-name selfRef" href="#name-error-handling">Error Handling</a>
        </h3>
<p id="section-3.8-1">In addition to the fallback mechanism described above, the standard classes of TCP errors may need to be handled in an MPTCP‑specific way. Note that changing semantics -- such as the relevance of a RST -- are covered in <a class="xref" href="#sec_semantics">Section 4</a>. Where possible, we do not want to deviate from regular TCP behavior.<a class="pilcrow" href="#section-3.8-1">¶</a></p>
<p id="section-3.8-2">The following list covers possible errors and the appropriate MPTCP behavior:<a class="pilcrow" href="#section-3.8-2">¶</a></p>
<ul>
<li id="section-3.8-3.1">Unknown token in MP_JOIN (or HMAC failure in MP_JOIN ACK, or missing MP_JOIN in SYN/ACK response): send RST (analogous to TCP's behavior on an unknown port)<a class="pilcrow" href="#section-3.8-3.1">¶</a>
</li>
<li id="section-3.8-3.2">DSN out of window (during normal operation): drop the data; do not send Data ACKs<a class="pilcrow" href="#section-3.8-3.2">¶</a>
</li>
<li id="section-3.8-3.3">Remove request for unknown Address ID: silently ignore<a class="pilcrow" href="#section-3.8-3.3">¶</a>
</li>
</ul>
</section>
</div>
<div id="heuristics">
<section id="section-3.9">
        <h3 id="name-heuristics">
<a class="section-number selfRef" href="#section-3.9">3.9. </a><a class="section-name selfRef" href="#name-heuristics">Heuristics</a>
        </h3>
<p id="section-3.9-1">There are a number of heuristics that are needed for
        performance or deployment but that are not required for
        protocol correctness.  In this section, we detail such
        heuristics. Note that discussions of buffering and certain
        sender and receiver window behaviors are presented in Sections 
        <a class="xref" href="#sec_rwin">3.3.4</a> and <a class="xref" href="#sec_sender">3.3.5</a>,
        and retransmission is discussed in <a class="xref" href="#sec_retransmit">Section 3.3.6</a>.<a class="pilcrow" href="#section-3.9-1">¶</a></p>
<section id="section-3.9.1">
          <h4 id="name-port-usage">
<a class="section-number selfRef" href="#section-3.9.1">3.9.1. </a><a class="section-name selfRef" href="#name-port-usage">Port Usage</a>
          </h4>
<p id="section-3.9.1-1">Under typical operation, an MPTCP implementation <span class="bcp14">SHOULD</span> use
          the same ports as the ports that are already in use. In other words, the
          destination port of a SYN containing an MP_JOIN option <span class="bcp14">SHOULD</span>
          be the same as the remote port of the first subflow in the
          connection.  The local port for such SYNs <span class="bcp14">SHOULD</span> also be the
          same as the port for the first subflow (and as such, an
          implementation <span class="bcp14">SHOULD</span> reserve ephemeral ports across all
          local IP addresses), although there may be cases where this
          is infeasible.  This strategy is intended to maximize the
          probability of the SYN being permitted by a firewall or NAT
          at the recipient and to avoid confusing any network-monitoring software.<a class="pilcrow" href="#section-3.9.1-1">¶</a></p>
<p id="section-3.9.1-2">There may also be cases, however, where a host wishes to 
          signal that a specific port should be used; this facility 
          is provided in the ADD_ADDR option as documented in
          <a class="xref" href="#sec_add_address">Section 3.4.1</a>.  It is therefore feasible
          to allow multiple subflows between the same two addresses
          but using different port pairs, and 
          such a facility could be used to allow load balancing within
          the network based on 5-tuples (e.g., some ECMP implementations <span>[<a class="xref" href="#RFC2992">RFC2992</a>]</span>).<a class="pilcrow" href="#section-3.9.1-2">¶</a></p>
</section>
<section id="section-3.9.2">
          <h4 id="name-delayed-subflow-start-and-s">
<a class="section-number selfRef" href="#section-3.9.2">3.9.2. </a><a class="section-name selfRef" href="#name-delayed-subflow-start-and-s">Delayed Subflow Start and Subflow Symmetry</a>
          </h4>
<p id="section-3.9.2-1">Many TCP connections are short-lived and consist only of a few 
          segments, and so the overhead
          of using MPTCP outweighs any benefits. A heuristic is required,
          therefore, to decide when to start using additional subflows in 
          an MPTCP connection. Experimental deployments have shown that
          MPTCP can be applied in a range of scenarios, so an implementation
          will likely need to take into account such factors as the type of
          traffic being sent and the duration of the session; this information
          <span class="bcp14">MAY</span> be signaled by the application layer.<a class="pilcrow" href="#section-3.9.2-1">¶</a></p>
<p id="section-3.9.2-2">However, for standard TCP traffic, a suggested general-purpose
          heuristic that an implementation <span class="bcp14">MAY</span> choose to employ is as follows.<a class="pilcrow" href="#section-3.9.2-2">¶</a></p>
<p id="section-3.9.2-3">If a host has data buffered for its peer (which implies that the
          application has received a request for data), the host opens one
          subflow for each initial window's worth of data that is buffered.<a class="pilcrow" href="#section-3.9.2-3">¶</a></p>
<p id="section-3.9.2-4">Consideration should also be given to limiting the rate of adding
          new subflows, as well as limiting the total number of subflows open
          for a particular connection.  A host may choose to vary these values 
          based on its load or knowledge of traffic and path characteristics.<a class="pilcrow" href="#section-3.9.2-4">¶</a></p>
<p id="section-3.9.2-5">Note that this heuristic alone is probably insufficient. Traffic
          for many common applications, such as downloads, is highly asymmetric, and 
          the host that is multihomed may well be the client that will never fill
          its buffers and thus never use MPTCP according to this heuristic. Advanced APIs that allow an 
          application to signal its traffic requirements would aid in these decisions.<a class="pilcrow" href="#section-3.9.2-5">¶</a></p>
<p id="section-3.9.2-6">An additional time-based heuristic could be applied, opening additional
          subflows after a given period of time has passed. This would alleviate the
          above issue and also provide resilience for low‑bandwidth but long-lived
          applications.<a class="pilcrow" href="#section-3.9.2-6">¶</a></p>
<p id="section-3.9.2-7">Another issue is that both communicating hosts may simultaneously try to
          set up a subflow between the same pair of addresses. This leads to an
          inefficient use of resources.<a class="pilcrow" href="#section-3.9.2-7">¶</a></p>
<p id="section-3.9.2-8">If the same ports are used on all subflows, as recommended above, 
          then standard TCP simultaneous-open logic should take care of this situation 
          and only one subflow will be established between the address pairs. However, 
          this relies on the same ports being used at both end hosts. If a host does
          not support TCP simultaneous open, it is <span class="bcp14">RECOMMENDED</span> that some element 
          of randomization be applied to the time to wait before opening new subflows,
          so that only one subflow is created between a given address pair. If, however, 
          hosts signal additional ports to use (for example, for leveraging ECMP on-path), 
          this heuristic is not appropriate.<a class="pilcrow" href="#section-3.9.2-8">¶</a></p>
<p id="section-3.9.2-9">This section has shown some of the factors that an implementer
          should consider when developing MPTCP heuristics, but it is not intended to be
          prescriptive.<a class="pilcrow" href="#section-3.9.2-9">¶</a></p>
</section>
<section id="section-3.9.3">
          <h4 id="name-failure-handling">
<a class="section-number selfRef" href="#section-3.9.3">3.9.3. </a><a class="section-name selfRef" href="#name-failure-handling">Failure Handling</a>
          </h4>
<p id="section-3.9.3-1">Requirements for MPTCP's handling of unexpected signals are
          given in <a class="xref" href="#sec_errors">Section 3.8</a>. There are other failure cases, 
          however, where hosts can choose appropriate behavior.<a class="pilcrow" href="#section-3.9.3-1">¶</a></p>
<p id="section-3.9.3-2">For example, <a class="xref" href="#sec_init">Section 3.1</a> suggests that a host <span class="bcp14">SHOULD</span>
          fall back to trying regular TCP SYNs after one or more failures of MPTCP
          SYNs for a connection. A host may keep a system-wide cache of such 
          information, so that it can back off from using MPTCP, firstly for that
          particular destination host and, eventually, on a whole interface, if 
          MPTCP connections continue to fail. The duration of such a cache would
          be implementation specific.<a class="pilcrow" href="#section-3.9.3-2">¶</a></p>
<p id="section-3.9.3-3">Another failure could occur when the MP_JOIN handshake fails.
          <a class="xref" href="#sec_errors">Section 3.8</a> specifies that an incorrect handshake <span class="bcp14">MUST</span>
          lead to the subflow being closed with a RST. A host operating an active
          intrusion-detection system may choose to start blocking MP_JOIN packets
          from the source host if multiple failed MP_JOIN attempts are seen. From
          the connection initiator's point of view, if an MP_JOIN fails, it
          <span class="bcp14">SHOULD NOT</span>
          attempt to connect to the same IP address and port during the lifetime 
          of the connection, unless the other host refreshes the information with 
          another ADD_ADDR option. Note that the ADD_ADDR option is informational 
          only and does not guarantee that the other host will attempt a connection.<a class="pilcrow" href="#section-3.9.3-3">¶</a></p>
<p id="section-3.9.3-4">In addition, an implementation may learn, over a number of connections, 
          that certain interfaces or destination addresses consistently fail and
          may default to not trying to use MPTCP for such interfaces or
          addresses.  The behavior of subflows that perform particularly badly
          or subflows that regularly fail during use could also 
          be learned, so that an implementation can temporarily choose not to use 
          these paths.<a class="pilcrow" href="#section-3.9.3-4">¶</a></p>
</section>
</section>
</div>
</section>
</div>
<div id="sec_semantics">
<section id="section-4">
      <h2 id="name-semantic-issues">
<a class="section-number selfRef" href="#section-4">4. </a><a class="section-name selfRef" href="#name-semantic-issues">Semantic Issues</a>
      </h2>
<p id="section-4-1">In order to support multipath operation, the semantics of some TCP
      components have changed. To help clarify, this section lists these
      semantic changes as a point of reference.<a class="pilcrow" href="#section-4-1">¶</a></p>
<dl class="dlParallel" id="section-4-2">
        <dt id="section-4-2.1">Sequence number:</dt>
<dd id="section-4-2.2" style="margin-left: 1.5em"> The (in-header) TCP sequence
            number is specific to the subflow. To allow the receiver to
            reorder application data, an additional data-level
            sequence space is used. In this data‑level sequence space, the initial SYN and
            the final DATA_FIN occupy 1 octet of sequence space. This is done to
            ensure that these
            signals are acknowledged at the connection level. There is an explicit
            mapping of data sequence space to subflow sequence space,
            which is signaled through TCP options in data
            packets.<a class="pilcrow" href="#section-4-2.2">¶</a>
</dd>
<dt id="section-4-2.3">ACK:</dt>
<dd id="section-4-2.4" style="margin-left: 1.5em"> The ACK field in the TCP header
            acknowledges only the subflow sequence number -- not the
            data-level sequence space. Implementations <span class="bcp14">SHOULD NOT</span>
            attempt to infer a data-level acknowledgment from the
            subflow ACKs.  
            This separates subflow-level and connection-level processing
            at an end host.<a class="pilcrow" href="#section-4-2.4">¶</a>
</dd>
<dt id="section-4-2.5">Duplicate ACK:</dt>
<dd id="section-4-2.6" style="margin-left: 1.5em"> A duplicate ACK that includes any MPTCP signaling
            (with the exception of the DSS option) <span class="bcp14">MUST NOT</span> be treated as a signal of congestion. 
            To limit the chances of non-MPTCP-aware entities mistakenly interpreting duplicate 
            ACKs as a signal of congestion, MPTCP <span class="bcp14">SHOULD NOT</span> send more than two duplicate ACKs 
            containing (non-DSS) MPTCP signals in a row.<a class="pilcrow" href="#section-4-2.6">¶</a>
</dd>
<dt id="section-4-2.7">Receive Window:</dt>
<dd id="section-4-2.8" style="margin-left: 1.5em">The receive window in the TCP
            header indicates the amount of free buffer space for the
            whole data-level connection (as opposed to the amount of space for this
            subflow) that is available at the receiver.  The
            semantics are the same as for regular TCP, but to maintain these
            semantics the receive window must be interpreted at the
            sender as relative to the sequence number given in the
            DATA_ACK rather than the subflow ACK in the TCP header.
            In this way, the original role of flow control is preserved.
            Note that some middleboxes may change the receive window,
            and so a host <span class="bcp14">SHOULD</span> use the maximum value of those recently
            seen on the constituent subflows for the connection-level
            receive window and also needs to maintain a subflow-level 
            window for subflow-level processing.<a class="pilcrow" href="#section-4-2.8">¶</a>
</dd>
<dt id="section-4-2.9">FIN:</dt>
<dd id="section-4-2.10" style="margin-left: 1.5em"> The FIN flag in the TCP header applies
            only to the subflow it is sent on -- not to the whole
            connection. For connection-level FIN semantics, the
            DATA_FIN option is used.<a class="pilcrow" href="#section-4-2.10">¶</a>
</dd>
<dt id="section-4-2.11">RST:</dt>
<dd id="section-4-2.12" style="margin-left: 1.5em"> The RST flag in the TCP header applies
            only to the subflow it is sent on -- not to the whole
            connection. The MP_FASTCLOSE option provides the Fast Close
            functionality of a RST at the MPTCP connection level.<a class="pilcrow" href="#section-4-2.12">¶</a>
</dd>
<dt id="section-4-2.13">Address List:</dt>
<dd id="section-4-2.14" style="margin-left: 1.5em"> Address list management (i.e., 
            knowledge of the local and remote hosts' lists of 
            available IP addresses) is handled
            on a per-connection basis (as opposed to per subflow, per
            host, or per pair of communicating hosts).  This permits
            the application of per-connection local policy.  Adding an
            address to one connection (either explicitly through an 
            ADD_ADDR message or implicitly through an MP_JOIN) has no implications
            for other connections between the same pair of hosts.<a class="pilcrow" href="#section-4-2.14">¶</a>
</dd>
<dt id="section-4-2.15">5-tuple:</dt>
<dd id="section-4-2.16" style="margin-left: 1.5em"> The 5-tuple (protocol, local
            address, local port, remote address, remote port)
            presented by kernel APIs to the application layer in a
            non-multipath-aware application is that of the first
            subflow, even if the subflow has since been closed and
            removed from the connection. This decision, and other
            related API issues, are discussed in more detail in
            <span>[<a class="xref" href="#RFC6897">RFC6897</a>]</span>.<a class="pilcrow" href="#section-4-2.16">¶</a>
</dd>
</dl>
</section>
</div>
<div id="sec_security">
<section id="section-5">
      <h2 id="name-security-considerations">
<a class="section-number selfRef" href="#section-5">5. </a><a class="section-name selfRef" href="#name-security-considerations">Security Considerations</a>
      </h2>
<p id="section-5-1">As identified in <span>[<a class="xref" href="#RFC6181">RFC6181</a>]</span>, the
      addition of multipath capability to TCP will bring with it a number of
      new classes of threats. In order to prevent these threats, <span>[<a class="xref" href="#RFC6182">RFC6182</a>]</span> presents a set of requirements for a security
      solution for MPTCP. The fundamental goal is for the security of MPTCP to
      be "no worse" than regular TCP today. The key security requirements
      are as follows:<a class="pilcrow" href="#section-5-1">¶</a></p>
<ul>
<li id="section-5-2.1">Provide a mechanism to confirm that the parties in a subflow
        handshake are the same as the parties in the original connection setup.<a class="pilcrow" href="#section-5-2.1">¶</a>
</li>
<li id="section-5-2.2">Provide verification that the peer can receive traffic at a new address before using it as part of a connection.<a class="pilcrow" href="#section-5-2.2">¶</a>
</li>
<li id="section-5-2.3">Provide replay protection, i.e., ensure that a request to add⁠/remove a subflow is "fresh".<a class="pilcrow" href="#section-5-2.3">¶</a>
</li>
</ul>
<p id="section-5-3">
        In order to achieve these goals, MPTCP includes a hash-based handshake
      algorithm, as documented in Sections <a class="xref" href="#sec_init">3.1</a> and <a class="xref" href="#sec_join">3.2</a>.<a class="pilcrow" href="#section-5-3">¶</a></p>
<p id="section-5-4">The security of the MPTCP connection hangs on the use of keys that
      are shared once at the start of the first subflow and are never sent
      again over the network (unless used in the Fast Close mechanism (<a class="xref" href="#sec_fastclose">Section 3.5</a>)).  To ease demultiplexing
      while not giving away any cryptographic material, future subflows use a
      truncated cryptographic hash of this key as the connection
      identification "token".  The keys are concatenated and used as keys for
      creating Hash-based Message Authentication Codes (HMACs) used on subflow
      setup, in order to verify that the parties in the handshake are the same
      as the parties in the original connection setup.  It also provides verification that
      the peer can receive traffic at this new address.  Replay attacks would
      still be possible when only keys are used; therefore, the handshakes use
      single-use random numbers (nonces) at both ends -- this ensures that the HMAC will never be the same on two handshakes. Guidance on generating random numbers suitable for use as keys is given in <span>[<a class="xref" href="#RFC4086">RFC4086</a>]</span> and discussed in <a class="xref" href="#sec_init">Section 3.1</a>. The nonces are valid for the lifetime of the TCP connection attempt. HMAC is also used to secure the ADD_ADDR option, due to the threats identified in <span>[<a class="xref" href="#RFC7430">RFC7430</a>]</span>.<a class="pilcrow" href="#section-5-4">¶</a></p>
<p id="section-5-5">The use of crypto capability bits in the initial connection handshake
      to negotiate the use of a particular algorithm allows the deployment of additional crypto mechanisms in the future.  This negotiation would nevertheless be susceptible to a bid-down attack by an on-path active attacker who could modify the crypto capability bits in the response from the receiver to use a less secure crypto mechanism. The security mechanism presented in this document should therefore protect against all forms of flooding and hijacking attacks discussed in <span>[<a class="xref" href="#RFC6181">RFC6181</a>]</span>.<a class="pilcrow" href="#section-5-5">¶</a></p>
<p id="section-5-6">The version negotiation specified in <a class="xref" href="#sec_init">Section 3.1</a>, if differing MPTCP versions shared a common
      negotiation format, would allow an on-path attacker to apply a
      theoretical bid-down attack. Since the v1 and v0 protocols have a
      different handshake, such an attack would require that the client
      re-establish the connection using v0 and that the server support v0.
 Note that an on-path attacker would have access to the raw data, negating any other TCP-level security mechanisms. As also noted in <a class="xref" href="#app_changelog">Appendix E</a>, this document specifies the removal of the AddrID field <span>[<a class="xref" href="#RFC6824">RFC6824</a>]</span> in the MP_PRIO option (<a class="xref" href="#sec_policy">Section 3.3.8</a>).
 This change eliminates the possibility of a theoretical attack where
 a subflow could be placed in "backup" mode by an attacker.<a class="pilcrow" href="#section-5-6">¶</a></p>
<p id="section-5-7">During normal operation, regular TCP protection mechanisms (such as
      ensuring that sequence numbers are in-window) will provide the same
      level of protection against attacks on individual TCP subflows as the
      level of protection that exists for regular TCP today. Implementations will introduce additional buffers compared to regular TCP, to reassemble data at the connection level. The application of window sizing will minimize the risk of denial-of-service attacks consuming resources.<a class="pilcrow" href="#section-5-7">¶</a></p>
<p id="section-5-8">As discussed in <a class="xref" href="#sec_add_address">Section 3.4.1</a>, a host may advertise its private addresses, but these might point to different hosts in the receiver's network. The MP_JOIN handshake (<a class="xref" href="#sec_join">Section 3.2</a>) will ensure that this does not succeed in setting up a subflow to the incorrect host. However, it could still create unwanted TCP handshake traffic. This feature of MPTCP could be a target for denial-of-service exploits, with malicious participants in MPTCP connections encouraging the recipient to target other hosts in the network. Therefore, implementations should consider heuristics (<a class="xref" href="#heuristics">Section 3.9</a>) at both the sender and receiver to reduce the impact of this.<a class="pilcrow" href="#section-5-8">¶</a></p>
<p id="section-5-9">To further protect against malicious ADD_ADDR messages sent by an off-path attacker, the ADD_ADDR includes an HMAC using the keys negotiated during the handshake. This effectively prevents an attacker from diverting an MPTCP connection through an off-path ADD_ADDR injection into the stream.<a class="pilcrow" href="#section-5-9">¶</a></p>
<p id="section-5-10">A small security risk could theoretically exist with key reuse, but in order to accomplish a replay attack, both the sender and receiver keys, and the sender and receiver random numbers, in the MP_JOIN handshake (<a class="xref" href="#sec_join">Section 3.2</a>) would have to match.<a class="pilcrow" href="#section-5-10">¶</a></p>
<p id="section-5-11">While this specification defines a "medium" security solution,
      meeting the criteria specified at the start of this section and in the
      threat analysis document <span>[<a class="xref" href="#RFC6181">RFC6181</a>]</span>, since attacks
      only ever get worse, it is likely that a future version of MPTCP would
      need to be able to support stronger security.
 There are several ways the security of MPTCP could potentially be improved; some of these would be compatible with MPTCP as defined in this document, while others may not be. For now, the best approach is to gain experience with the current approach, establish what might work, and check that the threat analysis is still accurate.<a class="pilcrow" href="#section-5-11">¶</a></p>
<p id="section-5-12">Possible ways of improving MPTCP security could include:<a class="pilcrow" href="#section-5-12">¶</a></p>
<ul>
<li id="section-5-13.1">defining a new MPTCP cryptographic algorithm, as negotiated in
        MP_CAPABLE. If an implementation was being deployed in a controlled
        environment where additional assumptions could be made, such as the
        ability for the servers to store state during the TCP handshake, then
        it may be possible to use a stronger cryptographic algorithm than
        would otherwise be possible.<a class="pilcrow" href="#section-5-13.1">¶</a>
</li>
<li id="section-5-13.2">defining how to secure data transfer with MPTCP, while not changing the signaling part of the protocol.<a class="pilcrow" href="#section-5-13.2">¶</a>
</li>
<li id="section-5-13.3">defining security that requires more option space, perhaps in
        conjunction with a "long options" proposal for extending the TCP
        option space (such as those surveyed in <span>[<a class="xref" href="#I-D.ananth-tcpm-tcpoptext">TCPLO</a>]</span>), or perhaps
        building on the current approach with a second stage of
security based on MPTCP options.<a class="pilcrow" href="#section-5-13.3">¶</a>
</li>
<li id="section-5-13.4">revisiting the working group's decision to exclusively use TCP
    options for MPTCP signaling and instead looking at the
    possibility of using TCP payloads as well.<a class="pilcrow" href="#section-5-13.4">¶</a>
</li>
</ul>
<p id="section-5-14">MPTCP has been designed with several methods available to indicate a new security mechanism, including:<a class="pilcrow" href="#section-5-14">¶</a></p>
<ul>
<li id="section-5-15.1">available flags in MP_CAPABLE (<a class="xref" href="#tcpm_capable">Figure 4</a>).<a class="pilcrow" href="#section-5-15.1">¶</a>
</li>
<li id="section-5-15.2">available subtypes in the MPTCP option (<a class="xref" href="#fig_option">Figure 3</a>).<a class="pilcrow" href="#section-5-15.2">¶</a>
</li>
<li id="section-5-15.3">the Version field in MP_CAPABLE (<a class="xref" href="#tcpm_capable">Figure 4</a>).<a class="pilcrow" href="#section-5-15.3">¶</a>
</li>
</ul>
</section>
</div>
<div id="sec_middleboxes">
<section id="section-6">
      <h2 id="name-interactions-with-middlebox">
<a class="section-number selfRef" href="#section-6">6. </a><a class="section-name selfRef" href="#name-interactions-with-middlebox">Interactions with Middleboxes</a>
      </h2>
<p id="section-6-1">Multipath TCP was designed to be deployable in the present world. Its design takes into account "reasonable"
existing middlebox behavior. In this section, we outline a few representative middlebox-related failure scenarios and 
show how Multipath TCP handles them. Next, we list the design decisions
Multipath TCP has made to accommodate the different 
middleboxes.<a class="pilcrow" href="#section-6-1">¶</a></p>
<p id="section-6-2">A primary concern is our use of a new TCP option. Middleboxes should forward packets
with unknown options unchanged, yet there are some that don't. We expect these
middleboxes to strip options and pass the data, 
drop packets with new options, copy the same option into multiple segments (e.g., when doing segmentation), or drop 
options during segment coalescing.<a class="pilcrow" href="#section-6-2">¶</a></p>
<p id="section-6-3">MPTCP uses a single new TCP option called "Kind", and all message types are defined by "subtype" values (see <a class="xref" href="#IANA">Section 7</a>). This should reduce the chances of only some types of MPTCP options being passed; instead, the key differing characteristics are different paths and the presence of the SYN flag.<a class="pilcrow" href="#section-6-3">¶</a></p>
<p id="section-6-4">MPTCP SYN packets on the first subflow of a connection contain the MP_CAPABLE option (<a class="xref" href="#sec_init">Section 3.1</a>). If this is dropped, MPTCP <span class="bcp14">SHOULD</span> fall back to regular TCP. If packets with the MP_JOIN option (<a class="xref" href="#sec_join">Section 3.2</a>) are dropped, the paths will simply not be used.<a class="pilcrow" href="#section-6-4">¶</a></p>
<p id="section-6-5">If a middlebox strips options but otherwise passes the packets
      unchanged, MPTCP will behave safely. If an MP_CAPABLE option is dropped
      on either the outgoing path or the return path, the initiating host can
      fall back to regular TCP, as illustrated in <a class="xref" href="#fig_syn">Figure 17</a> and discussed in <a class="xref" href="#sec_init">Section 3.1</a>.<a class="pilcrow" href="#section-6-5">¶</a></p>
<span id="name-connection-setup-with-middl"></span><div id="fig_syn">
<figure id="figure-17">
        <div class="artwork art-text alignLeft" id="section-6-6.1">
<pre>             Host A                              Host B
               |              Middlebox M            |
               |                   |                 |
               | SYN (MP_CAPABLE)  |        SYN      |
               |-------------------|----------------&gt;|
               |                SYN/ACK              |
               |&lt;------------------------------------|
           a) MP_CAPABLE option stripped on outgoing path

             Host A                                Host B
               |           SYN (MP_CAPABLE)            |
               |--------------------------------------&gt;|
               |             Middlebox M               |
               |                  |                    |
               |    SYN/ACK       |SYN/ACK (MP_CAPABLE)|
               |&lt;-----------------|--------------------|
           b) MP_CAPABLE option stripped on return path</pre>
</div>
<figcaption><a class="selfRef" href="#figure-17">Figure 17</a>:
<a class="selfRef" href="#name-connection-setup-with-middl">Connection Setup with Middleboxes That Strip Options from Packets</a>
        </figcaption></figure>
</div>
<p id="section-6-7">Subflow SYNs contain the MP_JOIN option. If this option is stripped on the outgoing path, 
the SYN will appear to be a regular SYN to Host B.  Depending on whether there is a listening socket on 
the target port, Host B will reply with either a SYN/ACK or a RST (subflow connection fails). When Host A 
receives the SYN/ACK, it sends a RST because the SYN/ACK does not contain the MP_JOIN option and its token. 
Either way, the subflow setup fails but otherwise does not affect the MPTCP connection as a whole.<a class="pilcrow" href="#section-6-7">¶</a></p>
<p id="section-6-8">We now examine data flow with MPTCP, assuming that the flow is
      correctly set up, which implies that the options in the SYN
packets were allowed through by the relevant middleboxes. If options are allowed through and there is no resegmentation or 
coalescing to TCP segments, Multipath TCP flows can proceed without problems.<a class="pilcrow" href="#section-6-8">¶</a></p>
<p id="section-6-9">The case when options get stripped on data packets is discussed
      in <a class="xref" href="#sec_fallback">Section 3.7</a>.
        If only some MPTCP options are stripped, behavior is not deterministic. If some Data Sequence Mappings are lost, the connection can continue so long as mappings exist for the subflow-level data (e.g., if multiple maps have been sent that reinforce each other). If some subflow-level space is left unmapped, however, the subflow is treated as broken and is closed, using the process described in <a class="xref" href="#sec_fallback">Section 3.7</a>. MPTCP should survive with a loss of some Data ACKs, but performance will degrade as the fraction of stripped options increases.
We do not expect such cases to appear in practice, though: most 
middleboxes will either strip all options or let them all through.<a class="pilcrow" href="#section-6-9">¶</a></p>
<p id="section-6-10">We end this section with a list of middlebox classes, their behavior, and the elements in the MPTCP design
that allow operation through such middleboxes. Issues surrounding dropping packets with options
or stripping options were discussed above and are not included here:<a class="pilcrow" href="#section-6-10">¶</a></p>
<ul>
<li id="section-6-11.1">NATs (Network Address (and port) Translators) <span>[<a class="xref" href="#RFC3022">RFC3022</a>]</span> change the source address (and
        often the source port) of packets. This means that a host will not know its
    public-facing address for signaling in MPTCP. Therefore, MPTCP permits implicit address addition via the MP_JOIN option,
    and the handshake mechanism ensures that connection attempts to private addresses <span>[<a class="xref" href="#RFC1918">RFC1918</a>]</span>, since they are authenticated, will only set up subflows to the correct hosts.
    Explicit address removal is undertaken by an Address ID to allow no knowledge of the source address.<a class="pilcrow" href="#section-6-11.1">¶</a>
</li>
<li id="section-6-11.2">Performance Enhancing Proxies (PEPs) <span>[<a class="xref" href="#RFC3135">RFC3135</a>]</span> might proactively ACK data to increase performance. MPTCP, however, relies on accurate congestion control signals from the end host, and non‑MPTCP-aware PEPs will not be able to provide such signals. MPTCP will, therefore, fall back to single-path TCP or close the problematic subflow (see <a class="xref" href="#sec_fallback">Section 3.7</a>).<a class="pilcrow" href="#section-6-11.2">¶</a>
</li>
<li id="section-6-11.3">Traffic normalizers <span>[<a class="xref" href="#norm">norm</a>]</span> may not
        allow holes in sequence numbers, and they may cache packets and retransmit the same data.
MPTCP looks like standard TCP on the wire and will not retransmit different data on the same subflow sequence number. In the event of a retransmission, the same data will be retransmitted on the original TCP subflow even if it is additionally retransmitted at the connection level on a different subflow.<a class="pilcrow" href="#section-6-11.3">¶</a>
</li>
<li id="section-6-11.4">Firewalls <span>[<a class="xref" href="#RFC2979">RFC2979</a>]</span> might perform
        Initial Sequence Number (ISN) randomization on TCP connections. MPTCP uses relative 
sequence numbers in Data Sequence Mappings to cope with this. Like NATs, firewalls will not permit many incoming connections, so
MPTCP supports address signaling (ADD_ADDR) so that a multiaddressed host can invite its peer behind the firewall/NAT to connect 
out to its additional interface.<a class="pilcrow" href="#section-6-11.4">¶</a>
</li>
<li id="section-6-11.5">Intrusion Detection Systems / Intrusion Prevention Systems (IDSs⁠/IPSs) observe packet streams for patterns and content that could threaten a network. MPTCP may require the
instrumentation of additional paths, and an MPTCP-aware IDS or IPS would need to read MPTCP tokens to correlate data from multiple subflows to maintain comparable visibility into all of the traffic between devices. Without such changes, an IDS would get an incomplete view of the traffic, increasing the risk of missing traffic of interest (false negatives) and increasing the chances of erroneously identifying a subflow as a risk due to only seeing partial data (false positives).<a class="pilcrow" href="#section-6-11.5">¶</a>
</li>
<li id="section-6-11.6">Application-level middleboxes such as content-aware firewalls may
        alter the payload within a subflow -- for example, rewriting URIs in
        HTTP traffic. MPTCP will detect such changes using the checksum
and close the affected subflow(s), if there are other subflows that can be used. If all subflows are affected, MPTCP
will fall back to TCP, allowing such middleboxes to change the payload. MPTCP-aware middleboxes should be able to adjust the payload and MPTCP metadata in order not to break the connection.<a class="pilcrow" href="#section-6-11.6">¶</a>
</li>
</ul>
<p id="section-6-12">

        In addition, all classes of middleboxes may affect TCP traffic in the following ways:<a class="pilcrow" href="#section-6-12">¶</a></p>
<ul>
<li id="section-6-13.1">TCP options may be removed, or packets with unknown options dropped, by many classes of middleboxes. It is intended
that the initial SYN exchange, with a TCP option, will be sufficient to identify the path's capabilities. If such a packet does
not get through, MPTCP will end up falling back to regular TCP.<a class="pilcrow" href="#section-6-13.1">¶</a>
</li>
<li id="section-6-13.2">Segmentation/coalescing (e.g., TCP segmentation offloading) might copy options between packets and might
strip some options. MPTCP's Data Sequence Mapping includes the relative subflow sequence number instead of using the sequence
number in the segment. In this way, the mapping is independent of the packets that carry it.<a class="pilcrow" href="#section-6-13.2">¶</a>
</li>
<li id="section-6-13.3">The receive window may be shrunk by some middleboxes at the
        subflow level. MPTCP will use the maximum window at the data level but will also obey
subflow-specific windows.<a class="pilcrow" href="#section-6-13.3">¶</a>
</li>
</ul>
</section>
</div>
<div id="IANA">
<section id="section-7">
      <h2 id="name-iana-considerations">
<a class="section-number selfRef" href="#section-7">7. </a><a class="section-name selfRef" href="#name-iana-considerations">IANA Considerations</a>
      </h2>
<p id="section-7-1">This document obsoletes <span>[<a class="xref" href="#RFC6824">RFC6824</a>]</span>. As such, IANA has updated
      several registries to point to this document. In addition, this document
      creates one new registry.  These topics are described in the following subsections.<a class="pilcrow" href="#section-7-1">¶</a></p>
<div id="IANA-TCP-Option-Kind">
<section id="section-7.1">
        <h3 id="name-tcp-option-kind-numbers">
<a class="section-number selfRef" href="#section-7.1">7.1. </a><a class="section-name selfRef" href="#name-tcp-option-kind-numbers">TCP Option Kind Numbers</a>
        </h3>
<p id="section-7.1-1">IANA has
      updated the "TCP Option Kind Numbers" registry to point to this document
      for Multipath TCP, as shown in <a class="xref" href="#table_tcpo">Table 1</a>:<a class="pilcrow" href="#section-7.1-1">¶</a></p>
<span id="name-tcp-option-kind-numbers-2"></span><div id="table_tcpo">
<table class="center" id="table-1">
          <caption>
<a class="selfRef" href="#table-1">Table 1</a>:
<a class="selfRef" href="#name-tcp-option-kind-numbers-2">TCP Option Kind Numbers</a>
          </caption>
<thead>
            <tr>
              <th class="text-center" colspan="1" rowspan="1">Kind</th>
              <th class="text-center" colspan="1" rowspan="1">Length</th>
              <th class="text-center" colspan="1" rowspan="1">Meaning</th>
              <th class="text-center" colspan="1" rowspan="1">Reference</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td class="text-center" colspan="1" rowspan="1">30</td>
              <td class="text-center" colspan="1" rowspan="1">N</td>
              <td class="text-center" colspan="1" rowspan="1">Multipath TCP (MPTCP)</td>
              <td class="text-center" colspan="1" rowspan="1">RFC 8684</td>
            </tr>
          </tbody>
        </table>
</div>
</section>
</div>
<div id="IANA_subtypes">
<section id="section-7.2">
        <h3 id="name-mptcp-option-subtypes">
<a class="section-number selfRef" href="#section-7.2">7.2. </a><a class="section-name selfRef" href="#name-mptcp-option-subtypes">MPTCP Option Subtypes</a>
        </h3>
<p id="section-7.2-1">The 4-bit MPTCP subtype in the "MPTCP Option Subtypes"
        subregistry under the "Transmission Control Protocol (TCP) Parameters"
        registry was defined in <span>[<a class="xref" href="#RFC6824">RFC6824</a>]</span>. Since <span>[<a class="xref" href="#RFC6824">RFC6824</a>]</span> is an
        Experimental RFC and not a Standards Track RFC, and since no further
        entries have occurred beyond those pointing to <span>[<a class="xref" href="#RFC6824">RFC6824</a>]</span>, IANA has
        replaced the existing registry with the contents of
        <a class="xref" href="#table_iana">Table 2</a> and with the following
        explanatory note.<a class="pilcrow" href="#section-7.2-1">¶</a></p>
<p id="section-7.2-2">Note: This registry specifies the MPTCP Option Subtypes for MPTCP v1, which obsoletes the Experimental MPTCP v0. For the MPTCP v0 subtypes, please refer to <span>[<a class="xref" href="#RFC6824">RFC6824</a>]</span>.<a class="pilcrow" href="#section-7.2-2">¶</a></p>
<span id="name-mptcp-option-subtypes-2"></span><div id="table_iana">
<table class="center" id="table-2">
          <caption>
<a class="selfRef" href="#table-2">Table 2</a>:
<a class="selfRef" href="#name-mptcp-option-subtypes-2">MPTCP Option Subtypes</a>
          </caption>
<thead>
            <tr>
              <th class="text-center" colspan="1" rowspan="1">Value</th>
              <th class="text-center" colspan="1" rowspan="1">Symbol</th>
              <th class="text-center" colspan="1" rowspan="1">Name</th>
              <th class="text-center" colspan="1" rowspan="1">Reference</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td class="text-center" colspan="1" rowspan="1">0x0</td>
              <td class="text-center" colspan="1" rowspan="1">MP_CAPABLE</td>
              <td class="text-center" colspan="1" rowspan="1">Multipath Capable</td>
              <td class="text-center" colspan="1" rowspan="1">RFC 8684, <a class="xref" href="#sec_init">Section 3.1</a>
</td>
            </tr>
            <tr>
              <td class="text-center" colspan="1" rowspan="1">0x1</td>
              <td class="text-center" colspan="1" rowspan="1">MP_JOIN</td>
              <td class="text-center" colspan="1" rowspan="1">Join Connection</td>
              <td class="text-center" colspan="1" rowspan="1">RFC 8684, <a class="xref" href="#sec_join">Section 3.2</a>
</td>
            </tr>
            <tr>
              <td class="text-center" colspan="1" rowspan="1">0x2</td>
              <td class="text-center" colspan="1" rowspan="1">DSS</td>
              <td class="text-center" colspan="1" rowspan="1">Data Sequence Signal (Data ACK and Data Sequence Mapping)</td>
              <td class="text-center" colspan="1" rowspan="1">RFC 8684, <a class="xref" href="#sec_generalop">Section 3.3</a>
</td>
            </tr>
            <tr>
              <td class="text-center" colspan="1" rowspan="1">0x3</td>
              <td class="text-center" colspan="1" rowspan="1">ADD_ADDR</td>
              <td class="text-center" colspan="1" rowspan="1">Add Address</td>
              <td class="text-center" colspan="1" rowspan="1">RFC 8684, <a class="xref" href="#sec_add_address">Section 3.4.1</a>
</td>
            </tr>
            <tr>
              <td class="text-center" colspan="1" rowspan="1">0x4</td>
              <td class="text-center" colspan="1" rowspan="1">REMOVE_ADDR</td>
              <td class="text-center" colspan="1" rowspan="1">Remove Address</td>
              <td class="text-center" colspan="1" rowspan="1">RFC 8684, <a class="xref" href="#sec_remove_addr">Section 3.4.2</a>
</td>
            </tr>
            <tr>
              <td class="text-center" colspan="1" rowspan="1">0x5</td>
              <td class="text-center" colspan="1" rowspan="1">MP_PRIO</td>
              <td class="text-center" colspan="1" rowspan="1">Change Subflow Priority</td>
              <td class="text-center" colspan="1" rowspan="1">RFC 8684, <a class="xref" href="#sec_policy">Section 3.3.8</a>
</td>
            </tr>
            <tr>
              <td class="text-center" colspan="1" rowspan="1">0x6</td>
              <td class="text-center" colspan="1" rowspan="1">MP_FAIL</td>
              <td class="text-center" colspan="1" rowspan="1">Fallback</td>
              <td class="text-center" colspan="1" rowspan="1">RFC 8684, <a class="xref" href="#sec_fallback">Section 3.7</a>
</td>
            </tr>
            <tr>
              <td class="text-center" colspan="1" rowspan="1">0x7</td>
              <td class="text-center" colspan="1" rowspan="1">MP_FASTCLOSE</td>
              <td class="text-center" colspan="1" rowspan="1">Fast Close</td>
              <td class="text-center" colspan="1" rowspan="1">RFC 8684, <a class="xref" href="#sec_fastclose">Section 3.5</a>
</td>
            </tr>
            <tr>
              <td class="text-center" colspan="1" rowspan="1">0x8</td>
              <td class="text-center" colspan="1" rowspan="1">MP_TCPRST</td>
              <td class="text-center" colspan="1" rowspan="1">Subflow Reset</td>
              <td class="text-center" colspan="1" rowspan="1">RFC 8684, <a class="xref" href="#sec_reset">Section 3.6</a>
</td>
            </tr>
            <tr>
              <td class="text-center" colspan="1" rowspan="1">0xf</td>
              <td class="text-center" colspan="1" rowspan="1">MP_EXPERIMENTAL</td>
              <td class="text-center" colspan="1" rowspan="1">Reserved for Private Use</td>
              <td class="text-center" colspan="1" rowspan="1"></td>
            </tr>
          </tbody>
        </table>
</div>
<p id="section-7.2-4">Values 0x9 through 0xe are currently unassigned. Option 0xf is reserved for use by private experiments. Its use may be formalized in a future specification. Future assignments in this registry are to be defined by Standards Action as defined by <span>[<a class="xref" href="#RFC8126">RFC8126</a>]</span>.  Assignments consist of the MPTCP subtype's symbolic name, its associated value, and a reference to its specification.<a class="pilcrow" href="#section-7.2-4">¶</a></p>
</section>
</div>
<div id="IANA_handshake">
<section id="section-7.3">
        <h3 id="name-mptcp-handshake-algorithms">
<a class="section-number selfRef" href="#section-7.3">7.3. </a><a class="section-name selfRef" href="#name-mptcp-handshake-algorithms">MPTCP Handshake Algorithms</a>
        </h3>
<p id="section-7.3-1">The "MPTCP Handshake Algorithms" subregistry under the
        "Transmission Control Protocol (TCP) Parameters" registry was defined
        in <span>[<a class="xref" href="#RFC6824">RFC6824</a>]</span>. Since <span>[<a class="xref" href="#RFC6824">RFC6824</a>]</span> is an Experimental RFC and not
        a Standards Track RFC, and since no further entries have occurred
        beyond those pointing to <span>[<a class="xref" href="#RFC6824">RFC6824</a>]</span>, IANA has replaced
        the existing registry with the contents of
 <a class="xref" href="#table_crypto">Table 3</a> and with the following explanatory note.<a class="pilcrow" href="#section-7.3-1">¶</a></p>
<p id="section-7.3-2">Note: This registry specifies the MPTCP Handshake Algorithms for MPTCP v1, which obsoletes the Experimental MPTCP v0. For the MPTCP v0 subtypes, please refer to <span>[<a class="xref" href="#RFC6824">RFC6824</a>]</span>.<a class="pilcrow" href="#section-7.3-2">¶</a></p>
<span id="name-mptcp-handshake-algorithms-2"></span><div id="table_crypto">
<table class="center" id="table-3">
          <caption>
<a class="selfRef" href="#table-3">Table 3</a>:
<a class="selfRef" href="#name-mptcp-handshake-algorithms-2">MPTCP Handshake Algorithms</a>
          </caption>
<thead>
            <tr>
              <th class="text-center" colspan="1" rowspan="1">Flag Bit</th>
              <th class="text-center" colspan="1" rowspan="1">Meaning</th>
              <th class="text-center" colspan="1" rowspan="1">Reference</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td class="text-center" colspan="1" rowspan="1">A</td>
              <td class="text-center" colspan="1" rowspan="1">Checksum required</td>
              <td class="text-center" colspan="1" rowspan="1">RFC 8684, <a class="xref" href="#sec_init">Section 3.1</a>
</td>
            </tr>
            <tr>
              <td class="text-center" colspan="1" rowspan="1">B</td>
              <td class="text-center" colspan="1" rowspan="1">Extensibility</td>
              <td class="text-center" colspan="1" rowspan="1">RFC 8684, <a class="xref" href="#sec_init">Section 3.1</a>
</td>
            </tr>
            <tr>
              <td class="text-center" colspan="1" rowspan="1">C</td>
              <td class="text-center" colspan="1" rowspan="1">Do not attempt to establish new subflows to the source address.</td>
              <td class="text-center" colspan="1" rowspan="1">RFC 8684, <a class="xref" href="#sec_init">Section 3.1</a>
</td>
            </tr>
            <tr>
              <td class="text-center" colspan="1" rowspan="1">D-G</td>
              <td class="text-center" colspan="1" rowspan="1">Unassigned</td>
              <td class="text-center" colspan="1" rowspan="1"></td>
            </tr>
            <tr>
              <td class="text-center" colspan="1" rowspan="1">H</td>
              <td class="text-center" colspan="1" rowspan="1">HMAC-SHA256</td>
              <td class="text-center" colspan="1" rowspan="1">RFC 8684, <a class="xref" href="#sec_join">Section 3.2</a>
</td>
            </tr>
          </tbody>
        </table>
</div>
<p id="section-7.3-4">Note that the meanings of bits "D" through "H" can be dependent upon bit "B",
      depending on how the Extensibility parameter is defined in future specifications; see
      <a class="xref" href="#sec_init">Section 3.1</a> for more information.<a class="pilcrow" href="#section-7.3-4">¶</a></p>
<p id="section-7.3-5">Future assignments in this registry are also
      to be defined by Standards Action as defined by <span>[<a class="xref" href="#RFC8126">RFC8126</a>]</span>.
      Assignments consist of the value of the flags, a symbolic name for the algorithm,
      and a reference to its specification.<a class="pilcrow" href="#section-7.3-5">¶</a></p>
</section>
</div>
<div id="IANA_rst">
<section id="section-7.4">
        <h3 id="name-mp_tcprst-reason-codes">
<a class="section-number selfRef" href="#section-7.4">7.4. </a><a class="section-name selfRef" href="#name-mp_tcprst-reason-codes">MP_TCPRST Reason Codes</a>
        </h3>
<p id="section-7.4-1">IANA has created a further subregistry, "MPTCP MP_TCPRST
        Reason Codes" under the "Transmission Control Protocol (TCP)
        Parameters" registry, based on the reason code in the MP_TCPRST (<a class="xref" href="#sec_reset">Section 3.6</a>) message. Initial values for this registry are given in <a class="xref" href="#table_rstcodes">Table 4</a>; future assignments are to be defined by Specification Required as defined by <span>[<a class="xref" href="#RFC8126">RFC8126</a>]</span>. Assignments consist of the value of the code, a short description of its meaning, and a reference to its specification. The maximum value is 0xff.<a class="pilcrow" href="#section-7.4-1">¶</a></p>
<span id="name-mptcp-mp_tcprst-reason-code"></span><div id="table_rstcodes">
<table class="center" id="table-4">
          <caption>
<a class="selfRef" href="#table-4">Table 4</a>:
<a class="selfRef" href="#name-mptcp-mp_tcprst-reason-code">MPTCP MP_TCPRST Reason Codes</a>
          </caption>
<thead>
            <tr>
              <th class="text-center" colspan="1" rowspan="1">Code</th>
              <th class="text-center" colspan="1" rowspan="1">Meaning</th>
              <th class="text-center" colspan="1" rowspan="1">Reference</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td class="text-center" colspan="1" rowspan="1">0x00</td>
              <td class="text-center" colspan="1" rowspan="1">Unspecified error</td>
              <td class="text-center" colspan="1" rowspan="1">RFC 8684, <a class="xref" href="#sec_reset">Section 3.6</a>
</td>
            </tr>
            <tr>
              <td class="text-center" colspan="1" rowspan="1">0x01</td>
              <td class="text-center" colspan="1" rowspan="1">MPTCP-specific error</td>
              <td class="text-center" colspan="1" rowspan="1">RFC 8684, <a class="xref" href="#sec_reset">Section 3.6</a>
</td>
            </tr>
            <tr>
              <td class="text-center" colspan="1" rowspan="1">0x02</td>
              <td class="text-center" colspan="1" rowspan="1">Lack of resources</td>
              <td class="text-center" colspan="1" rowspan="1">RFC 8684, <a class="xref" href="#sec_reset">Section 3.6</a>
</td>
            </tr>
            <tr>
              <td class="text-center" colspan="1" rowspan="1">0x03</td>
              <td class="text-center" colspan="1" rowspan="1">Administratively prohibited</td>
              <td class="text-center" colspan="1" rowspan="1">RFC 8684, <a class="xref" href="#sec_reset">Section 3.6</a>
</td>
            </tr>
            <tr>
              <td class="text-center" colspan="1" rowspan="1">0x04</td>
              <td class="text-center" colspan="1" rowspan="1">Too much outstanding data</td>
              <td class="text-center" colspan="1" rowspan="1">RFC 8684, <a class="xref" href="#sec_reset">Section 3.6</a>
</td>
            </tr>
            <tr>
              <td class="text-center" colspan="1" rowspan="1">0x05</td>
              <td class="text-center" colspan="1" rowspan="1">Unacceptable performance</td>
              <td class="text-center" colspan="1" rowspan="1">RFC 8684, <a class="xref" href="#sec_reset">Section 3.6</a>
</td>
            </tr>
            <tr>
              <td class="text-center" colspan="1" rowspan="1">0x06</td>
              <td class="text-center" colspan="1" rowspan="1">Middlebox interference</td>
              <td class="text-center" colspan="1" rowspan="1">RFC 8684, <a class="xref" href="#sec_reset">Section 3.6</a>
</td>
            </tr>
          </tbody>
        </table>
</div>
<p id="section-7.4-3">As guidance to the designated expert <span>[<a class="xref" href="#RFC8126">RFC8126</a>]</span>, assignments should not normally be refused unless
        codepoint space is becoming scarce, provided that there is a clear
        distinction from other, already-existing codes and also provided that there is sufficient guidance for implementers both sending and receiving these codes.<a class="pilcrow" href="#section-7.4-3">¶</a></p>
</section>
</div>
</section>
</div>
<section id="section-8">
      <h2 id="name-references">
<a class="section-number selfRef" href="#section-8">8. </a><a class="section-name selfRef" href="#name-references">References</a>
      </h2>
<section id="section-8.1">
        <h3 id="name-normative-references">
<a class="section-number selfRef" href="#section-8.1">8.1. </a><a class="section-name selfRef" href="#name-normative-references">Normative References</a>
        </h3>
<dl class="references">
<dt id="RFC0793">[RFC0793]</dt>
<dd>
<span class="refAuthor">Postel, J.</span>, <span class="refTitle">"Transmission Control Protocol"</span>, <span class="seriesInfo">STD 7</span>, <span class="seriesInfo">RFC 793</span>, <span class="seriesInfo">DOI 10.17487/RFC0793</span>, <time datetime="1981-09">September 1981</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc793">https://www.rfc-editor.org/info/rfc793</a>&gt;</span>. </dd>
<dt id="RFC2104">[RFC2104]</dt>
<dd>
<span class="refAuthor">Krawczyk, H.</span><span class="refAuthor">, Bellare, M.</span><span class="refAuthor">, and R. Canetti</span>, <span class="refTitle">"HMAC: Keyed-Hashing for Message Authentication"</span>, <span class="seriesInfo">RFC 2104</span>, <span class="seriesInfo">DOI 10.17487/RFC2104</span>, <time datetime="1997-02">February 1997</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc2104">https://www.rfc-editor.org/info/rfc2104</a>&gt;</span>. </dd>
<dt id="RFC2119">[RFC2119]</dt>
<dd>
<span class="refAuthor">Bradner, S.</span>, <span class="refTitle">"Key words for use in RFCs to Indicate Requirement Levels"</span>, <span class="seriesInfo">BCP 14</span>, <span class="seriesInfo">RFC 2119</span>, <span class="seriesInfo">DOI 10.17487/RFC2119</span>, <time datetime="1997-03">March 1997</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc2119">https://www.rfc-editor.org/info/rfc2119</a>&gt;</span>. </dd>
<dt id="RFC5961">[RFC5961]</dt>
<dd>
<span class="refAuthor">Ramaiah, A.</span><span class="refAuthor">, Stewart, R.</span><span class="refAuthor">, and M. Dalal</span>, <span class="refTitle">"Improving TCP's Robustness to Blind In-Window Attacks"</span>, <span class="seriesInfo">RFC 5961</span>, <span class="seriesInfo">DOI 10.17487/RFC5961</span>, <time datetime="2010-08">August 2010</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc5961">https://www.rfc-editor.org/info/rfc5961</a>&gt;</span>. </dd>
<dt id="RFC6234">[RFC6234]</dt>
<dd>
<span class="refAuthor">Eastlake 3rd, D.</span><span class="refAuthor"> and T. Hansen</span>, <span class="refTitle">"US Secure Hash Algorithms (SHA and SHA-based HMAC and HKDF)"</span>, <span class="seriesInfo">RFC 6234</span>, <span class="seriesInfo">DOI 10.17487/RFC6234</span>, <time datetime="2011-05">May 2011</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc6234">https://www.rfc-editor.org/info/rfc6234</a>&gt;</span>. </dd>
<dt id="RFC8174">[RFC8174]</dt>
<dd>
<span class="refAuthor">Leiba, B.</span>, <span class="refTitle">"Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words"</span>, <span class="seriesInfo">BCP 14</span>, <span class="seriesInfo">RFC 8174</span>, <span class="seriesInfo">DOI 10.17487/RFC8174</span>, <time datetime="2017-05">May 2017</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc8174">https://www.rfc-editor.org/info/rfc8174</a>&gt;</span>. </dd>
</dl>
</section>
<section id="section-8.2">
        <h3 id="name-informative-references">
<a class="section-number selfRef" href="#section-8.2">8.2. </a><a class="section-name selfRef" href="#name-informative-references">Informative References</a>
        </h3>
<dl class="references">
<dt id="deployments">[deployments]</dt>
<dd>
<span class="refAuthor">Bonaventure, O.</span><span class="refAuthor"> and S. Seo</span>, <span class="refTitle">"Multipath TCP Deployments"</span>, <span class="seriesInfo">IETF Journal 2016</span>, <time datetime="2016-11">November 2016</time>, <span>&lt;<a href="https://www.ietfjournal.org/multipath-tcp-deployments/">https://www.ietfjournal.org/multipath-tcp-deployments/</a>&gt;</span>. </dd>
<dt id="howhard">[howhard]</dt>
<dd>
<span class="refAuthor">Raiciu, C.</span><span class="refAuthor">, Paasch, C.</span><span class="refAuthor">, Barre, S.</span><span class="refAuthor">, Ford, A.</span><span class="refAuthor">, Honda, M.</span><span class="refAuthor">, Duchene, F.</span><span class="refAuthor">, Bonaventure, O.</span><span class="refAuthor">, and M. Handley</span>, <span class="refTitle">"How Hard Can It Be? Designing and Implementing a Deployable Multipath TCP"</span>, <span class="seriesInfo">Usenix Symposium on Networked Systems Design and Implementation 2012</span>, <time datetime="2012-04">April 2012</time>, <span>&lt;<a href="https://www.usenix.org/conference/nsdi12/technical-sessions/presentation/raiciu">https://www.usenix.org/conference/nsdi12/technical-sessions/presentation/raiciu</a>&gt;</span>. </dd>
<dt id="norm">[norm]</dt>
<dd>
<span class="refAuthor">Handley, M.</span><span class="refAuthor">, Paxson, V.</span><span class="refAuthor">, and C. Kreibich</span>, <span class="refTitle">"Network Intrusion Detection: Evasion, Traffic Normalization, and End-to-End Protocol Semantics"</span>, <span class="seriesInfo">Usenix Security Symposium 2001</span>, <time datetime="2001-08">August 2001</time>, <span>&lt;<a href="https://www.usenix.org/legacy/events/sec01/full_papers/handley/handley.pdf">https://www.usenix.org/legacy/events/sec01/full_papers/handley/handley.pdf</a>&gt;</span>. </dd>
<dt id="RFC1122">[RFC1122]</dt>
<dd>
<span class="refAuthor">Braden, R., Ed.</span>, <span class="refTitle">"Requirements for Internet Hosts - Communication Layers"</span>, <span class="seriesInfo">STD 3</span>, <span class="seriesInfo">RFC 1122</span>, <span class="seriesInfo">DOI 10.17487/RFC1122</span>, <time datetime="1989-10">October 1989</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc1122">https://www.rfc-editor.org/info/rfc1122</a>&gt;</span>. </dd>
<dt id="RFC1918">[RFC1918]</dt>
<dd>
<span class="refAuthor">Rekhter, Y.</span><span class="refAuthor">, Moskowitz, B.</span><span class="refAuthor">, Karrenberg, D.</span><span class="refAuthor">, de Groot, G. J.</span><span class="refAuthor">, and E. Lear</span>, <span class="refTitle">"Address Allocation for Private Internets"</span>, <span class="seriesInfo">BCP 5</span>, <span class="seriesInfo">RFC 1918</span>, <span class="seriesInfo">DOI 10.17487/RFC1918</span>, <time datetime="1996-02">February 1996</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc1918">https://www.rfc-editor.org/info/rfc1918</a>&gt;</span>. </dd>
<dt id="RFC2018">[RFC2018]</dt>
<dd>
<span class="refAuthor">Mathis, M.</span><span class="refAuthor">, Mahdavi, J.</span><span class="refAuthor">, Floyd, S.</span><span class="refAuthor">, and A. Romanow</span>, <span class="refTitle">"TCP Selective Acknowledgment Options"</span>, <span class="seriesInfo">RFC 2018</span>, <span class="seriesInfo">DOI 10.17487/RFC2018</span>, <time datetime="1996-10">October 1996</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc2018">https://www.rfc-editor.org/info/rfc2018</a>&gt;</span>. </dd>
<dt id="RFC2979">[RFC2979]</dt>
<dd>
<span class="refAuthor">Freed, N.</span>, <span class="refTitle">"Behavior of and Requirements for Internet Firewalls"</span>, <span class="seriesInfo">RFC 2979</span>, <span class="seriesInfo">DOI 10.17487/RFC2979</span>, <time datetime="2000-10">October 2000</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc2979">https://www.rfc-editor.org/info/rfc2979</a>&gt;</span>. </dd>
<dt id="RFC2992">[RFC2992]</dt>
<dd>
<span class="refAuthor">Hopps, C.</span>, <span class="refTitle">"Analysis of an Equal-Cost Multi-Path Algorithm"</span>, <span class="seriesInfo">RFC 2992</span>, <span class="seriesInfo">DOI 10.17487/RFC2992</span>, <time datetime="2000-11">November 2000</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc2992">https://www.rfc-editor.org/info/rfc2992</a>&gt;</span>. </dd>
<dt id="RFC3022">[RFC3022]</dt>
<dd>
<span class="refAuthor">Srisuresh, P.</span><span class="refAuthor"> and K. Egevang</span>, <span class="refTitle">"Traditional IP Network Address Translator (Traditional NAT)"</span>, <span class="seriesInfo">RFC 3022</span>, <span class="seriesInfo">DOI 10.17487/RFC3022</span>, <time datetime="2001-01">January 2001</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc3022">https://www.rfc-editor.org/info/rfc3022</a>&gt;</span>. </dd>
<dt id="RFC3135">[RFC3135]</dt>
<dd>
<span class="refAuthor">Border, J.</span><span class="refAuthor">, Kojo, M.</span><span class="refAuthor">, Griner, J.</span><span class="refAuthor">, Montenegro, G.</span><span class="refAuthor">, and Z. Shelby</span>, <span class="refTitle">"Performance Enhancing Proxies Intended to Mitigate Link-Related Degradations"</span>, <span class="seriesInfo">RFC 3135</span>, <span class="seriesInfo">DOI 10.17487/RFC3135</span>, <time datetime="2001-06">June 2001</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc3135">https://www.rfc-editor.org/info/rfc3135</a>&gt;</span>. </dd>
<dt id="RFC4086">[RFC4086]</dt>
<dd>
<span class="refAuthor">Eastlake 3rd, D.</span><span class="refAuthor">, Schiller, J.</span><span class="refAuthor">, and S. Crocker</span>, <span class="refTitle">"Randomness Requirements for Security"</span>, <span class="seriesInfo">BCP 106</span>, <span class="seriesInfo">RFC 4086</span>, <span class="seriesInfo">DOI 10.17487/RFC4086</span>, <time datetime="2005-06">June 2005</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc4086">https://www.rfc-editor.org/info/rfc4086</a>&gt;</span>. </dd>
<dt id="RFC4987">[RFC4987]</dt>
<dd>
<span class="refAuthor">Eddy, W.</span>, <span class="refTitle">"TCP SYN Flooding Attacks and Common Mitigations"</span>, <span class="seriesInfo">RFC 4987</span>, <span class="seriesInfo">DOI 10.17487/RFC4987</span>, <time datetime="2007-08">August 2007</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc4987">https://www.rfc-editor.org/info/rfc4987</a>&gt;</span>. </dd>
<dt id="RFC5681">[RFC5681]</dt>
<dd>
<span class="refAuthor">Allman, M.</span><span class="refAuthor">, Paxson, V.</span><span class="refAuthor">, and E. Blanton</span>, <span class="refTitle">"TCP Congestion Control"</span>, <span class="seriesInfo">RFC 5681</span>, <span class="seriesInfo">DOI 10.17487/RFC5681</span>, <time datetime="2009-09">September 2009</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc5681">https://www.rfc-editor.org/info/rfc5681</a>&gt;</span>. </dd>
<dt id="RFC6181">[RFC6181]</dt>
<dd>
<span class="refAuthor">Bagnulo, M.</span>, <span class="refTitle">"Threat Analysis for TCP Extensions for Multipath Operation with Multiple Addresses"</span>, <span class="seriesInfo">RFC 6181</span>, <span class="seriesInfo">DOI 10.17487/RFC6181</span>, <time datetime="2011-03">March 2011</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc6181">https://www.rfc-editor.org/info/rfc6181</a>&gt;</span>. </dd>
<dt id="RFC6182">[RFC6182]</dt>
<dd>
<span class="refAuthor">Ford, A.</span><span class="refAuthor">, Raiciu, C.</span><span class="refAuthor">, Handley, M.</span><span class="refAuthor">, Barre, S.</span><span class="refAuthor">, and J. Iyengar</span>, <span class="refTitle">"Architectural Guidelines for Multipath TCP Development"</span>, <span class="seriesInfo">RFC 6182</span>, <span class="seriesInfo">DOI 10.17487/RFC6182</span>, <time datetime="2011-03">March 2011</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc6182">https://www.rfc-editor.org/info/rfc6182</a>&gt;</span>. </dd>
<dt id="RFC6356">[RFC6356]</dt>
<dd>
<span class="refAuthor">Raiciu, C.</span><span class="refAuthor">, Handley, M.</span><span class="refAuthor">, and D. Wischik</span>, <span class="refTitle">"Coupled Congestion Control for Multipath Transport Protocols"</span>, <span class="seriesInfo">RFC 6356</span>, <span class="seriesInfo">DOI 10.17487/RFC6356</span>, <time datetime="2011-10">October 2011</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc6356">https://www.rfc-editor.org/info/rfc6356</a>&gt;</span>. </dd>
<dt id="RFC6528">[RFC6528]</dt>
<dd>
<span class="refAuthor">Gont, F.</span><span class="refAuthor"> and S. Bellovin</span>, <span class="refTitle">"Defending against Sequence Number Attacks"</span>, <span class="seriesInfo">RFC 6528</span>, <span class="seriesInfo">DOI 10.17487/RFC6528</span>, <time datetime="2012-02">February 2012</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc6528">https://www.rfc-editor.org/info/rfc6528</a>&gt;</span>. </dd>
<dt id="RFC6824">[RFC6824]</dt>
<dd>
<span class="refAuthor">Ford, A.</span><span class="refAuthor">, Raiciu, C.</span><span class="refAuthor">, Handley, M.</span><span class="refAuthor">, and O. Bonaventure</span>, <span class="refTitle">"TCP Extensions for Multipath Operation with Multiple Addresses"</span>, <span class="seriesInfo">RFC 6824</span>, <span class="seriesInfo">DOI 10.17487/RFC6824</span>, <time datetime="2013-01">January 2013</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc6824">https://www.rfc-editor.org/info/rfc6824</a>&gt;</span>. </dd>
<dt id="RFC6897">[RFC6897]</dt>
<dd>
<span class="refAuthor">Scharf, M.</span><span class="refAuthor"> and A. Ford</span>, <span class="refTitle">"Multipath TCP (MPTCP) Application Interface Considerations"</span>, <span class="seriesInfo">RFC 6897</span>, <span class="seriesInfo">DOI 10.17487/RFC6897</span>, <time datetime="2013-03">March 2013</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc6897">https://www.rfc-editor.org/info/rfc6897</a>&gt;</span>. </dd>
<dt id="RFC7323">[RFC7323]</dt>
<dd>
<span class="refAuthor">Borman, D.</span><span class="refAuthor">, Braden, B.</span><span class="refAuthor">, Jacobson, V.</span><span class="refAuthor">, and R. Scheffenegger, Ed.</span>, <span class="refTitle">"TCP Extensions for High Performance"</span>, <span class="seriesInfo">RFC 7323</span>, <span class="seriesInfo">DOI 10.17487/RFC7323</span>, <time datetime="2014-09">September 2014</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc7323">https://www.rfc-editor.org/info/rfc7323</a>&gt;</span>. </dd>
<dt id="RFC7413">[RFC7413]</dt>
<dd>
<span class="refAuthor">Cheng, Y.</span><span class="refAuthor">, Chu, J.</span><span class="refAuthor">, Radhakrishnan, S.</span><span class="refAuthor">, and A. Jain</span>, <span class="refTitle">"TCP Fast Open"</span>, <span class="seriesInfo">RFC 7413</span>, <span class="seriesInfo">DOI 10.17487/RFC7413</span>, <time datetime="2014-12">December 2014</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc7413">https://www.rfc-editor.org/info/rfc7413</a>&gt;</span>. </dd>
<dt id="RFC7430">[RFC7430]</dt>
<dd>
<span class="refAuthor">Bagnulo, M.</span><span class="refAuthor">, Paasch, C.</span><span class="refAuthor">, Gont, F.</span><span class="refAuthor">, Bonaventure, O.</span><span class="refAuthor">, and C. Raiciu</span>, <span class="refTitle">"Analysis of Residual Threats and Possible Fixes for Multipath TCP (MPTCP)"</span>, <span class="seriesInfo">RFC 7430</span>, <span class="seriesInfo">DOI 10.17487/RFC7430</span>, <time datetime="2015-07">July 2015</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc7430">https://www.rfc-editor.org/info/rfc7430</a>&gt;</span>. </dd>
<dt id="RFC8041">[RFC8041]</dt>
<dd>
<span class="refAuthor">Bonaventure, O.</span><span class="refAuthor">, Paasch, C.</span><span class="refAuthor">, and G. Detal</span>, <span class="refTitle">"Use Cases and Operational Experience with Multipath TCP"</span>, <span class="seriesInfo">RFC 8041</span>, <span class="seriesInfo">DOI 10.17487/RFC8041</span>, <time datetime="2017-01">January 2017</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc8041">https://www.rfc-editor.org/info/rfc8041</a>&gt;</span>. </dd>
<dt id="RFC8126">[RFC8126]</dt>
<dd>
<span class="refAuthor">Cotton, M.</span><span class="refAuthor">, Leiba, B.</span><span class="refAuthor">, and T. Narten</span>, <span class="refTitle">"Guidelines for Writing an IANA Considerations Section in RFCs"</span>, <span class="seriesInfo">BCP 26</span>, <span class="seriesInfo">RFC 8126</span>, <span class="seriesInfo">DOI 10.17487/RFC8126</span>, <time datetime="2017-06">June 2017</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc8126">https://www.rfc-editor.org/info/rfc8126</a>&gt;</span>. </dd>
<dt id="I-D.ananth-tcpm-tcpoptext">[TCPLO]</dt>
<dd>
<span class="refAuthor">Ramaiah, A.</span>, <span class="refTitle">"TCP option space extension"</span>, <span class="refContent">Work in Progress</span>, <span class="seriesInfo">Internet-Draft, draft-ananth-tcpm-tcpoptext-00</span>, <time datetime="2012-03-26">26 March 2012</time>, <span>&lt;<a href="https://tools.ietf.org/html/draft-ananth-tcpm-tcpoptext-00">https://tools.ietf.org/html/draft-ananth-tcpm-tcpoptext-00</a>&gt;</span>. </dd>
</dl>
</section>
</section>
<div id="app_options">
<section id="section-appendix.a">
      <h2 id="name-notes-on-use-of-tcp-options">
<a class="section-number selfRef" href="#section-appendix.a">Appendix A. </a><a class="section-name selfRef" href="#name-notes-on-use-of-tcp-options">Notes on Use of TCP Options</a>
      </h2>
<p id="section-appendix.a-1">The TCP option space is limited due to the length of the Data Offset field in the TCP header (4 bits), which defines the TCP header length in 32-bit words. With the standard TCP header being 20 bytes, this leaves a maximum of 40 bytes for options, and many of these may already be used by options such as timestamp and SACK.<a class="pilcrow" href="#section-appendix.a-1">¶</a></p>
<p id="section-appendix.a-2">We performed a brief study on the commonly used TCP options in SYN,
 data, and pure ACK packets and found that there is enough room
 to fit all the options discussed in this document.<a class="pilcrow" href="#section-appendix.a-2">¶</a></p>
<p id="section-appendix.a-3">SYN packets typically include the following options: Maximum Segment Size (MSS) (4 bytes),
      window scale (3 bytes), SACK permitted (2 bytes), and timestamp
      (10 bytes). The sum of these options is 19 bytes. Some operating
      systems appear to pad each option up to a word boundary, thus using 24
      bytes (a brief survey suggests that Windows XP and Mac OS X do this, whereas Linux does not).

      Optimistically, therefore, we have 21 bytes available, or 16 if options have to be
      word-aligned. In either case, however, the SYN versions of 
      MP_CAPABLE (12 bytes) and MP_JOIN (12 or 16 bytes) will fit in this remaining space.<a class="pilcrow" href="#section-appendix.a-3">¶</a></p>
<p id="section-appendix.a-4">Note that due to the use of a 64-bit data-level sequence space, it is
      feasible that MPTCP will not require the timestamp option for
      protection against wrapped sequence numbers (per the Protection
      Against Wrapped Sequences (PAWS) mechanism, as described in <span>[<a class="xref" href="#RFC7323">RFC7323</a>]</span>), since the data-level sequence space has far less
      chance of wrapping. Confirmation of the validity of this optimization is
      left for further study.<a class="pilcrow" href="#section-appendix.a-4">¶</a></p>
<p id="section-appendix.a-5">TCP data packets typically carry timestamp options in every packet,
      taking 10 bytes (or 12, with padding). That leaves 30 bytes (or 28, if
      word-aligned). The DSS option varies in length, depending on (1) whether the
      Data Sequence Mapping, DATA_ACK, or both are included, (2) whether the
      sequence numbers in use are 4 or 8 octets, and (3) whether the
      checksum is present. The maximum size of the DSS option is 28 bytes, so even that will fit in the available space. But unless a connection is both bidirectional and high-bandwidth, it is unlikely that all that option space will be required on each DSS option.<a class="pilcrow" href="#section-appendix.a-5">¶</a></p>
<p id="section-appendix.a-6">Within the DSS option, it is not necessary to include the Data Sequence Mapping and DATA_ACK in each packet, and in many cases it may be possible to alternate their presence (so long as the mapping covers the data being sent in the subsequent packet). It would also be possible to alternate between 4-byte and 8-byte sequence numbers in each option.<a class="pilcrow" href="#section-appendix.a-6">¶</a></p>
<p id="section-appendix.a-7">On subflow and connection setup, an MPTCP option is also set on the third packet (an ACK). These are 20 bytes (for MP_CAPABLE) and 24 bytes (for MP_JOIN), both of which will fit in the available option space.<a class="pilcrow" href="#section-appendix.a-7">¶</a></p>
<p id="section-appendix.a-8">Pure ACKs in TCP typically contain only timestamps (10 bytes). Here, Multipath TCP typically 
needs to encode only the DATA_ACK (maximum of 12 bytes). Occasionally, ACKs will contain SACK information. Depending 
on the number of lost packets, SACK may utilize the entire option space. If a DATA_ACK had to be
included, then it is probably necessary to reduce the number of SACK blocks to accommodate the 
DATA_ACK. However, the presence of the DATA_ACK is unlikely to be necessary in a case where SACK is
in use, since until at least some of the SACK blocks have been retransmitted, the cumulative
data-level ACK will not be moving forward (or if it does, due to retransmissions on another path, 
then that path can also be used to transmit the new DATA_ACK).<a class="pilcrow" href="#section-appendix.a-8">¶</a></p>
<p id="section-appendix.a-9">The ADD_ADDR option can be between 16 and 30 bytes, depending on
      (1) whether IPv4 or IPv6 is used and (2) whether or not the port number is
      present. It is unlikely that such signaling would fit in a data packet
      (although if there is space, it is fine to include it). It is
      recommended that duplicate ACKs not be used with any other payload or options, in
      order to transmit these rare signals. Note that this is the reason for
      mandating that duplicate ACKs with MPTCP options not be taken as a signal of congestion.<a class="pilcrow" href="#section-appendix.a-9">¶</a></p>
</section>
</div>
<div id="app_tfo">
<section id="section-appendix.b">
      <h2 id="name-tcp-fast-open-and-mptcp">
<a class="section-number selfRef" href="#section-appendix.b">Appendix B. </a><a class="section-name selfRef" href="#name-tcp-fast-open-and-mptcp">TCP Fast Open and MPTCP</a>
      </h2>
<p id="section-appendix.b-1">TCP Fast Open (TFO) is an experimental TCP extension, described in
      <span>[<a class="xref" href="#RFC7413">RFC7413</a>]</span>, which has been introduced to
      allow the sending of data
      one RTT earlier than with regular TCP. This is
      considered a valuable gain, as very short connections are very common,
      especially for HTTP request/response schemes. It achieves this by sending
      the SYN segment together with the application's data and allowing the listener to reply
      immediately with data after the SYN/ACK. <span>[<a class="xref" href="#RFC7413">RFC7413</a>]</span> secures
      this mechanism by using a new TCP option that includes a cookie that
      is negotiated in a preceding connection.<a class="pilcrow" href="#section-appendix.b-1">¶</a></p>
<p id="section-appendix.b-2">When using TFO in conjunction with MPTCP, there are two key
        points to take into account, as detailed below.<a class="pilcrow" href="#section-appendix.b-2">¶</a></p>
<div id="tfocookie">
<section id="section-b.1">
        <h2 id="name-tfo-cookie-request-with-mpt">
<a class="section-number selfRef" href="#section-b.1">B.1. </a><a class="section-name selfRef" href="#name-tfo-cookie-request-with-mpt">TFO Cookie Request with MPTCP</a>
        </h2>
<p id="section-b.1-1">When a TFO initiator first connects to a listener, it cannot immediately
          include data in the SYN for security reasons <span>[<a class="xref" href="#RFC7413">RFC7413</a>]</span>.
          Instead, it requests a cookie that will be used in subsequent
          connections. This is done with the TCP cookie request/response options,
          of 2 bytes and 6-18 bytes, respectively (depending on the chosen cookie length).<a class="pilcrow" href="#section-b.1-1">¶</a></p>
<p id="section-b.1-2">TFO and MPTCP can be combined, provided that the total length of all the
          options does not exceed the maximum 40 bytes possible in TCP:<a class="pilcrow" href="#section-b.1-2">¶</a></p>
<ul>
<li id="section-b.1-3.1">In the SYN: MPTCP uses a 4-byte MP_CAPABLE option. The sum
          of the MPTCP and TFO options is 6 bytes. With typical TCP options using up
          to 19 bytes in the SYN (24 bytes if options are padded at a word boundary),
          there is enough space to combine the MP_CAPABLE with the TFO cookie request.<a class="pilcrow" href="#section-b.1-3.1">¶</a>
</li>
<li id="section-b.1-3.2">In the SYN + ACK: MPTCP uses a 12-byte MP_CAPABLE option, but
          now the TFO option can be as long as 18 bytes. Since the maximum option length
          may be exceeded, it is up to the listener to avoid this problem by using a
          shorter cookie.
          As an example, if we consider that 19 bytes are used for classical
          TCP options, the maximum possible cookie length would be
          7 bytes. Note that, for the SYN packet, the same limitation applies to subsequent
          connections (because the initiator then echoes
          the cookie back to the listener). Finally, if the security impact of reducing
          the cookie size is not deemed acceptable, the listener can reduce the
          amount of space used by other TCP options by omitting the TCP timestamps (as
          outlined in <a class="xref" href="#app_options">Appendix A</a>).<a class="pilcrow" href="#section-b.1-3.2">¶</a>
</li>
</ul>
</section>
</div>
<div id="tfodata">
<section id="section-b.2">
        <h2 id="name-data-sequence-mapping-under">
<a class="section-number selfRef" href="#section-b.2">B.2. </a><a class="section-name selfRef" href="#name-data-sequence-mapping-under">Data Sequence Mapping under TFO</a>
        </h2>
<p id="section-b.2-1">In the TCP establishment phase, MPTCP uses a key exchange that is
          used to generate the Initial Data Sequence Numbers (IDSNs). In particular,
          the SYN with MP_CAPABLE occupies the first octet of data sequence
          space. With TFO, one way to handle the data sent together with the SYN
          would be to consider an implicit DSS mapping that covers that SYN segment
          (since there is not enough space in the SYN to include a DSS option).
          The problem with that approach is that if a middlebox modifies the TFO
          data, this will not be noticed by MPTCP because of the absence of a
          DSS checksum. For example, a TCP‑aware (but not MPTCP-aware) middlebox could
          insert bytes at the beginning of the stream and adapt the TCP checksum
          and sequence numbers accordingly. With an implicit mapping, this information would
          give to the initiator and listener a different view of the DSS
          mapping; there would be no
          way to detect this inconsistency, because the DSS checksum is not present.<a class="pilcrow" href="#section-b.2-1">¶</a></p>
<p id="section-b.2-2">To solve this issue, the TFO data must not be considered part of the
          data sequence number space: the SYN with MP_CAPABLE still occupies
          the first octet of data sequence space, but then the first non-TFO
          data byte occupies the second octet. This guarantees that, if the
          use of the DSS checksum is negotiated, all data in the data sequence
          number space is checksummed. We also note that this does not entail
          a loss of functionality, because TFO data is always only sent on the
          initial subflow, before any attempt to create additional subflows.<a class="pilcrow" href="#section-b.2-2">¶</a></p>
</section>
</div>
<div id="tfoexamples">
<section id="section-b.3">
        <h2 id="name-connection-establishment-ex">
<a class="section-number selfRef" href="#section-b.3">B.3. </a><a class="section-name selfRef" href="#name-connection-establishment-ex">Connection Establishment Examples</a>
        </h2>
<p id="section-b.3-1">A few examples of possible "TFO + MPTCP"
          establishment scenarios are shown below.<a class="pilcrow" href="#section-b.3-1">¶</a></p>
<p id="section-b.3-2">Before an initiator can send data together with the SYN, it must request
          a cookie from the listener, as shown in <a class="xref" href="#fig_tfocookie">Figure 18</a>.  (Note:  The sequence number 
and length are annotated in <a class="xref" href="#fig_tfocookie">Figure 18</a> as
Seq(Length) (e.g., "S. 0(0)") and used as such in the subsequent figures
        (e.g., "S  0(20)" in <a class="xref" href="#fig_tfodata">Figure 19</a>).) This is done by simply combining the TFO and MPTCP options.<a class="pilcrow" href="#section-b.3-2">¶</a></p>
<span id="name-cookie-request"></span><div id="fig_tfocookie">
<figure id="figure-18">
          <div class="artwork art-text alignLeft" id="section-b.3-3.1">
<pre>initiator                                                    listener
    |                                                           |
    |   S Seq=0(Length=0) &lt;MP_CAPABLE&gt;, &lt;TFO cookie request&gt;    |
    | --------------------------------------------------------&gt; |
    |                                                           |
    |   S. 0(0) ack 1 &lt;MP_CAPABLE&gt;, &lt;TFO cookie&gt;                |
    | &lt;-------------------------------------------------------- |
    |                                                           |
    |   .  0(0) ack 1 &lt;MP_CAPABLE&gt;                              |
    | --------------------------------------------------------&gt; |
    |                                                           |</pre>
</div>
<figcaption><a class="selfRef" href="#figure-18">Figure 18</a>:
<a class="selfRef" href="#name-cookie-request">Cookie Request</a>
          </figcaption></figure>
</div>
<p id="section-b.3-4">Once this is done, the received cookie can be used for TFO, as shown
          in <a class="xref" href="#fig_tfodata">Figure 19</a>. In this example, the initiator first
          sends 20 bytes in the SYN. The listener immediately replies with 100 bytes
          following the SYN-ACK, to which the initiator replies with 20 more bytes.
          Note that the last segment in the figure
          has a TCP sequence number of 21, while the DSS subflow sequence
          number is 1 (because the TFO data is not part of the data sequence
          number space, as explained in <a class="xref" href="#tfodata">Appendix B.2</a>.<a class="pilcrow" href="#section-b.3-4">¶</a></p>
<span id="name-the-listener-supports-tfo"></span><div id="fig_tfodata">
<figure id="figure-19">
          <div class="artwork art-text alignLeft" id="section-b.3-5.1">
<pre>initiator                                                    listener
    |                                                           |
    |    S  0(20) &lt;MP_CAPABLE&gt;, &lt;TFO cookie&gt;                    |
    | --------------------------------------------------------&gt; |
    |                                                           |
    |    S. 0(0) ack 21 &lt;MP_CAPABLE&gt;                            |
    | &lt;-------------------------------------------------------- |
    |                                                           |
    |    .  1(100) ack 21 &lt;DSS ack=1 seq=1 ssn=1 dlen=100&gt;      |
    | &lt;-------------------------------------------------------- |
    |                                                           |
    |    .  21(0) ack 1 &lt;MP_CAPABLE&gt;                            |
    | --------------------------------------------------------&gt; |
    |                                                           |
    |    .  21(20) ack 101 &lt;DSS ack=101 seq=1 ssn=1 dlen=20&gt;    |
    | --------------------------------------------------------&gt; |
    |                                                           |</pre>
</div>
<figcaption><a class="selfRef" href="#figure-19">Figure 19</a>:
<a class="selfRef" href="#name-the-listener-supports-tfo">The Listener Supports TFO</a>
          </figcaption></figure>
</div>
<p id="section-b.3-6">In <a class="xref" href="#fig_tfofallback">Figure 20</a>, the listener does not support TFO.  The initiator detects
          that no state is created in the listener (as no data is ACKed) and now
          sends the MP_CAPABLE in the third packet, in order for the listener to
          build its MPTCP context at the end of the establishment.  Now, the
          TFO data, when retransmitted, becomes part of the Data Sequence Mapping
          because it is effectively sent (in fact re‑sent) after the
          establishment.<a class="pilcrow" href="#section-b.3-6">¶</a></p>
<span id="name-the-listener-does-not-suppo"></span><div id="fig_tfofallback">
<figure id="figure-20">
          <div class="artwork art-text alignLeft" id="section-b.3-7.1">
<pre>initiator                                                    listener
    |                                                           |
    |    S  0(20) &lt;MP_CAPABLE&gt;, &lt;TFO cookie&gt;                    |
    | --------------------------------------------------------&gt; |
    |                                                           |
    |    S. 0(0) ack 1 &lt;MP_CAPABLE&gt;                             |
    | &lt;-------------------------------------------------------- |
    |                                                           |
    |    .  1(0) ack 1 &lt;MP_CAPABLE&gt;                             |
    | --------------------------------------------------------&gt; |
    |                                                           |
    |    .  1(20) ack 1 &lt;DSS ack=1 seq=1 ssn=1 dlen=20&gt;         |
    | --------------------------------------------------------&gt; |
    |                                                           |
    |    .  0(0) ack 21 &lt;DSS ack=21 seq=1 ssn=1 dlen=0&gt;         |
    | &lt;-------------------------------------------------------- |
    |                                                           |</pre>
</div>
<figcaption><a class="selfRef" href="#figure-20">Figure 20</a>:
<a class="selfRef" href="#name-the-listener-does-not-suppo">The Listener Does Not Support TFO</a>
          </figcaption></figure>
</div>
<p id="section-b.3-8">It is also possible that the listener acknowledges only part of the TFO
          data, as illustrated in <a class="xref" href="#fig_tfopartial">Figure 21</a>. The
          initiator will simply retransmit the missing data together with a
 DSS mapping.<a class="pilcrow" href="#section-b.3-8">¶</a></p>
<span id="name-partial-data-acknowledgment"></span><div id="fig_tfopartial">
<figure id="figure-21">
          <div class="artwork art-text alignLeft" id="section-b.3-9.1">
<pre>initiator                                                    listener
    |                                                           |
    |    S  0(1000) &lt;MP_CAPABLE&gt;, &lt;TFO cookie&gt;                  |
    | --------------------------------------------------------&gt; |
    |                                                           |
    |    S. 0(0) ack 501 &lt;MP_CAPABLE&gt;                           |
    | &lt;-------------------------------------------------------- |
    |                                                           |
    |    .  501(0) ack 1 &lt;MP_CAPABLE&gt;                           |
    | --------------------------------------------------------&gt; |
    |                                                           |
    |    .  501(500) ack 1 &lt;DSS ack=1 seq=1 ssn=1 dlen=500&gt;     |
    | --------------------------------------------------------&gt; |
    |                                                           |</pre>
</div>
<figcaption><a class="selfRef" href="#figure-21">Figure 21</a>:
<a class="selfRef" href="#name-partial-data-acknowledgment">Partial Data Acknowledgment</a>
          </figcaption></figure>
</div>
</section>
</div>
</section>
</div>
<div id="app_tcb">
<section id="section-appendix.c">
      <h2 id="name-control-blocks">
<a class="section-number selfRef" href="#section-appendix.c">Appendix C. </a><a class="section-name selfRef" href="#name-control-blocks">Control Blocks</a>
      </h2>
<p id="section-appendix.c-1">Conceptually, an MPTCP connection can be represented as an MPTCP protocol control
block (PCB) that contains several variables that track the progress and the
state of the MPTCP connection and a set of linked TCP control blocks
that correspond to the subflows that have been established.<a class="pilcrow" href="#section-appendix.c-1">¶</a></p>
<p id="section-appendix.c-2">RFC 793 <span>[<a class="xref" href="#RFC0793">RFC0793</a>]</span> specifies several state variables. Whenever possible, we reuse
the same terminology as RFC 793 to describe the state variables that are
maintained by MPTCP.<a class="pilcrow" href="#section-appendix.c-2">¶</a></p>
<section id="section-c.1">
        <h2 id="name-mptcp-control-block">
<a class="section-number selfRef" href="#section-c.1">C.1. </a><a class="section-name selfRef" href="#name-mptcp-control-block">MPTCP Control Block</a>
        </h2>
<p id="section-c.1-1">The MPTCP control block contains the following variables per connection.<a class="pilcrow" href="#section-c.1-1">¶</a></p>
<section id="section-c.1.1">
          <h3 id="name-authentication-and-metadata">
<a class="section-number selfRef" href="#section-c.1.1">C.1.1. </a><a class="section-name selfRef" href="#name-authentication-and-metadata">Authentication and Metadata</a>
          </h3>
<dl class="dlParallel" id="section-c.1.1-1">
            <dt id="section-c.1.1-1.1">Local.Token (32 bits):</dt>
<dd id="section-c.1.1-1.2" style="margin-left: 1.5em"> This is the token chosen by the local host on
this MPTCP connection. The token must be unique among all established
MPTCP connections and is generated from the local key.<a class="pilcrow" href="#section-c.1.1-1.2">¶</a>
</dd>
<dt id="section-c.1.1-1.3">Local.Key (64 bits):</dt>
<dd id="section-c.1.1-1.4" style="margin-left: 1.5em"> This is the key sent by the local host on this
MPTCP connection.<a class="pilcrow" href="#section-c.1.1-1.4">¶</a>
</dd>
<dt id="section-c.1.1-1.5">Remote.Token (32 bits):</dt>
<dd id="section-c.1.1-1.6" style="margin-left: 1.5em"> This is the token chosen by the remote host on
this MPTCP connection, generated from the remote key.<a class="pilcrow" href="#section-c.1.1-1.6">¶</a>
</dd>
<dt id="section-c.1.1-1.7">Remote.Key (64 bits):</dt>
<dd id="section-c.1.1-1.8" style="margin-left: 1.5em"> This is the key chosen by the remote host on
this MPTCP connection.<a class="pilcrow" href="#section-c.1.1-1.8">¶</a>
</dd>
<dt id="section-c.1.1-1.9">MPTCP.Checksum (flag):</dt>
<dd id="section-c.1.1-1.10" style="margin-left: 1.5em"> This flag is set to true if at least one of the 
hosts has set the "A" bit in the MP_CAPABLE options exchanged during
connection establishment; otherwise,
it is set to false.  If this flag is set, the checksum must be computed in
all DSS options.<a class="pilcrow" href="#section-c.1.1-1.10">¶</a>
</dd>
</dl>
</section>
<section id="section-c.1.2">
          <h3 id="name-sending-side">
<a class="section-number selfRef" href="#section-c.1.2">C.1.2. </a><a class="section-name selfRef" href="#name-sending-side">Sending Side</a>
          </h3>
<dl class="dlParallel" id="section-c.1.2-1">
            <dt id="section-c.1.2-1.1">SND.UNA (64 bits):</dt>
<dd id="section-c.1.2-1.2" style="margin-left: 1.5em"> This is the data sequence number of the next byte to be
acknowledged, at the MPTCP connection level. This variable is updated
upon reception of a DSS option containing a DATA_ACK.<a class="pilcrow" href="#section-c.1.2-1.2">¶</a>
</dd>
<dt id="section-c.1.2-1.3">SND.NXT (64 bits):</dt>
<dd id="section-c.1.2-1.4" style="margin-left: 1.5em"> This is the data sequence number of the next byte to be
sent. SND.NXT is used to determine the value of the DSN in the DSS option.<a class="pilcrow" href="#section-c.1.2-1.4">¶</a>
</dd>
<dt id="section-c.1.2-1.5">SND.WND (32 bits):</dt>
<dd id="section-c.1.2-1.6" style="margin-left: 1.5em"> This is the send window.  32 bits if the features in RFC
            7323 are used; 16 bits otherwise. MPTCP maintains the send window at the MPTCP connection level, and the same
window is shared by all subflows. All subflows use the MPTCP connection-level
SND.WND to compute the SEQ.WND value that is sent in each
transmitted segment.<a class="pilcrow" href="#section-c.1.2-1.6">¶</a>
</dd>
</dl>
</section>
<section id="section-c.1.3">
          <h3 id="name-receiving-side">
<a class="section-number selfRef" href="#section-c.1.3">C.1.3. </a><a class="section-name selfRef" href="#name-receiving-side">Receiving Side</a>
          </h3>
<dl class="dlParallel" id="section-c.1.3-1">
            <dt id="section-c.1.3-1.1">RCV.NXT (64 bits):</dt>
<dd id="section-c.1.3-1.2" style="margin-left: 1.5em"> This is the data sequence number of the next byte that
is expected on the MPTCP connection. This state variable is modified
upon reception of in-order data. The value of RCV.NXT is used to specify
the DATA_ACK that is sent in the DSS option on all subflows.<a class="pilcrow" href="#section-c.1.3-1.2">¶</a>
</dd>
<dt id="section-c.1.3-1.3">RCV.WND (32 bits):</dt>
<dd id="section-c.1.3-1.4" style="margin-left: 1.5em"> This is the connection-level receive window, which is the
            maximum of the RCV.WND on all the subflows.  32 bits if the features in RFC 7323 are used; 16 bits otherwise.<a class="pilcrow" href="#section-c.1.3-1.4">¶</a>
</dd>
</dl>
</section>
</section>
<section id="section-c.2">
        <h2 id="name-tcp-control-blocks">
<a class="section-number selfRef" href="#section-c.2">C.2. </a><a class="section-name selfRef" href="#name-tcp-control-blocks">TCP Control Blocks</a>
        </h2>
<p id="section-c.2-1">The MPTCP control block also contains a list of the TCP control blocks
that are associated with the MPTCP connection.<a class="pilcrow" href="#section-c.2-1">¶</a></p>
<p id="section-c.2-2">Note that the TCP control block on the TCP subflows does not contain the
RCV.WND and SND.WND state variables, as these are maintained at the MPTCP
connection level and not at the subflow level.<a class="pilcrow" href="#section-c.2-2">¶</a></p>
<p id="section-c.2-3">Inside each TCP control block, the following state variables are defined.<a class="pilcrow" href="#section-c.2-3">¶</a></p>
<section id="section-c.2.1">
          <h3 id="name-sending-side-2">
<a class="section-number selfRef" href="#section-c.2.1">C.2.1. </a><a class="section-name selfRef" href="#name-sending-side-2">Sending Side</a>
          </h3>
<dl class="dlParallel" id="section-c.2.1-1">
            <dt id="section-c.2.1-1.1">SND.UNA (32 bits):</dt>
<dd id="section-c.2.1-1.2" style="margin-left: 1.5em"> This is the sequence number of the next byte to be
acknowledged on the subflow. This variable is updated upon reception of
each TCP acknowledgment on the subflow.<a class="pilcrow" href="#section-c.2.1-1.2">¶</a>
</dd>
<dt id="section-c.2.1-1.3">SND.NXT (32 bits):</dt>
<dd id="section-c.2.1-1.4" style="margin-left: 1.5em"> This is the sequence number of the next byte to be
sent on the subflow. SND.NXT is used to set the value of SEG.SEQ upon
transmission of the next segment.<a class="pilcrow" href="#section-c.2.1-1.4">¶</a>
</dd>
</dl>
</section>
<section id="section-c.2.2">
          <h3 id="name-receiving-side-2">
<a class="section-number selfRef" href="#section-c.2.2">C.2.2. </a><a class="section-name selfRef" href="#name-receiving-side-2">Receiving Side</a>
          </h3>
<dl class="dlParallel" id="section-c.2.2-1">
            <dt id="section-c.2.2-1.1">RCV.NXT (32 bits):</dt>
<dd id="section-c.2.2-1.2" style="margin-left: 1.5em"> This is the sequence number of the next byte that
is expected on the subflow. This state variable is modified upon
reception of in-order segments. The value of RCV.NXT is copied to the
SEG.ACK field of the next segments transmitted on the subflow.<a class="pilcrow" href="#section-c.2.2-1.2">¶</a>
</dd>
<dt id="section-c.2.2-1.3">RCV.WND (32 bits):</dt>
<dd id="section-c.2.2-1.4" style="margin-left: 1.5em">This is the subflow-level receive window that is updated with
            the window field from the segments received on this subflow.  32
            bits if the features in RFC 7323 are used; 16 bits otherwise.<a class="pilcrow" href="#section-c.2.2-1.4">¶</a>
</dd>
</dl>
</section>
</section>
</section>
</div>
<div id="app_fsm">
<section id="section-appendix.d">
      <h2 id="name-finite-state-machine">
<a class="section-number selfRef" href="#section-appendix.d">Appendix D. </a><a class="section-name selfRef" href="#name-finite-state-machine">Finite State Machine</a>
      </h2>
<p id="section-appendix.d-1">The diagram in <a class="xref" href="#fig_fsm">Figure 22</a> shows the
      Finite State Machine for connection-level closure.  This illustrates how
      the DATA_FIN connection-level signal (indicated in the diagram as the
      DFIN flag on a DATA_ACK) (1) interacts with subflow-level FINs and (2) permits break-before-make handover between subflows.<a class="pilcrow" href="#section-appendix.d-1">¶</a></p>
<span id="name-finite-state-machine-for-co"></span><div id="fig_fsm">
<figure id="figure-22">
        <div class="artwork art-text alignLeft" id="section-appendix.d-2.1">
<pre>                             +---------+
                             | M_ESTAB |
                             +---------+
                    M_CLOSE    |     |    rcv DATA_FIN
                     -------   |     |    -------
+---------+       snd DATA_FIN /       \ snd DATA_ACK[DFIN] +-------+
|  M_FIN  |&lt;-----------------           -------------------&gt;|M_CLOSE|
| WAIT-1  |---------------------------                      |  WAIT |
+---------+               rcv DATA_FIN \                    +-------+
  | rcv DATA_ACK[DFIN]         ------- |                   M_CLOSE |
  | --------------        snd DATA_ACK |                   ------- |
  | CLOSE all subflows                 |              snd DATA_FIN |
  V                                    V                           V
+-----------+              +-----------+                 +----------+
|M_FINWAIT-2|              | M_CLOSING |                 |M_LAST-ACK|
+-----------+              +-----------+                 +----------+
  |              rcv DATA_ACK[DFIN] |           rcv DATA_ACK[DFIN] |
  | rcv DATA_FIN     -------------- |               -------------- |
  |  -------     CLOSE all subflows |           CLOSE all subflows |
  | snd DATA_ACK[DFIN]              V            delete MPTCP PCB  V
  \                          +-----------+                 +--------+
    ------------------------&gt;|M_TIME WAIT|----------------&gt;|M_CLOSED|
                             +-----------+                 +--------+
                                        All subflows in CLOSED
                                            ------------
                                        delete MPTCP PCB</pre>
</div>
<figcaption><a class="selfRef" href="#figure-22">Figure 22</a>:
<a class="selfRef" href="#name-finite-state-machine-for-co">Finite State Machine for Connection Closure</a>
        </figcaption></figure>
</div>
</section>
</div>
<div id="app_changelog">
<section id="section-appendix.e">
      <h2 id="name-changes-from-rfc-6824">
<a class="section-number selfRef" href="#section-appendix.e">Appendix E. </a><a class="section-name selfRef" href="#name-changes-from-rfc-6824">Changes from RFC 6824</a>
      </h2>
<p id="section-appendix.e-1">This appendix lists the key technical changes between <span>[<a class="xref" href="#RFC6824">RFC6824</a>]</span>,
      which specifies MPTCP v0; and this document, which obsoletes <span>[<a class="xref" href="#RFC6824">RFC6824</a>]</span> and specifies MPTCP v1. Note that this specification is not backward compatible with <span>[<a class="xref" href="#RFC6824">RFC6824</a>]</span>.<a class="pilcrow" href="#section-appendix.e-1">¶</a></p>
<ul>
<li id="section-appendix.e-2.1">This document incorporates lessons learned from the various implementations, deployments, and experiments gathered in the documents "Use Cases and Operational Experience with Multipath TCP" <span>[<a class="xref" href="#RFC8041">RFC8041</a>]</span> and the IETF Journal article "Multipath TCP Deployments" <span>[<a class="xref" href="#deployments">deployments</a>]</span>.<a class="pilcrow" href="#section-appendix.e-2.1">¶</a>
</li>
<li id="section-appendix.e-2.2">Connection initiation, through the exchange of the MP_CAPABLE
        MPTCP option, is different from <span>[<a class="xref" href="#RFC6824">RFC6824</a>]</span>. The SYN no longer
        includes the initiator's key, to allow the MP_CAPABLE option on the SYN to be shorter in length and to avoid duplicating the sending of keying material.<a class="pilcrow" href="#section-appendix.e-2.2">¶</a>
</li>
<li id="section-appendix.e-2.3">This also ensures reliable delivery of the key on the MP_CAPABLE
        option by allowing its transmission to be combined with data and thus
        using TCP's built-in reliability mechanism. If the initiator does not
        immediately have data to send, the MP_CAPABLE option with the keys
        will be repeated on the first data packet. If the other end is the first to send, then the presence of the DSS option implicitly confirms the receipt of the MP_CAPABLE.<a class="pilcrow" href="#section-appendix.e-2.3">¶</a>
</li>
<li id="section-appendix.e-2.4">In the Flags field of MP_CAPABLE, "C" is now assigned to mean that
        the sender of this option will not accept additional MPTCP subflows to
        the source address and port. This improves efficiency -- for example,
        in cases where the sender is behind a strict NAT.<a class="pilcrow" href="#section-appendix.e-2.4">¶</a>
</li>
<li id="section-appendix.e-2.5">In the Flags field of MP_CAPABLE, "H" now indicates the use of HMAC-SHA256 (rather than HMAC-SHA1).<a class="pilcrow" href="#section-appendix.e-2.5">¶</a>
</li>
<li id="section-appendix.e-2.6">Connection initiation also defines the procedure for version negotiation, for implementations that support both v0 <span>[<a class="xref" href="#RFC6824">RFC6824</a>]</span> and v1 (this document).<a class="pilcrow" href="#section-appendix.e-2.6">¶</a>
</li>
<li id="section-appendix.e-2.7">The HMAC-SHA256 (rather than HMAC-SHA1) algorithm is used, as it provides better security. It is used to generate the token in the MP_JOIN and ADD_ADDR messages and to set the IDSN.<a class="pilcrow" href="#section-appendix.e-2.7">¶</a>
</li>
<li id="section-appendix.e-2.8">A new subflow-level option exists to signal reasons for sending a
        RST on a subflow (MP_TCPRST (<a class="xref" href="#sec_reset">Section 3.6</a>)); this can help an implementation decide whether to attempt later reconnection.<a class="pilcrow" href="#section-appendix.e-2.8">¶</a>
</li>
<li id="section-appendix.e-2.9">The MP_PRIO option (<a class="xref" href="#sec_policy">Section 3.3.8</a>),
        which is used to signal a change of priority for a subflow, no longer
        includes the AddrID field. Its purpose was to allow the changed
        priority to be applied on a subflow other than the one it was sent
        on. However, it was determined that this could be used by a
        man-in-the-middle to divert all traffic onto its own path, and MP_PRIO
        does not include a token or other type of security mechanism.<a class="pilcrow" href="#section-appendix.e-2.9">¶</a>
</li>
<li id="section-appendix.e-2.10">The ADD_ADDR option (<a class="xref" href="#sec_add_address">Section 3.4.1</a>), which is used to inform the other host about another potential address, is different in several ways. It now includes an HMAC of the added address, for enhanced security. In addition, reliability for the ADD_ADDR option has been added: the IPVer field is replaced with a flag field, and one flag is assigned ("E") that is used as an "echo" so a host can indicate that it has received the option.<a class="pilcrow" href="#section-appendix.e-2.10">¶</a>
</li>
<li id="section-appendix.e-2.11">This document describes an additional way of performing a Fast
        Close -- by sending an MP_FASTCLOSE option on a RST on all subflows. This allows the host to tear down the subflows and the connection immediately.<a class="pilcrow" href="#section-appendix.e-2.11">¶</a>
</li>
<li id="section-appendix.e-2.12">IANA has reserved the MPTCP option subtype of value 0xf for
        Private Use (<a class="xref" href="#IANA_subtypes">Section 7.2</a>). This document doesn't define how to use that value.<a class="pilcrow" href="#section-appendix.e-2.12">¶</a>
</li>
<li id="section-appendix.e-2.13">This document adds a new appendix (<a class="xref" href="#app_tfo">Appendix B</a>), which discusses the usage of both MPTCP options
        and TFO options on the same packet.<a class="pilcrow" href="#section-appendix.e-2.13">¶</a>
</li>
</ul>
</section>
</div>
<div id="Acknowledgments">
<section id="section-appendix.f">
      <h2 id="name-acknowledgments">
<a class="section-name selfRef" href="#name-acknowledgments">Acknowledgments</a>
      </h2>
<p id="section-appendix.f-1">The authors gratefully acknowledge significant input into this
      document from <span class="contact-name">Sebastien Barre</span> and <span class="contact-name">Andrew McDonald</span>.<a class="pilcrow" href="#section-appendix.f-1">¶</a></p>
<p id="section-appendix.f-2">The authors also wish to acknowledge reviews and contributions from
      <span class="contact-name">Iljitsch van Beijnum</span>, <span class="contact-name">Lars       Eggert</span>, <span class="contact-name">Marcelo Bagnulo</span>, <span class="contact-name">Robert Hancock</span>, <span class="contact-name">Pasi Sarolahti</span>,
      <span class="contact-name">Toby Moncaster</span>, <span class="contact-name">Philip       Eardley</span>, <span class="contact-name">Sergio Lembo</span>, <span class="contact-name">Lawrence Conroy</span>, <span class="contact-name">Yoshifumi Nishida</span>,
      <span class="contact-name">Bob Briscoe</span>, <span class="contact-name">Stein Gjessing</span>,
      <span class="contact-name">Andrew McGregor</span>, <span class="contact-name">Georg       Hampel</span>, <span class="contact-name">Anumita Biswas</span>, <span class="contact-name">Wes       Eddy</span>, <span class="contact-name">Alexey Melnikov</span>, <span class="contact-name">Francis Dupont</span>, <span class="contact-name">Adrian Farrel</span>,
      <span class="contact-name">Barry Leiba</span>, <span class="contact-name">Robert Sparks</span>,
      <span class="contact-name">Sean Turner</span>, <span class="contact-name">Stephen       Farrell</span>, <span class="contact-name">Martin Stiemerling</span>, <span class="contact-name">Gregory Detal</span>, <span class="contact-name">Fabien Duchene</span>,
      <span class="contact-name">Xavier de Foy</span>, <span class="contact-name">Rahul Jadhav</span>,
      <span class="contact-name">Klemens Schragel</span>, <span class="contact-name">Mirja       Kühlewind</span>, <span class="contact-name">Sheng Jiang</span>, <span class="contact-name">Alissa Cooper</span>, <span class="contact-name">Ines Robles</span>, <span class="contact-name">Roman Danyliw</span>, <span class="contact-name">Adam Roach</span>,
      <span class="contact-name">Eric Vyncke</span>, and <span class="contact-name">Ben Kaduk</span>.<a class="pilcrow" href="#section-appendix.f-2">¶</a></p>
</section>
</div>
<div id="authors-addresses">
<section id="section-appendix.g">
      <h2 id="name-authors-addresses">
<a class="section-name selfRef" href="#name-authors-addresses">Authors' Addresses</a>
      </h2>
<address class="vcard">
        <div class="left" dir="auto"><span class="fn nameRole">Alan Ford</span></div>
<div class="left" dir="auto"><span class="org">Pexip</span></div>
<div class="email">
<span>Email:</span>
<a class="email" href="mailto:alan.ford@gmail.com">alan.ford@gmail.com</a>
</div>
</address>
<address class="vcard">
        <div class="left" dir="auto"><span class="fn nameRole">Costin Raiciu</span></div>
<div class="left" dir="auto"><span class="org">University Politehnica of Bucharest</span></div>
<div class="left" dir="auto"><span class="street-address">Splaiul Independentei 313</span></div>
<div class="left" dir="auto"><span class="locality">Bucharest</span></div>
<div class="left" dir="auto"><span class="country-name">Romania</span></div>
<div class="email">
<span>Email:</span>
<a class="email" href="mailto:costin.raiciu@cs.pub.ro">costin.raiciu@cs.pub.ro</a>
</div>
</address>
<address class="vcard">
        <div class="left" dir="auto"><span class="fn nameRole">Mark Handley</span></div>
<div class="left" dir="auto"><span class="org">University College London</span></div>
<div class="left" dir="auto"><span class="street-address">Gower Street</span></div>
<div class="left" dir="auto"><span class="locality">London</span></div>
<div class="left" dir="auto"><span class="postal-code">WC1E 6BT</span></div>
<div class="left" dir="auto"><span class="country-name">United Kingdom</span></div>
<div class="email">
<span>Email:</span>
<a class="email" href="mailto:m.handley@cs.ucl.ac.uk">m.handley@cs.ucl.ac.uk</a>
</div>
</address>
<address class="vcard">
        <div class="left" dir="auto"><span class="fn nameRole">Olivier Bonaventure</span></div>
<div class="left" dir="auto"><span class="org">Université catholique de Louvain</span></div>
<div class="left" dir="auto"><span class="street-address">Pl. Ste Barbe, 2</span></div>
<div class="left" dir="auto">
<span class="postal-code">1348</span> <span class="locality">Louvain-la-Neuve</span>
</div>
<div class="left" dir="auto"><span class="country-name">Belgium</span></div>
<div class="email">
<span>Email:</span>
<a class="email" href="mailto:olivier.bonaventure@uclouvain.be">olivier.bonaventure@uclouvain.be</a>
</div>
</address>
<address class="vcard">
        <div class="left" dir="auto"><span class="fn nameRole">Christoph Paasch</span></div>
<div class="left" dir="auto"><span class="org">Apple, Inc.</span></div>
<div class="left" dir="auto">
<span class="locality">Cupertino</span>, <span class="region">CA</span> </div>
<div class="left" dir="auto"><span class="country-name">United States of America</span></div>
<div class="email">
<span>Email:</span>
<a class="email" href="mailto:cpaasch@apple.com">cpaasch@apple.com</a>
</div>
</address>
</section>
</div>
<script>const toc = document.getElementById("toc");
toc.querySelector("h2").addEventListener("click", e => {
  toc.classList.toggle("active");
});
toc.querySelector("nav").addEventListener("click", e => {
  toc.classList.remove("active");
});
</script>


</body></html>