<!DOCTYPE html>
<html class="RFC" lang="en"><head>
<meta charset="utf-8"/>
<meta content="Common,Latin" name="scripts"/>
<meta content="initial-scale=1.0" name="viewport"/>
<title>RFC 8931: IPv6 over Low-Power Wireless Personal Area Network (6LoWPAN) Selective Fragment Recovery</title>
<meta content="Pascal Thubert" name="author"/>
<meta content="
       
        This document updates RFC 4944 with a protocol that forwards individual fragments
        across a route-over mesh and recovers them end to end, with
 congestion control
        capabilities to protect the network.
       
    " name="description"/>
<meta content="xml2rfc 3.5.0" name="generator"/>
<meta content="8931" name="rfc.number"/>
<!-- Generator version information:
  xml2rfc 3.5.0
    Python 3.6.10
    appdirs 1.4.4
    ConfigArgParse 1.2.3
    google-i18n-address 2.3.5
    html5lib 1.0.1
    intervaltree 3.0.2
    Jinja2 2.11.2
    kitchen 1.2.6
    lxml 4.4.2
    pycairo 1.19.0
    pycountry 19.8.18
    pyflakes 2.1.1
    PyYAML 5.3.1
    requests 2.22.0
    setuptools 40.6.2
    six 1.14.0
    WeasyPrint 51
-->
<link href="rfc8931.xml" rel="alternate" type="application/rfc+xml"/>
<link href="#copyright" rel="license"/>
<style type="text/css">/*

  NOTE: Changes at the bottom of this file overrides some earlier settings.

  Once the style has stabilized and has been adopted as an official RFC style,
  this can be consolidated so that style settings occur only in one place, but
  for now the contents of this file consists first of the initial CSS work as
  provided to the RFC Formatter (xml2rfc) work, followed by itemized and
  commented changes found necssary during the development of the v3
  formatters.

*/

/* fonts */
@import url('https://fonts.googleapis.com/css?family=Noto+Sans'); /* Sans-serif */
@import url('https://fonts.googleapis.com/css?family=Noto+Serif'); /* Serif (print) */
@import url('https://fonts.googleapis.com/css?family=Roboto+Mono'); /* Monospace */

@viewport {
  zoom: 1.0;
  width: extend-to-zoom;
}
@-ms-viewport {
  width: extend-to-zoom;
  zoom: 1.0;
}
/* general and mobile first */
html {
}
body {
  max-width: 90%;
  margin: 1.5em auto;
  color: #222;
  background-color: #fff;
  font-size: 14px;
  font-family: 'Noto Sans', Arial, Helvetica, sans-serif;
  line-height: 1.6;
  scroll-behavior: smooth;
}
.ears {
  display: none;
}

/* headings */
#title, h1, h2, h3, h4, h5, h6 {
  margin: 1em 0 0.5em;
  font-weight: bold;
  line-height: 1.3;
}
#title {
  clear: both;
  border-bottom: 1px solid #ddd;
  margin: 0 0 0.5em 0;
  padding: 1em 0 0.5em;
}
.author {
  padding-bottom: 4px;
}
h1 {
  font-size: 26px;
  margin: 1em 0;
}
h2 {
  font-size: 22px;
  margin-top: -20px;  /* provide offset for in-page anchors */
  padding-top: 33px;
}
h3 {
  font-size: 18px;
  margin-top: -36px;  /* provide offset for in-page anchors */
  padding-top: 42px;
}
h4 {
  font-size: 16px;
  margin-top: -36px;  /* provide offset for in-page anchors */
  padding-top: 42px;
}
h5, h6 {
  font-size: 14px;
}
#n-copyright-notice {
  border-bottom: 1px solid #ddd;
  padding-bottom: 1em;
  margin-bottom: 1em;
}
/* general structure */
p {
  padding: 0;
  margin: 0 0 1em 0;
  text-align: left;
}
div, span {
  position: relative;
}
div {
  margin: 0;
}
.alignRight.art-text {
  background-color: #f9f9f9;
  border: 1px solid #eee;
  border-radius: 3px;
  padding: 1em 1em 0;
  margin-bottom: 1.5em;
}
.alignRight.art-text pre {
  padding: 0;
}
.alignRight {
  margin: 1em 0;
}
.alignRight > *:first-child {
  border: none;
  margin: 0;
  float: right;
  clear: both;
}
.alignRight > *:nth-child(2) {
  clear: both;
  display: block;
  border: none;
}
svg {
  display: block;
}
.alignCenter.art-text {
  background-color: #f9f9f9;
  border: 1px solid #eee;
  border-radius: 3px;
  padding: 1em 1em 0;
  margin-bottom: 1.5em;
}
.alignCenter.art-text pre {
  padding: 0;
}
.alignCenter {
  margin: 1em 0;
}
.alignCenter > *:first-child {
  border: none;
  /* this isn't optimal, but it's an existence proof.  PrinceXML doesn't
     support flexbox yet.
  */
  display: table;
  margin: 0 auto;
}

/* lists */
ol, ul {
  padding: 0;
  margin: 0 0 1em 2em;
}
ol ol, ul ul, ol ul, ul ol {
  margin-left: 1em;
}
li {
  margin: 0 0 0.25em 0;
}
.ulCompact li {
  margin: 0;
}
ul.empty, .ulEmpty {
  list-style-type: none;
}
ul.empty li, .ulEmpty li {
  margin-top: 0.5em;
}
ul.compact, .ulCompact,
ol.compact, .olCompact {
  line-height: 100%;
  margin: 0 0 0 2em;
}

/* definition lists */
dl {
}
dl > dt {
  float: left;
  margin-right: 1em;
}
/* 
dl.nohang > dt {
  float: none;
}
*/
dl > dd {
  margin-bottom: .8em;
  min-height: 1.3em;
}
dl.compact > dd, .dlCompact > dd {
  margin-bottom: 0em;
}
dl > dd > dl {
  margin-top: 0.5em;
  margin-bottom: 0em;
}

/* links */
a {
  text-decoration: none;
}
a[href] {
  color: #22e; /* Arlen: WCAG 2019 */
}
a[href]:hover {
  background-color: #f2f2f2;
}
figcaption a[href],
a[href].selfRef {
  color: #222;
}
/* XXX probably not this:
a.selfRef:hover {
  background-color: transparent;
  cursor: default;
} */

/* Figures */
tt, code, pre, code {
  background-color: #f9f9f9;
  font-family: 'Roboto Mono', monospace;
}
pre {
  border: 1px solid #eee;
  margin: 0;
  padding: 1em;
}
img {
  max-width: 100%;
}
figure {
  margin: 0;
}
figure blockquote {
  margin: 0.8em 0.4em 0.4em;
}
figcaption {
  font-style: italic;
  margin: 0 0 1em 0;
}
@media screen {
  pre {
    overflow-x: auto;
    max-width: 100%;
    max-width: calc(100% - 22px);
  }
}

/* aside, blockquote */
aside, blockquote {
  margin-left: 0;
  padding: 1.2em 2em;
}
blockquote {
  background-color: #f9f9f9;
  color: #111; /* Arlen: WCAG 2019 */
  border: 1px solid #ddd;
  border-radius: 3px;
  margin: 1em 0;
}
cite {
  display: block;
  text-align: right;
  font-style: italic;
}

/* tables */
table {
  width: 100%;
  margin: 0 0 1em;
  border-collapse: collapse;
  border: 1px solid #eee;
}
th, td {
  text-align: left;
  vertical-align: top;
  padding: 0.5em 0.75em;
}
th {
  text-align: left;
  background-color: #e9e9e9;
}
tr:nth-child(2n+1) > td {
  background-color: #f5f5f5;
}
table caption {
  font-style: italic;
  margin: 0;
  padding: 0;
  text-align: left;
}
table p {
  /* XXX to avoid bottom margin on table row signifiers. If paragraphs should
     be allowed within tables more generally, it would be far better to select on a class. */
  margin: 0;
}

/* pilcrow */
a.pilcrow {
  color: #666; /* Arlen: AHDJ 2019 */
  text-decoration: none;
  visibility: hidden;
  user-select: none;
  -ms-user-select: none;
  -o-user-select:none;
  -moz-user-select: none;
  -khtml-user-select: none;
  -webkit-user-select: none;
  -webkit-touch-callout: none;
}
@media screen {
  aside:hover > a.pilcrow,
  p:hover > a.pilcrow,
  blockquote:hover > a.pilcrow,
  div:hover > a.pilcrow,
  li:hover > a.pilcrow,
  pre:hover > a.pilcrow {
    visibility: visible;
  }
  a.pilcrow:hover {
    background-color: transparent;
  }
}

/* misc */
hr {
  border: 0;
  border-top: 1px solid #eee;
}
.bcp14 {
  font-variant: small-caps;
}

.role {
  font-variant: all-small-caps;
}

/* info block */
#identifiers {
  margin: 0;
  font-size: 0.9em;
}
#identifiers dt {
  width: 3em;
  clear: left;
}
#identifiers dd {
  float: left;
  margin-bottom: 0;
}
#identifiers .authors .author {
  display: inline-block;
  margin-right: 1.5em;
}
#identifiers .authors .org {
  font-style: italic;
}

/* The prepared/rendered info at the very bottom of the page */
.docInfo {
  color: #666; /* Arlen: WCAG 2019 */
  font-size: 0.9em;
  font-style: italic;
  margin-top: 2em;
}
.docInfo .prepared {
  float: left;
}
.docInfo .prepared {
  float: right;
}

/* table of contents */
#toc  {
  padding: 0.75em 0 2em 0;
  margin-bottom: 1em;
}
nav.toc ul {
  margin: 0 0.5em 0 0;
  padding: 0;
  list-style: none;
}
nav.toc li {
  line-height: 1.3em;
  margin: 0.75em 0;
  padding-left: 1.2em;
  text-indent: -1.2em;
}
/* references */
.references dt {
  text-align: right;
  font-weight: bold;
  min-width: 7em;
}
.references dd {
  margin-left: 8em;
  overflow: auto;
}

.refInstance {
  margin-bottom: 1.25em;
}

.references .ascii {
  margin-bottom: 0.25em;
}

/* index */
.index ul {
  margin: 0 0 0 1em;
  padding: 0;
  list-style: none;
}
.index ul ul {
  margin: 0;
}
.index li {
  margin: 0;
  text-indent: -2em;
  padding-left: 2em;
  padding-bottom: 5px;
}
.indexIndex {
  margin: 0.5em 0 1em;
}
.index a {
  font-weight: 700;
}
/* make the index two-column on all but the smallest screens */
@media (min-width: 600px) {
  .index ul {
    -moz-column-count: 2;
    -moz-column-gap: 20px;
  }
  .index ul ul {
    -moz-column-count: 1;
    -moz-column-gap: 0;
  }
}

/* authors */
address.vcard {
  font-style: normal;
  margin: 1em 0;
}

address.vcard .nameRole {
  font-weight: 700;
  margin-left: 0;
}
address.vcard .label {
  font-family: "Noto Sans",Arial,Helvetica,sans-serif;
  margin: 0.5em 0;
}
address.vcard .type {
  display: none;
}
.alternative-contact {
  margin: 1.5em 0 1em;
}
hr.addr {
  border-top: 1px dashed;
  margin: 0;
  color: #ddd;
  max-width: calc(100% - 16px);
}

/* temporary notes */
.rfcEditorRemove::before {
  position: absolute;
  top: 0.2em;
  right: 0.2em;
  padding: 0.2em;
  content: "The RFC Editor will remove this note";
  color: #9e2a00; /* Arlen: WCAG 2019 */
  background-color: #ffd; /* Arlen: WCAG 2019 */
}
.rfcEditorRemove {
  position: relative;
  padding-top: 1.8em;
  background-color: #ffd; /* Arlen: WCAG 2019 */
  border-radius: 3px;
}
.cref {
  background-color: #ffd; /* Arlen: WCAG 2019 */
  padding: 2px 4px;
}
.crefSource {
  font-style: italic;
}
/* alternative layout for smaller screens */
@media screen and (max-width: 1023px) {
  body {
    padding-top: 2em;
  }
  #title {
    padding: 1em 0;
  }
  h1 {
    font-size: 24px;
  }
  h2 {
    font-size: 20px;
    margin-top: -18px;  /* provide offset for in-page anchors */
    padding-top: 38px;
  }
  #identifiers dd {
    max-width: 60%;
  }
  #toc {
    position: fixed;
    z-index: 2;
    top: 0;
    right: 0;
    padding: 0;
    margin: 0;
    background-color: inherit;
    border-bottom: 1px solid #ccc;
  }
  #toc h2 {
    margin: -1px 0 0 0;
    padding: 4px 0 4px 6px;
    padding-right: 1em;
    min-width: 190px;
    font-size: 1.1em;
    text-align: right;
    background-color: #444;
    color: white;
    cursor: pointer;
  }
  #toc h2::before { /* css hamburger */
    float: right;
    position: relative;
    width: 1em;
    height: 1px;
    left: -164px;
    margin: 6px 0 0 0;
    background: white none repeat scroll 0 0;
    box-shadow: 0 4px 0 0 white, 0 8px 0 0 white;
    content: "";
  }
  #toc nav {
    display: none;
    padding: 0.5em 1em 1em;
    overflow: auto;
    height: calc(100vh - 48px);
    border-left: 1px solid #ddd;
  }
}

/* alternative layout for wide screens */
@media screen and (min-width: 1024px) {
  body {
    max-width: 724px;
    margin: 42px auto;
    padding-left: 1.5em;
    padding-right: 29em;
  }
  #toc {
    position: fixed;
    top: 42px;
    right: 42px;
    width: 25%;
    margin: 0;
    padding: 0 1em;
    z-index: 1;
  }
  #toc h2 {
    border-top: none;
    border-bottom: 1px solid #ddd;
    font-size: 1em;
    font-weight: normal;
    margin: 0;
    padding: 0.25em 1em 1em 0;
  }
  #toc nav {
    display: block;
    height: calc(90vh - 84px);
    bottom: 0;
    padding: 0.5em 0 0;
    overflow: auto;
  }
  img { /* future proofing */
    max-width: 100%;
    height: auto;
  }
}

/* pagination */
@media print {
  body {

    width: 100%;
  }
  p {
    orphans: 3;
    widows: 3;
  }
  #n-copyright-notice {
    border-bottom: none;
  }
  #toc, #n-introduction {
    page-break-before: always;
  }
  #toc {
    border-top: none;
    padding-top: 0;
  }
  figure, pre {
    page-break-inside: avoid;
  }
  figure {
    overflow: scroll;
  }
  h1, h2, h3, h4, h5, h6 {
    page-break-after: avoid;
  }
  h2+*, h3+*, h4+*, h5+*, h6+* {
    page-break-before: avoid;
  }
  pre {
    white-space: pre-wrap;
    word-wrap: break-word;
    font-size: 10pt;
  }
  table {
    border: 1px solid #ddd;
  }
  td {
    border-top: 1px solid #ddd;
  }
}

/* This is commented out here, as the string-set: doesn't
   pass W3C validation currently */
/*
.ears thead .left {
  string-set: ears-top-left content();
}

.ears thead .center {
  string-set: ears-top-center content();
}

.ears thead .right {
  string-set: ears-top-right content();
}

.ears tfoot .left {
  string-set: ears-bottom-left content();
}

.ears tfoot .center {
  string-set: ears-bottom-center content();
}

.ears tfoot .right {
  string-set: ears-bottom-right content();
}
*/

@page :first {
  padding-top: 0;
  @top-left {
    content: normal;
    border: none;
  }
  @top-center {
    content: normal;
    border: none;
  }
  @top-right {
    content: normal;
    border: none;
  }
}

@page {
  size: A4;
  margin-bottom: 45mm;
  padding-top: 20px;
  /* The follwing is commented out here, but set appropriately by in code, as
     the content depends on the document */
  /*
  @top-left {
    content: 'Internet-Draft';
    vertical-align: bottom;
    border-bottom: solid 1px #ccc;
  }
  @top-left {
    content: string(ears-top-left);
    vertical-align: bottom;
    border-bottom: solid 1px #ccc;
  }
  @top-center {
    content: string(ears-top-center);
    vertical-align: bottom;
    border-bottom: solid 1px #ccc;
  }
  @top-right {
    content: string(ears-top-right);
    vertical-align: bottom;
    border-bottom: solid 1px #ccc;
  }
  @bottom-left {
    content: string(ears-bottom-left);
    vertical-align: top;
    border-top: solid 1px #ccc;
  }
  @bottom-center {
    content: string(ears-bottom-center);
    vertical-align: top;
    border-top: solid 1px #ccc;
  }
  @bottom-right {
      content: '[Page ' counter(page) ']';
      vertical-align: top;
      border-top: solid 1px #ccc;
  }
  */

}

/* Changes introduced to fix issues found during implementation */
/* Make sure links are clickable even if overlapped by following H* */
a {
  z-index: 2;
}
/* Separate body from document info even without intervening H1 */
section {
  clear: both;
}


/* Top align author divs, to avoid names without organization dropping level with org names */
.author {
  vertical-align: top;
}

/* Leave room in document info to show Internet-Draft on one line */
#identifiers dt {
  width: 8em;
}

/* Don't waste quite as much whitespace between label and value in doc info */
#identifiers dd {
  margin-left: 1em;
}

/* Give floating toc a background color (needed when it's a div inside section */
#toc {
  background-color: white;
}

/* Make the collapsed ToC header render white on gray also when it's a link */
@media screen and (max-width: 1023px) {
  #toc h2 a,
  #toc h2 a:link,
  #toc h2 a:focus,
  #toc h2 a:hover,
  #toc a.toplink,
  #toc a.toplink:hover {
    color: white;
    background-color: #444;
    text-decoration: none;
  }
}

/* Give the bottom of the ToC some whitespace */
@media screen and (min-width: 1024px) {
  #toc {
    padding: 0 0 1em 1em;
  }
}

/* Style section numbers with more space between number and title */
.section-number {
  padding-right: 0.5em;
}

/* prevent monospace from becoming overly large */
tt, code, pre, code {
  font-size: 95%;
}

/* Fix the height/width aspect for ascii art*/
pre.sourcecode,
.art-text pre {
  line-height: 1.12;
}


/* Add styling for a link in the ToC that points to the top of the document */
a.toplink {
  float: right;
  margin-right: 0.5em;
}

/* Fix the dl styling to match the RFC 7992 attributes */
dl > dt,
dl.dlParallel > dt {
  float: left;
  margin-right: 1em;
}
dl.dlNewline > dt {
  float: none;
}

/* Provide styling for table cell text alignment */
table td.text-left,
table th.text-left {
  text-align: left;
}
table td.text-center,
table th.text-center {
  text-align: center;
}
table td.text-right,
table th.text-right {
  text-align: right;
}

/* Make the alternative author contact informatio look less like just another
   author, and group it closer with the primary author contact information */
.alternative-contact {
  margin: 0.5em 0 0.25em 0;
}
address .non-ascii {
  margin: 0 0 0 2em;
}

/* With it being possible to set tables with alignment
  left, center, and right, { width: 100%; } does not make sense */
table {
  width: auto;
}

/* Avoid reference text that sits in a block with very wide left margin,
   because of a long floating dt label.*/
.references dd {
  overflow: visible;
}

/* Control caption placement */
caption {
  caption-side: bottom;
}

/* Limit the width of the author address vcard, so names in right-to-left
   script don't end up on the other side of the page. */

address.vcard {
  max-width: 30em;
  margin-right: auto;
}

/* For address alignment dependent on LTR or RTL scripts */
address div.left {
  text-align: left;
}
address div.right {
  text-align: right;
}

/* Provide table alignment support.  We can't use the alignX classes above
   since they do unwanted things with caption and other styling. */
table.right {
 margin-left: auto;
 margin-right: 0;
}
table.center {
 margin-left: auto;
 margin-right: auto;
}
table.left {
 margin-left: 0;
 margin-right: auto;
}

/* Give the table caption label the same styling as the figcaption */
caption a[href] {
  color: #222;
}

@media print {
  .toplink {
    display: none;
  }

  /* avoid overwriting the top border line with the ToC header */
  #toc {
    padding-top: 1px;
  }

  /* Avoid page breaks inside dl and author address entries */
  .vcard {
    page-break-inside: avoid;
  }

}
/* Tweak the bcp14 keyword presentation */
.bcp14 {
  font-variant: small-caps;
  font-weight: bold;
  font-size: 0.9em;
}
/* Tweak the invisible space above H* in order not to overlay links in text above */
 h2 {
  margin-top: -18px;  /* provide offset for in-page anchors */
  padding-top: 31px;
 }
 h3 {
  margin-top: -18px;  /* provide offset for in-page anchors */
  padding-top: 24px;
 }
 h4 {
  margin-top: -18px;  /* provide offset for in-page anchors */
  padding-top: 24px;
 }
/* Float artwork pilcrow to the right */
@media screen {
  .artwork a.pilcrow {
    display: block;
    line-height: 0.7;
    margin-top: 0.15em;
  }
}
/* Make pilcrows on dd visible */
@media screen {
  dd:hover > a.pilcrow {
    visibility: visible;
  }
}
/* Make the placement of figcaption match that of a table's caption
   by removing the figure's added bottom margin */
.alignLeft.art-text,
.alignCenter.art-text,
.alignRight.art-text {
   margin-bottom: 0;
}
.alignLeft,
.alignCenter,
.alignRight {
  margin: 1em 0 0 0;
}
/* In print, the pilcrow won't show on hover, so prevent it from taking up space,
   possibly even requiring a new line */
@media print {
  a.pilcrow {
    display: none;
  }
}
/* Styling for the external metadata */
div#external-metadata {
  background-color: #eee;
  padding: 0.5em;
  margin-bottom: 0.5em;
  display: none;
}
div#internal-metadata {
  padding: 0.5em;                       /* to match the external-metadata padding */
}
/* Styling for title RFC Number */
h1#rfcnum {
  clear: both;
  margin: 0 0 -1em;
  padding: 1em 0 0 0;
}
/* Make .olPercent look the same as <ol><li> */
dl.olPercent > dd {
  margin-bottom: 0.25em;
  min-height: initial;
}
/* Give aside some styling to set it apart */
aside {
  border-left: 1px solid #ddd;
  margin: 1em 0 1em 2em;
  padding: 0.2em 2em;
}
aside > dl,
aside > ol,
aside > ul,
aside > table,
aside > p {
  margin-bottom: 0.5em;
}
/* Additional page break settings */
@media print {
  figcaption, table caption {
    page-break-before: avoid;
  }
}
/* Font size adjustments for print */
@media print {
  body  { font-size: 10pt;      line-height: normal; max-width: 96%; }
  h1    { font-size: 1.72em;    padding-top: 1.5em; } /* 1*1.2*1.2*1.2 */
  h2    { font-size: 1.44em;    padding-top: 1.5em; } /* 1*1.2*1.2 */
  h3    { font-size: 1.2em;     padding-top: 1.5em; } /* 1*1.2 */
  h4    { font-size: 1em;       padding-top: 1.5em; }
  h5, h6 { font-size: 1em;      margin: initial; padding: 0.5em 0 0.3em; }
}
/* Sourcecode margin in print, when there's no pilcrow */
@media print {
  .artwork,
  .sourcecode {
    margin-bottom: 1em;
  }
}
/* Avoid narrow tables forcing too narrow table captions, which may render badly */
table {
  min-width: 20em;
}
/* ol type a */
ol.type-a { list-style-type: lower-alpha; }
ol.type-A { list-style-type: upper-alpha; }
ol.type-i { list-style-type: lower-roman; }
ol.type-I { list-style-type: lower-roman; }
/* Apply the print table and row borders in general, on request from the RPC,
and increase the contrast between border and odd row background sligthtly */
table {
  border: 1px solid #ddd;
}
td {
  border-top: 1px solid #ddd;
}
tr:nth-child(2n+1) > td {
  background-color: #f8f8f8;
}
/* Use style rules to govern display of the TOC. */
@media screen and (max-width: 1023px) {
  #toc nav { display: none; }
  #toc.active nav { display: block; }
}
/* Add support for keepWithNext */
.keepWithNext {
  break-after: avoid-page;
  break-after: avoid-page;
}
/* Add support for keepWithPrevious */
.keepWithPrevious {
  break-before: avoid-page;
}
/* Change the approach to avoiding breaks inside artwork etc. */
figure, pre, table, .artwork, .sourcecode  {
  break-before: avoid-page;
  break-after: auto;
}
/* Avoid breaks between <dt> and <dd> */
dl {
  break-before: auto;
  break-inside: auto;
}
dt {
  break-before: auto;
  break-after: avoid-page;
}
dd {
  break-before: avoid-page;
  break-after: auto;
  orphans: 3;
  widows: 3
}
span.break, dd.break {
  margin-bottom: 0;
  min-height: 0;
  break-before: auto;
  break-inside: auto;
  break-after: auto;
}
/* Undo break-before ToC */
@media print {
  #toc {
    break-before: auto;
  }
}
/* Text in compact lists should not get extra bottim margin space,
   since that would makes the list not compact */
ul.compact p, .ulCompact p,
ol.compact p, .olCompact p {
 margin: 0;
}
/* But the list as a whole needs the extra space at the end */
section ul.compact,
section .ulCompact,
section ol.compact,
section .olCompact {
  margin-bottom: 1em;                    /* same as p not within ul.compact etc. */
}
/* The tt and code background above interferes with for instance table cell
   backgrounds.  Changed to something a bit more selective. */
tt, code {
  background-color: transparent;
}
p tt, p code, li tt, li code {
  background-color: #f8f8f8;
}
/* Tweak the pre margin -- 0px doesn't come out well */
pre {
   margin-top: 0.5px;
}
/* Tweak the comact list text */
ul.compact, .ulCompact,
ol.compact, .olCompact,
dl.compact, .dlCompact {
  line-height: normal;
}
/* Don't add top margin for nested lists */
li > ul, li > ol, li > dl,
dd > ul, dd > ol, dd > dl,
dl > dd > dl {
  margin-top: initial;
}
/* Elements that should not be rendered on the same line as a <dt> */
/* This should match the element list in writer.text.TextWriter.render_dl() */
dd > div.artwork:first-child,
dd > aside:first-child,
dd > figure:first-child,
dd > ol:first-child,
dd > div:first-child > pre.sourcecode,
dd > table:first-child,
dd > ul:first-child {
  clear: left;
}
/* fix for weird browser behaviour when <dd/> is empty */
dt+dd:empty::before{
  content: "\00a0";
}
</style>
<link href="rfc-local.css" rel="stylesheet" type="text/css"/>
<link href="https://dx.doi.org/10.17487/rfc8931" rel="alternate"/>
  <link href="urn:issn:2070-1721" rel="alternate"/>
  <link href="https://datatracker.ietf.org/doc/draft-ietf-6lo-fragment-recovery-21" rel="prev"/>
  </head>
<body>
<script src="https://www.rfc-editor.org/js/metadata.min.js"></script>
<table class="ears">
<thead><tr>
<td class="left">RFC 8931</td>
<td class="center">Selective RFRAG</td>
<td class="right">November 2020</td>
</tr></thead>
<tfoot><tr>
<td class="left">Thubert</td>
<td class="center">Standards Track</td>
<td class="right">[Page]</td>
</tr></tfoot>
</table>
<div class="document-information" id="external-metadata"></div>
<div class="document-information" id="internal-metadata">
<dl id="identifiers">
<dt class="label-stream">Stream:</dt>
<dd class="stream">Internet Engineering Task Force (IETF)</dd>
<dt class="label-rfc">RFC:</dt>
<dd class="rfc"><a class="eref" href="https://www.rfc-editor.org/rfc/rfc8931">8931</a></dd>
<dt class="label-updates">Updates:</dt>
<dd class="updates">
<a class="eref" href="https://www.rfc-editor.org/rfc/rfc4944">4944</a> </dd>
<dt class="label-category">Category:</dt>
<dd class="category">Standards Track</dd>
<dt class="label-published">Published:</dt>
<dd class="published">
<time class="published" datetime="2020-11">November 2020</time>
    </dd>
<dt class="label-issn">ISSN:</dt>
<dd class="issn">2070-1721</dd>
<dt class="label-authors">Author:</dt>
<dd class="authors">
<div class="author">
      <div class="author-name">P. Thubert, <span class="editor">Ed.</span>
</div>
<div class="org">Cisco Systems</div>
</div>
</dd>
</dl>
</div>
<h1 id="rfcnum">RFC 8931</h1>
<h1 id="title">IPv6 over Low-Power Wireless Personal Area Network (6LoWPAN) Selective Fragment Recovery</h1>
<section id="section-abstract">
      <h2 id="abstract"><a class="selfRef" href="#abstract">Abstract</a></h2>
<p id="section-abstract-1">
        This document updates RFC 4944 with a protocol that forwards individual fragments
        across a route-over mesh and recovers them end to end, with
 congestion control
        capabilities to protect the network.<a class="pilcrow" href="#section-abstract-1">¶</a></p>
</section>
<div id="status-of-memo">
<section id="section-boilerplate.1">
        <h2 id="name-status-of-this-memo">
<a class="section-name selfRef" href="#name-status-of-this-memo">Status of This Memo</a>
        </h2>
<p id="section-boilerplate.1-1">
            This is an Internet Standards Track document.<a class="pilcrow" href="#section-boilerplate.1-1">¶</a></p>
<p id="section-boilerplate.1-2">
            This document is a product of the Internet Engineering Task Force
            (IETF).  It represents the consensus of the IETF community.  It has
            received public review and has been approved for publication by
            the Internet Engineering Steering Group (IESG).  Further
            information on Internet Standards is available in Section 2 of 
            RFC 7841.<a class="pilcrow" href="#section-boilerplate.1-2">¶</a></p>
<p id="section-boilerplate.1-3">
            Information about the current status of this document, any
            errata, and how to provide feedback on it may be obtained at
            <span><a href="https://www.rfc-editor.org/info/rfc8931">https://www.rfc-editor.org/info/rfc8931</a></span>.<a class="pilcrow" href="#section-boilerplate.1-3">¶</a></p>
</section>
</div>
<div id="copyright">
<section id="section-boilerplate.2">
        <h2 id="name-copyright-notice">
<a class="section-name selfRef" href="#name-copyright-notice">Copyright Notice</a>
        </h2>
<p id="section-boilerplate.2-1">
            Copyright (c) 2020 IETF Trust and the persons identified as the
            document authors. All rights reserved.<a class="pilcrow" href="#section-boilerplate.2-1">¶</a></p>
<p id="section-boilerplate.2-2">
            This document is subject to BCP 78 and the IETF Trust's Legal
            Provisions Relating to IETF Documents
            (<span><a href="https://trustee.ietf.org/license-info">https://trustee.ietf.org/license-info</a></span>) in effect on the date of
            publication of this document. Please review these documents
            carefully, as they describe your rights and restrictions with
            respect to this document. Code Components extracted from this
            document must include Simplified BSD License text as described in
            Section 4.e of the Trust Legal Provisions and are provided without
            warranty as described in the Simplified BSD License.<a class="pilcrow" href="#section-boilerplate.2-2">¶</a></p>
</section>
</div>
<div id="toc">
<section id="section-toc.1">
        <a class="toplink" href="#" onclick="scroll(0,0)">▲</a><h2 id="name-table-of-contents">
<a class="section-name selfRef" href="#name-table-of-contents">Table of Contents</a>
        </h2>
<nav class="toc"><ul class="ulEmpty compact toc">
<li class="ulEmpty compact toc" id="section-toc.1-1.1">
            <p class="keepWithNext" id="section-toc.1-1.1.1"><a class="xref" href="#section-1">1</a>.  <a class="xref" href="#name-introduction">Introduction</a><a class="pilcrow" href="#section-toc.1-1.1.1">¶</a></p>
</li>
          <li class="ulEmpty compact toc" id="section-toc.1-1.2">
            <p id="section-toc.1-1.2.1"><a class="xref" href="#section-2">2</a>.  <a class="xref" href="#name-terminology">Terminology</a><a class="pilcrow" href="#section-toc.1-1.2.1">¶</a></p>
<ul class="ulEmpty compact toc">
<li class="ulEmpty compact toc" id="section-toc.1-1.2.2.1">
                <p class="keepWithNext" id="section-toc.1-1.2.2.1.1"><a class="xref" href="#section-2.1">2.1</a>.  <a class="xref" href="#name-requirements-language">Requirements Language</a><a class="pilcrow" href="#section-toc.1-1.2.2.1.1">¶</a></p>
</li>
              <li class="ulEmpty compact toc" id="section-toc.1-1.2.2.2">
                <p class="keepWithNext" id="section-toc.1-1.2.2.2.1"><a class="xref" href="#section-2.2">2.2</a>.  <a class="xref" href="#name-background">Background</a><a class="pilcrow" href="#section-toc.1-1.2.2.2.1">¶</a></p>
</li>
              <li class="ulEmpty compact toc" id="section-toc.1-1.2.2.3">
                <p id="section-toc.1-1.2.2.3.1"><a class="xref" href="#section-2.3">2.3</a>.  <a class="xref" href="#name-other-terms">Other Terms</a><a class="pilcrow" href="#section-toc.1-1.2.2.3.1">¶</a></p>
</li>
            </ul>
</li>
          <li class="ulEmpty compact toc" id="section-toc.1-1.3">
            <p id="section-toc.1-1.3.1"><a class="xref" href="#section-3">3</a>.  <a class="xref" href="#name-updating-rfc-4944">Updating RFC 4944</a><a class="pilcrow" href="#section-toc.1-1.3.1">¶</a></p>
</li>
          <li class="ulEmpty compact toc" id="section-toc.1-1.4">
            <p id="section-toc.1-1.4.1"><a class="xref" href="#section-4">4</a>.  <a class="xref" href="#name-extending-rfc-8930">Extending RFC 8930</a><a class="pilcrow" href="#section-toc.1-1.4.1">¶</a></p>
<ul class="ulEmpty compact toc">
<li class="ulEmpty compact toc" id="section-toc.1-1.4.2.1">
                <p id="section-toc.1-1.4.2.1.1"><a class="xref" href="#section-4.1">4.1</a>.  <a class="xref" href="#name-slack-in-the-first-fragment">Slack in the First Fragment</a><a class="pilcrow" href="#section-toc.1-1.4.2.1.1">¶</a></p>
</li>
              <li class="ulEmpty compact toc" id="section-toc.1-1.4.2.2">
                <p id="section-toc.1-1.4.2.2.1"><a class="xref" href="#section-4.2">4.2</a>.  <a class="xref" href="#name-gap-between-frames">Gap between Frames</a><a class="pilcrow" href="#section-toc.1-1.4.2.2.1">¶</a></p>
</li>
              <li class="ulEmpty compact toc" id="section-toc.1-1.4.2.3">
                <p id="section-toc.1-1.4.2.3.1"><a class="xref" href="#section-4.3">4.3</a>.  <a class="xref" href="#name-congestion-control">Congestion Control</a><a class="pilcrow" href="#section-toc.1-1.4.2.3.1">¶</a></p>
</li>
              <li class="ulEmpty compact toc" id="section-toc.1-1.4.2.4">
                <p id="section-toc.1-1.4.2.4.1"><a class="xref" href="#section-4.4">4.4</a>.  <a class="xref" href="#name-modifying-the-first-fragmen">Modifying the First Fragment</a><a class="pilcrow" href="#section-toc.1-1.4.2.4.1">¶</a></p>
</li>
            </ul>
</li>
          <li class="ulEmpty compact toc" id="section-toc.1-1.5">
            <p id="section-toc.1-1.5.1"><a class="xref" href="#section-5">5</a>.  <a class="xref" href="#name-new-dispatch-types-and-head">New Dispatch Types and Headers</a><a class="pilcrow" href="#section-toc.1-1.5.1">¶</a></p>
<ul class="ulEmpty compact toc">
<li class="ulEmpty compact toc" id="section-toc.1-1.5.2.1">
                <p id="section-toc.1-1.5.2.1.1"><a class="xref" href="#section-5.1">5.1</a>.  <a class="xref" href="#name-recoverable-fragment-dispat">Recoverable Fragment Dispatch Type and Header</a><a class="pilcrow" href="#section-toc.1-1.5.2.1.1">¶</a></p>
</li>
              <li class="ulEmpty compact toc" id="section-toc.1-1.5.2.2">
                <p id="section-toc.1-1.5.2.2.1"><a class="xref" href="#section-5.2">5.2</a>.  <a class="xref" href="#name-rfrag-acknowledgment-dispat">RFRAG Acknowledgment Dispatch Type and Header</a><a class="pilcrow" href="#section-toc.1-1.5.2.2.1">¶</a></p>
</li>
            </ul>
</li>
          <li class="ulEmpty compact toc" id="section-toc.1-1.6">
            <p id="section-toc.1-1.6.1"><a class="xref" href="#section-6">6</a>.  <a class="xref" href="#name-fragment-recovery">Fragment Recovery</a><a class="pilcrow" href="#section-toc.1-1.6.1">¶</a></p>
<ul class="ulEmpty compact toc">
<li class="ulEmpty compact toc" id="section-toc.1-1.6.2.1">
                <p id="section-toc.1-1.6.2.1.1"><a class="xref" href="#section-6.1">6.1</a>.  <a class="xref" href="#name-forwarding-fragments">Forwarding Fragments</a><a class="pilcrow" href="#section-toc.1-1.6.2.1.1">¶</a></p>
<ul class="ulEmpty compact toc">
<li class="ulEmpty compact toc" id="section-toc.1-1.6.2.1.2.1">
                    <p id="section-toc.1-1.6.2.1.2.1.1"><a class="xref" href="#section-6.1.1">6.1.1</a>.  <a class="xref" href="#name-receiving-the-first-fragmen">Receiving the First Fragment</a><a class="pilcrow" href="#section-toc.1-1.6.2.1.2.1.1">¶</a></p>
</li>
                  <li class="ulEmpty compact toc" id="section-toc.1-1.6.2.1.2.2">
                    <p id="section-toc.1-1.6.2.1.2.2.1"><a class="xref" href="#section-6.1.2">6.1.2</a>.  <a class="xref" href="#name-receiving-the-next-fragment">Receiving the Next Fragments</a><a class="pilcrow" href="#section-toc.1-1.6.2.1.2.2.1">¶</a></p>
</li>
                </ul>
</li>
              <li class="ulEmpty compact toc" id="section-toc.1-1.6.2.2">
                <p id="section-toc.1-1.6.2.2.1"><a class="xref" href="#section-6.2">6.2</a>.  <a class="xref" href="#name-receiving-rfrag-acknowledgm">Receiving RFRAG Acknowledgments</a><a class="pilcrow" href="#section-toc.1-1.6.2.2.1">¶</a></p>
</li>
              <li class="ulEmpty compact toc" id="section-toc.1-1.6.2.3">
                <p id="section-toc.1-1.6.2.3.1"><a class="xref" href="#section-6.3">6.3</a>.  <a class="xref" href="#name-aborting-the-transmission-o">Aborting the Transmission of a Fragmented Packet</a><a class="pilcrow" href="#section-toc.1-1.6.2.3.1">¶</a></p>
</li>
              <li class="ulEmpty compact toc" id="section-toc.1-1.6.2.4">
                <p id="section-toc.1-1.6.2.4.1"><a class="xref" href="#section-6.4">6.4</a>.  <a class="xref" href="#name-applying-recoverable-fragme">Applying Recoverable Fragmentation along a Diverse Path</a><a class="pilcrow" href="#section-toc.1-1.6.2.4.1">¶</a></p>
</li>
            </ul>
</li>
          <li class="ulEmpty compact toc" id="section-toc.1-1.7">
            <p id="section-toc.1-1.7.1"><a class="xref" href="#section-7">7</a>.  <a class="xref" href="#name-management-considerations">Management Considerations</a><a class="pilcrow" href="#section-toc.1-1.7.1">¶</a></p>
<ul class="ulEmpty compact toc">
<li class="ulEmpty compact toc" id="section-toc.1-1.7.2.1">
                <p id="section-toc.1-1.7.2.1.1"><a class="xref" href="#section-7.1">7.1</a>.  <a class="xref" href="#name-protocol-parameters">Protocol Parameters</a><a class="pilcrow" href="#section-toc.1-1.7.2.1.1">¶</a></p>
</li>
              <li class="ulEmpty compact toc" id="section-toc.1-1.7.2.2">
                <p id="section-toc.1-1.7.2.2.1"><a class="xref" href="#section-7.2">7.2</a>.  <a class="xref" href="#name-observing-the-network">Observing the Network</a><a class="pilcrow" href="#section-toc.1-1.7.2.2.1">¶</a></p>
</li>
            </ul>
</li>
          <li class="ulEmpty compact toc" id="section-toc.1-1.8">
            <p id="section-toc.1-1.8.1"><a class="xref" href="#section-8">8</a>.  <a class="xref" href="#name-security-considerations">Security Considerations</a><a class="pilcrow" href="#section-toc.1-1.8.1">¶</a></p>
</li>
          <li class="ulEmpty compact toc" id="section-toc.1-1.9">
            <p id="section-toc.1-1.9.1"><a class="xref" href="#section-9">9</a>.  <a class="xref" href="#name-iana-considerations">IANA Considerations</a><a class="pilcrow" href="#section-toc.1-1.9.1">¶</a></p>
</li>
          <li class="ulEmpty compact toc" id="section-toc.1-1.10">
            <p id="section-toc.1-1.10.1"><a class="xref" href="#section-10">10</a>. <a class="xref" href="#name-references">References</a><a class="pilcrow" href="#section-toc.1-1.10.1">¶</a></p>
<ul class="ulEmpty compact toc">
<li class="ulEmpty compact toc" id="section-toc.1-1.10.2.1">
                <p id="section-toc.1-1.10.2.1.1"><a class="xref" href="#section-10.1">10.1</a>.  <a class="xref" href="#name-normative-references">Normative References</a><a class="pilcrow" href="#section-toc.1-1.10.2.1.1">¶</a></p>
</li>
              <li class="ulEmpty compact toc" id="section-toc.1-1.10.2.2">
                <p id="section-toc.1-1.10.2.2.1"><a class="xref" href="#section-10.2">10.2</a>.  <a class="xref" href="#name-informative-references">Informative References</a><a class="pilcrow" href="#section-toc.1-1.10.2.2.1">¶</a></p>
</li>
            </ul>
</li>
          <li class="ulEmpty compact toc" id="section-toc.1-1.11">
            <p id="section-toc.1-1.11.1"><a class="xref" href="#section-appendix.a">Appendix A</a>.  <a class="xref" href="#name-rationale">Rationale</a><a class="pilcrow" href="#section-toc.1-1.11.1">¶</a></p>
</li>
          <li class="ulEmpty compact toc" id="section-toc.1-1.12">
            <p id="section-toc.1-1.12.1"><a class="xref" href="#section-appendix.b">Appendix B</a>.  <a class="xref" href="#name-requirements">Requirements</a><a class="pilcrow" href="#section-toc.1-1.12.1">¶</a></p>
</li>
          <li class="ulEmpty compact toc" id="section-toc.1-1.13">
            <p id="section-toc.1-1.13.1"><a class="xref" href="#section-appendix.c">Appendix C</a>.  <a class="xref" href="#name-considerations-on-congestio">Considerations on Congestion Control</a><a class="pilcrow" href="#section-toc.1-1.13.1">¶</a></p>
</li>
          <li class="ulEmpty compact toc" id="section-toc.1-1.14">
            <p id="section-toc.1-1.14.1"><a class="xref" href="#section-appendix.d"></a><a class="xref" href="#name-acknowledgments">Acknowledgments</a><a class="pilcrow" href="#section-toc.1-1.14.1">¶</a></p>
</li>
          <li class="ulEmpty compact toc" id="section-toc.1-1.15">
            <p id="section-toc.1-1.15.1"><a class="xref" href="#section-appendix.e"></a><a class="xref" href="#name-authors-address">Author's Address</a><a class="pilcrow" href="#section-toc.1-1.15.1">¶</a></p>
</li>
        </ul>
</nav>
</section>
</div>
<div id="introduction">
<section id="section-1">
      <h2 id="name-introduction">
<a class="section-number selfRef" href="#section-1">1. </a><a class="section-name selfRef" href="#name-introduction">Introduction</a>
      </h2>
<p id="section-1-1">

        In most Low-Power and Lossy Network (LLN) applications, the bulk of
        the traffic consists of small chunks of data (on the order of a few bytes
        to a few tens of bytes) at a time. Given that an
        <span><a class="xref" href="#IEEE.802.15.4">IEEE Std 802.15.4</a> [<a class="xref" href="#IEEE.802.15.4">IEEE.802.15.4</a>]</span>
        frame can carry a payload of 74 bytes or more, fragmentation is
        usually not required. However, and though this happens only
        occasionally, a number of mission-critical applications do require
        the capability to transfer larger chunks of data, for instance, to
        support the firmware upgrade of the LLN nodes or the extraction of logs
        from LLN nodes.<a class="pilcrow" href="#section-1-1">¶</a></p>
<p id="section-1-2">
        In the former case, the large chunk of data is
        transferred to the LLN node, whereas in the latter case, the large chunk
        flows away from the LLN node.
        In both cases, the size can be on the
        order of 10 KB or more, and an end-to-end reliable transport
        is required.<a class="pilcrow" href="#section-1-2">¶</a></p>
<p id="section-1-3">
     <span><a class="xref" href="#RFC4944">"Transmission of IPv6 Packets over IEEE 802.15.4
        Networks"</a> [<a class="xref" href="#RFC4944">RFC4944</a>]</span> defines the original IPv6 over Low-Power Wireless Personal Area Network (6LoWPAN) datagram fragmentation
        mechanism for LLNs. One critical issue with this original design is that
        routing an IPv6 <span>[<a class="xref" href="#RFC8200">RFC8200</a>]</span> packet across a route-over mesh
        requires the reassembly of the packet at each hop. <span><a class="xref" href="#I-D.ietf-6tisch-architecture">"An
        Architecture for IPv6 over the TSCH mode of IEEE 802.15.4"</a> [<a class="xref" href="#I-D.ietf-6tisch-architecture">6TiSCH</a>]</span>
        indicates that this may cause latency along a path and impact critical
        resources such as memory and battery; to alleviate those
        undesirable effects, it recommends using a 6LoWPAN Fragment Forwarding
        (6LFF) technique.<a class="pilcrow" href="#section-1-3">¶</a></p>
<p id="section-1-4">

        <span><a class="xref" href="#RFC8930">"On Forwarding 6LoWPAN Fragments over a Multihop IPv6 Network"</a> [<a class="xref" href="#RFC8930">RFC8930</a>]</span> specifies the generic behavior
        that all 6LFF techniques including this specification follow, and it presents
        the associated caveats. In particular, the routing information is fully
        indicated in the first fragment, which is always forwarded first.
        With this specification, the first fragment is identified by a Sequence
        of 0 as opposed to a dispatch type in <span>[<a class="xref" href="#RFC4944">RFC4944</a>]</span>.
        A state is formed and used to forward all the next fragments along the
        same path. The Datagram_Tag is locally significant to the Layer 2 source
        of the packet and is swapped at each hop; see <a class="xref" href="#ffc">Section 6</a>.
        This specification encodes the Datagram_Tag in 1 byte, which will
        saturate if more than 256 datagrams transit in fragmented
        form over a single hop at the same time.
        This is not realistic at the time of this writing.
        Should this happen in a new 6LoWPAN technology, a node will need to use
        several link-layer addresses to increase its indexing capacity.<a class="pilcrow" href="#section-1-4">¶</a></p>
<p id="section-1-5">
        <span><a class="xref" href="#I-D.ietf-lwig-6lowpan-virtual-reassembly">"Virtual reassembly buffers in 6LoWPAN"</a> [<a class="xref" href="#I-D.ietf-lwig-6lowpan-virtual-reassembly">LWIG-FRAG</a>]</span> proposes a 6LFF
        technique that is compatible with <span>[<a class="xref" href="#RFC4944">RFC4944</a>]</span> without the
        need to define a new protocol.
        However, adding that capability alone to the local implementation of the
        original 6LoWPAN fragmentation would not address the inherent fragility
        of fragmentation (see <span>[<a class="xref" href="#RFC8900">RFC8900</a>]</span>), in
        particular, the issues of resources locked on the reassembling endpoint and the wasted
        transmissions due to the loss of a single fragment in a whole datagram.
        <span>[<a class="xref" href="#Kent">Kent</a>]</span> compares the unreliable delivery of fragments with
        a mechanism it calls "selective acknowledgments" that recovers the loss
        of a fragment individually. The paper illustrates the benefits that can
        be derived from such a method; see Figures 1, 2, and 3 in Section 2.3 of <span>[<a class="xref" href="#Kent">Kent</a>]</span>.
        <span>[<a class="xref" href="#RFC4944">RFC4944</a>]</span> has no selective recovery, and the whole datagram
        fails when one fragment is not delivered to the reassembling  endpoint.
        Constrained memory resources are blocked on the reassembling endpoint until
        it times out, possibly causing the loss of subsequent packets
        that cannot be received for the lack of buffers.<a class="pilcrow" href="#section-1-5">¶</a></p>
<p id="section-1-6">
        That problem is exacerbated when forwarding fragments over multiple hops
        since a loss at an intermediate hop will not be discovered by either the
        fragmenting or the reassembling endpoints. Should this happen, the source will keep on sending
        fragments, wasting even more resources in the network since the datagram
        cannot arrive in its entirety, which possibly contributes to the
        condition that caused the loss.
        <span>[<a class="xref" href="#RFC4944">RFC4944</a>]</span> is lacking a congestion control to avoid
        participating in a saturation that may have caused the loss of the
        fragment.
        It has no signaling to abort a multi-fragment transmission at any
        time and from either end, and if the
        capability to forward fragments is implemented, clean up the related
        state in the network.<a class="pilcrow" href="#section-1-6">¶</a></p>
<p id="section-1-7">
        This specification provides a method to forward fragments over, typically,
        a few hops in a route-over 6LoWPAN mesh and a selective acknowledgment
        to recover individual fragments between 6LoWPAN endpoints. The method
        can help limit the congestion loss in the network and addresses the
        requirements in <a class="xref" href="#req">Appendix B</a>. Flow control is out of scope since
        the endpoints are expected to be able to store the full datagram.
        Deployments are expected to be managed and homogeneous, and an
        incremental transition requires a flag day.<a class="pilcrow" href="#section-1-7">¶</a></p>
</section>
</div>
<section id="section-2">
      <h2 id="name-terminology">
<a class="section-number selfRef" href="#section-2">2. </a><a class="section-name selfRef" href="#name-terminology">Terminology</a>
      </h2>
<div id="bcp">
<section id="section-2.1">
        <h3 id="name-requirements-language">
<a class="section-number selfRef" href="#section-2.1">2.1. </a><a class="section-name selfRef" href="#name-requirements-language">Requirements Language</a>
        </h3>
<p id="section-2.1-1">
    The key words "<span class="bcp14">MUST</span>", "<span class="bcp14">MUST NOT</span>", "<span class="bcp14">REQUIRED</span>", "<span class="bcp14">SHALL</span>", "<span class="bcp14">SHALL NOT</span>", "<span class="bcp14">SHOULD</span>", "<span class="bcp14">SHOULD NOT</span>", "<span class="bcp14">RECOMMENDED</span>", "<span class="bcp14">NOT RECOMMENDED</span>",
    "<span class="bcp14">MAY</span>", and "<span class="bcp14">OPTIONAL</span>" in this document are to be interpreted as
    described in BCP 14 <span>[<a class="xref" href="#RFC2119">RFC2119</a>]</span> <span>[<a class="xref" href="#RFC8174">RFC8174</a>]</span>
    when, and only when, they appear in all capitals, as shown here.<a class="pilcrow" href="#section-2.1-1">¶</a></p>
</section>
</div>
<div id="lo">
<section id="section-2.2">
        <h3 id="name-background">
<a class="section-number selfRef" href="#section-2.2">2.2. </a><a class="section-name selfRef" href="#name-background">Background</a>
        </h3>
<p id="section-2.2-1">
 This document uses 6LoWPAN terms and concepts
 that are presented in  <span><a class="xref" href="#RFC4919">"IPv6 over Low-Power
 Wireless Personal Area Networks (6LoWPANs): Overview, Assumptions,
     Problem Statement, and Goals"</a> [<a class="xref" href="#RFC4919">RFC4919</a>]</span>; <span><a class="xref" href="#RFC4944">"Transmission of IPv6 Packets over IEEE 802.15.4 Networks"</a> [<a class="xref" href="#RFC4944">RFC4944</a>]</span>; and
        <span><a class="xref" href="#RFC6606">"Problem Statement and Requirements for
 IPv6 over Low-Power Wireless Personal Area Network (6LoWPAN)
 Routing"</a> [<a class="xref" href="#RFC6606">RFC6606</a>]</span>.<a class="pilcrow" href="#section-2.2-1">¶</a></p>
<p id="section-2.2-2"><span>[<a class="xref" href="#RFC8930">RFC8930</a>]</span> discusses the generic concept
        of a  Virtual Reassembly Buffer (VRB) and specifies behaviors
        and caveats that are common to a large family of 6LFF techniques
        including the mechanism specified by this document,
        which is fully inherited from that specification.
        It also defines terms used in this document:  Compressed Form,
        Datagram_Tag, Datagram_Size, Fragment_Offset, and
        6LoWPAN Fragment Forwarding endpoint (commonly abbreviated as only
        "endpoint").<a class="pilcrow" href="#section-2.2-2">¶</a></p>
<p id="section-2.2-3">
 Past experience with fragmentation has shown that misassociated or lost
        fragments can lead to poor network behavior and, occasionally, trouble
        at the application layer. The reader is encouraged to read
 <span><a class="xref" href="#RFC4963">"IPv4 Reassembly Errors at High Data Rates"</a> [<a class="xref" href="#RFC4963">RFC4963</a>]</span>
        and follow the references for more information.
 That experience led to the definition of the <span><a class="xref" href="#RFC8201">"Path
        MTU Discovery for IP version 6"</a> [<a class="xref" href="#RFC8201">RFC8201</a>]</span> protocol that limits fragmentation over the
        Internet.
 Specifically, in the case of UDP, valuable additional information can be
        found in <span><a class="xref" href="#RFC8085">"UDP Usage Guidelines"</a> [<a class="xref" href="#RFC8085">RFC8085</a>]</span>.<a class="pilcrow" href="#section-2.2-3">¶</a></p>
<p id="section-2.2-4"><span><a class="xref" href="#RFC8087">"The Benefits of Using Explicit Congestion Notification (ECN)"</a> [<a class="xref" href="#RFC8087">RFC8087</a>]</span>
        provides useful information on the potential benefits and pitfalls of
        using ECN.<a class="pilcrow" href="#section-2.2-4">¶</a></p>
<p id="section-2.2-5">Quoting <span><a class="xref" href="#RFC3031">"Multiprotocol Label Switching Architecture"</a> [<a class="xref" href="#RFC3031">RFC3031</a>]</span>:<a class="pilcrow" href="#section-2.2-5">¶</a></p>
<blockquote id="section-2.2-6">With MPLS, "packets are "labeled" before they are forwarded [along a Label Switched
        Path (LSP)]. At subsequent hops, there is no further analysis of the packet's
        network layer header. Rather, the label is used as an index into a
        table which specifies the next hop, and a new label".<a class="pilcrow" href="#section-2.2-6">¶</a>
</blockquote>
<p id="section-2.2-7">
        <span>[<a class="xref" href="#RFC8930">RFC8930</a>]</span> leverages
        MPLS to forward fragments that actually
        do not have a network-layer header, since the fragmentation occurs below
        IP, and this specification makes it reversible so the reverse path can
        be followed as well.<a class="pilcrow" href="#section-2.2-7">¶</a></p>
</section>
</div>
<div id="new">
<section id="section-2.3">
        <h3 id="name-other-terms">
<a class="section-number selfRef" href="#section-2.3">2.3. </a><a class="section-name selfRef" href="#name-other-terms">Other Terms</a>
        </h3>
<p id="section-2.3-1">
    This specification uses the following terms:<a class="pilcrow" href="#section-2.3-1">¶</a></p>
<span class="break"></span><dl class="dlParallel" id="section-2.3-2">
          <dt id="section-2.3-2.1">RFRAG:</dt>
          <dd id="section-2.3-2.2" style="margin-left: 1.5em">Recoverable Fragment<a class="pilcrow" href="#section-2.3-2.2">¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-2.3-2.3">RFRAG-ACK:</dt>
          <dd id="section-2.3-2.4" style="margin-left: 1.5em">Recoverable Fragment Acknowledgment<a class="pilcrow" href="#section-2.3-2.4">¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-2.3-2.5">RFRAG Acknowledgment Request:</dt>
          <dd id="section-2.3-2.6" style="margin-left: 1.5em">An RFRAG with the
       Acknowledgment Request flag ("X" flag) set.<a class="pilcrow" href="#section-2.3-2.6">¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-2.3-2.7">NULL bitmap:</dt>
          <dd id="section-2.3-2.8" style="margin-left: 1.5em">Refers to a bitmap with all bits set to zero.<a class="pilcrow" href="#section-2.3-2.8">¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-2.3-2.9">FULL bitmap:</dt>
          <dd id="section-2.3-2.10" style="margin-left: 1.5em">Refers to a bitmap with all bits set to one.<a class="pilcrow" href="#section-2.3-2.10">¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-2.3-2.11">Reassembling endpoint:</dt>
          <dd id="section-2.3-2.12" style="margin-left: 1.5em">The receiving endpoint.<a class="pilcrow" href="#section-2.3-2.12">¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-2.3-2.13">Fragmenting endpoint:</dt>
          <dd id="section-2.3-2.14" style="margin-left: 1.5em">The sending endpoint.<a class="pilcrow" href="#section-2.3-2.14">¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-2.3-2.15">Forward direction:</dt>
          <dd id="section-2.3-2.16" style="margin-left: 1.5em">The direction of a path, which is followed by the RFRAG.<a class="pilcrow" href="#section-2.3-2.16">¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-2.3-2.17">Reverse direction:</dt>
          <dd id="section-2.3-2.18" style="margin-left: 1.5em">The reverse direction of a path, which is taken by the
       RFRAG-ACK.<a class="pilcrow" href="#section-2.3-2.18">¶</a>
</dd>
        <dd class="break"></dd>
</dl>
<p id="section-2.3-3"></p>
</section>
</div>
</section>
<section id="section-3">
      <h2 id="name-updating-rfc-4944">
<a class="section-number selfRef" href="#section-3">3. </a><a class="section-name selfRef" href="#name-updating-rfc-4944">Updating RFC 4944</a>
      </h2>
<p id="section-3-1">This specification updates the fragmentation mechanism that is
    specified in <span>[<a class="xref" href="#RFC4944">RFC4944</a>]</span> for use in route-over
    LLNs by providing a model where fragments can be forwarded
    end to end across a 6LoWPAN LLN and where fragments that are lost on
    the way can be recovered individually.
    A new format for fragments is introduced, and new dispatch types are defined
    in <a class="xref" href="#dispatch">Section 5</a>.<a class="pilcrow" href="#section-3-1">¶</a></p>
<p id="section-3-2">
    <span>[<a class="xref" href="#RFC8138">RFC8138</a>]</span> allows modifying the size of a packet en route by
    removing the consumed hops in a compressed Routing Header.
    This requires that
    Fragment_Offset and Datagram_Size (defined in <a class="xref" href="#RF2">Section 5.1</a>) also be
    modified en route, which is difficult to do in the uncompressed form.
    This specification expresses those fields in the compressed form and
    allows modifying them en route easily (more in <a class="xref" href="#mod">Section 4.4</a>).<a class="pilcrow" href="#section-3-2">¶</a></p>
<p id="section-3-3">
    To be consistent with <span><a class="relref" href="https://www.rfc-editor.org/rfc/rfc6282#section-2">Section 2</a> of [<a class="xref" href="#RFC6282">RFC6282</a>]</span>, for the
    fragmentation mechanism described in <span><a class="relref" href="https://www.rfc-editor.org/rfc/rfc4944#section-5.3">Section 5.3</a> of [<a class="xref" href="#RFC4944">RFC4944</a>]</span>,
    any header that cannot fit within the first fragment <span class="bcp14">MUST NOT</span> be compressed
    when using the fragmentation mechanism described in this specification.<a class="pilcrow" href="#section-3-3">¶</a></p>
</section>
<section id="section-4">
      <h2 id="name-extending-rfc-8930">
<a class="section-number selfRef" href="#section-4">4. </a><a class="section-name selfRef" href="#name-extending-rfc-8930">Extending RFC 8930</a>
      </h2>
<p id="section-4-1">This specification implements the generic 6LFF technique defined in
    <span>[<a class="xref" href="#RFC8930">RFC8930</a>]</span> and provides end-to-end fragment
    recovery and congestion control mechanisms.<a class="pilcrow" href="#section-4-1">¶</a></p>
<section id="section-4.1">
        <h3 id="name-slack-in-the-first-fragment">
<a class="section-number selfRef" href="#section-4.1">4.1. </a><a class="section-name selfRef" href="#name-slack-in-the-first-fragment">Slack in the First Fragment</a>
        </h3>
<p id="section-4.1-1">
    <span>[<a class="xref" href="#RFC8930">RFC8930</a>]</span> allows for a refragmentation operation
    in intermediate nodes, whereby the trailing bytes from a given fragment may be
    left in the VRB to be added as the heading bytes in the next fragment.
    This solves the case when the outgoing fragment needs more space than the incoming fragment; that case may arise when
    the 6LoWPAN header compression is not as efficient on the outgoing link or
    if the Link MTU is reduced.<a class="pilcrow" href="#section-4.1-1">¶</a></p>
<p id="section-4.1-2">
    This specification cannot allow that refragmentation operation since
    the fragments are recovered end to end based on a sequence number. The
    Fragment_Size <span class="bcp14">MUST</span> be tailored to fit the minimal MTU along the path, and
    the first fragment that contains a 6LoWPAN compressed header <span class="bcp14">MUST</span> have enough
    slack to enable a less-efficient compression in the next hops to still
    fit within the Link MTU.<a class="pilcrow" href="#section-4.1-2">¶</a></p>
<p id="section-4.1-3">
    For instance, if the fragmenting endpoint is also the 6LoWPAN compression endpoint, it will
    elide the Interface ID (IID) of the source IPv6 address when it matches the link-layer address
    <span>[<a class="xref" href="#RFC6282">RFC6282</a>]</span>. In that case, it <span class="bcp14">MUST</span> leave slack in the first fragment as the if MTU on the first hop was 8 bytes less, so the next hop can expand the IID within the same fragment within MTU.<a class="pilcrow" href="#section-4.1-3">¶</a></p>
</section>
<div id="gap">
<section id="section-4.2">
        <h3 id="name-gap-between-frames">
<a class="section-number selfRef" href="#section-4.2">4.2. </a><a class="section-name selfRef" href="#name-gap-between-frames">Gap between Frames</a>
        </h3>
<p id="section-4.2-1"><span>[<a class="xref" href="#RFC8930">RFC8930</a>]</span> requires that a
    configurable interval of time be inserted between transmissions to the same
    next hop and, in particular, between fragments of a same datagram.
    In the case of half duplex interfaces, this inter-frame gap ensures that the
    next hop is done forwarding the previous frame and is capable of receiving
    the next one.<a class="pilcrow" href="#section-4.2-1">¶</a></p>
<p id="section-4.2-2">
    In the case of a mesh operating at a single frequency with omnidirectional
    antennas, a larger inter-frame gap is required to protect the frame against
    hidden terminal collisions with the previous frame of the same flow that is
    still progressing along a common path.<a class="pilcrow" href="#section-4.2-2">¶</a></p>
<p id="section-4.2-3">
    The inter-frame gap is useful even for unfragmented datagrams, but it
    becomes a necessity for fragments that are typically generated in a fast
    sequence and are all sent over the exact same path.<a class="pilcrow" href="#section-4.2-3">¶</a></p>
</section>
</div>
<section id="section-4.3">
        <h3 id="name-congestion-control">
<a class="section-number selfRef" href="#section-4.3">4.3. </a><a class="section-name selfRef" href="#name-congestion-control">Congestion Control</a>
        </h3>
<p id="section-4.3-1">
    The inter-frame gap is the only protection that
    <span>[<a class="xref" href="#RFC8930">RFC8930</a>]</span> imposes by default. This
    document enables grouping fragments in windows and requesting intermediate
    acknowledgments, so the number of in-flight fragments can be bounded.
    This document also adds an
    ECN mechanism that can be used to protect the network by adapting the
    size of the window, the size of the fragments, and/or the inter-frame gap.<a class="pilcrow" href="#section-4.3-1">¶</a></p>
<p id="section-4.3-2">
    This specification enables the fragmenting endpoint to apply a congestion control
    mechanism to tune those parameters, but the mechanism itself is out of scope.
    In most cases, the expectation is that most datagrams will require only a
    few fragments, and that only the last fragment will be acknowledged. A
    basic implementation of the fragmenting endpoint is NOT <span class="bcp14">REQUIRED</span> to vary
    the size of the window, the duration of the inter-frame gap, or the size of a
    fragment in the middle of the transmission of a datagram, and it <span class="bcp14">MAY</span> ignore
    the ECN signal or simply reset the window to 1 (see <a class="xref" href="#onECN">Appendix C</a>)
    until the end of this datagram upon detecting a congestion.<a class="pilcrow" href="#section-4.3-2">¶</a></p>
<p id="section-4.3-3">
    An intermediate node that experiences a congestion <span class="bcp14">MAY</span> set the ECN bit in a
    fragment, and the reassembling endpoint echoes the ECN bit at most once at
    the next opportunity to acknowledge back.<a class="pilcrow" href="#section-4.3-3">¶</a></p>
<p id="section-4.3-4">
    The size of the fragments is typically computed from the
    Link MTU to maximize the size of the resulting  frames.
    The size of the window and the duration of the inter-frame
    gap <span class="bcp14">SHOULD</span> be configurable, to reduce the chances of congestion and to
    follow the general recommendations
    in <span>[<a class="xref" href="#RFC8930">RFC8930</a>]</span>, respectively.<a class="pilcrow" href="#section-4.3-4">¶</a></p>
</section>
<div id="mod">
<section id="section-4.4">
        <h3 id="name-modifying-the-first-fragmen">
<a class="section-number selfRef" href="#section-4.4">4.4. </a><a class="section-name selfRef" href="#name-modifying-the-first-fragmen">Modifying the First Fragment</a>
        </h3>
<p id="section-4.4-1">
    The compression of the hop limit, of the source and destination addresses
    in the IPv6 header, and of the Routing Header, which are all in the first fragment, may change en route in a
    route-over mesh LLN.
    If the size of the first fragment is modified, then the intermediate node
    <span class="bcp14">MUST</span> adapt the Datagram_Size, encoded in the Fragment_Size field,
    to reflect that difference.<a class="pilcrow" href="#section-4.4-1">¶</a></p>
<p id="section-4.4-2">
    The intermediate node <span class="bcp14">MUST</span> also save the difference of Datagram_Size of the
    first fragment in the VRB and add it to the Fragment_Offset of all the
    subsequent fragments that it forwards for that datagram. In the case of a Source Routing 
    Header 6LoWPAN Routing Header (SRH-6LoRH)
    <span>[<a class="xref" href="#RFC8138">RFC8138</a>]</span> being consumed and thus reduced, that
    difference is negative, meaning that the Fragment_Offset is decremented by
    the number of bytes that were consumed.<a class="pilcrow" href="#section-4.4-2">¶</a></p>
</section>
</div>
</section>
<div id="dispatch">
<section id="section-5">
      <h2 id="name-new-dispatch-types-and-head">
<a class="section-number selfRef" href="#section-5">5. </a><a class="section-name selfRef" href="#name-new-dispatch-types-and-head">New Dispatch Types and Headers</a>
      </h2>
<p id="section-5-1"> This document specifies an alternative to the 6LoWPAN fragmentation
    sub-layer <span>[<a class="xref" href="#RFC4944">RFC4944</a>]</span> to emulate a Link MTU up to 2048 bytes
    for the upper layer, which can be the 6LoWPAN header compression sub-layer
    that is defined in <span><a class="xref" href="#RFC6282">"Compression Format for IPv6
    Datagrams over IEEE 802.15.4-Based Networks"</a> [<a class="xref" href="#RFC6282">RFC6282</a>]</span>. This specification also provides a reliable
    transmission of the fragments over a multi-hop 6LoWPAN route-over mesh
    network and a minimal congestion control to reduce the chances of congestion loss.<a class="pilcrow" href="#section-5-1">¶</a></p>
<p id="section-5-2">
     A 6LoWPAN Fragment Forwarding <span>[<a class="xref" href="#RFC8930">RFC8930</a>]</span>
     technique derived from MPLS enables the forwarding of individual fragments
     across a 6LoWPAN route-over mesh without reassembly at each hop.
     The Datagram_Tag is used as a label; it is locally unique to the
     node that owns the source link-layer address of the fragment, so together
     the link-layer address and the label can identify the fragment globally
     within the lifetime of the datagram.
     A node may build the Datagram_Tag in its own locally significant way,
     as long as the chosen Datagram_Tag stays unique to the particular datagram
     for its lifetime.
     The result is that the label does not need to be globally unique, but
     it must be swapped at each hop as the source link-layer address changes.<a class="pilcrow" href="#section-5-2">¶</a></p>
<p id="section-5-3">
 In the following sections, a Datagram_Tag extends the semantics defined in
    "Fragmentation Type and Header" (see <span><a class="relref" href="https://www.rfc-editor.org/rfc/rfc4944#section-5.3">Section 5.3</a> of [<a class="xref" href="#RFC4944">RFC4944</a>]</span>).
    The Datagram_Tag is a locally unique identifier for the datagram from the
    perspective of the sender. This means that the Datagram_Tag identifies a
    datagram uniquely in the network when associated with the source of the
    datagram. As the datagram gets forwarded, the source changes, and the
    Datagram_Tag must be swapped as detailed in
    <span>[<a class="xref" href="#RFC8930">RFC8930</a>]</span>.<a class="pilcrow" href="#section-5-3">¶</a></p>
<p id="section-5-4">This specification extends <span>[<a class="xref" href="#RFC4944">RFC4944</a>]</span>
 with two new dispatch types for RFRAG and the RFRAG-ACK that is received back.

    The new 6LoWPAN dispatch types are taken from
    <span>[<a class="xref" href="#RFC8025">RFC8025</a>]</span>, as indicated in <a class="xref" href="#difig">Table 1</a>
    of <a class="xref" href="#ianacon">Section 9</a>.<a class="pilcrow" href="#section-5-4">¶</a></p>
<div id="RF2">
<section id="section-5.1">
        <h3 id="name-recoverable-fragment-dispat">
<a class="section-number selfRef" href="#section-5.1">5.1. </a><a class="section-name selfRef" href="#name-recoverable-fragment-dispat">Recoverable Fragment Dispatch Type and Header</a>
        </h3>
<p id="section-5.1-1">
 In this specification, if the packet is compressed, the size and offset
    of the fragments are expressed with respect to the compressed form of the
    packet, as opposed to the uncompressed (native) form.<a class="pilcrow" href="#section-5.1-1">¶</a></p>
<p id="section-5.1-2">
 The format of the fragment header is shown in <a class="xref" href="#RFfigalt">Figure 1</a>.
    It is the same for all fragments even though the Fragment_Offset is overloaded.
    The format has a length and an offset, as
    well as a Sequence field. This would be redundant if the offset was computed
    as the product of the Sequence by the length, but this is not the case.
    The position of a fragment in the
    reassembly buffer is correlated with neither the value of the Sequence
    field nor the order in which the fragments are received.
    This enables splitting fragments to cope with an MTU deduction; see the example of
    fragment Sequence 5 that is retried end to end as smaller fragment Sequences 13
    and 14 in <a class="xref" href="#ura">Section 6.2</a>.<a class="pilcrow" href="#section-5.1-2">¶</a></p>
<p id="section-5.1-3">
    The first fragment is recognized by a Sequence of 0; it carries its
    Fragment_Size and the Datagram_Size of the compressed packet before it is
    fragmented, whereas the other fragments carry their Fragment_Size and
    Fragment_Offset. The last fragment
    for a datagram is recognized when its Fragment_Offset and its Fragment_Size
    add up to the stored Datagram_Size of the packet identified by the
    sender link-layer address and the Datagram_Tag.<a class="pilcrow" href="#section-5.1-3">¶</a></p>
<span id="name-rfrag-dispatch-type-and-hea"></span><div id="RFfigalt">
<figure id="figure-1">
          <div class="artwork art-text alignCenter" id="section-5.1-4.1">
<pre>                           1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
                                    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                                    |1 1 1 0 1 0 0|E|  Datagram_Tag |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |X| Sequence|   Fragment_Size   |       Fragment_Offset         |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                                             X set == Ack-Request
</pre>
</div>
<figcaption><a class="selfRef" href="#figure-1">Figure 1</a>:
<a class="selfRef" href="#name-rfrag-dispatch-type-and-hea">RFRAG Dispatch Type and Header</a>
          </figcaption></figure>
</div>
<span class="break"></span><dl class="dlParallel" id="section-5.1-5">
          <dt id="section-5.1-5.1">X:</dt>
          <dd id="section-5.1-5.2" style="margin-left: 1.5em">1 bit; Ack-Request. When set, the fragmenting endpoint requires an
       RFRAG Acknowledgment from the reassembling endpoint.<a class="pilcrow" href="#section-5.1-5.2">¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-5.1-5.3">E:</dt>
          <dd id="section-5.1-5.4" style="margin-left: 1.5em">1 bit; Explicit Congestion Notification. The "E"
       flag is cleared by the source of the fragment and set by intermediate
       routers to signal that this fragment experienced congestion along
       its path.<a class="pilcrow" href="#section-5.1-5.4">¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-5.1-5.5">Fragment_Size:</dt>
          <dd id="section-5.1-5.6" style="margin-left: 1.5em">10-bit unsigned integer. The size of this
       fragment in a unit that depends on link-layer technology. Unless
       overridden by a more specific specification, that unit is the byte,
       which allows fragments up to 1023 bytes.<a class="pilcrow" href="#section-5.1-5.6">¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-5.1-5.7">Datagram_Tag:</dt>
          <dd id="section-5.1-5.8" style="margin-left: 1.5em">8 bits. An identifier of the datagram that
       is locally unique to the link-layer sender.<a class="pilcrow" href="#section-5.1-5.8">¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-5.1-5.9">Sequence:</dt>
          <dd id="section-5.1-5.10" style="margin-left: 1.5em">5-bit unsigned integer.
       The sequence number of the fragment in the acknowledgment bitmap.
       Fragments are numbered as [0..N], where N is in [0..31].
       A Sequence of 0 indicates the first fragment in a datagram, but non-zero
       values are not indicative of the position in the reassembly buffer.<a class="pilcrow" href="#section-5.1-5.10">¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-5.1-5.11">Fragment_Offset:</dt>
          <dd id="section-5.1-5.12" style="margin-left: 1.5em">
            <p id="section-5.1-5.12.1">16-bit unsigned integer.<a class="pilcrow" href="#section-5.1-5.12.1">¶</a></p>
<p id="section-5.1-5.12.2">
       When the Fragment_Offset is set to a non-zero value, its semantics depend
       on the value of the Sequence field as follows:<a class="pilcrow" href="#section-5.1-5.12.2">¶</a></p>
<ul class="normal">
<li class="normal" id="section-5.1-5.12.3.1">
       For a first fragment (i.e., with a Sequence of 0), this field indicates
       the Datagram_Size of the compressed datagram, to help the reassembling endpoint
       allocate an adapted buffer for the reception and reassembly operations.
       The fragment may be stored for local reassembly. Alternatively, it may be
       routed based on the destination IPv6 address. In that case, a VRB state
       must be installed as described in <a class="xref" href="#ff">Section 6.1.1</a>.<a class="pilcrow" href="#section-5.1-5.12.3.1">¶</a>
</li>
              <li class="normal" id="section-5.1-5.12.3.2">
       When the Sequence is not 0, this field indicates the offset of the
       fragment in the compressed form of the datagram. The fragment may be
       added to a local reassembly buffer or forwarded based on an existing
       VRB as described in <a class="xref" href="#nf">Section 6.1.2</a>.<a class="pilcrow" href="#section-5.1-5.12.3.2">¶</a>
</li>
            </ul>
<p id="section-5.1-5.12.4">
       A Fragment_Offset that is set to a value of 0 indicates
       an abort condition, and all states regarding the datagram should be
       cleaned up once the processing of the fragment is complete;
       the processing of the fragment depends on whether there is a VRB already
       established for this datagram and if the next hop is still reachable:<a class="pilcrow" href="#section-5.1-5.12.4">¶</a></p>
<ul class="normal">
<li class="normal" id="section-5.1-5.12.5.1">
       if a VRB already exists and the next hop is still reachable, the fragment
       is to be
       forwarded along the associated LSP
       as described in <a class="xref" href="#nf">Section 6.1.2</a>, without checking the value
       of the Sequence field.<a class="pilcrow" href="#section-5.1-5.12.5.1">¶</a>
</li>
              <li class="normal" id="section-5.1-5.12.5.2">
       else, if the Sequence is 0, then the fragment is to be routed as
       described in <a class="xref" href="#ff">Section 6.1.1</a>, but no state is conserved afterwards.
       In that case, the session, if it exists, is aborted, and the packet is
       also forwarded in an attempt to clean up the next hops along the
       path indicated by the IPv6 header (possibly including a Routing Header).<a class="pilcrow" href="#section-5.1-5.12.5.2">¶</a>
</li>
              <li class="normal" id="section-5.1-5.12.5.3">
       else (the Sequence is non-zero and either no VRB exists or the next hop
       is unavailable), the fragment cannot be forwarded or routed; the fragment
       is discarded and an abort RFRAG-ACK
       is sent back to the source as described in <a class="xref" href="#nf">Section 6.1.2</a>.<a class="pilcrow" href="#section-5.1-5.12.5.3">¶</a>
</li>
            </ul>
<p id="section-5.1-5.12.6"></p>
</dd>
        <dd class="break"></dd>
</dl>
<p id="section-5.1-6">
 Recoverable Fragments are sequenced, and a bitmap is used in the RFRAG
    Acknowledgment to indicate the received fragments by setting the individual
    bits that correspond to their sequence.<a class="pilcrow" href="#section-5.1-6">¶</a></p>
<p id="section-5.1-7">
    There is no requirement on the reassembling endpoint to check that the
    received fragments are consecutive and non-overlapping.

    This may be useful, in particular, in the case where the MTU changes and a
    fragment Sequence is retried with a smaller Fragment_Size, with the remainder of
    the original fragment being retried with new Sequence values.

    The fragmenting endpoint knows that the datagram is fully received
    when the acknowledged fragments cover the whole datagram, which is implied
    by a FULL bitmap.<a class="pilcrow" href="#section-5.1-7">¶</a></p>
</section>
</div>
<div id="ackfrag">
<section id="section-5.2">
        <h3 id="name-rfrag-acknowledgment-dispat">
<a class="section-number selfRef" href="#section-5.2">5.2. </a><a class="section-name selfRef" href="#name-rfrag-acknowledgment-dispat">RFRAG Acknowledgment Dispatch Type and Header</a>
        </h3>
<p id="section-5.2-1">This specification also defines a 4-byte RFRAG Acknowledgment Bitmap
       that is used by the reassembling endpoint
       to selectively confirm the reception of individual fragments.
       A given offset in the bitmap maps one to one with a given sequence number
       and indicates which fragment is acknowledged as follows:<a class="pilcrow" href="#section-5.2-1">¶</a></p>
<span id="name-rfrag-acknowledgment-bitmap"></span><div id="dCack3">
<figure id="figure-2">
          <div class="artwork art-text alignCenter" id="section-5.2-2.1">
<pre>                         1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |           RFRAG Acknowledgment Bitmap                         |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     ^                 ^
     |                 |    bitmap indicating whether:
     |                 +----- Fragment with Sequence 9 was received
     +----------------------- Fragment with Sequence 0 was received
</pre>
</div>
<figcaption><a class="selfRef" href="#figure-2">Figure 2</a>:
<a class="selfRef" href="#name-rfrag-acknowledgment-bitmap">RFRAG Acknowledgment Bitmap Encoding</a>
          </figcaption></figure>
</div>
<p id="section-5.2-3">    <a class="xref" href="#dCack2">Figure 3</a> shows an example RFRAG Acknowledgment Bitmap that
       indicates that all fragments from Sequence 0 to 20 were received, except
       for fragments 1, 2, and 16, which were lost and must be retried.<a class="pilcrow" href="#section-5.2-3">¶</a></p>
<span id="name-example-rfrag-acknowledgmen"></span><div id="dCack2">
<figure id="figure-3">
          <div class="artwork art-text alignCenter" id="section-5.2-4.1">
<pre>                         1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |1|0|0|1|1|1|1|1|1|1|1|1|1|1|1|1|0|1|1|1|1|0|0|0|0|0|0|0|0|0|0|0|
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>
</div>
<figcaption><a class="selfRef" href="#figure-3">Figure 3</a>:
<a class="selfRef" href="#name-example-rfrag-acknowledgmen">Example RFRAG Acknowledgment Bitmap</a>
          </figcaption></figure>
</div>
<p id="section-5.2-5">The RFRAG Acknowledgment Bitmap is included in
 an RFRAG Acknowledgment header, as follows:<a class="pilcrow" href="#section-5.2-5">¶</a></p>
<span id="name-rfrag-acknowledgment-dispatc"></span><div id="ackfig">
<figure id="figure-4">
          <div class="artwork art-text alignCenter" id="section-5.2-6.1">
<pre>
                         1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
                                    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                                    |1 1 1 0 1 0 1|E|  Datagram_Tag |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |          RFRAG Acknowledgment Bitmap (32 bits)                |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>
</div>
<figcaption><a class="selfRef" href="#figure-4">Figure 4</a>:
<a class="selfRef" href="#name-rfrag-acknowledgment-dispatc">RFRAG Acknowledgment Dispatch Type and Header</a>
          </figcaption></figure>
</div>
<span class="break"></span><dl class="dlParallel" id="section-5.2-7">
          <dt id="section-5.2-7.1">E:</dt>
          <dd id="section-5.2-7.2" style="margin-left: 1.5em">1 bit; Explicit Congestion Notification Echo.<a class="pilcrow" href="#section-5.2-7.2">¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-5.2-7.3"></dt>
          <dd id="section-5.2-7.4" style="margin-left: 1.5em">When set, the fragmenting endpoint indicates that at least one of the acknowledged fragments
 was received with an Explicit Congestion Notification, indicating that the
 path followed by the fragments is subject to congestion. See more details in
        <a class="xref" href="#onECN">Appendix C</a>.<a class="pilcrow" href="#section-5.2-7.4">¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-5.2-7.5">Datagram_Tag:</dt>
          <dd id="section-5.2-7.6" style="margin-left: 1.5em">8 bits; an identifier of the datagram that
       is locally unique to the link-layer recipient.<a class="pilcrow" href="#section-5.2-7.6">¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-5.2-7.7">RFRAG Acknowledgment Bitmap:</dt>
          <dd id="section-5.2-7.8" style="margin-left: 1.5em">An RFRAG Acknowledgment Bitmap, whereby setting the bit at offset x
        indicates that fragment x was received, as shown in <a class="xref" href="#dCack3">Figure 2</a>.
        A NULL bitmap indicates that the fragmentation process is aborted.
        A FULL bitmap indicates that the fragmentation process is complete;
        all fragments were received at the reassembly endpoint.<a class="pilcrow" href="#section-5.2-7.8">¶</a>
</dd>
        <dd class="break"></dd>
</dl>
</section>
</div>
</section>
</div>
<div id="ffc">
<section id="section-6">
      <h2 id="name-fragment-recovery">
<a class="section-number selfRef" href="#section-6">6. </a><a class="section-name selfRef" href="#name-fragment-recovery">Fragment Recovery</a>
      </h2>
<p id="section-6-1">
 The RFRAG header is used to transport
    a fragment and optionally request an RFRAG-ACK that
    confirms the reception of one or more fragments.
    An RFRAG-ACK is carried as a standalone fragment header (i.e.,
    with no 6LoWPAN payload) in a message that is propagated back to the
    fragmenting endpoint.

    To achieve this, each hop that performed an MPLS-like operation on fragments
    reverses that operation for the RFRAG-ACK by sending a frame from the next
    hop to the previous hop as known by its link-layer address in the VRB.
    The Datagram_Tag in the RFRAG-ACK is unique to the reassembling endpoint and is enough
    information for an intermediate hop to locate the VRB that contains the
    Datagram_Tag used by the previous hop and the Layer 2 information associated with it (interface and link-layer address).<a class="pilcrow" href="#section-6-1">¶</a></p>
<p id="section-6-2"> The fragmenting endpoint (i.e., the node that fragments the packets at the 6LoWPAN level)
     also controls the number of acknowledgments by setting the Ack-Request flag in the RFRAG packets.<a class="pilcrow" href="#section-6-2">¶</a></p>
<p id="section-6-3">
    The fragmenting endpoint may set the Ack-Request flag on any fragment to perform
    congestion control by limiting the number of outstanding fragments, which
    are the fragments that have been sent but for which reception or loss
    was not positively confirmed by the reassembling endpoint. The maximum
    number of outstanding fragments is controlled by the Window-Size. It is configurable and
    may vary in case of ECN notification. When the endpoint that
    reassembles the packets at the 6LoWPAN level receives a fragment with the Ack-Request flag set, it <span class="bcp14">MUST</span> send an
    RFRAG-ACK back to the originator to confirm reception of all the
    fragments it has received so far.<a class="pilcrow" href="#section-6-3">¶</a></p>
<p id="section-6-4">
    The Ack-Request ("X") set in an RFRAG marks the end of a window. This flag
    <span class="bcp14">MUST</span> be set on the last fragment if the fragmenting endpoint wishes to perform
    an automatic repeat request (ARQ) process for the datagram,
    and it <span class="bcp14">MAY</span> be set in any intermediate fragment for the purpose of congestion control.<a class="pilcrow" href="#section-6-4">¶</a></p>
<p id="section-6-5">
    This ARQ process <span class="bcp14">MUST</span> be protected by a Retransmission Timeout (RTO) timer,
    and the fragment that carries the "X"
    flag <span class="bcp14">MAY</span> be retried upon a timeout for a configurable number of times (see
    <a class="xref" href="#protp">Section 7.1</a>) with an exponential backoff.
    Upon exhaustion of the retries, the fragmenting endpoint may either abort the
    transmission of the datagram or resend the first fragment with an "X" flag
    set in order to establish a new path for the datagram and obtain the list of
    fragments that were received over the old path in the acknowledgment bitmap.
 When the fragmenting endpoint knows that an underlying link-layer
    mechanism protects the fragments, it may refrain from using the RFRAG
    Acknowledgment mechanism and never set the Ack-Request bit.<a class="pilcrow" href="#section-6-5">¶</a></p>
<p id="section-6-6">The reassembling endpoint <span class="bcp14">MAY</span> issue unsolicited acknowledgments.
    An unsolicited acknowledgment signals to the fragmenting endpoint that it
    can resume sending in case it has reached its maximum number
 of outstanding fragments. Another use is to inform the fragmenting endpoint
    that the reassembling endpoint aborted the processing of an individual
    datagram.<a class="pilcrow" href="#section-6-6">¶</a></p>
<p id="section-6-7">
    The RFRAG Acknowledgment carries an ECN indication for congestion
    control (see <a class="xref" href="#onECN">Appendix C</a>).
    The reassembling endpoint of a fragment with the "E" (ECN) flag set <span class="bcp14">MUST</span>
    echo that information at most once by setting the "E" (ECN) flag
    in the next RFRAG-ACK.<a class="pilcrow" href="#section-6-7">¶</a></p>
<p id="section-6-8">
 In order to protect the datagram, the fragmenting endpoint transfers a controlled number
    of fragments and flags to the last
 fragment of a window with an RFRAG Acknowledgment Request. The reassembling endpoint <span class="bcp14">MUST</span>
    acknowledge a fragment with the acknowledgment request bit set.
    If any fragment immediately preceding
 an acknowledgment request is still missing, the reassembling endpoint <span class="bcp14">MAY</span> intentionally
 delay its acknowledgment to allow in-transit fragments to arrive.
    Because it might defeat the round-trip time computation, delaying the
    acknowledgment should be configurable and not enabled by default.<a class="pilcrow" href="#section-6-8">¶</a></p>
<p id="section-6-9">
    When enough fragments are received to cover the whole datagram, the reassembling endpoint reconstructs
    the packet, passes it to the upper layer, sends an RFRAG-ACK on
    the reverse path with a FULL bitmap, and arms a short timer, e.g.,
    on the order of an average round-trip time in the network. The FULL bitmap
    is used as opposed to a bitmap that acknowledges only the received fragments
    to let the intermediate nodes know that the datagram is fully received.
    As the timer runs, the reassembling endpoint absorbs the fragments that were
    still in flight for that datagram without creating a new state, acknowledging
    the ones that bear an Ack-Request with an FRAG Acknowledgment and the
    FULL bitmap.
    The reassembling endpoint aborts the communication if fragments with a
    matching source and Datagram-Tag continue to be received
    after the timer expires.<a class="pilcrow" href="#section-6-9">¶</a></p>
<p id="section-6-10">
    Note that acknowledgments might consume precious resources, so the use of
    unsolicited acknowledgments <span class="bcp14">SHOULD</span> be configurable and not enabled by
    default.<a class="pilcrow" href="#section-6-10">¶</a></p>
<p id="section-6-11">
    An observation is that streamlining the forwarding of fragments generally
    reduces the latency over the LLN mesh, providing room for retries within
    existing upper-layer reliability mechanisms.
 The fragmenting endpoint protects the transmission over the LLN mesh with a retry timer
    that is configured for a use case and may be adapted dynamically, e.g.,
    according to the method detailed in <span>[<a class="xref" href="#RFC6298">RFC6298</a>]</span>.
    It is expected that the upper-layer retry mechanism obeys the recommendations in
    <span>[<a class="xref" href="#RFC8085">RFC8085</a>]</span>, in which case a single
    round of fragment recovery should fit within the upper-layer recovery timers.<a class="pilcrow" href="#section-6-11">¶</a></p>
<p id="section-6-12">
    Fragments <span class="bcp14">MUST</span> be sent in a round-robin fashion: the sender <span class="bcp14">MUST</span> send all
    the fragments for a first time before it retries any lost fragment; lost
    fragments <span class="bcp14">MUST</span> be retried in sequence, oldest first. This mechanism
    enables the receiver to acknowledge fragments that were delayed in
    the network before they are retried.<a class="pilcrow" href="#section-6-12">¶</a></p>
<p id="section-6-13">
    When a single radio frequency is used by contiguous hops, the fragmenting endpoint <span class="bcp14">SHOULD</span> insert a delay between the frames (e.g., carrying fragments) that are sent to the same next hop. The delay <span class="bcp14">SHOULD</span> cover multiple transmissions so as to let a frame progress a few hops and avoid hidden terminal issues.
    This precaution is not required on channel hopping technologies such as Time-Slotted Channel Hopping (TSCH)
    <span>[<a class="xref" href="#RFC6554">RFC6554</a>]</span>, where nodes that communicate at Layer 2 are scheduled to send
    and receive, respectively, and different hops operate on different channels.<a class="pilcrow" href="#section-6-13">¶</a></p>
<div id="ffg">
<section id="section-6.1">
        <h3 id="name-forwarding-fragments">
<a class="section-number selfRef" href="#section-6.1">6.1. </a><a class="section-name selfRef" href="#name-forwarding-fragments">Forwarding Fragments</a>
        </h3>
<p id="section-6.1-1">
    This specification inherits from <span>[<a class="xref" href="#RFC8930">RFC8930</a>]</span>
    and proposes a Virtual Reassembly Buffer technique to forward fragments with no intermediate reconstruction of the entire datagram.<a class="pilcrow" href="#section-6.1-1">¶</a></p>
<p id="section-6.1-2">
    The IPv6 header <span class="bcp14">MUST</span> be placed in the first fragment in full to enable the routing decision. The first fragment is routed and creates an LSP from the fragmenting endpoint to the reassembling endpoint. The next fragments are label switched along that LSP.
    As a consequence, the next fragments can only follow the path that was set
    up by the first fragment; they cannot follow an alternate route.
      The Datagram_Tag is used to carry the label, which is swapped in each hop.<a class="pilcrow" href="#section-6.1-2">¶</a></p>
<p id="section-6.1-3">
    If the first fragment is too large for the path MTU, it will repeatedly fail
    and never establish an LSP. In that case,
    the fragmenting endpoint <span class="bcp14">MAY</span> retry the same datagram with a smaller
    Fragment_Size, in which case it <span class="bcp14">MUST</span> abort the original attempt and use a
    new Datagram_Tag for the new attempt.<a class="pilcrow" href="#section-6.1-3">¶</a></p>
<div id="ff">
<section id="section-6.1.1">
          <h4 id="name-receiving-the-first-fragmen">
<a class="section-number selfRef" href="#section-6.1.1">6.1.1. </a><a class="section-name selfRef" href="#name-receiving-the-first-fragmen">Receiving the First Fragment</a>
          </h4>
<p id="section-6.1.1-1">
 In route-over mode, the source and destination link-layer addresses in a frame
    change at each hop. The label that is formed and placed in the
    Datagram_Tag by the sender is associated with the source link-layer address and only valid (and temporarily unique) for that source link-layer address.<a class="pilcrow" href="#section-6.1.1-1">¶</a></p>
<p id="section-6.1.1-2">
    Upon receiving the first fragment (i.e., with a Sequence of 0), an intermediate router
    creates a VRB and the associated
    LSP state indexed by the incoming interface, the previous-hop link-layer address,
    and the Datagram_Tag and forwards the fragment along the IPv6 route that matches
    the destination IPv6 address in the IPv6 header until it reaches the
    reassembling endpoint, as prescribed by
    <span>[<a class="xref" href="#RFC8930">RFC8930</a>]</span>.
    The LSP state enables matching the next incoming fragments of a datagram to
    the abstract forwarding information of the next interface, source and next-hop
    link-layer addresses, and the swapped Datagram_Tag.<a class="pilcrow" href="#section-6.1.1-2">¶</a></p>
<p id="section-6.1.1-3">
    In addition, the router also forms a reverse LSP state indexed by the interface to the next hop, the link-layer address the router uses as source for that datagram, and the swapped Datagram_Tag. This reverse LSP state
    enables matching the tuple (interface, destination link-layer address, Datagram_Tag) found in an RFRAG-ACK to the abstract forwarding information (previous interface, previous link-layer address, Datagram_Tag) used to forward the RFRAG-ACK back to the fragmenting endpoint.<a class="pilcrow" href="#section-6.1.1-3">¶</a></p>
</section>
</div>
<div id="nf">
<section id="section-6.1.2">
          <h4 id="name-receiving-the-next-fragment">
<a class="section-number selfRef" href="#section-6.1.2">6.1.2. </a><a class="section-name selfRef" href="#name-receiving-the-next-fragment">Receiving the Next Fragments</a>
          </h4>
<p id="section-6.1.2-1">Upon receiving the next fragment (i.e., with a non-zero Sequence),
    an intermediate router looks up
    an LSP indexed by the tuple (incoming interface, previous-hop link-layer address, Datagram_Tag) found in the fragment.
    If it is found, the router forwards the fragment using the associated VRB as
    prescribed by <span>[<a class="xref" href="#RFC8930">RFC8930</a>]</span>.<a class="pilcrow" href="#section-6.1.2-1">¶</a></p>
<p id="section-6.1.2-2">If the VRB for the tuple is not found, the router builds an RFRAG-ACK
    to abort the transmission of the packet. The resulting message has the
 following information:<a class="pilcrow" href="#section-6.1.2-2">¶</a></p>
<ul class="normal">
<li class="normal" id="section-6.1.2-3.1">The source and destination link-layer addresses are swapped from those found
        in the fragment, and the same interface is used<a class="pilcrow" href="#section-6.1.2-3.1">¶</a>
</li>
            <li class="normal" id="section-6.1.2-3.2">The Datagram_Tag is set to the Datagram_Tag found in the fragment<a class="pilcrow" href="#section-6.1.2-3.2">¶</a>
</li>
            <li class="normal" id="section-6.1.2-3.3">A NULL bitmap is used to signal the abort condition<a class="pilcrow" href="#section-6.1.2-3.3">¶</a>
</li>
          </ul>
<p id="section-6.1.2-4">
 At this point, the router is all set and can send the RFRAG-ACK back to
    the previous router. The RFRAG-ACK should normally be forwarded all the way
    to the source using the reverse LSP state in the VRBs in the intermediate
    routers as described in the next section.<a class="pilcrow" href="#section-6.1.2-4">¶</a></p>
<p id="section-6.1.2-5">
    <span>[<a class="xref" href="#RFC8930">RFC8930</a>]</span> indicates that the
    reassembling endpoint stores
    "the actual packet data from the fragments received so far, in a form that
    makes it possible to detect when the whole packet has been received and can
    be processed or forwarded".
    How this is computed is implementation specific,
    but it relies on receiving all the bytes up to the Datagram_Size indicated in
    the first fragment.
    An implementation may receive overlapping fragments as the result of retries
    after an MTU change.<a class="pilcrow" href="#section-6.1.2-5">¶</a></p>
</section>
</div>
</section>
</div>
<div id="ura">
<section id="section-6.2">
        <h3 id="name-receiving-rfrag-acknowledgm">
<a class="section-number selfRef" href="#section-6.2">6.2. </a><a class="section-name selfRef" href="#name-receiving-rfrag-acknowledgm">Receiving RFRAG Acknowledgments</a>
        </h3>
<p id="section-6.2-1">Upon receipt of an RFRAG-ACK, the router looks up a reverse LSP indexed by the interface and destination link-layer address of the received frame and the received Datagram_Tag in the RFRAG-ACK.
    If it is found, the router forwards the fragment using the associated VRB as
    prescribed by <span>[<a class="xref" href="#RFC8930">RFC8930</a>]</span>, but it uses
    the reverse LSP so that the RFRAG-ACK flows back to the fragmenting endpoint.<a class="pilcrow" href="#section-6.2-1">¶</a></p>
<p id="section-6.2-2">If the reverse LSP is not found, the router <span class="bcp14">MUST</span> silently drop the RFRAG-ACK message.<a class="pilcrow" href="#section-6.2-2">¶</a></p>
<p id="section-6.2-3">Either way, if the RFRAG-ACK indicates that the fragment was entirely received (FULL bitmap), it arms a short timer, and upon timeout, the VRB and all the associated states are destroyed. Until the timer elapses, fragments of that datagram may still be received, e.g., if the RFRAG-ACK was lost on the path back, and the source retried the last fragment. In that
    case, the router generates an RFRAG-ACK with a FULL bitmap back to the fragmenting endpoint if an acknowledgment was requested; else, it silently drops the fragment.<a class="pilcrow" href="#section-6.2-3">¶</a></p>
<p id="section-6.2-4">
    This specification does not provide a method to discover the number of hops
    or the minimal value of MTU along those hops. In a typical case, the MTU is
    constant and is the same across the network. But should the minimal MTU along
    the path decrease, it is possible to retry a long fragment (say a Sequence of 5) with
    several shorter fragments with a Sequence that was not used before (e.g.,
    13 and 14). Fragment 5 is marked as abandoned and will not be retried
    anymore. Note that when this mechanism is in place, it is hard to predict
    the total number of fragments that will be needed or the final shape of the
    bitmap that would cover the whole packet. This is why the FULL bitmap is used
    when the reassembling endpoint gets the whole datagram regardless of which
    fragments were actually used to do so. Intermediate nodes will know unambiguously
    that the process is complete. Note that Path MTU Discovery is out of scope for this document.<a class="pilcrow" href="#section-6.2-4">¶</a></p>
</section>
</div>
<section id="section-6.3">
        <h3 id="name-aborting-the-transmission-o">
<a class="section-number selfRef" href="#section-6.3">6.3. </a><a class="section-name selfRef" href="#name-aborting-the-transmission-o">Aborting the Transmission of a Fragmented Packet</a>
        </h3>
<p id="section-6.3-1">
 A reset is signaled on the forward path with a pseudo fragment that has the Fragment_Offset set to 0. The sender of a reset <span class="bcp14">SHOULD</span> also set the Sequence and Fragment_Size field to 0.<a class="pilcrow" href="#section-6.3-1">¶</a></p>
<p id="section-6.3-2">
    When the fragmenting endpoint or a router on the path decides that a packet should be dropped and the fragmentation process aborted, it generates a reset pseudo fragment and forwards it down the fragment path.<a class="pilcrow" href="#section-6.3-2">¶</a></p>
<p id="section-6.3-3">Each router along the path forwards the pseudo fragment in
 turn based on the VRB state. If an acknowledgment is not requested, the VRB and all associated states are destroyed.<a class="pilcrow" href="#section-6.3-3">¶</a></p>
<p id="section-6.3-4">
 Upon reception of the pseudo fragment, the reassembling endpoint cleans up all resources for the packet
 associated with the Datagram_Tag. If an acknowledgment is requested, the reassembling endpoint responds with a NULL bitmap.<a class="pilcrow" href="#section-6.3-4">¶</a></p>
<p id="section-6.3-5">On the other hand, the reassembling endpoint might need to abort the processing of a fragmented packet for internal reasons, for instance, if it is out of reassembly buffers, already uses all 256 possible values of the Datagram_Tag, or keeps receiving fragments beyond a reasonable time while it considers that this packet is already fully reassembled and was passed to the upper layer. In that case, the reassembling endpoint <span class="bcp14">SHOULD</span> indicate so to the fragmenting endpoint with a NULL bitmap in an RFRAG-ACK.<a class="pilcrow" href="#section-6.3-5">¶</a></p>
<p id="section-6.3-6">
    The RFRAG-ACK is forwarded all the way back to the source of the packet and cleans up all resources on the path.
 Upon an acknowledgment with a NULL bitmap, the fragmenting endpoint <span class="bcp14">MUST</span> abort the transmission of the fragmented datagram with one exception: in the particular case of the first fragment, it <span class="bcp14">MAY</span> decide to retry via an alternate next hop instead.<a class="pilcrow" href="#section-6.3-6">¶</a></p>
</section>
<section id="section-6.4">
        <h3 id="name-applying-recoverable-fragme">
<a class="section-number selfRef" href="#section-6.4">6.4. </a><a class="section-name selfRef" href="#name-applying-recoverable-fragme">Applying Recoverable Fragmentation along a Diverse Path</a>
        </h3>
<p id="section-6.4-1">
    The text above can be read with the assumption of a serial path between a
    source and a destination. The IPv6 over the TSCH mode of IEEE 802.15.4e (6TiSCH) architecture (see
    <span><a class="relref" href="https://tools.ietf.org/html/draft-ietf-6tisch-architecture-29#section-4.5.3">Section 4.5.3</a> of [<a class="xref" href="#I-D.ietf-6tisch-architecture">6TiSCH</a>]</span>)
    defines the concept of a Track that can be a complex path between a source
    and a destination with Packet ARQ, Replication,
    Elimination, and Overhearing (PAREO) along the Track. This specification
    can be used along any subset of
    the complex Track where the first fragment is flooded. The last RFRAG
    Acknowledgment is flooded on that same subset in the reverse direction.
    Intermediate RFRAG Acknowledgments can be flooded on any sub-subset of that
    reverse subset that reaches back to the source.<a class="pilcrow" href="#section-6.4-1">¶</a></p>
</section>
</section>
</div>
<section id="section-7">
      <h2 id="name-management-considerations">
<a class="section-number selfRef" href="#section-7">7. </a><a class="section-name selfRef" href="#name-management-considerations">Management Considerations</a>
      </h2>
<p id="section-7-1">

    This specification extends  <span>[<a class="xref" href="#RFC8930">RFC8930</a>]</span> and requires the same parameters in the reassembling endpoint and on intermediate nodes. There is no new parameter as echoing ECN is always on. These parameters typically include the reassembly timeout at the reassembling endpoint, an inactivity cleanup timer on the intermediate nodes, and the number of messages that can be processed in parallel in all nodes.<a class="pilcrow" href="#section-7-1">¶</a></p>
<p id="section-7-2">

    The configuration settings introduced by this specification only apply to the fragmenting endpoint, which is in full control of the transmission.
    LLNs vary a lot in size (there can be thousands of nodes in a mesh), in
    speed (from 10 Kbps to several Mbps at the PHY layer), in traffic density, and in optimizations that are desired (e.g., the selection of a Routing Protocol for LLNs (RPL) <span>[<a class="xref" href="#RFC6550">RFC6550</a>]</span> Objective Function <span>[<a class="xref" href="#RFC6552">RFC6552</a>]</span> impacts the shape of the routing graph).<a class="pilcrow" href="#section-7-2">¶</a></p>
<p id="section-7-3">
    For that reason, only very generic guidance can be given on the settings of the fragmenting endpoint and on whether complex algorithms are needed to perform congestion control or to estimate the round-trip time. To cover the most complex use cases, this specification enables the fragmenting endpoint to vary the fragment size, the window size, and the inter-frame gap based on the number of losses, the observed variations of the round-trip time, and the setting of the ECN bit.<a class="pilcrow" href="#section-7-3">¶</a></p>
<div id="protp">
<section id="section-7.1">
        <h3 id="name-protocol-parameters">
<a class="section-number selfRef" href="#section-7.1">7.1. </a><a class="section-name selfRef" href="#name-protocol-parameters">Protocol Parameters</a>
        </h3>
<p id="section-7.1-1">
    The management system <span class="bcp14">SHOULD</span> be capable of providing the parameters listed in this section, and an
    implementation <span class="bcp14">MUST</span> abide by those parameters and, in particular, never exceed the minimum and maximum configured boundaries.<a class="pilcrow" href="#section-7.1-1">¶</a></p>
<p id="section-7.1-2">
    An implementation should consider the generic recommendations from the IETF in the matter of congestion control and rate management for IP datagrams in
    <span>[<a class="xref" href="#RFC8085">RFC8085</a>]</span>.
    An implementation may perform congestion control by using a dynamic value of the window size (Window_Size), adapting the fragment size (Fragment_Size), and potentially
    reducing the load by inserting an inter-frame gap that is longer than necessary. In a large network where nodes contend for the bandwidth, a larger Fragment_Size consumes less bandwidth but also reduces fluidity and incurs higher chances of loss in transmission.<a class="pilcrow" href="#section-7.1-2">¶</a></p>
<p id="section-7.1-3">
    This is controlled by the following parameters:<a class="pilcrow" href="#section-7.1-3">¶</a></p>
<span class="break"></span><dl class="dlParallel" id="section-7.1-4">
          <dt id="section-7.1-4.1">inter-frame gap:</dt>
          <dd id="section-7.1-4.2" style="margin-left: 1.5em">
       The inter-frame gap indicates the minimum amount of time between transmissions.
       The inter-frame gap controls the rate at which fragments are sent, the ratio of air time, and the amount of memory in intermediate nodes that a particular datagram will use. It can be used as a flow control, a congestion control, and/or a collision
       control measure.
       It <span class="bcp14">MUST</span> be set at a minimum to a value that protects the propagation of one transmission against collision with next <span>[<a class="xref" href="#RFC8930">RFC8930</a>]</span>. In a wireless network that uses the same frequency along a path, this may represent the time for a frame to progress over multiple hops (see more in <a class="xref" href="#gap">Section 4.2</a>).
       It <span class="bcp14">SHOULD</span> be augmented beyond this as necessary to protect the network against congestion.<a class="pilcrow" href="#section-7.1-4.2">¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-7.1-4.3">MinFragmentSize:</dt>
          <dd id="section-7.1-4.4" style="margin-left: 1.5em">
       The MinFragmentSize is the minimum value for the Fragment_Size. It <span class="bcp14">MUST</span> be lower than the minimum value of smallest 1-hop MTU that can be encountered along the path.<a class="pilcrow" href="#section-7.1-4.4">¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-7.1-4.5">OptFragmentSize:</dt>
          <dd id="section-7.1-4.6" style="margin-left: 1.5em">
       The OptFragmentSize is the value for the Fragment_Size that the fragmenting endpoint
       should use to start with. It is greater than or equal to MinFragmentSize. It is less than or equal to MaxFragmentSize. For the
       first fragment, it must account for the expansion of the IPv6 addresses and of the Hop Limit field within MTU. For all fragments, it is a balance between the expected fluidity and the overhead of link-layer and 6LoWPAN headers. For a small MTU, the idea is to keep it close to the maximum, whereas for larger MTUs, it might make sense to keep it short enough so that the duty cycle of the transmitter is bounded, e.g., to transmit at least 10 frames per second.<a class="pilcrow" href="#section-7.1-4.6">¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-7.1-4.7">MaxFragmentSize:</dt>
          <dd id="section-7.1-4.8" style="margin-left: 1.5em">
       The MaxFragmentSize is the maximum value for the Fragment_Size.
       It <span class="bcp14">MUST</span> be lower than the maximum value of the smallest 1-hop MTU that can be encountered along the path. A large
       value augments the chances of buffer bloat and transmission loss.
       The value <span class="bcp14">MUST</span> be less than 512 if the unit that is defined
       for the PHY layer is the byte.<a class="pilcrow" href="#section-7.1-4.8">¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-7.1-4.9">Window_Size:</dt>
          <dd id="section-7.1-4.10" style="margin-left: 1.5em">
            <p id="section-7.1-4.10.1">
       The Window_Size <span class="bcp14">MUST</span> be at least 1 and less than 33.<a class="pilcrow" href="#section-7.1-4.10.1">¶</a></p>
<ul class="normal">
<li class="normal" id="section-7.1-4.10.2.1">
       If the round-trip time is known, the Window_Size <span class="bcp14">SHOULD</span> be set to the round-trip time divided by the time per fragment; that is, the time to transmit a fragment plus the inter-frame gap.<a class="pilcrow" href="#section-7.1-4.10.2.1">¶</a>
</li>
            </ul>
<p id="section-7.1-4.10.3">
       Otherwise:<a class="pilcrow" href="#section-7.1-4.10.3">¶</a></p>
<ul class="normal">
<li class="normal" id="section-7.1-4.10.4.1">
       A window_size of 32 indicates that only the last fragment is to be acknowledged in each round. This is the <span class="bcp14">RECOMMENDED</span> value in a half-duplex LLN
       where the fragment acknowledgment consumes roughly the same bandwidth on the
       same links as the fragments themselves.<a class="pilcrow" href="#section-7.1-4.10.4.1">¶</a>
</li>
              <li class="normal" id="section-7.1-4.10.4.2">
       If it is set to a smaller value, more acks are generated.
       In a full-duplex network, the load on the forward path will be lower, and
       a small value of 3 <span class="bcp14">SHOULD</span> be configured.<a class="pilcrow" href="#section-7.1-4.10.4.2">¶</a>
</li>
            </ul>
</dd>
        <dd class="break"></dd>
</dl>
<p id="section-7.1-5">
    An implementation may perform its estimate of the RTO or use a configured one. The ARQ process is controlled by the following parameters:<a class="pilcrow" href="#section-7.1-5">¶</a></p>
<span class="break"></span><dl class="dlParallel" id="section-7.1-6">
          <dt id="section-7.1-6.1">MinARQTimeOut:</dt>
          <dd id="section-7.1-6.2" style="margin-left: 1.5em">
       The minimum amount of time a node should wait for an RFRAG Acknowledgment before it takes the next action.
       It <span class="bcp14">MUST</span> be more than the maximum expected round-trip time in the respective network.<a class="pilcrow" href="#section-7.1-6.2">¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-7.1-6.3">OptARQTimeOut:</dt>
          <dd id="section-7.1-6.4" style="margin-left: 1.5em">
       The initial value of the RTO, which is the amount of time that a fragmenting endpoint should wait for an RFRAG Acknowledgment before it takes the next action. It is greater than or equal to MinARQTimeOut. It is less than or equal to MaxARQTimeOut. See <a class="xref" href="#onECN">Appendix C</a> for recommendations on computing the round-trip time. By default, a value of 3 times the maximum expected round-trip time in the respective network is <span class="bcp14">RECOMMENDED</span>.<a class="pilcrow" href="#section-7.1-6.4">¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-7.1-6.5">MaxARQTimeOut:</dt>
          <dd id="section-7.1-6.6" style="margin-left: 1.5em">
       The maximum amount of time a node should wait for the RFRAG Acknowledgment before it takes the next action. It must cover the longest expected round-trip time and be several times less than the timeout that covers the recomposition buffer at the reassembling endpoint, which is typically on the order of the minute.
       An upper bound can be estimated to ensure that the datagram is either fully transmitted or dropped
       before an upper layer decides to retry it.<a class="pilcrow" href="#section-7.1-6.6">¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-7.1-6.7">MaxFragRetries:</dt>
          <dd id="section-7.1-6.8" style="margin-left: 1.5em">
       The maximum number of retries for a particular fragment. A default value of 3 is <span class="bcp14">RECOMMENDED</span>.
       An upper bound can be estimated to ensure that the datagram is either fully transmitted or dropped
       before an upper layer decides to retry it.<a class="pilcrow" href="#section-7.1-6.8">¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-7.1-6.9">MaxDatagramRetries:</dt>
          <dd id="section-7.1-6.10" style="margin-left: 1.5em">
       The maximum number of retries from scratch for a particular datagram.
       A default value of 1 is <span class="bcp14">RECOMMENDED</span>.
       An upper bound can be estimated to ensure that the datagram is either fully transmitted or dropped
       before an upper layer decides to retry it.<a class="pilcrow" href="#section-7.1-6.10">¶</a>
</dd>
        <dd class="break"></dd>
</dl>
<p id="section-7.1-7">
    An implementation may be capable of performing congestion control based on ECN; see <a class="xref" href="#onECN">Appendix C</a>. This is controlled by the following parameter:<a class="pilcrow" href="#section-7.1-7">¶</a></p>
<span class="break"></span><dl class="dlParallel" id="section-7.1-8">
          <dt id="section-7.1-8.1">UseECN:</dt>
          <dd id="section-7.1-8.2" style="margin-left: 1.5em">
       Indicates whether the fragmenting endpoint should react to ECN.
       The fragmenting endpoint may react to ECN by varying the Window_Size between
       MinWindowSize and MaxWindowSize, varying the Fragment_Size between MinFragmentSize and MaxFragmentSize, and/or increasing or reducing the inter-frame gap.
       With this specification, if UseECN is set and a fragmenting
       endpoint detects a congestion, it may apply a congestion control method until the end of the datagram, whereas if UseECN is reset, the endpoint does not react to congestion.
       Future specifications may provide additional parameters and capabilities.<a class="pilcrow" href="#section-7.1-8.2">¶</a>
</dd>
        <dd class="break"></dd>
</dl>
</section>
</div>
<section id="section-7.2">
        <h3 id="name-observing-the-network">
<a class="section-number selfRef" href="#section-7.2">7.2. </a><a class="section-name selfRef" href="#name-observing-the-network">Observing the Network</a>
        </h3>
<p id="section-7.2-1">The management system should monitor the number of retries
    and ECN settings that can be observed from the perspective of
    the fragmenting endpoint with respect to the reassembling endpoint and reciprocally.

    It may then tune the optimum size of
    Fragment_Size and of Window_Size, OptFragmentSize, and OptWindowSize,
    respectively, at the fragmenting endpoint towards a particular reassembling endpoint, which is applicable to the
    next datagrams.
    It will preferably tune the inter-frame gap to
    increase the spacing between fragments of the same datagram and reduce the
    buffer bloat in the intermediate node that holds one or more fragments of that
    datagram.<a class="pilcrow" href="#section-7.2-1">¶</a></p>
</section>
</section>
<section id="section-8">
      <h2 id="name-security-considerations">
<a class="section-number selfRef" href="#section-8">8. </a><a class="section-name selfRef" href="#name-security-considerations">Security Considerations</a>
      </h2>
<p id="section-8-1">
    This document specifies an instantiation of a 6LFF technique and inherits
    from the generic description in <span>[<a class="xref" href="#RFC8930">RFC8930</a>]</span>.
    The considerations in the Security Considerations section of <span>[<a class="xref" href="#RFC8930">RFC8930</a>]</span>  equally apply to this document.<a class="pilcrow" href="#section-8-1">¶</a></p>
<p id="section-8-2">
    In addition to the threats detailed therein, an attacker that is on path can
    prematurely end the transmission of a datagram by sending a RFRAG Acknowledgment
    to the fragmenting endpoint. It can also cause extra transmissions of
    fragments by resetting bits in the RFRAG Acknowledgment Bitmap and of
    RFRAG Acknowledgments by forcing the  Ack-Request bit in fragments that it
    forwards.<a class="pilcrow" href="#section-8-2">¶</a></p>
<p id="section-8-3">
    As indicated in <span>[<a class="xref" href="#RFC8930">RFC8930</a>]</span>, secure joining and link-layer security are <span class="bcp14">REQUIRED</span> to protect against those attacks, as the fragmentation protocol does not include any native
    security mechanisms.<a class="pilcrow" href="#section-8-3">¶</a></p>
<p id="section-8-4">
    This specification does not recommend a particular algorithm for the
    estimation of the duration of the RTO that covers the detection of the
    loss of a fragment with the "X" flag set; regardless, an attacker on the
    path may slow down or discard packets, which in turn can affect the
    throughput of fragmented packets.<a class="pilcrow" href="#section-8-4">¶</a></p>
<p id="section-8-5">Compared to
 <span>[<a class="xref" href="#RFC4944">RFC4944</a>]</span>, this specification reduces the Datagram_Tag to 8 bits, and
    the tag wraps faster than with <span>[<a class="xref" href="#RFC4944">RFC4944</a>]</span>.
    But for a constrained network where a node is expected to be able to hold
    only one or a few large packets in memory, 256 is still a large number.
    Also, the acknowledgment mechanism allows cleaning up the state rapidly
    once the packet is fully transmitted or aborted.<a class="pilcrow" href="#section-8-5">¶</a></p>
<p id="section-8-6">
    The abstract Virtual Recovery Buffer from
    <span>[<a class="xref" href="#RFC8930">RFC8930</a>]</span> may be used to perform a
    Denial-of-Service (DoS) attack against the intermediate routers since the
    routers need to maintain a state per flow. The particular VRB implementation
    technique described in
    <span>[<a class="xref" href="#I-D.ietf-lwig-6lowpan-virtual-reassembly">LWIG-FRAG</a>]</span> allows realigning
    which data goes in which fragment; this causes the intermediate node to
    store a portion of the data, which adds an attack vector that is not present
    with this specification. With this specification, the data that is
    transported in each fragment is conserved, and the state to keep does not
    include any data that would not fit in the previous fragment.<a class="pilcrow" href="#section-8-6">¶</a></p>
</section>
<div id="ianacon">
<section id="section-9">
      <h2 id="name-iana-considerations">
<a class="section-number selfRef" href="#section-9">9. </a><a class="section-name selfRef" href="#name-iana-considerations">IANA Considerations</a>
      </h2>
<p id="section-9-1">

    This document allocates two patterns for a total of four dispatch values for Recoverable Fragments from the
   "Dispatch Type Field" registry that was created by <span>[<a class="xref" href="#RFC4944">RFC4944</a>]</span> and
     reformatted by <span><a class="xref" href="#RFC8025">"IPv6 over Low-Power Wireless Personal Area
                   Network (6LoWPAN) Paging Dispatch"</a> [<a class="xref" href="#RFC8025">RFC8025</a>]</span>.<a class="pilcrow" href="#section-9-1">¶</a></p>
<span id="name-additional-dispatch-value-b"></span><div id="difig">
<table class="center" id="table-1">
        <caption>
<a class="selfRef" href="#table-1">Table 1</a>:
<a class="selfRef" href="#name-additional-dispatch-value-b">Additional Dispatch Value Bit Patterns</a>
        </caption>
<thead>
          <tr>
            <td class="text-left" colspan="1" rowspan="1">Bit Pattern</td>
            <td class="text-left" colspan="1" rowspan="1">Page</td>
            <td class="text-left" colspan="1" rowspan="1">Header Type</td>
            <td class="text-left" colspan="1" rowspan="1">Reference</td>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td class="text-left" colspan="1" rowspan="1">11  10100x</td>
            <td class="text-left" colspan="1" rowspan="1">0</td>
            <td class="text-left" colspan="1" rowspan="1">RFRAG - Recoverable
      Fragment</td>
            <td class="text-left" colspan="1" rowspan="1">RFC 8931</td>
          </tr>
          <tr>
            <td class="text-left" colspan="1" rowspan="1">11  10100x</td>
            <td class="text-left" colspan="1" rowspan="1">1-14</td>
            <td class="text-left" colspan="1" rowspan="1">Unassigned</td>
            <td class="text-left" colspan="1" rowspan="1"></td>
          </tr>
          <tr>
            <td class="text-left" colspan="1" rowspan="1">11  10100x</td>
            <td class="text-left" colspan="1" rowspan="1">15</td>
            <td class="text-left" colspan="1" rowspan="1">Reserved for Experimental Use</td>
            <td class="text-left" colspan="1" rowspan="1">RFC 8025</td>
          </tr>
          <tr>
            <td class="text-left" colspan="1" rowspan="1">11  10101x</td>
            <td class="text-left" colspan="1" rowspan="1">0</td>
            <td class="text-left" colspan="1" rowspan="1">RFRAG-ACK - RFRAG
      Acknowledgment</td>
            <td class="text-left" colspan="1" rowspan="1">RFC 8931</td>
          </tr>
          <tr>
            <td class="text-left" colspan="1" rowspan="1">11  10101x</td>
            <td class="text-left" colspan="1" rowspan="1">1-14</td>
            <td class="text-left" colspan="1" rowspan="1">Unassigned</td>
            <td class="text-left" colspan="1" rowspan="1"></td>
          </tr>
          <tr>
            <td class="text-left" colspan="1" rowspan="1">11  10101x</td>
            <td class="text-left" colspan="1" rowspan="1">15</td>
            <td class="text-left" colspan="1" rowspan="1">Reserved for Experimental Use</td>
            <td class="text-left" colspan="1" rowspan="1">RFC 8025</td>
          </tr>
        </tbody>
      </table>
</div>
</section>
</div>
<section id="section-10">
      <h2 id="name-references">
<a class="section-number selfRef" href="#section-10">10. </a><a class="section-name selfRef" href="#name-references">References</a>
      </h2>
<section id="section-10.1">
        <h3 id="name-normative-references">
<a class="section-number selfRef" href="#section-10.1">10.1. </a><a class="section-name selfRef" href="#name-normative-references">Normative References</a>
        </h3>
<dl class="references">
<dt id="RFC2119">[RFC2119]</dt>
        <dd>
<span class="refAuthor">Bradner, S.</span>, <span class="refTitle">"Key words for use in RFCs to Indicate Requirement Levels"</span>, <span class="seriesInfo">BCP 14</span>, <span class="seriesInfo">RFC 2119</span>, <span class="seriesInfo">DOI 10.17487/RFC2119</span>, <time class="refDate" datetime="1997-03">March 1997</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc2119">https://www.rfc-editor.org/info/rfc2119</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC4919">[RFC4919]</dt>
        <dd>
<span class="refAuthor">Kushalnagar, N.</span><span class="refAuthor">, Montenegro, G.</span><span class="refAuthor">, and C. Schumacher</span>, <span class="refTitle">"IPv6 over Low-Power Wireless Personal Area Networks (6LoWPANs): Overview, Assumptions, Problem Statement, and Goals"</span>, <span class="seriesInfo">RFC 4919</span>, <span class="seriesInfo">DOI 10.17487/RFC4919</span>, <time class="refDate" datetime="2007-08">August 2007</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc4919">https://www.rfc-editor.org/info/rfc4919</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC4944">[RFC4944]</dt>
        <dd>
<span class="refAuthor">Montenegro, G.</span><span class="refAuthor">, Kushalnagar, N.</span><span class="refAuthor">, Hui, J.</span><span class="refAuthor">, and D. Culler</span>, <span class="refTitle">"Transmission of IPv6 Packets over IEEE 802.15.4 Networks"</span>, <span class="seriesInfo">RFC 4944</span>, <span class="seriesInfo">DOI 10.17487/RFC4944</span>, <time class="refDate" datetime="2007-09">September 2007</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc4944">https://www.rfc-editor.org/info/rfc4944</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC6282">[RFC6282]</dt>
        <dd>
<span class="refAuthor">Hui, J., Ed.</span><span class="refAuthor"> and P. Thubert</span>, <span class="refTitle">"Compression Format for IPv6 Datagrams over IEEE 802.15.4-Based Networks"</span>, <span class="seriesInfo">RFC 6282</span>, <span class="seriesInfo">DOI 10.17487/RFC6282</span>, <time class="refDate" datetime="2011-09">September 2011</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc6282">https://www.rfc-editor.org/info/rfc6282</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC6298">[RFC6298]</dt>
        <dd>
<span class="refAuthor">Paxson, V.</span><span class="refAuthor">, Allman, M.</span><span class="refAuthor">, Chu, J.</span><span class="refAuthor">, and M. Sargent</span>, <span class="refTitle">"Computing TCP's Retransmission Timer"</span>, <span class="seriesInfo">RFC 6298</span>, <span class="seriesInfo">DOI 10.17487/RFC6298</span>, <time class="refDate" datetime="2011-06">June 2011</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc6298">https://www.rfc-editor.org/info/rfc6298</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC6606">[RFC6606]</dt>
        <dd>
<span class="refAuthor">Kim, E.</span><span class="refAuthor">, Kaspar, D.</span><span class="refAuthor">, Gomez, C.</span><span class="refAuthor">, and C. Bormann</span>, <span class="refTitle">"Problem Statement and Requirements for IPv6 over Low-Power Wireless Personal Area Network (6LoWPAN) Routing"</span>, <span class="seriesInfo">RFC 6606</span>, <span class="seriesInfo">DOI 10.17487/RFC6606</span>, <time class="refDate" datetime="2012-05">May 2012</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc6606">https://www.rfc-editor.org/info/rfc6606</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC8025">[RFC8025]</dt>
        <dd>
<span class="refAuthor">Thubert, P., Ed.</span><span class="refAuthor"> and R. Cragie</span>, <span class="refTitle">"IPv6 over Low-Power Wireless Personal Area Network (6LoWPAN) Paging Dispatch"</span>, <span class="seriesInfo">RFC 8025</span>, <span class="seriesInfo">DOI 10.17487/RFC8025</span>, <time class="refDate" datetime="2016-11">November 2016</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc8025">https://www.rfc-editor.org/info/rfc8025</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC8138">[RFC8138]</dt>
        <dd>
<span class="refAuthor">Thubert, P., Ed.</span><span class="refAuthor">, Bormann, C.</span><span class="refAuthor">, Toutain, L.</span><span class="refAuthor">, and R. Cragie</span>, <span class="refTitle">"IPv6 over Low-Power Wireless Personal Area Network (6LoWPAN) Routing Header"</span>, <span class="seriesInfo">RFC 8138</span>, <span class="seriesInfo">DOI 10.17487/RFC8138</span>, <time class="refDate" datetime="2017-04">April 2017</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc8138">https://www.rfc-editor.org/info/rfc8138</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC8174">[RFC8174]</dt>
        <dd>
<span class="refAuthor">Leiba, B.</span>, <span class="refTitle">"Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words"</span>, <span class="seriesInfo">BCP 14</span>, <span class="seriesInfo">RFC 8174</span>, <span class="seriesInfo">DOI 10.17487/RFC8174</span>, <time class="refDate" datetime="2017-05">May 2017</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc8174">https://www.rfc-editor.org/info/rfc8174</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC8200">[RFC8200]</dt>
        <dd>
<span class="refAuthor">Deering, S.</span><span class="refAuthor"> and R. Hinden</span>, <span class="refTitle">"Internet Protocol, Version 6 (IPv6) Specification"</span>, <span class="seriesInfo">STD 86</span>, <span class="seriesInfo">RFC 8200</span>, <span class="seriesInfo">DOI 10.17487/RFC8200</span>, <time class="refDate" datetime="2017-07">July 2017</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc8200">https://www.rfc-editor.org/info/rfc8200</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC8930">[RFC8930]</dt>
      <dd>
<span class="refAuthor">Watteyne, T., Ed.</span><span class="refAuthor">, Thubert, P., Ed.</span><span class="refAuthor">, and C. Bormann</span>, <span class="refTitle">"On Forwarding 6LoWPAN (IPv6 over Low-Power Wireless Personal Area Network) Fragments over a Multi-Hop IPv6 Network"</span>, <span class="seriesInfo">RFC 8930</span>, <span class="seriesInfo">DOI 10.17487/RFC8930</span>, <time class="refDate" datetime="2020-11">November 2020</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc8930">https://www.rfc-editor.org/info/rfc8930</a>&gt;</span>. </dd>
<dd class="break"></dd>
</dl>
</section>
<section id="section-10.2">
        <h3 id="name-informative-references">
<a class="section-number selfRef" href="#section-10.2">10.2. </a><a class="section-name selfRef" href="#name-informative-references">Informative References</a>
        </h3>
<dl class="references">
<dt id="I-D.ietf-6tisch-architecture">[6TiSCH]</dt>
        <dd>
<span class="refAuthor">Thubert, P.</span>, <span class="refTitle">"An Architecture for IPv6 over the TSCH mode of IEEE 802.15.4"</span>, <span class="refContent">Work in Progress</span>, <span class="seriesInfo">Internet-Draft, draft-ietf-6tisch-architecture-29</span>, <time class="refDate" datetime="2020-08-27">27 August 2020</time>, <span>&lt;<a href="https://tools.ietf.org/html/draft-ietf-6tisch-architecture-29">https://tools.ietf.org/html/draft-ietf-6tisch-architecture-29</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="IEEE.802.15.4">[IEEE.802.15.4]</dt>
        <dd>
<span class="refAuthor">IEEE</span>, <span class="refTitle">"IEEE Standard for Low-Rate Wireless Networks"</span>, <span class="seriesInfo">IEEE Standard 802.15.4-2015</span>, <span class="seriesInfo">DOI 10.1109/IEEESTD.2016.7460875</span>, <time class="refDate" datetime="2016-04">April 2016</time>, <span>&lt;<a href="http://ieeexplore.ieee.org/document/7460875/">http://ieeexplore.ieee.org/document/7460875/</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="Kent">[Kent]</dt>
        <dd>
<span class="refAuthor">Kent, C.</span><span class="refAuthor"> and J. Mogul</span>, <span class="refTitle">"Fragmentation Considered Harmful"</span>, <span class="refContent">SIGCOMM '87: Proceedings of the ACM workshop on Frontiers in computer communications technology, pp. 390-401</span>, <span class="seriesInfo">DOI 10.1145/55483.55524</span>, <time class="refDate" datetime="1987-08">August 1987</time>, <span>&lt;<a href="http://www.hpl.hp.com/techreports/Compaq-DEC/WRL-87-3.pdf">http://www.hpl.hp.com/techreports/Compaq-DEC/WRL-87-3.pdf</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="I-D.ietf-lwig-6lowpan-virtual-reassembly">[LWIG-FRAG]</dt>
        <dd>
<span class="refAuthor">Bormann, C.</span><span class="refAuthor"> and T. Watteyne</span>, <span class="refTitle">"Virtual reassembly buffers in 6LoWPAN"</span>, <span class="refContent">Work in Progress</span>, <span class="seriesInfo">Internet-Draft, draft-ietf-lwig-6lowpan-virtual-reassembly-02</span>, <time class="refDate" datetime="2020-03-09">9 March 2020</time>, <span>&lt;<a href="https://tools.ietf.org/html/draft-ietf-lwig-6lowpan-virtual-reassembly-02">https://tools.ietf.org/html/draft-ietf-lwig-6lowpan-virtual-reassembly-02</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC2914">[RFC2914]</dt>
        <dd>
<span class="refAuthor">Floyd, S.</span>, <span class="refTitle">"Congestion Control Principles"</span>, <span class="seriesInfo">BCP 41</span>, <span class="seriesInfo">RFC 2914</span>, <span class="seriesInfo">DOI 10.17487/RFC2914</span>, <time class="refDate" datetime="2000-09">September 2000</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc2914">https://www.rfc-editor.org/info/rfc2914</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC3031">[RFC3031]</dt>
        <dd>
<span class="refAuthor">Rosen, E.</span><span class="refAuthor">, Viswanathan, A.</span><span class="refAuthor">, and R. Callon</span>, <span class="refTitle">"Multiprotocol Label Switching Architecture"</span>, <span class="seriesInfo">RFC 3031</span>, <span class="seriesInfo">DOI 10.17487/RFC3031</span>, <time class="refDate" datetime="2001-01">January 2001</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc3031">https://www.rfc-editor.org/info/rfc3031</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC3168">[RFC3168]</dt>
        <dd>
<span class="refAuthor">Ramakrishnan, K.</span><span class="refAuthor">, Floyd, S.</span><span class="refAuthor">, and D. Black</span>, <span class="refTitle">"The Addition of Explicit Congestion Notification (ECN) to IP"</span>, <span class="seriesInfo">RFC 3168</span>, <span class="seriesInfo">DOI 10.17487/RFC3168</span>, <time class="refDate" datetime="2001-09">September 2001</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc3168">https://www.rfc-editor.org/info/rfc3168</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC4963">[RFC4963]</dt>
        <dd>
<span class="refAuthor">Heffner, J.</span><span class="refAuthor">, Mathis, M.</span><span class="refAuthor">, and B. Chandler</span>, <span class="refTitle">"IPv4 Reassembly Errors at High Data Rates"</span>, <span class="seriesInfo">RFC 4963</span>, <span class="seriesInfo">DOI 10.17487/RFC4963</span>, <time class="refDate" datetime="2007-07">July 2007</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc4963">https://www.rfc-editor.org/info/rfc4963</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC5033">[RFC5033]</dt>
        <dd>
<span class="refAuthor">Floyd, S.</span><span class="refAuthor"> and M. Allman</span>, <span class="refTitle">"Specifying New Congestion Control Algorithms"</span>, <span class="seriesInfo">BCP 133</span>, <span class="seriesInfo">RFC 5033</span>, <span class="seriesInfo">DOI 10.17487/RFC5033</span>, <time class="refDate" datetime="2007-08">August 2007</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc5033">https://www.rfc-editor.org/info/rfc5033</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC5681">[RFC5681]</dt>
        <dd>
<span class="refAuthor">Allman, M.</span><span class="refAuthor">, Paxson, V.</span><span class="refAuthor">, and E. Blanton</span>, <span class="refTitle">"TCP Congestion Control"</span>, <span class="seriesInfo">RFC 5681</span>, <span class="seriesInfo">DOI 10.17487/RFC5681</span>, <time class="refDate" datetime="2009-09">September 2009</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc5681">https://www.rfc-editor.org/info/rfc5681</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC6550">[RFC6550]</dt>
        <dd>
<span class="refAuthor">Winter, T., Ed.</span><span class="refAuthor">, Thubert, P., Ed.</span><span class="refAuthor">, Brandt, A.</span><span class="refAuthor">, Hui, J.</span><span class="refAuthor">, Kelsey, R.</span><span class="refAuthor">, Levis, P.</span><span class="refAuthor">, Pister, K.</span><span class="refAuthor">, Struik, R.</span><span class="refAuthor">, Vasseur, JP.</span><span class="refAuthor">, and R. Alexander</span>, <span class="refTitle">"RPL: IPv6 Routing Protocol for Low-Power and Lossy Networks"</span>, <span class="seriesInfo">RFC 6550</span>, <span class="seriesInfo">DOI 10.17487/RFC6550</span>, <time class="refDate" datetime="2012-03">March 2012</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc6550">https://www.rfc-editor.org/info/rfc6550</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC6552">[RFC6552]</dt>
        <dd>
<span class="refAuthor">Thubert, P., Ed.</span>, <span class="refTitle">"Objective Function Zero for the Routing Protocol for Low-Power and Lossy Networks (RPL)"</span>, <span class="seriesInfo">RFC 6552</span>, <span class="seriesInfo">DOI 10.17487/RFC6552</span>, <time class="refDate" datetime="2012-03">March 2012</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc6552">https://www.rfc-editor.org/info/rfc6552</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC6554">[RFC6554]</dt>
        <dd>
<span class="refAuthor">Hui, J.</span><span class="refAuthor">, Vasseur, JP.</span><span class="refAuthor">, Culler, D.</span><span class="refAuthor">, and V. Manral</span>, <span class="refTitle">"An IPv6 Routing Header for Source Routes with the Routing Protocol for Low-Power and Lossy Networks (RPL)"</span>, <span class="seriesInfo">RFC 6554</span>, <span class="seriesInfo">DOI 10.17487/RFC6554</span>, <time class="refDate" datetime="2012-03">March 2012</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc6554">https://www.rfc-editor.org/info/rfc6554</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC7554">[RFC7554]</dt>
        <dd>
<span class="refAuthor">Watteyne, T., Ed.</span><span class="refAuthor">, Palattella, M.</span><span class="refAuthor">, and L. Grieco</span>, <span class="refTitle">"Using IEEE 802.15.4e Time-Slotted Channel Hopping (TSCH) in the Internet of Things (IoT): Problem Statement"</span>, <span class="seriesInfo">RFC 7554</span>, <span class="seriesInfo">DOI 10.17487/RFC7554</span>, <time class="refDate" datetime="2015-05">May 2015</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc7554">https://www.rfc-editor.org/info/rfc7554</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC7567">[RFC7567]</dt>
        <dd>
<span class="refAuthor">Baker, F., Ed.</span><span class="refAuthor"> and G. Fairhurst, Ed.</span>, <span class="refTitle">"IETF Recommendations Regarding Active Queue Management"</span>, <span class="seriesInfo">BCP 197</span>, <span class="seriesInfo">RFC 7567</span>, <span class="seriesInfo">DOI 10.17487/RFC7567</span>, <time class="refDate" datetime="2015-07">July 2015</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc7567">https://www.rfc-editor.org/info/rfc7567</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC8085">[RFC8085]</dt>
        <dd>
<span class="refAuthor">Eggert, L.</span><span class="refAuthor">, Fairhurst, G.</span><span class="refAuthor">, and G. Shepherd</span>, <span class="refTitle">"UDP Usage Guidelines"</span>, <span class="seriesInfo">BCP 145</span>, <span class="seriesInfo">RFC 8085</span>, <span class="seriesInfo">DOI 10.17487/RFC8085</span>, <time class="refDate" datetime="2017-03">March 2017</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc8085">https://www.rfc-editor.org/info/rfc8085</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC8087">[RFC8087]</dt>
        <dd>
<span class="refAuthor">Fairhurst, G.</span><span class="refAuthor"> and M. Welzl</span>, <span class="refTitle">"The Benefits of Using Explicit Congestion Notification (ECN)"</span>, <span class="seriesInfo">RFC 8087</span>, <span class="seriesInfo">DOI 10.17487/RFC8087</span>, <time class="refDate" datetime="2017-03">March 2017</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc8087">https://www.rfc-editor.org/info/rfc8087</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC8201">[RFC8201]</dt>
        <dd>
<span class="refAuthor">McCann, J.</span><span class="refAuthor">, Deering, S.</span><span class="refAuthor">, Mogul, J.</span><span class="refAuthor">, and R. Hinden, Ed.</span>, <span class="refTitle">"Path MTU Discovery for IP version 6"</span>, <span class="seriesInfo">STD 87</span>, <span class="seriesInfo">RFC 8201</span>, <span class="seriesInfo">DOI 10.17487/RFC8201</span>, <time class="refDate" datetime="2017-07">July 2017</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc8201">https://www.rfc-editor.org/info/rfc8201</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC8900">[RFC8900]</dt>
      <dd>
<span class="refAuthor">Bonica, R.</span><span class="refAuthor">, Baker, F.</span><span class="refAuthor">, Huston, G.</span><span class="refAuthor">, Hinden, R.</span><span class="refAuthor">, Troan, O.</span><span class="refAuthor">, and F. Gont</span>, <span class="refTitle">"IP Fragmentation Considered Fragile"</span>, <span class="seriesInfo">BCP 230</span>, <span class="seriesInfo">RFC 8900</span>, <span class="seriesInfo">DOI 10.17487/RFC8900</span>, <time class="refDate" datetime="2020-09">September 2020</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc8900">https://www.rfc-editor.org/info/rfc8900</a>&gt;</span>. </dd>
<dd class="break"></dd>
</dl>
</section>
</section>
<div id="rationale">
<section id="section-appendix.a">
      <h2 id="name-rationale">
<a class="section-number selfRef" href="#section-appendix.a">Appendix A. </a><a class="section-name selfRef" href="#name-rationale">Rationale</a>
      </h2>
<p id="section-appendix.a-1">

   There are a number of uses for large packets in Wireless Sensor Networks. Such usages
   may not be the most typical or represent the largest amount of traffic over the LLN;
   however, the associated functionality can be critical enough to justify extra care for
   ensuring effective transport of large packets across the LLN.<a class="pilcrow" href="#section-appendix.a-1">¶</a></p>
<p id="section-appendix.a-2">
   The list of those usages includes:<a class="pilcrow" href="#section-appendix.a-2">¶</a></p>
<p id="section-appendix.a-3">Towards the LLN node:<a class="pilcrow" href="#section-appendix.a-3">¶</a></p>
<ul class="ulEmpty normal">
<li class="ulEmpty normal" id="section-appendix.a-4.1">
          <span class="break"></span><dl class="dlParallel" id="section-appendix.a-4.1.1">
            <dt id="section-appendix.a-4.1.1.1">Firmware update:</dt>
            <dd id="section-appendix.a-4.1.1.2" style="margin-left: 1.5em">
        For example, a new version of the LLN node software is downloaded from a system
    manager over unicast or multicast services.
    Such a reflashing operation typically involves updating a large number of similar
    LLN nodes over a relatively short period of time.<a class="pilcrow" href="#section-appendix.a-4.1.1.2">¶</a>
</dd>
            <dd class="break"></dd>
<dt id="section-appendix.a-4.1.1.3">Packages of commands:</dt>
            <dd id="section-appendix.a-4.1.1.4" style="margin-left: 1.5em">
        A number of commands or a full configuration can be packaged as a single message
        to ensure consistency and enable atomic execution or complete rollback.
    Until such commands are fully received and interpreted, the intended operation will not take effect.<a class="pilcrow" href="#section-appendix.a-4.1.1.4">¶</a>
</dd>
          <dd class="break"></dd>
</dl>
</li>
      </ul>
<p id="section-appendix.a-5">From the LLN node:<a class="pilcrow" href="#section-appendix.a-5">¶</a></p>
<ul class="ulEmpty normal">
<li class="ulEmpty normal" id="section-appendix.a-6.1">
          <span class="break"></span><dl class="dlParallel" id="section-appendix.a-6.1.1">
            <dt id="section-appendix.a-6.1.1.1">Waveform captures:</dt>
            <dd id="section-appendix.a-6.1.1.2" style="margin-left: 1.5em">
        A number of consecutive samples are measured at a high rate for a short time and then are transferred
    from a sensor to a gateway or an edge server as a single large report.<a class="pilcrow" href="#section-appendix.a-6.1.1.2">¶</a>
</dd>
            <dd class="break"></dd>
<dt id="section-appendix.a-6.1.1.3">Data logs:</dt>
            <dd id="section-appendix.a-6.1.1.4" style="margin-left: 1.5em">
        LLN nodes may generate large logs of sampled data
        for later extraction. LLN nodes may also generate
        system logs to assist in diagnosing problems on the
        node or network.<a class="pilcrow" href="#section-appendix.a-6.1.1.4">¶</a>
</dd>
            <dd class="break"></dd>
<dt id="section-appendix.a-6.1.1.5">Large data packets:</dt>
            <dd id="section-appendix.a-6.1.1.6" style="margin-left: 1.5em">
        Rich data types might require more than one fragment.<a class="pilcrow" href="#section-appendix.a-6.1.1.6">¶</a>
</dd>
          <dd class="break"></dd>
</dl>
</li>
      </ul>
<p id="section-appendix.a-7">
    Uncontrolled firmware download or waveform upload can easily result in a massive
    increase of the traffic and saturate the network.<a class="pilcrow" href="#section-appendix.a-7">¶</a></p>
<p id="section-appendix.a-8">
    When a fragment is lost in transmission, the lack of recovery in
           the original fragmentation system of RFC 4944 implies that all
           fragments would need to be resent, further contributing
        to the congestion that caused the initial loss
           and potentially leading to congestion collapse.<a class="pilcrow" href="#section-appendix.a-8">¶</a></p>
<p id="section-appendix.a-9">
    This saturation may lead to excessive radio interference or random early discard
    (leaky bucket) in relaying nodes. Additional queuing and memory congestion may
    result while waiting for a low-power next hop to emerge from its sleep state.<a class="pilcrow" href="#section-appendix.a-9">¶</a></p>
<p id="section-appendix.a-10">
     Considering that RFC 4944
 defines an MTU as 1280 bytes, and that in most incarnations
 (except 802.15.4g) an IEEE Std 802.15.4 frame can limit the link-layer payload
 to as few as 74 bytes, a packet might be fragmented into at
     least 18 fragments at the 6LoWPAN shim layer. Taking into
     account the worst-case header overhead for 6LoWPAN
     Fragmentation and Mesh Addressing headers will increase
     the number of required fragments to around 32. This level
     of fragmentation is much higher than that traditionally
     experienced over the Internet with IPv4 fragments. At the
     same time, the use of radios increases the probability of
     transmission loss, and mesh-under techniques compound that
     risk over multiple hops.<a class="pilcrow" href="#section-appendix.a-10">¶</a></p>
<p id="section-appendix.a-11">
     Mechanisms such as TCP or application-layer segmentation
     could be used to support end-to-end reliable transport. One
     option to support bulk data transfer over a frame-size-constrained
 LLN is to set the Maximum Segment Size to fit within the link
     maximum frame size. However, doing so can add significant header
     overhead to each 802.15.4 frame and cause extraneous acknowledgments
        across the LLN compared to the method in this specification.<a class="pilcrow" href="#section-appendix.a-11">¶</a></p>
</section>
</div>
<div id="req">
<section id="section-appendix.b">
      <h2 id="name-requirements">
<a class="section-number selfRef" href="#section-appendix.b">Appendix B. </a><a class="section-name selfRef" href="#name-requirements">Requirements</a>
      </h2>
<p id="section-appendix.b-1">
 For one-hop communications, a number of LLN
        link layers propose a local acknowledgment mechanism that is enough to
 detect and recover the loss of fragments. In a multi-hop environment, an
        end-to-end fragment recovery mechanism might be a good complement to a
 hop-by-hop Medium Access Control (MAC) recovery.
     This document introduces a simple protocol to recover individual fragments
        between 6LFF endpoints that may be multiple hops away.<a class="pilcrow" href="#section-appendix.b-1">¶</a></p>
<p id="section-appendix.b-2">
        The method addresses the following requirements of an LLN:<a class="pilcrow" href="#section-appendix.b-2">¶</a></p>
<span class="break"></span><dl class="dlParallel" id="section-appendix.b-3">
        <dt id="section-appendix.b-3.1">Number of fragments:</dt>
        <dd id="section-appendix.b-3.2" style="margin-left: 1.5em">The recovery mechanism must support highly fragmented packets, with a maximum of 32 fragments per packet.<a class="pilcrow" href="#section-appendix.b-3.2">¶</a>
</dd>
        <dd class="break"></dd>
<dt id="section-appendix.b-3.3">Minimum acknowledgment overhead:</dt>
        <dd id="section-appendix.b-3.4" style="margin-left: 1.5em"> Because the radio is half duplex, and because of silent time spent in the
    various medium access mechanisms, an acknowledgment consumes roughly as many resources as a data fragment.<a class="pilcrow" href="#section-appendix.b-3.4">¶</a>
</dd>
        <dd class="break"></dd>
<dt id="section-appendix.b-3.5"></dt>
        <dd id="section-appendix.b-3.6" style="margin-left: 1.5em">The new end-to-end fragment recovery mechanism should be able to acknowledge multiple fragments in a single message and
 not require an acknowledgment at all if fragments are already protected at a lower layer.<a class="pilcrow" href="#section-appendix.b-3.6">¶</a>
</dd>
        <dd class="break"></dd>
<dt id="section-appendix.b-3.7">Controlled latency:</dt>
        <dd id="section-appendix.b-3.8" style="margin-left: 1.5em">The recovery mechanism must succeed or give up within the time boundary imposed by the recovery process
    of the upper-layer protocols.<a class="pilcrow" href="#section-appendix.b-3.8">¶</a>
</dd>
        <dd class="break"></dd>
<dt id="section-appendix.b-3.9">Optional congestion control:</dt>
        <dd id="section-appendix.b-3.10" style="margin-left: 1.5em"> The aggregation of multiple concurrent flows may lead to the saturation of the radio network and congestion collapse.<a class="pilcrow" href="#section-appendix.b-3.10">¶</a>
</dd>
        <dd class="break"></dd>
<dt id="section-appendix.b-3.11"></dt>
        <dd id="section-appendix.b-3.12" style="margin-left: 1.5em">The recovery mechanism should provide means for controlling the number of fragments in transit over the LLN.<a class="pilcrow" href="#section-appendix.b-3.12">¶</a>
</dd>
      <dd class="break"></dd>
</dl>
</section>
</div>
<div id="onECN">
<section id="section-appendix.c">
      <h2 id="name-considerations-on-congestio">
<a class="section-number selfRef" href="#section-appendix.c">Appendix C. </a><a class="section-name selfRef" href="#name-considerations-on-congestio">Considerations on Congestion Control</a>
      </h2>
<p id="section-appendix.c-1">Considering that a multi-hop LLN can be a very sensitive environment
 due to the limited queuing capabilities of a
 large population of its nodes, this document recommends a simple and
 conservative approach to congestion control, based on TCP congestion avoidance.<a class="pilcrow" href="#section-appendix.c-1">¶</a></p>
<p id="section-appendix.c-2">Congestion on the forward path is assumed in case of packet loss, and
    packet loss is assumed upon timeout. This document allows controlling the number
    of outstanding fragments that have been transmitted, but for which an
   acknowledgment was not yet received, and that are still covered by the ARQ timer.<a class="pilcrow" href="#section-appendix.c-2">¶</a></p>
<p id="section-appendix.c-3">Congestion on the forward path can also be indicated by an ECN mechanism.
 Though whether and how ECN <span>[<a class="xref" href="#RFC3168">RFC3168</a>]</span> is carried out over the
    LoWPAN is out of scope, this document provides a way for the destination
    endpoint to echo an ECN indication back to the fragmenting endpoint in an
    acknowledgment message as represented in
 <a class="xref" href="#ackfig">Figure 4</a> in <a class="xref" href="#ackfrag">Section 5.2</a>.<a class="pilcrow" href="#section-appendix.c-3">¶</a></p>
<p id="section-appendix.c-4">
    While the support of echoing the ECN at the reassembling endpoint is mandatory, this
    specification only provides a minimalistic behavior on the fragmenting endpoint.
    If an "E" flag is received, the window <span class="bcp14">SHOULD</span> be reduced at least by 1 and at max to 1. Halving the window for each "E" flag received could be a good compromise, but it needs further experimentation. A very simple implementation may just reset the window to 1, so the fragments are sent and acknowledged one by one.<a class="pilcrow" href="#section-appendix.c-4">¶</a></p>
<p id="section-appendix.c-5">
    Note that any action that has been performed upon detection of congestion
    only applies for the transmission of one datagram, and the next datagram
    starts with the configured Window_Size again.<a class="pilcrow" href="#section-appendix.c-5">¶</a></p>
<p id="section-appendix.c-6">
    The exact use of the Acknowledgment Request flag and of the window are left to implementation. An optimistic implementation could send all the fragments up to Window_Size, setting the Acknowledgment Request "X" flag only on the last fragment; wait for the bitmap, which means a gap of half a round-trip time; and resend the losses.
    A pessimistic implementation could set the "X" flag on the first fragment to check that the path works and open the window only upon receiving the RFRAG-ACK. It could then set an "X" flag again on the second fragment and use the window as a credit to send up to Window_Size before it is blocked. In that case, if the RFRAG-ACK comes back before the window starves, the gating factor is the inter-frame gap. If the RFRAG-ACK does not arrive in time, the Window_Size is the gating factor, and the
    transmission of the datagram is delayed.<a class="pilcrow" href="#section-appendix.c-6">¶</a></p>
<p id="section-appendix.c-7">
   It must be noted that even though the inter-frame gap can be used as a flow
   control or a congestion control measure, it also plays a critical role in
   wireless collision avoidance.
   In particular, when a mesh operates on the same channel over multiple hops,
   the forwarding of a fragment over a certain hop may collide with the
   forwarding of the next fragment that is following over a previous hop but that is in the same interference domain. To prevent this, the fragmenting endpoint is required to pace individual fragments within a transmit window with an inter-frame gap. This is needed to ensure that a given fragment is sent only when the previous fragment has had a chance to progress beyond the interference domain of this hop.

   In the case of
   6TiSCH <span>[<a class="xref" href="#I-D.ietf-6tisch-architecture">6TiSCH</a>]</span>, which operates
   over the
   Time-Slotted Channel Hopping (TSCH) mode
   of operation of IEEE 802.15.4 <span>[<a class="xref" href="#RFC7554">RFC7554</a>]</span>, a fragment is forwarded over a different
   channel at a different time, and it makes full sense to transmit the next fragment as
   soon as the previous fragment has had its chance to be forwarded at the next
   hop.<a class="pilcrow" href="#section-appendix.c-7">¶</a></p>
<p id="section-appendix.c-8">
    Depending on the setting of the Window_Size and the inter-frame gap,
    how the window is used, and the number of hops, the Window_Size may or
    may not become the gating factor that blocks the transmission.
    If the sender uses the Window_Size as a credit:<a class="pilcrow" href="#section-appendix.c-8">¶</a></p>
<ul class="normal">
<li class="normal" id="section-appendix.c-9.1">
    a conservative Window_Size of, say, 3 will be the gating factor that limits the transmission rate of the sender -- and causes transmission gaps longer than the inter-frame gap -- as soon as the
    number of hops exceeds 3 in a TSCH network and 5-9 in a single frequency mesh.
    The more hops the more the starving window will add to latency of the transmission.<a class="pilcrow" href="#section-appendix.c-9.1">¶</a>
</li>
        <li class="normal" id="section-appendix.c-9.2">
    The recommendation to align the Window-Size to the round-trip time divided by
    the time per fragment aligns the Window-Size to the time it takes to get the
    RFAG_ACK before the window starves. A Window-Size that is higher than that increases
    the chances of a congestion but does not improve the forward throughput. Considering that the RFRAG-ACK takes the same path as the fragment with the assumption that it travels at roughly the same speed, an inter-frame gap that separates fragments by 2
    hops leads to a Window_Size that is roughly the number of hops.<a class="pilcrow" href="#section-appendix.c-9.2">¶</a>
</li>
        <li class="normal" id="section-appendix.c-9.3">
    Setting the Window-Size to 32 minimizes the cost of the acknowledgment
    in a constrained network and frees bandwidth for the fragments in a half-duplex
    network. Using it increases the risk of congestion if a bottleneck forms, but it
    optimizes the use of resources under normal conditions. When it is used, the
    only protection for the network is the inter-frame gap, which must be chosen
    wisely to prevent the formation of a bottleneck.<a class="pilcrow" href="#section-appendix.c-9.3">¶</a>
</li>
      </ul>
<p id="section-appendix.c-10">
    From the standpoint of a source 6LoWPAN endpoint, an outstanding
    fragment is a fragment that was
 sent but for which no explicit acknowledgment was yet received.
 This means that the fragment might be on the path or received but not yet
    acknowledged, or the acknowledgment might be on the path back. It is also
    possible that either the fragment or the acknowledgment was lost on the
    way.<a class="pilcrow" href="#section-appendix.c-10">¶</a></p>
<p id="section-appendix.c-11">From the fragmenting endpoint standpoint,
 all outstanding fragments might still be in the network and contribute to its congestion.
 There is an assumption, though, that after a certain amount of time, a frame is either received
    or lost, so it is not causing congestion anymore. This amount of time can be estimated based on the round-trip
 time between the 6LoWPAN endpoints. For the lack of a more adapted technique, the method detailed in <span><a class="xref" href="#RFC6298">"Computing TCP's Retransmission Timer"</a> [<a class="xref" href="#RFC6298">RFC6298</a>]</span> may be used for that computation.<a class="pilcrow" href="#section-appendix.c-11">¶</a></p>
<p id="section-appendix.c-12">
    This specification provides the necessary tools for the fragmenting endpoint
    to take congestion control actions and protect the network, but it leaves the
    implementation free to select the action to be taken. The intention is to
    use it to build experience and specify more precisely the congestion control actions
    in one or more future specifications. <span><a class="xref" href="#RFC2914">"Congestion Control Principles"</a> [<a class="xref" href="#RFC2914">RFC2914</a>]</span> and <span><a class="xref" href="#RFC5033">"Specifying New Congestion Control Algorithms"</a> [<a class="xref" href="#RFC5033">RFC5033</a>]</span> provide indications and wisdom that should help through this process.<a class="pilcrow" href="#section-appendix.c-12">¶</a></p>
<p id="section-appendix.c-13">
    <span>[<a class="xref" href="#RFC7567">RFC7567</a>]</span> and <span>[<a class="xref" href="#RFC5681">RFC5681</a>]</span> provide deeper information on why congestion control is needed and how TCP handles it. Basically, the goal here is to
 manage the number of fragments present in the network; this is achieved by reducing the number of outstanding fragments over a congested path by throttling the sources.<a class="pilcrow" href="#section-appendix.c-13">¶</a></p>
</section>
</div>
<section id="section-appendix.d">
      <h2 id="name-acknowledgments">
<a class="section-name selfRef" href="#name-acknowledgments">Acknowledgments</a>
      </h2>
<p id="section-appendix.d-1">The author wishes to thank <span class="contact-name">Michel Veillette</span>, <span class="contact-name">Dario Tedeschi</span>, <span class="contact-name">Laurent Toutain</span>,
<span class="contact-name">Carles Gomez Montenegro</span>, <span class="contact-name">Thomas Watteyne</span>, and <span class="contact-name">Michael Richardson</span> for their in-depth
reviews and comments.
Also, many thanks to <span class="contact-name">Roman Danyliw</span>, <span class="contact-name">Peter Yee</span>, <span class="contact-name">Colin Perkins</span>, <span class="contact-name">Tirumaleswar Reddy.K</span>, <span class="contact-name">Éric Vyncke</span>, <span class="contact-name">Warren Kumari</span>, <span class="contact-name">Magnus Westerlund</span>, <span class="contact-name">Erik Nordmark</span>, and especially <span class="contact-name">Benjamin Kaduk</span> and <span class="contact-name">Mirja Kühlewind</span> for
their careful reviews and help during the IETF Last Call and IESG review process.
Thanks to <span class="contact-name">Jonathan Hui</span>, <span class="contact-name">Jay Werb</span>, <span class="contact-name">Christos Polyzois</span>, <span class="contact-name">Soumitri Kolavennu</span>,
<span class="contact-name">Pat Kinney</span>, <span class="contact-name">Margaret Wasserman</span>, <span class="contact-name">Richard Kelsey</span>, <span class="contact-name">Carsten Bormann</span>, and
<span class="contact-name">Harry Courtice</span> for their various contributions in the long process that lead to this document.<a class="pilcrow" href="#section-appendix.d-1">¶</a></p>
</section>
<div id="authors-addresses">
<section id="section-appendix.e">
      <h2 id="name-authors-address">
<a class="section-name selfRef" href="#name-authors-address">Author's Address</a>
      </h2>
<address class="vcard">
        <div class="left" dir="auto"><span class="fn nameRole">Pascal Thubert (<span class="role">editor</span>)</span></div>
<div class="left" dir="auto"><span class="org">Cisco Systems, Inc.</span></div>
<div class="left" dir="auto"><span class="extended-address">Building D</span></div>
<div class="left" dir="auto"><span class="street-address">45 Allee des Ormes - BP1200</span></div>
<div class="left" dir="auto">
<span class="postal-code">06254</span> <span class="locality">MOUGINS - Sophia Antipolis</span>
</div>
<div class="left" dir="auto"><span class="country-name">France</span></div>
<div class="tel">
<span>Phone:</span>
<a class="tel" href="tel:+33%20497%2023%2026%2034">+33 497 23 26 34</a>
</div>
<div class="email">
<span>Email:</span>
<a class="email" href="mailto:pthubert@cisco.com">pthubert@cisco.com</a>
</div>
</address>
</section>
</div>
<script>const toc = document.getElementById("toc");
toc.querySelector("h2").addEventListener("click", e => {
  toc.classList.toggle("active");
});
toc.querySelector("nav").addEventListener("click", e => {
  toc.classList.remove("active");
});
</script>


</body></html>