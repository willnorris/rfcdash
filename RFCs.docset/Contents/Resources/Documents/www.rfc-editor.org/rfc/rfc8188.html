<html><head></head><body><pre>Internet Engineering Task Force (IETF)                        M. Thomson
Request for Comments: 8188                                       Mozilla
Category: Standards Track                                      June 2017
ISSN: 2070-1721


                  <span class="h1">Encrypted Content-Encoding for HTTP</span>

Abstract

   This memo introduces a content coding for HTTP that allows message
   payloads to be encrypted.

Status of This Memo

   This is an Internet Standards Track document.

   This document is a product of the Internet Engineering Task Force
   (IETF).  It represents the consensus of the IETF community.  It has
   received public review and has been approved for publication by the
   Internet Engineering Steering Group (IESG).  Further information on
   Internet Standards is available in <a href="./rfc7841#section-2">Section 2 of RFC 7841</a>.

   Information about the current status of this document, any errata,
   and how to provide feedback on it may be obtained at
   <a href="http://www.rfc-editor.org/info/rfc8188">http://www.rfc-editor.org/info/rfc8188</a>.

Copyright Notice

   Copyright (c) 2017 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to <a href="https://www.rfc-editor.org/bcp/bcp78">BCP 78</a> and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (<a href="http://trustee.ietf.org/license-info">http://trustee.ietf.org/license-info</a>) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.










<span class="grey">Thomson                      Standards Track                    [Page 1]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-2"></span>
<span class="grey"><a href="./rfc8188">RFC 8188</a>                 HTTP Encryption Coding                June 2017</span>


Table of Contents

   <a href="#section-1">1</a>.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   <a href="#page-2">2</a>
     <a href="#section-1.1">1.1</a>.  Requirements Language . . . . . . . . . . . . . . . . . .   <a href="#page-3">3</a>
   <a href="#section-2">2</a>.  The "aes128gcm" HTTP Content Coding . . . . . . . . . . . . .   <a href="#page-3">3</a>
     <a href="#section-2.1">2.1</a>.  Encryption Content-Coding Header  . . . . . . . . . . . .   <a href="#page-5">5</a>
     <a href="#section-2.2">2.2</a>.  Content-Encryption Key Derivation . . . . . . . . . . . .   <a href="#page-6">6</a>
     <a href="#section-2.3">2.3</a>.  Nonce Derivation  . . . . . . . . . . . . . . . . . . . .   <a href="#page-6">6</a>
   <a href="#section-3">3</a>.  Examples  . . . . . . . . . . . . . . . . . . . . . . . . . .   <a href="#page-7">7</a>
     <a href="#section-3.1">3.1</a>.  Encryption of a Response  . . . . . . . . . . . . . . . .   <a href="#page-7">7</a>
     <a href="#section-3.2">3.2</a>.  Encryption with Multiple Records  . . . . . . . . . . . .   <a href="#page-8">8</a>
   <a href="#section-4">4</a>.  Security Considerations . . . . . . . . . . . . . . . . . . .   <a href="#page-8">8</a>
     <a href="#section-4.1">4.1</a>.  Automatic Decryption  . . . . . . . . . . . . . . . . . .   <a href="#page-9">9</a>
     <a href="#section-4.2">4.2</a>.  Message Truncation  . . . . . . . . . . . . . . . . . . .   <a href="#page-9">9</a>
     <a href="#section-4.3">4.3</a>.  Key and Nonce Reuse . . . . . . . . . . . . . . . . . . .   <a href="#page-9">9</a>
     <a href="#section-4.4">4.4</a>.  Data Encryption Limits  . . . . . . . . . . . . . . . . .  <a href="#page-10">10</a>
     <a href="#section-4.5">4.5</a>.  Content Integrity . . . . . . . . . . . . . . . . . . . .  <a href="#page-10">10</a>
     <a href="#section-4.6">4.6</a>.  Leaking Information in Header Fields  . . . . . . . . . .  <a href="#page-10">10</a>
     <a href="#section-4.7">4.7</a>.  Poisoning Storage . . . . . . . . . . . . . . . . . . . .  <a href="#page-11">11</a>
     <a href="#section-4.8">4.8</a>.  Sizing and Timing Attacks . . . . . . . . . . . . . . . .  <a href="#page-11">11</a>
   <a href="#section-5">5</a>.  IANA Considerations . . . . . . . . . . . . . . . . . . . . .  <a href="#page-12">12</a>
     <a href="#section-5.1">5.1</a>.  The "aes128gcm" HTTP Content Coding . . . . . . . . . . .  <a href="#page-12">12</a>
   <a href="#section-6">6</a>.  References  . . . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-12">12</a>
     <a href="#section-6.1">6.1</a>.  Normative References  . . . . . . . . . . . . . . . . . .  <a href="#page-12">12</a>
     <a href="#section-6.2">6.2</a>.  Informative References  . . . . . . . . . . . . . . . . .  <a href="#page-13">13</a>
   <a href="#appendix-A">Appendix A</a>.  JWE Mapping  . . . . . . . . . . . . . . . . . . . .  <a href="#page-15">15</a>
   Acknowledgements  . . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-16">16</a>
   Author's Address  . . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-16">16</a>

<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/1.%20%20Introduction"></a><a class="selflink" href="#section-1" id="section-1">1</a>.  Introduction</span>

   It is sometimes desirable to encrypt the contents of an HTTP message
   (request or response) so that when the payload is stored (e.g., with
   an HTTP PUT), only someone with the appropriate key can read it.

   For example, it might be necessary to store a file on a server
   without exposing its contents to that server.  Furthermore, that same
   file could be replicated to other servers (to make it more resistant
   to server or network failure), downloaded by clients (to make it
   available offline), etc., without exposing its contents.

   These uses are not met by the use of Transport Layer Security (TLS)
   [<a href="./rfc5246" title='"The Transport Layer Security (TLS) Protocol Version 1.2"'>RFC5246</a>], since it only encrypts the channel between the client and
   server.

   This document specifies a content coding (see <a href="./rfc7231#section-3.1.2">Section 3.1.2 of
   [RFC7231]</a>) for HTTP to serve these and other use cases.




<span class="grey">Thomson                      Standards Track                    [Page 2]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-3"></span>
<span class="grey"><a href="./rfc8188">RFC 8188</a>                 HTTP Encryption Coding                June 2017</span>


   This content coding is not a direct adaptation of message-based
   encryption formats -- such as those that are described by [<a href="./rfc4880" title='"OpenPGP Message Format"'>RFC4880</a>],
   [<a href="./rfc5652" title='"Cryptographic Message Syntax (CMS)"'>RFC5652</a>], [<a href="./rfc7516" title='"JSON Web Encryption (JWE)"'>RFC7516</a>], and [<a href="#ref-XMLENC" title='"XML Encryption Syntax and Processing Version 1.1"'>XMLENC</a>].  Those formats are not suited to
   stream processing, which is necessary for HTTP.  The format described
   here follows more closely to the lower-level constructs described in
   [<a href="./rfc5116" title='"An Interface and Algorithms for Authenticated Encryption"'>RFC5116</a>].

   To the extent that message-based encryption formats use the same
   primitives, the format can be considered to be a sequence of
   encrypted messages with a particular profile.  For instance,
   <a href="#appendix-A">Appendix A</a> explains how the format is congruent with a sequence of
   JSON Web Encryption [<a href="./rfc7516" title='"JSON Web Encryption (JWE)"'>RFC7516</a>] values with a fixed header.

   This mechanism is likely only a small part of a larger design that
   uses content encryption.  How clients and servers acquire and
   identify keys will depend on the use case.  In particular, a key
   management system is not described.

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/1.1.%20%20Requirements%20Language"></a><a class="selflink" href="#section-1.1" id="section-1.1">1.1</a>.  Requirements Language</span>

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
   "OPTIONAL" in this document are to be interpreted as described in <a href="https://www.rfc-editor.org/bcp/bcp14">BCP</a>
   <a href="https://www.rfc-editor.org/bcp/bcp14">14</a> [<a href="./rfc2119" title='"Key words for use in RFCs to Indicate Requirement Levels"'>RFC2119</a>] [<a href="./rfc8174" title='"Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words"'>RFC8174</a>] when, and only when, they appear in all
   capitals, as shown here.

<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/2.%20%20The%20%22aes128gcm%22%20HTTP%20Content%20Coding"></a><a class="selflink" href="#section-2" id="section-2">2</a>.  The "aes128gcm" HTTP Content Coding</span>

   The "aes128gcm" HTTP content coding indicates that a payload has been
   encrypted using Advanced Encryption Standard (AES) in Galois/Counter
   Mode (GCM) as identified as AEAD_AES_128_GCM in <a href="./rfc5116#section-5.1">[RFC5116],
   Section 5.1</a>.  The AEAD_AES_128_GCM algorithm uses a 128-bit content-
   encryption key.

   Using this content coding requires knowledge of a key.  How this key
   is acquired is not defined in this document.

   The "aes128gcm" content coding uses a single fixed set of encryption
   primitives.  Cipher agility is achieved by defining a new content-
   coding scheme.  This ensures that only the HTTP Accept-Encoding
   header field is necessary to negotiate the use of encryption.

   The "aes128gcm" content coding uses a fixed record size.  The final
   encoding consists of a header (see <a href="#section-2.1">Section 2.1</a>) and zero or more
   fixed-size encrypted records; the final record can be smaller than
   the record size.





<span class="grey">Thomson                      Standards Track                    [Page 3]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-4"></span>
<span class="grey"><a href="./rfc8188">RFC 8188</a>                 HTTP Encryption Coding                June 2017</span>


   The record size determines the length of each portion of plaintext
   that is enciphered.  The record size ("rs") is included in the
   content-coding header (see <a href="#section-2.1">Section 2.1</a>).

   +-----------+             content
   |   data    |             any length up to rs-17 octets
   +-----------+
        |
        v
   +-----------+-----+       add a delimiter octet (0x01 or 0x02)
   |   data    | pad |       then 0x00-valued octets to rs-16
   +-----------+-----+       (or less on the last record)
            |
            v
   +--------------------+    encrypt with AEAD_AES_128_GCM;
   |    ciphertext      |    final size is rs;
   +--------------------+    the last record can be smaller

   AEAD_AES_128_GCM produces ciphertext 16 octets longer than its input
   plaintext.  Therefore, the unencrypted content of each record is
   shorter than the record size by 16 octets.  Valid records always
   contain at least a padding delimiter octet and a 16-octet
   authentication tag.

   Each record contains a single padding delimiter octet followed by any
   number of zero octets.  The last record uses a padding delimiter
   octet set to the value 2, all other records have a padding delimiter
   octet value of 1.

   On decryption, the padding delimiter is the last non-zero-valued
   octet of the record.  A decrypter MUST fail if the record contains no
   non-zero octet.  A decrypter MUST fail if the last record contains a
   padding delimiter with a value other than 2 or if any record other
   than the last contains a padding delimiter with a value other than 1.

   The nonce for each record is a 96-bit value constructed from the
   record sequence number and the input-keying material.  Nonce
   derivation is covered in <a href="#section-2.3">Section 2.3</a>.

   The additional data passed to each invocation of AEAD_AES_128_GCM is
   a zero-length octet sequence.

   A consequence of this record structure is that range requests
   [<a href="./rfc7233" title='"Hypertext Transfer Protocol (HTTP/1.1): Range Requests"'>RFC7233</a>] and random access to encrypted payload bodies are possible
   at the granularity of the record size.  Partial records at the ends
   of a range cannot be decrypted.  Thus, it is best if range requests
   start and end on record boundaries.  However, note that random access




<span class="grey">Thomson                      Standards Track                    [Page 4]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-5"></span>
<span class="grey"><a href="./rfc8188">RFC 8188</a>                 HTTP Encryption Coding                June 2017</span>


   to specific parts of encrypted data could be confounded by the
   presence of padding.

   Selecting the record size most appropriate for a given situation
   requires a trade-off.  A smaller record size allows decrypted octets
   to be released more rapidly, which can be appropriate for
   applications that depend on responsiveness.  Smaller records also
   reduce the additional data required if random access into the
   ciphertext is needed.

   Applications that don't depend on streaming, random access, or
   arbitrary padding can use larger records, or even a single record.  A
   larger record size reduces processing and data overheads.

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/2.1.%20%20Encryption%20Content-Coding%20Header"></a><a class="selflink" href="#section-2.1" id="section-2.1">2.1</a>.  Encryption Content-Coding Header</span>

   The content coding uses a header block that includes all parameters
   needed to decrypt the content (other than the key).  The header block
   is placed in the body of a message ahead of the sequence of records.

   +-----------+--------+-----------+---------------+
   | salt (16) | rs (4) | idlen (1) | keyid (idlen) |
   +-----------+--------+-----------+---------------+

   salt:  The "salt" parameter comprises the first 16 octets of the
      "aes128gcm" content-coding header.  The same "salt" parameter
      value MUST NOT be reused for two different payload bodies that
      have the same input-keying material; generating a random salt for
      every application of the content coding ensures that content-
      encryption key reuse is highly unlikely.

   rs:  The "rs" or record size parameter contains an unsigned 32-bit
      integer in network byte order that describes the record size in
      octets.  Note that it is, therefore, impossible to exceed the
      2^36-31 limit on plaintext input to AEAD_AES_128_GCM.  Values
      smaller than 18 are invalid.

   idlen:  The "idlen" parameter is an unsigned 8-bit integer that
      defines the length of the "keyid" parameter.

   keyid:  The "keyid" parameter can be used to identify the keying
      material that is used.  This field is the length determined by the
      "idlen" parameter.  Recipients that receive a message are expected
      to know how to retrieve keys; the "keyid" parameter might be input
      to that process.  A "keyid" parameter SHOULD be a UTF-8-encoded
      [<a href="./rfc3629" title='"UTF-8, a transformation format of ISO 10646"'>RFC3629</a>] string, particularly where the identifier might need to
      be rendered in a textual form.




<span class="grey">Thomson                      Standards Track                    [Page 5]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-6"></span>
<span class="grey"><a href="./rfc8188">RFC 8188</a>                 HTTP Encryption Coding                June 2017</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/2.2.%20%20Content-Encryption%20Key%20Derivation"></a><a class="selflink" href="#section-2.2" id="section-2.2">2.2</a>.  Content-Encryption Key Derivation</span>

   In order to allow the reuse of keying material for multiple different
   HTTP messages, a content-encryption key is derived for each message.
   The content-encryption key is derived from the "salt" parameter using
   the HMAC-based key derivation function (HKDF) described in [<a href="./rfc5869" title='"HMAC-based Extract-and-Expand Key Derivation Function (HKDF)"'>RFC5869</a>]
   using the SHA-256 hash algorithm [<a href="#ref-FIPS180-4">FIPS180-4</a>].

   The value of the "salt" parameter is the salt input to the HKDF.  The
   keying material identified by the "keyid" parameter is the input-
   keying material (IKM) to HKDF.  Input-keying material is expected to
   be provided to recipients separately.  The extract phase of HKDF,
   therefore, produces a pseudorandom key (PRK) as follows:

      PRK = HMAC-SHA-256 (salt, IKM)

   The info parameter to HKDF is set to the ASCII-encoded string
   "Content-Encoding: aes128gcm" and a single zero octet:

      cek_info = "Content-Encoding: aes128gcm" || 0x00

   Note(1):  Concatenation of octet sequences is represented by the "||"
      operator.

   Note(2):  The strings used here and in <a href="#section-2.3">Section 2.3</a> do not include a
      terminating 0x00 octet, as is used in some programming languages.

   AEAD_AES_128_GCM requires a 16-octet (128-bit) content-encryption key
   (CEK), so the length (L) parameter to HKDF is 16.  The second step of
   HKDF can, therefore, be simplified to the first 16 octets of a single
   HMAC:

      CEK = HMAC-SHA-256(PRK, cek_info || 0x01)

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/2.3.%20%20Nonce%20Derivation"></a><a class="selflink" href="#section-2.3" id="section-2.3">2.3</a>.  Nonce Derivation</span>

   The nonce input to AEAD_AES_128_GCM is constructed for each record.
   The nonce for each record is a 12-octet (96-bit) value that is
   derived from the record sequence number, input-keying material, and
   "salt" parameter.

   The input-keying material and "salt" parameter are input to HKDF with
   different info and length (L) parameters.








<span class="grey">Thomson                      Standards Track                    [Page 6]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-7"></span>
<span class="grey"><a href="./rfc8188">RFC 8188</a>                 HTTP Encryption Coding                June 2017</span>


   The length (L) parameter is 12 octets.  The info parameter for the
   nonce is the ASCII-encoded string "Content-Encoding: nonce",
   terminated by a single zero octet:

      nonce_info = "Content-Encoding: nonce" || 0x00

   The result is combined with the record sequence number -- using
   exclusive or -- to produce the nonce.  The record sequence number
   (SEQ) is a 96-bit unsigned integer in network byte order that starts
   at zero.

   Thus, the final nonce for each record is a 12-octet value:

      NONCE = HMAC-SHA-256(PRK, nonce_info || 0x01) XOR SEQ

   This nonce construction prevents removal or reordering of records.

<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/3.%20%20Examples"></a><a class="selflink" href="#section-3" id="section-3">3</a>.  Examples</span>

   This section shows a few examples of the encrypted-content coding.

   Note: All binary values in the examples in this section use base64
   encoding with URL and filename safe alphabet [<a href="./rfc4648" title='"The Base16, Base32, and Base64 Data Encodings"'>RFC4648</a>].  This
   includes the bodies of requests.  Whitespace and line wrapping is
   added to fit formatting constraints.

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/3.1.%20%20Encryption%20of%20a%20Response"></a><a class="selflink" href="#section-3.1" id="section-3.1">3.1</a>.  Encryption of a Response</span>

   Here, a successful HTTP GET response has been encrypted.  This uses a
   record size of 4096 octets and no padding (just the single-octet
   padding delimiter), so only a partial record is present.  The input-
   keying material is identified by an empty string (that is, the
   "keyid" field in the header is zero octets in length).

   The encrypted data in this example is the UTF-8-encoded string "I am
   the walrus".  The input-keying material is the value "yqdlZ-
   tYemfogSmv7Ws5PQ" (in base64url).  The 54-octet content body contains
   a single record and is shown here using 71 base64url characters for
   presentation reasons.

   HTTP/1.1 200 OK
   Content-Type: application/octet-stream
   Content-Length: 54
   Content-Encoding: aes128gcm

   I1BsxtFttlv3u_Oo94xnmwAAEAAA-NAVub2qFgBEuQKRapoZu-IxkIva3MEB1PD-
   ly8Thjg




<span class="grey">Thomson                      Standards Track                    [Page 7]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-8"></span>
<span class="grey"><a href="./rfc8188">RFC 8188</a>                 HTTP Encryption Coding                June 2017</span>


   Note that the media type has been changed to "application/octet-
   stream" to avoid exposing information about the content.
   Alternatively (and equivalently), the Content-Type header field can
   be omitted.

   Intermediate values for this example (all shown using base64url):

   salt (from header) = I1BsxtFttlv3u_Oo94xnmw
   PRK = zyeH5phsIsgUyd4oiSEIy35x-gIi4aM7y0hCF8mwn9g
   CEK = _wniytB-ofscZDh4tbSjHw
   NONCE = Bcs8gkIRKLI8GeI8
   unencrypted data = SSBhbSB0aGUgd2FscnVzAg

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/3.2.%20%20Encryption%20with%20Multiple%20Records"></a><a class="selflink" href="#section-3.2" id="section-3.2">3.2</a>.  Encryption with Multiple Records</span>

   This example shows the same message with input-keying material of
   "BO3ZVPxUlnLORbVGMpbT1Q".  In this example, the plaintext is split
   into records of 25 octets each (that is, the "rs" field in the header
   is 25).  The first record includes one 0x00 padding octet.  This
   means that there are 7 octets of message in the first record and 8 in
   the second.  A key identifier of the UTF-8-encoded string "a1" is
   also included in the header.

   HTTP/1.1 200 OK
   Content-Length: 73
   Content-Encoding: aes128gcm

   uNCkWiNYzKTnBN9ji3-qWAAAABkCYTHOG8chz_gnvgOqdGYovxyjuqRyJFjEDyoF
   1Fvkj6hQPdPHI51OEUKEpgz3SsLWIqS_uA

<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/4.%20%20Security%20Considerations"></a><a class="selflink" href="#section-4" id="section-4">4</a>.  Security Considerations</span>

   This mechanism assumes the presence of a key management framework
   that is used to manage the distribution of keys between valid senders
   and receivers.  Defining key management is part of composing this
   mechanism into a larger application, protocol, or framework.

   Implementation of cryptography -- and key management in particular --
   can be difficult.  For instance, implementations need to account for
   the potential for exposing keying material on side channels, such as
   might be exposed by the time it takes to perform a given operation.
   The requirements for a good implementation of cryptographic
   algorithms can change over time.








<span class="grey">Thomson                      Standards Track                    [Page 8]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-9"></span>
<span class="grey"><a href="./rfc8188">RFC 8188</a>                 HTTP Encryption Coding                June 2017</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/4.1.%20%20Automatic%20Decryption"></a><a class="selflink" href="#section-4.1" id="section-4.1">4.1</a>.  Automatic Decryption</span>

   As a content coding, a "aes128gcm" content coding might be
   automatically removed by a receiver in a way that is not obvious to
   the ultimate consumer of a message.  Recipients that depend on
   content-origin authentication using this mechanism MUST reject
   messages that don't include the "aes128gcm" content coding.

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/4.2.%20%20Message%20Truncation"></a><a class="selflink" href="#section-4.2" id="section-4.2">4.2</a>.  Message Truncation</span>

   This content encoding is designed to permit the incremental
   processing of large messages.  It also permits random access to
   plaintext in a limited fashion.  The content encoding permits a
   receiver to detect when a message is truncated.

   A partially delivered message MUST NOT be processed as though the
   entire message was successfully delivered.  For instance, a partially
   delivered message cannot be cached as though it were complete.

   An attacker might exploit willingness to process partial messages to
   cause a receiver to remain in a specific intermediate state.
   Implementations performing processing on partial messages need to
   ensure that any intermediate processing states don't advantage an
   attacker.

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/4.3.%20%20Key%20and%20Nonce%20Reuse"></a><a class="selflink" href="#section-4.3" id="section-4.3">4.3</a>.  Key and Nonce Reuse</span>

   Encrypting different plaintext with the same content-encryption key
   and nonce in AES-GCM is not safe [<a href="./rfc5116" title='"An Interface and Algorithms for Authenticated Encryption"'>RFC5116</a>].  The scheme defined here
   uses a fixed progression of nonce values.  Thus, a new content-
   encryption key is needed for every application of the content coding.
   Since input-keying material can be reused, a unique "salt" parameter
   is needed to ensure that a content-encryption key is not reused.

   If a content-encryption key is reused -- that is, if input-keying
   material and "salt" parameter are reused -- this could expose the
   plaintext and the authentication key, nullifying the protection
   offered by encryption.  Thus, if the same input-keying material is
   reused, then the "salt" parameter MUST be unique each time.  This
   ensures that the content-encryption key is not reused.  An
   implementation SHOULD generate a random "salt" parameter for every
   message.









<span class="grey">Thomson                      Standards Track                    [Page 9]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-10"></span>
<span class="grey"><a href="./rfc8188">RFC 8188</a>                 HTTP Encryption Coding                June 2017</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/4.4.%20%20Data%20Encryption%20Limits"></a><a class="selflink" href="#section-4.4" id="section-4.4">4.4</a>.  Data Encryption Limits</span>

   There are limits to the data that AEAD_AES_128_GCM can encipher.  The
   maximum value for the record size is limited by the size of the "rs"
   field in the header (see <a href="#section-2.1">Section 2.1</a>), which ensures that the 2^36-31
   limit for a single application of AEAD_AES_128_GCM is not reached
   [<a href="./rfc5116" title='"An Interface and Algorithms for Authenticated Encryption"'>RFC5116</a>].  In order to preserve a 2^-40 probability of
   indistinguishability under chosen plaintext attack (IND-CPA), the
   total amount of plaintext that can be enciphered with the key derived
   from the same input-keying material and salt MUST be less than 2^44.5
   blocks of 16 octets [<a href="#ref-AEBounds" title='"Limits on Authenticated Encryption Use in TLS"'>AEBounds</a>].

   If the record size is a multiple of 16 octets, this means that 398
   terabytes can be encrypted safely, including padding and overhead.
   However, if the record size is not a multiple of 16 octets, the total
   amount of data that can be safely encrypted is reduced because
   partial AES blocks are encrypted.  The worst case is a record size of
   18 octets, for which at most 74 terabytes of plaintext can be
   encrypted, of which at least half is padding.

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/4.5.%20%20Content%20Integrity"></a><a class="selflink" href="#section-4.5" id="section-4.5">4.5</a>.  Content Integrity</span>

   This mechanism only provides content-origin authentication.  The
   authentication tag only ensures that an entity with access to the
   content-encryption key produced the encrypted data.

   Any entity with the content-encryption key can, therefore, produce
   content that will be accepted as valid.  This includes all recipients
   of the same HTTP message.

   Furthermore, any entity that is able to modify both the Content-
   Encoding header field and the HTTP message body can replace the
   contents.  Without the content-encryption key or the input-keying
   material, modifications to, or replacement of, parts of a payload
   body are not possible.

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/4.6.%20%20Leaking%20Information%20in%20Header%20Fields"></a><a class="selflink" href="#section-4.6" id="section-4.6">4.6</a>.  Leaking Information in Header Fields</span>

   Because only the payload body is encrypted, information exposed in
   header fields is visible to anyone who can read the HTTP message.
   This could expose side-channel information.

   For example, the Content-Type header field can leak information about
   the payload body.







<span class="grey">Thomson                      Standards Track                   [Page 10]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-11"></span>
<span class="grey"><a href="./rfc8188">RFC 8188</a>                 HTTP Encryption Coding                June 2017</span>


   There are a number of strategies available to mitigate this threat,
   depending upon the application's threat model and the users'
   tolerance for leaked information:

   1.  Determine that it is not an issue.  For example, if it is
       expected that all content stored will be "application/json", or
       another very common media type, exposing the Content-Type header
       field could be an acceptable risk.

   2.  If it is considered sensitive information and it is possible to
       determine it through other means (e.g., out of band, using hints
       in other representations, etc.), omit the relevant headers, and/
       or normalize them.  In the case of Content-Type, this could be
       accomplished by always sending Content-Type:
       application/octet-stream (the most generic media type), or no
       Content-Type at all.

   3.  If it is considered sensitive information and it is not possible
       to convey it elsewhere, encapsulate the HTTP message using the
       application/http media type (see <a href="./rfc7230#section-8.3.2">Section 8.3.2 of [RFC7230]</a>),
       encrypting that as the payload of the "outer" message.

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/4.7.%20%20Poisoning%20Storage"></a><a class="selflink" href="#section-4.7" id="section-4.7">4.7</a>.  Poisoning Storage</span>

   This mechanism only offers data-origin authentication; it does not
   perform authentication or authorization of the message creator, which
   could still need to be performed (e.g., by HTTP authentication
   [<a href="./rfc7235" title='"Hypertext Transfer Protocol (HTTP/1.1): Authentication"'>RFC7235</a>]).

   This is especially relevant when an HTTP PUT request is accepted by a
   server without decrypting the payload; if the request is
   unauthenticated, it becomes possible for a third party to deny
   service and/or poison the store.

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/4.8.%20%20Sizing%20and%20Timing%20Attacks"></a><a class="selflink" href="#section-4.8" id="section-4.8">4.8</a>.  Sizing and Timing Attacks</span>

   Applications using this mechanism need to be aware that the size of
   encrypted messages, as well as their timing, HTTP methods, URIs and
   so on, may leak sensitive information.  See, for example, [<a href="#ref-NETFLIX" title='"Identifying HTTPS-Protected Netflix Videos in Real-Time"'>NETFLIX</a>]
   or [<a href="#ref-CLINIC" title='"I Know Why You Went to the Clinic: Risks and Realization of HTTPS Traffic Analysis"'>CLINIC</a>].

   This risk can be mitigated through the use of the padding that this
   mechanism provides.  Alternatively, splitting up content into
   segments and storing them separately might reduce exposure.  HTTP/2
   [<a href="./rfc7540" title='"Hypertext Transfer Protocol Version 2 (HTTP/2)"'>RFC7540</a>] combined with TLS [<a href="./rfc5246" title='"The Transport Layer Security (TLS) Protocol Version 1.2"'>RFC5246</a>] might be used to hide the size
   of individual messages.





<span class="grey">Thomson                      Standards Track                   [Page 11]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-12"></span>
<span class="grey"><a href="./rfc8188">RFC 8188</a>                 HTTP Encryption Coding                June 2017</span>


   Developing a padding strategy is difficult.  A good padding strategy
   can depend on context.  Common strategies include padding to a small
   set of fixed lengths, padding to multiples of a value, or padding to
   powers of 2.  Even a good strategy can still cause size information
   to leak if processing activity of a recipient can be observed.  This
   is especially true if the trailing records of a message contain only
   padding.  Distributing non-padding data across records is recommended
   to avoid leaking size information.

<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/5.%20%20IANA%20Considerations"></a><a class="selflink" href="#section-5" id="section-5">5</a>.  IANA Considerations</span>

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/5.1.%20%20The%20%22aes128gcm%22%20HTTP%20Content%20Coding"></a><a class="selflink" href="#section-5.1" id="section-5.1">5.1</a>.  The "aes128gcm" HTTP Content Coding</span>

   This memo registers the "aes128gcm" HTTP content coding in the "HTTP
   Content Coding Registry", as detailed in <a href="#section-2">Section 2</a>.

   o  Name: aes128gcm

   o  Description: AES-GCM encryption with a 128-bit content-encryption
      key

   o  Reference: this specification

<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/6.%20%20References"></a><a class="selflink" href="#section-6" id="section-6">6</a>.  References</span>

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/6.1.%20%20Normative%20References"></a><a class="selflink" href="#section-6.1" id="section-6.1">6.1</a>.  Normative References</span>

   [<a id="ref-FIPS180-4">FIPS180-4</a>]
              National Institute of Standards and Technology, "Secure
              Hash Standard (SHS)", FIPS PUB 180-4,
              DOI 10.6028/NIST.FIPS180-4, August 2015,
              &lt;<a href="http://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf">http://nvlpubs.nist.gov/nistpubs/FIPS/</a>
              <a href="http://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf">NIST.FIPS.180-4.pdf</a>&gt;.

   [<a id="ref-RFC2119">RFC2119</a>]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", <a href="https://www.rfc-editor.org/bcp/bcp14">BCP 14</a>, <a href="./rfc2119">RFC 2119</a>,
              DOI 10.17487/RFC2119, March 1997,
              &lt;<a href="http://www.rfc-editor.org/info/rfc2119">http://www.rfc-editor.org/info/rfc2119</a>&gt;.

   [<a id="ref-RFC3629">RFC3629</a>]  Yergeau, F., "UTF-8, a transformation format of ISO
              10646", STD 63, <a href="./rfc3629">RFC 3629</a>, DOI 10.17487/RFC3629, November
              2003, &lt;<a href="http://www.rfc-editor.org/info/rfc3629">http://www.rfc-editor.org/info/rfc3629</a>&gt;.

   [<a id="ref-RFC5116">RFC5116</a>]  McGrew, D., "An Interface and Algorithms for Authenticated
              Encryption", <a href="./rfc5116">RFC 5116</a>, DOI 10.17487/RFC5116, January 2008,
              &lt;<a href="http://www.rfc-editor.org/info/rfc5116">http://www.rfc-editor.org/info/rfc5116</a>&gt;.





<span class="grey">Thomson                      Standards Track                   [Page 12]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-13"></span>
<span class="grey"><a href="./rfc8188">RFC 8188</a>                 HTTP Encryption Coding                June 2017</span>


   [<a id="ref-RFC5869">RFC5869</a>]  Krawczyk, H. and P. Eronen, "HMAC-based Extract-and-Expand
              Key Derivation Function (HKDF)", <a href="./rfc5869">RFC 5869</a>,
              DOI 10.17487/RFC5869, May 2010,
              &lt;<a href="http://www.rfc-editor.org/info/rfc5869">http://www.rfc-editor.org/info/rfc5869</a>&gt;.

   [<a id="ref-RFC7230">RFC7230</a>]  Fielding, R., Ed. and J. Reschke, Ed., "Hypertext Transfer
              Protocol (HTTP/1.1): Message Syntax and Routing",
              <a href="./rfc7230">RFC 7230</a>, DOI 10.17487/RFC7230, June 2014,
              &lt;<a href="http://www.rfc-editor.org/info/rfc7230">http://www.rfc-editor.org/info/rfc7230</a>&gt;.

   [<a id="ref-RFC7231">RFC7231</a>]  Fielding, R., Ed. and J. Reschke, Ed., "Hypertext Transfer
              Protocol (HTTP/1.1): Semantics and Content", <a href="./rfc7231">RFC 7231</a>,
              DOI 10.17487/RFC7231, June 2014,
              &lt;<a href="http://www.rfc-editor.org/info/rfc7231">http://www.rfc-editor.org/info/rfc7231</a>&gt;.

   [<a id="ref-RFC8174">RFC8174</a>]  Leiba, B., "Ambiguity of Uppercase vs Lowercase in <a href="./rfc2119">RFC</a>
              <a href="./rfc2119">2119</a> Key Words", <a href="https://www.rfc-editor.org/bcp/bcp14">BCP 14</a>, <a href="./rfc8174">RFC 8174</a>, DOI 10.17487/RFC8174,
              May 2017, &lt;<a href="http://www.rfc-editor.org/info/rfc8174">http://www.rfc-editor.org/info/rfc8174</a>&gt;.

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/6.2.%20%20Informative%20References"></a><a class="selflink" href="#section-6.2" id="section-6.2">6.2</a>.  Informative References</span>

   [<a id="ref-AEBounds">AEBounds</a>] Luykx, A. and K. Paterson, "Limits on Authenticated
              Encryption Use in TLS", March 2016,
              &lt;<a href="http://www.isg.rhul.ac.uk/~kp/TLS-AEbounds.pdf">http://www.isg.rhul.ac.uk/~kp/TLS-AEbounds.pdf</a>&gt;.

   [<a id="ref-CLINIC">CLINIC</a>]   Miller, B., Huang, L., Joseph, A., and J. Tygar, "I Know
              Why You Went to the Clinic: Risks and Realization of HTTPS
              Traffic Analysis", DOI 10.1007/978-3-319-08506-7_8, March
              2014, &lt;<a href="https://arxiv.org/abs/1403.0297">https://arxiv.org/abs/1403.0297</a>&gt;.

   [<a id="ref-NETFLIX">NETFLIX</a>]  Reed, A. and M. Kranch, "Identifying HTTPS-Protected
              Netflix Videos in Real-Time", Proceedings of the Seventh
              ACM on Conference on Data and Application Security and
              Privacy CODASPY '17, DOI 10.1145/3029806.3029821, 2017.

   [<a id="ref-RFC4648">RFC4648</a>]  Josefsson, S., "The Base16, Base32, and Base64 Data
              Encodings", <a href="./rfc4648">RFC 4648</a>, DOI 10.17487/RFC4648, October 2006,
              &lt;<a href="http://www.rfc-editor.org/info/rfc4648">http://www.rfc-editor.org/info/rfc4648</a>&gt;.

   [<a id="ref-RFC4880">RFC4880</a>]  Callas, J., Donnerhacke, L., Finney, H., Shaw, D., and R.
              Thayer, "OpenPGP Message Format", <a href="./rfc4880">RFC 4880</a>,
              DOI 10.17487/RFC4880, November 2007,
              &lt;<a href="http://www.rfc-editor.org/info/rfc4880">http://www.rfc-editor.org/info/rfc4880</a>&gt;.

   [<a id="ref-RFC5246">RFC5246</a>]  Dierks, T. and E. Rescorla, "The Transport Layer Security
              (TLS) Protocol Version 1.2", <a href="./rfc5246">RFC 5246</a>,
              DOI 10.17487/RFC5246, August 2008,
              &lt;<a href="http://www.rfc-editor.org/info/rfc5246">http://www.rfc-editor.org/info/rfc5246</a>&gt;.



<span class="grey">Thomson                      Standards Track                   [Page 13]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-14"></span>
<span class="grey"><a href="./rfc8188">RFC 8188</a>                 HTTP Encryption Coding                June 2017</span>


   [<a id="ref-RFC5652">RFC5652</a>]  Housley, R., "Cryptographic Message Syntax (CMS)", STD 70,
              <a href="./rfc5652">RFC 5652</a>, DOI 10.17487/RFC5652, September 2009,
              &lt;<a href="http://www.rfc-editor.org/info/rfc5652">http://www.rfc-editor.org/info/rfc5652</a>&gt;.

   [<a id="ref-RFC7233">RFC7233</a>]  Fielding, R., Ed., Lafon, Y., Ed., and J. Reschke, Ed.,
              "Hypertext Transfer Protocol (HTTP/1.1): Range Requests",
              <a href="./rfc7233">RFC 7233</a>, DOI 10.17487/RFC7233, June 2014,
              &lt;<a href="http://www.rfc-editor.org/info/rfc7233">http://www.rfc-editor.org/info/rfc7233</a>&gt;.

   [<a id="ref-RFC7235">RFC7235</a>]  Fielding, R., Ed. and J. Reschke, Ed., "Hypertext Transfer
              Protocol (HTTP/1.1): Authentication", <a href="./rfc7235">RFC 7235</a>,
              DOI 10.17487/RFC7235, June 2014,
              &lt;<a href="http://www.rfc-editor.org/info/rfc7235">http://www.rfc-editor.org/info/rfc7235</a>&gt;.

   [<a id="ref-RFC7516">RFC7516</a>]  Jones, M. and J. Hildebrand, "JSON Web Encryption (JWE)",
              <a href="./rfc7516">RFC 7516</a>, DOI 10.17487/RFC7516, May 2015,
              &lt;<a href="http://www.rfc-editor.org/info/rfc7516">http://www.rfc-editor.org/info/rfc7516</a>&gt;.

   [<a id="ref-RFC7540">RFC7540</a>]  Belshe, M., Peon, R., and M. Thomson, Ed., "Hypertext
              Transfer Protocol Version 2 (HTTP/2)", <a href="./rfc7540">RFC 7540</a>,
              DOI 10.17487/RFC7540, May 2015,
              &lt;<a href="http://www.rfc-editor.org/info/rfc7540">http://www.rfc-editor.org/info/rfc7540</a>&gt;.

   [<a id="ref-XMLENC">XMLENC</a>]   Eastlake, D., Reagle, J., Hirsch, F., and T. Roessler,
              "XML Encryption Syntax and Processing Version 1.1", World
              Wide Web Consortium Recommendation
              REC-xmlenc-core1-20130411, April 2013,
              &lt;<a href="http://www.w3.org/TR/2013/REC-xmlenc-core1-20130411">http://www.w3.org/TR/2013/REC-xmlenc-core1-20130411</a>&gt;.























<span class="grey">Thomson                      Standards Track                   [Page 14]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-15"></span>
<span class="grey"><a href="./rfc8188">RFC 8188</a>                 HTTP Encryption Coding                June 2017</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/Appendix%20A.%20%20JWE%20Mapping"></a><a class="selflink" href="#appendix-A" id="appendix-A">Appendix A</a>.  JWE Mapping</span>

   The "aes128gcm" content coding can be considered as a sequence of
   JSON Web Encryption (JWE) [<a href="./rfc7516" title='"JSON Web Encryption (JWE)"'>RFC7516</a>] objects, each corresponding to a
   single fixed-size record that includes trailing padding.  The
   following transformations are applied to a JWE object that might be
   expressed using the JWE Compact Serialization:

   o  The JWE Protected Header is fixed to the value { "alg": "dir",
      "enc": "A128GCM" }, describing direct encryption using AES-GCM
      with a 128-bit content-encryption key.  This header is not
      transmitted, it is instead implied by the value of the Content-
      Encoding header field.

   o  The JWE Encrypted Key is empty, as stipulated by the direct
      encryption algorithm.

   o  The JWE Initialization Vector ("iv") for each record is set to the
      exclusive-or of the 96-bit record sequence number, starting at
      zero, and a value derived from the input-keying material (see
      <a href="#section-2.3">Section 2.3</a>).  This value is also not transmitted.

   o  The final value is the concatenated header, JWE Ciphertext, and
      JWE Authentication Tag, all expressed without base64url encoding.
      The "." separator is omitted, since the length of these fields is
      known.

   Thus, the example in <a href="#section-3.1">Section 3.1</a> can be rendered using the JWE
   Compact Serialization as:

   eyAiYWxnIjogImRpciIsICJlbmMiOiAiQTEyOEdDTSIgfQ..Bcs8gkIRKLI8GeI8.
   -NAVub2qFgBEuQKRapoZuw.4jGQi9rcwQHU8P6XLxOGOA

   Where the first line represents the fixed JWE Protected Header, an
   empty JWE Encrypted Key, and the algorithmically determined JWE
   Initialization Vector.  The second line contains the encoded body,
   split into JWE Ciphertext and JWE Authentication Tag.














<span class="grey">Thomson                      Standards Track                   [Page 15]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-16"></span>
<span class="grey"><a href="./rfc8188">RFC 8188</a>                 HTTP Encryption Coding                June 2017</span>


Acknowledgements

   Mark Nottingham was an original author of this document.

   The following people provided valuable input: Richard Barnes, David
   Benjamin, Peter Beverloo, JR Conlin, Mike Jones, Stephen Farrell,
   Adam Langley, James Manger, John Mattsson, Julian Reschke, Eric
   Rescorla, Jim Schaad, and Magnus Westerlund.

Author's Address

   Martin Thomson
   Mozilla

   Email: martin.thomson@gmail.com




































Thomson                      Standards Track                   [Page 16]
</pre>
</body></html>