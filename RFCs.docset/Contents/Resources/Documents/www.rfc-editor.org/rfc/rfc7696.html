<html><head></head><body><pre>Internet Engineering Task Force (IETF)                        R. Housley
Request for Comments: 7696                                Vigil Security
BCP: 201                                                   November 2015
Category: Best Current Practice
ISSN: 2070-1721


             <span class="h1">Guidelines for Cryptographic Algorithm Agility</span>
            <span class="h1">and Selecting Mandatory-to-Implement Algorithms</span>

Abstract

   Many IETF protocols use cryptographic algorithms to provide
   confidentiality, integrity, authentication, or digital signature.
   Communicating peers must support a common set of cryptographic
   algorithms for these mechanisms to work properly.  This memo provides
   guidelines to ensure that protocols have the ability to migrate from
   one mandatory-to-implement algorithm suite to another over time.

Status of This Memo

   This memo documents an Internet Best Current Practice.

   This document is a product of the Internet Engineering Task Force
   (IETF).  It represents the consensus of the IETF community.  It has
   received public review and has been approved for publication by the
   Internet Engineering Steering Group (IESG).  Further information on
   BCPs is available in <a href="./rfc5741#section-2">Section 2 of RFC 5741</a>.

   Information about the current status of this document, any errata,
   and how to provide feedback on it may be obtained at
   <a href="http://www.rfc-editor.org/info/rfc7696">http://www.rfc-editor.org/info/rfc7696</a>.

Copyright Notice

   Copyright (c) 2015 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to <a href="https://www.rfc-editor.org/bcp/bcp78">BCP 78</a> and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (<a href="http://trustee.ietf.org/license-info">http://trustee.ietf.org/license-info</a>) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.




<span class="grey">Housley                   Best Current Practice                 [Page 1]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-2"></span>
<span class="grey"><a href="./rfc7696">RFC 7696</a>        Guidelines for Cryptographic Alg Agility   November 2015</span>


Table of Contents

   <a href="#section-1">1</a>.  Introduction . . . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-2">2</a>
     <a href="#section-1.1">1.1</a>.  Terminology  . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-3">3</a>
   <a href="#section-2">2</a>.  Algorithm Agility Guidelines . . . . . . . . . . . . . . . . .  <a href="#page-3">3</a>
     <a href="#section-2.1">2.1</a>.  Algorithm Identifiers  . . . . . . . . . . . . . . . . . .  <a href="#page-4">4</a>
     <a href="#section-2.2">2.2</a>.  Mandatory-to-Implement Algorithms  . . . . . . . . . . . .  <a href="#page-5">5</a>
       <a href="#section-2.2.1">2.2.1</a>.  Platform Specifications  . . . . . . . . . . . . . . .  <a href="#page-5">5</a>
       <a href="#section-2.2.2">2.2.2</a>.  Cryptographic Key Size . . . . . . . . . . . . . . . .  <a href="#page-5">5</a>
       <a href="#section-2.2.3">2.2.3</a>.  Providing Notice of Expected Changes . . . . . . . . .  <a href="#page-6">6</a>
     <a href="#section-2.3">2.3</a>.  Transitioning from Weak Algorithms . . . . . . . . . . . .  <a href="#page-6">6</a>
     <a href="#section-2.4">2.4</a>.  Algorithm Transition Mechanisms  . . . . . . . . . . . . .  <a href="#page-7">7</a>
     <a href="#section-2.5">2.5</a>.  Cryptographic Key Management . . . . . . . . . . . . . . .  <a href="#page-8">8</a>
     <a href="#section-2.6">2.6</a>.  Preserving Interoperability  . . . . . . . . . . . . . . .  <a href="#page-8">8</a>
     <a href="#section-2.7">2.7</a>.  Balancing Security Strength  . . . . . . . . . . . . . . .  <a href="#page-9">9</a>
     <a href="#section-2.8">2.8</a>.  Balancing Protocol Complexity  . . . . . . . . . . . . . . <a href="#page-10">10</a>
     <a href="#section-2.9">2.9</a>.  Opportunistic Security . . . . . . . . . . . . . . . . . . <a href="#page-10">10</a>
   <a href="#section-3">3</a>.  Cryptographic Algorithm Specifications . . . . . . . . . . . . <a href="#page-11">11</a>
     <a href="#section-3.1">3.1</a>.  Choosing Mandatory-to-Implement Algorithms . . . . . . . . <a href="#page-11">11</a>
     <a href="#section-3.2">3.2</a>.  Too Many Choices Can Be Harmful  . . . . . . . . . . . . . <a href="#page-12">12</a>
     <a href="#section-3.3">3.3</a>.  Picking One True Cipher Suite Can Be Harmful . . . . . . . <a href="#page-13">13</a>
     <a href="#section-3.4">3.4</a>.  National Cipher Suites . . . . . . . . . . . . . . . . . . <a href="#page-14">14</a>
   <a href="#section-4">4</a>.  Security Considerations  . . . . . . . . . . . . . . . . . . . <a href="#page-14">14</a>
   <a href="#section-5">5</a>.  IANA Considerations  . . . . . . . . . . . . . . . . . . . . . <a href="#page-16">16</a>
   <a href="#section-6">6</a>.  Normative References . . . . . . . . . . . . . . . . . . . . . <a href="#page-16">16</a>
   <a href="#section-7">7</a>.  Informative References . . . . . . . . . . . . . . . . . . . . <a href="#page-16">16</a>
   Acknowledgements . . . . . . . . . . . . . . . . . . . . . . . . . <a href="#page-19">19</a>
   Author's Address . . . . . . . . . . . . . . . . . . . . . . . . . <a href="#page-19">19</a>

<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/1.%20%20Introduction"></a><a class="selflink" href="#section-1" id="section-1">1</a>.  Introduction</span>

   Many IETF protocols use cryptographic algorithms to provide
   confidentiality, integrity, authentication, or digital signature.
   For interoperability, communicating peers must support a common set
   of cryptographic algorithms.  In most cases, a combination of
   compatible cryptographic algorithms will be used to provide the
   desired security services.  The set of cryptographic algorithms being
   used at a particular time is often referred to as a cryptographic
   algorithm suite or cipher suite.  In a protocol, algorithm
   identifiers might name a single cryptographic algorithm or a full
   suite of algorithms.

   Cryptographic algorithms age; they become weaker with time.  As new
   cryptanalysis techniques are developed and computing capabilities
   improve, the work required to break a particular cryptographic
   algorithm will reduce, making an attack on the algorithm more
   feasible for more attackers.  While it is unknown how cryptoanalytic
   attacks will evolve, it is certain that they will get better.  It is



<span class="grey">Housley                   Best Current Practice                 [Page 2]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-3"></span>
<span class="grey"><a href="./rfc7696">RFC 7696</a>        Guidelines for Cryptographic Alg Agility   November 2015</span>


   unknown how much better they will become or when the advances will
   happen.  Protocol designers need to assume that advances in computing
   power or advances in cryptoanalytic techniques will eventually make
   any algorithm obsolete.  For this reason, protocols need mechanisms
   to migrate from one algorithm suite to another over time.

   Algorithm agility is achieved when a protocol can easily migrate from
   one algorithm suite to another more desirable one, over time.  For
   the protocol implementer, this means that implementations should be
   modular to easily accommodate the insertion of new algorithms or
   suites of algorithms.  Ideally, implementations will also provide a
   way to measure when deployed implementations have shifted away from
   the old algorithms and to the better ones.  For the protocol
   designer, algorithm agility means that one or more algorithm or suite
   identifiers must be supported, the set of mandatory-to-implement
   algorithms will change over time, and an IANA registry of algorithm
   identifiers will be needed.

   Algorithm identifiers by themselves are not sufficient to ensure easy
   migration.  Action by people that maintain implementations and
   operate services is needed to develop, deploy, and adjust
   configuration settings to enable the new more desirable algorithms
   and to deprecate or disable older, less desirable ones.  For various
   reasons, most notably interoperability concerns, experience has shown
   that it has proven difficult for implementers and administrators to
   remove or disable weak algorithms.  Further, the inability of legacy
   systems and resource-constrained devices to support new algorithms
   adds to those concerns.  As a result, people live with weaker
   algorithms, sometimes seriously flawed ones, well after experts
   recommend migration.

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/1.1.%20%20Terminology"></a><a class="selflink" href="#section-1.1" id="section-1.1">1.1</a>.  Terminology</span>

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in [<a href="./rfc2119" title='"Key words for use in RFCs to Indicate Requirement Levels"'>RFC2119</a>].

<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/2.%20%20Algorithm%20Agility%20Guidelines"></a><a class="selflink" href="#section-2" id="section-2">2</a>.  Algorithm Agility Guidelines</span>

   These guidelines are for use by IETF working groups and protocol
   authors for IETF protocols that make use of cryptographic algorithms.
   Past attempts at algorithm agility have not been completely
   successful, and this section provides some insights from those
   experiences.







<span class="grey">Housley                   Best Current Practice                 [Page 3]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-4"></span>
<span class="grey"><a href="./rfc7696">RFC 7696</a>        Guidelines for Cryptographic Alg Agility   November 2015</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/2.1.%20%20Algorithm%20Identifiers"></a><a class="selflink" href="#section-2.1" id="section-2.1">2.1</a>.  Algorithm Identifiers</span>

   IETF protocols that make use of cryptographic algorithms MUST support
   one or more algorithms or suites.  The protocol MUST include a
   mechanism to identify the algorithm or suite that is being used.  An
   algorithm identifier might be explicitly carried in the protocol.
   Alternatively, a management mechanism can be used to identify the
   algorithm.  For example, an entry in a key table that includes a key
   value and an algorithm identifier might be sufficient.

   If a protocol does not carry an algorithm identifier, then the
   protocol version number or some other major change is needed to
   transition from one algorithm to another.  The inclusion of an
   algorithm identifier is a minimal step toward cryptographic algorithm
   agility.

   Sometimes a combination of protocol version number and explicit
   algorithm or suite identifiers is appropriate.  For example, the
   Transport Layer Security (TLS) [<a href="./rfc5246" title='"The Transport Layer Security (TLS) Protocol Version 1.2"'>RFC5246</a>] version number names the
   default key derivation function, and the cipher suite identifier
   names the rest of the needed algorithms.

   Some approaches carry one identifier for each algorithm that is used.
   Other approaches carry one identifier for a full suite of algorithms.
   Both approaches are used in IETF protocols.  Designers are encouraged
   to pick one of these approaches and use it consistently throughout
   the protocol or family of protocols.  Suite identifiers make it
   easier for the protocol designer to ensure that the algorithm
   selections are complete and compatible for future assignments.
   However, suite identifiers inherently face a combinatoric explosion
   as new algorithms are defined.  Algorithm identifiers, on the other
   hand, impose a burden on implementations by forcing a determination
   at run-time regarding which algorithm combinations are acceptable.

   Regardless of the approach used, protocols historically negotiate the
   symmetric cipher and cipher mode together to ensure that they are
   compatible.

   In the IPsec protocol suite, the Internet Key Exchange Protocol
   version 2 (IKEv2) [<a href="./rfc7296" title='"Internet Key Exchange Protocol Version 2 (IKEv2)"'>RFC7296</a>] carries the algorithm identifiers for the
   Authentication Header (AH) [<a href="./rfc4302" title='"IP Authentication Header"'>RFC4302</a>] and the Encapsulating Security
   Payload (ESP) [<a href="./rfc4303" title='"IP Encapsulating Security Payload (ESP)"'>RFC4303</a>].  Such separation is a completely fine design
   choice.  In contrast, TLS [<a href="./rfc5246" title='"The Transport Layer Security (TLS) Protocol Version 1.2"'>RFC5246</a>] carries cipher suite identifiers,
   which is also a completely fine design choice.







<span class="grey">Housley                   Best Current Practice                 [Page 4]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-5"></span>
<span class="grey"><a href="./rfc7696">RFC 7696</a>        Guidelines for Cryptographic Alg Agility   November 2015</span>


   An IANA registry SHOULD be used for these algorithm or suite
   identifiers.  Once an algorithm identifier is added to the registry,
   it should not be changed or removed.  However, it is desirable to
   mark a registry entry as deprecated when implementation is no longer
   advisable.

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/2.2.%20%20Mandatory-to-Implement%20Algorithms"></a><a class="selflink" href="#section-2.2" id="section-2.2">2.2</a>.  Mandatory-to-Implement Algorithms</span>

   For secure interoperability, <a href="https://www.rfc-editor.org/bcp/bcp61">BCP 61</a> [<a href="./rfc3365" title='"Strong Security Requirements for Internet Engineering Task Force Standard Protocols"'>RFC3365</a>] recognizes that
   communicating peers that use cryptographic mechanisms must support a
   common set of strong cryptographic algorithms.  For this reason, IETF
   protocols that employ cryptography MUST specify one or more strong
   mandatory-to-implement algorithms or suites.  This does not require
   all deployments to use this algorithm or suite, but it does require
   that it be available to all deployments.

   The IETF needs to be able to change the mandatory-to-implement
   algorithms over time.  It is highly desirable to make this change
   without updating the base protocol specification.  To achieve this
   goal, it is RECOMMENDED that the base protocol specification includes
   a reference to a companion algorithms document, allowing the update
   of one document without necessarily requiring an update to the other.
   This division also facilitates the advancement of the base protocol
   specification on the standards maturity ladder even if the algorithm
   document changes frequently.

   The IETF SHOULD keep the set of mandatory-to-implement algorithms
   small.  To do so, the set of algorithms will necessarily change over
   time, and the transition SHOULD happen before the algorithms in the
   current set have weakened to the breaking point.

<span class="h4"><a class="dashAnchor" name="//apple_ref/cpp/Section/2.2.1.%20%20Platform%20Specifications"></a><a class="selflink" href="#section-2.2.1" id="section-2.2.1">2.2.1</a>.  Platform Specifications</span>

   Note that mandatory-to-implement algorithms or suites are not
   specified for protocols that are embedded in other protocols; in
   these cases, the system-level protocol specification identifies the
   mandatory-to-implement algorithm or suite.  For example, S/MIME
   [<a href="./rfc5751" title='"Secure/Multipurpose Internet Mail Extensions (S/MIME) Version 3.2 Message Specification"'>RFC5751</a>] makes use of the cryptographic message Syntax (CMS)
   [<a href="./rfc5652" title='"Cryptographic Message Syntax (CMS)"'>RFC5652</a>], and S/MIME specifies the mandatory-to-implement
   algorithms, not CMS.  This approach allows other protocols to make
   use of CMS and make different mandatory-to-implement algorithm
   choices.

<span class="h4"><a class="dashAnchor" name="//apple_ref/cpp/Section/2.2.2.%20%20Cryptographic%20Key%20Size"></a><a class="selflink" href="#section-2.2.2" id="section-2.2.2">2.2.2</a>.  Cryptographic Key Size</span>

   Some cryptographic algorithms are inherently tied to a specific key
   size, but others allow many different key sizes.  Likewise, some
   algorithms support parameters of different sizes, such as integrity



<span class="grey">Housley                   Best Current Practice                 [Page 5]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-6"></span>
<span class="grey"><a href="./rfc7696">RFC 7696</a>        Guidelines for Cryptographic Alg Agility   November 2015</span>


   check values or nonces.  The algorithm specification MUST identify
   the specific key sizes and parameter sizes that are to be supported.
   When more than one key size is available, expect the mandatory-to-
   implement key size to increase over time.

   Guidance on cryptographic key size for asymmetric keys can be found
   in <a href="https://www.rfc-editor.org/bcp/bcp86">BCP 86</a> [<a href="./rfc3766" title='"Determining Strengths For Public Keys Used For Exchanging Symmetric Keys"'>RFC3766</a>].

   Guidance on cryptographic key size for symmetric keys can be found in
   <a href="https://www.rfc-editor.org/bcp/bcp195">BCP 195</a> [<a href="./rfc7525" title='"Recommendations for Secure Use of Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS)"'>RFC7525</a>].

<span class="h4"><a class="dashAnchor" name="//apple_ref/cpp/Section/2.2.3.%20%20Providing%20Notice%20of%20Expected%20Changes"></a><a class="selflink" href="#section-2.2.3" id="section-2.2.3">2.2.3</a>.  Providing Notice of Expected Changes</span>

   Fortunately, algorithm failures without warning are rare.  More
   often, algorithm transition is the result of age.  For example, the
   transition from DES to Triple-DES to AES took place over decades,
   causing a shift in symmetric block cipher strength from 56 bits to
   112 bits to 128 bits.  Where possible, authors SHOULD provide notice
   to implementers about expected algorithm transitions.  One approach
   that was first used in <a href="./rfc4307">RFC 4307</a> [<a href="./rfc4307" title='"Cryptographic Algorithms for Use in the Internet Key Exchange Version 2 (IKEv2)"'>RFC4307</a>] is to use SHOULD+, SHOULD-,
   and MUST- in the specification of algorithms.  The definitions below
   are slightly modified from those in <a href="./rfc4307">RFC 4307</a>.

      SHOULD+  This term means the same as SHOULD.  However, it is
               likely that an algorithm marked as SHOULD+ will be
               promoted to a MUST in the future.

      SHOULD-  This term means the same as SHOULD.  However, it is
               likely that an algorithm marked as SHOULD- will be
               deprecated to a MAY or worse in the future.

      MUST-    This term means the same as MUST.  However, it is
               expected that an algorithm marked as MUST- will be
               downgraded in the future.  Although the status of the
               algorithm will be determined at a later time, it is
               reasonable to expect that a the status of a MUST-
               algorithm will remain at least a SHOULD or a SHOULD-.

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/2.3.%20%20Transitioning%20from%20Weak%20Algorithms"></a><a class="selflink" href="#section-2.3" id="section-2.3">2.3</a>.  Transitioning from Weak Algorithms</span>

   Transition from an old algorithm that is found to be weak can be
   tricky.  It is of course straightforward to specify the use of a new,
   better algorithm.  And then, when the new algorithm is widely
   deployed, the old algorithm ought no longer be used.  However,
   knowledge about the implementation and deployment of the new
   algorithm will always be imperfect, so one cannot be completely
   assured of interoperability with the new algorithm.




<span class="grey">Housley                   Best Current Practice                 [Page 6]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-7"></span>
<span class="grey"><a href="./rfc7696">RFC 7696</a>        Guidelines for Cryptographic Alg Agility   November 2015</span>


   Algorithm transition is naturally facilitated as part of an algorithm
   selection or negotiation mechanism.  Protocols traditionally select
   the best algorithm or suite that is supported by all communicating
   peers and acceptable by their policies.  In addition, a mechanism is
   needed to determine whether the new algorithm has been deployed.  For
   example, SMIMECapabilities [<a href="./rfc5751" title='"Secure/Multipurpose Internet Mail Extensions (S/MIME) Version 3.2 Message Specification"'>RFC5751</a>] allows S/MIME mail user agents
   to share the list of algorithms that they are willing to use in
   preference order.  For another example, the DNSSEC EDNS0 option
   [<a href="./rfc6975" title='"Signaling Cryptographic Algorithm Understanding in DNS Security Extensions (DNSSEC)"'>RFC6975</a>] measures the acceptance and use of new digital signing
   algorithms.

   In the Resource Public Key Infrastructure (RPKI), a globally
   recognized digital signature is needed.  <a href="https://www.rfc-editor.org/bcp/bcp182">BCP 182</a> [<a href="./rfc6916" title='"Algorithm Agility Procedure for the Resource Public Key Infrastructure (RPKI)"'>RFC6916</a>] provides
   an approach to transition, where a second signature algorithm is
   introduced and then the original one is phased out.

   In the worst case, the old algorithm may be found to be tragically
   flawed, permitting a casual attacker to download a simple script to
   break it.  Sadly, this has happened when a secure algorithm is used
   incorrectly or used with poor key management, resulting in a weak
   cryptographic algorithm suite.  In such situations, the protection
   offered by the algorithm is severely compromised, perhaps to the
   point that one wants to stop using the weak suite altogether,
   rejecting offers to use the weak suite well before the new suite is
   widely deployed.

   In any case, there comes a point in time where one refuses to use the
   old, weak algorithm or suite.  This can happen on a flag day, or each
   installation can select a date on their own.

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/2.4.%20%20Algorithm%20Transition%20Mechanisms"></a><a class="selflink" href="#section-2.4" id="section-2.4">2.4</a>.  Algorithm Transition Mechanisms</span>

   Cryptographic algorithm selection or negotiation SHOULD be integrity
   protected.  If selection is not integrity protected, then the
   protocol will be subject to a downgrade attack.  Without integrity
   protection of algorithm or suite selection, the attempt to transition
   to a new algorithm or suite may introduce new opportunities for
   downgrade attacks.

   Transition mechanisms need to consider the algorithm that is used to
   provide integrity protection for algorithm negotiation itself.

   If a protocol specifies a single mandatory-to-implement integrity
   algorithm, eventually that algorithm will be found to be weak.







<span class="grey">Housley                   Best Current Practice                 [Page 7]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-8"></span>
<span class="grey"><a href="./rfc7696">RFC 7696</a>        Guidelines for Cryptographic Alg Agility   November 2015</span>


   Extra care is needed when a mandatory-to-implement algorithm is used
   to provide integrity protection for the negotiation of other
   cryptographic algorithms.  In this situation, a flaw in the
   mandatory-to-implement algorithm may allow an attacker to influence
   the choices of the other algorithms.

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/2.5.%20%20Cryptographic%20Key%20Establishment"></a><a class="selflink" href="#section-2.5" id="section-2.5">2.5</a>.  Cryptographic Key Establishment</span>

   Traditionally, protocol designers have avoided more than one approach
   to exchanges that establish cryptographic keys because it makes the
   security analysis of the overall protocol more difficult.  When
   frameworks such as the Extensible Authentication Protocol (EAP)
   [<a href="./rfc3748" title='"Extensible Authentication Protocol (EAP)"'>RFC3748</a>] and Simple Authentication and Security Layer (SASL)
   [<a href="./rfc4422" title='"Simple Authentication and Security Layer (SASL)"'>RFC4422</a>] are employed, key establishment is very flexible, often
   hiding many of the details from the application.  This results in
   protocols that support multiple key establishment approaches.  In
   fact, the key establishment approach itself is negotiable, which
   creates a design challenge to protect the negotiation of the key
   establishment approach before it is used to produce cryptographic
   keys.

   Protocols can negotiate a key establishment approach, derive an
   initial cryptographic key, and then authenticate the negotiation.
   However, if the authentication fails, the only recourse is to start
   the negotiation over from the beginning.

   Some environments will restrict the key establishment approaches by
   policy.  Such policies tend to improve interoperability within a
   particular environment, but they cause problems for individuals that
   need to work in multiple incompatible environments.

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/2.6.%20%20Preserving%20Interoperability"></a><a class="selflink" href="#section-2.6" id="section-2.6">2.6</a>.  Preserving Interoperability</span>

   Cryptographic algorithm deprecation is very difficult.  People do not
   like to introduce interoperability problems, even to preserve
   security.  As a result, flawed algorithms are supported for far too
   long.  The impact of legacy software and long support tails on
   security can be reduced by making it easy to transition from old
   algorithms and suites to new ones.  Social pressure is often needed
   to cause the transition to happen.

   Implementers have been reluctant to remove deprecated algorithms or
   suites from server software, and server administrators have been
   reluctant to disable them over concerns that some party will no
   longer have the ability to connect to their server.  Implementers and
   administrators want to improve security by using the best supported
   algorithms, but their actions are tempered by the desire to preserve
   connectivity.  Recently, some browser vendors have started to provide



<span class="grey">Housley                   Best Current Practice                 [Page 8]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-9"></span>
<span class="grey"><a href="./rfc7696">RFC 7696</a>        Guidelines for Cryptographic Alg Agility   November 2015</span>


   visual warnings when a deprecated algorithm or suite is used.  These
   visual warnings provide a new incentive to transition away from
   deprecated algorithms and suites, prompting customers to ask for
   improved security.

   Transition in Internet infrastructure is particularly difficult.  The
   digital signature on the certificate for an intermediate
   certification authority (CA) [<a href="./rfc5280" title='"Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile"'>RFC5280</a>] is often expected to last
   decades, which hinders the transition away from a weak signature
   algorithm or short key length.  Once a long-lived certificate is
   issued with a particular signature algorithm, that algorithm will be
   used by many relying parties, and none of them can stop supporting it
   without invalidating all of the subordinate certificates.  In a
   hierarchical system, many subordinate certificates could be impacted
   by the decision to drop support for a weak signature algorithm or an
   associated hash function.

   Organizations that have a significant influence can assist by
   coordinating the demise of an algorithm suite, making the transition
   easier for their own users as well as others.

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/2.7.%20%20Balancing%20Security%20Strength"></a><a class="selflink" href="#section-2.7" id="section-2.7">2.7</a>.  Balancing Security Strength</span>

   When selecting or negotiating a suite of cryptographic algorithms,
   the strength of each algorithm SHOULD be considered.  The algorithms
   in a suite SHOULD be roughly equal by providing comparable best-known
   attack work factors.  However, the security service provided by each
   algorithm in a particular context needs to be considered when making
   the selection.  Algorithm strength needs to be considered at the time
   a protocol is designed.  It also needs to be considered at the time a
   protocol implementation is deployed and configured.  Advice from
   experts is useful, but, in reality, such advice is often unavailable
   to system administrators that are deploying a protocol
   implementation.  For this reason, protocol designers SHOULD provide
   clear guidance to implementers, leading to balanced options being
   available at the time of deployment.

   Performance is always a factor is selecting cryptographic algorithms.
   Performance and security need to be balanced.  Some algorithms offer
   flexibility in their strength by adjusting the key size, number of
   rounds, authentication tag size, prime group size, and so on.  For
   example, TLS cipher suites include Diffie-Hellman or RSA without
   specifying a particular public key length.  If the algorithm
   identifier or suite identifier named a particular public key length,
   migration to longer ones would be more difficult.  On the other hand,
   inclusion of a public key length would make it easier to migrate away
   from short ones when computational resources available to attacker
   dictate the need to do so.  The flexibility on asymmetric key length



<span class="grey">Housley                   Best Current Practice                 [Page 9]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-10"></span>
<span class="grey"><a href="./rfc7696">RFC 7696</a>        Guidelines for Cryptographic Alg Agility   November 2015</span>


   has led to interoperability problems, and to avoid these problems in
   the future any aspect of the algorithm not specified by the algorithm
   identifiers need to be negotiated, including key size and parameters.

   In CMS [<a href="./rfc5652" title='"Cryptographic Message Syntax (CMS)"'>RFC5652</a>], a previously distributed symmetric key-encryption
   key can be used to encrypt a content-encryption key, which in turn is
   used to encrypt the content.  The key-encryption and content-
   encryption algorithms are often different.  If, for example, a
   message content is encrypted with a 128-bit AES key and the content-
   encryption key is wrapped with a 256-bit AES key, then at most 128
   bits of protection is provided.  In this situation, the algorithm and
   key size selections should ensure that the key encryption is at least
   as strong as the content encryption.  In general, wrapping one key
   with another key of a different size yields the security strength of
   the shorter key.

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/2.8.%20%20Balancing%20Protocol%20Complexity"></a><a class="selflink" href="#section-2.8" id="section-2.8">2.8</a>.  Balancing Protocol Complexity</span>

   Protocol designs need to anticipate changes in the supported
   cryptographic algorithm set over time.  There are a number of ways to
   enable the transition, and <a href="#section-3">Section 3</a> discusses some of the related
   issues.

   Keep implementations as simple as possible.  Complex protocol
   negotiation provides opportunities for attack, such as downgrade
   attacks.  Support for many algorithm alternatives is also harmful.
   Both of these can lead to portions of the implementation that are
   rarely used, increasing the opportunity for undiscovered exploitable
   implementation bugs.

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/2.9.%20%20Opportunistic%20Security"></a><a class="selflink" href="#section-2.9" id="section-2.9">2.9</a>.  Opportunistic Security</span>

   Despite the guidance in <a href="#section-2.4">Section 2.4</a>, opportunistic security [<a href="./rfc7435" title='"Opportunistic Security: Some Protection Most of the Time"'>RFC7435</a>]
   also deserves consideration, especially at the time a protocol
   implementation is deployed and configured.  Opportunistic security,
   like other reasons for encrypting traffic, needs to make use of the
   strongest encryption algorithms that are implemented and allowed by
   policy.  When communicating parties do not have strong algorithms in
   common, using algorithms that are weak against advanced attackers but
   sufficient against others is one way to make pervasive surveillance
   significantly more difficult.  As a result, when communicating
   parties do not have strong algorithms in common, algorithms that
   would not be acceptable in many negotiated situations are acceptable
   for opportunistic security when legacy systems are in use for
   unauthenticated encrypted sessions (as discussed in <a href="./rfc7435#section-3">Section 3 of
   [RFC7435]</a>) as long as their use does not facilitate downgrade
   attacks.  Similarly, weaker algorithms and shorter key sizes are also
   acceptable for opportunistic security with the same constraints.



<span class="grey">Housley                   Best Current Practice                [Page 10]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-11"></span>
<span class="grey"><a href="./rfc7696">RFC 7696</a>        Guidelines for Cryptographic Alg Agility   November 2015</span>


   That said, the use of strong algorithms is always preferable.

<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/3.%20%20Cryptographic%20Algorithm%20Specifications"></a><a class="selflink" href="#section-3" id="section-3">3</a>.  Cryptographic Algorithm Specifications</span>

   There are tradeoffs between the number of cryptographic algorithms
   that are supported and the time to deploy a new algorithm.  This
   section provides some of the insights about the tradeoff faced by
   protocol designers.

   Ideally, two independent sets of mandatory-to-implement algorithms
   will be specified, allowing for a primary suite and a secondary
   suite.  This approach ensures that the secondary suite is widely
   deployed if a flaw is found in the primary one.

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/3.1.%20%20Choosing%20Mandatory-to-Implement%20Algorithms"></a><a class="selflink" href="#section-3.1" id="section-3.1">3.1</a>.  Choosing Mandatory-to-Implement Algorithms</span>

   It may seem as if the ability to use an algorithm of one's own
   choosing is very desirable; however, the selection is often better
   left to experts.  When there are choices, end-users might select
   between configuration profiles that have been defined by experts.
   Further, experts need not specify each and every cryptographic
   algorithm alternative.  Specifying all possible choices will not lead
   to them all being available in every implementation.  Mandatory-to-
   implement algorithms MUST have a stable public specification and
   public documentation that has been well studied, giving rise to
   significant confidence.  The IETF has always had a preference for
   unencumbered algorithms.  There are significant benefits in selecting
   algorithms and suites that are widely deployed.  The selected
   algorithms need to be resistant to side-channel attacks and also meet
   the performance, power, and code size requirements on a wide variety
   of platforms.  In addition, inclusion of too many alternatives may
   add complexity to algorithm selection or negotiation.  Specification
   of too many alternatives will likely hamper interoperability and may
   hamper security as well.  When specifying new algorithms or suites,
   protocol designers would be prudent to consider whether existing ones
   can be deprecated.

   There is significant benefit in selecting the same algorithms and
   suites for different protocols.  Using the same algorithms can
   simplify implementation when more than one of the protocols is used
   in the same device or system.

   Sometimes more than one mandatory-to-implement algorithm is needed to
   increase the likelihood of interoperability among a diverse
   population.  For example, authenticated encryption is provided by
   AES-CCM [<a href="./rfc3610" title='"Counter with CBC-MAC (CCM)"'>RFC3610</a>] and AES-GCM [<a href="#ref-GCM" title='"Recommendation for Block Cipher Modes of Operation: Galois/Counter Mode (GCM) and GMAC"'>GCM</a>].  Both of these algorithms are
   considered to be secure.  AES-CCM is available in hardware used by
   many small devices, and AES-GCM is parallelizable and well suited to



<span class="grey">Housley                   Best Current Practice                [Page 11]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-12"></span>
<span class="grey"><a href="./rfc7696">RFC 7696</a>        Guidelines for Cryptographic Alg Agility   November 2015</span>


   high-speed devices.  Therefore, an application needing authenticated
   encryption might specify one of these algorithms or both of these
   algorithms, depending on the population.

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/3.2.%20%20Too%20Many%20Choices%20Can%20Be%20Harmful"></a><a class="selflink" href="#section-3.2" id="section-3.2">3.2</a>.  Too Many Choices Can Be Harmful</span>

   It is fairly easy to specify the use of any arbitrary cryptographic
   algorithm, and once the specification is available, the algorithm
   gets implemented and deployed.  Some people say that the freedom to
   specify algorithms independently from the rest of the protocol has
   led to the specification of too many cryptographic algorithms.  Once
   deployed, even with moderate uptake, it is quite difficult to remove
   algorithms because interoperability with some party will be impacted.
   As a result, weaker ciphers stick around far too long.  Sometimes
   implementers are forced to maintain cryptographic algorithm
   implementations well beyond their useful lifetime.

   In order to manage the proliferation of algorithm choices and provide
   an expectation of interoperability, many protocols specify mandatory-
   to-implement algorithms or suites.  All implementers are expected to
   support the mandatory-to-implement cryptographic algorithm, and they
   can include any others algorithms that they desire.  The mandatory-
   to-implement algorithms are chosen to be highly secure and follow the
   guidance in <a href="./rfc1984">RFC 1984</a> [<a href="./rfc1984" title='"IAB and IESG Statement on Cryptographic Technology and the Internet"'>RFC1984</a>].  Of course, many other factors,
   including intellectual property rights, have an impact on the
   cryptographic algorithms that are selected by the community.
   Generally, the mandatory-to-implement algorithms ought to be
   preferred, and the other algorithms ought to be selected only in
   special situations.  However, it can be very difficult for a skilled
   system administrator to determine the proper configuration to achieve
   these preferences.

   In some cases, more than one mandatory-to-implement cryptographic
   algorithm has been specified.  This is intended to ensure that at
   least one secure cryptographic algorithm will be available, even if
   other mandatory-to-implement algorithms are broken.  To achieve this
   goal, the selected algorithms must be diverse, so that a
   cryptoanalytic advance against one of the algorithms does not also
   impact the other selected algorithms.  The idea is to have an
   implemented and deployed algorithm as a fallback.  However, all of
   the selected algorithms need to be routinely exercised to ensure
   quality implementation.  This is not always easy to do, especially if
   the various selected algorithms require different credentials.
   Obtaining multiple credentials for the same installation is an
   unacceptable burden on system administrators.  Also, the manner by
   which system administrators are advised to switch algorithms or
   suites is, at best, ad hoc and, at worst, entirely absent.




<span class="grey">Housley                   Best Current Practice                [Page 12]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-13"></span>
<span class="grey"><a href="./rfc7696">RFC 7696</a>        Guidelines for Cryptographic Alg Agility   November 2015</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/3.3.%20%20Picking%20One%20True%20Cipher%20Suite%20Can%20Be%20Harmful"></a><a class="selflink" href="#section-3.3" id="section-3.3">3.3</a>.  Picking One True Cipher Suite Can Be Harmful</span>

   In the past, protocol designers have chosen one cryptographic
   algorithm or suite, and then tied many protocol details to that
   selection.  Plan for algorithm transition, either because a mistake
   is made in the initial selection or because the protocol is
   successfully used for a long time and the algorithm becomes weak with
   age.  Either way, the design should enable transition.

   Protocol designers are sometimes misled by the simplicity that
   results from selecting one true algorithm or suite.  Since algorithms
   age, the selection cannot be stable forever.  Even the most simple
   protocol needs a version number to signal which algorithm is being
   used.  This approach has at least two desirable consequences.  First,
   the protocol is simpler because there is no need for algorithm
   negotiation.  Second, system administrators do not need to make any
   algorithm-related configuration decisions.  However, the only way to
   respond to news that an algorithm that is part of the one true cipher
   suite has been broken is to update the protocol specification to the
   next version, implement the new specification, and then get it
   deployed.

   The first IEEE 802.11 [<a href="#ref-WiFi" title='"Wireless LAN Medium Access Control (MAC) And Physical Layer (PHY) Specifications"'>WiFi</a>] specification included Wired Equivalent
   Privacy (WEP) as the only encryption technique.  Many of the protocol
   details were driven by the selected algorithm.  WEP was found to be
   quite weak [<a href="#ref-WEP" title='"Wired Equivalent Privacy"'>WEP</a>], and a very large effort was needed to specify,
   implement, and deploy the alternative encryption techniques.  This
   effort was made even harder by the protocol design choices that were
   tied to the initial algorithm selection and the desire for backward
   compatibility.

   Experience with the transition from SHA-1 to SHA-256 indicates that
   the time from protocol specification to widespread use takes more
   than five years.  In this case, the protocol specifications and
   implementation were straightforward and fairly prompt.  In many
   software products, the new algorithm was not considered an update to
   the existing release, so the roll-out of the next release, subsequent
   deployment, and finally adjustment of the configuration by system
   administrators took many years.  In many consumer hardware products,
   firmware to implement the new algorithm was difficult to locate and
   install, or it was simply not available.  Further, infrastructure
   providers were unwilling to make the transition until all of their
   potential clients were able to use the new algorithm.








<span class="grey">Housley                   Best Current Practice                [Page 13]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-14"></span>
<span class="grey"><a href="./rfc7696">RFC 7696</a>        Guidelines for Cryptographic Alg Agility   November 2015</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/3.4.%20%20National%20Cipher%20Suites"></a><a class="selflink" href="#section-3.4" id="section-3.4">3.4</a>.  National Cipher Suites</span>

   Some nations specify cryptographic algorithms, and then require their
   use through legislation or regulations.  These algorithms may not
   have wide public review, and they can have limited geographic scope
   in their deployment.  Yet, the legislative or regulatory mandate
   creates a captive market.  As a result, such algorithms will get
   specified, implemented, and deployed.  The default server or
   responder configuration SHOULD disable such algorithms; in this way,
   explicit action by the system administrator is needed to enable them
   where they are actually required.  For tiny devices with no user
   interface, an administrator action may only be possible at the time
   the device is purchased.

   National algorithms can force an implementer to produce several
   incompatible product releases for different countries or regions;
   this has significantly greater cost over development of a product
   using a globally acceptable algorithm.  This situation could be even
   worse if the various national algorithms impose different
   requirements on the protocol, its key management, or its use of
   random values.

<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/4.%20%20Security%20Considerations"></a><a class="selflink" href="#section-4" id="section-4">4</a>.  Security Considerations</span>

   This document provides guidance to working groups and protocol
   designers.  The security of the Internet is improved when broken or
   weak cryptographic algorithms can be easily replaced with strong
   ones.

   From a software development and maintenance perspective,
   cryptographic algorithms can often be added and removed without
   making changes to surrounding data structures, protocol parsing
   routines, or state machines.  This approach separates the
   cryptographic algorithm implementation from the rest of the code,
   which makes it easier to tackle special security concerns such as key
   exposure and constant-time execution.

   Sometimes application-layer protocols can make use of transport-layer
   security protocols, such as TLS [<a href="./rfc5246" title='"The Transport Layer Security (TLS) Protocol Version 1.2"'>RFC5246</a>] or Datagram TLS (DTLS)
   [<a href="./rfc6347" title='"Datagram Transport Layer Security Version 1.2"'>RFC6347</a>].  This insulates the application-layer protocol from the
   details of cryptography, but it is likely to still be necessary to
   handle the transition from unprotected traffic to protected traffic
   in the application-layer protocol.  In addition, the application-
   layer protocol may need to handle the downgrade from encrypted
   communication to plaintext communication.






<span class="grey">Housley                   Best Current Practice                [Page 14]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-15"></span>
<span class="grey"><a href="./rfc7696">RFC 7696</a>        Guidelines for Cryptographic Alg Agility   November 2015</span>


   Hardware offers challenges in the transition of algorithms, for both
   tiny devices and very high-end data center equipment.  Many tiny
   devices do not include the ability to update the firmware at all.
   Even if the firmware can be updated, tiny devices are often deployed
   in places that make it very inconvenient to do so.  High-end data
   center equipment may use special-purpose chips to achieve very high
   performance, which means that board-level replacement may be needed
   to change the algorithm.  Cost and downtime are both factors in such
   an upgrade.

   In most cases, the cryptographic algorithm remains strong, but an
   attack is found against the way that the strong algorithm is used in
   a particular protocol.  In these cases, a protocol change will
   probably be needed.  For example, the order of cryptographic
   operations in the TLS protocol has evolved as various attacks have
   been discovered.  Originally, TLS performed encryption after
   computation of the message authentication code (MAC).  This order of
   operations is called MAC-then-encrypt, which actually involves MAC
   computation, padding, and then encryption.  This is no longer
   considered secure [<a href="#ref-BN" title='"Authenticated Encryption: Relations among notions and analysis of the generic composition paradigm"'>BN</a>] [<a href="#ref-K" title='"The Order of Encryption and Authentication for Protecting Communications (or: How Secure Is SSL?)"'>K</a>].  As a result, a mechanism was specified
   to use encrypt-then-MAC instead [<a href="./rfc7366" title='"Encrypt-then-MAC for Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS)"'>RFC7366</a>].  Future versions of TLS
   are expected to use exclusively authenticated encryption algorithms
   [<a href="./rfc5116" title='"An Interface and Algorithms for Authenticated Encryption"'>RFC5116</a>], which should resolve the ordering discussion altogether.
   After discovery of such attacks, updating the cryptographic
   algorithms is not likely to be sufficient to thwart the new attack.
   It may necessary to make significant changes to the protocol.

   Some protocols are used to protect stored data.  For example, S/MIME
   [<a href="./rfc5751" title='"Secure/Multipurpose Internet Mail Extensions (S/MIME) Version 3.2 Message Specification"'>RFC5751</a>] can protect a message kept in a mailbox.  To recover the
   protected stored data, protocol implementations need to support older
   algorithms, even when they no longer use the older algorithms for the
   protection of new stored data.

   Support for too many algorithms can lead to implementation
   vulnerabilities.  When many algorithms are supported, some of them
   will be rarely used.  Any code that is rarely used can contain
   undetected bugs, and algorithm implementations are no different.
   Measurements SHOULD be used to determine whether implemented
   algorithms are actually being used, and if they are not, future
   releases should remove them.  In addition, unused algorithms or
   suites SHOULD be marked as deprecated in the IANA registry.  In
   short, eliminate the cruft.

   <a href="#section-2.3">Section 2.3</a> talks about algorithm transition without considering any
   other aspects of the protocol design.  In practice, there are
   dependencies between the cryptographic algorithm and other aspects of





<span class="grey">Housley                   Best Current Practice                [Page 15]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-16"></span>
<span class="grey"><a href="./rfc7696">RFC 7696</a>        Guidelines for Cryptographic Alg Agility   November 2015</span>


   the protocol.  For example, the BEAST attack [<a href="#ref-BEAST" title='"BEAST attack"'>BEAST</a>] against TLS
   [<a href="./rfc5246" title='"The Transport Layer Security (TLS) Protocol Version 1.2"'>RFC5246</a>] caused many sites to turn off modern cryptographic
   algorithms in favor of older and clearly weaker algorithms.

   Mechanisms for timely update of devices are needed to deploy a
   replacement algorithm or suite.  It takes a long time to specify,
   implement, and deploy a replacement; therefore, the transition
   process needs to begin when practically exploitable flaws become
   known.  The update processes on some devices involve certification,
   which further increases the time to deploy a replacement.  For
   example, devices that are part of health or safety systems often
   require certification before deployment.  Embedded systems and SCADA
   (supervisory control and data acquisition) systems often have upgrade
   cycles stretching over many years, leading to similar time-to-
   deployment issues.  Prompt action is needed if a replacement has any
   hope of being deployed before exploitation techniques become widely
   available.

<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/5.%20%20IANA%20Considerations"></a><a class="selflink" href="#section-5" id="section-5">5</a>.  IANA Considerations</span>

   This document does not establish any new IANA registries, nor does it
   add any entries to existing registries.

   This document does RECOMMEND a convention for new registries for
   cryptographic algorithm or suite identifiers.  Once an algorithm or
   suite identifier is added to the registry, it SHOULD NOT be changed
   or removed.  However, it is desirable to include a means of marking a
   registry entry as deprecated when implementation is no longer
   advisable.

<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/6.%20%20Normative%20References"></a><a class="selflink" href="#section-6" id="section-6">6</a>.  Normative References</span>

   [<a id="ref-RFC2119">RFC2119</a>] Bradner, S., "Key words for use in RFCs to Indicate
             Requirement Levels", <a href="https://www.rfc-editor.org/bcp/bcp14">BCP 14</a>, <a href="./rfc2119">RFC 2119</a>,
             DOI 10.17487/RFC2119, March 1997,
             &lt;<a href="http://www.rfc-editor.org/info/rfc2119">http://www.rfc-editor.org/info/rfc2119</a>&gt;.

   [<a id="ref-RFC3766">RFC3766</a>] Orman, H. and P. Hoffman, "Determining Strengths For Public
             Keys Used For Exchanging Symmetric Keys", <a href="https://www.rfc-editor.org/bcp/bcp86">BCP 86</a>, <a href="./rfc3766">RFC 3766</a>,
             DOI 10.17487/RFC3766, April 2004,
             &lt;<a href="http://www.rfc-editor.org/info/rfc3766">http://www.rfc-editor.org/info/rfc3766</a>&gt;.

<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/7.%20%20Informative%20References"></a><a class="selflink" href="#section-7" id="section-7">7</a>.  Informative References</span>

   [<a id="ref-BEAST">BEAST</a>]   Wikipedia, "BEAST attack" under "Transport Layer Security",
             November 2015, &lt;<a href="https://en.wikipedia.org/w/index.php?title=Transport_Layer_Security&amp;oldid=689441642#BEAST_attack">https://en.wikipedia.org/w/index.php?title=</a>
             <a href="https://en.wikipedia.org/w/index.php?title=Transport_Layer_Security&amp;oldid=689441642#BEAST_attack">Transport_Layer_Security&amp;oldid=689441642#BEAST_attack</a>&gt;.




<span class="grey">Housley                   Best Current Practice                [Page 16]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-17"></span>
<span class="grey"><a href="./rfc7696">RFC 7696</a>        Guidelines for Cryptographic Alg Agility   November 2015</span>


   [<a id="ref-BN">BN</a>]      Bellare, M. and C. Namprempre, "Authenticated Encryption:
             Relations among notions and analysis of the generic
             composition paradigm", Proceedings of AsiaCrypt '00,
             Springer-Verlag LNCS No. 1976, p. 531,
             DOI 10.1007/3-540-44448-3_41, December 2000.

   [<a id="ref-GCM">GCM</a>]     Dworkin, M, "Recommendation for Block Cipher Modes of
             Operation: Galois/Counter Mode (GCM) and GMAC", NIST
             Special Publication 800-30D, November 2007.

   [<a id="ref-K">K</a>]       Krawczyk, H., "The Order of Encryption and Authentication
             for Protecting Communications (or: How Secure Is SSL?)",
             Proceedings of Crypto '01, Springer-Verlag LNCS No. 2139,
             p. 310, DOI 10.1007/3-540-44647-8_19, August 2001.

   [<a id="ref-RFC1984">RFC1984</a>] IAB and IESG, "IAB and IESG Statement on Cryptographic
             Technology and the Internet", <a href="https://www.rfc-editor.org/bcp/bcp200">BCP 200</a>, <a href="./rfc1984">RFC 1984</a>,
             DOI 10.17487/RFC1984, August 1996,
             &lt;<a href="http://www.rfc-editor.org/info/rfc1984">http://www.rfc-editor.org/info/rfc1984</a>&gt;.

   [<a id="ref-RFC3365">RFC3365</a>] Schiller, J., "Strong Security Requirements for Internet
             Engineering Task Force Standard Protocols", <a href="https://www.rfc-editor.org/bcp/bcp61">BCP 61</a>,
             <a href="./rfc3365">RFC 3365</a>, DOI 10.17487/RFC3365, August 2002,
             &lt;<a href="http://www.rfc-editor.org/info/rfc3365">http://www.rfc-editor.org/info/rfc3365</a>&gt;.

   [<a id="ref-RFC3610">RFC3610</a>] Whiting, D., Housley, R., and N. Ferguson, "Counter with
             CBC-MAC (CCM)", <a href="./rfc3610">RFC 3610</a>, DOI 10.17487/RFC3610, September
             2003, &lt;<a href="http://www.rfc-editor.org/info/rfc3610">http://www.rfc-editor.org/info/rfc3610</a>&gt;.

   [<a id="ref-RFC3748">RFC3748</a>] Aboba, B., Blunk, L., Vollbrecht, J., Carlson, J., and H.
             Levkowetz, Ed., "Extensible Authentication Protocol (EAP)",
             <a href="./rfc3748">RFC 3748</a>, DOI 10.17487/RFC3748, June 2004,
             &lt;<a href="http://www.rfc-editor.org/info/rfc3748">http://www.rfc-editor.org/info/rfc3748</a>&gt;.

   [<a id="ref-RFC4302">RFC4302</a>] Kent, S., "IP Authentication Header", <a href="./rfc4302">RFC 4302</a>,
             DOI 10.17487/RFC4302, December 2005,
             &lt;<a href="http://www.rfc-editor.org/info/rfc4302">http://www.rfc-editor.org/info/rfc4302</a>&gt;.

   [<a id="ref-RFC4303">RFC4303</a>] Kent, S., "IP Encapsulating Security Payload (ESP)",
             <a href="./rfc4303">RFC 4303</a>, DOI 10.17487/RFC4303, December 2005,
             &lt;<a href="http://www.rfc-editor.org/info/rfc4303">http://www.rfc-editor.org/info/rfc4303</a>&gt;.

   [<a id="ref-RFC4307">RFC4307</a>] Schiller, J., "Cryptographic Algorithms for Use in the
             Internet Key Exchange Version 2 (IKEv2)", <a href="./rfc4307">RFC 4307</a>,
             DOI 10.17487/RFC4307, December 2005,
             &lt;<a href="http://www.rfc-editor.org/info/rfc4307">http://www.rfc-editor.org/info/rfc4307</a>&gt;.





<span class="grey">Housley                   Best Current Practice                [Page 17]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-18"></span>
<span class="grey"><a href="./rfc7696">RFC 7696</a>        Guidelines for Cryptographic Alg Agility   November 2015</span>


   [<a id="ref-RFC4422">RFC4422</a>] Melnikov, A., Ed., and K. Zeilenga, Ed., "Simple
             Authentication and Security Layer (SASL)", <a href="./rfc4422">RFC 4422</a>,
             DOI 10.17487/RFC4422, June 2006,
             &lt;<a href="http://www.rfc-editor.org/info/rfc4422">http://www.rfc-editor.org/info/rfc4422</a>&gt;.

   [<a id="ref-RFC5116">RFC5116</a>] McGrew, D., "An Interface and Algorithms for Authenticated
             Encryption", <a href="./rfc5116">RFC 5116</a>, DOI 10.17487/RFC5116, January 2008,
             &lt;<a href="http://www.rfc-editor.org/info/rfc5116">http://www.rfc-editor.org/info/rfc5116</a>&gt;.

   [<a id="ref-RFC5246">RFC5246</a>] Dierks, T. and E. Rescorla, "The Transport Layer Security
             (TLS) Protocol Version 1.2", <a href="./rfc5246">RFC 5246</a>,
             DOI 10.17487/RFC5246, August 2008,
             &lt;<a href="http://www.rfc-editor.org/info/rfc5246">http://www.rfc-editor.org/info/rfc5246</a>&gt;.

   [<a id="ref-RFC5280">RFC5280</a>] Cooper, D., Santesson, S., Farrell, S., Boeyen, S.,
             Housley, R., and W. Polk, "Internet X.509 Public Key
             Infrastructure Certificate and Certificate Revocation List
             (CRL) Profile", <a href="./rfc5280">RFC 5280</a>, DOI 10.17487/RFC5280, May 2008,
             &lt;<a href="http://www.rfc-editor.org/info/rfc5280">http://www.rfc-editor.org/info/rfc5280</a>&gt;.

   [<a id="ref-RFC5652">RFC5652</a>] Housley, R., "Cryptographic Message Syntax (CMS)", STD 70,
             <a href="./rfc5652">RFC 5652</a>, DOI 10.17487/RFC5652, September 2009,
             &lt;<a href="http://www.rfc-editor.org/info/rfc5652">http://www.rfc-editor.org/info/rfc5652</a>&gt;.

   [<a id="ref-RFC5751">RFC5751</a>] Ramsdell, B. and S. Turner, "Secure/Multipurpose Internet
             Mail Extensions (S/MIME) Version 3.2 Message
             Specification", <a href="./rfc5751">RFC 5751</a>, DOI 10.17487/RFC5751, January
             2010, &lt;<a href="http://www.rfc-editor.org/info/rfc5751">http://www.rfc-editor.org/info/rfc5751</a>&gt;.

   [<a id="ref-RFC6347">RFC6347</a>] Rescorla, E. and N. Modadugu, "Datagram Transport Layer
             Security Version 1.2", <a href="./rfc6347">RFC 6347</a>, DOI 10.17487/RFC6347,
             January 2012, &lt;<a href="http://www.rfc-editor.org/info/rfc6347">http://www.rfc-editor.org/info/rfc6347</a>&gt;.

   [<a id="ref-RFC6916">RFC6916</a>] Gagliano, R., Kent, S., and S. Turner, "Algorithm Agility
             Procedure for the Resource Public Key Infrastructure
             (RPKI)", <a href="https://www.rfc-editor.org/bcp/bcp182">BCP 182</a>, <a href="./rfc6916">RFC 6916</a>, DOI 10.17487/RFC6916, April
             2013, &lt;<a href="http://www.rfc-editor.org/info/rfc6916">http://www.rfc-editor.org/info/rfc6916</a>&gt;.

   [<a id="ref-RFC6975">RFC6975</a>] Crocker, S. and S. Rose, "Signaling Cryptographic Algorithm
             Understanding in DNS Security Extensions (DNSSEC)",
             <a href="./rfc6975">RFC 6975</a>, DOI 10.17487/RFC6975, July 2013,
             &lt;<a href="http://www.rfc-editor.org/info/rfc6975">http://www.rfc-editor.org/info/rfc6975</a>&gt;.

   [<a id="ref-RFC7296">RFC7296</a>] Kaufman, C., Hoffman, P., Nir, Y., Eronen, P., and T.
             Kivinen, "Internet Key Exchange Protocol Version 2
             (IKEv2)", STD 79, <a href="./rfc7296">RFC 7296</a>, DOI 10.17487/RFC7296, October
             2014, &lt;<a href="http://www.rfc-editor.org/info/rfc7296">http://www.rfc-editor.org/info/rfc7296</a>&gt;.




<span class="grey">Housley                   Best Current Practice                [Page 18]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-19"></span>
<span class="grey"><a href="./rfc7696">RFC 7696</a>        Guidelines for Cryptographic Alg Agility   November 2015</span>


   [<a id="ref-RFC7366">RFC7366</a>] Gutmann, P., "Encrypt-then-MAC for Transport Layer Security
             (TLS) and Datagram Transport Layer Security (DTLS)",
             <a href="./rfc7366">RFC 7366</a>, DOI 10.17487/RFC7366, September 2014,
             &lt;<a href="http://www.rfc-editor.org/info/rfc7366">http://www.rfc-editor.org/info/rfc7366</a>&gt;.

   [<a id="ref-RFC7435">RFC7435</a>] Dukhovni, V., "Opportunistic Security: Some Protection Most
             of the Time", <a href="./rfc7435">RFC 7435</a>, DOI 10.17487/RFC7435, December
             2014, &lt;<a href="http://www.rfc-editor.org/info/rfc7435">http://www.rfc-editor.org/info/rfc7435</a>&gt;.

   [<a id="ref-RFC7525">RFC7525</a>] Sheffer, Y., Holz, R., and P. Saint-Andre, "Recommendations
             for Secure Use of Transport Layer Security (TLS) and
             Datagram Transport Layer Security (DTLS)", <a href="https://www.rfc-editor.org/bcp/bcp195">BCP 195</a>,
             <a href="./rfc7525">RFC 7525</a>, DOI 10.17487/RFC7525, May 2015,
             &lt;<a href="http://www.rfc-editor.org/info/rfc7525">http://www.rfc-editor.org/info/rfc7525</a>&gt;.

   [<a id="ref-WEP">WEP</a>]     Wikipedia, "Wired Equivalent Privacy", November 2015,
             &lt;<a href="https://en.wikipedia.org/w/index.php?title=Wired_Equivalent_Privacy&amp;oldid=688848497">https://en.wikipedia.org/w/index.php?</a>
             <a href="https://en.wikipedia.org/w/index.php?title=Wired_Equivalent_Privacy&amp;oldid=688848497">title=Wired_Equivalent_Privacy&amp;oldid=688848497</a>&gt;.

   [<a id="ref-WiFi">WiFi</a>]    IEEE, "Wireless LAN Medium Access Control (MAC) And
             Physical Layer (PHY) Specifications", IEEE Std 802.11-1997,
             1997.

Acknowledgements

   Thanks to Bernard Aboba, Derek Atkins, David Black, Randy Bush, Jon
   Callas, Andrew Chi, Steve Crocker, Viktor Dukhovni, Stephen Farrell,
   Tony Finch, Ian Grigg, Peter Gutmann, Phillip Hallam-Baker, Wes
   Hardaker, Joe Hildebrand, Paul Hoffman, Christian Huitema, Leif
   Johansson, Suresh Krishnan, Watson Ladd, Paul Lambert, Ben Laurie,
   Eliot Lear, Nikos Mavrogiannopoulos, Kathleen Moriarty, Yoav Nir,
   Kenny Paterson, Rich Salz, Wendy Seltzer, Joel Sing, Rene Struik,
   Kristof Teichel, Martin Thompson, Jeffrey Walton, Nico Williams, and
   Peter Yee for their review and insightful comments.  While some of
   these people do not agree with some aspects of this document, the
   discussion that resulted for their comments has certainly resulted in
   a better document.

Author's Address

   Russ Housley
   Vigil Security, LLC
   918 Spring Knoll Drive
   Herndon, VA 20170
   United States

   Email: housley@vigilsec.com




Housley                   Best Current Practice                [Page 19]
</pre>
</body></html>