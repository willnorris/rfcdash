<html><head></head><body><pre>Internet Engineering Task Force (IETF)                       B. Trammell
Request for Comments: 7373                                    ETH Zurich
Category: Standards Track                                 September 2014
ISSN: 2070-1721


      <span class="h1">Textual Representation of IP Flow Information Export (IPFIX)</span>
                          <span class="h1">Abstract Data Types</span>

Abstract

   This document defines UTF-8 representations for IP Flow Information
   Export (IPFIX) abstract data types (ADTs) to support interoperable
   usage of the IPFIX Information Elements with protocols based on
   textual encodings.

Status of This Memo

   This is an Internet Standards Track document.

   This document is a product of the Internet Engineering Task Force
   (IETF).  It represents the consensus of the IETF community.  It has
   received public review and has been approved for publication by the
   Internet Engineering Steering Group (IESG).  Further information on
   Internet Standards is available in <a href="./rfc5741#section-2">Section 2 of RFC 5741</a>.

   Information about the current status of this document, any errata,
   and how to provide feedback on it may be obtained at
   <a href="http://www.rfc-editor.org/info/rfc7373">http://www.rfc-editor.org/info/rfc7373</a>.

Copyright Notice

   Copyright (c) 2014 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to <a href="https://www.rfc-editor.org/bcp/bcp78">BCP 78</a> and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (<a href="http://trustee.ietf.org/license-info">http://trustee.ietf.org/license-info</a>) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.







<span class="grey">Trammell                     Standards Track                    [Page 1]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-2"></span>
<span class="grey"><a href="./rfc7373">RFC 7373</a>                    IPFIX Text Types              September 2014</span>


Table of Contents

   <a href="#section-1">1</a>.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   <a href="#page-2">2</a>
   <a href="#section-2">2</a>.  Terminology . . . . . . . . . . . . . . . . . . . . . . . . .   <a href="#page-3">3</a>
   <a href="#section-3">3</a>.  Identifying Information Elements  . . . . . . . . . . . . . .   <a href="#page-3">3</a>
   <a href="#section-4">4</a>.  Data Type Encodings . . . . . . . . . . . . . . . . . . . . .   <a href="#page-3">3</a>
     <a href="#section-4.1">4.1</a>.  octetArray  . . . . . . . . . . . . . . . . . . . . . . .   <a href="#page-4">4</a>
     <a href="#section-4.2">4.2</a>.  unsigned8, unsigned16, unsigned32, and unsigned64 . . . .   <a href="#page-4">4</a>
     <a href="#section-4.3">4.3</a>.  signed8, signed16, signed32, and signed64 . . . . . . . .   <a href="#page-5">5</a>
     <a href="#section-4.4">4.4</a>.  float32 and float64 . . . . . . . . . . . . . . . . . . .   <a href="#page-6">6</a>
     <a href="#section-4.5">4.5</a>.  boolean . . . . . . . . . . . . . . . . . . . . . . . . .   <a href="#page-7">7</a>
     <a href="#section-4.6">4.6</a>.  macAddress  . . . . . . . . . . . . . . . . . . . . . . .   <a href="#page-7">7</a>
     <a href="#section-4.7">4.7</a>.  string  . . . . . . . . . . . . . . . . . . . . . . . . .   <a href="#page-7">7</a>
     <a href="#section-4.8">4.8</a>.  The dateTime ADTs . . . . . . . . . . . . . . . . . . . .   <a href="#page-8">8</a>
     <a href="#section-4.9">4.9</a>.  ipv4Address . . . . . . . . . . . . . . . . . . . . . . .   <a href="#page-8">8</a>
     <a href="#section-4.10">4.10</a>. ipv6Address . . . . . . . . . . . . . . . . . . . . . . .   <a href="#page-9">9</a>
     <a href="#section-4.11">4.11</a>. basicList, subTemplateList, and subTemplateMultiList  . .   <a href="#page-9">9</a>
   <a href="#section-5">5</a>.  Security Considerations . . . . . . . . . . . . . . . . . . .   <a href="#page-9">9</a>
   <a href="#section-6">6</a>.  References  . . . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-10">10</a>
     <a href="#section-6.1">6.1</a>.  Normative References  . . . . . . . . . . . . . . . . . .  <a href="#page-10">10</a>
     <a href="#section-6.2">6.2</a>.  Informative References  . . . . . . . . . . . . . . . . .  <a href="#page-11">11</a>
   <a href="#appendix-A">Appendix A</a>.  Example  . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-13">13</a>
   Acknowledgments . . . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-14">14</a>
   Author's Address  . . . . . . . . . . . . . . . . . . . . . . . .

<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/1.%20%20Introduction"></a><a class="selflink" href="#section-1" id="section-1">1</a>.  Introduction</span>

   The IP Flow Information Export (IPFIX) Information Model [<a href="./rfc7012" title='"Information Model for IP Flow Information Export (IPFIX)"'>RFC7012</a>]
   provides a set of abstract data types (ADTs) for the IANA "IPFIX
   Information Elements" registry [<a href="#ref-IANA-IPFIX">IANA-IPFIX</a>], which contains a rich
   set of Information Elements for description of information about
   network entities and network traffic data, and abstract data types
   for these Information Elements.  The IPFIX Protocol Specification
   [<a href="./rfc7011" title='"Specification of the IP Flow Information Export (IPFIX) Protocol for the Exchange of Flow Information"'>RFC7011</a>], in turn, defines a big-endian binary encoding for these
   abstract data types suitable for use with the IPFIX protocol.

   However, present and future operations and management protocols and
   applications may use textual encodings, and generic framing and
   structure, as in JSON [<a href="./rfc7159" title='"The JavaScript Object Notation (JSON) Data Interchange Format"'>RFC7159</a>] or XML.  A definition of canonical
   textual encodings for the IPFIX abstract data types would allow this
   set of Information Elements to be used for such applications and for
   these applications to interoperate with IPFIX applications at the
   Information Element definition level.

   Note that templating or other mechanisms used for data description
   for such applications and protocols are application specific and,
   therefore, out of scope for this document: only Information Element
   identification and value representation are defined here.



<span class="grey">Trammell                     Standards Track                    [Page 2]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-3"></span>
<span class="grey"><a href="./rfc7373">RFC 7373</a>                    IPFIX Text Types              September 2014</span>


   In most cases where a textual representation will be used, an
   explicit tradeoff is made for human readability or manipulability
   over compactness; this assumption is used in defining standard
   representations of IPFIX ADTs.

<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/2.%20%20Terminology"></a><a class="selflink" href="#section-2" id="section-2">2</a>.  Terminology</span>

   Capitalized terms defined in the IPFIX Protocol Specification
   [<a href="./rfc7011" title='"Specification of the IP Flow Information Export (IPFIX) Protocol for the Exchange of Flow Information"'>RFC7011</a>] and the IPFIX Information Model [<a href="./rfc7012" title='"Information Model for IP Flow Information Export (IPFIX)"'>RFC7012</a>] are used in this
   document as defined in those documents.  The key words "MUST", "MUST
   NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT",
   "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be
   interpreted as described in [<a href="./rfc2119" title='"Key words for use in RFCs to Indicate Requirement Levels"'>RFC2119</a>].  In addition, this document
   defines the following terminology for its own use:

   Enclosing Context
      A textual representation of Information Element values is applied
      to use the IPFIX Information Model within some existing textual
      format (e.g., XML [<a href="#ref-W3C-XML" title='"Extensible Markup Language (XML) 1.0 (Fifth Edition)"'>W3C-XML</a>] and JSON [<a href="./rfc7159" title='"The JavaScript Object Notation (JSON) Data Interchange Format"'>RFC7159</a>]).  This outer
      format is referred to as the Enclosing Context within this
      document.  Enclosing Contexts define escaping and quoting rules
      for represented values.

<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/3.%20%20Identifying%20Information%20Elements"></a><a class="selflink" href="#section-3" id="section-3">3</a>.  Identifying Information Elements</span>

   The "IPFIX Information Elements" registry [<a href="#ref-IANA-IPFIX">IANA-IPFIX</a>] defines a set
   of Information Elements numbered by Information Element identifiers
   and named for human readability.  These Information Element
   identifiers are meant for use with the IPFIX protocol and have little
   meaning when applying the "IPFIX Information Elements" registry to
   textual representations.

   Instead, applications using textual representations of Information
   Elements use Information Element names to identify them; see
   <a href="#appendix-A">Appendix A</a> for examples illustrating this principle.

<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/4.%20%20Data%20Type%20Encodings"></a><a class="selflink" href="#section-4" id="section-4">4</a>.  Data Type Encodings</span>

   Each subsection of this section defines a textual encoding for the
   abstract data types defined in [<a href="./rfc7012" title='"Information Model for IP Flow Information Export (IPFIX)"'>RFC7012</a>].  This section uses ABNF,
   including the Core Rules in <a href="./rfc5234#appendix-B">Appendix B of [RFC5234]</a>, to describe the
   format of textual representations of IPFIX abstract data types.

   If future documents update [<a href="./rfc7012" title='"Information Model for IP Flow Information Export (IPFIX)"'>RFC7012</a>] to add new abstract data types
   to the IPFIX Information Model, and those abstract data types are
   generally useful, this document will also need to be updated in order
   to define textual encodings for those abstract data types.




<span class="grey">Trammell                     Standards Track                    [Page 3]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-4"></span>
<span class="grey"><a href="./rfc7373">RFC 7373</a>                    IPFIX Text Types              September 2014</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/4.1.%20%20octetArray"></a><a class="selflink" href="#section-4.1" id="section-4.1">4.1</a>.  octetArray</span>

   If the Enclosing Context defines a representation for binary objects,
   that representation SHOULD be used.

   Otherwise, since the goal of textual representation of Information
   Elements is human readability over compactness, the values of
   Information Elements of the octetArray data type are represented as a
   string of pairs of hexadecimal digits, one pair per byte, in the
   order the bytes would appear on the wire were the octetArray encoded
   directly in IPFIX per [<a href="./rfc7011" title='"Specification of the IP Flow Information Export (IPFIX) Protocol for the Exchange of Flow Information"'>RFC7011</a>].  Whitespace may occur between any
   pair of digits to assist in human readability of the string but is
   not necessary.  In ABNF:

   hex-octet = 2HEXDIG

   octetarray = hex-octet *([WSP] hex-octet)

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/4.2.%20%20unsigned8%2C%20unsigned16%2C%20unsigned32%2C%20and%20unsigned64"></a><a class="selflink" href="#section-4.2" id="section-4.2">4.2</a>.  unsigned8, unsigned16, unsigned32, and unsigned64</span>

   If the Enclosing Context defines a representation for unsigned
   integers, that representation SHOULD be used.

   In the special case where the unsigned Information Element has
   identifier semantics and refers to a set of codepoints either in an
   external registry, in a sub-registry, or directly in the description
   of the Information Element, then the name or short description for
   that codepoint as a string MAY be used to improve readability.

   Otherwise, the values of Information Elements of an unsigned integer
   type may be represented as either unprefixed base-10 (decimal)
   strings, base-16 (hexadecimal) strings prefixed by "0x", or base-2
   (binary) strings prefixed by "0b".  In ABNF:

   unsigned = 1*DIGIT / "0x" 1*HEXDIG / "0b" 1*BIT

   Leading zeroes are allowed in any representation and do not signify
   base-8 (octal) representation.  Binary representation is intended for
   use with Information Elements with flag semantics, but it can be used
   in any case.

   The encoded value MUST be in range for the corresponding abstract
   data type or Information Element.  Values that are out of range are
   interpreted as clipped to the implicit range for the Information
   Element as defined by the abstract data type or to the explicit range
   of the Information Element if defined.  Minimum and maximum values
   for abstract data types are shown in Table 1 below.




<span class="grey">Trammell                     Standards Track                    [Page 4]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-5"></span>
<span class="grey"><a href="./rfc7373">RFC 7373</a>                    IPFIX Text Types              September 2014</span>


              +------------+---------+----------------------+
              |       type | minimum |              maximum |
              +------------+---------+----------------------+
              |  unsigned8 |       0 |                  255 |
              | unsigned16 |       0 |                65535 |
              | unsigned32 |       0 |           4294967295 |
              | unsigned64 |       0 | 18446744073709551615 |
              +------------+---------+----------------------+

       Table 1: Ranges for Unsigned Abstract Data Types (in Decimal)

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/4.3.%20%20signed8%2C%20signed16%2C%20signed32%2C%20and%20signed64"></a><a class="selflink" href="#section-4.3" id="section-4.3">4.3</a>.  signed8, signed16, signed32, and signed64</span>

   If the Enclosing Context defines a representation for signed
   integers, that representation SHOULD be used.

   Otherwise, the values of Information Elements of signed integer types
   are represented as optionally prefixed base-10 (decimal) strings.  In
   ABNF:

   sign = "+" / "-"

   signed = [sign] 1*DIGIT

   If the sign is omitted, it is assumed to be positive.  Leading zeroes
   are allowed and do not signify base-8 (octal) encoding.  The
   representation "-0" is explicitly allowed and is equal to zero.

   The encoded value MUST be in range for the corresponding abstract
   data type or Information Element.  Values that are out of range are
   to be interpreted as clipped to the implicit range for the
   Information Element as defined by the abstract data type or to the
   explicit range of the Information Element if defined.  Minimum and
   maximum values for abstract data types are shown in Table 2 below.

        +----------+----------------------+----------------------+
        |     type |              minimum |              maximum |
        +----------+----------------------+----------------------+
        |  signed8 |                 -128 |                 +127 |
        | signed16 |               -32768 |               +32767 |
        | signed32 |          -2147483648 |          +2147483647 |
        | signed64 | -9223372036854775808 | +9223372036854775807 |
        +----------+----------------------+----------------------+

        Table 2: Ranges for Signed Abstract Data Types (in Decimal)






<span class="grey">Trammell                     Standards Track                    [Page 5]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-6"></span>
<span class="grey"><a href="./rfc7373">RFC 7373</a>                    IPFIX Text Types              September 2014</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/4.4.%20%20float32%20and%20float64"></a><a class="selflink" href="#section-4.4" id="section-4.4">4.4</a>.  float32 and float64</span>

   If the Enclosing Context defines a representation for floating-point
   numbers, that representation SHOULD be used.

   Otherwise, the values of Information Elements of float32 or float64
   types are represented as optionally sign-prefixed, optionally base-10
   exponent-suffixed, floating-point decimal numbers, as in
   [<a href="#ref-IEEE.754.2008">IEEE.754.2008</a>].  The special strings "NaN", "+inf", and "-inf"
   represent "not a number", "positive infinity", and "negative
   infinity", respectively.

   In ABNF:

   sign = "+" / "-"

   exponent = "e" [sign] 1*3DIGIT

   right-decimal = "." 1*DIGIT

   mantissa = 1*DIGIT [right-decimal]

   num = [sign] mantissa [exponent]

   naninf = "NaN" / (sign "inf")

   float = num / naninf

   The expressed value is ( mantissa * 10 ^ exponent ).  If the sign is
   omitted, it is assumed to be positive.  If the exponent is omitted,
   it is assumed to be zero.  Leading zeroes may appear in the mantissa
   and/or the exponent.  Values MUST be within range for single- or
   double-precision numbers as defined in [<a href="#ref-IEEE.754.2008">IEEE.754.2008</a>]; finite values
   outside the appropriate range are to be interpreted as clamped to be
   within the range.  Note that no more than three digits are required
   or allowed for exponents in this encoding due to these ranges.

   Note that since this representation is meant for human readability,
   writers MAY sacrifice precision to use a more human-readable
   representation of a given value, at the expense of the ability to
   recover the exact bit pattern at the reader.  Therefore, decoders
   MUST NOT assume that the represented values are exactly comparable
   for equality.








<span class="grey">Trammell                     Standards Track                    [Page 6]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-7"></span>
<span class="grey"><a href="./rfc7373">RFC 7373</a>                    IPFIX Text Types              September 2014</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/4.5.%20%20boolean"></a><a class="selflink" href="#section-4.5" id="section-4.5">4.5</a>.  boolean</span>

   If the Enclosing Context defines a representation for boolean values,
   that representation SHOULD be used.

   Otherwise, a true boolean value is represented by the literal string
   "true" and a false boolean value by the literal string "false".  In
   ABNF:

   boolean-true = "true"

   boolean-false = "false"

   boolean = boolean-true / boolean-false

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/4.6.%20%20macAddress"></a><a class="selflink" href="#section-4.6" id="section-4.6">4.6</a>.  macAddress</span>

   Media Access Control (MAC) addresses are represented as IEEE 802
   MAC-48 addresses, hexadecimal bytes with the most significant byte
   first, separated by colons.  In ABNF:

   hex-octet = 2HEXDIG

   macaddress = hex-octet 5( ":" hex-octet )

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/4.7.%20%20string"></a><a class="selflink" href="#section-4.7" id="section-4.7">4.7</a>.  string</span>

   As Information Elements of the string type are simply Unicode strings
   (encoded as UTF-8 when appearing in Data Sets in IPFIX Messages
   [<a href="./rfc7011" title='"Specification of the IP Flow Information Export (IPFIX) Protocol for the Exchange of Flow Information"'>RFC7011</a>]), they are represented directly, using the Unicode encoding
   rules and quoting and escaping rules of the Enclosing Context.

   If the Enclosing Context cannot natively represent Unicode
   characters, the escaping facility provided by the Enclosing Context
   MUST be used for nonrepresentable characters.  Additionally, strings
   containing characters reserved in the Enclosing Context (e.g.,
   control characters, markup characters, and quotes) MUST be escaped or
   quoted according to the rules of the Enclosing Context.

   It is presumed that the Enclosing Context has sufficient restrictions
   on the use of Unicode to prevent the unsafe use of nonprinting and
   control characters.  As there is no accepted solution for the
   processing and safe display of mixed-direction strings, mixed-
   direction strings should be avoided using this encoding.  Note also
   that since this document presents no additional requirements for the
   normalization of Unicode strings, care must be taken when comparing
   strings using this encoding; direct byte-pattern comparisons are not
   sufficient for determining whether two strings are equivalent.  See



<span class="grey">Trammell                     Standards Track                    [Page 7]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-8"></span>
<span class="grey"><a href="./rfc7373">RFC 7373</a>                    IPFIX Text Types              September 2014</span>


   [<a id="ref-RFC6885">RFC6885</a>] and [<a href="#ref-PRECIS" title='"PRECIS Framework: Preparation and Comparison of Internationalized Strings in Application Protocols"'>PRECIS</a>] for more on possible unexpected results and
   related risks in comparing Unicode strings.

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/4.8.%20%20The%20dateTime%20ADTs"></a><a class="selflink" href="#section-4.8" id="section-4.8">4.8</a>.  The dateTime ADTs</span>

   Timestamp abstract data types are represented generally as in
   [<a href="./rfc3339" title='"Date and Time on the Internet: Timestamps"'>RFC3339</a>], with two important differences.  First, all IPFIX
   timestamps are expressed in terms of UTC, so textual representations
   of these Information Elements are explicitly in UTC as well.  Time
   zone offsets are, therefore, not required or supported.  Second,
   there are four timestamp abstract data types, separated by the
   precision that they can express.  Fractional seconds are omitted in
   dateTimeSeconds, expressed in milliseconds in dateTimeMilliseconds,
   and so on.

   In ABNF, taken from [<a href="./rfc3339" title='"Date and Time on the Internet: Timestamps"'>RFC3339</a>] and modified as follows:

   date-fullyear   = 4DIGIT
   date-month      = 2DIGIT  ; 01-12
   date-mday       = 2DIGIT  ; 01-28, 01-29, 01-30, 01-31
   time-hour       = 2DIGIT  ; 00-23
   time-minute     = 2DIGIT  ; 00-59
   time-second     = 2DIGIT  ; 00-58, 00-59, 00-60
   time-msec       = "." 3DIGIT
   time-usec       = "." 6DIGIT
   time-nsec       = "." 9DIGIT
   full-date       = date-fullyear "-" date-month "-" date-mday
   integer-time    = time-hour ":" time-minute ":" time-second

   datetimeseconds      = full-date "T" integer-time
   datetimemilliseconds = full-date "T" integer-time "." time-msec
   datetimemicroseconds = full-date "T" integer-time "." time-usec
   datetimenanoseconds  = full-date "T" integer-time "." time-nsec

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/4.9.%20%20ipv4Address"></a><a class="selflink" href="#section-4.9" id="section-4.9">4.9</a>.  ipv4Address</span>

   IP version 4 addresses are represented in dotted-quad format, most
   significant byte first, as it would be in a Uniform Resource
   Identifier [<a href="./rfc3986" title='"Uniform Resource Identifier (URI): Generic Syntax"'>RFC3986</a>]; the ABNF for an IPv4 address is taken from
   [<a href="./rfc3986" title='"Uniform Resource Identifier (URI): Generic Syntax"'>RFC3986</a>] and reproduced below:

   dec-octet   = DIGIT                 ; 0-9
               / %x31-39 DIGIT         ; 10-99
               / "1" 2DIGIT            ; 100-199
               / "2" %x30-34 DIGIT     ; 200-249
               / "25" %x30-35          ; 250-255

   ipv4address = dec-octet 3( "." dec-octet )



<span class="grey">Trammell                     Standards Track                    [Page 8]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-9"></span>
<span class="grey"><a href="./rfc7373">RFC 7373</a>                    IPFIX Text Types              September 2014</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/4.10.%20%20ipv6Address"></a><a class="selflink" href="#section-4.10" id="section-4.10">4.10</a>.  ipv6Address</span>

   IP version 6 addresses are represented as in <a href="./rfc4291#section-2.2">Section 2.2 of
   [RFC4291]</a>, as updated by <a href="./rfc5952#section-4">Section 4 of [RFC5952]</a>.  The ABNF for an
   IPv6 address is taken from [<a href="./rfc3986" title='"Uniform Resource Identifier (URI): Generic Syntax"'>RFC3986</a>] and reproduced below, using the
   ipv4address production from the previous section:

   ls32        = ( h16 ":" h16 ) / ipv4address
               ; least significant 32 bits of address
   h16         = 1*4HEXDIG
               ; 16 bits of address represented in hexadecimal
               ; zeroes to be suppressed as in <a href="./rfc5952">RFC 5952</a>

   ipv6address =                            6( h16 ":" ) ls32
               /                       "::" 5( h16 ":" ) ls32
               / [               h16 ] "::" 4( h16 ":" ) ls32
               / [     h16 ":"   h16 ] "::" 3( h16 ":" ) ls32
               / [ *2( h16 ":" ) h16 ] "::" 2( h16 ":" ) ls32
               / [ *3( h16 ":" ) h16 ] "::"    h16 ":"   ls32
               / [ *4( h16 ":" ) h16 ] "::"              ls32
               / [ *5( h16 ":" ) h16 ] "::"              h16
               / [ *6( h16 ":" ) h16 ] "::"

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/4.11.%20%20basicList%2C%20subTemplateList%2C%20and%20subTemplateMultiList"></a><a class="selflink" href="#section-4.11" id="section-4.11">4.11</a>.  basicList, subTemplateList, and subTemplateMultiList</span>

   These abstract data types, defined for IPFIX Structured Data
   [<a href="./rfc6313" title='"Export of Structured Data in IP Flow Information Export (IPFIX)"'>RFC6313</a>], do not represent actual data types; they are instead
   designed to provide a mechanism by which complex structure can be
   represented in IPFIX below the template level.  It is assumed that
   protocols using textual Information Element representation will
   provide their own structure.  Therefore, Information Elements of
   these data types MUST NOT be used in textual representations.

<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/5.%20%20Security%20Considerations"></a><a class="selflink" href="#section-5" id="section-5">5</a>.  Security Considerations</span>

   The security considerations for the IPFIX protocol [<a href="./rfc7011" title='"Specification of the IP Flow Information Export (IPFIX) Protocol for the Exchange of Flow Information"'>RFC7011</a>] apply.

   Implementations of decoders of Information Element values using these
   representations must take care to correctly handle invalid input, but
   the encodings presented here are not special in that respect.

   The encoding specified in this document, and representations that may
   be built upon it, are specifically not intended for the storage of
   data.  However, since storage of data in the format in which it is
   exchanged is a very common practice, and the ubiquity of tools for
   indexing and searching text significantly increases the ease of
   searching and the risk of privacy-sensitive data being accidentally
   indexed or searched, the privacy considerations in <a href="#section-11.8">Section 11.8</a> of



<span class="grey">Trammell                     Standards Track                    [Page 9]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-10"></span>
<span class="grey"><a href="./rfc7373">RFC 7373</a>                    IPFIX Text Types              September 2014</span>


   [<a id="ref-RFC7011">RFC7011</a>] are especially important to observe when storing data using
   the encoding specified in this document that was derived from the
   measurement of network traffic.

   When using representations based on this encoding to transmit or
   store network traffic data, consider omitting especially privacy-
   sensitive values by not representing the columns or keys containing
   those values, as in black-marker anonymization as discussed in
   <a href="./rfc6235#section-4">Section 4 of [RFC6235]</a>.  Other anonymization techniques described in
   [<a href="./rfc6235" title='"IP Flow Anonymization Support"'>RFC6235</a>] may also be useful in these situations.

   The encodings for all abstract data types other than 'string' are
   defined in such a way as to be representable in the US-ASCII
   character set and, therefore, should be unproblematic for all
   Enclosing Contexts.  However, the 'string' abstract data type may be
   vulnerable to problems with ill-formed UTF-8 strings as discussed in
   <a href="./rfc7011#section-6.1.6">Section 6.1.6 of [RFC7011]</a>; see [<a href="#ref-UTF8-EXPLOIT">UTF8-EXPLOIT</a>] for background.

<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/6.%20%20References"></a><a class="selflink" href="#section-6" id="section-6">6</a>.  References</span>

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/6.1.%20%20Normative%20References"></a><a class="selflink" href="#section-6.1" id="section-6.1">6.1</a>.  Normative References</span>

   [<a id="ref-RFC2119">RFC2119</a>]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", <a href="https://www.rfc-editor.org/bcp/bcp14">BCP 14</a>, <a href="./rfc2119">RFC 2119</a>, March 1997,
              &lt;<a href="http://www.rfc-editor.org/info/rfc2119">http://www.rfc-editor.org/info/rfc2119</a>&gt;.

   [<a id="ref-RFC3339">RFC3339</a>]  Klyne, G., Ed. and C. Newman, "Date and Time on the
              Internet: Timestamps", <a href="./rfc3339">RFC 3339</a>, July 2002,
              &lt;<a href="http://www.rfc-editor.org/info/rfc3986">http://www.rfc-editor.org/info/rfc3986</a>&gt;.

   [<a id="ref-RFC3986">RFC3986</a>]  Berners-Lee, T., Fielding, R., and L. Masinter, "Uniform
              Resource Identifier (URI): Generic Syntax", STD 66, <a href="./rfc3986">RFC</a>
              <a href="./rfc3986">3986</a>, January 2005,
              &lt;<a href="http://www.rfc-editor.org/info/rfc3986">http://www.rfc-editor.org/info/rfc3986</a>&gt;.

   [<a id="ref-RFC4291">RFC4291</a>]  Hinden, R. and S. Deering, "IP Version 6 Addressing
              Architecture", <a href="./rfc4291">RFC 4291</a>, February 2006,
              &lt;<a href="http://www.rfc-editor.org/info/rfc4291">http://www.rfc-editor.org/info/rfc4291</a>&gt;.

   [<a id="ref-RFC5234">RFC5234</a>]  Crocker, D. and P. Overell, "Augmented BNF for Syntax
              Specifications: ABNF", STD 68, <a href="./rfc5234">RFC 5234</a>, January 2008,
              &lt;<a href="http://www.rfc-editor.org/info/rfc5234">http://www.rfc-editor.org/info/rfc5234</a>&gt;.

   [<a id="ref-RFC5952">RFC5952</a>]  Kawamura, S. and M. Kawashima, "A Recommendation for IPv6
              Address Text Representation", <a href="./rfc5952">RFC 5952</a>, August 2010,
              &lt;<a href="http://www.rfc-editor.org/info/rfc5952">http://www.rfc-editor.org/info/rfc5952</a>&gt;.





<span class="grey">Trammell                     Standards Track                   [Page 10]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-11"></span>
<span class="grey"><a href="./rfc7373">RFC 7373</a>                    IPFIX Text Types              September 2014</span>


   [<a id="ref-RFC7011">RFC7011</a>]  Claise, B., Trammell, B., and P. Aitken, "Specification of
              the IP Flow Information Export (IPFIX) Protocol for the
              Exchange of Flow Information", STD 77, <a href="./rfc7011">RFC 7011</a>, September
              2013, &lt;<a href="http://www.rfc-editor.org/info/rfc7011">http://www.rfc-editor.org/info/rfc7011</a>&gt;.

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/6.2.%20%20Informative%20References"></a><a class="selflink" href="#section-6.2" id="section-6.2">6.2</a>.  Informative References</span>

   [<a id="ref-IANA-IPFIX">IANA-IPFIX</a>]
              IANA, "IPFIX Information Elements",
              &lt;<a href="http://www.iana.org/assignments/ipfix/">http://www.iana.org/assignments/ipfix/</a>&gt;.

   [<a id="ref-IEEE.754.2008">IEEE.754.2008</a>]
              Institute of Electrical and Electronics Engineers, "IEEE
              Standard for Floating-Point Arithmetic", IEEE Standard
              754, August 2008.

   [<a id="ref-PRECIS">PRECIS</a>]   Saint-Andre, P. and M. Blanchet, "PRECIS Framework:
              Preparation and Comparison of Internationalized Strings in
              Application Protocols", Work in Progress, <a href="./draft-ietf-precis-framework-18">draft-ietf-</a>
              <a href="./draft-ietf-precis-framework-18">precis-framework-18</a>, September 2014.

   [<a id="ref-RFC6235">RFC6235</a>]  Boschi, E. and B. Trammell, "IP Flow Anonymization
              Support", <a href="./rfc6235">RFC 6235</a>, May 2011,
              &lt;<a href="http://www.rfc-editor.org/info/rfc6235">http://www.rfc-editor.org/info/rfc6235</a>&gt;.

   [<a id="ref-RFC6313">RFC6313</a>]  Claise, B., Dhandapani, G., Aitken, P., and S. Yates,
              "Export of Structured Data in IP Flow Information Export
              (IPFIX)", <a href="./rfc6313">RFC 6313</a>, July 2011,
              &lt;<a href="http://www.rfc-editor.org/info/rfc6313">http://www.rfc-editor.org/info/rfc6313</a>&gt;.

   [<a id="ref-RFC6885">RFC6885</a>]  Blanchet, M. and A. Sullivan, "Stringprep Revision and
              Problem Statement for the Preparation and Comparison of
              Internationalized Strings (PRECIS)", <a href="./rfc6885">RFC 6885</a>, March 2013,
              &lt;<a href="http://www.rfc-editor.org/info/rfc6885">http://www.rfc-editor.org/info/rfc6885</a>&gt;.

   [<a id="ref-RFC7012">RFC7012</a>]  Claise, B. and B. Trammell, "Information Model for IP Flow
              Information Export (IPFIX)", <a href="./rfc7012">RFC 7012</a>, September 2013,
              &lt;<a href="http://www.rfc-editor.org/info/rfc7012">http://www.rfc-editor.org/info/rfc7012</a>&gt;.

   [<a id="ref-RFC7013">RFC7013</a>]  Trammell, B. and B. Claise, "Guidelines for Authors and
              Reviewers of IP Flow Information Export (IPFIX)
              Information Elements", <a href="https://www.rfc-editor.org/bcp/bcp184">BCP 184</a>, <a href="./rfc7013">RFC 7013</a>, September 2013,
              &lt;<a href="http://www.rfc-editor.org/info/rfc7013">http://www.rfc-editor.org/info/rfc7013</a>&gt;.

   [<a id="ref-RFC7159">RFC7159</a>]  Bray, T., "The JavaScript Object Notation (JSON) Data
              Interchange Format", <a href="./rfc7159">RFC 7159</a>, March 2014,
              &lt;<a href="http://www.rfc-editor.org/info/rfc7159">http://www.rfc-editor.org/info/rfc7159</a>&gt;.




<span class="grey">Trammell                     Standards Track                   [Page 11]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-12"></span>
<span class="grey"><a href="./rfc7373">RFC 7373</a>                    IPFIX Text Types              September 2014</span>


   [<a id="ref-UTF8-EXPLOIT">UTF8-EXPLOIT</a>]
              Davis, M. and M. Suignard, "Unicode Technical Report #36:
              Unicode Security Considerations", The Unicode Consortium,
              November 2012.

   [<a id="ref-W3C-XML">W3C-XML</a>]  Bray, T., Paoli, J., Sperberg-McQueen, C., Maler, E., and
              F. Yergeau, "Extensible Markup Language (XML) 1.0 (Fifth
              Edition)", W3C Recommendation REC-xml, November 2008.











































<span class="grey">Trammell                     Standards Track                   [Page 12]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-13"></span>
<span class="grey"><a href="./rfc7373">RFC 7373</a>                    IPFIX Text Types              September 2014</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/Appendix%20A.%20%20Example"></a><a class="selflink" href="#appendix-A" id="appendix-A">Appendix A</a>.  Example</span>

   In this section, we examine an IPFIX Template and a Data Record
   defined by that Template and show how that Data Record would be
   represented in JSON according to the specification in this document.
   Note that this is specifically NOT a recommendation for a particular
   representation but merely an illustration of the encodings in this
   document; the quoting and formatting in the example are JSON
   specific.

   Figure 1 shows a Template in Information Element Specifier (IESpec)
   format as defined in <a href="./rfc7013#section-10.1">Section 10.1 of [RFC7013]</a>; a corresponding JSON
   object representing a record defined by this template in the text
   format specified in this document is shown in Figure 2.

         flowStartMilliseconds(152)&lt;dateTimeMilliseconds&gt;[8]
         flowEndMilliseconds(153)&lt;dateTimeMilliseconds&gt;[8]
         octetDeltaCount(1)&lt;unsigned64&gt;[4]
         packetDeltaCount(2)&lt;unsigned64&gt;[4]
         sourceIPv6Address(27)&lt;ipv6Address&gt;[16]{key}
         destinationIPv6Address(28)&lt;ipv6Address&gt;[16]{key}
         sourceTransportPort(7)&lt;unsigned16&gt;[2]{key}
         destinationTransportPort(11)&lt;unsigned16&gt;[2]{key}
         protocolIdentifier(4)&lt;unsigned8&gt;[1]{key}
         tcpControlBits(6)&lt;unsigned16&gt;[2]
         flowEndReason(136)&lt;unsigned8&gt;[1]

              Figure 1: Sample Flow Template in IESpec Format

           {
               "flowStartMilliseconds": "2012-11-05T18:31:01.135",
               "flowEndMilliseconds": "2012-11-05T18:31:02.880",
               "octetDeltaCount": 195383,
               "packetDeltaCount": 88,
               "sourceIPv6Address": "2001:db8:c:1337::2",
               "destinationIPv6Address": "2001:db8:c:1337::3",
               "sourceTransportPort": 80,
               "destinationTransportPort": 32991,
               "protocolIdentifier": "tcp",
               "tcpControlBits": 19,
               "flowEndReason": 3
           }

               Figure 2: JSON Object Containing Sample Flow







<span class="grey">Trammell                     Standards Track                   [Page 13]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-14"></span>
<span class="grey"><a href="./rfc7373">RFC 7373</a>                    IPFIX Text Types              September 2014</span>


Acknowledgments

   Thanks to Paul Aitken, Benoit Claise, Andrew Feren, Juergen Quittek,
   David Black, and the IESG for their reviews and comments.  Thanks to
   Dave Thaler and Stephan Neuhaus for discussions that improved the
   floating-point representation section.  This work is materially
   supported by the European Union Seventh Framework Programme under
   grant agreement 318627 mPlane.

Author's Address

   Brian Trammell
   Swiss Federal Institute of Technology Zurich
   Gloriastrasse 35
   8092 Zurich
   Switzerland

   Phone: +41 44 632 70 13
   EMail: ietf@trammell.ch
































Trammell                     Standards Track                   [Page 14]
</pre>
</body></html>