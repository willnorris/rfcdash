<html><head></head><body><pre>Internet Engineering Task Force (IETF)                      M. Bjorklund
Request for Comments: 8342                                Tail-f Systems
Updates: <a href="./rfc7950">7950</a>                                           J. Schoenwaelder
Category: Standards Track                              Jacobs University
ISSN: 2070-1721                                                P. Shafer
                                                               K. Watsen
                                                        Juniper Networks
                                                               R. Wilton
                                                           Cisco Systems
                                                              March 2018


            <span class="h1">Network Management Datastore Architecture (NMDA)</span>

Abstract

   Datastores are a fundamental concept binding the data models written
   in the YANG data modeling language to network management protocols
   such as the Network Configuration Protocol (NETCONF) and RESTCONF.
   This document defines an architectural framework for datastores based
   on the experience gained with the initial simpler model, addressing
   requirements that were not well supported in the initial model.  This
   document updates <a href="./rfc7950">RFC 7950</a>.

Status of This Memo

   This is an Internet Standards Track document.

   This document is a product of the Internet Engineering Task Force
   (IETF).  It represents the consensus of the IETF community.  It has
   received public review and has been approved for publication by the
   Internet Engineering Steering Group (IESG).  Further information on
   Internet Standards is available in <a href="./rfc7841#section-2">SectionÂ 2 of RFC 7841</a>.

   Information about the current status of this document, any errata,
   and how to provide feedback on it may be obtained at
   <a href="https://www.rfc-editor.org/info/rfc8342">https://www.rfc-editor.org/info/rfc8342</a>.














<span class="grey">Bjorklund, et al.            Standards Track                    [Page 1]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-2"></span>
<span class="grey"><a href="./rfc8342">RFC 8342</a>                          NMDA                        March 2018</span>


Copyright Notice

   Copyright (c) 2018 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to <a href="https://www.rfc-editor.org/bcp/bcp78">BCP 78</a> and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (<a href="https://trustee.ietf.org/license-info">https://trustee.ietf.org/license-info</a>) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.

Table of Contents

   <a href="#section-1">1</a>. Introduction ....................................................<a href="#page-3">3</a>
   <a href="#section-2">2</a>. Objectives ......................................................<a href="#page-4">4</a>
   <a href="#section-3">3</a>. Terminology .....................................................<a href="#page-5">5</a>
   <a href="#section-4">4</a>. Background ......................................................<a href="#page-8">8</a>
      <a href="#section-4.1">4.1</a>. Original Model of Datastores ...............................<a href="#page-9">9</a>
   <a href="#section-5">5</a>. Architectural Model of Datastores ..............................<a href="#page-11">11</a>
      <a href="#section-5.1">5.1</a>. Conventional Configuration Datastores .....................<a href="#page-12">12</a>
           <a href="#section-5.1.1">5.1.1</a>. The Startup Configuration Datastore (&lt;startup&gt;) ....<a href="#page-12">12</a>
           5.1.2. The Candidate Configuration Datastore
                  (&lt;candidate&gt;) ......................................<a href="#page-13">13</a>
           <a href="#section-5.1.3">5.1.3</a>. The Running Configuration Datastore (&lt;running&gt;) ....<a href="#page-13">13</a>
           <a href="#section-5.1.4">5.1.4</a>. The Intended Configuration Datastore (&lt;intended&gt;) ..13
      <a href="#section-5.2">5.2</a>. Dynamic Configuration Datastores ..........................<a href="#page-14">14</a>
      <a href="#section-5.3">5.3</a>. The Operational State Datastore (&lt;operational&gt;) ...........<a href="#page-14">14</a>
           <a href="#section-5.3.1">5.3.1</a>. Remnant Configuration ..............................<a href="#page-16">16</a>
           <a href="#section-5.3.2">5.3.2</a>. Missing Resources ..................................<a href="#page-16">16</a>
           <a href="#section-5.3.3">5.3.3</a>. System-Controlled Resources ........................<a href="#page-16">16</a>
           <a href="#section-5.3.4">5.3.4</a>. Origin Metadata Annotation .........................<a href="#page-17">17</a>
   <a href="#section-6">6</a>. Implications on YANG ...........................................<a href="#page-18">18</a>
      <a href="#section-6.1">6.1</a>. XPath Context .............................................<a href="#page-18">18</a>
      <a href="#section-6.2">6.2</a>. Invocation of Actions and RPCs ............................<a href="#page-19">19</a>
   <a href="#section-7">7</a>. YANG Modules ...................................................<a href="#page-20">20</a>
   <a href="#section-8">8</a>. IANA Considerations ............................................<a href="#page-26">26</a>
      <a href="#section-8.1">8.1</a>. Updates to the IETF XML Registry ..........................<a href="#page-26">26</a>
      <a href="#section-8.2">8.2</a>. Updates to the YANG Module Names Registry .................<a href="#page-27">27</a>
   <a href="#section-9">9</a>. Security Considerations ........................................<a href="#page-27">27</a>
   <a href="#section-10">10</a>. References ....................................................<a href="#page-28">28</a>
      <a href="#section-10.1">10.1</a>. Normative References .....................................<a href="#page-28">28</a>
      <a href="#section-10.2">10.2</a>. Informative References ...................................<a href="#page-29">29</a>





<span class="grey">Bjorklund, et al.            Standards Track                    [Page 2]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-3"></span>
<span class="grey"><a href="./rfc8342">RFC 8342</a>                          NMDA                        March 2018</span>


   <a href="#appendix-A">Appendix A</a>. Guidelines for Defining Datastores ....................<a href="#page-31">31</a>
     <a href="#appendix-A.1">A.1</a>. Define Which YANG Modules Can Be Used in the Datastore .....<a href="#page-31">31</a>
     <a href="#appendix-A.2">A.2</a>. Define Which Subset of YANG-Modeled Data Applies ...........<a href="#page-31">31</a>
     <a href="#appendix-A.3">A.3</a>. Define How Data Is Actualized ..............................<a href="#page-31">31</a>
     <a href="#appendix-A.4">A.4</a>. Define Which Protocols Can Be Used .........................<a href="#page-31">31</a>
     <a href="#appendix-A.5">A.5</a>. Define YANG Identities for the Datastore ...................<a href="#page-32">32</a>
   <a href="#appendix-B">Appendix B</a>. Example of an Ephemeral Dynamic Configuration
               Datastore .............................................<a href="#page-32">32</a>
   <a href="#appendix-C">Appendix C</a>. Example Data ..........................................<a href="#page-33">33</a>
     <a href="#appendix-C.1">C.1</a>. System Example .............................................<a href="#page-34">34</a>
     <a href="#appendix-C.2">C.2</a>. BGP Example ................................................<a href="#page-37">37</a>
       <a href="#appendix-C.2.1">C.2.1</a>. Datastores .............................................<a href="#page-38">38</a>
       <a href="#appendix-C.2.2">C.2.2</a>. Adding a Peer ..........................................<a href="#page-38">38</a>
       <a href="#appendix-C.2.3">C.2.3</a>. Removing a Peer ........................................<a href="#page-39">39</a>
     <a href="#appendix-C.3">C.3</a>. Interface Example ..........................................<a href="#page-40">40</a>
       <a href="#appendix-C.3.1">C.3.1</a>. Pre-provisioned Interfaces .............................<a href="#page-41">41</a>
       <a href="#appendix-C.3.2">C.3.2</a>. System-Provided Interface ..............................<a href="#page-42">42</a>
   Acknowledgments ...................................................<a href="#page-43">43</a>
   Authors' Addresses ................................................<a href="#page-44">44</a>

<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/1.%20%20Introduction"></a><a class="selflink" href="#section-1" id="section-1">1</a>.  Introduction</span>

   This document provides an architectural framework for datastores as
   they are used by network management protocols such as the Network
   Configuration Protocol (NETCONF) [<a href="./rfc6241" title='"Network Configuration Protocol (NETCONF)"'>RFC6241</a>], RESTCONF [<a href="./rfc8040" title='"RESTCONF Protocol"'>RFC8040</a>], and
   the YANG data modeling language [<a href="./rfc7950" title='"The YANG 1.1 Data Modeling Language"'>RFC7950</a>].  Datastores are a
   fundamental concept binding network management data models to network
   management protocols.  Agreement on a common architectural model of
   datastores ensures that data models can be written in a way that is
   network management protocol agnostic.  This architectural framework
   identifies a set of conceptual datastores, but it does not mandate
   that all network management protocols expose all these conceptual
   datastores.  This architecture is agnostic with regard to the
   encoding used by network management protocols.

   This document updates <a href="./rfc7950">RFC 7950</a> by refining the definition of the
   accessible tree for some XML Path Language (XPath) context (see
   <a href="#section-6.1">Section 6.1</a>) and the invocation context of operations (see
   <a href="#section-6.2">Section 6.2</a>).

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
   "OPTIONAL" in this document are to be interpreted as described in
   <a href="https://www.rfc-editor.org/bcp/bcp14">BCP 14</a> [<a href="./rfc2119" title='"Key words for use in RFCs to Indicate Requirement Levels"'>RFC2119</a>] [<a href="./rfc8174" title='"Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words"'>RFC8174</a>] when, and only when, they appear in all
   capitals, as shown here.






<span class="grey">Bjorklund, et al.            Standards Track                    [Page 3]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-4"></span>
<span class="grey"><a href="./rfc8342">RFC 8342</a>                          NMDA                        March 2018</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/2.%20%20Objectives"></a><a class="selflink" href="#section-2" id="section-2">2</a>.  Objectives</span>

   Network management data objects can often take two different values:
   the value configured by the user or an application (configuration)
   and the value that the device is actually using (operational state).
   These two values may be different for a number of reasons, e.g.,
   system internal interactions with hardware, interaction with
   protocols or other devices, or simply the time it takes to propagate
   a configuration change to the software and hardware components of a
   system.  Furthermore, configuration and operational state data
   objects may have different lifetimes.

   The original model of datastores required these data objects to be
   modeled twice in the YANG schema -- as "config true" objects and as
   "config false" objects.  The convention adopted by the interfaces
   data model [<a href="./rfc8343" title='"A YANG Data Model for Interface Management"'>RFC8343</a>] and the IP data model [<a href="./rfc8344" title='"A YANG Data Model for IP Management"'>RFC8344</a>] was to use two
   separate branches rooted at the root of the data tree: one branch for
   configuration data objects and one branch for operational state data
   objects.

   The duplication of definitions and the ad hoc separation of
   operational state data from configuration data lead to a number of
   problems.  Having configuration and operational state data in
   separate branches in the data model is operationally complicated and
   impacts the readability of module definitions.  Furthermore, the
   relationship between the branches is not machine readable, and filter
   expressions operating on configuration and on related operational
   state are different.

   With the revised architectural model of datastores defined in this
   document, the data objects are defined only once in the YANG schema
   but independent instantiations can appear in different datastores,
   e.g., one for a configured value and another for an operationally
   used value.  This provides a more elegant and simpler solution to the
   problem.

   The revised architectural model of datastores supports additional
   datastores for systems that support more advanced processing chains
   converting configuration to operational state.  For example, some
   systems support configuration that is not currently used (so-called
   "inactive configuration") or they support configuration templates
   that are used to expand configuration data via a common template.









<span class="grey">Bjorklund, et al.            Standards Track                    [Page 4]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-5"></span>
<span class="grey"><a href="./rfc8342">RFC 8342</a>                          NMDA                        March 2018</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/3.%20%20Terminology"></a><a class="selflink" href="#section-3" id="section-3">3</a>.  Terminology</span>

   This document defines the following terminology.  Some of the terms
   are revised definitions of terms originally defined in [<a href="./rfc6241" title='"Network Configuration Protocol (NETCONF)"'>RFC6241</a>] and
   [<a href="./rfc7950" title='"The YANG 1.1 Data Modeling Language"'>RFC7950</a>] (see also <a href="#section-4">Section 4</a>).  The revised definitions are
   semantically equivalent to the definitions found in [<a href="./rfc6241" title='"Network Configuration Protocol (NETCONF)"'>RFC6241</a>] and
   [<a href="./rfc7950" title='"The YANG 1.1 Data Modeling Language"'>RFC7950</a>].  It is expected that the revised definitions provided in
   this section will replace the definitions in [<a href="./rfc6241" title='"Network Configuration Protocol (NETCONF)"'>RFC6241</a>] and [<a href="./rfc7950" title='"The YANG 1.1 Data Modeling Language"'>RFC7950</a>]
   when these documents are revised.

   o  datastore: A conceptual place to store and access information.  A
      datastore might be implemented, for example, using files, a
      database, flash memory locations, or combinations thereof.  A
      datastore maps to an instantiated YANG data tree.

   o  schema node: A node in the schema tree.  The formal definition is
      provided in <a href="./rfc7950">RFC 7950</a>.

   o  datastore schema: The combined set of schema nodes for all modules
      supported by a particular datastore, taking into consideration any
      deviations and enabled features for that datastore.

   o  configuration: Data that is required to get a device from its
      initial default state into a desired operational state.  This data
      is modeled in YANG using "config true" nodes.  Configuration can
      originate from different sources.

   o  configuration datastore: A datastore holding configuration.

   o  running configuration datastore: A configuration datastore holding
      the current configuration of the device.  It may include
      configuration that requires further transformations before it can
      be applied.  This datastore is referred to as "&lt;running&gt;".

   o  candidate configuration datastore: A configuration datastore that
      can be manipulated without impacting the device's running
      configuration datastore and that can be committed to the running
      configuration datastore.  This datastore is referred to as
      "&lt;candidate&gt;".

   o  startup configuration datastore: A configuration datastore holding
      the configuration loaded by the device into the running
      configuration datastore when it boots.  This datastore is referred
      to as "&lt;startup&gt;".







<span class="grey">Bjorklund, et al.            Standards Track                    [Page 5]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-6"></span>
<span class="grey"><a href="./rfc8342">RFC 8342</a>                          NMDA                        March 2018</span>


   o  intended configuration: Configuration that is intended to be used
      by the device.  It represents the configuration after all
      configuration transformations to &lt;running&gt; have been performed and
      is the configuration that the system attempts to apply.

   o  intended configuration datastore: A configuration datastore
      holding the complete intended configuration of the device.  This
      datastore is referred to as "&lt;intended&gt;".

   o  configuration transformation: The addition, modification, or
      removal of configuration between the &lt;running&gt; and &lt;intended&gt;
      datastores.  Examples of configuration transformations include the
      removal of inactive configuration and the configuration produced
      through the expansion of templates.

   o  conventional configuration datastore: One of the following set of
      configuration datastores: &lt;running&gt;, &lt;startup&gt;, &lt;candidate&gt;, and
      &lt;intended&gt;.  These datastores share a common datastore schema, and
      protocol operations allow copying data between these datastores.
      The term "conventional" is chosen as a generic umbrella term for
      these datastores.

   o  conventional configuration: Configuration that is stored in any of
      the conventional configuration datastores.

   o  dynamic configuration datastore: A configuration datastore holding
      configuration obtained dynamically during the operation of a
      device through interaction with other systems, rather than through
      one of the conventional configuration datastores.

   o  dynamic configuration: Configuration obtained via a dynamic
      configuration datastore.

   o  learned configuration: Configuration that has been learned via
      protocol interactions with other systems and that is neither
      conventional nor dynamic configuration.

   o  system configuration: Configuration that is supplied by the device
      itself.

   o  default configuration: Configuration that is not explicitly
      provided but for which a value defined in the data model is used.

   o  applied configuration: Configuration that is actively in use by a
      device.  Applied configuration originates from conventional,
      dynamic, learned, system, and default configuration.





<span class="grey">Bjorklund, et al.            Standards Track                    [Page 6]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-7"></span>
<span class="grey"><a href="./rfc8342">RFC 8342</a>                          NMDA                        March 2018</span>


   o  system state: The additional data on a system that is not
      configuration, such as read-only status information and collected
      statistics.  System state is transient and modified by
      interactions with internal components or other systems.  System
      state is modeled in YANG using "config false" nodes.

   o  operational state: The combination of applied configuration and
      system state.

   o  operational state datastore: A datastore holding the complete
      operational state of the device.  This datastore is referred to as
      "&lt;operational&gt;".

   o  origin: A metadata annotation indicating the origin of a
      data item.

   o  remnant configuration: Configuration that remains part of the
      applied configuration for a period of time after it has been
      removed from the intended configuration or dynamic configuration.
      The time period may be minimal or may last until all resources
      used by the newly deleted configuration (e.g., network
      connections, memory allocations, file handles) have been
      deallocated.

   The following additional terms are not datastore specific, but they
   are commonly used and are thus defined here as well:

   o  client: An entity that can access YANG-defined data on a server,
      over some network management protocol.

   o  server: An entity that provides access to YANG-defined data to a
      client, over some network management protocol.

   o  notification: A server-initiated message indicating that a certain
      event has been recognized by the server.

   o  remote procedure call: An operation that can be invoked by a
      client on a server.













<span class="grey">Bjorklund, et al.            Standards Track                    [Page 7]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-8"></span>
<span class="grey"><a href="./rfc8342">RFC 8342</a>                          NMDA                        March 2018</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/4.%20%20Background"></a><a class="selflink" href="#section-4" id="section-4">4</a>.  Background</span>

   NETCONF [<a href="./rfc6241" title='"Network Configuration Protocol (NETCONF)"'>RFC6241</a>] provides the following definitions:

   o  datastore: A conceptual place to store and access information.  A
      datastore might be implemented, for example, using files, a
      database, flash memory locations, or combinations thereof.

   o  configuration datastore: The datastore holding the complete set of
      configuration that is required to get a device from its initial
      default state into a desired operational state.

   YANG 1.1 [<a href="./rfc7950" title='"The YANG 1.1 Data Modeling Language"'>RFC7950</a>] provides the following refinements when NETCONF is
   used with YANG (which is the usual case, but note that NETCONF was
   defined before YANG existed):

   o  datastore: When modeled with YANG, a datastore is realized as an
      instantiated data tree.

   o  configuration datastore: When modeled with YANG, a configuration
      datastore is realized as an instantiated data tree with
      configuration.

   [<a id="ref-RFC6244">RFC6244</a>] defined operational state data as follows:

   o  Operational state data is a set of data that has been obtained by
      the system at runtime and influences the system's behavior similar
      to configuration data.  In contrast to configuration data,
      operational state is transient and modified by interactions with
      internal components or other systems via specialized protocols.

   <a href="./rfc6244#section-4.3.3">SectionÂ 4.3.3 of [RFC6244]</a> discusses operational state and mentions,
   among other things, the option to consider operational state as being
   stored in another datastore.  <a href="./rfc6244#section-4.4">SectionÂ 4.4 of [RFC6244]</a> then concludes
   that, at the time of its writing, modeling state as distinct leafs
   and distinct branches is the recommended approach.

   Implementation experience and requests from operators [<a href="#ref-OpState-Reqs">OpState-Reqs</a>]
   [<a href="#ref-OpState-Modeling">OpState-Modeling</a>] indicate that the datastore model initially
   designed for NETCONF and refined by YANG needs to be extended.  In
   particular, the notion of intended configuration and applied
   configuration has developed.









<span class="grey">Bjorklund, et al.            Standards Track                    [Page 8]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-9"></span>
<span class="grey"><a href="./rfc8342">RFC 8342</a>                          NMDA                        March 2018</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/4.1.%20%20Original%20Model%20of%20Datastores"></a><a class="selflink" href="#section-4.1" id="section-4.1">4.1</a>.  Original Model of Datastores</span>

   The following drawing shows the original model of datastores as it is
   currently used by NETCONF [<a href="./rfc6241" title='"Network Configuration Protocol (NETCONF)"'>RFC6241</a>]:

          +-------------+                 +-----------+
          | &lt;candidate&gt; |                 | &lt;startup&gt; |
          |  (ct, rw)   |&lt;---+       +---&gt;| (ct, rw)  |
          +-------------+    |       |    +-----------+
                 |           |       |           |
                 |         +-----------+         |
                 +--------&gt;| &lt;running&gt; |&lt;--------+
                           | (ct, rw)  |
                           +-----------+
                                 |
                                 v
                          operational state  &lt;--- control plane
                              (cf, ro)

          ct = config true; cf = config false
          rw = read-write; ro = read-only
          boxes denote datastores

                                 Figure 1

   Note that this diagram simplifies the model: "read-only" (ro) and
   "read-write" (rw) are to be understood from the client's perspective,
   at a conceptual level.  In NETCONF, for example, support for
   &lt;candidate&gt; and &lt;startup&gt; is optional, and &lt;running&gt; does not have to
   be writable.  Furthermore, &lt;startup&gt; can only be modified by copying
   &lt;running&gt; to &lt;startup&gt; in the standardized NETCONF datastore editing
   model.  The RESTCONF protocol does not expose these differences and
   instead provides only a writable unified datastore, which hides
   whether edits are done through &lt;candidate&gt;, by directly modifying
   &lt;running&gt;, or via some other implementation-specific mechanism.
   RESTCONF also hides how configuration is made persistent.  Note that
   implementations may also have additional datastores that can
   propagate changes to &lt;running&gt;.  NETCONF explicitly mentions
   so-called "named datastores".












<span class="grey">Bjorklund, et al.            Standards Track                    [Page 9]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-10"></span>
<span class="grey"><a href="./rfc8342">RFC 8342</a>                          NMDA                        March 2018</span>


   Some observations:

   o  Operational state has not been defined as a datastore, although
      there were proposals in the past to introduce an operational state
      datastore.

   o  The NETCONF &lt;get&gt; operation returns the contents of &lt;running&gt;
      together with the operational state.  It is therefore necessary
      that "config false" data be in a different branch than the
      "config true" data if the operational state can have a different
      lifetime compared to configuration or if configuration is not
      immediately or successfully applied.

   o  Several implementations have proprietary mechanisms that allow
      clients to store inactive data in &lt;running&gt;.  Inactive data is
      conceptually removed before validation.

   o  Some implementations have proprietary mechanisms that allow
      clients to define configuration templates in &lt;running&gt;.  These
      templates are expanded automatically by the system, and the
      resulting configuration is applied internally.

   o  Some operators have reported that it is essential for them to be
      able to retrieve the configuration that has actually been
      successfully applied, which may be a subset or a superset of the
      &lt;running&gt; configuration.

























<span class="grey">Bjorklund, et al.            Standards Track                   [Page 10]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-11"></span>
<span class="grey"><a href="./rfc8342">RFC 8342</a>                          NMDA                        March 2018</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/5.%20%20Architectural%20Model%20of%20Datastores"></a><a class="selflink" href="#section-5" id="section-5">5</a>.  Architectural Model of Datastores</span>

   Below is a new conceptual model of datastores, extending the original
   model in order to reflect the experience gained with the original
   model.

     +-------------+                 +-----------+
     | &lt;candidate&gt; |                 | &lt;startup&gt; |
     |  (ct, rw)   |&lt;---+       +---&gt;| (ct, rw)  |
     +-------------+    |       |    +-----------+
            |           |       |           |
            |         +-----------+         |
            +--------&gt;| &lt;running&gt; |&lt;--------+
                      | (ct, rw)  |
                      +-----------+
                            |
                            |        // configuration transformations,
                            |        // e.g., removal of nodes marked as
                            |        // "inactive", expansion of
                            |        // templates
                            v
                      +------------+
                      | &lt;intended&gt; | // subject to validation
                      | (ct, ro)   |
                      +------------+
                            |        // changes applied, subject to
                            |        // local factors, e.g., missing
                            |        // resources, delays
                            |
       dynamic              |   +-------- learned configuration
       configuration        |   +-------- system configuration
       datastores -----+    |   +-------- default configuration
                       |    |   |
                       v    v   v
                    +---------------+
                    | &lt;operational&gt; | &lt;-- system state
                    | (ct + cf, ro) |
                    +---------------+

     ct = config true; cf = config false
     rw = read-write; ro = read-only
     boxes denote named datastores

                                 Figure 2







<span class="grey">Bjorklund, et al.            Standards Track                   [Page 11]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-12"></span>
<span class="grey"><a href="./rfc8342">RFC 8342</a>                          NMDA                        March 2018</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/5.1.%20%20Conventional%20Configuration%20Datastores"></a><a class="selflink" href="#section-5.1" id="section-5.1">5.1</a>.  Conventional Configuration Datastores</span>

   The conventional configuration datastores are a set of configuration
   datastores that share exactly the same datastore schema, allowing
   data to be copied between them.  The term is meant as a generic
   umbrella description of these datastores.  If a module does not
   contain any configuration data nodes and it is not needed to satisfy
   any imports, then it MAY be omitted from the datastore schema for the
   conventional configuration datastores.  The set of datastores
   include:

   o  &lt;running&gt;

   o  &lt;candidate&gt;

   o  &lt;startup&gt;

   o  &lt;intended&gt;

   Other conventional configuration datastores may be defined in future
   documents.

   The flow of data between these datastores is depicted in <a href="#section-5">Section 5</a>.

   The specific protocols may define explicit operations to copy between
   these datastores, e.g., NETCONF defines the &lt;copy-config&gt; operation.

<span class="h4"><a class="dashAnchor" name="//apple_ref/cpp/Section/5.1.1.%20%20The%20Startup%20Configuration%20Datastore%20%28%3Cstartup%3E%29"></a><a class="selflink" href="#section-5.1.1" id="section-5.1.1">5.1.1</a>.  The Startup Configuration Datastore (&lt;startup&gt;)</span>

   The startup configuration datastore (&lt;startup&gt;) is a configuration
   datastore holding the configuration loaded by the device when it
   boots.  &lt;startup&gt; is only present on devices that separate the
   startup configuration from the running configuration datastore.

   The startup configuration datastore may not be supported by all
   protocols or implementations.

   On devices that support non-volatile storage, the contents of
   &lt;startup&gt; will typically persist across reboots via that storage.  At
   boot time, the device loads the saved startup configuration into
   &lt;running&gt;.  To save a new startup configuration, data is copied to
   &lt;startup&gt; via either implicit or explicit protocol operations.









<span class="grey">Bjorklund, et al.            Standards Track                   [Page 12]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-13"></span>
<span class="grey"><a href="./rfc8342">RFC 8342</a>                          NMDA                        March 2018</span>


<span class="h4"><a class="dashAnchor" name="//apple_ref/cpp/Section/5.1.2.%20%20The%20Candidate%20Configuration%20Datastore%20%28%3Ccandidate%3E%29"></a><a class="selflink" href="#section-5.1.2" id="section-5.1.2">5.1.2</a>.  The Candidate Configuration Datastore (&lt;candidate&gt;)</span>

   The candidate configuration datastore (&lt;candidate&gt;) is a
   configuration datastore that can be manipulated without impacting the
   device's current configuration and that can be committed to
   &lt;running&gt;.

   The candidate configuration datastore may not be supported by all
   protocols or implementations.

   &lt;candidate&gt; does not typically persist across reboots, even in the
   presence of non-volatile storage.  If &lt;candidate&gt; is stored using
   non-volatile storage, it is reset at boot time to the contents of
   &lt;running&gt;.

<span class="h4"><a class="dashAnchor" name="//apple_ref/cpp/Section/5.1.3.%20%20The%20Running%20Configuration%20Datastore%20%28%3Crunning%3E%29"></a><a class="selflink" href="#section-5.1.3" id="section-5.1.3">5.1.3</a>.  The Running Configuration Datastore (&lt;running&gt;)</span>

   The running configuration datastore (&lt;running&gt;) is a configuration
   datastore that holds the current configuration of the device.  It MAY
   include configuration that requires further transformation before it
   can be applied, e.g., inactive configuration, or template-mechanism-
   oriented configuration that needs further expansion.  However,
   &lt;running&gt; MUST always be a valid configuration data tree, as defined
   in <a href="./rfc7950#section-8.1">SectionÂ 8.1 of [RFC7950]</a>.

   &lt;running&gt; MUST be supported if the device can be configured via
   conventional configuration datastores.

   If a device does not have a distinct &lt;startup&gt; and non-volatile
   storage is available, the device will typically use that non-volatile
   storage to allow &lt;running&gt; to persist across reboots.

<span class="h4"><a class="dashAnchor" name="//apple_ref/cpp/Section/5.1.4.%20%20The%20Intended%20Configuration%20Datastore%20%28%3Cintended%3E%29"></a><a class="selflink" href="#section-5.1.4" id="section-5.1.4">5.1.4</a>.  The Intended Configuration Datastore (&lt;intended&gt;)</span>

   The intended configuration datastore (&lt;intended&gt;) is a read-only
   configuration datastore.  It represents the configuration after all
   configuration transformations to &lt;running&gt; are performed (e.g.,
   template expansion, removal of inactive configuration) and is the
   configuration that the system attempts to apply.

   &lt;intended&gt; is tightly coupled to &lt;running&gt;.  Whenever data is written
   to &lt;running&gt;, the server MUST also immediately update and validate
   &lt;intended&gt;.

   &lt;intended&gt; MAY also be updated independently of &lt;running&gt; if the
   effect of a configuration transformation changes, but &lt;intended&gt; MUST
   always be a valid configuration data tree, as defined in <a href="./rfc7950#section-8.1">SectionÂ 8.1
   of [RFC7950]</a>.



<span class="grey">Bjorklund, et al.            Standards Track                   [Page 13]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-14"></span>
<span class="grey"><a href="./rfc8342">RFC 8342</a>                          NMDA                        March 2018</span>


   For simple implementations, &lt;running&gt; and &lt;intended&gt; are identical.

   The contents of &lt;intended&gt; are also related to the "config true"
   subset of &lt;operational&gt;; hence, a client can determine to what extent
   the intended configuration is currently in use by checking to see
   whether the contents of &lt;intended&gt; also appear in &lt;operational&gt;.

   &lt;intended&gt; does not persist across reboots; its relationship with
   &lt;running&gt; makes that unnecessary.

   Currently, there are no standard mechanisms defined that affect
   &lt;intended&gt; so that it would have different content than &lt;running&gt;,
   but this architecture allows for such mechanisms to be defined.

   One example of such a mechanism is support for marking nodes as
   inactive in &lt;running&gt;.  Inactive nodes are not copied to &lt;intended&gt;.
   A second example is support for templates, which can perform
   transformations on the configuration from &lt;running&gt; to the
   configuration written to &lt;intended&gt;.

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/5.2.%20%20Dynamic%20Configuration%20Datastores"></a><a class="selflink" href="#section-5.2" id="section-5.2">5.2</a>.  Dynamic Configuration Datastores</span>

   The model recognizes the need for dynamic configuration datastores
   that are, by definition, not part of the persistent configuration of
   a device.  In some contexts, these have been termed "ephemeral
   datastores", since the information is ephemeral, i.e., lost upon
   reboot.  The dynamic configuration datastores interact with the rest
   of the system through &lt;operational&gt;.

   The datastore schema for a dynamic configuration datastore MAY differ
   from the datastore schema used for conventional configuration
   datastores.  If a module does not contain any configuration data
   nodes and it is not needed to satisfy any imports, then it MAY be
   omitted from the datastore schema for the dynamic configuration
   datastore.

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/5.3.%20%20The%20Operational%20State%20Datastore%20%28%3Coperational%3E%29"></a><a class="selflink" href="#section-5.3" id="section-5.3">5.3</a>.  The Operational State Datastore (&lt;operational&gt;)</span>

   The operational state datastore (&lt;operational&gt;) is a read-only
   datastore that consists of all "config true" and "config false" nodes
   defined in the datastore's schema.  In the original NETCONF model,
   the operational state only had "config false" nodes.  The reason for
   incorporating "config true" nodes here is to be able to expose all
   operational settings without having to replicate definitions in the
   data models.






<span class="grey">Bjorklund, et al.            Standards Track                   [Page 14]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-15"></span>
<span class="grey"><a href="./rfc8342">RFC 8342</a>                          NMDA                        March 2018</span>


   &lt;operational&gt; contains system state and all configuration actually
   used by the system.  This includes all applied configuration from
   &lt;intended&gt;, learned configuration, system-provided configuration, and
   default values defined by any supported data models.  In addition,
   &lt;operational&gt; also contains applied configuration from dynamic
   configuration datastores.

   The datastore schema for &lt;operational&gt; MUST be a superset of the
   combined datastore schema used in all configuration datastores,
   except that configuration data nodes supported in a configuration
   datastore MAY be omitted from &lt;operational&gt; if a server is not able
   to accurately report them.

   Requests to retrieve nodes from &lt;operational&gt; always return the value
   in use if the node exists, regardless of any default value specified
   in the YANG module.  If no value is returned for a given node, then
   this implies that the node is not used by the device.

   The interpretation of what constitutes being "in use" by the system
   is dependent on both the schema definition and the device
   implementation.  Generally, functionality that is enabled and
   operational on the system would be considered to be "in use".
   Conversely, functionality that is neither enabled nor operational on
   the system is considered not to be "in use"; hence, it SHOULD be
   omitted from &lt;operational&gt;.

   &lt;operational&gt; SHOULD conform to any constraints specified in the data
   model, but given the principal aim of returning "in use" values, it
   is possible that constraints MAY be violated under some circumstances
   (e.g., an abnormal value is "in use", the structure of a list is
   being modified, or remnant configuration (see <a href="#section-5.3.1">Section 5.3.1</a>) still
   exists).  Note that deviations SHOULD be used when it is known in
   advance that a device does not fully conform to the &lt;operational&gt;
   schema.

   Only semantic constraints MAY be violated.  These are the YANG
   "when", "must", "mandatory", "unique", "min-elements", and
   "max-elements" statements; and the uniqueness of key values.

   Syntactic constraints MUST NOT be violated, including hierarchical
   organization, identifiers, and type-based constraints.  If a node in
   &lt;operational&gt; does not meet the syntactic constraints, then it
   MUST NOT be returned, and some other mechanism should be used to flag
   the error.

   &lt;operational&gt; does not persist across reboots.





<span class="grey">Bjorklund, et al.            Standards Track                   [Page 15]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-16"></span>
<span class="grey"><a href="./rfc8342">RFC 8342</a>                          NMDA                        March 2018</span>


<span class="h4"><a class="dashAnchor" name="//apple_ref/cpp/Section/5.3.1.%20%20Remnant%20Configuration"></a><a class="selflink" href="#section-5.3.1" id="section-5.3.1">5.3.1</a>.  Remnant Configuration</span>

   Changes to configuration may take time to percolate through to
   &lt;operational&gt;.  During this period, &lt;operational&gt; may contain nodes
   for both the previous and current configuration, as closely as
   possible tracking the current operation of the device.  Such remnant
   configuration from the previous configuration persists until the
   system has released resources used by the newly deleted configuration
   (e.g., network connections, memory allocations, file handles).

   Remnant configuration is a common example of where the semantic
   constraints defined in the data model cannot be relied upon for
   &lt;operational&gt;, since the system may have remnant configuration whose
   constraints were valid with the previous configuration and that are
   not valid with the current configuration.  Since constraints on
   "config false" nodes may refer to "config true" nodes, remnant
   configuration may force the violation of those constraints.

<span class="h4"><a class="dashAnchor" name="//apple_ref/cpp/Section/5.3.2.%20%20Missing%20Resources"></a><a class="selflink" href="#section-5.3.2" id="section-5.3.2">5.3.2</a>.  Missing Resources</span>

   Configuration in &lt;intended&gt; can refer to resources that are not
   available or otherwise not physically present.  In these situations,
   these parts of &lt;intended&gt; are not applied.  The data appears in
   &lt;intended&gt; but does not appear in &lt;operational&gt;.

   A typical example is an interface configuration that refers to an
   interface that is not currently present.  In such a situation, the
   interface configuration remains in &lt;intended&gt; but the interface
   configuration will not appear in &lt;operational&gt;.

   Note that configuration validity cannot depend on the current state
   of such resources, since that would imply that removing a resource
   might render the configuration invalid.  This is unacceptable,
   especially given that rebooting such a device would cause it to
   restart with an invalid configuration.  Instead, we allow
   configuration for missing resources to exist in &lt;running&gt; and
   &lt;intended&gt;, but it will not appear in &lt;operational&gt;.

<span class="h4"><a class="dashAnchor" name="//apple_ref/cpp/Section/5.3.3.%20%20System-Controlled%20Resources"></a><a class="selflink" href="#section-5.3.3" id="section-5.3.3">5.3.3</a>.  System-Controlled Resources</span>

   Sometimes, resources are controlled by the device and the
   corresponding system-controlled data appears in (and disappears from)
   &lt;operational&gt; dynamically.  If a system-controlled resource has
   matching configuration in &lt;intended&gt; when it appears, the system will
   try to apply the configuration; this causes the configuration to
   appear in &lt;operational&gt; eventually (if application of the
   configuration was successful).




<span class="grey">Bjorklund, et al.            Standards Track                   [Page 16]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-17"></span>
<span class="grey"><a href="./rfc8342">RFC 8342</a>                          NMDA                        March 2018</span>


<span class="h4"><a class="dashAnchor" name="//apple_ref/cpp/Section/5.3.4.%20%20Origin%20Metadata%20Annotation"></a><a class="selflink" href="#section-5.3.4" id="section-5.3.4">5.3.4</a>.  Origin Metadata Annotation</span>

   As configuration flows into &lt;operational&gt;, it is conceptually marked
   with a metadata annotation [<a href="./rfc7952" title='"Defining and Using Metadata with YANG"'>RFC7952</a>] that indicates its origin.  The
   origin applies to all configuration nodes except non-presence
   containers.  The "origin" metadata annotation is defined in
   <a href="#section-7">Section 7</a>.  The values are YANG identities.  The following identities
   are defined:

   o  origin: abstract base identity from which the other origin
      identities are derived.

   o  intended: represents configuration provided by &lt;intended&gt;.

   o  dynamic: represents configuration provided by a dynamic
      configuration datastore.

   o  system: represents configuration provided by the system itself.
      Examples of system configuration include applied configuration for
      an always-existing loopback interface, or interface configuration
      that is auto-created due to the hardware currently present in the
      device.

   o  learned: represents configuration that has been learned via
      protocol interactions with other systems, including such protocols
      as link-layer negotiations, routing protocols, and DHCP.

   o  default: represents configuration using a default value specified
      in the data model, using either values in the "default" statement
      or any values described in the "description" statement.  The
      default origin is only used when the configuration has not been
      provided by any other source.

   o  unknown: represents configuration for which the system cannot
      identify the origin.

   These identities can be further refined, e.g., there could be
   separate identities for particular types or instances of dynamic
   configuration datastores derived from "dynamic".

   For all configuration data nodes in &lt;operational&gt;, the device SHOULD
   report the origin that most accurately reflects the source of the
   configuration that is in use by the system.








<span class="grey">Bjorklund, et al.            Standards Track                   [Page 17]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-18"></span>
<span class="grey"><a href="./rfc8342">RFC 8342</a>                          NMDA                        March 2018</span>


   In cases where it could be ambiguous as to which origin should be
   used, i.e., where the same data node value has originated from
   multiple sources, the "description" statement in the YANG module
   SHOULD be used as guidance for choosing the appropriate origin.  For
   example:

   If, for a particular configuration node, the associated YANG
   "description" statement indicates that a protocol-negotiated value
   overrides any configured value, then the origin would be reported as
   "learned", even when a learned value is the same as the configured
   value.

   Conversely, if, for a particular configuration node, the associated
   YANG "description" statement indicates that a protocol-negotiated
   value does not override an explicitly configured value, then the
   origin would be reported as "intended", even when a learned value is
   the same as the configured value.

   In the case that a device cannot provide an accurate origin for a
   particular configuration data node, it SHOULD use the origin
   "unknown".

<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/6.%20%20Implications%20on%20YANG"></a><a class="selflink" href="#section-6" id="section-6">6</a>.  Implications on YANG</span>

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/6.1.%20%20XPath%20Context"></a><a class="selflink" href="#section-6.1" id="section-6.1">6.1</a>.  XPath Context</span>

   This section updates <a href="./rfc7950#section-6.4.1">SectionÂ 6.4.1 of RFC 7950</a>.

   If a server implements the architecture defined in this document, the
   accessible trees for some XPath contexts are refined as follows:

   o  If the XPath expression is defined in a substatement to a data
      node that represents system state, the accessible tree is all
      operational state in the server.  The root node has all top-level
      data nodes in all modules as children.

   o  If the XPath expression is defined in a substatement to a
      "notification" statement, the accessible tree is the notification
      instance and all operational state in the server.  If the
      notification is defined on the top level in a module, then the
      root node has the node representing the notification being defined
      and all top-level data nodes in all modules as children.
      Otherwise, the root node has all top-level data nodes in all
      modules as children.







<span class="grey">Bjorklund, et al.            Standards Track                   [Page 18]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-19"></span>
<span class="grey"><a href="./rfc8342">RFC 8342</a>                          NMDA                        March 2018</span>


   o  If the XPath expression is defined in a substatement to an "input"
      statement in an "rpc" or "action" statement, the accessible tree
      is the RPC or action operation instance and all operational state
      in the server.  The root node has top-level data nodes in all
      modules as children.  Additionally, for an RPC, the root node also
      has the node representing the RPC operation being defined as a
      child.  The node representing the operation being defined has the
      operation's input parameters as children.

   o  If the XPath expression is defined in a substatement to an
      "output" statement in an "rpc" or "action" statement, the
      accessible tree is the RPC or action operation instance and all
      operational state in the server.  The root node has top-level data
      nodes in all modules as children.  Additionally, for an RPC, the
      root node also has the node representing the RPC operation being
      defined as a child.  The node representing the operation being
      defined has the operation's output parameters as children.

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/6.2.%20%20Invocation%20of%20Actions%20and%20RPCs"></a><a class="selflink" href="#section-6.2" id="section-6.2">6.2</a>.  Invocation of Actions and RPCs</span>

   This section updates <a href="./rfc7950#section-7.15">SectionÂ 7.15 of RFC 7950</a>.

   Actions are always invoked in the context of the operational state
   datastore.  The node for which the action is invoked MUST exist in
   the operational state datastore.

   Note that this document does not constrain the result of invoking an
   RPC or action in any way.  For example, an RPC might be defined to
   modify the contents of some datastore.






















<span class="grey">Bjorklund, et al.            Standards Track                   [Page 19]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-20"></span>
<span class="grey"><a href="./rfc8342">RFC 8342</a>                          NMDA                        March 2018</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/7.%20%20YANG%20Modules"></a><a class="selflink" href="#section-7" id="section-7">7</a>.  YANG Modules</span>

   &lt;CODE BEGINS&gt; file "ietf-datastores@2018-02-14.yang"

   module ietf-datastores {
     yang-version 1.1;
     namespace "urn:ietf:params:xml:ns:yang:ietf-datastores";
     prefix ds;

     organization
       "IETF Network Modeling (NETMOD) Working Group";

     contact
       "WG Web:   &lt;<a href="https://datatracker.ietf.org/wg/netmod/">https://datatracker.ietf.org/wg/netmod/</a>&gt;

        WG List:  &lt;mailto:netmod@ietf.org&gt;

        Author:   Martin Bjorklund
                  &lt;mailto:mbj@tail-f.com&gt;

        Author:   Juergen Schoenwaelder
                  &lt;mailto:j.schoenwaelder@jacobs-university.de&gt;

        Author:   Phil Shafer
                  &lt;mailto:phil@juniper.net&gt;

        Author:   Kent Watsen
                  &lt;mailto:kwatsen@juniper.net&gt;

        Author:   Rob Wilton
                  &lt;rwilton@cisco.com&gt;";

     description
       "This YANG module defines a set of identities for identifying
        datastores.

        Copyright (c) 2018 IETF Trust and the persons identified as
        authors of the code.  All rights reserved.

        Redistribution and use in source and binary forms, with or
        without modification, is permitted pursuant to, and subject to
        the license terms contained in, the Simplified BSD License set
        forth in <a href="#section-4">Section 4</a>.c of the IETF Trust's Legal Provisions
        Relating to IETF Documents
        (<a href="https://trustee.ietf.org/license-info">https://trustee.ietf.org/license-info</a>).






<span class="grey">Bjorklund, et al.            Standards Track                   [Page 20]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-21"></span>
<span class="grey"><a href="./rfc8342">RFC 8342</a>                          NMDA                        March 2018</span>


        This version of this YANG module is part of <a href="./rfc8342">RFC 8342</a>
        (<a href="https://www.rfc-editor.org/info/rfc8342">https://www.rfc-editor.org/info/rfc8342</a>); see the RFC itself
        for full legal notices.";

     revision 2018-02-14 {
       description
         "Initial revision.";
       reference
         "<a href="./rfc8342">RFC 8342</a>: Network Management Datastore Architecture (NMDA)";
     }

     /*
      * Identities
      */

     identity datastore {
       description
         "Abstract base identity for datastore identities.";
     }

     identity conventional {
       base datastore;
       description
         "Abstract base identity for conventional configuration
          datastores.";
     }

     identity running {
       base conventional;
       description
         "The running configuration datastore.";
     }

     identity candidate {
       base conventional;
       description
         "The candidate configuration datastore.";
     }

     identity startup {
       base conventional;
       description
         "The startup configuration datastore.";
     }







<span class="grey">Bjorklund, et al.            Standards Track                   [Page 21]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-22"></span>
<span class="grey"><a href="./rfc8342">RFC 8342</a>                          NMDA                        March 2018</span>


     identity intended {
       base conventional;
       description
         "The intended configuration datastore.";
     }

     identity dynamic {
       base datastore;
       description
         "Abstract base identity for dynamic configuration datastores.";
     }

     identity operational {
       base datastore;
       description
         "The operational state datastore.";
     }

     /*
      * Type definitions
      */

     typedef datastore-ref {
       type identityref {
         base datastore;
       }
       description
         "A datastore identity reference.";
     }
   }

   &lt;CODE ENDS&gt;



















<span class="grey">Bjorklund, et al.            Standards Track                   [Page 22]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-23"></span>
<span class="grey"><a href="./rfc8342">RFC 8342</a>                          NMDA                        March 2018</span>


   &lt;CODE BEGINS&gt; file "ietf-origin@2018-02-14.yang"

   module ietf-origin {
     yang-version 1.1;
     namespace "urn:ietf:params:xml:ns:yang:ietf-origin";
     prefix or;

     import ietf-yang-metadata {
       prefix md;
     }

     organization
       "IETF Network Modeling (NETMOD) Working Group";

     contact
       "WG Web:   &lt;<a href="https://datatracker.ietf.org/wg/netmod/">https://datatracker.ietf.org/wg/netmod/</a>&gt;

        WG List:  &lt;mailto:netmod@ietf.org&gt;

        Author:   Martin Bjorklund
                  &lt;mailto:mbj@tail-f.com&gt;

        Author:   Juergen Schoenwaelder
                  &lt;mailto:j.schoenwaelder@jacobs-university.de&gt;

        Author:   Phil Shafer
                  &lt;mailto:phil@juniper.net&gt;

        Author:   Kent Watsen
                  &lt;mailto:kwatsen@juniper.net&gt;

        Author:   Rob Wilton
                  &lt;rwilton@cisco.com&gt;";

     description
       "This YANG module defines an 'origin' metadata annotation and a
        set of identities for the origin value.

        Copyright (c) 2018 IETF Trust and the persons identified as
        authors of the code.  All rights reserved.

        Redistribution and use in source and binary forms, with or
        without modification, is permitted pursuant to, and subject to
        the license terms contained in, the Simplified BSD License set
        forth in <a href="#section-4">Section 4</a>.c of the IETF Trust's Legal Provisions
        Relating to IETF Documents
        (<a href="https://trustee.ietf.org/license-info">https://trustee.ietf.org/license-info</a>).




<span class="grey">Bjorklund, et al.            Standards Track                   [Page 23]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-24"></span>
<span class="grey"><a href="./rfc8342">RFC 8342</a>                          NMDA                        March 2018</span>


        This version of this YANG module is part of <a href="./rfc8342">RFC 8342</a>
        (<a href="https://www.rfc-editor.org/info/rfc8342">https://www.rfc-editor.org/info/rfc8342</a>); see the RFC itself
        for full legal notices.";

     revision 2018-02-14 {
       description
         "Initial revision.";
       reference
         "<a href="./rfc8342">RFC 8342</a>: Network Management Datastore Architecture (NMDA)";
     }

     /*
      * Identities
      */

     identity origin {
       description
         "Abstract base identity for the origin annotation.";
     }

     identity intended {
       base origin;
       description
         "Denotes configuration from the intended configuration
          datastore.";
     }

     identity dynamic {
       base origin;
       description
         "Denotes configuration from a dynamic configuration
          datastore.";
     }

     identity system {
       base origin;
       description
         "Denotes configuration originated by the system itself.

          Examples of system configuration include applied configuration
          for an always-existing loopback interface, or interface
          configuration that is auto-created due to the hardware
          currently present in the device.";
     }







<span class="grey">Bjorklund, et al.            Standards Track                   [Page 24]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-25"></span>
<span class="grey"><a href="./rfc8342">RFC 8342</a>                          NMDA                        March 2018</span>


     identity learned {
       base origin;
       description
         "Denotes configuration learned from protocol interactions with
          other devices, instead of via either the intended
          configuration datastore or any dynamic configuration
          datastore.

          Examples of protocols that provide learned configuration
          include link-layer negotiations, routing protocols, and
          DHCP.";
     }

     identity default {
       base origin;
       description
         "Denotes configuration that does not have a configured or
          learned value but has a default value in use.  Covers both
          values defined in a 'default' statement and values defined
          via an explanation in a 'description' statement.";
     }

     identity unknown {
       base origin;
       description
         "Denotes configuration for which the system cannot identify the
          origin.";
     }

     /*
      * Type definitions
      */

     typedef origin-ref {
       type identityref {
         base origin;
       }
       description
         "An origin identity reference.";
     }











<span class="grey">Bjorklund, et al.            Standards Track                   [Page 25]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-26"></span>
<span class="grey"><a href="./rfc8342">RFC 8342</a>                          NMDA                        March 2018</span>


     /*
      * Metadata annotations
      */

     md:annotation origin {
       type origin-ref;
       description
         "The 'origin' annotation can be present on any configuration
          data node in the operational state datastore.  It specifies
          from where the node originated.  If not specified for a given
          configuration data node, then the origin is the same as the
          origin of its parent node in the data tree.  The origin for
          any top-level configuration data nodes must be specified.";
     }
   }

   &lt;CODE ENDS&gt;

<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/8.%20%20IANA%20Considerations"></a><a class="selflink" href="#section-8" id="section-8">8</a>.  IANA Considerations</span>

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/8.1.%20%20Updates%20to%20the%20IETF%20XML%20Registry"></a><a class="selflink" href="#section-8.1" id="section-8.1">8.1</a>.  Updates to the IETF XML Registry</span>

   This document registers two URIs in the "IETF XML Registry"
   [<a href="./rfc3688" title='"The IETF XML Registry"'>RFC3688</a>].  Following the format in [<a href="./rfc3688" title='"The IETF XML Registry"'>RFC3688</a>], the following
   registrations have been made:

      URI: urn:ietf:params:xml:ns:yang:ietf-datastores
      Registrant Contact: The IESG.
      XML: N/A; the requested URI is an XML namespace.

      URI: urn:ietf:params:xml:ns:yang:ietf-origin
      Registrant Contact: The IESG.
      XML: N/A; the requested URI is an XML namespace.


















<span class="grey">Bjorklund, et al.            Standards Track                   [Page 26]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-27"></span>
<span class="grey"><a href="./rfc8342">RFC 8342</a>                          NMDA                        March 2018</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/8.2.%20%20Updates%20to%20the%20YANG%20Module%20Names%20Registry"></a><a class="selflink" href="#section-8.2" id="section-8.2">8.2</a>.  Updates to the YANG Module Names Registry</span>

   This document registers two YANG modules in the "YANG Module Names"
   registry [<a href="./rfc6020" title='"YANG - A Data Modeling Language for the Network Configuration Protocol (NETCONF)"'>RFC6020</a>].  Following the format in [<a href="./rfc6020" title='"YANG - A Data Modeling Language for the Network Configuration Protocol (NETCONF)"'>RFC6020</a>], the following
   registrations have been made:

      name:         ietf-datastores
      namespace:    urn:ietf:params:xml:ns:yang:ietf-datastores
      prefix:       ds
      reference:    <a href="./rfc8342">RFC 8342</a>

      name:         ietf-origin
      namespace:    urn:ietf:params:xml:ns:yang:ietf-origin
      prefix:       or
      reference:    <a href="./rfc8342">RFC 8342</a>

<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/9.%20%20Security%20Considerations"></a><a class="selflink" href="#section-9" id="section-9">9</a>.  Security Considerations</span>

   This document discusses an architectural model of datastores for
   network management using NETCONF/RESTCONF and YANG.  It has no
   security impact on the Internet.

   Although this document specifies several YANG modules, these modules
   only define identities and a metadata annotation; hence, the "YANG
   module security guidelines" [<a href="#ref-YANG-SEC" title='"YANG Security Guidelines"'>YANG-SEC</a>] do not apply.

   The origin metadata annotation exposes the origin of values in the
   applied configuration.  Origin information may provide hints that
   certain control-plane protocols are active on a device.  Since origin
   information is tied to applied configuration values, it is only
   accessible to clients that have the permissions to read the applied
   configuration values.  Security administrators should consider the
   sensitivity of origin information while defining access control
   rules.

















<span class="grey">Bjorklund, et al.            Standards Track                   [Page 27]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-28"></span>
<span class="grey"><a href="./rfc8342">RFC 8342</a>                          NMDA                        March 2018</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/10.%20%20References"></a><a class="selflink" href="#section-10" id="section-10">10</a>.  References</span>

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/10.1.%20%20Normative%20References"></a><a class="selflink" href="#section-10.1" id="section-10.1">10.1</a>.  Normative References</span>

   [<a id="ref-RFC2119">RFC2119</a>]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", <a href="https://www.rfc-editor.org/bcp/bcp14">BCP 14</a>, <a href="./rfc2119">RFC 2119</a>,
              DOI 10.17487/RFC2119, March 1997,
              &lt;<a href="https://www.rfc-editor.org/info/rfc2119">https://www.rfc-editor.org/info/rfc2119</a>&gt;.

   [<a id="ref-RFC6241">RFC6241</a>]  Enns, R., Ed., Bjorklund, M., Ed., Schoenwaelder, J., Ed.,
              and A. Bierman, Ed., "Network Configuration Protocol
              (NETCONF)", <a href="./rfc6241">RFC 6241</a>, DOI 10.17487/RFC6241, June 2011,
              &lt;<a href="https://www.rfc-editor.org/info/rfc6241">https://www.rfc-editor.org/info/rfc6241</a>&gt;.

   [<a id="ref-RFC7950">RFC7950</a>]  Bjorklund, M., Ed., "The YANG 1.1 Data Modeling Language",
              <a href="./rfc7950">RFC 7950</a>, DOI 10.17487/RFC7950, August 2016,
              &lt;<a href="https://www.rfc-editor.org/info/rfc7950">https://www.rfc-editor.org/info/rfc7950</a>&gt;.

   [<a id="ref-RFC7952">RFC7952</a>]  Lhotka, L., "Defining and Using Metadata with YANG",
              <a href="./rfc7952">RFC 7952</a>, DOI 10.17487/RFC7952, August 2016,
              &lt;<a href="https://www.rfc-editor.org/info/rfc7952">https://www.rfc-editor.org/info/rfc7952</a>&gt;.

   [<a id="ref-RFC8040">RFC8040</a>]  Bierman, A., Bjorklund, M., and K. Watsen, "RESTCONF
              Protocol", <a href="./rfc8040">RFC 8040</a>, DOI 10.17487/RFC8040, January 2017,
              &lt;<a href="https://www.rfc-editor.org/info/rfc8040">https://www.rfc-editor.org/info/rfc8040</a>&gt;.

   [<a id="ref-RFC8174">RFC8174</a>]  Leiba, B., "Ambiguity of Uppercase vs Lowercase in
              <a href="./rfc2119">RFC 2119</a> Key Words", <a href="https://www.rfc-editor.org/bcp/bcp14">BCP 14</a>, <a href="./rfc8174">RFC 8174</a>,
              DOI 10.17487/RFC8174, May 2017,
              &lt;<a href="https://www.rfc-editor.org/info/rfc8174">https://www.rfc-editor.org/info/rfc8174</a>&gt;.

   [<a id="ref-W3C.REC-xml-20081126">W3C.REC-xml-20081126</a>]
              Bray, T., Paoli, J., Sperberg-McQueen, M., Maler, E., and
              F. Yergeau, "Extensible Markup Language (XML) 1.0
              (Fifth Edition)", World Wide Web Consortium Recommendation
              REC-xml-20081126, November 2008,
              &lt;<a href="https://www.w3.org/TR/2008/REC-xml-20081126">https://www.w3.org/TR/2008/REC-xml-20081126</a>&gt;.














<span class="grey">Bjorklund, et al.            Standards Track                   [Page 28]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-29"></span>
<span class="grey"><a href="./rfc8342">RFC 8342</a>                          NMDA                        March 2018</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/10.2.%20%20Informative%20References"></a><a class="selflink" href="#section-10.2" id="section-10.2">10.2</a>.  Informative References</span>

   [<a id="ref-NETMOD-Operational">NETMOD-Operational</a>]
              Bjorklund, M. and L. Lhotka, "Operational Data in NETCONF
              and YANG", Work in Progress, <a href="./draft-bjorklund-netmod-operational-00">draft-bjorklund-netmod-</a>
              <a href="./draft-bjorklund-netmod-operational-00">operational-00</a>, October 2012.

   [<a id="ref-OpState-Enhance">OpState-Enhance</a>]
              Watsen, K., Bierman, A., Bjorklund, M., and J.
              Schoenwaelder, "Operational State Enhancements for YANG,
              NETCONF, and RESTCONF", Work in Progress, <a href="./draft-kwatsen-netmod-opstate-02">draft-kwatsen-</a>
              <a href="./draft-kwatsen-netmod-opstate-02">netmod-opstate-02</a>, February 2016.

   [<a id="ref-OpState-Modeling">OpState-Modeling</a>]
              Shakir, R., Shaikh, A., and M. Hines, "Consistent Modeling
              of Operational State Data in YANG", Work in Progress,
              <a href="./draft-openconfig-netmod-opstate-01">draft-openconfig-netmod-opstate-01</a>, July 2015.

   [<a id="ref-OpState-Reqs">OpState-Reqs</a>]
              Watsen, K. and T. Nadeau, "Terminology and Requirements
              for Enhanced Handling of Operational State", Work in
              Progress, <a href="./draft-ietf-netmod-opstate-reqs-04">draft-ietf-netmod-opstate-reqs-04</a>, January 2016.

   [<a id="ref-RFC3688">RFC3688</a>]  Mealling, M., "The IETF XML Registry", <a href="https://www.rfc-editor.org/bcp/bcp81">BCP 81</a>, <a href="./rfc3688">RFC 3688</a>,
              DOI 10.17487/RFC3688, January 2004,
              &lt;<a href="https://www.rfc-editor.org/info/rfc3688">https://www.rfc-editor.org/info/rfc3688</a>&gt;.

   [<a id="ref-RFC6020">RFC6020</a>]  Bjorklund, M., Ed., "YANG - A Data Modeling Language for
              the Network Configuration Protocol (NETCONF)", <a href="./rfc6020">RFC 6020</a>,
              DOI 10.17487/RFC6020, October 2010,
              &lt;<a href="https://www.rfc-editor.org/info/rfc6020">https://www.rfc-editor.org/info/rfc6020</a>&gt;.

   [<a id="ref-RFC6244">RFC6244</a>]  Shafer, P., "An Architecture for Network Management Using
              NETCONF and YANG", <a href="./rfc6244">RFC 6244</a>, DOI 10.17487/RFC6244,
              June 2011, &lt;<a href="https://www.rfc-editor.org/info/rfc6244">https://www.rfc-editor.org/info/rfc6244</a>&gt;.

   [<a id="ref-RFC8343">RFC8343</a>]  Bjorklund, M., "A YANG Data Model for Interface
              Management", <a href="./rfc8343">RFC 8343</a>, DOI 10.17487/RFC8343, March 2018,
              &lt;<a href="https://www.rfc-editor.org/info/rfc8343">https://www.rfc-editor.org/info/rfc8343</a>&gt;.

   [<a id="ref-RFC8344">RFC8344</a>]  Bjorklund, M., "A YANG Data Model for IP Management",
              <a href="./rfc8344">RFC 8344</a>, DOI 10.17487/RFC8344, March 2018,
              &lt;<a href="https://www.rfc-editor.org/info/rfc8344">https://www.rfc-editor.org/info/rfc8344</a>&gt;.








<span class="grey">Bjorklund, et al.            Standards Track                   [Page 29]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-30"></span>
<span class="grey"><a href="./rfc8342">RFC 8342</a>                          NMDA                        March 2018</span>


   [<a id="ref-With-config-state">With-config-state</a>]
              Wilton, R., ""With-config-state" Capability for
              NETCONF/RESTCONF", Work in Progress, <a href="./draft-wilton-netmod-opstate-yang-02">draft-wilton-netmod-</a>
              <a href="./draft-wilton-netmod-opstate-yang-02">opstate-yang-02</a>, December 2015.

   [<a id="ref-YANG-SEC">YANG-SEC</a>] IETF, "YANG Security Guidelines", &lt;<a href="https://trac.ietf.org/trac/ops/wiki/yang-security-guidelines">https://trac.ietf.org/</a>
              <a href="https://trac.ietf.org/trac/ops/wiki/yang-security-guidelines">trac/ops/wiki/yang-security-guidelines</a>&gt;.












































<span class="grey">Bjorklund, et al.            Standards Track                   [Page 30]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-31"></span>
<span class="grey"><a href="./rfc8342">RFC 8342</a>                          NMDA                        March 2018</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/Appendix%20A.%20%20Guidelines%20for%20Defining%20Datastores"></a><a class="selflink" href="#appendix-A" id="appendix-A">Appendix A</a>.  Guidelines for Defining Datastores</span>

   The definition of a new datastore in this architecture should be
   provided in a document (e.g., an RFC) purposed for defining the
   datastore.  When it makes sense, more than one datastore may be
   defined in the same document (e.g., when the datastores are logically
   connected).  Each datastore's definition should address the points
   specified in the subsections below.

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/A.1.%20%20Define%20Which%20YANG%20Modules%20Can%20Be%20Used%20in%20the%20Datastore"></a><a class="selflink" href="#appendix-A.1" id="appendix-A.1">A.1</a>.  Define Which YANG Modules Can Be Used in the Datastore</span>

   Not all YANG modules may be used in all datastores.  Some datastores
   may constrain which data models can be used in them.  If it is
   desirable that a subset of all modules can be targeted to the
   datastore, then the documentation defining the datastore must
   indicate this.

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/A.2.%20%20Define%20Which%20Subset%20of%20YANG-Modeled%20Data%20Applies"></a><a class="selflink" href="#appendix-A.2" id="appendix-A.2">A.2</a>.  Define Which Subset of YANG-Modeled Data Applies</span>

   By default, the data in a datastore is modeled by all YANG statements
   in the available YANG modules.  However, it is possible to specify
   criteria that YANG statements must satisfy in order to be present in
   a datastore.  For instance, maybe only "config true" nodes, or
   "config false" nodes that also have a specific YANG extension, are
   present in the datastore.

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/A.3.%20%20Define%20How%20Data%20Is%20Actualized"></a><a class="selflink" href="#appendix-A.3" id="appendix-A.3">A.3</a>.  Define How Data Is Actualized</span>

   The new datastore must specify how it interacts with other
   datastores.

   For example, the diagram in <a href="#section-5">Section 5</a> depicts dynamic configuration
   datastores feeding into &lt;operational&gt;.  How this interaction occurs
   has to be defined by the particular dynamic configuration datastores.
   In some cases, it may occur implicitly, as soon as the data is put
   into the dynamic configuration datastore, while in other cases an
   explicit action (e.g., an RPC) may be required to trigger the
   application of the datastore's data.

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/A.4.%20%20Define%20Which%20Protocols%20Can%20Be%20Used"></a><a class="selflink" href="#appendix-A.4" id="appendix-A.4">A.4</a>.  Define Which Protocols Can Be Used</span>

   By default, it is assumed that both the NETCONF and RESTCONF
   protocols can be used to interact with a datastore.  However, it may
   be that only a specific protocol can be used (e.g., Forwarding and
   Control Element Separation (ForCES)) or that a subset of all protocol
   operations or capabilities are available (e.g., no locking or no
   XPath-based filtering).




<span class="grey">Bjorklund, et al.            Standards Track                   [Page 31]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-32"></span>
<span class="grey"><a href="./rfc8342">RFC 8342</a>                          NMDA                        March 2018</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/A.5.%20%20Define%20YANG%20Identities%20for%20the%20Datastore"></a><a class="selflink" href="#appendix-A.5" id="appendix-A.5">A.5</a>.  Define YANG Identities for the Datastore</span>

   The datastore must be defined with a YANG identity that uses the
   "ds:datastore" identity, or one of its derived identities, as its
   base.  This identity is necessary, so that the datastore can be
   referenced in protocol operations (e.g., &lt;get-data&gt;).

   The datastore may also be defined with an identity that uses the
   "or:origin" identity, or one of its derived identities, as its base.
   This identity is needed if the datastore interacts with
   &lt;operational&gt;, so that data originating from the datastore can be
   identified as such via the "origin" metadata attribute defined in
   <a href="#section-7">Section 7</a>.

   An example of these guidelines in use is provided in <a href="#appendix-B">Appendix B</a>.

<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/Appendix%20B.%20%20Example%20of%20an%20Ephemeral%20Dynamic%20Configuration%20Datastore"></a><a class="selflink" href="#appendix-B" id="appendix-B">Appendix B</a>.  Example of an Ephemeral Dynamic Configuration Datastore</span>

   This section defines documentation for an example dynamic
   configuration datastore using the guidelines provided in <a href="#appendix-A">Appendix A</a>.
   For brevity, only a terse example is provided; it is expected that a
   standalone RFC would be written when this type of scenario is fully
   considered.

   This example defines a dynamic configuration datastore called
   "ephemeral", which is loosely modeled after the work done in the I2RS
   Working Group.

   +--------------------+----------------------------------------------+
   | Name               | Value                                        |
   +--------------------+----------------------------------------------+
   | Name               | ephemeral                                    |
   |                    |                                              |
   | YANG modules       | all (default)                                |
   |                    |                                              |
   | YANG nodes         | all "config true" data nodes                 |
   |                    |                                              |
   | How applied        | changes automatically propagated to          |
   |                    | &lt;operational&gt;                                |
   |                    |                                              |
   | Protocols          | NETCONF/RESTCONF (default)                   |
   |                    |                                              |
   | Defining YANG      | "example-ds-ephemeral"                       |
   | module             |                                              |
   +--------------------+----------------------------------------------+

              Properties of the Example "ephemeral" Datastore




<span class="grey">Bjorklund, et al.            Standards Track                   [Page 32]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-33"></span>
<span class="grey"><a href="./rfc8342">RFC 8342</a>                          NMDA                        March 2018</span>


   module example-ds-ephemeral {
     yang-version 1.1;
     namespace "urn:example:ds-ephemeral";
     prefix eph;

     import ietf-datastores {
       prefix ds;
     }
     import ietf-origin {
       prefix or;
     }

     // datastore identity
     identity ds-ephemeral {
       base ds:dynamic;
       description
         "The ephemeral dynamic configuration datastore.";
     }

     // origin identity
     identity or-ephemeral {
       base or:dynamic;
       description
         "Denotes data from the ephemeral dynamic configuration
          datastore.";
     }
   }

<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/Appendix%20C.%20%20Example%20Data"></a><a class="selflink" href="#appendix-C" id="appendix-C">Appendix C</a>.  Example Data</span>

   The use of datastores is complex, and many of the subtle effects are
   more easily presented using examples.  This section presents a series
   of example data models with some sample contents of the various
   datastores.

   The XML [<a href="#ref-W3C.REC-xml-20081126">W3C.REC-xml-20081126</a>] snippets that follow are provided as
   examples only.














<span class="grey">Bjorklund, et al.            Standards Track                   [Page 33]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-34"></span>
<span class="grey"><a href="./rfc8342">RFC 8342</a>                          NMDA                        March 2018</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/C.1.%20%20System%20Example"></a><a class="selflink" href="#appendix-C.1" id="appendix-C.1">C.1</a>.  System Example</span>

   In this example, the following fictional module is used:

   module example-system {
     yang-version 1.1;
     namespace urn:example:system;
     prefix sys;

     import ietf-inet-types {
       prefix inet;
     }

     container system {
       leaf hostname {
         type string;
       }

       list interface {
         key name;

         leaf name {
           type string;
         }

         container auto-negotiation {
           leaf enabled {
             type boolean;
             default true;
           }
           leaf speed {
             type uint32;
             units mbps;
             description
               "The advertised speed, in Mbps.";
           }
         }

         leaf speed {
           type uint32;
           units mbps;
           config false;
           description
             "The speed of the interface, in Mbps.";
         }






<span class="grey">Bjorklund, et al.            Standards Track                   [Page 34]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-35"></span>
<span class="grey"><a href="./rfc8342">RFC 8342</a>                          NMDA                        March 2018</span>


         list address {
           key ip;

           leaf ip {
             type inet:ip-address;
           }
           leaf prefix-length {
             type uint8;
           }
         }
       }
     }
   }

   The operator has configured the hostname and two interfaces, so the
   contents of &lt;intended&gt; are:

   &lt;system xmlns="urn:example:system"&gt;

     &lt;hostname&gt;foo.example.com&lt;/hostname&gt;

     &lt;interface&gt;
       &lt;name&gt;eth0&lt;/name&gt;
       &lt;auto-negotiation&gt;
         &lt;speed&gt;1000&lt;/speed&gt;
       &lt;/auto-negotiation&gt;
       &lt;address&gt;
         &lt;ip&gt;2001:db8::10&lt;/ip&gt;
         &lt;prefix-length&gt;64&lt;/prefix-length&gt;
       &lt;/address&gt;
     &lt;/interface&gt;

     &lt;interface&gt;
       &lt;name&gt;eth1&lt;/name&gt;
       &lt;address&gt;
         &lt;ip&gt;2001:db8::20&lt;/ip&gt;
         &lt;prefix-length&gt;64&lt;/prefix-length&gt;
       &lt;/address&gt;
     &lt;/interface&gt;

   &lt;/system&gt;

   The system has detected that the hardware for one of the configured
   interfaces ("eth1") is not yet present, so the configuration for that
   interface is not applied.  Further, the system has received a
   hostname and an additional IP address for "eth0" over DHCP.  In
   addition to filling in the default value for the auto-negotiation
   enabled leaf, a loopback interface entry is also automatically



<span class="grey">Bjorklund, et al.            Standards Track                   [Page 35]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-36"></span>
<span class="grey"><a href="./rfc8342">RFC 8342</a>                          NMDA                        March 2018</span>


   instantiated by the system.  All of this is reflected in
   &lt;operational&gt;.  Note how the "origin" metadata attribute for several
   "config true" data nodes is inherited from their parent data nodes.

   &lt;system
       xmlns="urn:example:system"
       xmlns:or="urn:ietf:params:xml:ns:yang:ietf-origin"&gt;

     &lt;hostname or:origin="or:learned"&gt;bar.example.com&lt;/hostname&gt;

     &lt;interface or:origin="or:intended"&gt;
       &lt;name&gt;eth0&lt;/name&gt;
       &lt;auto-negotiation&gt;
         &lt;enabled or:origin="or:default"&gt;true&lt;/enabled&gt;
         &lt;speed&gt;1000&lt;/speed&gt;
       &lt;/auto-negotiation&gt;
       &lt;speed&gt;100&lt;/speed&gt;
       &lt;address&gt;
         &lt;ip&gt;2001:db8::10&lt;/ip&gt;
         &lt;prefix-length&gt;64&lt;/prefix-length&gt;
       &lt;/address&gt;
       &lt;address or:origin="or:learned"&gt;
         &lt;ip&gt;2001:db8::1:100&lt;/ip&gt;
         &lt;prefix-length&gt;64&lt;/prefix-length&gt;
       &lt;/address&gt;
     &lt;/interface&gt;

     &lt;interface or:origin="or:system"&gt;
       &lt;name&gt;lo0&lt;/name&gt;
       &lt;address&gt;
         &lt;ip&gt;::1&lt;/ip&gt;
         &lt;prefix-length&gt;128&lt;/prefix-length&gt;
       &lt;/address&gt;
     &lt;/interface&gt;

   &lt;/system&gt;















<span class="grey">Bjorklund, et al.            Standards Track                   [Page 36]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-37"></span>
<span class="grey"><a href="./rfc8342">RFC 8342</a>                          NMDA                        March 2018</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/C.2.%20%20BGP%20Example"></a><a class="selflink" href="#appendix-C.2" id="appendix-C.2">C.2</a>.  BGP Example</span>

   Consider the following fragment of a fictional BGP module:

       container bgp {
         leaf local-as {
           type uint32;
         }
         leaf peer-as {
           type uint32;
         }
         list peer {
           key name;
           leaf name {
             type inet:ip-address;
           }
           leaf local-as {
             type uint32;
             description
               "... Defaults to ../local-as.";
           }
           leaf peer-as {
             type uint32;
             description
               "... Defaults to ../peer-as.";
           }
           leaf local-port {
             type inet:port;
           }
           leaf remote-port {
             type inet:port;
             default 179;
           }
           leaf state {
             config false;
             type enumeration {
               enum init;
               enum established;
               enum closing;
             }
           }
         }
       }

   In this example model, both bgp/peer/local-as and bgp/peer/peer-as
   have complex hierarchical values, allowing the user to specify
   default values for all peers in a single location.




<span class="grey">Bjorklund, et al.            Standards Track                   [Page 37]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-38"></span>
<span class="grey"><a href="./rfc8342">RFC 8342</a>                          NMDA                        March 2018</span>


   The model also follows the pattern of fully integrating state
   ("config false") nodes with configuration ("config true") nodes.
   There is no separate "bgp-state" hierarchy, with the accompanying
   repetition of containment and naming nodes.  This makes the model
   simpler and more readable.

<span class="h4"><a class="dashAnchor" name="//apple_ref/cpp/Section/C.2.1.%20%20Datastores"></a><a class="selflink" href="#appendix-C.2.1" id="appendix-C.2.1">C.2.1</a>.  Datastores</span>

   Each datastore represents differing views of these nodes.  &lt;running&gt;
   will hold the configuration provided by the operator -- for example,
   a single BGP peer.  &lt;intended&gt; will conceptually hold the data as
   validated, after the removal of data not intended for validation and
   after any local template mechanisms are performed.  &lt;operational&gt;
   will show data from &lt;intended&gt; as well as any "config false" nodes.

<span class="h4"><a class="dashAnchor" name="//apple_ref/cpp/Section/C.2.2.%20%20Adding%20a%20Peer"></a><a class="selflink" href="#appendix-C.2.2" id="appendix-C.2.2">C.2.2</a>.  Adding a Peer</span>

   If the user configures a single BGP peer, then that peer will be
   visible in both &lt;running&gt; and &lt;intended&gt;.  It may also appear in
   &lt;candidate&gt; if the server supports the candidate configuration
   datastore.  Retrieving the peer will return only the user-specified
   values.

   No time delay should exist between the appearance of the peer in
   &lt;running&gt; and &lt;intended&gt;.

   In this scenario, we've added the following to &lt;running&gt;:

     &lt;bgp&gt;
       &lt;local-as&gt;64501&lt;/local-as&gt;
       &lt;peer-as&gt;64502&lt;/peer-as&gt;
       &lt;peer&gt;
         &lt;name&gt;2001:db8::2:3&lt;/name&gt;
       &lt;/peer&gt;
     &lt;/bgp&gt;

<span class="h5"><a class="dashAnchor" name="//apple_ref/cpp/Section/C.2.2.1.%20%20%3Coperational%3E"></a><a class="selflink" href="#appendix-C.2.2.1" id="appendix-C.2.2.1">C.2.2.1</a>.  &lt;operational&gt;</span>

   The operational datastore will contain the fully expanded peer data,
   including "config false" nodes.  In our example, this means that the
   "state" node will appear.

   In addition, &lt;operational&gt; will contain the "currently in use" values
   for all nodes.  This means that local-as and peer-as will be
   populated even if they are not given values in &lt;intended&gt;.  The value
   of bgp/local-as will be used if bgp/peer/local-as is not provided;
   bgp/peer-as and bgp/peer/peer-as will have the same relationship.  In




<span class="grey">Bjorklund, et al.            Standards Track                   [Page 38]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-39"></span>
<span class="grey"><a href="./rfc8342">RFC 8342</a>                          NMDA                        March 2018</span>


   the operational view, this means that every peer will have values for
   their local-as and peer-as, even if those values are not explicitly
   configured but are provided by bgp/local-as and bgp/peer-as.

   Each BGP peer has a TCP connection associated with it, using the
   values of local-port and remote-port from &lt;intended&gt;.  If those
   values are not supplied, the system will select values.  When the
   connection is established, &lt;operational&gt; will contain the current
   values for the local-port and remote-port nodes regardless of the
   origin.  If the system has chosen the values, the "origin" attribute
   will be set to "system".  Before the connection is established, one
   or both of the nodes may not appear, since the system may not yet
   have their values.

     &lt;bgp xmlns:or="urn:ietf:params:xml:ns:yang:ietf-origin"
          or:origin="or:intended"&gt;
       &lt;local-as&gt;64501&lt;/local-as&gt;
       &lt;peer-as&gt;64502&lt;/peer-as&gt;
       &lt;peer&gt;
         &lt;name&gt;2001:db8::2:3&lt;/name&gt;
         &lt;local-as or:origin="or:default"&gt;64501&lt;/local-as&gt;
         &lt;peer-as or:origin="or:default"&gt;64502&lt;/peer-as&gt;
         &lt;local-port or:origin="or:system"&gt;60794&lt;/local-port&gt;
         &lt;remote-port or:origin="or:default"&gt;179&lt;/remote-port&gt;
         &lt;state&gt;established&lt;/state&gt;
       &lt;/peer&gt;
     &lt;/bgp&gt;

<span class="h4"><a class="dashAnchor" name="//apple_ref/cpp/Section/C.2.3.%20%20Removing%20a%20Peer"></a><a class="selflink" href="#appendix-C.2.3" id="appendix-C.2.3">C.2.3</a>.  Removing a Peer</span>

   Changes to configuration may take time to percolate through the
   various software components involved.  During this period, it is
   imperative to continue to give an accurate view of the working of the
   device.  &lt;operational&gt; will contain nodes for both the previous and
   current configuration, as closely as possible tracking the current
   operation of the device.

   Consider the scenario where a client removes a BGP peer.  When a peer
   is removed, the operational state will continue to reflect the
   existence of that peer until the peer's resources are released,
   including closing the peer's connection.  During this period, the
   current data values will continue to be visible in &lt;operational&gt;,
   with the "origin" attribute set to indicate the origin of the
   original data.







<span class="grey">Bjorklund, et al.            Standards Track                   [Page 39]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-40"></span>
<span class="grey"><a href="./rfc8342">RFC 8342</a>                          NMDA                        March 2018</span>


     &lt;bgp xmlns:or="urn:ietf:params:xml:ns:yang:ietf-origin"
          or:origin="or:intended"&gt;
       &lt;local-as&gt;64501&lt;/local-as&gt;
       &lt;peer-as&gt;64502&lt;/peer-as&gt;
       &lt;peer&gt;
         &lt;name&gt;2001:db8::2:3&lt;/name&gt;
         &lt;local-as or:origin="or:default"&gt;64501&lt;/local-as&gt;
         &lt;peer-as or:origin="or:default"&gt;64502&lt;/peer-as&gt;
         &lt;local-port or:origin="or:system"&gt;60794&lt;/local-port&gt;
         &lt;remote-port or:origin="or:default"&gt;179&lt;/remote-port&gt;
         &lt;state&gt;closing&lt;/state&gt;
       &lt;/peer&gt;
     &lt;/bgp&gt;

   Once resources are released and the connection is closed, the peer's
   data is removed from &lt;operational&gt;.

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/C.3.%20%20Interface%20Example"></a><a class="selflink" href="#appendix-C.3" id="appendix-C.3">C.3</a>.  Interface Example</span>

   In this section, we will use this simple interface data model:

     container interfaces {
       list interface {
         key name;
         leaf name {
           type string;
         }
         leaf description {
           type string;
         }
         leaf mtu {
           type uint16;
         }
         leaf-list ip-address {
           type inet:ip-address;
         }
       }
     }













<span class="grey">Bjorklund, et al.            Standards Track                   [Page 40]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-41"></span>
<span class="grey"><a href="./rfc8342">RFC 8342</a>                          NMDA                        March 2018</span>


<span class="h4"><a class="dashAnchor" name="//apple_ref/cpp/Section/C.3.1.%20%20Pre-provisioned%20Interfaces"></a><a class="selflink" href="#appendix-C.3.1" id="appendix-C.3.1">C.3.1</a>.  Pre-provisioned Interfaces</span>

   One common issue in networking devices is the support of Field
   Replaceable Units (FRUs) that can be inserted and removed from the
   device without requiring a reboot or interfering with normal
   operation.  These FRUs are typically interface cards, and the devices
   support pre-provisioning of these interfaces.

   If a client creates an interface "et-0/0/0" but the interface does
   not physically exist at this point, then &lt;intended&gt; might contain the
   following:

     &lt;interfaces&gt;
       &lt;interface&gt;
         &lt;name&gt;et-0/0/0&lt;/name&gt;
         &lt;description&gt;Test interface&lt;/description&gt;
       &lt;/interface&gt;
     &lt;/interfaces&gt;

   Since the interface does not exist, this data does not appear in
   &lt;operational&gt;.

   When a FRU containing this interface is inserted, the system will
   detect it and process the associated configuration.  &lt;operational&gt;
   will contain the data from &lt;intended&gt;, as well as nodes added by the
   system, such as the current value of the interface's MTU.

     &lt;interfaces xmlns:or="urn:ietf:params:xml:ns:yang:ietf-origin"
                 or:origin="or:intended"&gt;
       &lt;interface&gt;
         &lt;name&gt;et-0/0/0&lt;/name&gt;
         &lt;description&gt;Test interface&lt;/description&gt;
         &lt;mtu or:origin="or:system"&gt;1500&lt;/mtu&gt;
       &lt;/interface&gt;
     &lt;/interfaces&gt;

   If the FRU is removed, the interface data is removed from
   &lt;operational&gt;.













<span class="grey">Bjorklund, et al.            Standards Track                   [Page 41]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-42"></span>
<span class="grey"><a href="./rfc8342">RFC 8342</a>                          NMDA                        March 2018</span>


<span class="h4"><a class="dashAnchor" name="//apple_ref/cpp/Section/C.3.2.%20%20System-Provided%20Interface"></a><a class="selflink" href="#appendix-C.3.2" id="appendix-C.3.2">C.3.2</a>.  System-Provided Interface</span>

   Imagine that the system provides a loopback interface (named "lo0")
   with a default IPv4 address of "127.0.0.1" and a default IPv6 address
   of "::1".  The system will only provide configuration for this
   interface if there is no data for it in &lt;intended&gt;.

   When no configuration for "lo0" appears in &lt;intended&gt;, &lt;operational&gt;
   will show the system-provided data:

     &lt;interfaces xmlns:or="urn:ietf:params:xml:ns:yang:ietf-origin"
                 or:origin="or:intended"&gt;
       &lt;interface or:origin="or:system"&gt;
         &lt;name&gt;lo0&lt;/name&gt;
         &lt;ip-address&gt;127.0.0.1&lt;/ip-address&gt;
         &lt;ip-address&gt;::1&lt;/ip-address&gt;
       &lt;/interface&gt;
     &lt;/interfaces&gt;

   When configuration for "lo0" does appear in &lt;intended&gt;, &lt;operational&gt;
   will show that data with the origin set to "intended".  If the
   "ip-address" is not provided, then the system-provided value will
   appear as follows:

     &lt;interfaces xmlns:or="urn:ietf:params:xml:ns:yang:ietf-origin"
                 or:origin="or:intended"&gt;
       &lt;interface&gt;
         &lt;name&gt;lo0&lt;/name&gt;
         &lt;description&gt;loopback&lt;/description&gt;
         &lt;ip-address or:origin="or:system"&gt;127.0.0.1&lt;/ip-address&gt;
         &lt;ip-address&gt;::1&lt;/ip-address&gt;
       &lt;/interface&gt;
     &lt;/interfaces&gt;


















<span class="grey">Bjorklund, et al.            Standards Track                   [Page 42]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-43"></span>
<span class="grey"><a href="./rfc8342">RFC 8342</a>                          NMDA                        March 2018</span>


Acknowledgments

   This document grew out of many discussions that took place since
   2010.  Several documents ([<a href="#ref-NETMOD-Operational">NETMOD-Operational</a>] [<a href="#ref-With-config-state">With-config-state</a>]
   [<a href="#ref-OpState-Reqs">OpState-Reqs</a>] [<a href="#ref-OpState-Enhance">OpState-Enhance</a>] [<a href="#ref-OpState-Modeling">OpState-Modeling</a>], as well as
   [<a href="./rfc6244" title='"An Architecture for Network Management Using NETCONF and YANG"'>RFC6244</a>]), touched on some of the problems of the original datastore
   model.  The following people were authors of these works in progress
   or were otherwise actively involved in the discussions that led to
   this document:

   o  Lou Berger, LabN Consulting, L.L.C., &lt;lberger@labn.net&gt;

   o  Andy Bierman, YumaWorks, &lt;andy@yumaworks.com&gt;

   o  Marcus Hines, Google, &lt;hines@google.com&gt;

   o  Christian Hopps, Deutsche Telekom, &lt;chopps@chopps.org&gt;

   o  Balazs Lengyel, Ericsson, &lt;balazs.lengyel@ericsson.com&gt;

   o  Ladislav Lhotka, CZ.NIC, &lt;lhotka@nic.cz&gt;

   o  Acee Lindem, Cisco Systems, &lt;acee@cisco.com&gt;

   o  Thomas Nadeau, Brocade Networks, &lt;tnadeau@lucidvision.com&gt;

   o  Tom Petch, Engineering Networks Ltd, &lt;ietfc@btconnect.com&gt;

   o  Anees Shaikh, Google, &lt;aashaikh@google.com&gt;

   o  Rob Shakir, Google, &lt;robjs@google.com&gt;

   o  Jason Sterne, Nokia, &lt;jason.sterne@nokia.com&gt;

   Juergen Schoenwaelder was partly funded by Flamingo, a Network of
   Excellence project (ICT-318488) supported by the European Commission
   under its Seventh Framework Programme.














<span class="grey">Bjorklund, et al.            Standards Track                   [Page 43]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-44"></span>
<span class="grey"><a href="./rfc8342">RFC 8342</a>                          NMDA                        March 2018</span>


Authors' Addresses

   Martin Bjorklund
   Tail-f Systems

   Email: mbj@tail-f.com


   Juergen Schoenwaelder
   Jacobs University

   Email: j.schoenwaelder@jacobs-university.de


   Phil Shafer
   Juniper Networks

   Email: phil@juniper.net


   Kent Watsen
   Juniper Networks

   Email: kwatsen@juniper.net


   Robert Wilton
   Cisco Systems

   Email: rwilton@cisco.com





















Bjorklund, et al.            Standards Track                   [Page 44]
</pre>
</body></html>