<html><head></head><body><pre>Internet Engineering Task Force (IETF)                       B. Campbell
Request for Comments: 8583                               S. Donovan, Ed.
Category: Standards Track                                         Oracle
ISSN: 2070-1721                                              JJ. Trottin
                                                                   Nokia
                                                             August 2019


                  <span class="h1">Diameter Load Information Conveyance</span>

Abstract

   <a href="./rfc7068">RFC 7068</a> describes requirements for Overload Control in Diameter.
   This includes a requirement to allow Diameter nodes to send "load"
   information, even when the node is not overloaded.  The base solution
   defined in <a href="./rfc7683">RFC 7683</a> (Diameter Overload Information Conveyance (DOIC))
   describes a mechanism meeting most of the requirements but does not
   currently include the ability to send load information.  This
   document defines a mechanism for the conveying of Diameter load
   information.

Status of This Memo

   This is an Internet Standards Track document.

   This document is a product of the Internet Engineering Task Force
   (IETF).  It represents the consensus of the IETF community.  It has
   received public review and has been approved for publication by the
   Internet Engineering Steering Group (IESG).  Further information on
   Internet Standards is available in <a href="./rfc7841#section-2">SectionÂ 2 of RFC 7841</a>.

   Information about the current status of this document, any errata,
   and how to provide feedback on it may be obtained at
   <a href="https://www.rfc-editor.org/info/rfc8583">https://www.rfc-editor.org/info/rfc8583</a>.

















<span class="grey">Campbell, et al.             Standards Track                    [Page 1]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-2"></span>
<span class="grey"><a href="./rfc8583">RFC 8583</a>                      Diameter Load                  August 2019</span>


Copyright Notice

   Copyright (c) 2019 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to <a href="https://www.rfc-editor.org/bcp/bcp78">BCP 78</a> and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (<a href="https://trustee.ietf.org/license-info">https://trustee.ietf.org/license-info</a>) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.





































<span class="grey">Campbell, et al.             Standards Track                    [Page 2]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-3"></span>
<span class="grey"><a href="./rfc8583">RFC 8583</a>                      Diameter Load                  August 2019</span>


Table of Contents

   <a href="#section-1">1</a>.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   <a href="#page-4">4</a>
   <a href="#section-2">2</a>.  Terminology and Abbreviations . . . . . . . . . . . . . . . .   <a href="#page-4">4</a>
   <a href="#section-3">3</a>.  Conventions Used in This Document . . . . . . . . . . . . . .   <a href="#page-5">5</a>
   <a href="#section-4">4</a>.  Background  . . . . . . . . . . . . . . . . . . . . . . . . .   <a href="#page-5">5</a>
     <a href="#section-4.1">4.1</a>.  Differences between Load and Overload Information . . . .   <a href="#page-5">5</a>
     <a href="#section-4.2">4.2</a>.  How Is Load Information Used? . . . . . . . . . . . . . .   <a href="#page-6">6</a>
   <a href="#section-5">5</a>.  Solution Overview . . . . . . . . . . . . . . . . . . . . . .   <a href="#page-7">7</a>
     <a href="#section-5.1">5.1</a>.  Theory of Operation . . . . . . . . . . . . . . . . . . .   <a href="#page-9">9</a>
   <a href="#section-6">6</a>.  Load-Mechanism Procedures . . . . . . . . . . . . . . . . . .  <a href="#page-11">11</a>
     <a href="#section-6.1">6.1</a>.  Reporting-Node Behavior . . . . . . . . . . . . . . . . .  <a href="#page-11">11</a>
       <a href="#section-6.1.1">6.1.1</a>.  Endpoint Reporting-Node Behavior  . . . . . . . . . .  <a href="#page-11">11</a>
       <a href="#section-6.1.2">6.1.2</a>.  Agent Reporting-Node Behavior . . . . . . . . . . . .  <a href="#page-12">12</a>
     <a href="#section-6.2">6.2</a>.  Reacting-Node Behavior  . . . . . . . . . . . . . . . . .  <a href="#page-13">13</a>
     <a href="#section-6.3">6.3</a>.  Extensibility . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-14">14</a>
     <a href="#section-6.4">6.4</a>.  Addition and Removal of Nodes . . . . . . . . . . . . . .  <a href="#page-14">14</a>
   <a href="#section-7">7</a>.  Attribute-Value Pairs . . . . . . . . . . . . . . . . . . . .  <a href="#page-15">15</a>
     <a href="#section-7.1">7.1</a>.  Load AVP  . . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-15">15</a>
     <a href="#section-7.2">7.2</a>.  Load-Type AVP . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-15">15</a>
     <a href="#section-7.3">7.3</a>.  Load-Value AVP  . . . . . . . . . . . . . . . . . . . . .  <a href="#page-15">15</a>
     <a href="#section-7.4">7.4</a>.  SourceID AVP  . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-15">15</a>
     <a href="#section-7.5">7.5</a>.  Attribute-Value Pair Flag Rules . . . . . . . . . . . . .  <a href="#page-16">16</a>
   <a href="#section-8">8</a>.  Security Considerations . . . . . . . . . . . . . . . . . . .  <a href="#page-16">16</a>
   <a href="#section-9">9</a>.  IANA Considerations . . . . . . . . . . . . . . . . . . . . .  <a href="#page-16">16</a>
   <a href="#section-10">10</a>. References  . . . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-17">17</a>
     <a href="#section-10.1">10.1</a>.  Normative References . . . . . . . . . . . . . . . . . .  <a href="#page-17">17</a>
     <a href="#section-10.2">10.2</a>.  Informative References . . . . . . . . . . . . . . . . .  <a href="#page-17">17</a>
   <a href="#appendix-A">Appendix A</a>.  Topology Scenarios . . . . . . . . . . . . . . . . .  <a href="#page-18">18</a>
     <a href="#appendix-A.1">A.1</a>.  No Agent  . . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-18">18</a>
     <a href="#appendix-A.2">A.2</a>.  Single Agent  . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-18">18</a>
     <a href="#appendix-A.3">A.3</a>.  Multiple Agents . . . . . . . . . . . . . . . . . . . . .  <a href="#page-19">19</a>
     <a href="#appendix-A.4">A.4</a>.  Linked Agents . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-19">19</a>
     <a href="#appendix-A.5">A.5</a>.  Shared Server Pools . . . . . . . . . . . . . . . . . . .  <a href="#page-21">21</a>
     <a href="#appendix-A.6">A.6</a>.  Agent Chains  . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-21">21</a>
     <a href="#appendix-A.7">A.7</a>.  Fully-Meshed Layers . . . . . . . . . . . . . . . . . . .  <a href="#page-22">22</a>
     <a href="#appendix-A.8">A.8</a>.  Partitions  . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-22">22</a>
     <a href="#appendix-A.9">A.9</a>.  Active-Standby Nodes  . . . . . . . . . . . . . . . . . .  <a href="#page-22">22</a>
   Authors' Addresses  . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-23">23</a>












<span class="grey">Campbell, et al.             Standards Track                    [Page 3]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-4"></span>
<span class="grey"><a href="./rfc8583">RFC 8583</a>                      Diameter Load                  August 2019</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/1.%20%20Introduction"></a><a class="selflink" href="#section-1" id="section-1">1</a>.  Introduction</span>

   [<a id="ref-RFC7068">RFC7068</a>] describes requirements for Overload Control in Diameter
   [<a href="./rfc6733" title='"Diameter Base Protocol"'>RFC6733</a>].  The DIME Working Group has finished the Diameter Overload
   Information Conveyance (DOIC) mechanism [<a href="./rfc7683" title='"Diameter Overload Indication Conveyance"'>RFC7683</a>].  As currently
   specified, DOIC fulfills some, but not all, of the requirements.

   In particular, DOIC does not fulfill Req 23 and Req 24:

      REQ 23: The solution MUST provide sufficient information to enable
      a load-balancing node to divert messages that are rejected or
      otherwise throttled by an overloaded upstream node to other
      upstream nodes that are the most likely to have sufficient
      capacity to process them.

      REQ 24: The solution MUST provide a mechanism for indicating load
      levels, even when not in an overload condition, to assist nodes in
      making decisions to prevent overload conditions from occurring.

   There are several other requirements in [<a href="./rfc7068" title='"Diameter Overload Control Requirements"'>RFC7068</a>] that mention both
   overload and load information that are only partially fulfilled by
   DOIC.

   The DIME Working Group explicitly chose not to fulfill these
   requirements when publishing DOIC [<a href="./rfc7683" title='"Diameter Overload Indication Conveyance"'>RFC7683</a>] due to several reasons.
   A principal reason was that the working group did not agree on a
   general approach for conveying load information.  It chose to
   progress the rest of DOIC and deferred load information conveyance to
   a DOIC extension or a separate mechanism.

   This document defines a mechanism that addresses the load-related
   requirements from <a href="./rfc7068">RFC 7068</a>.

<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/2.%20%20Terminology%20and%20Abbreviations"></a><a class="selflink" href="#section-2" id="section-2">2</a>.  Terminology and Abbreviations</span>

   AVP
      Attribute-Value Pair

   DOIC
      Diameter Overload Information Conveyance [<a href="./rfc7683" title='"Diameter Overload Indication Conveyance"'>RFC7683</a>]

   Load
      The relative usage of the Diameter message processing capacity of
      a Diameter node.  A low load level indicates that the Diameter
      node is underutilized.  A high load level indicates that the node
      is closer to being fully utilized.





<span class="grey">Campbell, et al.             Standards Track                    [Page 4]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-5"></span>
<span class="grey"><a href="./rfc8583">RFC 8583</a>                      Diameter Load                  August 2019</span>


   Offered Load
      The actual traffic sent to the reporting node after overload
      abatement and routing decisions are made.

   Reporting Node
      A DOIC node that sends a DOIC Overload report in a Diameter answer
      message.

   Reacting Node
      A DOIC node that receives and acts on a DOIC Overload report.

   Routing Information
      Routing Information referred to in this document can include the
      Routing and Peer tables defined in <a href="./rfc6733">RFC 6733</a>.  It can also include
      other implementation-specific tables used to store load
      information.  This document does not define the structure of such
      tables.

<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/3.%20%20Conventions%20Used%20in%20This%20Document"></a><a class="selflink" href="#section-3" id="section-3">3</a>.  Conventions Used in This Document</span>

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
   "OPTIONAL" in this document are to be interpreted as described in
   <a href="https://www.rfc-editor.org/bcp/bcp14">BCP 14</a> [<a href="./rfc2119" title='"Key words for use in RFCs to Indicate Requirement Levels"'>RFC2119</a>] [<a href="./rfc8174" title='"Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words"'>RFC8174</a>] when, and only when, they appear in all
   capitals, as shown here.

<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/4.%20%20Background"></a><a class="selflink" href="#section-4" id="section-4">4</a>.  Background</span>

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/4.1.%20%20Differences%20between%20Load%20and%20Overload%20Information"></a><a class="selflink" href="#section-4.1" id="section-4.1">4.1</a>.  Differences between Load and Overload Information</span>

   Previous discussions of how to solve the load-related requirements in
   [<a href="./rfc7068" title='"Diameter Overload Control Requirements"'>RFC7068</a>] have shown that people did not have an agreed-upon concept
   of how "load" information differs from "overload" information.  While
   the two concepts are highly interrelated, there are two primary
   differences.  First, a Diameter node always has a load.  At any given
   time, that load may be effectively zero, effectively fully loaded, or
   somewhere in between.  In contrast, overload is an exceptional
   condition.  A node only has Overload information when it is in an
   overloaded state.  Furthermore, the relationship between a node's
   load level and overload state at any given time may be vague.  For
   example, a node may normally operate at a "fully loaded" level, but
   still not be considered overloaded.  Another node may declare itself
   to be "overloaded" even though it might not be fully "loaded".

   Second, Overload information, in the form of a DOIC Overload Report
   (OLR) [<a href="./rfc7683" title='"Diameter Overload Indication Conveyance"'>RFC7683</a>] indicates an explicit request for action on the part
   of the reacting node; the OLR requests that the reacting node reduce
   the offered load, the actual traffic sent to the reporting node after



<span class="grey">Campbell, et al.             Standards Track                    [Page 5]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-6"></span>
<span class="grey"><a href="./rfc8583">RFC 8583</a>                      Diameter Load                  August 2019</span>


   overload abatement and routing decisions are made, by an indicated
   amount (by default) or as prescribed by the selected abatement
   algorithm.  Effectively, DOIC provides a contract between the
   reporting node and the reacting node.

   In contrast, load is informational; load information can be
   considered a hint to the recipient node.  That node may use the load
   information for load-balancing purposes, as an input to certain
   overload abatement techniques, to make inferences about the
   likelihood that the sending node becomes overloaded in the immediate
   future, or for other purposes.

   None of this prevents a Diameter node from deciding to reduce the
   offered load based on load information.  The fundamental difference
   is that an Overload report requires the reduction of the offered
   load.  It is also reasonable for a Diameter node to decide to
   increase the offered load based on load information.

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/4.2.%20%20How%20Is%20Load%20Information%20Used%3F"></a><a class="selflink" href="#section-4.2" id="section-4.2">4.2</a>.  How Is Load Information Used?</span>

   [<a id="ref-RFC7068">RFC7068</a>] contemplates two primary uses for load information.  Req 23
   discusses how load information might be used when performing
   diversion as an overload abatement technique as described in
   [<a href="./rfc7683" title='"Diameter Overload Indication Conveyance"'>RFC7683</a>].  When a reacting node diverts traffic away from an
   overloaded node, it needs load information for the other candidates
   for that traffic in order to effectively load-balance the diverted
   load between potential candidates.  Otherwise, diversion has a
   greater potential to drive other nodes into overload.

   Req 24 discusses how Diameter load information might be used when no
   overload condition currently exists.  Diameter nodes can use the load
   information to make decisions to try to avoid overload conditions in
   the first place.  Normal load-balancing falls into this category, but
   the Diameter node can take other proactive steps as well.

   If the loaded nodes are Diameter servers (or clients in the case of
   server-to-client transactions), both of these uses of load
   information should be accomplished by a Diameter node that performs
   server selection (selection of the Diameter endpoint to which the
   request is to be routed for processing).  Typically, server selection
   is performed by a node (a client or an agent) that is an immediate
   peer of the server.  However, there are scenarios (see <a href="#appendix-A">Appendix A</a>)
   where a client or proxy that is not the immediate peer to the
   selected servers performs server selection.  In this case, the client
   or proxy enforces the server selection by inserting a Destination-
   Host AVP.





<span class="grey">Campbell, et al.             Standards Track                    [Page 6]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-7"></span>
<span class="grey"><a href="./rfc8583">RFC 8583</a>                      Diameter Load                  August 2019</span>


   As an example, a Diameter node (e.g., client) can use a redirect
   agent to get candidate destination host addresses.  The redirect
   agent might return several destination host addresses from which the
   Diameter node selects one.  The Diameter node can use load
   information received from these hosts to make the selection.

   Just as load information can be used as part of server selection, it
   can also be used as input to the selection of the next-hop peer to
   which a request is to be routed.

   It should be noted that a Diameter node will need to process both
   load reports and Overload reports from the same Diameter node.  The
   reacting node for the overload report always has the responsibility
   to reduce the amount of Diameter traffic sent to the overloaded node.
   If, or how, the reacting node uses load information to achieve this
   is left as an implementation decision.

<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/5.%20%20Solution%20Overview"></a><a class="selflink" href="#section-5" id="section-5">5</a>.  Solution Overview</span>

   The mechanism defined here for the conveyance of load information is
   similar in some ways to the mechanism defined for DOIC and is
   different in other ways.

   As with DOIC, load information is conveyed by piggybacking the Load
   AVPs on existing Diameter applications.

   There are two primary differences.  First, there is no capability
   negotiation process for load.  The sender of the load information is
   sending it with the expectation that any supporting nodes will use it
   when making routing decisions.  If there are no nodes that support
   the Load mechanism, then the load information is ignored.

   The second big difference between DOIC and Load is visibility of the
   DOIC or load information within a Diameter network.  DOIC information
   is sent end-to-end resulting in the ability of all nodes in the path
   of the answer message that carries the OC-OLR AVP to act on the
   information, although only one node actually consumes and reacts to
   the report.  The DOIC Overload reports remain in the message all the
   way from the reporting node to the node that is the target for the
   answer message.

   For the Load mechanism, there are two types of load reports and only
   the first one is transmitted end-to-end.

   The first type of load report is a host-load report, which contains
   the load of the endpoint sending the answer message.  This load
   report is carried end-to-end to enable any nodes that make server
   selection decisions to use the load status of the sending endpoint as



<span class="grey">Campbell, et al.             Standards Track                    [Page 7]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-8"></span>
<span class="grey"><a href="./rfc8583">RFC 8583</a>                      Diameter Load                  August 2019</span>


   part of the server selection decision.  Unlike with DOIC, more than
   one node may make use of the load information received.

   The second type of load report is a peer-load report.  This report is
   used by Diameter nodes as part of the logic to select the next-hop
   Diameter node and, as such, does not have significance beyond the
   peer node.  load reports of type "PEER" are removed by the first
   supporting Diameter node to receive the report.

   Because load reports can traverse Diameter nodes that do not support
   the Load mechanism, it is necessary to include the identity of the
   node to which the load report applies as part of the load report.
   This allows for a Diameter node to verify that a load report applies
   to its peer or that it should be ignored.

   The load report includes a value indicating the relative load of the
   sending node, specified in a manner consistent with that defined for
   DNS SRV [<a href="./rfc2782" title='"A DNS RR for specifying the location of services (DNS SRV)"'>RFC2782</a>].

   The goal is to make it possible to use both the Load values received
   as a part of the Diameter Load mechanism and weight values received
   as a result of a DNS SRV query.  As a result, the Diameter Load value
   has a range of 0-65535.  This value and DNS SRV weight values are
   then used in a distribution algorithm similar to that specified in
   [<a href="./rfc2782" title='"A DNS RR for specifying the location of services (DNS SRV)"'>RFC2782</a>].

   The DNS SRV distribution algorithm results in more messages being
   sent to a node with a higher weight value.  As a result, a higher
   Diameter Load value indicates a LOWER load on the sending node.  A
   node that is heavily loaded sends a lower Diameter Load value.
   Stated another way, a node that has zero load would have a Load value
   of 65535.  A node that is 100% loaded would have a Load value of 0.

   The distribution algorithm used by Diameter nodes supporting the
   Diameter Load mechanism is an implementation decision, but it needs
   to result in similar behavior to the algorithm described for the use
   of weight values specified in [<a href="./rfc2782" title='"A DNS RR for specifying the location of services (DNS SRV)"'>RFC2782</a>].

   The method for calculating the Load value included in the load report
   is also left as an implementation decision.

   The frequency for sending of load reports is also left as an
   implementation decision.  The sending node might choose to send load
   reports in all messages or it might choose to only send load reports
   when the Load value has changed by some implementation-specific
   amount.  The important consideration is that all nodes needing the
   load information have a sufficiently accurate view of the node's
   load.



<span class="grey">Campbell, et al.             Standards Track                    [Page 8]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-9"></span>
<span class="grey"><a href="./rfc8583">RFC 8583</a>                      Diameter Load                  August 2019</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/5.1.%20%20Theory%20of%20Operation"></a><a class="selflink" href="#section-5.1" id="section-5.1">5.1</a>.  Theory of Operation</span>

   This section outlines how the Diameter Load mechanism is expected to
   work.

   For this discussion, assume the following Diameter network
   configuration:

           ---A1---A3----S[1], S[2]...S[p]
          /   | \ /
         C    |  x
          \   | / \
           ---A2---A4----S[p+1], S[p+2] ...S[n]

                    Figure 1: Example Diameter Network

   Note that in this diagram, S[1] and S[2] through S[p] are peers to
   A3.  S[p+1] and S[p+2] through S[n] are peers to A4.

   Also assume that the request for a Diameter transaction takes the
   following path:

         C     A1     A4     S[n]
         |      |      |      |
         |-----&gt;|-----&gt;|-----&gt;|
         xxR     xxR    xxR

                      Figure 2: Request Message Path

   When sending the answer message, an endpoint node that supports the
   Diameter Load mechanism includes its own load information in the
   answer message.  Because it is a Diameter endpoint, it includes a
   host-load report.

         C     A1     A4     S[n]
         |      |      |      |
         |      |      |&lt;-----|
         |      |       xxA(Load type:HOST, source:S[n])
         |      |      |      |

                    Figure 3: Answer Message from S[n]

   If Agent A4 supports the Load mechanism, then A4's actions depend on
   whether A4 is responsible for doing server selection.  If A4 is not
   doing server selection, then A4 ignores the host-load report.  If A4
   is responsible for doing server selection, then it stores the load





<span class="grey">Campbell, et al.             Standards Track                    [Page 9]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-10"></span>
<span class="grey"><a href="./rfc8583">RFC 8583</a>                      Diameter Load                  August 2019</span>


   information for S[n] in its routing information for the handling of
   subsequent request messages.  In both cases, A4 leaves the host-load
   report in the message.

      Note: If A4 does not support the Load mechanism, then it will
      relay the answer message without doing any processing on the load
      information.  In this case, the load information AVPs will be
      relayed without change.

   A4 then calculates its own load information and inserts load
   information AVPs of type "PEER" in the message before sending the
   message to A1.

         C     A1     A4     S[n]
         |      |      |      |
         |      |&lt;-----|      |
         |       xxA(Load type:PEER, source:A4)
         |       xxA(Load type:HOST, source:S[n])
         |      |      |      |

                     Figure 4: Answer Message from A4

   If A1 supports the Load mechanism, then it processes each of the load
   reports it receives separately.

   For the peer-load report, A1 first determines if the source of the
   report indicated in the load report matches the DiameterIdentity of
   the Diameter node from which the request was received.  If the
   identities do not match, then the peer-load report is discarded.  If
   the identities match, then A1 saves the load information in its
   routing information for routing of subsequent request messages.  In
   both cases, A1 strips the peer-load report from the message.

   For the host-load report, A1's actions depend on whether A1 is
   responsible for doing server selection.  If A1 is not doing server
   selection, then A1 ignores the host-load report.  If A1 is
   responsible for doing server selection, then it stores the load
   information for S[n] in its routing information for the handling of
   subsequent request messages.  In both cases, A1 leaves the host-load
   report in the message.











<span class="grey">Campbell, et al.             Standards Track                   [Page 10]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-11"></span>
<span class="grey"><a href="./rfc8583">RFC 8583</a>                      Diameter Load                  August 2019</span>


   A1 then calculates its own load information and inserts load
   information AVPs of type "PEER" in the message before sending the
   message to C:

         C     A1     A4     S[n]
         |      |      |      |
         |&lt;-----|      |      |
          xxA(Load type:PEER, source:A1)
          xxA(Load type:HOST, source:S[n])

                     Figure 5: Answer Message from A1

   As with A1, C processes each load report separately.

   For the peer-load report, C follows the same procedure as A1 for
   determining if the load report was received from the peer from which
   the report was sent.  When finding it does, C stores the load
   information for use when making future routing decisions.

   For the host-load report, C saves the load information only if it is
   responsible for doing server selection.

   The load information received by all nodes is then used for routing
   of subsequent request messages.

<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/6.%20%20Load-Mechanism%20Procedures"></a><a class="selflink" href="#section-6" id="section-6">6</a>.  Load-Mechanism Procedures</span>

   This section defines the normative behaviors for the Load mechanism.

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/6.1.%20%20Reporting-Node%20Behavior"></a><a class="selflink" href="#section-6.1" id="section-6.1">6.1</a>.  Reporting-Node Behavior</span>

   This section defines the procedures of Diameter reporting nodes that
   generate load reports.

<span class="h4"><a class="dashAnchor" name="//apple_ref/cpp/Section/6.1.1.%20%20Endpoint%20Reporting-Node%20Behavior"></a><a class="selflink" href="#section-6.1.1" id="section-6.1.1">6.1.1</a>.  Endpoint Reporting-Node Behavior</span>

   A Diameter endpoint that supports the Diameter Load mechanism MUST
   include a load report of type "HOST" in sufficient answer messages to
   ensure that all consumers of the load information receive timely
   updates.

   The Diameter endpoint MUST include its own DiameterIdentity in the
   SourceID AVP included in the Load AVP.

   The Diameter endpoint MUST include a Load-Type AVP of type "HOST" in
   the Load AVP.





<span class="grey">Campbell, et al.             Standards Track                   [Page 11]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-12"></span>
<span class="grey"><a href="./rfc8583">RFC 8583</a>                      Diameter Load                  August 2019</span>


   The Diameter endpoint MUST include its Load value in the Load-Value
   AVP in the Load AVP.

   The Load value should be calculated in a way that reflects the
   available load independently of the weight of each server in order to
   accurately compare Load values from different nodes.  Any specific
   Load value needs to identify the same amount of available capacity
   regardless of the Diameter node that calculates the value.

   The mechanism used to calculate the Load value that fulfills this
   requirement is an implementation decision.

   The frequency of sending load reports is an implementation decision.

   For instance, if the only consumer of the load reports is the
   endpoint's peer, then the endpoint can choose to only include a load
   report when the load of the endpoint has changed by a meaningful
   percentage.  If there are consumers of the endpoint load report other
   than the endpoint's peer (this will be the case if other nodes are
   responsible for server selection), then the endpoint might choose to
   include load reports in all answer messages as a way of ensuring that
   all nodes doing server selection get accurate load information.

<span class="h4"><a class="dashAnchor" name="//apple_ref/cpp/Section/6.1.2.%20%20Agent%20Reporting-Node%20Behavior"></a><a class="selflink" href="#section-6.1.2" id="section-6.1.2">6.1.2</a>.  Agent Reporting-Node Behavior</span>

   A Diameter Agent that supports the Diameter Load mechanism MUST
   include a peer-load report in sufficient answer messages to ensure
   that all users of the load information receive timely updates.

   The Diameter Agent MUST include its own DiameterIdentity in the
   SourceID AVP included in the Load AVP.

   The Diameter Agent MUST include a Load-Type AVP of type "PEER" in the
   Load AVP.

   The Diameter Agent MUST include its Load value in the Load-Value AVP
   in the Load AVP.

   The Load value should be calculated in a way that reflects the
   available load independently of the weight of each agent in order to
   accurately compare Load values from different nodes.  Any specific
   Load value needs to identify the same amount of available capacity
   regardless of the Diameter node that calculates the value.

   The mechanism used to calculate the Load value that fulfills this
   requirement is an implementation decision.

   The frequency of sending load reports is an implementation decision.



<span class="grey">Campbell, et al.             Standards Track                   [Page 12]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-13"></span>
<span class="grey"><a href="./rfc8583">RFC 8583</a>                      Diameter Load                  August 2019</span>


      Note: In the case of load reports of type "PEER", it is only
      necessary to include load reports when the Load value has changed
      by some meaningful value, as long as the agent ensures that all
      peers receive the report.  It is also acceptable to include the
      load report in every answer message handled by the Diameter Agent.

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/6.2.%20%20Reacting-Node%20Behavior"></a><a class="selflink" href="#section-6.2" id="section-6.2">6.2</a>.  Reacting-Node Behavior</span>

   This section defines the behavior of Diameter nodes processing load
   reports.

   A Diameter node that supports the Diameter Load mechanism MUST be
   prepared to process load reports of type "HOST" and of type "PEER",
   as indicated in the Load-Type AVP included in the Load AVP received
   in the same answer message or from multiple answer messages.

      Note: The node needs to be able to handle messages with no Load
      reports, messages with just a peer-load report, messages with just
      a host-load report, and messages with both types of load reports.

   If the Diameter node is not responsible for doing server selection,
   then it SHOULD ignore load reports of type "HOST".

   If the Diameter node is responsible for doing server selection, then
   it SHOULD save the Load value included in the Load-Value AVP included
   in the Load AVP of type "HOST" in its routing information.

   If the Diameter node receives a load report of type "PEER", then the
   Diameter node MUST determine if the load report was inserted into the
   answer message by the peer from which the message was received.  This
   is achieved by comparing the DiameterIdentity associated with the
   connection from which the message was received with the
   DiameterIdentity included in the SourceID AVP in the load report.

   If the Diameter node determines that the load report of type "PEER"
   was not received from the peer that sent or relayed the answer
   message, then the node MUST ignore the load report.

   If the Diameter node determines that the load report of type "PEER"
   was received from the peer that sent or relayed the answer message,
   then the node SHOULD save the load information in its routing
   information.

   In all cases, a Diameter Agent MUST strip all load reports of type
   "PEER" received in answer messages.






<span class="grey">Campbell, et al.             Standards Track                   [Page 13]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-14"></span>
<span class="grey"><a href="./rfc8583">RFC 8583</a>                      Diameter Load                  August 2019</span>


      Note: This ensures that there will be precisely one load report of
      type "PEER", e.g., that of the Diameter node sending the message,
      in any answer messages sent by the Diameter Agent.

   How a Diameter node uses load information for making routing
   decisions is an implementation decision.  However, the distribution
   algorithm MUST result in similar behavior as the algorithm described
   for the use of weight values in [<a href="./rfc2782" title='"A DNS RR for specifying the location of services (DNS SRV)"'>RFC2782</a>].

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/6.3.%20%20Extensibility"></a><a class="selflink" href="#section-6.3" id="section-6.3">6.3</a>.  Extensibility</span>

   The Load mechanism can be extended to include additional information
   in the load reports.

   Any extension may define new AVPs for use in load reports.  These new
   AVPs SHOULD be defined to be extensions to the Load AVPs defined in
   this document.

   Grouped AVP extension mechanisms defined by [<a href="./rfc6733" title='"Diameter Base Protocol"'>RFC6733</a>] apply.  This
   allows, for example, defining a new feature that is mandatory to be
   understood even when piggybacked on an existing application.

   As with any Diameter specification, [<a href="./rfc6733" title='"Diameter Base Protocol"'>RFC6733</a>] requires all new AVPs
   to be registered with IANA.  See <a href="#section-9">Section 9</a> for the required
   procedures.

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/6.4.%20%20Addition%20and%20Removal%20of%20Nodes"></a><a class="selflink" href="#section-6.4" id="section-6.4">6.4</a>.  Addition and Removal of Nodes</span>

   When a Diameter node is added, the new node will start by advertising
   its load.  Downstream nodes will need to factor the new load
   information into load-balancing decisions.  The downstream nodes can
   attempt to ensure a smooth increase of the traffic to the new node,
   avoiding an immediate spike of traffic to that new node.  The method
   for the handling of such a smooth increase is implementation-
   specific, but it can rely on the evolution of load information
   received from the new node and from the other nodes.

   When removing a node in a controlled way (e.g., for maintenance
   purposes, so outside a failure case), it might be appropriate to
   progressively reduce the traffic to this node by routing traffic to
   other nodes.  Simple load information (load percentage) would not be
   sufficient.  The method for the handling of the node removal is
   implementation-specific, but it can rely on the evolution of the load
   information received from the node to be removed.







<span class="grey">Campbell, et al.             Standards Track                   [Page 14]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-15"></span>
<span class="grey"><a href="./rfc8583">RFC 8583</a>                      Diameter Load                  August 2019</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/7.%20%20Attribute-Value%20Pairs"></a><a class="selflink" href="#section-7" id="section-7">7</a>.  Attribute-Value Pairs</span>

   The section defines the AVPs required for the Load mechanism.

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/7.1.%20%20Load%20AVP"></a><a class="selflink" href="#section-7.1" id="section-7.1">7.1</a>.  Load AVP</span>

   The Load AVP (AVP code 650) is of type Grouped and is used to convey
   load information between Diameter nodes.

    Load ::= &lt; AVP Header: 650 &gt;
             [ Load-Type ]
             [ Load-Value ]
             [ SourceID ]
           * [ AVP ]

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/7.2.%20%20Load-Type%20AVP"></a><a class="selflink" href="#section-7.2" id="section-7.2">7.2</a>.  Load-Type AVP</span>

   The Load-Type AVP (AVP code 651) is of type Enumerated.  It is used
   to convey the type of Diameter node that sent the load information.
   The following values are defined:

   HOST 0  The load report is for a host.

   PEER 1  The load report is for a peer.

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/7.3.%20%20Load-Value%20AVP"></a><a class="selflink" href="#section-7.3" id="section-7.3">7.3</a>.  Load-Value AVP</span>

   The Load-Value AVP (AVP code 652) is of type Unsigned64.  It is used
   to convey relative load information about the sender of the load
   report.

   The Load-Value AVP is specified in a manner similar to the weight
   value in DNS SRV ([<a href="./rfc2782" title='"A DNS RR for specifying the location of services (DNS SRV)"'>RFC2782</a>]).

   The Load value has a range of 0-65535.

   A higher value indicates a lower load on the sending node.  A lower
   value indicates that the sending node is heavily loaded.

      Stated another way, a node that has zero load would have a Load
      value of 65535.  A node that is 100% loaded would have a Load
      value of 0.

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/7.4.%20%20SourceID%20AVP"></a><a class="selflink" href="#section-7.4" id="section-7.4">7.4</a>.  SourceID AVP</span>

   The SourceID AVP is defined in [<a href="./rfc8581" title='"Diameter Agent Overload and the Peer Overload Report"'>RFC8581</a>].  It is used to identify the
   Diameter node that sent the load report.




<span class="grey">Campbell, et al.             Standards Track                   [Page 15]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-16"></span>
<span class="grey"><a href="./rfc8583">RFC 8583</a>                      Diameter Load                  August 2019</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/7.5.%20%20Attribute-Value%20Pair%20Flag%20Rules"></a><a class="selflink" href="#section-7.5" id="section-7.5">7.5</a>.  Attribute-Value Pair Flag Rules</span>

                                                             +---------+
                                                             |AVP flag |
                                                             |rules    |
                                                             +----+----+
                            AVP   Section                    |    |MUST|
     Attribute Name         Code  Defined  Value Type        |MUST| NOT|
    +--------------------------------------------------------+----+----+
    |Load                   650   7.1      Grouped           |    | V  |
    +--------------------------------------------------------+----+----+
    |Load-Type              651   7.2      Enumerated        |    | V  |
    +--------------------------------------------------------+----+----+
    |Load-Value             652   7.3      Unsigned64        |    | V  |
    +------------------------------------------------------ -+----+----+
    |SourceID               649   7.4      DiameterIdentity  |    | V  |
    +--------------------------------------------------------+----+----+

   As described in the Diameter base protocol [<a href="./rfc6733" title='"Diameter Base Protocol"'>RFC6733</a>], the M-bit usage
   for a given AVP in a given command may be defined by the application.

<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/8.%20%20Security%20Considerations"></a><a class="selflink" href="#section-8" id="section-8">8</a>.  Security Considerations</span>

   Load information may be sensitive information in some cases.
   Depending on the mechanism, an unauthorized recipient might be able
   to infer the topology of a Diameter network from load information.
   Load information might be useful in identifying targets for denial-
   of-service (DoS) attacks, where a node known to be already heavily
   loaded might be a tempting target.  Load information might also be
   useful as feedback about the success of an ongoing DoS attack.

   Given that routing decisions are impacted by load information, there
   is potential for negative impacts on a Diameter network caused by
   erroneous or malicious load reports.  This includes the malicious
   changing of Load values by Diameter Agents.

   Any load information conveyance mechanism will need to allow
   operators to avoid sending load information to nodes that are not
   authorized to receive it.  Since Diameter currently only offers
   authentication of nodes at the transport level and does not support
   end-to-end security mechanisms, any solution that sends load
   information to non-peer nodes requires a transitive-trust model.

<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/9.%20%20IANA%20Considerations"></a><a class="selflink" href="#section-9" id="section-9">9</a>.  IANA Considerations</span>

   IANA has registered three new AVP codes in the "Authentication,
   Authorization, and Accounting (AAA) Parameters" registry; see
   Sections <a href="#section-7.1">7.1</a>, <a href="#section-7.2">7.2</a>, and <a href="#section-7.3">7.3</a>.



<span class="grey">Campbell, et al.             Standards Track                   [Page 16]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-17"></span>
<span class="grey"><a href="./rfc8583">RFC 8583</a>                      Diameter Load                  August 2019</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/10.%20%20References"></a><a class="selflink" href="#section-10" id="section-10">10</a>.  References</span>

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/10.1.%20%20Normative%20References"></a><a class="selflink" href="#section-10.1" id="section-10.1">10.1</a>.  Normative References</span>

   [<a id="ref-RFC2119">RFC2119</a>]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", <a href="https://www.rfc-editor.org/bcp/bcp14">BCP 14</a>, <a href="./rfc2119">RFC 2119</a>,
              DOI 10.17487/RFC2119, March 1997,
              &lt;<a href="https://www.rfc-editor.org/info/rfc2119">https://www.rfc-editor.org/info/rfc2119</a>&gt;.

   [<a id="ref-RFC2782">RFC2782</a>]  Gulbrandsen, A., Vixie, P., and L. Esibov, "A DNS RR for
              specifying the location of services (DNS SRV)", <a href="./rfc2782">RFC 2782</a>,
              DOI 10.17487/RFC2782, February 2000,
              &lt;<a href="https://www.rfc-editor.org/info/rfc2782">https://www.rfc-editor.org/info/rfc2782</a>&gt;.

   [<a id="ref-RFC6733">RFC6733</a>]  Fajardo, V., Ed., Arkko, J., Loughney, J., and G. Zorn,
              Ed., "Diameter Base Protocol", <a href="./rfc6733">RFC 6733</a>,
              DOI 10.17487/RFC6733, October 2012,
              &lt;<a href="https://www.rfc-editor.org/info/rfc6733">https://www.rfc-editor.org/info/rfc6733</a>&gt;.

   [<a id="ref-RFC7683">RFC7683</a>]  Korhonen, J., Ed., Donovan, S., Ed., Campbell, B., and L.
              Morand, "Diameter Overload Indication Conveyance",
              <a href="./rfc7683">RFC 7683</a>, DOI 10.17487/RFC7683, October 2015,
              &lt;<a href="https://www.rfc-editor.org/info/rfc7683">https://www.rfc-editor.org/info/rfc7683</a>&gt;.

   [<a id="ref-RFC8174">RFC8174</a>]  Leiba, B., "Ambiguity of Uppercase vs Lowercase in <a href="./rfc2119">RFC</a>
              <a href="./rfc2119">2119</a> Key Words", <a href="https://www.rfc-editor.org/bcp/bcp14">BCP 14</a>, <a href="./rfc8174">RFC 8174</a>, DOI 10.17487/RFC8174,
              May 2017, &lt;<a href="https://www.rfc-editor.org/info/rfc8174">https://www.rfc-editor.org/info/rfc8174</a>&gt;.

   [<a id="ref-RFC8581">RFC8581</a>]  Donovan, S., "Diameter Agent Overload and the Peer
              Overload Report", <a href="./rfc8581">RFC 8581</a>, DOI 10.17487/RFC8581, August
              2019, &lt;<a href="https://www.rfc-editor.org/info/rfc8581">https://www.rfc-editor.org/info/rfc8581</a>&gt;.

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/10.2.%20%20Informative%20References"></a><a class="selflink" href="#section-10.2" id="section-10.2">10.2</a>.  Informative References</span>

   [<a id="ref-RFC7068">RFC7068</a>]  McMurry, E. and B. Campbell, "Diameter Overload Control
              Requirements", <a href="./rfc7068">RFC 7068</a>, DOI 10.17487/RFC7068, November
              2013, &lt;<a href="https://www.rfc-editor.org/info/rfc7068">https://www.rfc-editor.org/info/rfc7068</a>&gt;.














<span class="grey">Campbell, et al.             Standards Track                   [Page 17]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-18"></span>
<span class="grey"><a href="./rfc8583">RFC 8583</a>                      Diameter Load                  August 2019</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/Appendix%20A.%20%20Topology%20Scenarios"></a><a class="selflink" href="#appendix-A" id="appendix-A">Appendix A</a>.  Topology Scenarios</span>

   This section presents a number of Diameter topology scenarios and
   discusses how load information might be used in each scenario.

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/A.1.%20%20No%20Agent"></a><a class="selflink" href="#appendix-A.1" id="appendix-A.1">A.1</a>.  No Agent</span>

   Figure 6 shows a simple client-server scenario where a client picks
   from a set of candidate servers available for a particular realm and
   application.  The client selects the server for a given transaction
   using the load information received from each server.

       ------S1
      /
     C
      \
       ------S2

                  Figure 6: Basic Client Server Scenario

      If a node supports dynamic discovery, it will not obtain load
      information from the nodes with which it has no Diameter
      connection established.  Nevertheless, it might take into account
      the load information from the other nodes to decide to add
      connections to new nodes with the dynamic discovery mechanism.

      Note: The use of dynamic connections needs to be considered.

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/A.2.%20%20Single%20Agent"></a><a class="selflink" href="#appendix-A.2" id="appendix-A.2">A.2</a>.  Single Agent</span>

   Figure 7 shows a client that sends requests to an agent.  The agent
   selects the request destination from a set of candidate servers,
   using load information received from each server.  The client does
   not need to receive load information since it does not select between
   multiple agents.

            ------S1
           /
     C----A
           \
            ------S2

                      Figure 7: Simple Agent Scenario








<span class="grey">Campbell, et al.             Standards Track                   [Page 18]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-19"></span>
<span class="grey"><a href="./rfc8583">RFC 8583</a>                      Diameter Load                  August 2019</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/A.3.%20%20Multiple%20Agents"></a><a class="selflink" href="#appendix-A.3" id="appendix-A.3">A.3</a>.  Multiple Agents</span>

   Figure 8 shows a client selecting between multiple agents and each
   agent selecting from multiple servers.  The client selects an agent
   based on the load information received from each agent.  Each agent
   selects a server based on the load information received from its
   servers.

   This scenario adds a complication that one set of servers may be more
   loaded than the other set.  If, for example, S4 was the least loaded
   server, C would need to know to select agent A2 to reach S4.  This
   might require C to receive load information from the servers as well
   as the agents.  Alternatively, each agent might use the load of its
   servers as an input into calculating its own load, in effect
   aggregating upstream load.

   Similarly, if C sends a host-routed request [<a href="./rfc7683" title='"Diameter Overload Indication Conveyance"'>RFC7683</a>], it needs to
   know which agent can deliver requests to the selected server.
   Without some special, potentially proprietary, knowledge of the
   topology upstream of A1 and A2, C would select the agent based on the
   normal peer selection procedures for the realm and application, and
   perhaps consider the load information from A1 and A2.  If C sends a
   request to A1 that contains a Destination-Host AVP with a value of
   S4, A1 will not be able to deliver the request.

             -----S3
            /
       ---A1------S1
      /
     C
      \
       ---A2------S2
            \
             ---- S4

                   Figure 8: Multiple Agents and Servers

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/A.4.%20%20Linked%20Agents"></a><a class="selflink" href="#appendix-A.4" id="appendix-A.4">A.4</a>.  Linked Agents</span>

   Figure 9 shows a scenario similar to that of Figure 8, except that
   the agents are linked so that A1 can forward a request to A2, and
   vice-versa.  Each agent could receive load information from the
   linked agent as well as its connected servers.

   This somewhat simplifies the complication from Figure 8 due to the
   fact that C does not necessarily need to choose a particular agent to
   reach a particular server.  But, it creates a similar question of




<span class="grey">Campbell, et al.             Standards Track                   [Page 19]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-20"></span>
<span class="grey"><a href="./rfc8583">RFC 8583</a>                      Diameter Load                  August 2019</span>


   how, for example, A1 might know that S4 was less loaded than S1 or
   S3.  Additionally, it creates the opportunity for sub-optimal request
   paths.  For example, [C,A1,A2,S4] vs. [C,A2,S4].

   A likely application for linked agents is when each agent prefers to
   route only to directly connected servers and only forwards requests
   to another agent under exceptional circumstances.  For example, A1
   might not forward requests to A2 unless both S1 and S3 are
   overloaded.  In this case, A1 might use the load information from S1
   and S3 to select between those, and only consider the load
   information from A2 (and other connected agents) if it needs to
   divert requests to different agents.

              -----S3
             /
        ---A1------S1
      /    |
     C     |
      \    |
        ---A2------S2
             \
              ---- S4

                          Figure 9: Linked Agents

   Figure 10 is a variant of Figure 9.  In this case, C1 sends all
   traffic through A1, and C2 sends all traffic through A2.  By default,
   A1 will load-balance traffic between S1 and S3, and A2 will load-
   balance traffic between S2 and S4.

   Now, if S1 and S3 are significantly more loaded than S2 and S4, A1
   may route some C1 traffic to A2.  This is a non-optimal path, but it
   allows better load balancing between the servers.  To achieve this,
   A1 needs to receive some load info from A2 about the S2/S4 load.

              -----S3
             /
     C1----A1------S1
           |
           |
           |
     C2----A2------S2
             \
              ---- S4

                         Figure 10: Linked Agents





<span class="grey">Campbell, et al.             Standards Track                   [Page 20]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-21"></span>
<span class="grey"><a href="./rfc8583">RFC 8583</a>                      Diameter Load                  August 2019</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/A.5.%20%20Shared%20Server%20Pools"></a><a class="selflink" href="#appendix-A.5" id="appendix-A.5">A.5</a>.  Shared Server Pools</span>

   Figure 11 is similar to Figure 9, except that instead of a link
   between agents, each agent is linked to all servers (The links to
   each set of servers should be interpreted as a link to each server.
   The links are not shown separately due to the limitations of ASCII
   art.).

   In this scenario, each agent can select among all of the servers
   based on the load information from the servers.  The client need only
   be concerned with the load information of the agents.

       ---A1---S[1], S[2]...S[p]
      /     \ /
     C       x
      \     / \
       ---A2---S[p+1], S[p+2] ...S[n]

                      Figure 11: Shared Server Pools

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/A.6.%20%20Agent%20Chains"></a><a class="selflink" href="#appendix-A.6" id="appendix-A.6">A.6</a>.  Agent Chains</span>

   The scenario in Figure 12 is similar to that of Figure 8, except that
   instead of the client possibly needing to select an agent that can
   route requests to the least loaded server, in this case A1 and A2
   need to make similar decisions when selecting between A3 or A4.  As
   the former scenario, this could be mitigated if A3 and A4 aggregate
   upstream loads into the load information they report downstream.

       ---A1---A3----S[1], S[2]...S[p]
      /   | \ /
     C    |  x
      \   | / \
       ---A2---A4----S[p+1], S[p+2] ...S[n]

                          Figure 12: Agent Chains















<span class="grey">Campbell, et al.             Standards Track                   [Page 21]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-22"></span>
<span class="grey"><a href="./rfc8583">RFC 8583</a>                      Diameter Load                  August 2019</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/A.7.%20%20Fully-Meshed%20Layers"></a><a class="selflink" href="#appendix-A.7" id="appendix-A.7">A.7</a>.  Fully-Meshed Layers</span>

   Figure 13 extends the scenario in Figure 11 by adding an extra layer
   of agents.  But since each layer of nodes can reach any node in the
   next layer, each node only needs to consider the load of its next-hop
   peer.

       ---A1---A3---S[1], S[2]...S[p]
      /   | \ / |\ /
     C    |  x  | x
      \   | / \ |/ \
       ---A2---A4---S[p+1], S[p+2] ...S[n]

                           Figure 13: Full Mesh

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/A.8.%20%20Partitions"></a><a class="selflink" href="#appendix-A.8" id="appendix-A.8">A.8</a>.  Partitions</span>

   A Diameter network with multiple servers is said to be "partitioned"
   when only a subset of available servers can serve a particular realm-
   routed request.  For example, one group of servers may handle users
   whose names start with "A" through "M", and another group may handle
   "N" through "Z".

   In such a partitioned network, nodes cannot load balance requests
   across partitions since not all servers can handle the request.  A
   client, or an intermediate agent, may still be able to load balance
   between servers inside a partition.

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/A.9.%20%20Active-Standby%20Nodes"></a><a class="selflink" href="#appendix-A.9" id="appendix-A.9">A.9</a>.  Active-Standby Nodes</span>

   The previous scenarios assume that traffic can be load balanced among
   all peers that are eligible to handle a request.  That is, the peers
   operate in an "active-active" configuration.  In an "active-standby"
   configuration, traffic would be load balanced among active peers.
   Requests would only be sent to peers in a "standby" state if the
   active peers became unavailable.  For example, requests might be
   diverted to a stand-by peer if one or more active peers becomes
   overloaded.













<span class="grey">Campbell, et al.             Standards Track                   [Page 22]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-23"></span>
<span class="grey"><a href="./rfc8583">RFC 8583</a>                      Diameter Load                  August 2019</span>


Authors' Addresses

   Ben Campbell
   Oracle
   7460 Warren Parkway, Suite 300
   Frisco, Texas  75034
   United States of America

   Email: ben@nostrum.com


   Steve Donovan (editor)
   Oracle
   7460 Warren Parkway # 300
   Frisco, Texas  75034
   United States of America

   Email: srdonovan@usdonovans.com


   Jean-Jacques Trottin
   Nokia
   Route de Villejust
   91620 Nozay
   France

   Email: jean-jacques.trottin@nokia.com
























Campbell, et al.             Standards Track                   [Page 23]
</pre>
</body></html>