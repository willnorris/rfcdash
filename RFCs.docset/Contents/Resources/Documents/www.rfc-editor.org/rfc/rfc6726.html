<html><head></head><body><pre>Internet Engineering Task Force (IETF)                          T. Paila
Request for Comments: 6726                                         Nokia
Obsoletes: <a href="./rfc3926">3926</a>                                                 R. Walsh
Category: Standards Track                                      Nokia/TUT
ISSN: 2070-1721                                                  M. Luby
                                             Qualcomm Technologies, Inc.
                                                                 V. Roca
                                                                   INRIA
                                                             R. Lehtonen
                                                             TeliaSonera
                                                           November 2012


          <span class="h1">FLUTE - File Delivery over Unidirectional Transport</span>

Abstract

   This document defines File Delivery over Unidirectional Transport
   (FLUTE), a protocol for the unidirectional delivery of files over the
   Internet, which is particularly suited to multicast networks.  The
   specification builds on Asynchronous Layered Coding, the base
   protocol designed for massively scalable multicast distribution.
   This document obsoletes <a href="./rfc3926">RFC 3926</a>.

Status of This Memo

   This is an Internet Standards Track document.

   This document is a product of the Internet Engineering Task Force
   (IETF).  It represents the consensus of the IETF community.  It has
   received public review and has been approved for publication by the
   Internet Engineering Steering Group (IESG).  Further information on
   Internet Standards is available in <a href="./rfc5741#section-2">Section 2 of RFC 5741</a>.

   Information about the current status of this document, any errata,
   and how to provide feedback on it may be obtained at
   <a href="http://www.rfc-editor.org/info/rfc6726">http://www.rfc-editor.org/info/rfc6726</a>.














<span class="grey">Paila, et al.                Standards Track                    [Page 1]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-2"></span>
<span class="grey"><a href="./rfc6726">RFC 6726</a>                          FLUTE                    November 2012</span>


Copyright Notice

   Copyright (c) 2012 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to <a href="https://www.rfc-editor.org/bcp/bcp78">BCP 78</a> and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (<a href="http://trustee.ietf.org/license-info">http://trustee.ietf.org/license-info</a>) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.

   This document may contain material from IETF Documents or IETF
   Contributions published or made publicly available before November
   10, 2008.  The person(s) controlling the copyright in some of this
   material may not have granted the IETF Trust the right to allow
   modifications of such material outside the IETF Standards Process.
   Without obtaining an adequate license from the person(s) controlling
   the copyright in such materials, this document may not be modified
   outside the IETF Standards Process, and derivative works of it may
   not be created outside the IETF Standards Process, except to format
   it for publication as an RFC or to translate it into languages other
   than English.

Table of Contents

   <a href="#section-1">1</a>. Introduction ....................................................<a href="#page-3">3</a>
      <a href="#section-1.1">1.1</a>. Applicability Statement ....................................<a href="#page-5">5</a>
           <a href="#section-1.1.1">1.1.1</a>. The Target Application Space ........................<a href="#page-5">5</a>
           <a href="#section-1.1.2">1.1.2</a>. The Target Scale ....................................<a href="#page-5">5</a>
           <a href="#section-1.1.3">1.1.3</a>. Intended Environments ...............................<a href="#page-5">5</a>
           <a href="#section-1.1.4">1.1.4</a>. Weaknesses ..........................................<a href="#page-6">6</a>
   <a href="#section-2">2</a>. Conventions Used in This Document ...............................<a href="#page-6">6</a>
   <a href="#section-3">3</a>. File Delivery ...................................................<a href="#page-7">7</a>
      <a href="#section-3.1">3.1</a>. File Delivery Session ......................................<a href="#page-8">8</a>
      <a href="#section-3.2">3.2</a>. File Delivery Table .......................................<a href="#page-10">10</a>
      <a href="#section-3.3">3.3</a>. Dynamics of FDT Instances within a File Delivery Session ..12
      <a href="#section-3.4">3.4</a>. Structure of FDT Instance Packets .........................<a href="#page-15">15</a>
           <a href="#section-3.4.1">3.4.1</a>. Format of FDT Instance Header ......................<a href="#page-16">16</a>
           <a href="#section-3.4.2">3.4.2</a>. Syntax of FDT Instance .............................<a href="#page-17">17</a>
           <a href="#section-3.4.3">3.4.3</a>. Content Encoding of FDT Instance ...................<a href="#page-21">21</a>
      <a href="#section-3.5">3.5</a>. Multiplexing of Files within a File Delivery Session ......<a href="#page-22">22</a>
   <a href="#section-4">4</a>. Channels, Congestion Control, and Timing .......................<a href="#page-23">23</a>
   <a href="#section-5">5</a>. Delivering FEC Object Transmission Information .................<a href="#page-24">24</a>
   <a href="#section-6">6</a>. Describing File Delivery Sessions ..............................<a href="#page-26">26</a>



<span class="grey">Paila, et al.                Standards Track                    [Page 2]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-3"></span>
<span class="grey"><a href="./rfc6726">RFC 6726</a>                          FLUTE                    November 2012</span>


   <a href="#section-7">7</a>. Security Considerations ........................................<a href="#page-27">27</a>
      <a href="#section-7.1">7.1</a>. Problem Statement .........................................<a href="#page-27">27</a>
      <a href="#section-7.2">7.2</a>. Attacks against the Data Flow .............................<a href="#page-28">28</a>
           <a href="#section-7.2.1">7.2.1</a>. Access to Confidential Files .......................<a href="#page-28">28</a>
           <a href="#section-7.2.2">7.2.2</a>. File Corruption ....................................<a href="#page-28">28</a>
      7.3. Attacks against the Session Control Parameters and
           Associated Building Blocks ................................<a href="#page-30">30</a>
           <a href="#section-7.3.1">7.3.1</a>. Attacks against the Session Description ............<a href="#page-30">30</a>
           <a href="#section-7.3.2">7.3.2</a>. Attacks against the FDT Instances ..................<a href="#page-31">31</a>
           <a href="#section-7.3.3">7.3.3</a>. Attacks against the ALC/LCT Parameters .............<a href="#page-31">31</a>
           <a href="#section-7.3.4">7.3.4</a>. Attacks against the Associated Building Blocks .....<a href="#page-32">32</a>
      <a href="#section-7.4">7.4</a>. Other Security Considerations .............................<a href="#page-32">32</a>
      <a href="#section-7.5">7.5</a>. Minimum Security Recommendations ..........................<a href="#page-33">33</a>
   <a href="#section-8">8</a>. IANA Considerations ............................................<a href="#page-34">34</a>
      <a href="#section-8.1">8.1</a>. Registration of the FDT Instance XML Namespace ............<a href="#page-34">34</a>
      <a href="#section-8.2">8.2</a>. Registration of the FDT Instance XML Schema ...............<a href="#page-34">34</a>
      <a href="#section-8.3">8.3</a>. Registration of the application/fdt+xml Media Type ........<a href="#page-35">35</a>
      8.4. Creation of the FLUTE Content Encoding Algorithms
           Registry ..................................................<a href="#page-36">36</a>
      <a href="#section-8.5">8.5</a>. Registration of LCT Header Extension Types ................<a href="#page-36">36</a>
   <a href="#section-9">9</a>. Acknowledgments ................................................<a href="#page-36">36</a>
   <a href="#section-10">10</a>. Contributors ..................................................<a href="#page-37">37</a>
   <a href="#section-11">11</a>. Change Log ....................................................<a href="#page-37">37</a>
      <a href="#section-11.1">11.1</a>. <a href="./rfc3926">RFC 3926</a> to This Document ................................<a href="#page-37">37</a>
   <a href="#section-12">12</a>. References ....................................................<a href="#page-40">40</a>
      <a href="#section-12.1">12.1</a>. Normative References .....................................<a href="#page-40">40</a>
      <a href="#section-12.2">12.2</a>. Informative References ...................................<a href="#page-41">41</a>
   <a href="#appendix-A">Appendix A</a>. Receiver Operation (Informative) ......................<a href="#page-44">44</a>
   <a href="#appendix-B">Appendix B</a>. Example of FDT Instance (Informative) .................<a href="#page-45">45</a>

<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/1.%20%20Introduction"></a><a class="selflink" href="#section-1" id="section-1">1</a>.  Introduction</span>

   This document defines FLUTE version 2, a protocol for unidirectional
   delivery of files over the Internet.  This specification is not
   backwards compatible with the previous experimental version defined
   in [<a href="./rfc3926" title='"FLUTE - File Delivery over Unidirectional Transport"'>RFC3926</a>] (see <a href="#section-11">Section 11</a> for details).  The specification builds
   on Asynchronous Layered Coding (ALC), version 1 [<a href="./rfc5775" title='"Asynchronous Layered Coding (ALC) Protocol Instantiation"'>RFC5775</a>], the base
   protocol designed for massively scalable multicast distribution.  ALC
   defines transport of arbitrary binary objects.  For file delivery
   applications, mere transport of objects is not enough, however.  The
   end systems need to know what the objects actually represent.  This
   document specifies a technique called FLUTE -- a mechanism for
   signaling and mapping the properties of files to concepts of ALC in a
   way that allows receivers to assign those parameters for received
   objects.  Consequently, throughout this document the term 'file'
   relates to an 'object' as discussed in ALC.  Although this





<span class="grey">Paila, et al.                Standards Track                    [Page 3]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-4"></span>
<span class="grey"><a href="./rfc6726">RFC 6726</a>                          FLUTE                    November 2012</span>


   specification frequently makes use of multicast addressing as an
   example, the techniques are similarly applicable for use with unicast
   addressing.

   This document defines a specific transport application of ALC, adding
   the following specifications:

   -  Definition of a file delivery session built on top of ALC,
      including transport details and timing constraints.

   -  In-band signaling of the transport parameters of the ALC session.

   -  In-band signaling of the properties of delivered files.

   -  Details associated with the multiplexing of multiple files within
      a session.

   This specification is structured as follows.  <a href="#section-3">Section 3</a> begins by
   defining the concept of the file delivery session.  Following that,
   it introduces the File Delivery Table, which forms the core part of
   this specification.  Further, it discusses multiplexing issues of
   transmission objects within a file delivery session.  <a href="#section-4">Section 4</a>
   describes the use of congestion control and channels with FLUTE.
   <a href="#section-5">Section 5</a> defines how the Forward Error Correction (FEC) Object
   Transmission Information is to be delivered within a file delivery
   session.  <a href="#section-6">Section 6</a> defines the required parameters for describing
   file delivery sessions in a general case.  <a href="#section-7">Section 7</a> outlines
   security considerations regarding file delivery with FLUTE.  Last,
   there are two informative appendices.  <a href="#appendix-A">Appendix A</a> describes an
   envisioned receiver operation for the receiver of the file delivery
   session.  Readers who want to see a simple example of FLUTE in
   operation should refer to <a href="#appendix-A">Appendix A</a> right away.  <a href="#appendix-B">Appendix B</a> gives an
   example of a File Delivery Table.

   This specification contains part of the definitions necessary to
   fully specify a Reliable Multicast Transport (RMT) protocol in
   accordance with [<a href="./rfc2357" title='"IETF Criteria for Evaluating Reliable Multicast Transport and Application Protocols"'>RFC2357</a>].

   This document obsoletes [<a href="./rfc3926" title='"FLUTE - File Delivery over Unidirectional Transport"'>RFC3926</a>], which contained a previous version
   of this specification and was published in the "Experimental"
   category.  This Proposed Standard specification is thus based on
   [<a href="./rfc3926" title='"FLUTE - File Delivery over Unidirectional Transport"'>RFC3926</a>] and has been updated according to accumulated experience
   and growing protocol maturity since the publication of [<a href="./rfc3926" title='"FLUTE - File Delivery over Unidirectional Transport"'>RFC3926</a>].
   Said experience applies both to this specification itself and to
   congestion control strategies related to the use of this
   specification.





<span class="grey">Paila, et al.                Standards Track                    [Page 4]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-5"></span>
<span class="grey"><a href="./rfc6726">RFC 6726</a>                          FLUTE                    November 2012</span>


   The differences between [<a href="./rfc3926" title='"FLUTE - File Delivery over Unidirectional Transport"'>RFC3926</a>] and this document are listed in
   <a href="#section-11">Section 11</a>.

   This document updates ALC [<a href="./rfc5775" title='"Asynchronous Layered Coding (ALC) Protocol Instantiation"'>RFC5775</a>] and Layered Coding Transport
   (LCT) [<a href="./rfc5651" title='"Layered Coding Transport (LCT) Building Block"'>RFC5651</a>] in the sense that it defines two new header
   extensions, EXT_FDT and EXT_CENC.

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/1.1.%20%20Applicability%20Statement"></a><a class="selflink" href="#section-1.1" id="section-1.1">1.1</a>.  Applicability Statement</span>

<span class="h4"><a class="dashAnchor" name="//apple_ref/cpp/Section/1.1.1.%20%20The%20Target%20Application%20Space"></a><a class="selflink" href="#section-1.1.1" id="section-1.1.1">1.1.1</a>.  The Target Application Space</span>

   FLUTE is applicable to the delivery of large and small files to many
   hosts, using delivery sessions of several seconds or more.  For
   instance, FLUTE could be used for the delivery of large software
   updates to many hosts simultaneously.  It could also be used for
   continuous, but segmented, data such as time-lined text for
   subtitling -- potentially leveraging its layering inheritance from
   ALC and LCT to scale the richness of the session to the congestion
   status of the network.  It is also suitable for the basic transport
   of metadata, for example, Session Description Protocol (SDP)
   [<a href="./rfc4566" title='"SDP: Session Description Protocol"'>RFC4566</a>] files that enable user applications to access multimedia
   sessions.

<span class="h4"><a class="dashAnchor" name="//apple_ref/cpp/Section/1.1.2.%20%20The%20Target%20Scale"></a><a class="selflink" href="#section-1.1.2" id="section-1.1.2">1.1.2</a>.  The Target Scale</span>

   Massive scalability is a primary design goal for FLUTE.  IP multicast
   is inherently massively scalable, but the best-effort service that it
   provides does not provide session management functionality,
   congestion control, or reliability.  FLUTE provides all of this by
   using ALC and IP multicast without sacrificing any of the inherent
   scalability of IP multicast.

<span class="h4"><a class="dashAnchor" name="//apple_ref/cpp/Section/1.1.3.%20%20Intended%20Environments"></a><a class="selflink" href="#section-1.1.3" id="section-1.1.3">1.1.3</a>.  Intended Environments</span>

   All of the environmental requirements and considerations that apply
   to the RMT building blocks used by FLUTE shall also apply to FLUTE.
   These are the ALC protocol instantiation [<a href="./rfc5775" title='"Asynchronous Layered Coding (ALC) Protocol Instantiation"'>RFC5775</a>], the LCT building
   block [<a href="./rfc5651" title='"Layered Coding Transport (LCT) Building Block"'>RFC5651</a>], and the FEC building block [<a href="./rfc5052" title='"Forward Error Correction (FEC) Building Block"'>RFC5052</a>].

   FLUTE can be used with both multicast and unicast delivery, but its
   primary application is for unidirectional multicast file delivery.
   FLUTE requires connectivity between a sender and receivers but does
   not require connectivity from receivers to a sender.  Because of its
   low expectations, FLUTE works with most types of networks, including
   LANs, WANs, Intranets, the Internet, asymmetric networks, wireless
   networks, and satellite networks.





<span class="grey">Paila, et al.                Standards Track                    [Page 5]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-6"></span>
<span class="grey"><a href="./rfc6726">RFC 6726</a>                          FLUTE                    November 2012</span>


   FLUTE is compatible with both IPv4 and IPv6, as no part of the packet
   is IP version specific.  FLUTE works with both multicast models:
   Any-Source Multicast (ASM) [<a href="./rfc1112" title='"Host extensions for IP multicasting"'>RFC1112</a>] and Source-Specific Multicast
   (SSM) [<a href="#ref-PAPER.SSM">PAPER.SSM</a>].

   FLUTE is applicable for both shared networks, such as the Internet,
   with a suitable congestion control building block; and provisioned/
   controlled networks, such as wireless broadcast radio systems, with a
   traffic-shaping building block.

<span class="h4"><a class="dashAnchor" name="//apple_ref/cpp/Section/1.1.4.%20%20Weaknesses"></a><a class="selflink" href="#section-1.1.4" id="section-1.1.4">1.1.4</a>.  Weaknesses</span>

   FLUTE congestion control protocols depend on the ability of a
   receiver to change multicast subscriptions between multicast groups
   supporting different rates and/or layered codings.  If the network
   does not support this, then the FLUTE congestion control protocols
   may not be amenable to such a network.

   FLUTE can also be used for point-to-point (unicast) communications.
   At a minimum, implementations of ALC MUST support the Wave and
   Equation Based Rate Control (WEBRC) [<a href="./rfc3738" title='"Wave and Equation Based Rate Control (WEBRC) Building Block"'>RFC3738</a>] multiple-rate
   congestion control scheme [<a href="./rfc5775" title='"Asynchronous Layered Coding (ALC) Protocol Instantiation"'>RFC5775</a>].  However, since WEBRC has been
   designed for massively scalable multicast flows, it is not clear how
   appropriate it is to the particular case of unicast flows.  Using a
   separate point-to-point congestion control scheme is another
   alternative.  How to do that is outside the scope of the present
   document.

   FLUTE provides reliability using the FEC building block.  This will
   reduce the error rate as seen by applications.  However, FLUTE does
   not provide a method for senders to verify the reception success of
   receivers, and the specification of such a method is outside the
   scope of this document.

<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/2.%20%20Conventions%20Used%20in%20This%20Document"></a><a class="selflink" href="#section-2" id="section-2">2</a>.  Conventions Used in This Document</span>

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in [<a href="./rfc2119" title='"Key words for use in RFCs to Indicate Requirement Levels"'>RFC2119</a>].

   The terms "object" and "transmission object" are consistent with the
   definitions in ALC [<a href="./rfc5775" title='"Asynchronous Layered Coding (ALC) Protocol Instantiation"'>RFC5775</a>] and LCT [<a href="./rfc5651" title='"Layered Coding Transport (LCT) Building Block"'>RFC5651</a>].  The terms "file" and
   "source object" are pseudonyms for "object".








<span class="grey">Paila, et al.                Standards Track                    [Page 6]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-7"></span>
<span class="grey"><a href="./rfc6726">RFC 6726</a>                          FLUTE                    November 2012</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/3.%20%20File%20Delivery"></a><a class="selflink" href="#section-3" id="section-3">3</a>.  File Delivery</span>

   Asynchronous Layered Coding [<a href="./rfc5775" title='"Asynchronous Layered Coding (ALC) Protocol Instantiation"'>RFC5775</a>] is a protocol designed for
   delivery of arbitrary binary objects.  It is especially suitable for
   massively scalable, unidirectional multicast distribution.  ALC
   provides the basic transport for FLUTE, and thus FLUTE inherits the
   requirements of ALC.

   This specification is designed for the delivery of files.  The core
   of this specification is to define how the properties of the files
   are carried in-band together with the delivered files.

   As an example, let us consider a 5200-byte file referred to by
   "http://www.example.com/docs/file.txt".  Using the example, the
   following properties describe the properties that need to be conveyed
   by the file delivery protocol.

   *  Identifier of the file, expressed as a URI [<a href="./rfc3986" title='"Uniform Resource Identifier (URI): Generic Syntax"'>RFC3986</a>].  The
      identifier MAY provide a location for the file.  In the above
      example: "http://www.example.com/docs/file.txt".

   *  File name (usually, this can be concluded from the URI).  In the
      above example: "file.txt".

   *  File type, expressed as Internet Media Types (often referred to as
      "Media Types").  In the above example: "text/plain".

   *  File size, expressed in octets.  In the above example: "5200".  If
      the file is content encoded, then this is the file size before
      content encoding.

   *  Content encoding of the file, within transport.  In the above
      example, the file could be encoded using ZLIB [<a href="./rfc1950" title='"ZLIB Compressed Data Format Specification version 3.3"'>RFC1950</a>].  In this
      case, the size of the transmission object carrying the file would
      probably differ from the file size.  The transmission object size
      is delivered to receivers as part of the FLUTE protocol.

   *  Security properties of the file, such as digital signatures,
      message digests, etc.  For example, one could use S/MIME [<a href="./rfc5751" title='"Secure/Multipurpose Internet Mail Extensions (S/MIME) Version 3.2 Message Specification"'>RFC5751</a>]
      as the content encoding type for files with this authentication
      wrapper, and one could use XML Digital Signatures (XML-DSIG)
      [<a href="./rfc3275" title='"(Extensible Markup Language) XML-Signature Syntax and Processing"'>RFC3275</a>] to digitally sign the file.  XML-DSIG can also be used
      to provide tamper prevention, e.g., in the Content-Location field.
      Content encoding is applied to file data before FEC protection.







<span class="grey">Paila, et al.                Standards Track                    [Page 7]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-8"></span>
<span class="grey"><a href="./rfc6726">RFC 6726</a>                          FLUTE                    November 2012</span>


   For each unique file, FLUTE encodes the attributes listed above and
   other attributes as children of an XML file element.  A table of XML
   file elements is transmitted as a special file called a 'File
   Delivery Table' (FDT), which is further described in the next
   subsection and in <a href="#section-3.2">Section 3.2</a>.

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/3.1.%20%20File%20Delivery%20Session"></a><a class="selflink" href="#section-3.1" id="section-3.1">3.1</a>.  File Delivery Session</span>

   ALC is a protocol instantiation of the Layered Coding Transport (LCT)
   building block [<a href="./rfc5651" title='"Layered Coding Transport (LCT) Building Block"'>RFC5651</a>].  Thus, ALC inherits the session concept of
   LCT.  In this document, we will use the concept of the ALC/LCT
   session to collectively denote the interchangeable terms "ALC
   session" and "LCT session".

   An ALC/LCT session consists of a set of logically grouped ALC/LCT
   channels associated with a single sender sending ALC/LCT packets for
   one or more objects.  An ALC/LCT channel is defined by the
   combination of a sender and an address associated with the channel by
   the sender.  A receiver joins a channel to start receiving the data
   packets sent to the channel by the sender, and a receiver leaves a
   channel to stop receiving data packets from the channel.

   One of the fields carried in the ALC/LCT header is the Transport
   Session Identifier (TSI), an integer carried in a field of size 16,
   32, or 48 bits (note that the TSI may be carried by other means, in
   which case it is absent from the LCT header [<a href="./rfc5651" title='"Layered Coding Transport (LCT) Building Block"'>RFC5651</a>]).  The (source
   IP address, TSI) pair uniquely identifies a session.  Note that the
   TSI is scoped by the IP address, so the same TSI may be used by
   several source IP addresses at once.  Thus, the receiver uses the
   (source IP address, TSI) pair from each packet to uniquely identify
   the session sending each packet.  When a session carries multiple
   objects, the Transmission Object Identifier (TOI) field within the
   ALC/LCT header names the object used to generate each packet.  Note
   that each object is associated with a unique TOI within the scope of
   a session.

   A FLUTE session consistent with this specification MUST use FLUTE
   version 2 as specified in this document.  Thus, all sessions
   consistent with this specification MUST set the FLUTE version to 2.
   The FLUTE version is carried within the EXT_FDT Header Extension
   (defined in <a href="#section-3.4.1">Section 3.4.1</a>) in the ALC/LCT layer.  A FLUTE session
   consistent with this specification MUST use ALC version 1 as
   specified in [<a href="./rfc5775" title='"Asynchronous Layered Coding (ALC) Protocol Instantiation"'>RFC5775</a>], and LCT version 1 as specified in [<a href="./rfc5651" title='"Layered Coding Transport (LCT) Building Block"'>RFC5651</a>].

   If multiple FLUTE sessions are sent to a channel, then receivers MUST
   determine the FLUTE protocol version, based on version fields and the
   (source IP address, TSI) pair carried in the ALC/LCT header of the
   packet.  Note that when a receiver first begins receiving packets, it



<span class="grey">Paila, et al.                Standards Track                    [Page 8]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-9"></span>
<span class="grey"><a href="./rfc6726">RFC 6726</a>                          FLUTE                    November 2012</span>


   might not know the FLUTE protocol version, as not every LCT packet
   carries the EXT_FDT header (containing the FLUTE protocol version).
   A new receiver MAY keep an open binding in the LCT protocol layer
   between the TSI and the FLUTE protocol version, until the EXT_FDT
   header arrives.  Alternatively, a new receiver MAY discover a binding
   between TSI and FLUTE protocol version via a session discovery
   protocol that is out of scope of this document.

   If the sender's IP address is not accessible to receivers, then
   packets that can be received by receivers contain an intermediate IP
   address.  In this case, the TSI is scoped by this intermediate IP
   address of the sender for the duration of the session.  As an
   example, the sender may be behind a Network Address Translation (NAT)
   device that temporarily assigns an IP address for the sender.  In
   this case, the TSI is scoped by the intermediate IP address assigned
   by the NAT.  As another example, the sender may send its original
   packets using IPv6, but some portions of the network may not be IPv6
   capable.  Thus, there may be an IPv6-to-IPv4 translator that changes
   the IP address of the packets to a different IPv4 address.  In this
   case, receivers in the IPv4 portion of the network will receive
   packets containing the IPv4 address, and thus the TSI for them is
   scoped by the IPv4 address.  How the IP address of the sender to be
   used to scope the session by receivers is delivered to receivers,
   whether it is the sender's IP address or an intermediate IP address,
   is outside the scope of this document.

   When FLUTE is used for file delivery over ALC, the ALC/LCT session is
   called a file delivery session, and the ALC/LCT concept of 'object'
   denotes either a 'file' or a 'File Delivery Table Instance'
   (<a href="#section-3.2">Section 3.2</a>).

   Additionally, the following rules apply:

   *  The TOI field MUST be included in ALC packets sent within a FLUTE
      session, with the exception that ALC packets sent in a FLUTE
      session with the Close Session (A) flag set to 1 (signaling the
      end of the session) and that contain no payload (carrying no
      information for any file or FDT) SHALL NOT carry the TOI.  See
      <a href="./rfc5651#section-5.1">Section 5.1 of [RFC5651]</a> for the LCT definition of the Close
      Session flag, and see <a href="./rfc5775#section-4.2">Section 4.2 of [RFC5775]</a> for an example of
      the use of a TOI within an ALC packet.

   *  The TOI value '0' is reserved for the delivery of File Delivery
      Table Instances.  Each non-expired File Delivery Table Instance is
      uniquely identified by an FDT Instance ID within the EXT_FDT
      header defined in <a href="#section-3.4.1">Section 3.4.1</a>.





<span class="grey">Paila, et al.                Standards Track                    [Page 9]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-10"></span>
<span class="grey"><a href="./rfc6726">RFC 6726</a>                          FLUTE                    November 2012</span>


   *  Each file in a file delivery session MUST be associated with a TOI
      (&gt;0) in the scope of that session.

   *  Information carried in the headers and the payload of a packet is
      scoped by the source IP address and the TSI.  Information
      particular to the object carried in the headers and the payload of
      a packet is further scoped by the TOI for file objects, and is
      further scoped by both the TOI and the FDT Instance ID for FDT
      Instance objects.

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/3.2.%20%20File%20Delivery%20Table"></a><a class="selflink" href="#section-3.2" id="section-3.2">3.2</a>.  File Delivery Table</span>

   The File Delivery Table (FDT) provides a means to describe various
   attributes associated with files that are to be delivered within the
   file delivery session.  The following lists are examples of such
   attributes and are not intended to be mutually exclusive or
   exhaustive.

   Attributes related to the delivery of a file:

   -  TOI value that represents the file

   -  FEC Object Transmission Information (including the FEC Encoding ID
      and, if relevant, the FEC Instance ID)

   -  Size of the transmission object carrying the file

   -  Aggregate rate of sending packets to all channels

   Attributes related to the file itself:

   -  Name, Identification, and Location of file (specified by the URI)

   -  Media type of file

   -  Size of file

   -  Encoding of file

   -  Message digest of file

   Some of these attributes MUST be included in the file description
   entry for a file; others are optional, as defined in <a href="#section-3.4.2">Section 3.4.2</a>.

   Logically, the FDT is a set of file description entries for files to
   be delivered in the session.  Each file description entry MUST
   include the TOI for the file that it describes and the URI
   identifying the file.  The TOI carried in each file description entry



<span class="grey">Paila, et al.                Standards Track                   [Page 10]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-11"></span>
<span class="grey"><a href="./rfc6726">RFC 6726</a>                          FLUTE                    November 2012</span>


   is how FLUTE names the ALC/LCT data packets used for delivery of the
   file.  Each file description entry may also contain one or more
   descriptors that map the above-mentioned attributes to the file.

   Each file delivery session MUST have an FDT that is local to the
   given session.  The FDT MUST provide a file description entry mapped
   to a TOI for each file appearing within the session.  An object that
   is delivered within the ALC session, but not described in the FDT,
   other than the FDT itself, is not considered a 'file' belonging to
   the file delivery session.  This object received with an unmapped TOI
   (non-zero TOI that is not resolved by the FDT) SHOULD in general be
   ignored by a FLUTE receiver.  The details of how to do that are out
   of scope of this specification.

   Note that a client that joins an active file delivery session MAY
   receive data packets for a TOI &gt; 0 before receiving any FDT Instance
   (see <a href="#section-3.3">Section 3.3</a> for recommendations on how to limit the probability
   that this situation will occur).  Even if the TOI is not mapped to
   any file description entry, this is hopefully a transient situation.
   When this happens, system performance might be improved by caching
   such packets within a reasonable time window and storage size.  Such
   optimizations are use-case and implementation specific, and further
   details are beyond the scope of this document.

   Within the file delivery session, the FDT is delivered as FDT
   Instances.  An FDT Instance contains one or more file description
   entries of the FDT.  Any FDT Instance can be equal to, be a subset
   of, be a superset of, overlap with, or complement any other FDT
   Instance.  A certain FDT Instance may be repeated multiple times
   during a session, even after subsequent FDT Instances (with higher
   FDT Instance ID numbers) have been transmitted.  Each FDT Instance
   contains at least a single file description entry and at most the
   exhaustive set of file description entries of the files being
   delivered in the file delivery session.

   A receiver of the file delivery session keeps an FDT database for
   received file description entries.  The receiver maintains the
   database, for example, upon reception of FDT Instances.  Thus, at any
   given time the contents of the FDT database represent the receiver's
   current view of the FDT of the file delivery session.  Since each
   receiver behaves independently of other receivers, it SHOULD NOT be
   assumed that the contents of the FDT database are the same for all
   the receivers of a given file delivery session.

   Since the FDT database is an abstract concept, the structure and the
   maintenance of the FDT database are left to individual
   implementations and are thus out of scope of this specification.




<span class="grey">Paila, et al.                Standards Track                   [Page 11]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-12"></span>
<span class="grey"><a href="./rfc6726">RFC 6726</a>                          FLUTE                    November 2012</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/3.3.%20%20Dynamics%20of%20FDT%20Instances%20within%20a%20File%20Delivery%20Session"></a><a class="selflink" href="#section-3.3" id="section-3.3">3.3</a>.  Dynamics of FDT Instances within a File Delivery Session</span>

   The following rules define the dynamics of the FDT Instances within a
   file delivery session:

   *  For every file delivered within a file delivery session, there
      MUST be a file description entry included in at least one FDT
      Instance sent within the session.  A file description entry
      contains at a minimum the mapping between the TOI and the URI.

   *  An FDT Instance MAY appear in any part of the file delivery
      session, and packets for an FDT Instance MAY be interleaved with
      packets for other files or other FDT Instances within a session.

   *  The TOI value of '0' MUST be reserved for delivery of FDT
      Instances.  The use of other TOI values (i.e., an integer &gt; 0) for
      FDT Instances is outside the scope of this specification.

   *  The FDT Instance is identified by the use of a new fixed-length
      LCT Header Extension, EXT_FDT (defined later in this section).
      Each non-expired FDT Instance is uniquely identified within the
      file delivery session by its FDT Instance ID, carried by the
      EXT_FDT Header Extension.  Any ALC/LCT packet carrying an FDT
      Instance MUST include EXT_FDT.

   *  It is RECOMMENDED that an FDT Instance that contains the file
      description entry for a file be sent at least once before sending
      the described file within a file delivery session.  This
      recommendation is intended to minimize the amount of file data
      that may be received by receivers in advance of the FDT Instance
      containing the entry for a file (such data must either be
      speculatively buffered or discarded).  Note that this possibility
      cannot be completely eliminated, since the first transmission of
      FDT data might be lost.

   *  Within a file delivery session, any TOI &gt; 0 MAY be described more
      than once.  For example, a previous FDT Instance 0 describes a TOI
      of value '3'.  Now, subsequent FDT Instances can either keep TOI
      '3' unmodified in the table, not include it, or augment the
      description.  However, subsequent FDT Instances MUST NOT change
      the parameters already described for a specific TOI.

   *  An FDT Instance is valid until its expiration time.  The
      expiration time is expressed within the FDT Instance payload as a
      UTF-8 decimal representation of a 32-bit unsigned integer.  The
      value of this integer represents the 32 most significant bits of a
      64-bit Network Time Protocol (NTP) [<a href="./rfc5905" title='"Network Time Protocol Version 4: Protocol and Algorithms Specification"'>RFC5905</a>] time value.  These
      32 bits provide an unsigned integer representing the time in



<span class="grey">Paila, et al.                Standards Track                   [Page 12]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-13"></span>
<span class="grey"><a href="./rfc6726">RFC 6726</a>                          FLUTE                    November 2012</span>


      seconds relative to 0 hours 1 January 1900 in the case of the
      prime epoch (era 0) [<a href="./rfc5905" title='"Network Time Protocol Version 4: Protocol and Algorithms Specification"'>RFC5905</a>].  The handling of time wraparound
      (to happen in 2036) requires that the associated epoch be
      considered.  In any case, both a sender and a receiver easily
      determine to which (136-year) epoch the FDT Instance expiration
      time value pertains by choosing the epoch for which the expiration
      time is closest in time to the current time.

      Here is an example.  Let us imagine that a new FLUTE session is
      started on February 7th, 2036, 0h, i.e., at NTP time
      4,294,944,000, a few hours before the end of epoch 0.  In order to
      define an FDT Instance valid for the next 48 hours, The FLUTE
      sender sets an expiry time of 149,504.  This FDT Instance will
      expire exactly on February 9th, 2036, 0h.  A client that receives
      this FDT Instance on the 7th, 0h, just after it has been sent,
      immediately understands that this value corresponds to epoch 1.  A
      client that joins the session on February 8th, 0h, i.e., at NTP
      time 63,104, epoch 1, immediately understands that the 149,504 NTP
      timestamp corresponds to epoch 1.

   *  The space of FDT Instance IDs is limited by the associated field
      size (i.e., 20 bits) in the EXT_FDT Header Extension
      (<a href="#section-3.4.1">Section 3.4.1</a>).  Therefore, senders should take care to always
      have a large enough supply of available FDT Instance IDs when
      specifying FDT expiration times.

   *  The receiver MUST NOT use a received FDT Instance to interpret
      packets received beyond the expiration time of the FDT Instance.

   *  A sender MUST use an expiration time in the future upon creation
      of an FDT Instance relative to its Sender Current Time (SCT).

   *  Any FEC Encoding ID MAY be used for the sending of FDT Instances.
      The default is to use the Compact No-Code FEC Encoding ID 0
      [<a href="./rfc5445" title='"Basic Forward Error Correction (FEC) Schemes"'>RFC5445</a>] for the sending of FDT Instances.  (Note that since FEC
      Encoding ID 0 is the default for FLUTE, this implies that Source
      Block Number and Encoding Symbol ID lengths both default to
      16 bits each.)

   *  If the receiver does not support the FEC Scheme indicated by the
      FEC Encoding ID, the receiver MUST NOT decode the associated FDT.

   *  It is RECOMMENDED that the mechanisms used for file attribute
      delivery SHOULD achieve a delivery probability that is higher than
      the file recovery probability and the file attributes SHOULD be
      delivered at this higher priority before the delivery of the
      associated files begins.




<span class="grey">Paila, et al.                Standards Track                   [Page 13]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-14"></span>
<span class="grey"><a href="./rfc6726">RFC 6726</a>                          FLUTE                    November 2012</span>


   Generally, a receiver needs to receive an FDT Instance describing a
   file before it is able to recover the file itself.  In this sense,
   FDT Instances are of higher priority than files.  Additionally, a
   FLUTE sender SHOULD assume that receivers will not receive all
   packets pertaining to FDT Instances.  The way FDT Instances are
   transmitted has a large impact on satisfying the recommendation
   above.  When there is a single file transmitted in the session, one
   way to satisfy the recommendation above is to repeatedly transmit on
   a regular enough basis FDT Instances describing the file while the
   file is being transmitted.  If an FDT Instance is longer than one
   packet payload in length, it is RECOMMENDED that an FEC code that
   provides protection against loss be used for delivering this FDT
   Instance.  When there are multiple files in a session concurrently
   being transmitted to receivers, the way the FDT Instances are
   structured and transmitted also has a large impact.  As an example, a
   way to satisfy the recommendation above is to transmit an FDT
   Instance that describes all files currently being transmitted, and to
   transmit this FDT Instance reliably, using the same techniques as
   explained for the case when there is a single file transmitted in a
   session.  If instead the concurrently transmitted files are described
   in separate FDT Instances, another way to satisfy this recommendation
   is to transmit all the relevant FDT Instances reliably, using the
   same techniques as explained for the case when there is a single file
   transmitted in a session.

   In any case, how often the description of a file is sent in an FDT
   Instance, how often an FDT Instance is sent, and how much FEC
   protection is provided for an FDT Instance (if longer than one packet
   payload) are dependent on the particular application and are outside
   the scope of this document.

   Sometimes the various attributes associated with files that are to be
   delivered within the file delivery session are sent out-of-band.  The
   details of how this is done are out of the scope of this document.
   However, it is still RECOMMENDED that any out-of-band transmission be
   managed in such a way that a receiver will be able to recover the
   attributes associated with a file at least as reliably as the
   receiver is able to receive enough packets containing encoding
   symbols to recover the file.  For example, the probability of a
   randomly chosen receiver being able to recover a given file can often
   be estimated based on a statistical model of reception conditions,
   the amount of data transmitted, and the properties of any Forward
   Error Correction in use.  The recommendation above suggests that
   mechanisms used for file attribute delivery should achieve a higher
   delivery probability than the file recovery probability.  The sender
   MAY also continue sending the various file attributes in-band, in
   addition to the out-of-band transmission.




<span class="grey">Paila, et al.                Standards Track                   [Page 14]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-15"></span>
<span class="grey"><a href="./rfc6726">RFC 6726</a>                          FLUTE                    November 2012</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/3.4.%20%20Structure%20of%20FDT%20Instance%20Packets"></a><a class="selflink" href="#section-3.4" id="section-3.4">3.4</a>.  Structure of FDT Instance Packets</span>

   FDT Instances are carried in ALC packets with TOI = 0 and with an
   additional REQUIRED LCT Header extension called the FDT Instance
   Header.  The FDT Instance Header (EXT_FDT) contains the FDT Instance
   ID that uniquely identifies FDT Instances within a file delivery
   session.  Placement of the FDT Instance Header is the same as that of
   any other LCT Header Extension.  There MAY be other LCT Header
   Extensions in use.

   The FDT Instance is encoded for transmission, like any other object,
   using an FEC Scheme (which MAY be the Compact No-Code FEC Scheme).
   The LCT Header Extensions are followed by the FEC Payload ID, and
   finally the Encoding Symbols for the FDT Instance, which contains one
   or more file description entries.  An FDT Instance MAY span several
   ALC packets -- the number of ALC packets is a function of the file
   attributes associated with the FDT Instance.  The FDT Instance Header
   is carried in each ALC packet carrying the FDT Instance.  The FDT
   Instance Header is identical for all ALC/LCT packets for a particular
   FDT Instance.

   The overall format of ALC/LCT packets carrying an FDT Instance is
   depicted in Figure 1 below.  All integer fields are carried in
   "big-endian" or "network order" format (i.e., most significant byte
   (octet) first).  As defined in [<a href="./rfc5775" title='"Asynchronous Layered Coding (ALC) Protocol Instantiation"'>RFC5775</a>], all ALC/LCT packets are
   sent using UDP.

   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                         UDP header                            |
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                Default LCT header (with TOI = 0)              |
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |          LCT Header Extensions (EXT_FDT, EXT_FTI, etc.)       |
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                       FEC Payload ID                          |
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                  FLUTE Payload: Encoding Symbol(s)
   ~             (for FDT Instance in an FDT packet)               ~

   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                       Figure 1: Overall FDT Packet





<span class="grey">Paila, et al.                Standards Track                   [Page 15]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-16"></span>
<span class="grey"><a href="./rfc6726">RFC 6726</a>                          FLUTE                    November 2012</span>


<span class="h4"><a class="dashAnchor" name="//apple_ref/cpp/Section/3.4.1.%20%20Format%20of%20FDT%20Instance%20Header"></a><a class="selflink" href="#section-3.4.1" id="section-3.4.1">3.4.1</a>.  Format of FDT Instance Header</span>

   The FDT Instance Header (EXT_FDT) is a new fixed-length, ALC
   Protocol-Instantiation-specific LCT Header Extension [<a href="./rfc5651" title='"Layered Coding Transport (LCT) Building Block"'>RFC5651</a>].  The
   Header Extension Type (HET) for the extension is 192.  Its format is
   defined below:

    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |   HET = 192   |   V   |          FDT Instance ID              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                         Figure 2: EXT_FDT Format

   Version of FLUTE (V), 4 bits:

   This document specifies FLUTE version 2.  Hence, in any ALC packet
   that carries an FDT Instance and that belongs to the file delivery
   session as specified in this specification MUST set this field
   to '2'.

   FDT Instance ID, 20 bits:

   For each file delivery session, the numbering of FDT Instances starts
   from '0' and is incremented by one for each subsequent FDT Instance.
   After reaching the maximum value (2^20-1), the numbering starts from
   the smallest FDT Instance ID value assigned to an expired FDT
   Instance.  When wraparound from a greater FDT Instance ID value to a
   smaller FDT Instance ID value occurs, the smaller FDT Instance ID
   value is considered logically higher than the greater FDT Instance ID
   value.  Then, the subsequent FDT Instances are assigned the next
   available smallest FDT Instance ID value, in order to always keep the
   FDT Instance ID values logically increasing.

   Senders MUST NOT reuse an FDT Instance ID value that is already in
   use for a non-expired FDT Instance.  Sender behavior when all the FDT
   Instance IDs are used by non-expired FEC Instances is outside the
   scope of this specification and left to individual implementations of
   FLUTE.  Receipt of an FDT Instance that reuses an FDT Instance ID
   value that is currently used by a non-expired FDT Instance MUST be
   considered an error case.  Receiver behavior in this case (e.g.,
   leave the session or ignore the new FDT Instance) is outside the
   scope of this specification and left to individual implementations of
   FLUTE.  Receivers MUST be ready to handle FDT Instance ID wraparound
   and situations where missing FDT Instance IDs result in increments
   larger than one.




<span class="grey">Paila, et al.                Standards Track                   [Page 16]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-17"></span>
<span class="grey"><a href="./rfc6726">RFC 6726</a>                          FLUTE                    November 2012</span>


<span class="h4"><a class="dashAnchor" name="//apple_ref/cpp/Section/3.4.2.%20%20Syntax%20of%20FDT%20Instance"></a><a class="selflink" href="#section-3.4.2" id="section-3.4.2">3.4.2</a>.  Syntax of FDT Instance</span>

   The FDT Instance contains file description entries that provide the
   mapping functionality described in <a href="#section-3.2">Section 3.2</a> above.

   The FDT Instance is an Extensible Markup Language (XML) structure
   that has a single root element "FDT-Instance".  The "FDT-Instance"
   element MUST contain the "Expires" attribute, which provides the
   expiration time of the FDT Instance.  In addition, the "FDT-Instance"
   element MAY contain the "Complete" attribute, a boolean that can be
   either set to '1' or 'true' for TRUE, or '0' or 'false' for FALSE.
   When TRUE, the "Complete" attribute signals that this "FDT Instance"
   includes the set of "File" entries that exhausts both the set of
   files delivered so far and the set of files to be delivered in the
   session.  This implies that no new data will be provided in future
   FDT Instances within this session (i.e., that either FDT Instances
   with higher ID numbers will not be used or, if they are used, will
   only provide file parameters identical to those already given in this
   and previous FDT Instances).  The "Complete" attribute is therefore
   used to provide a complete list of files in an entire FLUTE session
   (a "complete FDT").  Note that when all the FDT Instances received so
   far have no "Complete" attribute, the receiver MUST consider that the
   session is not complete and that new data MAY be provided in future
   FDT Instances.  This is equivalent to receiving FDT Instances having
   the "Complete" attribute set to FALSE.

   The "FDT-Instance" element MAY contain attributes that give common
   parameters for all files of an FDT Instance.  These attributes MAY
   also be provided for individual files in the "File" element.  Where
   the same attribute appears in both the "FDT-Instance" and the "File"
   elements, the value of the attribute provided in the "File" element
   takes precedence.

   For each file to be declared in the given FDT Instance, there is a
   single file description entry in the FDT Instance.  Each entry is
   represented by element "File", which is a child element of the FDT
   Instance structure.

   The attributes of the "File" element in the XML structure represent
   the attributes given to the file that is delivered in the file
   delivery session.  The value of the XML attribute name corresponds to
   the MIME field name, and the XML attribute value corresponds to the
   value of the MIME field body [<a href="./rfc2045" title='"Multipurpose Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies"'>RFC2045</a>].  Each "File" element MUST
   contain at least two attributes: "TOI" and "Content-Location".  "TOI"
   MUST be assigned a valid TOI value as described in <a href="#section-3.3">Section 3.3</a>.
   "Content-Location" [<a href="./rfc2616" title='"Hypertext Transfer Protocol -- HTTP/1.1"'>RFC2616</a>] MUST be assigned a syntactically valid
   URI, as defined in [<a href="./rfc3986" title='"Uniform Resource Identifier (URI): Generic Syntax"'>RFC3986</a>], which identifies the file to be
   delivered.  For example, it can be a URI with the "http" or "file"



<span class="grey">Paila, et al.                Standards Track                   [Page 17]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-18"></span>
<span class="grey"><a href="./rfc6726">RFC 6726</a>                          FLUTE                    November 2012</span>


   URI scheme.  Only one "Content-Location" attribute is allowed for
   each file.  The "Content-Location" field MUST be considered a string
   that identifies a file (i.e., two different strings are two different
   identifiers).  Any use of the "Content-Location" field for anything
   else other than to identify the object is out of scope of this
   specification.  The semantics for any two "File" elements declaring
   the same "Content-Location" but differing "TOI" is that the element
   appearing in the FDT Instance with the greater FDT Instance ID is
   considered to declare a newer instance (e.g., version) of the same
   "File".

   In addition to mandatory attributes, the "FDT-Instance" element and
   the "File" element MAY contain other attributes, of which the
   following are specifically pointed out:

   *  The attribute "Content-Type" SHOULD be included and, when present,
      MUST be used for the purpose defined in [<a href="./rfc2616" title='"Hypertext Transfer Protocol -- HTTP/1.1"'>RFC2616</a>].

   *  Where the length is described, the attribute "Content-Length" MUST
      be used for the purpose defined in [<a href="./rfc2616" title='"Hypertext Transfer Protocol -- HTTP/1.1"'>RFC2616</a>].  The transfer length
      is defined to be the length of the object transported in octets.
      It is often important to convey the transfer length to receivers,
      because the source block structure needs to be known for the FEC
      decoder to be applied to recover source blocks of the file, and
      the transfer length is often needed to properly determine the
      source block structure of the file.  There generally will be a
      difference between the length of the original file and the
      transfer length if content encoding is applied to the file before
      transport, and thus the "Content-Encoding" attribute is used.  If
      the file is not content encoded before transport (and thus the
      "Content-Encoding" attribute is not used), then the transfer
      length is the length of the original file, and in this case the
      "Content-Length" is also the transfer length.  However, if the
      file is content encoded before transport (and thus the
      "Content-Encoding" attribute is used), e.g., if compression is
      applied before transport to reduce the number of octets that need
      to be transferred, then the transfer length is generally different
      than the length of the original file, and in this case the
      attribute "Transfer-Length" MAY be used to carry the transfer
      length.

   *  Whenever content encoding is applied, the attribute
      "Content-Encoding" MUST be included.  Whenever the attribute
      "Content-Encoding" is included, it MUST be used as described in
      [<a href="./rfc2616" title='"Hypertext Transfer Protocol -- HTTP/1.1"'>RFC2616</a>].






<span class="grey">Paila, et al.                Standards Track                   [Page 18]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-19"></span>
<span class="grey"><a href="./rfc6726">RFC 6726</a>                          FLUTE                    November 2012</span>


   *  Where the MD5 message digest is described, the attribute
      "Content-MD5" MUST be used for the purpose defined in [<a href="./rfc2616" title='"Hypertext Transfer Protocol -- HTTP/1.1"'>RFC2616</a>].
      Note that the goal is to provide a decoded object integrity
      service in cases where transmission and/or FLUTE/ALC processing
      errors may occur (the probability of collision is in that case
      negligible).  It MUST NOT be regarded as a security mechanism (see
      <a href="#section-7">Section 7</a> for information regarding security measures).

   *  The FEC Object Transmission Information attributes are described
      in <a href="#section-5">Section 5</a>.

   The following specifies the XML Schema [<a href="#ref-XML-Schema-Part-1">XML-Schema-Part-1</a>]
   [<a href="#ref-XML-Schema-Part-2">XML-Schema-Part-2</a>] for the FDT Instance:

   BEGIN
   &lt;?xml version="1.0" encoding="UTF-8"?&gt;
   &lt;xs:schema xmlns="urn:ietf:params:xml:ns:fdt"
              xmlns:xs="http://www.w3.org/2001/XMLSchema"
              targetNamespace="urn:ietf:params:xml:ns:fdt"
              elementFormDefault="qualified"&gt;
     &lt;xs:element name="FDT-Instance" type="FDT-InstanceType"/&gt;
     &lt;xs:complexType name="FDT-InstanceType"&gt;
       &lt;xs:sequence&gt;
         &lt;xs:element name="File" type="FileType" maxOccurs="unbounded"/&gt;
         &lt;xs:any namespace="##other" processContents="skip"
                 minOccurs="0" maxOccurs="unbounded"/&gt;
       &lt;/xs:sequence&gt;
       &lt;xs:attribute name="Expires"
                     type="xs:string"
                     use="required"/&gt;
       &lt;xs:attribute name="Complete"
                     type="xs:boolean"
                     use="optional"/&gt;
       &lt;xs:attribute name="Content-Type"
                     type="xs:string"
                     use="optional"/&gt;
       &lt;xs:attribute name="Content-Encoding"
                     type="xs:string"
                     use="optional"/&gt;
       &lt;xs:attribute name="FEC-OTI-FEC-Encoding-ID"
                     type="xs:unsignedByte"
                     use="optional"/&gt;
       &lt;xs:attribute name="FEC-OTI-FEC-Instance-ID"
                     type="xs:unsignedLong"
                     use="optional"/&gt;
       &lt;xs:attribute name="FEC-OTI-Maximum-Source-Block-Length"
                     type="xs:unsignedLong"
                     use="optional"/&gt;



<span class="grey">Paila, et al.                Standards Track                   [Page 19]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-20"></span>
<span class="grey"><a href="./rfc6726">RFC 6726</a>                          FLUTE                    November 2012</span>


       &lt;xs:attribute name="FEC-OTI-Encoding-Symbol-Length"
                     type="xs:unsignedLong"
                     use="optional"/&gt;
       &lt;xs:attribute name="FEC-OTI-Max-Number-of-Encoding-Symbols"
                     type="xs:unsignedLong"
                     use="optional"/&gt;
       &lt;xs:attribute name="FEC-OTI-Scheme-Specific-Info"
                     type="xs:base64Binary"
                     use="optional"/&gt;
       &lt;xs:anyAttribute processContents="skip"/&gt;
     &lt;/xs:complexType&gt;
     &lt;xs:complexType name="FileType"&gt;
       &lt;xs:sequence&gt;
         &lt;xs:any namespace="##other" processContents="skip"
                 minOccurs="0" maxOccurs="unbounded"/&gt;
       &lt;/xs:sequence&gt;
       &lt;xs:attribute name="Content-Location"
                     type="xs:anyURI"
                     use="required"/&gt;
       &lt;xs:attribute name="TOI"
                     type="xs:positiveInteger"
                     use="required"/&gt;
       &lt;xs:attribute name="Content-Length"
                     type="xs:unsignedLong"
                     use="optional"/&gt;
       &lt;xs:attribute name="Transfer-Length"
                     type="xs:unsignedLong"
                     use="optional"/&gt;
       &lt;xs:attribute name="Content-Type"
                     type="xs:string"
                     use="optional"/&gt;
       &lt;xs:attribute name="Content-Encoding"
                     type="xs:string"
                     use="optional"/&gt;
       &lt;xs:attribute name="Content-MD5"
                     type="xs:base64Binary"
                     use="optional"/&gt;
       &lt;xs:attribute name="FEC-OTI-FEC-Encoding-ID"
                     type="xs:unsignedByte"
                     use="optional"/&gt;
       &lt;xs:attribute name="FEC-OTI-FEC-Instance-ID"
                     type="xs:unsignedLong"
                     use="optional"/&gt;
       &lt;xs:attribute name="FEC-OTI-Maximum-Source-Block-Length"
                     type="xs:unsignedLong"
                     use="optional"/&gt;





<span class="grey">Paila, et al.                Standards Track                   [Page 20]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-21"></span>
<span class="grey"><a href="./rfc6726">RFC 6726</a>                          FLUTE                    November 2012</span>


       &lt;xs:attribute name="FEC-OTI-Encoding-Symbol-Length"
                     type="xs:unsignedLong"
                     use="optional"/&gt;
       &lt;xs:attribute name="FEC-OTI-Max-Number-of-Encoding-Symbols"
                     type="xs:unsignedLong"
                     use="optional"/&gt;
       &lt;xs:attribute name="FEC-OTI-Scheme-Specific-Info"
                     type="xs:base64Binary"
                     use="optional"/&gt;
       &lt;xs:anyAttribute processContents="skip"/&gt;
     &lt;/xs:complexType&gt;
   &lt;/xs:schema&gt;
   END

                 Figure 3: XML Schema for the FDT Instance

   Any valid FDT Instance MUST use the above XML Schema.  This way, FDT
   provides extensibility to support private elements and private
   attributes within the file description entries.  Those could be, for
   example, the attributes related to the delivery of the file (timing,
   packet transmission rate, etc.).  Unsupported private elements and
   attributes SHOULD be silently ignored by a FLUTE receiver.

   In case the basic FDT XML Schema is extended in terms of new
   descriptors (attributes or elements), for descriptors applying to a
   single file, those MUST be placed within the element "File".  For
   descriptors applying to all files described by the current FDT
   Instance, those MUST be placed within the element "FDT-Instance".  It
   is RECOMMENDED that the new attributes applied in the FDT be in the
   format of message header fields and be either defined in the HTTP/1.1
   specification [<a href="./rfc2616" title='"Hypertext Transfer Protocol -- HTTP/1.1"'>RFC2616</a>] or another well-known specification, or in an
   IANA registry [<a href="#ref-IANAheaderfields">IANAheaderfields</a>].  However, this specification
   doesn't prohibit the use of other formats to allow private attributes
   to be used when interoperability is not a concern.

<span class="h4"><a class="dashAnchor" name="//apple_ref/cpp/Section/3.4.3.%20%20Content%20Encoding%20of%20FDT%20Instance"></a><a class="selflink" href="#section-3.4.3" id="section-3.4.3">3.4.3</a>.  Content Encoding of FDT Instance</span>

   The FDT Instance itself MAY be content encoded (e.g., compressed).
   This specification defines the FDT Instance Content Encoding Header
   (EXT_CENC).  EXT_CENC is a new fixed-length LCT Header Extension
   [<a href="./rfc5651" title='"Layered Coding Transport (LCT) Building Block"'>RFC5651</a>].  The Header Extension Type (HET) for the extension is 193.
   If the FDT Instance is content encoded, EXT_CENC MUST be used to
   signal the content encoding type.  In that case, the EXT_CENC Header
   Extension MUST be used in all ALC packets carrying the same FDT
   Instance ID.  Consequently, when the EXT_CENC header is used, it MUST
   be used together with a proper FDT Instance Header (EXT_FDT).  Within
   a file delivery session, FDT Instances that are not content encoded
   and FDT Instances that are content encoded MAY both appear.  If



<span class="grey">Paila, et al.                Standards Track                   [Page 21]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-22"></span>
<span class="grey"><a href="./rfc6726">RFC 6726</a>                          FLUTE                    November 2012</span>


   content encoding is not used for a given FDT Instance, EXT_CENC MUST
   NOT be used in any packet carrying the FDT Instance.  The format of
   EXT_CENC is defined below:

    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |   HET = 193   |     CENC      |          Reserved             |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                         Figure 4: EXT_CENC Format

   Content Encoding Algorithm (CENC), 8 bits:

   This field signals the content encoding algorithm used in the FDT
   Instance payload.  This subsection reserves the Content Encoding
   Algorithm values 0, 1, 2, and 3 for null, ZLIB [<a href="./rfc1950" title='"ZLIB Compressed Data Format Specification version 3.3"'>RFC1950</a>], DEFLATE
   [<a href="./rfc1951" title='"DEFLATE Compressed Data Format Specification version 1.3"'>RFC1951</a>], and GZIP [<a href="./rfc1952" title='"GZIP file format specification version 4.3"'>RFC1952</a>], respectively.

   Reserved, 16 bits:

   This field MUST be set to all '0's.  This field MUST be ignored on
   reception.

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/3.5.%20%20Multiplexing%20of%20Files%20within%20a%20File%20Delivery%20Session"></a><a class="selflink" href="#section-3.5" id="section-3.5">3.5</a>.  Multiplexing of Files within a File Delivery Session</span>

   The delivered files are carried as transmission objects (identified
   with TOIs) in the file delivery session.  All these objects,
   including the FDT Instances, MAY be multiplexed in any order and in
   parallel with each other within a session; i.e., packets for one file
   may be interleaved with packets for other files or other FDT
   Instances within a session.

   Multiple FDT Instances MAY be delivered in a single session using
   TOI = 0.  In this case, it is RECOMMENDED that the sending of a
   previous FDT Instance SHOULD end before the sending of the next FDT
   Instance starts.  However, due to unexpected network conditions,
   packets for the FDT Instances might be interleaved.  A receiver can
   determine which FDT Instance a packet contains information about,
   since the FDT Instances are uniquely identified by their FDT Instance
   ID carried in the EXT_FDT headers.










<span class="grey">Paila, et al.                Standards Track                   [Page 22]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-23"></span>
<span class="grey"><a href="./rfc6726">RFC 6726</a>                          FLUTE                    November 2012</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/4.%20%20Channels%2C%20Congestion%20Control%2C%20and%20Timing"></a><a class="selflink" href="#section-4" id="section-4">4</a>.  Channels, Congestion Control, and Timing</span>

   ALC/LCT has a concept of channels and congestion control.  There are
   four scenarios in which FLUTE is envisioned to be applied.

   (a)  Use of a single channel and a single-rate congestion control
        protocol.

   (b)  Use of multiple channels and a multiple-rate congestion control
        protocol.  In this case, the FDT Instances MAY be delivered on
        more than one channel.

   (c)  Use of a single channel without congestion control supplied by
        ALC, but only when in a controlled network environment where
        flow/congestion control is being provided by other means.

   (d)  Use of multiple channels without congestion control supplied by
        ALC, but only when in a controlled network environment where
        flow/congestion control is being provided by other means.  In
        this case, the FDT Instances MAY be delivered on more than one
        channel.

   When using just one channel for a file delivery session, as in (a)
   and (c), the notion of 'prior' and 'after' are intuitively defined
   for the delivery of objects with respect to their delivery times.

   However, if multiple channels are used, as in (b) and (d), it is not
   straightforward to state that an object was delivered 'prior' to the
   other.  An object may begin to be delivered on one or more of those
   channels before the delivery of a second object begins.  However, the
   use of multiple channels/layers may mean that the delivery of the
   second object is completed before the first.  This is not a problem
   when objects are delivered sequentially using a single channel.
   Thus, if the application of FLUTE has a mandatory or critical
   requirement that the first transmission object must complete 'prior'
   to the second one, it is RECOMMENDED that only a single channel be
   used for the file delivery session.














<span class="grey">Paila, et al.                Standards Track                   [Page 23]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-24"></span>
<span class="grey"><a href="./rfc6726">RFC 6726</a>                          FLUTE                    November 2012</span>


   Furthermore, if multiple channels are used, then a receiver joined to
   the session at a low reception rate will only be joined to the lower
   layers of the session.  Thus, since the reception of FDT Instances is
   of higher priority than the reception of files (because the reception
   of files depends on the reception of an FDT Instance describing it),
   the following are RECOMMENDED:

   1.  The layers to which packets for FDT Instances are sent SHOULD NOT
       be biased towards those layers to which lower-rate receivers are
       not joined.  For example, it is okay to put all the packets for
       an FDT Instance into the lowest layer (if this layer carries
       enough packets to deliver the FDT to higher-rate receivers in a
       reasonable amount of time), but it is not okay to put all the
       packets for an FDT Instance into the higher layers that only
       higher-rate receivers will receive.

   2.  If FDT Instances are generally longer than one Encoding Symbol in
       length and some packets for FDT Instances are sent to layers that
       lower-rate receivers do not receive, an FEC encoding other than
       Compact No-Code FEC Encoding ID 0 [<a href="./rfc5445" title='"Basic Forward Error Correction (FEC) Schemes"'>RFC5445</a>] SHOULD be used to
       deliver FDT Instances.  This is because in this case, even when
       there is no packet loss in the network, a lower-rate receiver
       will not receive all packets sent for an FDT Instance.

<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/5.%20%20Delivering%20FEC%20Object%20Transmission%20Information"></a><a class="selflink" href="#section-5" id="section-5">5</a>.  Delivering FEC Object Transmission Information</span>

   FLUTE inherits the use of the FEC building block [<a href="./rfc5052" title='"Forward Error Correction (FEC) Building Block"'>RFC5052</a>] from ALC.
   When using FLUTE for file delivery over ALC, the FEC Object
   Transmission Information MUST be delivered in-band within the file
   delivery session.  There are two methods to achieve this: the use of
   the ALC-specific LCT Header Extension EXT_FTI [<a href="./rfc5775" title='"Asynchronous Layered Coding (ALC) Protocol Instantiation"'>RFC5775</a>] and the use
   of the FDT.  The latter method is specified in this section.  The use
   of EXT_FTI requires repetition of the FEC Object Transmission
   Information to ensure reception (though not necessarily in every
   packet) and thus may entail higher overhead than the use of the FDT,
   but may also provide more timely delivery of the FEC Object
   Transmission Information.

   The receiver of a file delivery session MUST support delivery of FEC
   Object Transmission Information using EXT_FTI for the FDT Instances
   carried using TOI value 0.  For the TOI values other than 0, the
   receiver MUST support both methods: the use of EXT_FTI and the use of
   the FDT.








<span class="grey">Paila, et al.                Standards Track                   [Page 24]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-25"></span>
<span class="grey"><a href="./rfc6726">RFC 6726</a>                          FLUTE                    November 2012</span>


   The FEC Object Transmission Information that needs to be delivered to
   receivers MUST be exactly the same whether it is delivered using
   EXT_FTI or using the FDT (or both).  The FEC Object Transmission
   Information that MUST be delivered to receivers is defined by the FEC
   Scheme.  This section describes the delivery using the FDT.

   The FEC Object Transmission Information regarding a given TOI may be
   available from several sources.  In this case, it is RECOMMENDED that
   the receiver of the file delivery session prioritize the sources in
   the following way (in order of decreasing priority).

   1.  FEC Object Transmission Information that is available in EXT_FTI.

   2.  FEC Object Transmission Information that is available in the FDT.

   The FDT delivers FEC Object Transmission Information for each file
   using an appropriate attribute within the "FDT-Instance" or the
   "File" element of the FDT structure.

   *  "Transfer-Length" carries the "Transfer-Length" Object
      Transmission Information element defined in [<a href="./rfc5052" title='"Forward Error Correction (FEC) Building Block"'>RFC5052</a>].

   *  "FEC-OTI-FEC-Encoding-ID" carries the "FEC Encoding ID" Object
      Transmission Information element defined in [<a href="./rfc5052" title='"Forward Error Correction (FEC) Building Block"'>RFC5052</a>], as carried
      in the Codepoint field of the ALC/LCT header.

   *  "FEC-OTI-FEC-Instance-ID" carries the "FEC Instance ID" Object
      Transmission Information element defined in [<a href="./rfc5052" title='"Forward Error Correction (FEC) Building Block"'>RFC5052</a>] for
      Under-Specified FEC Schemes.

   *  "FEC-OTI-Maximum-Source-Block-Length" carries the
      "Maximum-Source-Block-Length" Object Transmission Information
      element defined in [<a href="./rfc5052" title='"Forward Error Correction (FEC) Building Block"'>RFC5052</a>], if required by the FEC Scheme.

   *  "FEC-OTI-Encoding-Symbol-Length" carries the
      "Encoding-Symbol-Length" Object Transmission Information element
      defined in [<a href="./rfc5052" title='"Forward Error Correction (FEC) Building Block"'>RFC5052</a>], if required by the FEC Scheme.

   *  "FEC-OTI-Max-Number-of-Encoding-Symbols" carries the
      "Max-Number-of-Encoding-Symbols" Object Transmission Information
      element defined in [<a href="./rfc5052" title='"Forward Error Correction (FEC) Building Block"'>RFC5052</a>], if required by the FEC Scheme.

   *  "FEC-OTI-Scheme-Specific-Info" carries the "encoded
      Scheme-specific FEC Object Transmission Information" as defined in
      [<a href="./rfc5052" title='"Forward Error Correction (FEC) Building Block"'>RFC5052</a>], if required by the FEC Scheme.






<span class="grey">Paila, et al.                Standards Track                   [Page 25]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-26"></span>
<span class="grey"><a href="./rfc6726">RFC 6726</a>                          FLUTE                    November 2012</span>


   In FLUTE, the FEC Encoding ID (8 bits) for a given TOI MUST be
   carried in the Codepoint field of the ALC/LCT header.  When the FEC
   Object Transmission Information for this TOI is delivered through the
   FDT, then the associated "FEC-OTI-FEC-Encoding-ID" attribute and the
   Codepoint field of all packets for this TOI MUST be the same.

<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/6.%20%20Describing%20File%20Delivery%20Sessions"></a><a class="selflink" href="#section-6" id="section-6">6</a>.  Describing File Delivery Sessions</span>

   To start receiving a file delivery session, the receiver needs to
   know transport parameters associated with the session.  Interpreting
   these parameters and starting the reception therefore represent the
   entry point from which thereafter the receiver operation falls into
   the scope of this specification.  According to [<a href="./rfc5775" title='"Asynchronous Layered Coding (ALC) Protocol Instantiation"'>RFC5775</a>], the
   transport parameters of an ALC/LCT session that the receiver needs to
   know are:

   *  The source IP address;

   *  The number of channels in the session;

   *  The destination IP address and port number for each channel in the
      session;

   *  The Transport Session Identifier (TSI) of the session;

   *  An indication that the session is a FLUTE session.  The need to
      demultiplex objects upon reception is implicit in any use of
      FLUTE, and this fulfills the ALC requirement of an indication of
      whether or not a session carries packets for more than one object
      (all FLUTE sessions carry packets for more than one object).

   Optionally, the following parameters MAY be associated with the
   session (note that the list is not exhaustive):

   *  The start time and end time of the session;

   *  FEC Encoding ID and FEC Instance ID when the default FEC Encoding
      ID 0 is not used for the delivery of the FDT;

   *  Content encoding format if optional content encoding of the FDT
      Instance is used, e.g., compression;

   *  Some information that tells receiver, in the first place, that the
      session contains files that are of interest;

   *  Definition and configuration of a congestion control mechanism for
      the session;




<span class="grey">Paila, et al.                Standards Track                   [Page 26]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-27"></span>
<span class="grey"><a href="./rfc6726">RFC 6726</a>                          FLUTE                    November 2012</span>


   *  Security parameters relevant for the session;

   *  FLUTE version number.

   It is envisioned that these parameters would be described according
   to some session description syntax (such as SDP [<a href="./rfc4566" title='"SDP: Session Description Protocol"'>RFC4566</a>] or XML
   based) and held in a file that would be acquired by the receiver
   before the FLUTE session begins by means of some transport protocol
   (such as the Session Announcement Protocol (SAP) [<a href="./rfc2974" title='"Session Announcement Protocol"'>RFC2974</a>], email,
   HTTP [<a href="./rfc2616" title='"Hypertext Transfer Protocol -- HTTP/1.1"'>RFC2616</a>], SIP [<a href="./rfc3261" title='"SIP: Session Initiation Protocol"'>RFC3261</a>], manual preconfiguration, etc.).
   However, the way in which the receiver discovers the above-mentioned
   parameters is out of scope of this document, as it is for LCT and
   ALC.  In particular, this specification does not mandate or exclude
   any mechanism.

<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/7.%20%20Security%20Considerations"></a><a class="selflink" href="#section-7" id="section-7">7</a>.  Security Considerations</span>

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/7.1.%20%20Problem%20Statement"></a><a class="selflink" href="#section-7.1" id="section-7.1">7.1</a>.  Problem Statement</span>

   A content delivery system is potentially subject to attacks.  Attacks
   may target:

   *  the network (to compromise the routing infrastructure, e.g., by
      creating congestion),

   *  the Content Delivery Protocol (CDP) (e.g., to compromise the
      normal behavior of FLUTE), or

   *  the content itself (e.g., to corrupt the files being transmitted).

   These attacks can be launched either:

   *  against the data flow itself (e.g., by sending forged packets),

   *  against the session control parameters (e.g., by corrupting the
      session description, the FDT Instances, or the ALC/LCT control
      parameters) that are sent either in-band or out-of-band, or

   *  against some associated building blocks (e.g., the congestion
      control component).

   In the following sections, we provide more details on these possible
   attacks and sketch some possible countermeasures.  We provide
   recommendations in <a href="#section-7.5">Section 7.5</a>.







<span class="grey">Paila, et al.                Standards Track                   [Page 27]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-28"></span>
<span class="grey"><a href="./rfc6726">RFC 6726</a>                          FLUTE                    November 2012</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/7.2.%20%20Attacks%20against%20the%20Data%20Flow"></a><a class="selflink" href="#section-7.2" id="section-7.2">7.2</a>.  Attacks against the Data Flow</span>

   Let us consider attacks against the data flow first.  At the least,
   the following types of attacks exist:

   *  attacks that are meant to give access to a confidential file
      (e.g., in the case of non-free content) and

   *  attacks that try to corrupt the file being transmitted (e.g., to
      inject malicious code within a file, or to prevent a receiver from
      using a file, which is a kind of denial of service (DoS)).

<span class="h4"><a class="dashAnchor" name="//apple_ref/cpp/Section/7.2.1.%20%20Access%20to%20Confidential%20Files"></a><a class="selflink" href="#section-7.2.1" id="section-7.2.1">7.2.1</a>.  Access to Confidential Files</span>

   Access control to the file being transmitted is typically provided by
   means of encryption.  This encryption can be done over the whole
   file, i.e., before applying FEC protection (e.g., by the content
   provider, before submitting the file to FLUTE), or can be done on a
   packet-by-packet basis (e.g., when IPsec/ESP [<a href="./rfc4303" title='"IP Encapsulating Security Payload (ESP)"'>RFC4303</a>] is used; see
   <a href="#section-7.5">Section 7.5</a>).  If confidentiality is a concern, it is RECOMMENDED
   that one of these solutions be used.

<span class="h4"><a class="dashAnchor" name="//apple_ref/cpp/Section/7.2.2.%20%20File%20Corruption"></a><a class="selflink" href="#section-7.2.2" id="section-7.2.2">7.2.2</a>.  File Corruption</span>

   Protection against corruptions (e.g., if an attacker sends forged
   packets) is achieved by means of a content integrity verification/
   sender authentication scheme.  This service can be provided at the
   file level, i.e., before applying content encoding and FEC encoding.
   In that case, a receiver has no way to identify which symbol(s)
   is(are) corrupted if the file is detected as corrupted.  This service
   can also be provided at the packet level, i.e., after applying
   content encoding and FEC encoding, on a packet-by-packet basis.  In
   this case, after removing all corrupted packets, the file may be in
   some cases recovered from the remaining correct packets.

   Integrity protection applied at the file level has the advantage of
   lower overhead, since only relatively few bits are added to provide
   the integrity protection compared to the file size.  However, it has
   the disadvantage that it cannot distinguish between correct packets
   and corrupt packets, and therefore correct packets, which may form
   the majority of packets received, may be unusable.  Integrity
   protection applied at the packet level has the advantage that it can
   distinguish between correct and corrupt packets, at the cost of
   additional per-packet overhead.







<span class="grey">Paila, et al.                Standards Track                   [Page 28]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-29"></span>
<span class="grey"><a href="./rfc6726">RFC 6726</a>                          FLUTE                    November 2012</span>


   Several techniques can provide this source authentication/content
   integrity service:

   *  At the file level, the file MAY be digitally signed (e.g., by
      using RSA Probabilistic Signature Scheme Public-Key Cryptography
      Standards version 1.5 (RSASSA-PKCS1-v1_5) [<a href="./rfc3447" title='"Public-Key Cryptography Standards (PKCS) #1: RSA Cryptography Specifications Version 2.1"'>RFC3447</a>]).  This
      signature enables a receiver to check the file's integrity once
      the file has been fully decoded.  Even if digital signatures are
      computationally expensive, this calculation occurs only once per
      file, which is usually acceptable.

   *  At the packet level, each packet can be digitally signed
      [<a href="./rfc6584" title='"Simple Authentication Schemes for the Asynchronous Layered Coding (ALC) and NACK-Oriented Reliable Multicast (NORM) Protocols"'>RFC6584</a>].  A major limitation is the high computational and
      transmission overheads that this solution requires.  To avoid this
      problem, the signature may span a set of symbols (instead of a
      single one) in order to amortize the signature calculation, but if
      a single symbol is missing, the integrity of the whole set cannot
      be checked.

   *  At the packet level, a Group-Keyed Message Authentication Code
      (MAC) [<a href="./rfc2104" title='"HMAC: Keyed- Hashing for Message Authentication"'>RFC2104</a>] [<a href="./rfc6584" title='"Simple Authentication Schemes for the Asynchronous Layered Coding (ALC) and NACK-Oriented Reliable Multicast (NORM) Protocols"'>RFC6584</a>] scheme can be used; an example is using
      HMAC-SHA-256 with a secret key shared by all the group members,
      senders, and receivers.  This technique creates a
      cryptographically secured digest of a packet that is sent along
      with the packet.  The Group-Keyed MAC scheme does not create
      prohibitive processing load or transmission overhead, but it has a
      major limitation: it only provides a group authentication/
      integrity service, since all group members share the same secret
      group key, which means that each member can send a forged packet.
      It is therefore restricted to situations where group members are
      fully trusted (or in association with another technique as a
      pre-check).

   *  At the packet level, Timed Efficient Stream Loss-Tolerant
      Authentication (TESLA) [<a href="./rfc4082" title='"Timed Efficient Stream Loss-Tolerant Authentication (TESLA): Multicast Source Authentication Transform Introduction"'>RFC4082</a>] [<a href="./rfc5776" title='"Use of Timed Efficient Stream Loss-Tolerant Authentication (TESLA) in the Asynchronous Layered Coding (ALC) and NACK-Oriented Reliable Multicast (NORM) Protocols"'>RFC5776</a>] is an attractive
      solution that is robust to losses, provides a true authentication/
      integrity service, and does not create any prohibitive processing
      load or transmission overhead.  However, checking a packet
      requires a small delay (a second or more) after its reception.

   *  At the packet level, IPsec/ESP [<a href="./rfc4303" title='"IP Encapsulating Security Payload (ESP)"'>RFC4303</a>] can be used to check the
      integrity and authenticate the sender of all the packets being
      exchanged in a session (see <a href="#section-7.5">Section 7.5</a>).

   Techniques relying on public key cryptography (digital signatures and
   TESLA during the bootstrap process, when used) require that public
   keys be securely associated to the entities.  This can be achieved by




<span class="grey">Paila, et al.                Standards Track                   [Page 29]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-30"></span>
<span class="grey"><a href="./rfc6726">RFC 6726</a>                          FLUTE                    November 2012</span>


   a Public Key Infrastructure (PKI), or by a Pretty Good Privacy (PGP)
   Web of Trust, or by pre-distributing the public keys of each group
   member.

   Techniques relying on symmetric key cryptography (Group-Keyed MAC)
   require that a secret key be shared by all group members.  This can
   be achieved by means of a group key management protocol, or simply by
   pre-distributing the secret key (but this manual solution has many
   limitations).

   It is up to the developer and deployer, who know the security
   requirements and features of the target application area, to define
   which solution is the most appropriate.  Nonetheless, in case there
   is any concern of the threat of file corruption, it is RECOMMENDED
   that at least one of these techniques be used.

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/7.3.%20%20Attacks%20against%20the%20Session%20Control%20Parameters%20and%20Associated"></a><a class="selflink" href="#section-7.3" id="section-7.3">7.3</a>.  Attacks against the Session Control Parameters and Associated</span>
<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/Building%20Blocks"></a>      Building Blocks</span>

   Let us now consider attacks against the session control parameters
   and the associated building blocks.  The attacker has at least the
   following opportunities to launch an attack:

   *  the attack can target the session description,

   *  the attack can target the FDT Instances,

   *  the attack can target the ALC/LCT parameters, carried within the
      LCT header, or

   *  the attack can target the FLUTE associated building blocks (e.g.,
      the multiple-rate congestion control protocol).

   The consequences of these attacks are potentially serious, since they
   might compromise the behavior of the content delivery system itself.

<span class="h4"><a class="dashAnchor" name="//apple_ref/cpp/Section/7.3.1.%20%20Attacks%20against%20the%20Session%20Description"></a><a class="selflink" href="#section-7.3.1" id="section-7.3.1">7.3.1</a>.  Attacks against the Session Description</span>

   A FLUTE receiver may potentially obtain an incorrect session
   description for the session.  The consequence of this is that
   legitimate receivers with the wrong session description are unable to
   correctly receive the session content, or that receivers
   inadvertently try to receive at a much higher rate than they are
   capable of, thereby possibly disrupting other traffic in the network.

   To avoid these problems, it is RECOMMENDED that measures be taken to
   prevent receivers from accepting incorrect session descriptions.  One
   such measure is source authentication to ensure that receivers only



<span class="grey">Paila, et al.                Standards Track                   [Page 30]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-31"></span>
<span class="grey"><a href="./rfc6726">RFC 6726</a>                          FLUTE                    November 2012</span>


   accept legitimate session descriptions from authorized senders.  How
   these measures are achieved is outside the scope of this document,
   since this session description is usually carried out-of-band.

<span class="h4"><a class="dashAnchor" name="//apple_ref/cpp/Section/7.3.2.%20%20Attacks%20against%20the%20FDT%20Instances"></a><a class="selflink" href="#section-7.3.2" id="section-7.3.2">7.3.2</a>.  Attacks against the FDT Instances</span>

   Corrupting the FDT Instances is one way to create a DoS attack.  For
   example, the attacker changes the MD5 sum associated to a file.  This
   possibly leads a receiver to reject the files received, no matter
   whether the files have been correctly received or not.

   Corrupting the FDT Instances is also a way to make the reception
   process more costly than it should be.  This can be achieved by
   changing the FEC Object Transmission Information when the FEC Object
   Transmission Information is included in the FDT Instance.  For
   example, an attacker may corrupt the FDT Instance in such a way that
   Reed-Solomon over GF(2^^16) would be used instead of GF(2^^8) with
   FEC Encoding ID 2.  This may significantly increase the processing
   load while compromising FEC decoding.

   More generally, because FDT Instance data is structured using the XML
   language by means of an XML media type, many of the security
   considerations described in [<a href="./rfc3023" title='"XML Media Types"'>RFC3023</a>] and [<a href="./rfc3470" title='"Guidelines for the Use of Extensible Markup Language (XML) within IETF Protocols"'>RFC3470</a>] also apply to
   such data.

   It is therefore RECOMMENDED that measures be taken to guarantee the
   integrity and to check the sender's identity of the FDT Instances.
   To that purpose, one of the countermeasures mentioned above
   (<a href="#section-7.2.2">Section 7.2.2</a>) SHOULD be used.  These measures will either be
   applied on a packet level or globally over the whole FDT Instance
   object.  Additionally, XML digital signatures [<a href="./rfc3275" title='"(Extensible Markup Language) XML-Signature Syntax and Processing"'>RFC3275</a>] are a way to
   protect the FDT Instance by digitally signing it.  When there is no
   packet-level integrity verification scheme, it is RECOMMENDED to rely
   on XML digital signatures of the FDT Instances.

<span class="h4"><a class="dashAnchor" name="//apple_ref/cpp/Section/7.3.3.%20%20Attacks%20against%20the%20ALC%2FLCT%20Parameters"></a><a class="selflink" href="#section-7.3.3" id="section-7.3.3">7.3.3</a>.  Attacks against the ALC/LCT Parameters</span>

   By corrupting the ALC/LCT header (or header extensions), one can
   execute attacks on the underlying ALC/LCT implementation.  For
   example, sending forged ALC packets with the Close Session flag (A)
   set to one can lead the receiver to prematurely close the session.
   Similarly, sending forged ALC packets with the Close Object flag (B)
   set to one can lead the receiver to prematurely give up the reception
   of an object.







<span class="grey">Paila, et al.                Standards Track                   [Page 31]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-32"></span>
<span class="grey"><a href="./rfc6726">RFC 6726</a>                          FLUTE                    November 2012</span>


   It is therefore RECOMMENDED that measures be taken to guarantee the
   integrity and to check the sender's identity of the ALC packets
   received.  To that purpose, one of the countermeasures mentioned
   above (<a href="#section-7.2.2">Section 7.2.2</a>) SHOULD be used.

<span class="h4"><a class="dashAnchor" name="//apple_ref/cpp/Section/7.3.4.%20%20Attacks%20against%20the%20Associated%20Building%20Blocks"></a><a class="selflink" href="#section-7.3.4" id="section-7.3.4">7.3.4</a>.  Attacks against the Associated Building Blocks</span>

   Let us first focus on the congestion control building block, which
   may be used in the ALC session.  A receiver with an incorrect or
   corrupted implementation of the multiple-rate congestion control
   building block may affect the health of the network in the path
   between the sender and the receiver.  That may also affect the
   reception rates of other receivers who joined the session.

   When the congestion control building block is applied with FLUTE, it
   is RECOMMENDED that receivers be required to identify themselves as
   legitimate before they receive the session description needed to join
   the session.  How receivers identify themselves as legitimate is
   outside the scope of this document.  If authenticating a receiver
   does not prevent this receiver from launching an attack, this
   authentication will enable the network operator to identify him and
   to take countermeasures.

   When the congestion control building block is applied with FLUTE, it
   is also RECOMMENDED that a packet-level authentication scheme be
   used, as explained in <a href="#section-7.2.2">Section 7.2.2</a>.  Some of them, like TESLA, only
   provide a delayed authentication service, whereas congestion control
   requires a rapid reaction.  It is therefore RECOMMENDED [<a href="./rfc5775" title='"Asynchronous Layered Coding (ALC) Protocol Instantiation"'>RFC5775</a>]
   that a receiver using TESLA quickly reduce its subscription level
   when the receiver believes that congestion did occur, even if the
   packet has not yet been authenticated.  Therefore, TESLA will not
   prevent DoS attacks where an attacker makes the receiver believe that
   congestion occurred.  This is an issue for the receiver, but this
   will not compromise the network.  Other authentication methods that
   do not feature this delayed authentication could be preferred, or a
   Group-Keyed MAC scheme could be used in parallel with TESLA to
   prevent attacks launched from outside of the group.

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/7.4.%20%20Other%20Security%20Considerations"></a><a class="selflink" href="#section-7.4" id="section-7.4">7.4</a>.  Other Security Considerations</span>

   The security considerations that apply to, and are described in, ALC
   [<a href="./rfc5775" title='"Asynchronous Layered Coding (ALC) Protocol Instantiation"'>RFC5775</a>], LCT [<a href="./rfc5651" title='"Layered Coding Transport (LCT) Building Block"'>RFC5651</a>], and FEC [<a href="./rfc5052" title='"Forward Error Correction (FEC) Building Block"'>RFC5052</a>] also apply to FLUTE, as
   FLUTE builds on those specifications.  In addition, any security
   considerations that apply to any congestion control building block
   used in conjunction with FLUTE also apply to FLUTE.






<span class="grey">Paila, et al.                Standards Track                   [Page 32]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-33"></span>
<span class="grey"><a href="./rfc6726">RFC 6726</a>                          FLUTE                    November 2012</span>


   Even if FLUTE defines a purely unidirectional delivery service,
   without any feedback information that would be sent to the sender,
   security considerations MAY require bidirectional communications.
   For instance, if an automated key management scheme is used, a
   bidirectional point-to-point channel is often needed to establish a
   shared secret between each receiver and the sender.  Each shared
   secret can then be used to distribute additional keys to the
   associated receiver (e.g., traffic encryption keys).

   As an example, [<a href="#ref-MBMSsecurity">MBMSsecurity</a>] details a complete security framework
   for the Third Generation Partnership Project (3GPP) Multimedia
   Broadcast/Multicast Service (MBMS) that relies on FLUTE/ALC for
   Download Sessions.  It relies on bidirectional point-to-point
   communications for User Equipment authentication and for key
   distribution, using the Multimedia Internet KEYing (MIKEY) protocol
   [<a href="./rfc3830" title='"MIKEY: Multimedia Internet KEYing"'>RFC3830</a>].  Because this security framework is specific to this use
   case, it cannot be reused as such for generic security
   recommendations in this specification.  Instead, the following
   section introduces minimum security recommendations.

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/7.5.%20%20Minimum%20Security%20Recommendations"></a><a class="selflink" href="#section-7.5" id="section-7.5">7.5</a>.  Minimum Security Recommendations</span>

   We now introduce a mandatory-to-implement, but not necessarily to
   use, security configuration, in the sense of [<a href="./rfc3365" title='"Strong Security Requirements for Internet Engineering Task Force Standard Protocols"'>RFC3365</a>].  Since FLUTE
   relies on ALC/LCT, it inherits the "baseline secure ALC operation" of
   [<a href="./rfc5775" title='"Asynchronous Layered Coding (ALC) Protocol Instantiation"'>RFC5775</a>].  More precisely, security is achieved by means of IPsec/
   ESP in transport mode.  [<a href="./rfc4303" title='"IP Encapsulating Security Payload (ESP)"'>RFC4303</a>] explains that ESP can be used to
   potentially provide confidentiality, data origin authentication,
   content integrity, anti-replay, and (limited) traffic flow
   confidentiality.  [<a href="./rfc5775" title='"Asynchronous Layered Coding (ALC) Protocol Instantiation"'>RFC5775</a>] specifies that the data origin
   authentication, content integrity, and anti-replay services SHALL be
   supported, and that the confidentiality service is RECOMMENDED.  If a
   short-lived session MAY rely on manual keying, it is also RECOMMENDED
   that an automated key management scheme be used, especially in the
   case of long-lived sessions.

   Therefore, the RECOMMENDED solution for FLUTE provides per-packet
   security, with data origin authentication, integrity verification,
   and anti-replay.  This is sufficient to prevent most of the in-band
   attacks listed above.  If confidentiality is required, a per-packet
   encryption SHOULD also be used.










<span class="grey">Paila, et al.                Standards Track                   [Page 33]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-34"></span>
<span class="grey"><a href="./rfc6726">RFC 6726</a>                          FLUTE                    November 2012</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/8.%20%20IANA%20Considerations"></a><a class="selflink" href="#section-8" id="section-8">8</a>.  IANA Considerations</span>

   This specification contains five separate items upon which IANA has
   taken action:

   1.  Registration of the FDT Instance XML Namespace.

   2.  Registration of the FDT Instance XML Schema.

   3.  Registration of the application/fdt+xml Media Type.

   4.  Registration of the Content Encoding Algorithms.

   5.  Registration of two LCT Header Extension Types (EXT_FDT and
       EXT_CENC).

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/8.1.%20%20Registration%20of%20the%20FDT%20Instance%20XML%20Namespace"></a><a class="selflink" href="#section-8.1" id="section-8.1">8.1</a>.  Registration of the FDT Instance XML Namespace</span>

   IANA has registered the following new XML Namespace in the IETF XML
   "ns" registry [<a href="./rfc3688" title='"The IETF XML Registry"'>RFC3688</a>] at
   <a href="http://www.iana.org/assignments/xml-registry/ns.html">http://www.iana.org/assignments/xml-registry/ns.html</a>.

   URI: urn:ietf:params:xml:ns:fdt

   Registrant Contact: Toni Paila (toni.paila@gmail.com)

   XML: N/A

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/8.2.%20%20Registration%20of%20the%20FDT%20Instance%20XML%20Schema"></a><a class="selflink" href="#section-8.2" id="section-8.2">8.2</a>.  Registration of the FDT Instance XML Schema</span>

   IANA has registered the following in the IETF XML "schema" registry
   [<a href="./rfc3688" title='"The IETF XML Registry"'>RFC3688</a>] at
   <a href="http://www.iana.org/assignments/xml-registry/schema.html">http://www.iana.org/assignments/xml-registry/schema.html</a>.

   URI: urn:ietf:params:xml:schema:fdt

   Registrant Contact: Toni Paila (toni.paila@gmail.com)

   XML: The XML Schema specified in <a href="#section-3.4.2">Section 3.4.2</a>












<span class="grey">Paila, et al.                Standards Track                   [Page 34]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-35"></span>
<span class="grey"><a href="./rfc6726">RFC 6726</a>                          FLUTE                    November 2012</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/8.3.%20%20Registration%20of%20the%20application%2Ffdt%2Bxml%20Media%20Type"></a><a class="selflink" href="#section-8.3" id="section-8.3">8.3</a>.  Registration of the application/fdt+xml Media Type</span>

   IANA has registered the following in the "Application Media Types"
   registry at <a href="http://www.iana.org/assignments/media-types/application/">http://www.iana.org/assignments/media-types/application/</a>.

   Type name: application

   Subtype name: fdt+xml

   Required parameters: none

   Optional parameters: charset="utf-8"

   Encoding considerations: binary (the FLUTE file delivery protocol
   does not impose any restriction on the objects it carries and in
   particular on the FDT Instance itself)

   Restrictions on usage: none

   Security considerations: fdt+xml data is passive and does not
   generally represent a unique or new security threat.  However, there
   is some risk in sharing any kind of data, in that unintentional
   information may be exposed, and that risk applies to fdt+xml data as
   well.

   Interoperability considerations: None

   Published specification: [<a href="./rfc6726">RFC6726</a>], especially noting <a href="#section-3.4.2">Section 3.4.2</a>.
   The specified FDT Instance functions as an actual media format of use
   to the general Internet community, and thus media type registration
   under the Standards Tree is appropriate to maximize interoperability.

   Applications that use this media type: file and object delivery
   applications and protocols (e.g., FLUTE).

   Additional information:

       Magic number(s): none
       File extension(s): ".fdt" (e.g., if there is a need to store an
                          FDT Instance as a file)
       Macintosh File Type Code(s): none

   Person and email address to contact for further information:
   Toni Paila (toni.paila@gmail.com)

   Intended usage: Common

   Author/Change controller: IETF



<span class="grey">Paila, et al.                Standards Track                   [Page 35]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-36"></span>
<span class="grey"><a href="./rfc6726">RFC 6726</a>                          FLUTE                    November 2012</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/8.4.%20%20Creation%20of%20the%20FLUTE%20Content%20Encoding%20Algorithms%20Registry"></a><a class="selflink" href="#section-8.4" id="section-8.4">8.4</a>.  Creation of the FLUTE Content Encoding Algorithms Registry</span>

   IANA has created a new registry, "FLUTE Content Encoding Algorithms",
   with a reference to [<a href="./rfc6726">RFC6726</a>]; see <a href="#section-3.4.3">Section 3.4.3</a>.  The registry
   entries consist of a numeric value from 0 to 255, inclusive, and may
   be registered using the Specification Required policy [<a href="./rfc5226" title="">RFC5226</a>].

   The initial contents of the registry are as follows, with unspecified
   values available for new registrations:

                  +-------+----------------+-----------+
                  | Value | Algorithm Name | Reference |
                  +-------+----------------+-----------+
                  |   0   |      null      | [<a href="./rfc6726">RFC6726</a>] |
                  |   1   |      ZLIB      | [<a href="./rfc1950" title='"ZLIB Compressed Data Format Specification version 3.3"'>RFC1950</a>] |
                  |   2   |     DEFLATE    | [<a href="./rfc1951" title='"DEFLATE Compressed Data Format Specification version 1.3"'>RFC1951</a>] |
                  |   3   |      GZIP      | [<a href="./rfc1952" title='"GZIP file format specification version 4.3"'>RFC1952</a>] |
                  +-------+----------------+-----------+

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/8.5.%20%20Registration%20of%20LCT%20Header%20Extension%20Types"></a><a class="selflink" href="#section-8.5" id="section-8.5">8.5</a>.  Registration of LCT Header Extension Types</span>

   IANA has registered two new entries in the "Layered Coding Transport
   (LCT) Header Extension Types" registry [<a href="./rfc5651" title='"Layered Coding Transport (LCT) Building Block"'>RFC5651</a>], as follows:

              +--------+----------+-------------------------+
              | Number |   Name   |        Reference        |
              +--------+----------+-------------------------+
              |   192  |  EXT_FDT | <a href="./rfc6726#section-3.4.1">[RFC6726] Section 3.4.1</a> |
              |   193  | EXT_CENC | <a href="./rfc6726#section-3.4.3">[RFC6726] Section 3.4.3</a> |
              +--------+----------+-------------------------+

<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/9.%20%20Acknowledgments"></a><a class="selflink" href="#section-9" id="section-9">9</a>.  Acknowledgments</span>

   The following persons have contributed to this specification: Brian
   Adamson, Mark Handley, Esa Jalonen, Roger Kermode, Juha-Pekka Luoma,
   Topi Pohjolainen, Lorenzo Vicisano, Mark Watson, David Harrington,
   Ben Campbell, Stephen Farrell, Robert Sparks, Ronald Bonica, Francis
   Dupont, Peter Saint-Andre, Don Gillies, and Barry Leiba.  The authors
   would like to thank all the contributors for their valuable work in
   reviewing and providing feedback regarding this specification.











<span class="grey">Paila, et al.                Standards Track                   [Page 36]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-37"></span>
<span class="grey"><a href="./rfc6726">RFC 6726</a>                          FLUTE                    November 2012</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/10.%20%20Contributors"></a><a class="selflink" href="#section-10" id="section-10">10</a>.  Contributors</span>

   Jani Peltotalo
   Tampere University of Technology
   P.O. Box 553 (Korkeakoulunkatu 1)
   Tampere FIN-33101
   Finland
   EMail: jani.peltotalo@tut.fi

   Sami Peltotalo
   Tampere University of Technology
   P.O. Box 553 (Korkeakoulunkatu 1)
   Tampere FIN-33101
   Finland
   EMail: sami.peltotalo@tut.fi

   Magnus Westerlund
   Ericsson Research
   Ericsson AB
   SE-164 80 Stockholm
   Sweden
   EMail: magnus.westerlund@ericsson.com

   Thorsten Lohmar
   Ericsson Research (EDD)
   Ericsson Allee 1
   52134 Herzogenrath
   Germany
   EMail: thorsten.lohmar@ericsson.com

<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/11.%20%20Change%20Log"></a><a class="selflink" href="#section-11" id="section-11">11</a>.  Change Log</span>

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/11.1.%20%20RFC%203926%20to%20This%20Document"></a><a class="selflink" href="#section-11.1" id="section-11.1">11.1</a>.  <a href="./rfc3926">RFC 3926</a> to This Document</span>

   Incremented the FLUTE protocol version from 1 to 2, due to concerns
   about backwards compatibility.  For instance, the LCT header changed
   between <a href="./rfc3451">RFC 3451</a> and [<a href="./rfc5651" title='"Layered Coding Transport (LCT) Building Block"'>RFC5651</a>].  In <a href="./rfc3451">RFC 3451</a>, the T and R fields of
   the LCT header indicate the presence of Sender Current Time and
   Expected Residual Time, respectively.  In [<a href="./rfc5651" title='"Layered Coding Transport (LCT) Building Block"'>RFC5651</a>], these fields
   MUST be set to zero and MUST be ignored by receivers (instead, the
   EXT_TIME Header Extensions can convey this information if needed).
   Thus, [<a href="./rfc5651" title='"Layered Coding Transport (LCT) Building Block"'>RFC5651</a>] is not backwards compatible with <a href="./rfc3451">RFC 3451</a>, even
   though both use LCT version 1.  FLUTE version 1 as specified in
   [<a href="./rfc3926" title='"FLUTE - File Delivery over Unidirectional Transport"'>RFC3926</a>] MUST use <a href="./rfc3451">RFC 3451</a>.  FLUTE version 2 as specified in this
   document MUST use [<a href="./rfc5651" title='"Layered Coding Transport (LCT) Building Block"'>RFC5651</a>].  Therefore, an implementation that
   relies on [<a href="./rfc3926" title='"FLUTE - File Delivery over Unidirectional Transport"'>RFC3926</a>] and <a href="./rfc3451">RFC 3451</a> will not be backwards compatible
   with FLUTE as specified in this document.




<span class="grey">Paila, et al.                Standards Track                   [Page 37]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-38"></span>
<span class="grey"><a href="./rfc6726">RFC 6726</a>                          FLUTE                    November 2012</span>


   Updated dependencies to other RFCs to revised versions; e.g., changed
   ALC reference from <a href="./rfc3450">RFC 3450</a> to [<a href="./rfc5775" title='"Asynchronous Layered Coding (ALC) Protocol Instantiation"'>RFC5775</a>], changed LCT reference from
   <a href="./rfc3451">RFC 3451</a> to [<a href="./rfc5651" title='"Layered Coding Transport (LCT) Building Block"'>RFC5651</a>], etc.

   Added clarification for the use of FLUTE for unicast communications
   in <a href="#section-1.1.4">Section 1.1.4</a>.

   Clarified how to reliably deliver the FDT in <a href="#section-3.3">Section 3.3</a> and the
   possibility of using out-of-band delivery of FDT information.

   Clarified how to address FDT Instance expiration time wraparound with
   the notion of the NTPv4 "epoch" in <a href="#section-3.3">Section 3.3</a>.

   Clarified what should be considered erroneous situations in
   <a href="#section-3.4.1">Section 3.4.1</a> (definition of FDT Instance ID).  In particular, a
   receiver MUST be ready to handle FDT Instance ID wraparounds and
   missing FDT Instances.

   Updated <a href="#section-7.5">Section 7.5</a> to define IPsec/ESP as a mandatory-to-implement
   security solution.

   Removed the 'Statement of Intent' from <a href="#section-1">Section 1</a>.  The statement of
   intent was meant to clarify the "Experimental" status of [<a href="./rfc3926" title='"FLUTE - File Delivery over Unidirectional Transport"'>RFC3926</a>].
   It does not apply to this document.

   Added clarification of "XML-DSIG" near the end of Section 3.

   In <a href="#section-3.2">Section 3.2</a>, replaced "complete FDT" with text that is more
   descriptive.

   Clarified Figure 1 with regard to "Encoding Symbol(s) for FDT
   Instance".

   Clarified the text regarding FDT Instance ID wraparound at the end of
   <a href="#section-3.4.1">Section 3.4.1</a>.

   Clarified "complete FDT" in <a href="#section-3.4.2">Section 3.4.2</a>.

   Added semantics for the case where two TOIs refer to the same
   Content-Location.  It is now in line with the way that 3GPP and
   Digital Video Broadcasting (DVB) standards interpret this case.

   In <a href="#section-3.4.2">Section 3.4.2</a>, the XML Schema of the FDT Instance was modified per
   advice from various sources.  For example, extension by element was
   missing but is now supported.  Also, the namespace definition was
   changed to URN format.

   Clarified FDT-schema extensibility at the end of <a href="#section-3.4.2">Section 3.4.2</a>.



<span class="grey">Paila, et al.                Standards Track                   [Page 38]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-39"></span>
<span class="grey"><a href="./rfc6726">RFC 6726</a>                          FLUTE                    November 2012</span>


   The CENC value allocation has been added at the end of <a href="#section-3.4.3">Section 3.4.3</a>.

   <a href="#section-5">Section 5</a> has been modified so that EXT_FTI and the FEC issues were
   replaced by a reference to the ALC specification [<a href="./rfc5775" title='"Asynchronous Layered Coding (ALC) Protocol Instantiation"'>RFC5775</a>].

   Added a clarifying paragraph on the use of the Codepoint field at the
   end of <a href="#section-5">Section 5</a>.

   Reworked <a href="#section-8">Section 8</a> -- IANA Considerations; it now contains six IANA
   registration requests:

   *  Registration of the FDT Instance XML Namespace.

   *  Registration of the FDT Instance XML Schema.

   *  Registration of the application/fdt+xml Media Type.

   *  Registration of the Content Encoding Algorithms.

   *  Registration of two LCT Header Extension Types and corresponding
      values in the LCT Header Extension Types Registry (192 for EXT_FDT
      and 193 for EXT_CENC).

   Added <a href="#section-10">Section 10</a> -- Contributors.

   Revised lists of both Normative and Informative references.

   Added a clarification that the receiver should ignore reserved bits
   of Header Extension type 193 upon reception.

   Elaborated on what kinds of networks cannot support FLUTE congestion
   control (<a href="#section-1.1.4">Section 1.1.4</a>).

   In <a href="#section-3.2">Section 3.2</a>, changed "several" (meaning 3-n vs. "couple" = 2) to
   "multiple" (meaning 2-n).

   Moved the requirement in <a href="#section-3.3">Section 3.3</a> (to send FDT more reliably than
   files) to a bulleted RECOMMENDED requirement, making check-off easier
   for testers.

   In <a href="#section-3.3">Section 3.3</a>, sharpened the definition that future FDT file
   instances can "augment" (meaning enhance) rather than "complement"
   (sometimes meaning negate, which is not allowed) the file parameters.

   Elaborated in Sections <a href="#section-3.3">3.3</a> and <a href="#section-4">4</a> that FEC Encoding ID = 0 is Compact
   No-Code FEC, so that the reader doesn't have to search other RFCs to
   understand these protocol constants used by FLUTE.




<span class="grey">Paila, et al.                Standards Track                   [Page 39]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-40"></span>
<span class="grey"><a href="./rfc6726">RFC 6726</a>                          FLUTE                    November 2012</span>


   Required in <a href="#section-3.3">Section 3.3</a> that FLUTE receivers SHALL NOT attempt to
   decode FDTs if they do not understand the FEC Encoding ID.

   Removed the restriction of <a href="#section-3.3">Section 3.3</a>, in bullet #4, that TOI = 0
   for the FDT, to be consistent with <a href="#appendix-A">Appendix A</a> step 6 and elsewhere.
   An FDT is signaled by an FDT Instance ID, NOT only by TOI = 0.

   Standardized on the term "expiration time", and avoided using the
   redundant and possibly confusing term "expiry time".

   To interwork with experimental FLUTE, stipulated in <a href="#section-3.1">Section 3.1</a> that
   only 1 instantiation of all 3 protocols -- FLUTE, ALC, and LCT -- can
   be associated with a session (source IP Address, TSI), and mentioned
   in <a href="#section-6">Section 6</a> that one may (optionally) derive the FLUTE version from
   the file delivery session description.

   Used a software writing tool to lower the reading grade level and
   simplify <a href="#section-3.1">Section 3.1</a>.

<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/12.%20%20References"></a><a class="selflink" href="#section-12" id="section-12">12</a>.  References</span>

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/12.1.%20%20Normative%20References"></a><a class="selflink" href="#section-12.1" id="section-12.1">12.1</a>.  Normative References</span>

   [<a id="ref-RFC2119">RFC2119</a>]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", <a href="https://www.rfc-editor.org/bcp/bcp14">BCP 14</a>, <a href="./rfc2119">RFC 2119</a>, March 1997.

   [<a id="ref-RFC5775">RFC5775</a>]  Luby, M., Watson, M., and L. Vicisano, "Asynchronous
              Layered Coding (ALC) Protocol Instantiation", <a href="./rfc5775">RFC 5775</a>,
              April 2010.

   [<a id="ref-RFC5651">RFC5651</a>]  Luby, M., Watson, M., and L. Vicisano, "Layered Coding
              Transport (LCT) Building Block", <a href="./rfc5651">RFC 5651</a>, October 2009.

   [<a id="ref-RFC5052">RFC5052</a>]  Watson, M., Luby, M., and L. Vicisano, "Forward Error
              Correction (FEC) Building Block", <a href="./rfc5052">RFC 5052</a>, August 2007.

   [<a id="ref-RFC5445">RFC5445</a>]  Watson, M., "Basic Forward Error Correction (FEC)
              Schemes", <a href="./rfc5445">RFC 5445</a>, March 2009.

   [<a id="ref-RFC5905">RFC5905</a>]  Mills, D., Martin, J., Ed., Burbank, J., and W. Kasch,
              "Network Time Protocol Version 4: Protocol and Algorithms
              Specification", <a href="./rfc5905">RFC 5905</a>, June 2010.

   [<a id="ref-RFC2616">RFC2616</a>]  Fielding, R., Gettys, J., Mogul, J., Frystyk, H.,
              Masinter, L., Leach, P., and T. Berners-Lee, "Hypertext
              Transfer Protocol -- HTTP/1.1", <a href="./rfc2616">RFC 2616</a>, June 1999.





<span class="grey">Paila, et al.                Standards Track                   [Page 40]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-41"></span>
<span class="grey"><a href="./rfc6726">RFC 6726</a>                          FLUTE                    November 2012</span>


   [<a id="ref-XML-Schema-Part-1">XML-Schema-Part-1</a>]
              Thompson, H., Beech, D., Maloney, M., and N. Mendelsohn,
              "XML Schema Part 1: Structures Second Edition",
              W3C Recommendation, October 2004,
              &lt;<a href="http://www.w3.org/TR/xmlschema-1/">http://www.w3.org/TR/xmlschema-1/</a>&gt;.

   [<a id="ref-XML-Schema-Part-2">XML-Schema-Part-2</a>]
              Biron, P. and A. Malhotra, "XML Schema Part 2: Datatypes
              Second Edition", W3C Recommendation, October 2004,
              &lt;<a href="http://www.w3.org/TR/xmlschema-2/">http://www.w3.org/TR/xmlschema-2/</a>&gt;.

   [<a id="ref-RFC3023">RFC3023</a>]  Murata, M., St. Laurent, S., and D. Kohn, "XML Media
              Types", <a href="./rfc3023">RFC 3023</a>, January 2001.

   [<a id="ref-RFC5226">RFC5226</a>]  Narten, T. and H. Alvestrand, "Guidelines for Writing an
              IANA Considerations Section in RFCs", <a href="./rfc5226">RFC 5226</a>, May 2008.

   [<a id="ref-RFC3738">RFC3738</a>]  Luby, M. and V. Goyal, "Wave and Equation Based Rate
              Control (WEBRC) Building Block", <a href="./rfc3738">RFC 3738</a>, April 2004.

              Note: The <a href="./rfc3738">RFC 3738</a> reference is to a target document of a
              lower maturity level.  Some caution should be used, since
              it may be less stable than the present document.

   [<a id="ref-RFC4303">RFC4303</a>]  Kent, S., "IP Encapsulating Security Payload (ESP)",
              <a href="./rfc4303">RFC 4303</a>, December 2005.

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/12.2.%20%20Informative%20References"></a><a class="selflink" href="#section-12.2" id="section-12.2">12.2</a>.  Informative References</span>

   [<a id="ref-RFC3926">RFC3926</a>]  Paila, T., Luby, M., Lehtonen, R., Roca, V., and R. Walsh,
              "FLUTE - File Delivery over Unidirectional Transport",
              <a href="./rfc3926">RFC 3926</a>, October 2004.

   [<a id="ref-RFC2357">RFC2357</a>]  Mankin, A., Romanow, A., Bradner, S., and V. Paxson, "IETF
              Criteria for Evaluating Reliable Multicast Transport and
              Application Protocols", <a href="./rfc2357">RFC 2357</a>, June 1998.

   [<a id="ref-RFC3986">RFC3986</a>]  Berners-Lee, T., Fielding, R., and L. Masinter, "Uniform
              Resource Identifier (URI): Generic Syntax", STD 66,
              <a href="./rfc3986">RFC 3986</a>, January 2005.

   [<a id="ref-RFC3470">RFC3470</a>]  Hollenbeck, S., Rose, M., and L. Masinter, "Guidelines for
              the Use of Extensible Markup Language (XML)
              within IETF Protocols", <a href="https://www.rfc-editor.org/bcp/bcp70">BCP 70</a>, <a href="./rfc3470">RFC 3470</a>, January 2003.

   [<a id="ref-RFC2045">RFC2045</a>]  Freed, N. and N. Borenstein, "Multipurpose Internet Mail
              Extensions (MIME) Part One: Format of Internet Message
              Bodies", <a href="./rfc2045">RFC 2045</a>, November 1996.



<span class="grey">Paila, et al.                Standards Track                   [Page 41]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-42"></span>
<span class="grey"><a href="./rfc6726">RFC 6726</a>                          FLUTE                    November 2012</span>


   [<a id="ref-RFC1950">RFC1950</a>]  Deutsch, P. and J-L. Gailly, "ZLIB Compressed Data Format
              Specification version 3.3", <a href="./rfc1950">RFC 1950</a>, May 1996.

   [<a id="ref-RFC1951">RFC1951</a>]  Deutsch, P., "DEFLATE Compressed Data Format Specification
              version 1.3", <a href="./rfc1951">RFC 1951</a>, May 1996.

   [<a id="ref-RFC1952">RFC1952</a>]  Deutsch, P., "GZIP file format specification version 4.3",
              <a href="./rfc1952">RFC 1952</a>, May 1996.

   [<a id="ref-IANAheaderfields">IANAheaderfields</a>]
              IANA, "Message Header Fields",
              &lt;<a href="http://www.iana.org/protocols">http://www.iana.org/protocols</a>&gt;.

   [<a id="ref-RFC2974">RFC2974</a>]  Handley, M., Perkins, C., and E. Whelan, "Session
              Announcement Protocol", <a href="./rfc2974">RFC 2974</a>, October 2000.

   [<a id="ref-RFC4566">RFC4566</a>]  Handley, M., Jacobson, V., and C. Perkins, "SDP: Session
              Description Protocol", <a href="./rfc4566">RFC 4566</a>, July 2006.

   [<a id="ref-RFC1112">RFC1112</a>]  Deering, S., "Host extensions for IP multicasting", STD 5,
              <a href="./rfc1112">RFC 1112</a>, August 1989.

   [<a id="ref-PAPER.SSM">PAPER.SSM</a>]
              Holbrook, H., "A Channel Model for Multicast", Ph.D.
              Dissertation, Stanford University, Department of Computer
              Science, Stanford, California, August 2001.

   [<a id="ref-RFC3365">RFC3365</a>]  Schiller, J., "Strong Security Requirements for Internet
              Engineering Task Force Standard Protocols", <a href="https://www.rfc-editor.org/bcp/bcp61">BCP 61</a>,
              <a href="./rfc3365">RFC 3365</a>, August 2002.

   [<a id="ref-RFC5751">RFC5751</a>]  Ramsdell, B. and S. Turner, "Secure/Multipurpose Internet
              Mail Extensions (S/MIME) Version 3.2 Message
              Specification", <a href="./rfc5751">RFC 5751</a>, January 2010.

   [<a id="ref-RFC3275">RFC3275</a>]  Eastlake 3rd, D., Reagle, J., and D. Solo, "(Extensible
              Markup Language) XML-Signature Syntax and Processing",
              <a href="./rfc3275">RFC 3275</a>, March 2002.

   [<a id="ref-RFC3261">RFC3261</a>]  Rosenberg, J., Schulzrinne, H., Camarillo, G., Johnston,
              A., Peterson, J., Sparks, R., Handley, M., and E.
              Schooler, "SIP: Session Initiation Protocol", <a href="./rfc3261">RFC 3261</a>,
              June 2002.

   [<a id="ref-RFC3688">RFC3688</a>]  Mealling, M., "The IETF XML Registry", <a href="https://www.rfc-editor.org/bcp/bcp81">BCP 81</a>, <a href="./rfc3688">RFC 3688</a>,
              January 2004.





<span class="grey">Paila, et al.                Standards Track                   [Page 42]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-43"></span>
<span class="grey"><a href="./rfc6726">RFC 6726</a>                          FLUTE                    November 2012</span>


   [<a id="ref-RFC3447">RFC3447</a>]  Jonsson, J. and B. Kaliski, "Public-Key Cryptography
              Standards (PKCS) #1: RSA Cryptography Specifications
              Version 2.1", <a href="./rfc3447">RFC 3447</a>, February 2003.

   [<a id="ref-RFC2104">RFC2104</a>]  Krawczyk, H., Bellare, M., and R. Canetti, "HMAC: Keyed-
              Hashing for Message Authentication", <a href="./rfc2104">RFC 2104</a>,
              February 1997.

   [<a id="ref-RFC4082">RFC4082</a>]  Perrig, A., Song, D., Canetti, R., Tygar, J., and B.
              Briscoe, "Timed Efficient Stream Loss-Tolerant
              Authentication (TESLA): Multicast Source Authentication
              Transform Introduction", <a href="./rfc4082">RFC 4082</a>, June 2005.

   [<a id="ref-RFC5776">RFC5776</a>]  Roca, V., Francillon, A., and S. Faurite, "Use of Timed
              Efficient Stream Loss-Tolerant Authentication (TESLA) in
              the Asynchronous Layered Coding (ALC) and NACK-Oriented
              Reliable Multicast (NORM) Protocols", <a href="./rfc5776">RFC 5776</a>,
              April 2010.

   [<a id="ref-RFC6584">RFC6584</a>]  Roca, V., "Simple Authentication Schemes for the
              Asynchronous Layered Coding (ALC) and NACK-Oriented
              Reliable Multicast (NORM) Protocols", <a href="./rfc6584">RFC 6584</a>,
              April 2012.

   [<a id="ref-RFC3830">RFC3830</a>]  Arkko, J., Carrara, E., Lindholm, F., Naslund, M., and K.
              Norrman, "MIKEY: Multimedia Internet KEYing", <a href="./rfc3830">RFC 3830</a>,
              August 2004.

   [<a id="ref-MBMSsecurity">MBMSsecurity</a>]
              3GPP, "3rd Generation Partnership Project; Technical
              Specification Group Services and System Aspects; 3G
              Security; Security of Multimedia Broadcast/Multicast
              Service (MBMS) (Release 10)", December 2010,
              &lt;<a href="http://www.3gpp.org/ftp/Specs/archive/33_series/33.246/">http://www.3gpp.org/ftp/Specs/archive/33_series/33.246/</a>&gt;.

















<span class="grey">Paila, et al.                Standards Track                   [Page 43]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-44"></span>
<span class="grey"><a href="./rfc6726">RFC 6726</a>                          FLUTE                    November 2012</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/Appendix%20A.%20%20Receiver%20Operation%20%28Informative%29"></a><a class="selflink" href="#appendix-A" id="appendix-A">Appendix A</a>.  Receiver Operation (Informative)</span>

   This section gives an example of how the receiver of the file
   delivery session may operate.  Instead of a detailed state-by-state
   specification, the following should be interpreted as a rough
   sequence of an envisioned file delivery receiver.

   1.  The receiver obtains the description of the file delivery session
       identified by the (source IP address, Transport Session
       Identifier) pair.  The receiver also obtains the destination IP
       addresses and respective ports associated with the file delivery
       session.

   2.  The receiver joins the channels in order to receive packets
       associated with the file delivery session.  The receiver may
       schedule this join operation utilizing the timing information
       contained in a possible description of the file delivery session.

   3.  The receiver receives ALC/LCT packets associated with the file
       delivery session.  The receiver checks that the packets match the
       declared Transport Session Identifier.  If not, the packets are
       silently discarded.

   4.  While receiving, the receiver demultiplexes packets based on
       their TOI and stores the relevant packet information in an
       appropriate area for recovery of the corresponding file.
       Multiple files can be reconstructed concurrently.

   5.  The receiver recovers an object.  An object can be recovered when
       an appropriate set of packets containing Encoding Symbols for the
       transmission object has been received.  An appropriate set of
       packets is dependent on the properties of the FEC Encoding ID and
       FEC Instance ID, and on other information contained in the FEC
       Object Transmission Information.

   6.  Objects with TOI = 0 are reserved for FDT Instances.  All FDT
       Instances are signaled by including an EXT_FDT Header Extension
       in the LCT header.  The EXT_FDT header contains an FDT Instance
       ID (i.e., an FDT version number).  If the object has an FDT
       Instance ID 'N', the receiver parses the payload of the instance
       'N' of the FDT and updates its FDT database accordingly.

   7.  If the object recovered is not an FDT Instance but a file, the
       receiver looks up its FDT database to get the properties
       described in the database, and assigns the file the given
       properties.  The receiver also checks that the received content





<span class="grey">Paila, et al.                Standards Track                   [Page 44]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-45"></span>
<span class="grey"><a href="./rfc6726">RFC 6726</a>                          FLUTE                    November 2012</span>


       length matches with the description in the database.  Optionally,
       if an MD5 checksum has been used, the receiver checks that the
       calculated MD5 matches the description in the FDT database.

   8.  The actions the receiver takes with imperfectly received files
       (missing data, mismatching content integrity digest, etc.) are
       outside the scope of this specification.  When a file is
       recovered before the associated file description entry is
       available, a possible behavior is to wait until an FDT Instance
       is received that includes the missing properties.

   9.  If the file delivery session end time has not been reached, go
       back to step 3.  Otherwise, end.

<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/Appendix%20B.%20%20Example%20of%20FDT%20Instance%20%28Informative%29"></a><a class="selflink" href="#appendix-B" id="appendix-B">Appendix B</a>.  Example of FDT Instance (Informative)</span>

   &lt;?xml version="1.0" encoding="UTF-8"?&gt;
   &lt;FDT-Instance xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
     xsi:schemaLocation="urn:ietf:params:xml:ns:fdt
                         ietf-flute-fdt.xsd"
     Expires="2890842807"&gt;
     &lt;File
       Content-Location="http://www.example.com/menu/tracklist.html"
       TOI="1"
       Content-Type="text/html"/&gt;
     &lt;File
       Content-Location="http://www.example.com/tracks/track1.mp3"
       TOI="2"
       Content-Length="6100"
       Content-Type="audio/mp3"
       Content-Encoding="gzip"
       Content-MD5="+VP5IrWploFkZWc11iLDdA=="
       Some-Private-Extension-Tag="abc123"/&gt;
   &lt;/FDT-Instance&gt;

















<span class="grey">Paila, et al.                Standards Track                   [Page 45]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-46"></span>
<span class="grey"><a href="./rfc6726">RFC 6726</a>                          FLUTE                    November 2012</span>


Authors' Addresses

   Toni Paila
   Nokia
   Itamerenkatu 11-13
   Helsinki  00180
   Finland

   EMail: toni.paila@gmail.com


   Rod Walsh
   Nokia/Tampere University of Technology
   P.O. Box 553 (Korkeakoulunkatu 1)
   Tampere  FI-33101
   Finland

   EMail: roderick.walsh@tut.fi


   Michael Luby
   Qualcomm Technologies, Inc.
   2030 Addison Street, Suite 420
   Berkeley, CA  94704
   USA

   EMail: luby@qti.qualcomm.com


   Vincent Roca
   INRIA
   655, av. de l'Europe
   Inovallee; Montbonnot
   ST ISMIER cedex  38334
   France

   EMail: vincent.roca@inria.fr


   Rami Lehtonen
   TeliaSonera
   Hatanpaankatu 1
   Tampere  FIN-33100
   Finland

   EMail: rami.lehtonen@teliasonera.com





Paila, et al.                Standards Track                   [Page 46]
</pre>
</body></html>