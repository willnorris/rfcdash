<html><head></head><body><pre>Network Working Group                                   J. Schoenwaelder
Request for Comments: 3179                               TU Braunschweig
Obsoletes: <a href="./rfc2593">2593</a>                                               J. Quittek
Category: Experimental                                   NEC Europe Ltd.
                                                            October 2001


             <span class="h1">Script MIB Extensibility Protocol Version 1.1</span>

Status of this Memo

   This memo defines an Experimental Protocol for the Internet
   community.  It does not specify an Internet standard of any kind.
   Discussion and suggestions for improvement are requested.
   Distribution of this memo is unlimited.

Copyright Notice

   Copyright (C) The Internet Society (2001).  All Rights Reserved.

Abstract

   The Script MIB extensibility protocol (SMX) defined in this memo
   separates language specific runtime systems from language independent
   Script MIB implementations.  The IETF Script MIB defines an interface
   for the delegation of management functions based on the Internet
   management framework.  A management script is a set of instructions
   that are executed by a language specific runtime system.

Table of Contents

   <a href="#section-1">1</a> Introduction .................................................    <a href="#page-2">2</a>
   <a href="#section-2">2</a> Process Model and Communication Model ........................    <a href="#page-3">3</a>
   <a href="#section-3">3</a> Security Profiles ............................................    <a href="#page-4">4</a>
   <a href="#section-4">4</a> Start of Runtime Systems and Connection Establishment ........    <a href="#page-4">4</a>
   <a href="#section-5">5</a> SMX Messages .................................................    <a href="#page-5">5</a>
   <a href="#section-5.1">5.1</a> Common Definitions .........................................    <a href="#page-5">5</a>
   <a href="#section-5.2">5.2</a> Commands ...................................................    <a href="#page-7">7</a>
   <a href="#section-5.3">5.3</a> Replies ....................................................    <a href="#page-7">7</a>
   <a href="#section-6">6</a> Elements of Procedure ........................................    <a href="#page-9">9</a>
   <a href="#section-6.1">6.1</a> SMX Message Processing on the Runtime Systems ..............    <a href="#page-9">9</a>
   <a href="#section-6.1.1">6.1.1</a> Processing the `hello' Command ...........................   <a href="#page-10">10</a>
   <a href="#section-6.1.2">6.1.2</a> Processing the `start' Command ...........................   <a href="#page-10">10</a>
   <a href="#section-6.1.3">6.1.3</a> Processing the `suspend' Command .........................   <a href="#page-11">11</a>
   <a href="#section-6.1.4">6.1.4</a> Processing the `resume' Command ..........................   <a href="#page-12">12</a>
   <a href="#section-6.1.5">6.1.5</a> Processing the `abort' Command ...........................   <a href="#page-12">12</a>
   <a href="#section-6.1.6">6.1.6</a> Processing the `status' Command ..........................   <a href="#page-12">12</a>
   <a href="#section-6.1.7">6.1.7</a> Generation of Asynchronous Notifications .................   <a href="#page-13">13</a>



<span class="grey">Schoenwaelder &amp; Quittek       Experimental                      [Page 1]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-2"></span>
<span class="grey"><a href="./rfc3179">RFC 3179</a>                    SMX Protocol 1.1                October 2001</span>


   <a href="#section-6.2">6.2</a> SMX Message Processing on the SNMP Agent ...................   <a href="#page-13">13</a>
   <a href="#section-6.2.1">6.2.1</a> Creating a Runtime System ................................   <a href="#page-14">14</a>
   <a href="#section-6.2.2">6.2.2</a> Generating the `hello' Command ...........................   <a href="#page-14">14</a>
   <a href="#section-6.2.3">6.2.3</a> Generating the `start' Command ...........................   <a href="#page-15">15</a>
   <a href="#section-6.2.4">6.2.4</a> Generating the `suspend' Command .........................   <a href="#page-16">16</a>
   <a href="#section-6.2.5">6.2.5</a> Generating the `resume' Command ..........................   <a href="#page-16">16</a>
   <a href="#section-6.2.6">6.2.6</a> Generating the `abort' Command ...........................   <a href="#page-17">17</a>
   <a href="#section-6.2.7">6.2.7</a> Generating the `status' Command ..........................   <a href="#page-18">18</a>
   <a href="#section-6.2.8">6.2.8</a> Processing Asynchronous Notifications ....................   <a href="#page-19">19</a>
   <a href="#section-7">7</a> Example SMX Message Flow .....................................   <a href="#page-20">20</a>
   <a href="#section-8">8</a> Transport Mappings ...........................................   <a href="#page-20">20</a>
   <a href="#section-8.1">8.1</a> SMX over Bi-directional Pipes ..............................   <a href="#page-21">21</a>
   <a href="#section-8.2">8.2</a> SMX over TCP ...............................................   <a href="#page-21">21</a>
   <a href="#section-9">9</a> Security Considerations ......................................   <a href="#page-21">21</a>
   <a href="#section-10">10</a> Changes from <a href="./rfc2593">RFC 2593</a> .......................................   <a href="#page-22">22</a>
   <a href="#section-11">11</a> Acknowledgments .............................................   <a href="#page-23">23</a>
   <a href="#section-12">12</a> References ..................................................   <a href="#page-23">23</a>
   <a href="#section-13">13</a> Authors' Addresses ..........................................   <a href="#page-24">24</a>
   <a href="#section-14">14</a> Full Copyright Statement ....................................   <a href="#page-25">25</a>

<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/1.%20%20Introduction"></a><a class="selflink" href="#section-1" id="section-1">1</a>.  Introduction</span>

   The Script MIB [<a href="#ref-1" title='"Definitions of Managed Objects for the Delegation of Management Scripts"'>1</a>] defines a standard interface for the delegation of
   management functions based on the Internet management framework.  In
   particular, it provides the following capabilities:

   1. Transfer of management scripts to a distributed manager.

   2. Initiating, suspending, resuming and terminating management
      scripts.

   3. Transfer of arguments for management scripts.

   4. Monitoring and control of running management scripts.

   5. Transfer of results produced by management scripts.

   A management script is a set of instructions executed by a language
   specific runtime system.  The Script MIB does not prescribe a
   specific language.  Instead, it allows to control scripts written in
   different languages that are executing concurrently.

   The Script MIB Extensibility protocol (SMX) defined in this memo can
   be used to separate language specific runtime systems from the
   runtime system independent Script MIB implementations.  The
   lightweight SMX protocol can be used to support different runtime
   systems without any changes to the language neutral part of a Script
   MIB implementation.



<span class="grey">Schoenwaelder &amp; Quittek       Experimental                      [Page 2]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-3"></span>
<span class="grey"><a href="./rfc3179">RFC 3179</a>                    SMX Protocol 1.1                October 2001</span>


   Examples of languages and runtime systems considered during the
   design of the SMX protocol are the Java virtual machine [<a href="#ref-2" title='"The Java Virtual Machine Specification"'>2</a>] and the
   Tool Command Language (Tcl) [<a href="#ref-3" title='"Tcl and the Tk Toolkit"'>3</a>].  Other languages with comparable
   features should be easy to integrate as well.

<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/2.%20%20Process%20Model%20and%20Communication%20Model"></a><a class="selflink" href="#section-2" id="section-2">2</a>.  Process Model and Communication Model</span>

   Figure 1 shows the process and communication model underlying the SMX
   protocol.  The language and runtime system independent SNMP agent
   implementing the Script MIB communicates with one ore more runtime
   systems via the SMX protocol.  A runtime system may be able to
   execute one or multiple scripts simultaneously (multi-threading).
   The SMX protocol supports multi-threading, but it does not require
   multi-threaded runtime systems.

   The SMX protocol uses a local storage device (usually implemented on
   top of the local file system) to transfer scripts from the SNMP agent
   to the runtime systems.  The SNMP agent has read and write access to
   the script storage device while the runtime systems only need read
   access.  The SMX protocol passes the location of a script in the
   local storage device to the runtime engines.  It is then the
   responsibility of the runtime engines to load the script from the
   specified location.

                                                   runtime 1
                  +--------------+       SMX      +---------+
                  |              |&lt;--------------&gt;| O  O  O |&lt;-+
          SNMP    |  Script MIB  |                +---------+  |
      &lt;----------&gt;|              |                             |
                  |  SNMP Agent  |                 runtime 2   |
                  |              |       SMX      +---------+  |
                  |              |&lt;--------------&gt;| O       |  |
                  +--------------+                +---------+  |
                          ^                            ^       |
                          |       +---------+          |       |
                          |       | script  |----------+       |
                          +------&gt;| storage |------------------+
                                  +---------+

          Figure 1: SMX process and communication model











<span class="grey">Schoenwaelder &amp; Quittek       Experimental                      [Page 3]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-4"></span>
<span class="grey"><a href="./rfc3179">RFC 3179</a>                    SMX Protocol 1.1                October 2001</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/3.%20%20Security%20Profiles"></a><a class="selflink" href="#section-3" id="section-3">3</a>.  Security Profiles</span>

   Security profiles control what a running script is allowed to do.  It
   is useful to distinguish two different classes of security profiles:

   -  The operating system security profile specifies the set of
      operating system services that can be used by the operating system
      level process which executes a script.  Under UNIX, this maps to
      the effective user and group identity for the running process.  In
      addition, many UNIX versions allow to set other resource limits,
      such as the number of open files or the maximum stack sizes.
      Another mechanism in UNIX is the chroot() system call which
      changes the file system root for a process.  The chroot()
      mechanism can be used to prevent runtime systems from accessing
      any system files.  It is suggested to make use of all applicable
      operating system security mechanism in order to protect the
      operating system from malicious scripts or runtime systems.

   -  Secure runtime systems provide fine grained control over the set
      of services that can be used by a running script at a particular
      point during script execution.  A runtime security profile
      specifying fine grained access control is runtime system
      dependent.  For a Java virtual machine, the runtime security
      profile is interpreted by the SecurityManager and ClassLoader
      classes[4].  For Tcl, the runtime security profile maps to the
      interpreter's security profile [<a href="#ref-5" title='"The Safe-Tcl Security Model"'>5</a>].

   The SMX protocol allows to execute scripts under different operating
   system profiles and runtime system profiles.  Multiple operating
   system security profiles are realized by using multiple runtime
   systems which execute in operating system processes with different
   security profiles.  Multiple runtime security profiles are supported
   by passing a security profile name to a runtime system during script
   invocation.

   The Script MIB does not define how operating system or runtime system
   security profiles are identified.  This memo suggests that the
   smLaunchOwner is mapped to an operating system security profile and a
   runtime system security profile when a script is started.

<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/4.%20%20Start%20of%20Runtime%20Systems%20and%20Connection%20Establishment"></a><a class="selflink" href="#section-4" id="section-4">4</a>.  Start of Runtime Systems and Connection Establishment</span>

   The SNMP agent starts runtime systems based on the static properties
   of the runtime system (multi-threaded or single-threaded) and the
   operating system security profiles.  Starting a new runtime system
   requires to create a process environment which matches the operating
   system security profile.




<span class="grey">Schoenwaelder &amp; Quittek       Experimental                      [Page 4]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-5"></span>
<span class="grey"><a href="./rfc3179">RFC 3179</a>                    SMX Protocol 1.1                October 2001</span>


   In order to prevent SMX communication from untrusted peers the SNMP
   agent has to choose a secure SMX transport.  This memo defines two
   transports in <a href="#section-8">Section 8</a>: (a) a bi-directional pipe using standard
   input/output streams on the runtime engine side, and (b) a TCP
   connection where the SNMP agent acts as a listening server that
   accepts only connections from local runtime engines that authenticate
   themselves with a secret shared between the agent and the runtime
   engine.

<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/5.%20%20SMX%20Messages"></a><a class="selflink" href="#section-5" id="section-5">5</a>.  SMX Messages</span>

   The message formats described below are defined using the Augmented
   BNF (ABNF) defined in <a href="./rfc2234">RFC 2234</a> [<a href="#ref-6" title='"Augmented BNF for Syntax Specifications: ABNF"'>6</a>].  The definitions for `ALPHA',
   `DIGIT', `HEXDIG', `WSP', `CRLF', `CR', `LF', `HTAB', `VCHAR' and
   `DQUOTE' are imported from <a href="./rfc2234#appendix-A">appendixÂ A of RFC 2234</a> and not repeated
   here.

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/5.1.%20%20Common%20Definitions"></a><a class="selflink" href="#section-5.1" id="section-5.1">5.1</a>.  Common Definitions</span>

   The following ABNF definitions are used in subsequent sections to
   define the SMX protocol messages.

   Zero          = %x30          ; the ASCII character '0'

   ProfileChars  = DIGIT / ALPHA / %x2D-2F / %x3A / %x5F
                                 ; digits, alphas, and the characters
                                 ; '-', '.', '/', ':', '_'

   QuotedString  = DQUOTE *(VCHAR / WSP) DQUOTE

   HexString     = 1*(HEXDIG HEXDIG)

   Id            = 1*DIGIT       ; identifier for an SMX transaction

   Script        = QuotedString  ; script file name

   RunId         = 1*DIGIT       ; globally unique identifier for a
                                 ; running script (note, smRunIndex
                                 ; is only unique for a smLaunchOwner,
                                 ; smLaunchName pair)

   Profile       = 1*ProfileChars ; security profile name

   RunState      =  "1"          ; smRunState `initializing'
   RunState      =/ "2"          ; smRunState `executing'
   RunState      =/ "3"          ; smRunState `suspending'
   RunState      =/ "4"          ; smRunState `suspended'
   RunState      =/ "5"          ; smRunState `resuming'



<span class="grey">Schoenwaelder &amp; Quittek       Experimental                      [Page 5]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-6"></span>
<span class="grey"><a href="./rfc3179">RFC 3179</a>                    SMX Protocol 1.1                October 2001</span>


   RunState      =/ "6"          ; smRunState `aborting'
   RunState      =/ "7"          ; smRunState `terminated'

   ExitCode      =  "1"          ; smRunExitCode `noError'
   ExitCode      =/ "2"          ; smRunExitCode `halted'
   ExitCode      =/ "3"          ; smRunExitCode `lifeTimeExceeded'
   ExitCode      =/ "4"          ; smRunExitCode `noResourcesLeft'
   ExitCode      =/ "5"          ; smRunExitCode `languageError'
   ExitCode      =/ "6"          ; smRunExitCode `runtimeError'
   ExitCode      =/ "7"          ; smRunExitCode `invalidArgument'
   ExitCode      =/ "8"          ; smRunExitCode `securityViolation'
   ExitCode      =/ "9"          ; smRunExitCode `genericError'

   Authenticator = HexString     ; authentication cookie

   Version       = "SMX/1.1"     ; current version of the SMX protocol

   Argument      = HexString / QuotedString      ; see smRunArgument

   Result        = HexString / QuotedString      ; see smRunResult

   ErrorMsg      = HexString / QuotedString      ; see smRunError

   The definition of QuotedString requires further explanation.  A
   quoted string may contain special character sequences, all starting
   with the backslash character (%x5C).  The interpretation of these
   sequences is as follows:

            `\\'   backslash character       (`%x5C')
            `\t'   tab character             (`HTAB')
            `\n'   newline character         (`LF')
            `\r'   carriage-return character (`CR')
            `\"'   quote character           (`DQUOTE')

   In all other cases not listed above, the backslash is dropped and the
   following character is treated as an ordinary character.

   `Argument' and `Result' is either a QuotedString or a HexString.  The
   Script MIB defines script arguments and results as arbitrary octet
   strings.  The SMX protocol supports a binary and a human readable
   representation since it is likely that printable argument and result
   strings will be used frequently.  However, an implementation must be
   able to handle both formats in order to be compliant with the Script
   MIB.

   The `Authenticator' is a HexString which does not carry any semantics
   other than being a random sequence of bytes.  It is therefore not
   necessary to have a human readable representation.



<span class="grey">Schoenwaelder &amp; Quittek       Experimental                      [Page 6]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-7"></span>
<span class="grey"><a href="./rfc3179">RFC 3179</a>                    SMX Protocol 1.1                October 2001</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/5.2.%20%20Commands"></a><a class="selflink" href="#section-5.2" id="section-5.2">5.2</a>.  Commands</span>

   The following ABNF definitions define the set of SMX commands which
   can be sent from the SNMP agent to a runtime system.

      Command =  "hello"   WSP Id CRLF

      Command =/ "start"   WSP Id WSP RunId WSP Script WSP Profile
                           WSP Argument CRLF

      Command =/ "suspend" WSP Id WSP RunId CRLF

      Command =/ "resume"  WSP Id WSP RunId CRLF

      Command =/ "abort"   WSP Id WSP RunId CRLF

      Command =/ "status"  WSP Id WSP RunId CRLF

   The `hello' command is always the first command sent over a SMX
   connection.  It is used to identify and authenticate the runtime
   system.  The `start' command starts the execution of a script.  The
   `suspend', `resume' and `abort' commands can be used to change the
   status of a running script.  The `status' command is used to retrieve
   status information for a running script.

   There is no compile command.  It is the responsibility of the SNMP
   agent to perform any compilation steps as needed before using the SMX
   `start' command.  There is no SMX command to shutdown a runtime
   system.  Closing the connection must be interpreted as a request to
   terminate all running scripts in that runtime system and to shutdown
   the runtime system.

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/5.3.%20%20Replies"></a><a class="selflink" href="#section-5.3" id="section-5.3">5.3</a>.  Replies</span>

   Every reply message starts with a three digit reply code and ends
   with `CRLF'.  The three digits in a reply code have a special
   meaning.  The first digit identifies the class of a reply message.
   The following classes exist:

      1yz   transient positive response
      2yz   permanent positive response
      3yz   transient negative response
      4yz   permanent negative response
      5yz   asynchronous notification

   The classes 1yz and 3yz are currently not used by SMX version 1.1.
   They are defined only for future SMX extensions.




<span class="grey">Schoenwaelder &amp; Quittek       Experimental                      [Page 7]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-8"></span>
<span class="grey"><a href="./rfc3179">RFC 3179</a>                    SMX Protocol 1.1                October 2001</span>


   The second digit encodes the specific category.  The following
   categories exist:

   x0z   syntax errors that don't fit any other category
   x1z   replies for commands targeted at the whole runtime system
   x2z   replies for commands targeted at scripts
   x3z   replies for commands targeted at running instances of scripts

   The third digit gives a finer gradation of meaning in each category
   specified by the second digit.  Below is the ABNF definition of all
   reply messages and codes:

      Reply =  "211" WSP Id WSP Version *1(WSP Authenticator) CRLF
                                    ; identification of the
                                    ; runtime system

      Reply =/ "231" WSP Id WSP RunState CRLF
                                    ; status of a running script

      Reply =/ "232" WSP Id CRLF    ; abort of a running script

      Reply =/ "401" WSP Id CRLF    ; syntax error in command

      Reply =/ "402" WSP Id CRLF    ; unknown command

      Reply =/ "421" WSP Id CRLF    ; unknown or illegal Script

      Reply =/ "431" WSP Id CRLF    ; unknown or illegal RunId

      Reply =/ "432" WSP Id CRLF    ; unknown or illegal Profile

      Reply =/ "433" WSP Id CRLF    ; illegal Argument

      Reply =/ "434" WSP Id CRLF    ; unable to change the status of
                                    ; a running script

      Reply =/ "511" WSP Zero WSP QuotedString CRLF
                                    ; an arbitrary message send from
                                    ; the runtime system

      Reply =/ "531" WSP Zero WSP RunId WSP RunState CRLF
                                    ; asynchronous running script
                                    ; status change

      Reply =/ "532" WSP Zero WSP RunId WSP RunState WSP Result CRLF
                                    ; intermediate script result





<span class="grey">Schoenwaelder &amp; Quittek       Experimental                      [Page 8]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-9"></span>
<span class="grey"><a href="./rfc3179">RFC 3179</a>                    SMX Protocol 1.1                October 2001</span>


      Reply =/ "533" WSP Zero WSP RunId WSP RunState WSP Result CRLF
                                    ; intermediate script result that
                                    ; triggers an event report

      Reply =/ "534" WSP Zero WSP RunId WSP Result CRLF
                                    ; normal script termination,
                                    ; deprecated

      Reply =/ "535" WSP Zero WSP RunId WSP ExitCode WSP ErrorMsg CRLF
                                    ; abnormal script termination,
                                    ; deprecated

      Reply =/ "536" WSP Zero WSP RunId WSP RunState WSP ErrorMsg CRLF
                                    ; script error

      Reply =/ "537" WSP Zero WSP RunId WSP RunState WSP ErrorMsg CRLF
                                    ; script error that
                                    ; triggers an event report

      Reply =/ "538" WSP Zero WSP RunId WSP ExitCode CRLF
                                    ; script termination

<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/6.%20%20Elements%20of%20Procedure"></a><a class="selflink" href="#section-6" id="section-6">6</a>.  Elements of Procedure</span>

   This section describes in detail the processing steps performed by
   the SNMP agent and the runtime system with regard to the SMX
   protocol.

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/6.1.%20%20SMX%20Message%20Processing%20on%20the%20Runtime%20Systems"></a><a class="selflink" href="#section-6.1" id="section-6.1">6.1</a>.  SMX Message Processing on the Runtime Systems</span>

   This section describes the processing of SMX command messages by a
   runtime engine and the conditions under which asynchronous
   notifications are generated.

   When the runtime system receives a message, it first tries to
   recognize a command consisting of the command string and the
   transaction identifier.  If the runtime system is not able to extract
   both the command string and the transaction identifier, then the
   message is discarded.  An asynchronous `511' reply may be generated
   in this case.  Otherwise, the command string is checked to be valid,
   i.e.  to be one of the strings `hello', `start', `suspend', `resume',
   `abort', or `status'.  If the string is invalid, a `402' reply is
   sent and processing of the message stops.  If a valid command has
   been detected, further processing of the message depends on the
   command as described below.






<span class="grey">Schoenwaelder &amp; Quittek       Experimental                      [Page 9]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-10"></span>
<span class="grey"><a href="./rfc3179">RFC 3179</a>                    SMX Protocol 1.1                October 2001</span>


   The command specific processing describes several possible syntax
   errors for which specific reply messages are generated.  If the
   runtime engine detects any syntax error which is not explicitly
   mentioned or which cannot be identified uniquely, a generic `401'
   reply is sent indicating that the command cannot be executed.

<span class="h4"><a class="dashAnchor" name="//apple_ref/cpp/Section/6.1.1.%20%20Processing%20the%20%60hello%27%20Command"></a><a class="selflink" href="#section-6.1.1" id="section-6.1.1">6.1.1</a>.  Processing the `hello' Command</span>

   When the runtime system receives a `hello' command, it processes it
   as follows:

   1. The runtime system sends a `211' reply.  If the runtime system has
      access to a shared secret, then the reply must contain the
      optional `Authenticator', which is a function of the shared
      secret.

<span class="h4"><a class="dashAnchor" name="//apple_ref/cpp/Section/6.1.2.%20%20Processing%20the%20%60start%27%20Command"></a><a class="selflink" href="#section-6.1.2" id="section-6.1.2">6.1.2</a>.  Processing the `start' Command</span>

   When the runtime system receives a `start' command, it processes it
   as follows:

   1. The syntax of the arguments of the `start' command is checked.
      The following four checks must be made:

      (a) The syntax of the `RunId' parameter is checked and a `431'
          reply is sent if any syntax error is detected.

      (b) The syntax of the `Script' parameter is checked and a `421'
          reply is sent if any syntax error is detected.

      (c) The syntax of the `Profile' parameter is checked and a `432'
          reply is sent if any syntax error is detected.

      (d) If syntax of the `Argument' parameter is checked and a `433'
          reply is sent if any syntax error is detected.

   2. The runtime system checks whether the new `RunId' is already in
      use.  If yes, a `431' reply is sent and processing stops.

   3. The runtime system checks whether the `Script' parameter is the
      name of a file on the local storage device, that can be read.  A
      `421' reply is sent and processing stops if the file does not
      exist or is not readable.

   4. The runtime system checks whether the security profile is known
      and sends a `432' reply and stops processing if not.

   5. The runtime engine starts the script given by the script name.



<span class="grey">Schoenwaelder &amp; Quittek       Experimental                     [Page 10]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-11"></span>
<span class="grey"><a href="./rfc3179">RFC 3179</a>                    SMX Protocol 1.1                October 2001</span>


      When the script has been started, a `231' reply is sent including
      the current run state.

   Processing of the `start' command stops, when the script reaches the
   state `running'.  For each asynchronous state change of the running
   script, a `531' reply is sent.  Processing of the `start' command is
   also stopped if an error occurs before the state `running' is
   reached.  In this case, the run is aborted and a `538' reply is
   generated.  An optional `536' reply can be send before the `538'
   reply to report an error message.

   If an `abort' command or a `suspend' command for the running script
   is received before processing of the `start' command is complete,
   then the processing of the `start' command may be stopped before the
   state `running' is reached.  In this case, the resulting status of
   the running script is given by the respective reply to the `abort' or
   `suspend' command, and no reply with the transaction identifier of
   the `start' command is generated.

<span class="h4"><a class="dashAnchor" name="//apple_ref/cpp/Section/6.1.3.%20%20Processing%20the%20%60suspend%27%20Command"></a><a class="selflink" href="#section-6.1.3" id="section-6.1.3">6.1.3</a>.  Processing the `suspend' Command</span>

   When the runtime system receives a `suspend' command, it processes it
   as follows:

   1. If there is a syntax error in the running script identifier or if
      there is no running script matching the identifier, a `431' reply
      is sent and processing of the command is stopped.

   2. If the running script is already in the state `suspended', a `231'
      reply is sent and processing of the command is stopped.

   3. If the running script is in the state `running', it is suspended
      and a `231' reply is sent after suspending.  If suspending fails,
      a `434' reply is sent and processing of the command is stopped.

   4. If the running script has not yet reached the state `running' (the
      `start' command still being processed), it may reach the state
      `suspended' without having been in the state `running'.  After
      reaching the state `suspended', a `231' reply is sent.

   5. If the running script is in any other state, a `434' reply is
      sent.









<span class="grey">Schoenwaelder &amp; Quittek       Experimental                     [Page 11]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-12"></span>
<span class="grey"><a href="./rfc3179">RFC 3179</a>                    SMX Protocol 1.1                October 2001</span>


<span class="h4"><a class="dashAnchor" name="//apple_ref/cpp/Section/6.1.4.%20%20Processing%20the%20%60resume%27%20Command"></a><a class="selflink" href="#section-6.1.4" id="section-6.1.4">6.1.4</a>.  Processing the `resume' Command</span>

   When the runtime system receives a `resume' command, it processes it
   as follows:

   1. If there is a syntax error in the running script identifier or if
      there is no running script matching the identifier, a `431' reply
      is sent and processing of the command is stopped.

   2. If the running script is already in the state `running', a `231'
      reply is sent and processing of the command is stopped.

   3. If the running script is in the state `suspended', it is resumed
      and a `231' reply is sent after resuming.  If resuming fails, a
      `434' reply is sent and processing of the command is stopped.

   4. If the `start' command is still being processed for the script, a
      `231' reply is sent when the state `running' has been reached.

   5. If the running script is in any other state, a `434' reply is
      sent.

<span class="h4"><a class="dashAnchor" name="//apple_ref/cpp/Section/6.1.5.%20%20Processing%20the%20%60abort%27%20Command"></a><a class="selflink" href="#section-6.1.5" id="section-6.1.5">6.1.5</a>.  Processing the `abort' Command</span>

   When the runtime system receives an `abort' command, it processes it
   as follows:

   1. If there is a syntax error in the running script identifier or if
      there is no running script matching the identifier, a `431' reply
      is sent and processing of the command is stopped.

   2. If the running script is already aborted, a `232' reply is sent
      and processing of the command is stopped.

   3. The running script is aborted and a `232' reply is sent after
      aborting.  If aborting fails, a `434' reply is sent and processing
      is stopped.

<span class="h4"><a class="dashAnchor" name="//apple_ref/cpp/Section/6.1.6.%20%20Processing%20the%20%60status%27%20Command"></a><a class="selflink" href="#section-6.1.6" id="section-6.1.6">6.1.6</a>.  Processing the `status' Command</span>

   When the runtime system receives a `status' command, it processes it
   as follows:

   1. If there is a syntax error in the running script identifier or if
      there is no running script matching the identifier, a `431' reply
      is sent and processing of the command is stopped.

   2. The status of the script is obtained and a `231' reply is sent.



<span class="grey">Schoenwaelder &amp; Quittek       Experimental                     [Page 12]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-13"></span>
<span class="grey"><a href="./rfc3179">RFC 3179</a>                    SMX Protocol 1.1                October 2001</span>


<span class="h4"><a class="dashAnchor" name="//apple_ref/cpp/Section/6.1.7.%20%20Generation%20of%20Asynchronous%20Notifications"></a><a class="selflink" href="#section-6.1.7" id="section-6.1.7">6.1.7</a>.  Generation of Asynchronous Notifications</span>

   The runtime system generates or may generate the following
   notifications:

   1. If a change of the status of a running script is observed by the
      runtime system, a `531' reply is sent.

   2. A `534' reply is sent if a running script terminates normally.
      This reply is deprecated.  You can emulate this reply with a
      combination of a `532' reply and a `538' reply.

   3. A `535' reply is sent if a running script terminates abnormally.
      This reply is deprecated.  You can emulate this reply with a
      combination of a `536' reply and a `538' reply.

   4. A `532' reply is sent if a script generates an intermediate
      result.

   5. A `533' reply is sent if a script generates an intermediate result
      which causes the generation of a `smScriptResult' notification.

   6. A `536' reply is sent if a running script produces an error.  If
      the error is fatal, the script execution will be terminated and a
      538 reply will follow.  Otherwise, if the error is non-fatal, the
      script continues execution.

   7. A `537' reply is sent if a running script produces an error which
      should cause the generation of a `smScriptException' notification.
      If the error is fatal, the script execution will be terminated and
      a 538 reply will follow.  Otherwise, if the error is non-fatal,
      the script continues execution.

   8. A `538' reply is sent if a running script terminates.  The
      ExitCode is used to distinguish between normal termination
      (`noError') or abnormal termination.

   9. Besides the notifications mentioned above, the runtime system may
      generate arbitrary `511' replies, which are logged or displayed by
      the SNMP agent.

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/6.2.%20%20SMX%20Message%20Processing%20on%20the%20SNMP%20Agent"></a><a class="selflink" href="#section-6.2" id="section-6.2">6.2</a>.  SMX Message Processing on the SNMP Agent</span>

   This section describes the conditions under which an SNMP agent
   implementing the Script MIB generates SMX commands.  It also
   describes how the SNMP agent processes replies to SMX commands.





<span class="grey">Schoenwaelder &amp; Quittek       Experimental                     [Page 13]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-14"></span>
<span class="grey"><a href="./rfc3179">RFC 3179</a>                    SMX Protocol 1.1                October 2001</span>


<span class="h4"><a class="dashAnchor" name="//apple_ref/cpp/Section/6.2.1.%20%20Creating%20a%20Runtime%20System"></a><a class="selflink" href="#section-6.2.1" id="section-6.2.1">6.2.1</a>.  Creating a Runtime System</span>

   New runtime systems are started by the SNMP agent while processing
   set requests for a `smLaunchStart' variable.  The SNMP agent first
   searches for an already running runtime systems which matches the
   security profiles associated with the `smLaunchStart' variable.  If
   no suitable runtime system is available, a new runtime system is
   started by either

   (a) starting the executable for the runtime system in a new process
       which conforms to the operating system security profile, and
       establishing a bi-directional pipe to the runtime systems
       standard input/output streams to be used for SMX transport, or

   (b) preparing the environment for the new runtime system and starting
       the executable for the runtime system in a new process which
       conforms to the operating system security profile.  The SNMP
       agent prepares to accept a connection from the new runtime
       system.

   The `smRunState' of all scripts that should be executed in the new
   runtime system is set to `initializing'.

<span class="h4"><a class="dashAnchor" name="//apple_ref/cpp/Section/6.2.2.%20%20Generating%20the%20%60hello%27%20Command"></a><a class="selflink" href="#section-6.2.2" id="section-6.2.2">6.2.2</a>.  Generating the `hello' Command</span>

   The `hello' command is generated once an SMX connection is
   established.  The SNMP agent sends the `hello' command as defined in
   <a href="#section-5.2">section 5.2</a>.  The SNMP agent then expects a reply from the runtime
   system within a reasonable timeout interval.

   1. If the timeout expires before the SNMP agent received a reply,
      then the connection is closed and all data associated with it is
      deleted.  Any scripts that should be running in this runtime
      system are aborted, the `smRunExitCode' is set to `genericError'
      and `smRunError' is modified to describe the error situation.

   2. If the received message can not be analyzed because it does not
      have the required format, then the connection is closed and all
      data associated with it is deleted.  Any scripts that should be
      running in this runtime system are aborted, the `smRunExitCode' is
      set to `genericError' and `smRunError' is modified to describe the
      error situation.

   3. If the received message is a `211' reply, then the `Id' is checked
      whether it matches the `Id' used in the `hello' command.  If the
      `Id' matches, then the `Version' is checked.  If the `Version'
      matches a supported SMX protocol version, then, if present, the
      `Authenticator' is checked.  If any of the tests fails or if the



<span class="grey">Schoenwaelder &amp; Quittek       Experimental                     [Page 14]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-15"></span>
<span class="grey"><a href="./rfc3179">RFC 3179</a>                    SMX Protocol 1.1                October 2001</span>


      SNMP agent requires an authenticator and it did not receive a
      matching `Authenticator' with the `211' reply, then the connection
      is closed and all data associated with this runtime system is
      deleted.  Any scripts that should be running in this runtime
      system are aborted, the `smRunExitCode' is set to `genericError'
      and `smRunError' is modified to describe the error situation.

   4. Received messages are discarded if none of the previous rules
      applies.

<span class="h4"><a class="dashAnchor" name="//apple_ref/cpp/Section/6.2.3.%20%20Generating%20the%20%60start%27%20Command"></a><a class="selflink" href="#section-6.2.3" id="section-6.2.3">6.2.3</a>.  Generating the `start' Command</span>

   The `start' command is generated while processing set-requests for a
   `smLaunchStart' variable.  The `start' command assumes that the SNMP
   agent already determined a runtime system suitable to execute the
   script associated with the `smLaunchStart' variable.  The SNMP agent
   sends the `start' command as defined in <a href="#section-5.2">section 5.2</a> to the selected
   runtime system.  The SNMP agent then expects a reply from the runtime
   system within a reasonable timeout interval.

   1. If the timeout expires before the SNMP agent received a reply,
      then the SNMP agent sends an `abort' command to abort the running
      script and sets the `RunState' of the running script to
      `terminated', the `smRunExitCode' to `genericError' and
      `smRunError' is modified to describe the timeout situation.

   2. If the received message can not be analyzed because it does not
      have the required format, then the message is ignored.  The SNMP
      agent continues to wait for a valid reply message until the
      timeout expires.

   3. If the received message is a `4yz' reply and the `Id' matches the
      `Id' of the `start' command, then the SNMP agent assumes that the
      script can not be started.  The `smRunState' of the running script
      is set to `terminated', the `smRunExitCode' to `genericError' and
      the `smRunError' is modified to contain a message describing the
      error situation.

   4. If the received message is a `231' reply and the `Id' matches the
      `Id' of the `start' command, then the `smRunState' variable of the
      running script is updated.

   5. Received messages are discarded if none of the previous rules
      applies.







<span class="grey">Schoenwaelder &amp; Quittek       Experimental                     [Page 15]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-16"></span>
<span class="grey"><a href="./rfc3179">RFC 3179</a>                    SMX Protocol 1.1                October 2001</span>


<span class="h4"><a class="dashAnchor" name="//apple_ref/cpp/Section/6.2.4.%20%20Generating%20the%20%60suspend%27%20Command"></a><a class="selflink" href="#section-6.2.4" id="section-6.2.4">6.2.4</a>.  Generating the `suspend' Command</span>

   The `suspend' command is generated while processing set-requests for
   the `smLaunchControl' and `smRunControl' variables which change the
   value to `suspend'.  The SNMP agent sets the `smRunState' variable to
   `suspending' and sends the `suspend' command as defined in <a href="#section-5.2">section</a>
   <a href="#section-5.2">5.2</a>.  The SNMP agent then expects a reply from the runtime system
   within a reasonable timeout interval.

   1. If the timeout expires before the SNMP agent received a reply,
      then the SNMP agent sends an `abort' command to abort the running
      script and sets the `smRunState' of the running script to
      `terminated', the `smRunExitCode' to `genericError' and
      `smRunError' is modified to describe the timeout situation.

   2. If the received message can not be analyzed because it does not
      have the required format, then the message is ignored.  The SNMP
      agent continues to wait for a valid reply message until the
      timeout expires.

   3. If the received message is a `401', `402' or a `431' reply and the
      `Id' matches the `Id' of the `suspend' command, then the runtime
      systems is assumed to not provide the suspend/resume capability
      and processing of the `suspend' command stops.

   4. If the received message is a `231' reply and the `Id' matches the
      `Id' of the `suspend' command, then the `smRunState' variable of
      the running script is updated.

   5. Received messages are discarded if none of the previous rules
      applies.

<span class="h4"><a class="dashAnchor" name="//apple_ref/cpp/Section/6.2.5.%20%20Generating%20the%20%60resume%27%20Command"></a><a class="selflink" href="#section-6.2.5" id="section-6.2.5">6.2.5</a>.  Generating the `resume' Command</span>

   The `resume' command is generated while processing set-requests for
   the `smLaunchControl' and `smRunControl' variables which change the
   value to `resume'.  The SNMP agent sets the `smRunState' variable to
   `resuming' and sends the `resume' command as defined in <a href="#section-5.2">section 5.2</a>.
   The SNMP agent then expects a reply from the runtime system within a
   reasonable timeout interval.

   1. If the timeout expires before the SNMP agent received a reply,
      then the SNMP agent sends an `abort' command to abort the running
      script and sets the `smRunState' of the running script to
      `terminated', the `smRunExitCode' to `genericError' and
      `smRunError' is modified to describe the timeout situation.





<span class="grey">Schoenwaelder &amp; Quittek       Experimental                     [Page 16]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-17"></span>
<span class="grey"><a href="./rfc3179">RFC 3179</a>                    SMX Protocol 1.1                October 2001</span>


   2. If the received message can not be analyzed because it does not
      have the required format, then the message is ignored.  The SNMP
      agent continues to wait for a valid reply message until the
      timeout expires.

   3. If the received message is a `401', `402' or a `431' reply and the
      `Id' matches the `Id' of the `resume' command, then the runtime
      systems is assumed to not provide the suspend/resume capability
      and processing of the `resume' command stops.

   4. If the received message is a `231' reply and the `Id' matches the
      `Id' of the `resume' command, then the `smRunState' variable of
      the running script is updated.

   5. Received messages are discarded if none of the previous rules
      applies.

<span class="h4"><a class="dashAnchor" name="//apple_ref/cpp/Section/6.2.6.%20%20Generating%20the%20%60abort%27%20Command"></a><a class="selflink" href="#section-6.2.6" id="section-6.2.6">6.2.6</a>.  Generating the `abort' Command</span>

   The `abort' command is generated while processing set-requests for
   the `smLaunchControl' and `smRunControl' variables which change the
   value to `abort'.  In addition, the `abort' command is also generated
   if the `smRunLifeTime' variable reaches the value 0.  The SNMP agent
   sends the `abort' command as defined in <a href="#section-5.2">section 5.2</a>.  The SNMP agent
   then expects a reply from the runtime system within a reasonable
   timeout interval.

   1. If the timeout expires before the SNMP agent received a reply,
      then the SNMP agent sets the `smRunState' of the running script to
      `terminated', the `smRunExitCode' to `genericError' and
      `smRunError' is modified to describe the timeout situation.

   2. If the received message can not be analyzed because it does not
      have the required format, then the message is ignored.  The SNMP
      agent continues to wait for a valid reply message until the
      timeout expires.

   3. If the received message is a `4yz' reply and the `Id' matches the
      `Id' of the `abort' command, then the SNMP agent assumes that the
      script can not be aborted.  The `smRunState' of the running script
      is set to `terminated', the `smRunExitCode' to `genericError' and
      the `smRunResult' is modified to describe the error situation.

   4. If the received message is a `232' reply and the `Id' matches the
      `Id' of the `abort' command, then the `smRunExitCode' variable of
      the terminated script is changed to either `halted' (when
      processing a set-request for the `smLaunchControl' and
      `smRunControl' variables) or `lifeTimeExceeded' (if the `abort'



<span class="grey">Schoenwaelder &amp; Quittek       Experimental                     [Page 17]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-18"></span>
<span class="grey"><a href="./rfc3179">RFC 3179</a>                    SMX Protocol 1.1                October 2001</span>


      command was generated because the `smRunLifeTime' variable reached
      the value 0).  The `smRunState' variable is changed to the value
      `terminated'.

   5. Received messages are discarded if none of the previous rules
      applies.

<span class="h4"><a class="dashAnchor" name="//apple_ref/cpp/Section/6.2.7.%20%20Generating%20the%20%60status%27%20Command"></a><a class="selflink" href="#section-6.2.7" id="section-6.2.7">6.2.7</a>.  Generating the `status' Command</span>

   The `status' command is generated either periodically or on demand by
   the SNMP agent in order to retrieve status information from running
   scripts.  The SNMP agent sends the `status' command as defined in
   5.2.  The SNMP agent then expects a reply from the runtime system
   within a reasonable timeout interval.

   1. If the timeout expires before the SNMP agent received a reply,
      then the SNMP agent sends an `abort' command to abort the running
      script and sets the `smRunState' of the running script to
      `terminated', the `smRunExitCode' to `genericError' and
      `smRunError' is modified to describe the timeout situation.

   2. If the received message can not be analyzed because it does not
      have the required format, then the message is ignored.  The SNMP
      agent continues to wait for a valid reply message until the
      timeout expires.

   3. If the received message is a `4yz' reply and the `Id' matches the
      `Id' of the `status' command, then the SNMP agent assumes that the
      script status can not be read, which is a fatal error condition.
      The SNMP agent sends an `abort' command to abort the running
      script.  The `smRunState' of the running script is set to
      `terminated', the `smRunExitCode' to `genericError' and the
      `smRunError' is modified to describe the error situation.

   4. If the received message is a `231' reply and the `Id' matches the
      `Id' of the `status' command, then the `smRunState' variable of
      the running script is updated.

   5. Received messages are discarded if none of the previous rules
      applies.











<span class="grey">Schoenwaelder &amp; Quittek       Experimental                     [Page 18]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-19"></span>
<span class="grey"><a href="./rfc3179">RFC 3179</a>                    SMX Protocol 1.1                October 2001</span>


<span class="h4"><a class="dashAnchor" name="//apple_ref/cpp/Section/6.2.8.%20%20Processing%20Asynchronous%20Notifications"></a><a class="selflink" href="#section-6.2.8" id="section-6.2.8">6.2.8</a>.  Processing Asynchronous Notifications</span>

   The runtime system can send asynchronous status change notifications.
   These `5yz' replies are processed as described below.

   1. If the received message is a `511' reply, then the message is
      displayed or logged appropriately and processing stops.

   2. If the received message is a `531' reply, then the SNMP agent
      checks whether a running script with the given `RunId' exists in
      the runtime system.  Processing of the notification stops if there
      is no running script with the `RunId'.  Otherwise, the
      `smRunState' is updated.

   3. If the received message is a `532' reply, then the SNMP agent
      checks whether a running script with the given `RunId' exists in
      the runtime system.  Processing of the notification stops if there
      is no running script with the `RunId'.  Otherwise, `smRunState'
      and `smRunResult' are updated.

   4. If the received message is a `533' reply, then the SNMP agent
      checks whether a running script with the given `RunId' exists in
      the runtime system.  Processing of the notification stops if there
      is no running script with the `RunId'.  Otherwise, `smRunState'
      and `smRunResult' are updated and the `smScriptResult'
      notification is generated.

   5. If the received message is a `534' reply, then the SNMP agent
      checks whether a running script with the given `RunId' exists in
      the runtime system.  Processing stops if there is no running
      script with the `RunId'.  Otherwise, `smExitCode' is set to
      `noError', `smRunState' is set to `terminated' and `smRunResult'
      is updated.

   6. If the received message is a `535' reply, then the SNMP agent
      checks whether a running script with the given `RunId' exists in
      the runtime system.  Processing stops if there is no running
      script with the `RunId'.  Otherwise, `smRunState' is set to
      `terminated' and `smExitCode' and `smRunError' are updated.

   7. If the received message is a `536' reply, then the SNMP agent
      checks whether a running script with the given `RunId' exists in
      the runtime system.  Processing of the notification stops if there
      is no running script with the `RunId'.  Otherwise, `smRunState'
      and `smRunError' are updated.






<span class="grey">Schoenwaelder &amp; Quittek       Experimental                     [Page 19]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-20"></span>
<span class="grey"><a href="./rfc3179">RFC 3179</a>                    SMX Protocol 1.1                October 2001</span>


   8. If the received message is a `537' reply, then the SNMP agent
      checks whether a running script with the given `RunId' exists in
      the runtime system.  Processing of the notification stops if there
      is no running script with the `RunId'.  Otherwise, `smRunState'
      and `smRunError' are updated and the `smScriptException'
      notification is generated.

   9. If the received message is a `538' reply, then the SNMP agent
      checks whether a running script with the given `RunId' exists in
      the runtime system.  Processing of the notification stops if there
      is no running script with the `RunId'.  Otherwise, `smRunState' is
      set to `terminated' and the `smExitCode' is updated.

<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/7.%20%20Example%20SMX%20Message%20Flow"></a><a class="selflink" href="#section-7" id="section-7">7</a>.  Example SMX Message Flow</span>

   Below is an example SMX message exchange.  Messages sent from the
   SNMP agent are marked with `&gt;' while replies sent from the runtime
   system are marked with `&lt;'.  Line terminators (`CRLF') are not shown
   in order to make the example more readable.

      &gt; hello 1
      &lt; 211 1 SMX/1.1 0AF0BAED6F877FBC
      &gt; start 2 42 "/var/snmp/scripts/foo.jar" untrusted ""
      &gt; start 5 44 "/var/snmp/scripts/bar.jar" trusted "www.ietf.org"
      &lt; 231 2 2
      &gt; start 12 48 "/var/snmp/scripts/foo.jar" funny ""
      &lt; 231 5 2
      &lt; 532 0 44 2 "waiting for response"
      &gt; status 18 42
      &gt; status 19 44
      &lt; 432 12
      &lt; 231 19 2
      &lt; 231 18 2
      &gt; hello 578
      &lt; 211 578 SMX/1.1 0AF0BAED6F877FBC
      &gt; suspend 581 42
      &lt; 231 581 4
      &lt; 532 0 44 7 "test completed"
      &lt; 538 0 44 1
      &gt; abort 611 42
      &lt; 232 611

<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/8.%20%20Transport%20Mappings"></a><a class="selflink" href="#section-8" id="section-8">8</a>.  Transport Mappings</span>

   In order to prevent SMX communication from untrusted peers the SNMP
   agent has to choose a secure SMX transport.  This memo defines two
   transports in <a href="#section-8">Section 8</a>: (a) a bi-directional pipe using standard
   input/output streams on the runtime engine side, and (b) a TCP



<span class="grey">Schoenwaelder &amp; Quittek       Experimental                     [Page 20]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-21"></span>
<span class="grey"><a href="./rfc3179">RFC 3179</a>                    SMX Protocol 1.1                October 2001</span>


   connection where the SNMP agent acts as a listening server that
   accepts only connections from local runtime engines that authenticate
   themselves with a secret shared between the agent and the runtime
   engine.

   For simplicity and security reasons the transport over bi-directional
   pipes is the preferred transport.

   Further transports (e.g., UNIX domain sockets) are possible but not
   defined at this point in time.  The reason for choosing pipes and TCP
   connections as the transport for SMX was that these IPC mechanisms
   are supported by most potential runtime systems, while other
   transports are not universally available.

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/8.1.%20%20SMX%20over%20Bi-directional%20Pipes"></a><a class="selflink" href="#section-8.1" id="section-8.1">8.1</a>.  SMX over Bi-directional Pipes</span>

   The SNMP agent first creates a bi-directional pipe.  Then the agent
   creates the runtime system process with its standard input and
   standard output streams connected to the pipe.  Further
   authentication mechanisms are not required.

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/8.2.%20%20SMX%20over%20TCP"></a><a class="selflink" href="#section-8.2" id="section-8.2">8.2</a>.  SMX over TCP</span>

   The SNMP agent first creates a listening TCP socket which accepts
   connections from runtime systems.  Then the agent creates the runtime
   system process.  It is then the responsibility of the runtime system
   to establish a connection to the agent's TCP socket once it has been
   started.  The SNMP agent must ensure that only authorized runtime
   systems establish a connection to the listening TCP socket.  The
   following rules are used for this purpose:

   -  The TCP connection must originate from the local host.

   -  The SNMP agent must check the `Authenticator' in the `211' reply
      if authentication is required and it must close the TCP connection
      if no valid response is received within a given time interval.

<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/9.%20%20Security%20Considerations"></a><a class="selflink" href="#section-9" id="section-9">9</a>.  Security Considerations</span>

   The SMX protocol as specified in this memo runs over a bi-directional
   pipe or over a local TCP connection between the agent and the runtime
   system.  Protocol messages never leave the local system.  It is
   therefore not possible to attack the message exchanges if the
   underlying operating system protects bi-directional pipes and local
   TCP connections from other users on the same machine.






<span class="grey">Schoenwaelder &amp; Quittek       Experimental                     [Page 21]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-22"></span>
<span class="grey"><a href="./rfc3179">RFC 3179</a>                    SMX Protocol 1.1                October 2001</span>


   The transport over a bi-directional pipe specifies that the pipe is
   created and connected to the standard input/output stream of the
   runtime engine by the agent before the runtime engine is started.  It
   is therefore not possible that an unauthorized process can exchange
   SMX messages over the bi-directional pipe.

   In case of the TCP transport, the only critical situation is the
   connection establishment phase.  The rules defined in <a href="#section-8">section 8</a>
   ensure that only local connections are accepted and that a runtime
   system has to authenticate itself with an authenticator if the agent
   requires authentication.  It is strongly suggested that agents
   require authentication, especially on multiuser systems.

   The SMX 1.0 specification in <a href="./rfc2593">RFC 2593</a> suggested a scheme where the
   authenticator was passed to the runtime engines as part of the
   process environment.  This scheme relies on the protection of process
   environments by the operating system against unauthorized access.
   Some operating systems allow users to read the process environment of
   arbitrary processes.  Hence the scheme proposed in <a href="./rfc2593">RFC 2593</a> is
   considered unsecure on these operating systems.  This memo does not
   dictate the mechanism by which the runtime obtains the shares secret.
   It is the responsibility of implementors or administrators to select
   a mechanism which is secure on the target platforms.

   The SMX protocol assumes a local script storage area which is used to
   pass script code from the SNMP agent to the runtime systems.  The SMX
   protocol passes file names from the agent to the runtime engines.  It
   is necessary that the script files in the local script storage area
   are properly protected so that only the SNMP agent has write access.
   Failure to properly protect write access to the local script storage
   area can allow attackers to execute arbitrary code in runtime systems
   that might have special privileges.

   The SMX protocol allows to execute script under different operating
   system and runtime system security profiles.  The memo suggests to
   map the smLaunchOwner value to an operating system and a runtime
   system security profile.  The operating system security profile is
   enforced by the operating system by setting up a proper process
   environment.  The runtime security profile is enforced by a secure
   runtime system (e.g., the Java virtual machine or a safe Tcl
   interpreter) [<a href="#ref-7" title='"Secure Internet Management by Delegation"'>7</a>].

<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/10.%20%20Changes%20from%20RFC%202593"></a><a class="selflink" href="#section-10" id="section-10">10</a>.  Changes from <a href="./rfc2593">RFC 2593</a></span>

   The following non-editorial changes have been made:

   1. Added the `536' and `537' replies which may be generated
      asynchronously by runtime engines to report error conditions.



<span class="grey">Schoenwaelder &amp; Quittek       Experimental                     [Page 22]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-23"></span>
<span class="grey"><a href="./rfc3179">RFC 3179</a>                    SMX Protocol 1.1                October 2001</span>


   2. Added the `538' reply which can be used to signal the (normal or
      abnormal) termination of a running script.  This new reply
      replaces the `534' and `535' replies, which are now deprecated.

   3. Relaxed the rules for ProfileChars to also include the characters
      ':'  and '_', which are frequently used in namespaces and
      identifiers.

   4. Changed the SMX protocol version number from 1.0 to 1.1.

   5. Added a second (and preferred) transport over a bi-directional
      pipe due to security risks when a shared secret is passed through
      an operating system's environment variable.

   6. Made the `Authenticator' in the `211' reply optional.

<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/11.%20%20Acknowledgments"></a><a class="selflink" href="#section-11" id="section-11">11</a>.  Acknowledgments</span>

   The protocol described in this memo is the result of a joint project
   between the Technical University of Braunschweig and C&amp;C Research
   Laboratories of NEC Europe Ltd. in Heidelberg.  The authors like to
   thank Matthias Bolz, Cornelia Kappler, Andreas Kind, Sven Mertens,
   Jan Nicklisch, and Frank Strauss for their contributions to the
   design and the implementation of the protocol described in this memo.
   The authors also like to thank David Wallis for pointing out a
   security risk in SMX 1.0 with passing a cookie via an operating
   system environment variable.

<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/12.%20%20References"></a><a class="selflink" href="#section-12" id="section-12">12</a>.  References</span>

   [<a id="ref-1">1</a>]  Levi, D. and J. Schoenwaelder, "Definitions of Managed Objects
        for the Delegation of Management Scripts", <a href="./rfc3165">RFC 3165</a>, September
        2001.

   [<a id="ref-2">2</a>]  Lindholm, T., and F. Yellin, "The Java Virtual Machine
        Specification", Addison Wesley, 1997.

   [<a id="ref-3">3</a>]  J.K. Ousterhout, "Tcl and the Tk Toolkit", Addison Wesley, 1994.

   [<a id="ref-4">4</a>]  Fritzinger, J.S., and M. Mueller, "Java Security", White Paper,
        Sun Microsystems, Inc., 1996.

   [<a id="ref-5">5</a>]  Levy, J.Y., Demailly, L., Ousterhout, J.K., and B. Welch, "The
        Safe-Tcl Security Model", Proc. USENIX Annual Technical
        Conference, June 1998.






<span class="grey">Schoenwaelder &amp; Quittek       Experimental                     [Page 23]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-24"></span>
<span class="grey"><a href="./rfc3179">RFC 3179</a>                    SMX Protocol 1.1                October 2001</span>


   [<a id="ref-6">6</a>]  Crocker, D. and P. Overell, "Augmented BNF for Syntax
        Specifications: ABNF", <a href="./rfc2234">RFC 2234</a>, November 1997.

   [<a id="ref-7">7</a>]  Schoenwaelder, J., and J. Quittek, "Secure Internet Management
        by Delegation", Computer Networks 35(1), January 2001.

<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/13.%20%20Authors%27%20Addresses"></a><a class="selflink" href="#section-13" id="section-13">13</a>.  Authors' Addresses</span>

   Juergen Schoenwaelder
   TU Braunschweig
   Bueltenweg 74/75
   38106 Braunschweig
   Germany

   Phone: +49 531 391-3283
   EMail: schoenw@ibr.cs.tu-bs.de


   Juergen Quittek
   NEC Europe Ltd.
   C&amp;C Research Laboratories
   Adenauerplatz 6
   69115 Heidelberg
   Germany

   Phone: +49 6221 90511-15
   EMail: quittek@ccrle.nec.de
























<span class="grey">Schoenwaelder &amp; Quittek       Experimental                     [Page 24]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-25"></span>
<span class="grey"><a href="./rfc3179">RFC 3179</a>                    SMX Protocol 1.1                October 2001</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/14.%20%20Full%20Copyright%20Statement"></a><a class="selflink" href="#section-14" id="section-14">14</a>.  Full Copyright Statement</span>

   Copyright (C) The Internet Society (2001).  All Rights Reserved.

   This document and translations of it may be copied and furnished to
   others, and derivative works that comment on or otherwise explain it
   or assist in its implementation may be prepared, copied, published
   and distributed, in whole or in part, without restriction of any
   kind, provided that the above copyright notice and this paragraph are
   included on all such copies and derivative works.  However, this
   document itself may not be modified in any way, such as by removing
   the copyright notice or references to the Internet Society or other
   Internet organizations, except as needed for the purpose of
   developing Internet standards in which case the procedures for
   copyrights defined in the Internet Standards process must be
   followed, or as required to translate it into languages other than
   English.

   The limited permissions granted above are perpetual and will not be
   revoked by the Internet Society or its successors or assigns.

   This document and the information contained herein is provided on an
   "AS IS" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING
   TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING
   BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION
   HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF
   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.

Acknowledgement

   Funding for the RFC Editor function is currently provided by the
   Internet Society.



















Schoenwaelder &amp; Quittek       Experimental                     [Page 25]
</pre>
</body></html>