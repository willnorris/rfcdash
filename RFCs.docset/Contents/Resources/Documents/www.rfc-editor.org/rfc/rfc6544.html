<html><head></head><body><pre>Internet Engineering Task Force (IETF)                      J. Rosenberg
Request for Comments: 6544                                   jdrosen.net
Category: Standards Track                                     A. Keranen
ISSN: 2070-1721                                                 Ericsson
                                                          B. B. Lowekamp
                                                                   Skype
                                                             A. B. Roach
                                                                 Tekelec
                                                              March 2012


    <span class="h1">TCP Candidates with Interactive Connectivity Establishment (ICE)</span>

Abstract

   Interactive Connectivity Establishment (ICE) defines a mechanism for
   NAT traversal for multimedia communication protocols based on the
   offer/answer model of session negotiation.  ICE works by providing a
   set of candidate transport addresses for each media stream, which are
   then validated with peer-to-peer connectivity checks based on Session
   Traversal Utilities for NAT (STUN).  ICE provides a general framework
   for describing candidates but only defines UDP-based media streams.
   This specification extends ICE to TCP-based media, including the
   ability to offer a mix of TCP and UDP-based candidates for a single
   stream.

Status of This Memo

   This is an Internet Standards Track document.

   This document is a product of the Internet Engineering Task Force
   (IETF).  It represents the consensus of the IETF community.  It has
   received public review and has been approved for publication by the
   Internet Engineering Steering Group (IESG).  Further information on
   Internet Standards is available in <a href="./rfc5741#section-2">Section 2 of RFC 5741</a>.

   Information about the current status of this document, any errata,
   and how to provide feedback on it may be obtained at
   <a href="http://www.rfc-editor.org/info/rfc6544">http://www.rfc-editor.org/info/rfc6544</a>.












<span class="grey">Rosenberg, et al.            Standards Track                    [Page 1]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-2"></span>
<span class="grey"><a href="./rfc6544">RFC 6544</a>                         ICE TCP                      March 2012</span>


Copyright Notice

   Copyright (c) 2012 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to <a href="https://www.rfc-editor.org/bcp/bcp78">BCP 78</a> and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (<a href="http://trustee.ietf.org/license-info">http://trustee.ietf.org/license-info</a>) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.

   This document may contain material from IETF Documents or IETF
   Contributions published or made publicly available before November
   10, 2008.  The person(s) controlling the copyright in some of this
   material may not have granted the IETF Trust the right to allow
   modifications of such material outside the IETF Standards Process.
   Without obtaining an adequate license from the person(s) controlling
   the copyright in such materials, this document may not be modified
   outside the IETF Standards Process, and derivative works of it may
   not be created outside the IETF Standards Process, except to format
   it for publication as an RFC or to translate it into languages other
   than English.

























<span class="grey">Rosenberg, et al.            Standards Track                    [Page 2]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-3"></span>
<span class="grey"><a href="./rfc6544">RFC 6544</a>                         ICE TCP                      March 2012</span>


Table of Contents

   <a href="#section-1">1</a>. Introduction ....................................................<a href="#page-4">4</a>
   <a href="#section-2">2</a>. Terminology .....................................................<a href="#page-5">5</a>
   <a href="#section-3">3</a>. Overview of Operation ...........................................<a href="#page-5">5</a>
   <a href="#section-4">4</a>. Sending the Initial Offer .......................................<a href="#page-7">7</a>
      <a href="#section-4.1">4.1</a>. Gathering Candidates .......................................<a href="#page-7">7</a>
      <a href="#section-4.2">4.2</a>. Prioritization .............................................<a href="#page-8">8</a>
      <a href="#section-4.3">4.3</a>. Choosing Default Candidates ...............................<a href="#page-10">10</a>
      <a href="#section-4.4">4.4</a>. Lite Implementation Requirements ..........................<a href="#page-10">10</a>
      <a href="#section-4.5">4.5</a>. Encoding the SDP ..........................................<a href="#page-11">11</a>
   <a href="#section-5">5</a>. Candidate Collection Techniques ................................<a href="#page-12">12</a>
      <a href="#section-5.1">5.1</a>. Host Candidates ...........................................<a href="#page-12">12</a>
      <a href="#section-5.2">5.2</a>. Server Reflexive Candidates ...............................<a href="#page-13">13</a>
      <a href="#section-5.3">5.3</a>. NAT-Assisted Candidates ...................................<a href="#page-13">13</a>
      <a href="#section-5.4">5.4</a>. UDP-Tunneled Candidates ...................................<a href="#page-14">14</a>
      <a href="#section-5.5">5.5</a>. Relayed Candidates ........................................<a href="#page-15">15</a>
   <a href="#section-6">6</a>. Receiving the Initial Offer and Answer .........................<a href="#page-15">15</a>
      <a href="#section-6.1">6.1</a>. Considerations with Two Lite Agents .......................<a href="#page-16">16</a>
      <a href="#section-6.2">6.2</a>. Forming the Check Lists ...................................<a href="#page-16">16</a>
   <a href="#section-7">7</a>. Connectivity Checks ............................................<a href="#page-17">17</a>
      <a href="#section-7.1">7.1</a>. STUN Client Procedures ....................................<a href="#page-17">17</a>
      <a href="#section-7.2">7.2</a>. STUN Server Procedures ....................................<a href="#page-18">18</a>
   <a href="#section-8">8</a>. Concluding ICE Processing ......................................<a href="#page-18">18</a>
   <a href="#section-9">9</a>. Subsequent Offer/Answer Exchanges ..............................<a href="#page-18">18</a>
      <a href="#section-9.1">9.1</a>. Updated Offer .............................................<a href="#page-18">18</a>
      <a href="#section-9.2">9.2</a>. ICE Restarts ..............................................<a href="#page-19">19</a>
   <a href="#section-10">10</a>. Media Handling ................................................<a href="#page-19">19</a>
      <a href="#section-10.1">10.1</a>. Sending Media ............................................<a href="#page-19">19</a>
      <a href="#section-10.2">10.2</a>. Receiving Media ..........................................<a href="#page-20">20</a>
   <a href="#section-11">11</a>. Connection Management .........................................<a href="#page-20">20</a>
      <a href="#section-11.1">11.1</a>. Connections Formed during Connectivity Checks ............<a href="#page-20">20</a>
      <a href="#section-11.2">11.2</a>. Connections Formed for Gathering Candidates ..............<a href="#page-21">21</a>
   <a href="#section-12">12</a>. Security Considerations .......................................<a href="#page-22">22</a>
   <a href="#section-13">13</a>. IANA Considerations ...........................................<a href="#page-23">23</a>
   <a href="#section-14">14</a>. Acknowledgements ..............................................<a href="#page-23">23</a>
   <a href="#section-15">15</a>. References ....................................................<a href="#page-23">23</a>
      <a href="#section-15.1">15.1</a>. Normative References .....................................<a href="#page-23">23</a>
      <a href="#section-15.2">15.2</a>. Informative References ...................................<a href="#page-24">24</a>
   <a href="#appendix-A">Appendix A</a>.  Limitations of ICE TCP ...............................<a href="#page-26">26</a>
   <a href="#appendix-B">Appendix B</a>.  Implementation Considerations for BSD Sockets ........<a href="#page-27">27</a>
   <a href="#appendix-C">Appendix C</a>.  SDP Examples .........................................<a href="#page-28">28</a>









<span class="grey">Rosenberg, et al.            Standards Track                    [Page 3]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-4"></span>
<span class="grey"><a href="./rfc6544">RFC 6544</a>                         ICE TCP                      March 2012</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/1.%20%20Introduction"></a><a class="selflink" href="#section-1" id="section-1">1</a>.  Introduction</span>

   Interactive Connectivity Establishment (ICE) [<a href="./rfc5245" title='"Interactive Connectivity Establishment (ICE): A Protocol for Network Address Translator (NAT) Traversal for Offer/Answer Protocols"'>RFC5245</a>] defines a
   mechanism for NAT traversal for multimedia communication protocols
   based on the offer/answer model [<a href="./rfc3264" title='"An Offer/Answer Model with Session Description Protocol (SDP)"'>RFC3264</a>] of session negotiation.
   ICE works by providing a set of candidate transport addresses for
   each media stream, which are then validated with peer-to-peer
   connectivity checks based on Session Traversal Utilities for NAT
   (STUN) [<a href="./rfc5389" title='"Session Traversal Utilities for NAT (STUN)"'>RFC5389</a>].  However, ICE only defines procedures for UDP-based
   transport protocols.

   There are many reasons why ICE support for TCP is important.  First,
   there are media protocols that only run over TCP.  Such protocols are
   used, for example, for screen sharing and instant messaging
   [<a href="./rfc4975" title='"The Message Session Relay Protocol (MSRP)"'>RFC4975</a>].  For these protocols to work in the presence of NAT,
   unless they define their own NAT traversal mechanisms, ICE support
   for TCP is needed.  In addition, RTP can also run over TCP [<a href="./rfc4571" title='"Framing Real-time Transport Protocol (RTP) and RTP Control Protocol (RTCP) Packets over Connection- Oriented Transport"'>RFC4571</a>].
   Typically, it is preferable to run RTP over UDP, and not TCP.
   However, in a variety of network environments, overly restrictive NAT
   and firewall devices prevent UDP-based communications altogether, but
   general TCP-based communications are permitted.  In such
   environments, sending RTP over TCP, and thus establishing the media
   session, may be preferable to having it fail altogether.  With this
   specification, agents can gather UDP and TCP candidates for a media
   stream, list the UDP ones with higher priority, and then only use the
   TCP-based ones if the UDP ones fail.  This provides a fallback
   mechanism that allows multimedia communications to be highly
   reliable.

   The usage of RTP over TCP is particularly useful when combined with
   Traversal Using Relays around NAT (TURN) [<a href="./rfc5766" title='"Traversal Using Relays around NAT (TURN): Relay Extensions to Session Traversal Utilities for NAT (STUN)"'>RFC5766</a>].  In this case,
   one of the agents would connect to its TURN server using TCP and
   obtain a TCP-based relayed candidate.  It would offer this to its
   peer agent as a candidate.  The other agent would initiate a TCP
   connection towards the TURN server.  When that connection is
   established, media can flow over the connections, through the TURN
   server.  The benefit of this usage is that it only requires the
   agents to make outbound TCP connections to a server on the public
   network.  This kind of operation is broadly interoperable through NAT
   and firewall devices.  Since it is a goal of ICE and this extension
   to provide highly reliable communications that "just work" in as
   broad a set of network deployments as possible, this use case is
   particularly important.

   This specification extends ICE by defining its usage with TCP
   candidates.  It also defines how ICE can be used with RTP and Secure
   RTP (SRTP) to provide both TCP and UDP candidates.  This
   specification does so by following the outline of ICE itself and



<span class="grey">Rosenberg, et al.            Standards Track                    [Page 4]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-5"></span>
<span class="grey"><a href="./rfc6544">RFC 6544</a>                         ICE TCP                      March 2012</span>


   calling out the additions and changes to support TCP candidates in
   ICE.  The base behavior of ICE [<a href="./rfc5245" title='"Interactive Connectivity Establishment (ICE): A Protocol for Network Address Translator (NAT) Traversal for Offer/Answer Protocols"'>RFC5245</a>] remains unchanged except for
   the extensions in this document that define the usage of ICE with TCP
   candidates.

   It should be noted that since TCP NAT traversal is more complicated
   than with UDP, ICE TCP is not generally as efficient as UDP-based
   ICE.  Discussion about this topic can be found in <a href="#appendix-A">Appendix A</a>.

<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/2.%20%20Terminology"></a><a class="selflink" href="#section-2" id="section-2">2</a>.  Terminology</span>

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
   "OPTIONAL" in this document are to be interpreted as described in <a href="./rfc2119">RFC</a>
   <a href="./rfc2119">2119</a> [<a href="./rfc2119" title='"Key words for use in RFCs to Indicate Requirement Levels"'>RFC2119</a>].

   This document uses the same terminology as ICE (see <a href="./rfc5245#section-3">Section 3 of
   [RFC5245]</a>).

<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/3.%20%20Overview%20of%20Operation"></a><a class="selflink" href="#section-3" id="section-3">3</a>.  Overview of Operation</span>

   The usage of ICE with TCP is relatively straightforward.  This
   specification mainly deals with how and when connections are opened
   and how those connections relate to candidate pairs.

   When agents perform address allocations to gather TCP-based
   candidates, three types of candidates can be obtained: active
   candidates, passive candidates, and simultaneous-open (S-O)
   candidates.  An active candidate is one for which the agent will
   attempt to open an outbound connection but will not receive incoming
   connection requests.  A passive candidate is one for which the agent
   will receive incoming connection attempts but not attempt a
   connection.  An S-O candidate is one for which the agent will attempt
   to open a connection simultaneously with its peer.

   When gathering candidates from a host interface, the agent typically
   obtains active, passive, and S-O candidates.  Similarly, one can use
   different techniques for obtaining, e.g., server reflexive, NAT-
   assisted, tunneled, or relayed candidates of these three types (see
   <a href="#section-5">Section 5</a>).  Connections to servers used for relayed and server
   reflexive candidates are kept open during ICE processing.

   When encoding these candidates into offers and answers, the type of
   the candidate is signaled.  In the case of active candidates, both IP
   address and port are present, but the port is meaningless (it is
   there only for making encoding of active candidates consistent with
   the other candidate types and is ignored by the peer).  As a
   consequence, active candidates do not need to be physically allocated



<span class="grey">Rosenberg, et al.            Standards Track                    [Page 5]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-6"></span>
<span class="grey"><a href="./rfc6544">RFC 6544</a>                         ICE TCP                      March 2012</span>


   at the time of address gathering.  Rather, the physical allocations,
   which occur as a consequence of a connection attempt, occur at the
   time of the connectivity checks.

   When the candidates are paired together, active candidates are always
   paired with passive, and S-O candidates with each other.  When a
   connectivity check is to be made on a candidate pair, each agent
   determines whether it is to make a connection attempt for this pair.

   The actual process of generating connectivity checks, managing the
   state of the check list, and updating the Valid list works
   identically for TCP as it does for UDP.

   ICE requires an agent to demultiplex STUN and application-layer
   traffic, since they appear on the same port.  This demultiplexing is
   described in [<a href="./rfc5245" title='"Interactive Connectivity Establishment (ICE): A Protocol for Network Address Translator (NAT) Traversal for Offer/Answer Protocols"'>RFC5245</a>] and is done using the magic cookie and other
   fields of the message.  Stream-oriented transports introduce another
   wrinkle, since they require a way to frame the connection so that the
   application and STUN packets can be extracted in order to
   differentiate STUN packets from application-layer traffic.  For this
   reason, TCP media streams utilizing ICE use the basic framing
   provided in <a href="./rfc4571">RFC 4571</a> [<a href="./rfc4571" title='"Framing Real-time Transport Protocol (RTP) and RTP Control Protocol (RTCP) Packets over Connection- Oriented Transport"'>RFC4571</a>], even if the application layer
   protocol is not RTP.

   When Transport Layer Security (TLS) or Datagram Transport Layer
   Security (DTLS) is used, they are also run over the <a href="./rfc4571">RFC 4571</a> framing
   shim, while STUN runs outside of the (D)TLS connection.  The
   resulting ICE TCP protocol stack is shown in Figure 1, with (D)TLS on
   the left side and without it on the right side.

                       +----------+
                       |          |
                       |    App   |
            +----------+----------+     +----------+----------+
            |          |          |     |          |          |
            |   STUN   |  (D)TLS  |     |   STUN   |    App   |
            +----------+----------+     +----------+----------+
            |                     |     |                     |
            |      <a href="./rfc4571">RFC 4571</a>       |     |      <a href="./rfc4571">RFC 4571</a>       |
            +---------------------+     +---------------------+
            |                     |     |                     |
            |         TCP         |     |         TCP         |
            +---------------------+     +---------------------+
            |                     |     |                     |
            |         IP          |     |         IP          |
            +---------------------+     +---------------------+

              Figure 1: ICE TCP Stack with and without (D)TLS



<span class="grey">Rosenberg, et al.            Standards Track                    [Page 6]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-7"></span>
<span class="grey"><a href="./rfc6544">RFC 6544</a>                         ICE TCP                      March 2012</span>


   The implication of this is that, for any media stream protected by
   (D)TLS, the agent will first run ICE procedures, exchanging STUN
   messages.  Then, once ICE completes, (D)TLS procedures begin.  ICE
   and (D)TLS are thus "peers" in the protocol stack.  The STUN messages
   are not sent over the (D)TLS connection, even ones sent for the
   purposes of keepalive in the middle of the media session.

<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/4.%20%20Sending%20the%20Initial%20Offer"></a><a class="selflink" href="#section-4" id="section-4">4</a>.  Sending the Initial Offer</span>

   For offerers making use of ICE for TCP streams, the procedures below
   are used.  The main differences compared to UDP candidates are the
   new methods for gathering candidates, how TCP candidates are
   prioritized, and how they are encoded in the Session Description
   Protocol (SDP) offer and answer.

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/4.1.%20%20Gathering%20Candidates"></a><a class="selflink" href="#section-4.1" id="section-4.1">4.1</a>.  Gathering Candidates</span>

   Providers of real-time communications services may decide that it is
   preferable to have no media at all rather than to have media over
   TCP.  To allow for choice, it is RECOMMENDED that it be possible to
   configure agents to either obtain or not obtain TCP candidates for
   real-time media.

   Having it be configurable, and then configuring it to be off, is far
   better than not having the capability at all.  An important goal of
   this specification is to provide a single mechanism that can be used
   across all types of endpoints.  As such, it is preferable to account
   for provider and network variation through configuration instead of
   hard-coded limitations in an implementation.  Besides, network
   characteristics and connectivity assumptions can, and will, change
   over time.  Just because an agent is communicating with a server on
   the public network today doesn't mean that it won't need to
   communicate with one behind a NAT tomorrow.  Just because an agent is
   behind a NAT with endpoint-independent mapping today doesn't mean
   that tomorrow it won't pick up its agent and take it to a public
   network access point where there is a NAT with address- and port-
   dependent mapping properties or one that only allows outbound TCP.
   The way to handle these cases and build a reliable system is for
   agents to implement a diverse set of techniques for allocating
   addresses, so that at least one of them is almost certainly going to
   work in any situation.  Implementors should consider very carefully
   any assumptions made about deployments before electing not to
   implement one of the mechanisms for address allocation.  In
   particular, implementors should consider whether the elements in the
   system may be mobile and connect through different networks with
   different connectivity.  They should also consider whether endpoints
   that are under their control, in terms of location and network
   connectivity, would always be under their control.  In environments



<span class="grey">Rosenberg, et al.            Standards Track                    [Page 7]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-8"></span>
<span class="grey"><a href="./rfc6544">RFC 6544</a>                         ICE TCP                      March 2012</span>


   where mobility and user control are possible, a multiplicity of
   techniques is essential for reliability.

   First, agents SHOULD obtain host candidates as described in
   <a href="#section-5.1">Section 5.1</a>.  Then, each agent SHOULD "obtain" (allocate a
   placeholder for) an active host candidate for each component of each
   TCP-capable media stream on each interface that the host has.  The
   agent does not yet have to actually allocate a port for these
   candidates, but they are used for the creation of the check lists.

   The agent SHOULD then obtain server reflexive, NAT-assisted, and/or
   UDP-tunneled candidates (see <a href="#section-5.2">Section 5.2</a>, <a href="#section-5.3">Section 5.3</a>, and
   <a href="#section-5.4">Section 5.4</a>).  The mechanisms for establishing these candidates and
   the number of candidates to collect vary from technique to technique.
   These considerations are discussed in the relevant sections.

   Next, agents SHOULD obtain passive (and possibly S-O) relayed
   candidates for each component as described in <a href="#section-5.5">Section 5.5</a>.  Each
   agent SHOULD also allocate a placeholder for an active relayed
   candidate for each component of each TCP-capable media stream.

   It is highly RECOMMENDED that a host obtains at least one set of host
   candidates and one set of relayed candidates.  Obtaining additional
   candidates will increase the chance of successfully creating a direct
   connection.

   Once the candidates have been obtained, the agent MUST keep the TCP
   connections open until ICE processing has completed.  See <a href="#appendix-B">Appendix B</a>
   for important implementation guidelines.

   If a media stream is UDP-based (such as RTP), an agent MAY use an
   additional host TCP candidate to request a UDP-based candidate from a
   TURN server (or some other relay with similar functionality).  Usage
   of such UDP candidates follows the procedures defined in ICE for UDP
   candidates.

   Like its UDP counterparts, TCP-based STUN transactions are paced out
   at one every Ta milliseconds (see <a href="./rfc5245#section-16">Section 16 of [RFC5245]</a>).  This
   pacing refers strictly to STUN transactions (both Binding and
   Allocate requests).  If performance of the transaction requires
   establishment of a TCP connection, then the connection gets opened
   when the transaction is performed.

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/4.2.%20%20Prioritization"></a><a class="selflink" href="#section-4.2" id="section-4.2">4.2</a>.  Prioritization</span>

   The transport protocol itself is a criteria for choosing one
   candidate over another.  If a particular media stream can run over
   UDP or TCP, the UDP candidates might be preferred over the TCP



<span class="grey">Rosenberg, et al.            Standards Track                    [Page 8]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-9"></span>
<span class="grey"><a href="./rfc6544">RFC 6544</a>                         ICE TCP                      March 2012</span>


   candidates.  This allows ICE to use the lower latency UDP
   connectivity if it exists but fallback to TCP if UDP doesn't work.

   In <a href="./rfc5245#section-4.1.2.1">Section 4.1.2.1 of [RFC5245]</a>, a recommended formula for UDP ICE
   candidate prioritization is defined.  For TCP candidates, the same
   formula and candidate type preferences SHOULD be used, and the
   RECOMMENDED type preferences for the new candidate types defined in
   this document (see <a href="#section-5">Section 5</a>) are 105 for NAT-assisted candidates and
   75 for UDP-tunneled candidates.

   When both UDP and TCP candidates are offered for the same media
   stream, and one transport protocol should be preferred over the
   other, the type preferences for the preferred transport protocol
   candidates SHOULD be increased and/or the type preferences for the
   other transport protocol candidates SHOULD be decreased.  How much
   the values should be increased or decreased depends on whether it is
   more important to choose a certain transport protocol or a certain
   candidate type.  If the candidate type is more important (e.g., even
   if UDP is preferred, TCP host candidates are preferred over UDP
   server reflexive candidates) changing type preference values by one
   for the other transport protocol candidates is enough.  On the other
   hand, if the transport protocol is more important (e.g., any UDP
   candidate is preferred over any TCP candidate), all the preferred
   transport protocol candidates SHOULD have type preference higher than
   the other transport protocol candidates.  However, it is RECOMMENDED
   that the relayed candidates are still preferred lower than the other
   candidate types.  For RTP-based media streams, it is RECOMMENDED that
   UDP candidates are preferred over TCP candidates.

   With TCP candidates, the local preference part of the recommended
   priority formula is updated to also include the directionality
   (active, passive, or simultaneous-open) of the TCP connection.  The
   RECOMMENDED local preference is then defined as:

      local preference = (2^13) * direction-pref + other-pref

   The direction-pref MUST be between 0 and 7 (both inclusive), with 7
   being the most preferred.  The other-pref MUST be between 0 and 8191
   (both inclusive), with 8191 being the most preferred.  It is
   RECOMMENDED that the host, UDP-tunneled, and relayed TCP candidates
   have the direction-pref assigned as follows: 6 for active, 4 for
   passive, and 2 for S-O.  For the NAT-assisted and server reflexive
   candidates, the RECOMMENDED values are: 6 for S-O, 4 for active, and
   2 for passive.

   The preference priorities listed here are simply recommendations that
   try to strike a balance between success probability and the resulting
   path's efficiency.  Depending on the scenario where ICE TCP is used,



<span class="grey">Rosenberg, et al.            Standards Track                    [Page 9]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-10"></span>
<span class="grey"><a href="./rfc6544">RFC 6544</a>                         ICE TCP                      March 2012</span>


   different values may be appropriate.  For example, if the overhead of
   a UDP tunnel is not an issue, those candidates should be prioritized
   higher since they are likely to have a high success probability.
   Also, simultaneous-open is prioritized higher than active and passive
   candidates for NAT-assisted and server reflexive candidates since if
   TCP S-O is supported by the operating systems of both endpoints, it
   should work at least as well as the active-passive approach.  If an
   implementation is uncertain whether S-O candidates are supported, it
   may be reasonable to prioritize them lower.  For host, UDP-tunneled,
   and relayed candidates, the S-O candidates are prioritized lower than
   active and passive since active-passive candidates should work with
   them at least as well as the S-O candidates.

   If any two candidates have the same type-preference and direction-
   pref, they MUST have a unique other-pref.  With this specification,
   this usually only happens with multi-homed hosts, in which case
   other-pref is the preference for the particular IP address from which
   the candidate was obtained.  When there is only a single IP address,
   this value SHOULD be set to the maximum allowed value (8191).

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/4.3.%20%20Choosing%20Default%20Candidates"></a><a class="selflink" href="#section-4.3" id="section-4.3">4.3</a>.  Choosing Default Candidates</span>

   The default candidate is chosen primarily based on the likelihood of
   it working with a non-ICE peer.  When media streams supporting mixed
   modes (both TCP and UDP) are used with ICE, it is RECOMMENDED that,
   for real-time streams (such as RTP), the default candidates be UDP-
   based.  However, the default SHOULD NOT be a simultaneous-open
   candidate.

   If a media stream is inherently TCP-based, it is RECOMMENDED for an
   offering full agent to select an active candidate as the default
   candidate and use [<a href="./rfc4145" title='"TCP-Based Media Transport in the Session Description Protocol (SDP)"'>RFC4145</a>] "setup" attribute value "active".  This
   increases the chances for a successful NAT traversal even without ICE
   support if the agent is behind a NAT and the peer is not.  For the
   same reason, for a lite agent, it is RECOMMENDED to use a passive
   candidate and "setup" attribute value "passive" in the offer.

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/4.4.%20%20Lite%20Implementation%20Requirements"></a><a class="selflink" href="#section-4.4" id="section-4.4">4.4</a>.  Lite Implementation Requirements</span>

   If an offerer meets the criteria for the lite mode as described in
   <a href="./rfc5245#appendix-A">Appendix A of [RFC5245]</a> (i.e., it will always have a public, globally
   unique IP address), it MAY use the lite mode of ICE for TCP
   candidates.  In the lite mode, for TCP candidates, only passive host
   candidates are gathered, unless active candidates are needed as the
   default candidates.  Otherwise, the procedures described for lite
   mode in [<a href="./rfc5245" title='"Interactive Connectivity Establishment (ICE): A Protocol for Network Address Translator (NAT) Traversal for Offer/Answer Protocols"'>RFC5245</a>] also apply to TCP candidates.  If UDP and TCP
   candidates are mixed in a media stream, the mode (lite or full)
   applies to both UDP and TCP candidates.



<span class="grey">Rosenberg, et al.            Standards Track                   [Page 10]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-11"></span>
<span class="grey"><a href="./rfc6544">RFC 6544</a>                         ICE TCP                      March 2012</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/4.5.%20%20Encoding%20the%20SDP"></a><a class="selflink" href="#section-4.5" id="section-4.5">4.5</a>.  Encoding the SDP</span>

   TCP-based candidates are encoded into a=candidate lines like the UDP
   candidates described in [<a href="./rfc5245" title='"Interactive Connectivity Establishment (ICE): A Protocol for Network Address Translator (NAT) Traversal for Offer/Answer Protocols"'>RFC5245</a>].  However, the transport protocol
   (i.e., value of the transport-extension token defined in <a href="./rfc5245#section-15.1">[RFC5245],
   Section 15.1</a>) is set to "TCP" and the connection type (active,
   passive, or S-O) is encoded using a new extension attribute.  With
   TCP candidates, the candidate-attribute syntax with Augmented BNF
   [<a href="./rfc5234" title='"Augmented BNF for Syntax Specifications: ABNF"'>RFC5234</a>] is then:

   candidate-attribute   = "candidate" ":" foundation SP component-id SP
                           "TCP" SP
                           priority SP
                           connection-address SP
                           port SP
                           cand-type
                           [SP rel-addr]
                           [SP rel-port]
                           SP tcp-type-ext
                           *(SP extension-att-name SP
                                extension-att-value)

   tcp-type-ext          = "tcptype" SP tcp-type
   tcp-type              = "active" / "passive" / "so"

   The connection-address encoded into the candidate-attribute for
   active candidates MUST be set to the IP address that will be used for
   the attempt, but the port(s) MUST be set to 9 (i.e., Discard).  For
   active relayed candidates, the value for connection-address MUST be
   identical to the IP address of a passive or simultaneous-open
   candidate from the same relay server.

   If the default candidate is TCP-based, the agent MUST include the
   a=setup and a=connection attributes from <a href="./rfc4145">RFC 4145</a> [<a href="./rfc4145" title='"TCP-Based Media Transport in the Session Description Protocol (SDP)"'>RFC4145</a>],
   following the procedures defined there as if ICE were not in use.  In
   particular, if an agent is the answerer, the a=setup attribute MUST
   meet the constraints in <a href="./rfc4145">RFC 4145</a> based on the value in the offer.

   If an agent is utilizing SRTP [<a href="./rfc3711" title='"The Secure Real-time Transport Protocol (SRTP)"'>RFC3711</a>], it MAY include a mix of UDP
   and TCP candidates.  If ICE selects a TCP candidate pair, it is
   RECOMMENDED that the agent still utilizes SRTP but runs it over the
   connection established by ICE.  The alternative, RTP over TLS, breaks
   RTP header compression and on-path RTP analysis tools and hence
   SHOULD be avoided.  In the case of DTLS-SRTP [<a href="./rfc5764" title='"Datagram Transport Layer Security (DTLS) Extension to Establish Keys for the Secure Real-time Transport Protocol (SRTP)"'>RFC5764</a>], the
   directionality attributes (a=setup) are utilized strictly to
   determine the direction of the DTLS handshake.  Directionality of the
   TCP connection establishment is determined by the ICE attributes and
   procedures defined here.



<span class="grey">Rosenberg, et al.            Standards Track                   [Page 11]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-12"></span>
<span class="grey"><a href="./rfc6544">RFC 6544</a>                         ICE TCP                      March 2012</span>


   If an agent is securing non-RTP media over TCP/TLS, the SDP MUST be
   constructed as described in <a href="./rfc4572">RFC 4572</a> [<a href="./rfc4572" title='"Connection-Oriented Media Transport over the Transport Layer Security (TLS) Protocol in the Session Description Protocol (SDP)"'>RFC4572</a>].  The directionality
   attributes (a=setup) are utilized strictly to determine the direction
   of the TLS handshake.  Directionality of the TCP connection
   establishment is determined by the ICE attributes and procedures
   defined here.

   Examples of SDP offers and answers with ICE TCP extensions are shown
   in <a href="#appendix-C">Appendix C</a>.

<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/5.%20%20Candidate%20Collection%20Techniques"></a><a class="selflink" href="#section-5" id="section-5">5</a>.  Candidate Collection Techniques</span>

   The following sections discuss a number of techniques that can be
   used to obtain candidates for use with ICE TCP.  It is important to
   note that this list is not intended to be exhaustive, nor is
   implementation of any specific technique beyond host candidates
   (<a href="#section-5.1">Section 5.1</a>) considered mandatory.

   Implementors are encouraged to implement as many of the following
   techniques from the following list as is practical, as well as to
   explore additional NAT-traversal techniques beyond those discussed in
   this document.  However, to get a reasonable success ratio, one
   SHOULD implement at least one relayed technique (e.g., TURN) and one
   technique for discovering the address given for the host by a NAT
   (e.g., STUN).

   To increase the success probability with the techniques described
   below and to aid with transition to IPv6, implementors SHOULD take
   particular care to include both IPv4 and IPv6 candidates as part of
   the process of gathering candidates.  If the local network or host
   does not support IPv6 addressing, then clients SHOULD make use of
   other techniques, e.g., TURN-IPv6 [<a href="./rfc6156" title='"Traversal Using Relays around NAT (TURN) Extension for IPv6"'>RFC6156</a>], Teredo [<a href="./rfc4380" title='"Teredo: Tunneling IPv6 over UDP through Network Address Translations (NATs)"'>RFC4380</a>], or
   SOCKS IPv4-IPv6 gatewaying [<a href="./rfc3089" title='"A SOCKS-based IPv6/IPv4 Gateway Mechanism"'>RFC3089</a>], for obtaining IPv6 candidates.

   While implementations SHOULD support as many techniques as feasible,
   they SHOULD also consider which of them to use if multiple options
   are available.  Since different candidates are paired with each
   other, offering a large number of candidates results in a large check
   list and potentially long-lasting connectivity checks.  For example,
   using multiple NAT-assisted techniques with the same NAT usually
   results only in redundant candidates.  Similarly, using just one of
   the multiple UDP tunneling or relaying techniques is often enough.

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/5.1.%20%20Host%20Candidates"></a><a class="selflink" href="#section-5.1" id="section-5.1">5.1</a>.  Host Candidates</span>

   Host candidates are the most simple candidates since they only
   require opening TCP sockets on the host's interfaces and sending/
   receiving connectivity checks from them.  However, if the hosts are



<span class="grey">Rosenberg, et al.            Standards Track                   [Page 12]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-13"></span>
<span class="grey"><a href="./rfc6544">RFC 6544</a>                         ICE TCP                      March 2012</span>


   behind different NATs, host candidates usually fail to work.  On the
   other hand, if there are no NATs between the hosts, host candidates
   are the most efficient method since they require no additional NAT
   traversal protocols or techniques.

   For each TCP-capable media stream the agent wishes to use (including
   ones like RTP that can be either UDP or TCP), the agent SHOULD obtain
   two host candidates (each on a different port) for each component of
   the media stream on each interface that the host has -- one for the
   simultaneous-open and one for the passive candidate.  If an agent is
   not capable of acting in one of these modes, it would omit those
   candidates.

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/5.2.%20%20Server%20Reflexive%20Candidates"></a><a class="selflink" href="#section-5.2" id="section-5.2">5.2</a>.  Server Reflexive Candidates</span>

   Server reflexive techniques aim to discover the address a NAT has
   given for the host by asking that from a server on the other side of
   the NAT and then creating proper bindings (unless such already exist)
   on the NATs with connectivity checks sent between the hosts.  Success
   of these techniques depends on the NATs' mapping and filtering
   behavior [<a href="./rfc5382" title='"NAT Behavioral Requirements for TCP"'>RFC5382</a>] and also on whether the NATs and hosts support the
   TCP simultaneous-open technique.

   Obtaining server reflexive passive candidates may require initiating
   connections from host's passive candidates; see <a href="#appendix-B">Appendix B</a> for
   implementation details on this.  Server reflexive active candidates
   can be derived from passive or S-O candidates by using the same IP
   addresses and interfaces as those candidates.  It is useful to obtain
   both server reflexive passive and S-O candidates since which one
   actually works better depends on the hosts and NATs.  Furthermore,
   some techniques (e.g., TURN relaying) require knowing the IP address
   of the peer's active candidates beforehand, so active server
   reflexive candidates are needed for such techniques to function
   properly.

   A widely used protocol for obtaining server reflexive candidates is
   STUN.  Its TCP-specific behavior is described in [<a href="./rfc5389" title='"Session Traversal Utilities for NAT (STUN)"'>RFC5389</a>], <a href="#section-7.2.2">Section</a>
   <a href="#section-7.2.2">7.2.2</a>.

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/5.3.%20%20NAT-Assisted%20Candidates"></a><a class="selflink" href="#section-5.3" id="section-5.3">5.3</a>.  NAT-Assisted Candidates</span>

   NAT-assisted techniques communicate with the NATs directly and, in
   this way, discover the address that the NAT has given to the host.
   NAT-assisted techniques also create proper bindings on the NATs.  The
   benefit of these techniques over the server reflexive techniques is
   that the NATs can adjust their mapping and filtering behavior so that
   connections can be successfully created.  A downside of NAT-assisted
   techniques is that they commonly allow communicating only with a NAT



<span class="grey">Rosenberg, et al.            Standards Track                   [Page 13]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-14"></span>
<span class="grey"><a href="./rfc6544">RFC 6544</a>                         ICE TCP                      March 2012</span>


   that is in the same subnet as the host and thus often fail in
   scenarios with multiple layers of NATs.  These techniques also rely
   on NATs supporting the specific protocols and allowing the users to
   modify their behavior.

   These candidates are encoded in the ICE offer and answer like the
   server reflexive candidates, but they (commonly) use a higher
   priority (as described in <a href="#section-4.2">Section 4.2</a>) and hence are tested before
   the server reflexive candidates.

   Currently, the Universal Plug and Play (UPnP) forum's Internet
   Gateway Device (IGD) protocol [<a href="#ref-UPnP-IGD" title='"Internet Gateway Device (IGD) Standardized Device Control Protocol V 1.0"'>UPnP-IGD</a>] and the NAT Port Mapping
   Protocol (PMP) [<a href="#ref-NAT-PMP" title='"NAT Port Mapping Protocol (NAT-PMP)"'>NAT-PMP</a>] are widely supported NAT-assisted
   techniques.  Other known protocols include Port Control Protocol
   (PCP) [<a href="#ref-PCP-BASE" title='"Port Control Protocol (PCP)"'>PCP-BASE</a>], SOCKS [<a href="./rfc1928" title='"SOCKS Protocol Version 5"'>RFC1928</a>], Realm Specific IP (RSIP)
   [<a href="./rfc3103" title='"Realm Specific IP: Protocol Specification"'>RFC3103</a>], and Simple Middlebox Configuration (SIMCO) [<a href="./rfc4540" title="&quot;NEC's Simple Middlebox Configuration (SIMCO) Protocol Version 3.0&quot;">RFC4540</a>].
   Also, the Middlebox Communications (MIDCOM) MIB [<a href="./rfc5190" title='"Definitions of Managed Objects for Middlebox Communication"'>RFC5190</a>] defines a
   mechanism based on the Simple Network Management Protocol (SNMP) for
   controlling NATs.

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/5.4.%20%20UDP-Tunneled%20Candidates"></a><a class="selflink" href="#section-5.4" id="section-5.4">5.4</a>.  UDP-Tunneled Candidates</span>

   UDP-tunneled NAT traversal techniques utilize the fact that UDP NAT
   traversal is simpler and more efficient than TCP NAT traversal.  With
   these techniques, the TCP packets (or possibly complete IP packets)
   are encapsulated in UDP packets.  Because of the encapsulation, these
   techniques increase the overhead for the connection and may require
   support from both of the endpoints, but on the other hand, UDP
   tunneling commonly results in reliable and fairly simple TCP NAT
   traversal.

   UDP-tunneled candidates can be encoded in the ICE offer and answer
   either as relayed or server reflexive candidates, depending on
   whether the tunneling protocol utilizes a relay between the hosts.
   The UDP-tunneled candidates may appear to applications as host
   candidates from a local pseudo-interface.  Treating these candidates
   as host candidates results in incorrect prioritization and possibly
   non-optimal candidate selection.  Implementations may attempt to
   detect pseudo-interfaces, e.g., from the address prefix of the
   interface, but detection details vary from technique to technique.

   For example, the Teredo protocol [<a href="./rfc4380" title='"Teredo: Tunneling IPv6 over UDP through Network Address Translations (NATs)"'>RFC4380</a>] [<a href="./rfc6081" title='"Teredo Extensions"'>RFC6081</a>] provides
   automatic UDP tunneling and IPv6 interworking.  The Teredo UDP tunnel
   is visible to the host application as an IPv6 address; thus, Teredo
   candidates are encoded as IPv6 addresses.






<span class="grey">Rosenberg, et al.            Standards Track                   [Page 14]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-15"></span>
<span class="grey"><a href="./rfc6544">RFC 6544</a>                         ICE TCP                      March 2012</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/5.5.%20%20Relayed%20Candidates"></a><a class="selflink" href="#section-5.5" id="section-5.5">5.5</a>.  Relayed Candidates</span>

   Relaying packets through a relay server is often the NAT traversal
   technique that has the highest success probability: communicating via
   a relay that is in the public Internet looks like normal client-
   server communication for the NATs and is supported in practice by all
   existing NATs, regardless of their filtering and mapping behavior.
   However, using a relay has several drawbacks, e.g., it usually
   results in a sub-optimal path for the packets, the relay needs to
   exist and it needs to be discovered, the relay is a possible single
   point of failure, relaying consumes potentially a lot of resources of
   the relay server, etc.  Therefore, relaying is often used as the last
   resort when no direct path can be created with other NAT traversal
   techniques.

   With relayed candidates, the host commonly needs to obtain only a
   passive candidate since any of the peer's server reflexive (and NAT-
   assisted if the peer can communicate with the outermost NAT) active
   candidates should work with the passive relayed candidate.  However,
   if the relay is behind a NAT or a firewall, also using active and S-O
   candidates will increase success probability.

   Relaying protocols capable of relaying TCP connections include TURN
   TCP [<a href="./rfc6062" title='"Traversal Using Relays around NAT (TURN) Extensions for TCP Allocations"'>RFC6062</a>] and SOCKS [<a href="./rfc1928" title='"SOCKS Protocol Version 5"'>RFC1928</a>] (which can also be used for IPv4-
   IPv6 gatewaying [<a href="./rfc3089" title='"A SOCKS-based IPv6/IPv4 Gateway Mechanism"'>RFC3089</a>]).  It is also possible to use a Secure
   SHell (SSH) [<a href="./rfc4251" title='"The Secure Shell (SSH) Protocol Architecture"'>RFC4251</a>] tunnel as a relayed candidate if a suitable
   server is available and the server permits this.

<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/6.%20%20Receiving%20the%20Initial%20Offer%20and%20Answer"></a><a class="selflink" href="#section-6" id="section-6">6</a>.  Receiving the Initial Offer and Answer</span>

   Handling an ICE offer with TCP candidates works in a similar way as
   with UDP candidates.  First, ICE support is verified (including the
   check for ice-mismatch described in <a href="./rfc5245#section-5.1">Section 5.1 of [RFC5245]</a>) and
   agent roles are determined.  Candidates are gathered using the
   techniques described in <a href="#section-5">Section 5</a> and prioritized as described in
   <a href="#section-4.2">Section 4.2</a>.  Default candidates are selected taking into account the
   considerations in <a href="#section-4.3">Section 4.3</a>.  The SDP answer is encoded as in
   <a href="./rfc5245#section-4.3">Section 4.3 of [RFC5245]</a>, with the exception of TCP candidates whose
   encoding is described in <a href="#section-4.5">Section 4.5</a>.

   When the offerer receives the initial answer, it also verifies ICE
   support and determines its role.  If both of the agents use lite
   implementations, the offerer takes the controlling role and uses the
   procedures defined in [<a href="./rfc4145" title='"TCP-Based Media Transport in the Session Description Protocol (SDP)"'>RFC4145</a>] to select the most preferred
   candidate pair with a new offer.






<span class="grey">Rosenberg, et al.            Standards Track                   [Page 15]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-16"></span>
<span class="grey"><a href="./rfc6544">RFC 6544</a>                         ICE TCP                      March 2012</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/6.1.%20%20Considerations%20with%20Two%20Lite%20Agents"></a><a class="selflink" href="#section-6.1" id="section-6.1">6.1</a>.  Considerations with Two Lite Agents</span>

   If both agents are using the lite mode and if the offerer uses the
   a=setup:active attribute [<a href="./rfc4145" title='"TCP-Based Media Transport in the Session Description Protocol (SDP)"'>RFC4145</a>] in the new offer, the offerer MAY
   initiate the TCP connection on the selected pair in parallel with the
   new offer to speed up the connection establishment.  Consequently,
   the answerer MUST still accept incoming TCP connections to any of the
   passive candidates it listed in the answer, from any of the IP
   addresses the offerer listed in the initial offer.

   If the answerer receives the new offer matching the candidate pair
   where a connection was already created in parallel with the new
   offer, it MUST accept the offer and respond to it while keeping the
   already-created connection.  If the connection that was created in
   parallel with the new offer does not match the candidate pair in the
   new offer, the connection MUST be closed, and ICE restart SHOULD be
   performed.

   Since the connection endpoints are not authenticated using the
   connectivity checks in the scenario where both agents use the lite
   mode, unless media-level security (e.g., TLS) is used, it is
   RECOMMENDED to use the full mode instead.  For more lite versus full
   implementation considerations, see <a href="./rfc5245#appendix-A">Appendix A of [RFC5245]</a>.

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/6.2.%20%20Forming%20the%20Check%20Lists"></a><a class="selflink" href="#section-6.2" id="section-6.2">6.2</a>.  Forming the Check Lists</span>

   As with UDP, check lists are formed only by full ICE implementations.
   When forming candidate pairs, the following types of TCP candidates
   can be paired with each other:

   Local           Remote
   Candidate       Candidate
   ---------------------------
   tcp-so          tcp-so
   tcp-active      tcp-passive
   tcp-passive     tcp-active

   When the agent prunes the check list, it MUST also remove any pair
   for which the local candidate is a passive TCP candidate.  With
   pruning, the NAT-assisted candidates are treated like server
   reflexive candidates if the base is also used as a host candidate.

   The remainder of check list processing works in the same way as the
   UDP case.







<span class="grey">Rosenberg, et al.            Standards Track                   [Page 16]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-17"></span>
<span class="grey"><a href="./rfc6544">RFC 6544</a>                         ICE TCP                      March 2012</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/7.%20%20Connectivity%20Checks"></a><a class="selflink" href="#section-7" id="section-7">7</a>.  Connectivity Checks</span>

   The TCP connectivity checks, like with UDP, are generated only by
   full implementations.  The TCP candidate pairs are in the same check
   list with the UDP candidate pairs, and they are scheduled for
   connectivity checks, as described in <a href="./rfc5245#section-5.8">Section 5.8 of [RFC5245]</a>, based
   on the priority order.

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/7.1.%20%20STUN%20Client%20Procedures"></a><a class="selflink" href="#section-7.1" id="section-7.1">7.1</a>.  STUN Client Procedures</span>

   When an agent wants to send a TCP-based connectivity check, it first
   opens a TCP connection, if none yet exists, for the 5-tuple defined
   by the candidate pair for which the check is to be sent.  This
   connection is opened from the local candidate of the pair to the
   remote candidate of the pair.  If the local candidate is tcp-active,
   the agent MUST open a connection from the interface associated with
   that local candidate.  This connection SHOULD be opened from an
   unallocated port.  For host candidates, this is readily done by
   connecting from the local candidate's interface.  For relayed, NAT-
   assisted, and UDP-tunneled candidates, the agent may need to use
   additional procedures specific to the protocol.

   Once the connection is established, the agent MUST utilize the shim
   defined in <a href="./rfc4571">RFC 4571</a> [<a href="./rfc4571" title='"Framing Real-time Transport Protocol (RTP) and RTP Control Protocol (RTCP) Packets over Connection- Oriented Transport"'>RFC4571</a>] for the duration this connection
   remains open.  The STUN Binding requests and responses are sent on
   top of this shim, so that the length field defined in <a href="./rfc4571">RFC 4571</a>
   precedes each STUN message.  If TLS or DTLS-SRTP is to be utilized
   for the media session, the TLS or DTLS-SRTP handshakes will take
   place on top of this shim as well.  However, they only start once ICE
   processing has completed.  In essence, the TLS or DTLS-SRTP
   handshakes are considered a part of the media protocol.  STUN is
   never run within the TLS or DTLS-SRTP session as part of the ICE
   procedures.

   If the TCP connection cannot be established, the check is considered
   to have failed, and a full-mode agent MUST update the pair state to
   Failed in the check list.  See <a href="./rfc5389#section-7.2.2">Section 7.2.2 of [RFC5389]</a> for more
   details on STUN over TCP.

   Once the connection is established, client procedures are identical
   to those for UDP candidates.  However, retransmissions of the STUN
   connectivity check messages are not needed, since TCP takes care of
   reliable delivery of the messages.  Note also that STUN responses
   received on an active TCP candidate will typically produce a peer
   reflexive candidate.  If the response to the first connectivity check
   on the established TCP connection is something other than a STUN





<span class="grey">Rosenberg, et al.            Standards Track                   [Page 17]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-18"></span>
<span class="grey"><a href="./rfc6544">RFC 6544</a>                         ICE TCP                      March 2012</span>


   message, the remote candidate address apparently was not one of the
   peer's addresses, and the agent SHOULD close the connection and
   consider all pairs with that remote candidate as failed.

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/7.2.%20%20STUN%20Server%20Procedures"></a><a class="selflink" href="#section-7.2" id="section-7.2">7.2</a>.  STUN Server Procedures</span>

   An ICE TCP agent, full or lite, MUST be prepared to receive incoming
   TCP connection requests on the base of any TCP candidate that is
   simultaneous-open or passive.  When the connection request is
   received, the agent MUST accept it.  The agent MUST utilize the
   framing defined in <a href="./rfc4571">RFC 4571</a> [<a href="./rfc4571" title='"Framing Real-time Transport Protocol (RTP) and RTP Control Protocol (RTCP) Packets over Connection- Oriented Transport"'>RFC4571</a>] for the lifetime of this
   connection.  Due to this framing, the agent will receive data in
   discrete frames.  Each frame could be media (such as RTP or SRTP),
   TLS, DTLS, or STUN packets.  The STUN packets are extracted as
   described in <a href="#section-10.2">Section 10.2</a>.

   Once the connection is established, STUN server procedures are
   identical to those for UDP candidates.  Note that STUN requests
   received on a passive TCP candidate will typically produce a remote
   peer reflexive candidate.

<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/8.%20%20Concluding%20ICE%20Processing"></a><a class="selflink" href="#section-8" id="section-8">8</a>.  Concluding ICE Processing</span>

   If there are TCP candidates for a media stream, a controlling agent
   MUST use the regular selection algorithm.

   When ICE processing for a media stream completes, each agent SHOULD
   close all TCP connections (that were opened due to this ICE session)
   except the ones between the candidate pairs selected by ICE.

   These two rules are related; the closure of connection on completion
   of ICE implies that a regular selection algorithm has to be used.
   This is because aggressive selection might cause transient pairs to
   be selected.  Once such a pair is selected, the agents would close
   the other connections, one of which may be about to be selected as a
   better choice.  This race condition may result in TCP connections
   being accidentally closed for the pair that ICE selects.

<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/9.%20%20Subsequent%20Offer%2FAnswer%20Exchanges"></a><a class="selflink" href="#section-9" id="section-9">9</a>.  Subsequent Offer/Answer Exchanges</span>

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/9.1.%20%20Updated%20Offer"></a><a class="selflink" href="#section-9.1" id="section-9.1">9.1</a>.  Updated Offer</span>

   When an updated offer is generated by the controlling endpoint after
   the connectivity checks have succeeded, the SDP extensions for
   connection-oriented media [<a href="./rfc4145" title='"TCP-Based Media Transport in the Session Description Protocol (SDP)"'>RFC4145</a>] are used to signal that an
   existing connection should be used, rather than opening a new one.





<span class="grey">Rosenberg, et al.            Standards Track                   [Page 18]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-19"></span>
<span class="grey"><a href="./rfc6544">RFC 6544</a>                         ICE TCP                      March 2012</span>


<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/9.2.%20%20ICE%20Restarts"></a><a class="selflink" href="#section-9.2" id="section-9.2">9.2</a>.  ICE Restarts</span>

   If an ICE restart occurs for a media stream with TCP candidate pairs
   that have been selected by ICE, the agents MUST NOT close the
   connections after the restart.  In the offer or answer that causes
   the restart, an agent MAY include a simultaneous-open candidate whose
   transport address matches the previously selected candidate.  If both
   agents do this, the result will be a simultaneous-open candidate pair
   matching an existing TCP connection.  In this case, the agents MUST
   NOT attempt to open a new connection (or start new TLS or DTLS-SRTP
   procedures).  Instead, that existing connection is reused, and STUN
   checks are performed.

   Once the restart completes, if the selected pair does not match the
   previously selected pair, the TCP connection for the previously
   selected pair SHOULD be closed by the agent.

<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/10.%20%20Media%20Handling"></a><a class="selflink" href="#section-10" id="section-10">10</a>.  Media Handling</span>

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/10.1.%20%20Sending%20Media"></a><a class="selflink" href="#section-10.1" id="section-10.1">10.1</a>.  Sending Media</span>

   When sending media, if the selected candidate pair matches an
   existing TCP connection, that connection MUST be used for sending
   media.

   The framing defined in <a href="./rfc4571">RFC 4571</a> MUST be used when sending media.  For
   media streams that are not RTP-based and do not normally use <a href="./rfc4571">RFC</a>
   <a href="./rfc4571">4571</a>, the agent treats the media stream as a byte stream and assumes
   that it has its own framing of some sort, if needed.  It then takes
   an arbitrary number of bytes from the byte stream and places that as
   a payload in the <a href="./rfc4571">RFC 4571</a> frames, including the length.  Next, the
   sender checks to see if the resulting set of bytes would be viewed as
   a STUN packet based on the rules in Sections <a href="#section-6">6</a> and <a href="#section-8">8</a> of [<a href="./rfc5389" title='"Session Traversal Utilities for NAT (STUN)"'>RFC5389</a>].
   This includes a check on the most significant two bits, the magic
   cookie, the length, and the fingerprint.  If, based on those rules,
   the bytes would be viewed as a STUN message, the sender MUST utilize
   a different number of bytes so that the length checks will fail.
   Though it is normally highly unlikely that an arbitrary number of
   bytes from a byte stream would resemble a STUN packet based on all of
   the checks, it can happen if the content of the application stream
   happens to contain a STUN message (for example, a file transfer of
   logs from a client that includes STUN messages).

   If TLS or DTLS-SRTP procedures are being utilized to protect the
   media stream, those procedures start at the point that media is
   permitted to flow, as defined in the ICE specification [<a href="./rfc5245" title='"Interactive Connectivity Establishment (ICE): A Protocol for Network Address Translator (NAT) Traversal for Offer/Answer Protocols"'>RFC5245</a>].
   The TLS or DTLS-SRTP handshakes occur on top of the <a href="./rfc4571">RFC 4571</a> shim and




<span class="grey">Rosenberg, et al.            Standards Track                   [Page 19]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-20"></span>
<span class="grey"><a href="./rfc6544">RFC 6544</a>                         ICE TCP                      March 2012</span>


   are considered part of the media stream for the purposes of this
   specification.

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/10.2.%20%20Receiving%20Media"></a><a class="selflink" href="#section-10.2" id="section-10.2">10.2</a>.  Receiving Media</span>

   The framing defined in <a href="./rfc4571">RFC 4571</a> MUST be used when receiving media.
   For media streams that are not RTP-based and do not normally use <a href="./rfc4571">RFC</a>
   <a href="./rfc4571">4571</a>, the agent extracts the payload of each <a href="./rfc4571">RFC 4571</a> frame and
   determines if it is a STUN or an application-layer data based on the
   procedures in ICE [<a href="./rfc5245" title='"Interactive Connectivity Establishment (ICE): A Protocol for Network Address Translator (NAT) Traversal for Offer/Answer Protocols"'>RFC5245</a>].  If media is being protected with DTLS-
   SRTP, the DTLS, RTP, and STUN packets are demultiplexed as described
   in <a href="./rfc5764#section-5.1.2">Section 5.1.2 of [RFC5764]</a>.

   For non-STUN data, the agent appends this to the ongoing byte stream
   collected from the frames.  It then parses the byte stream as if it
   had been directly received over the TCP connection.  This allows for
   ICE TCP to work without regard to the framing mechanism used by the
   application-layer protocol.

<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/11.%20%20Connection%20Management"></a><a class="selflink" href="#section-11" id="section-11">11</a>.  Connection Management</span>

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/11.1.%20%20Connections%20Formed%20during%20Connectivity%20Checks"></a><a class="selflink" href="#section-11.1" id="section-11.1">11.1</a>.  Connections Formed during Connectivity Checks</span>

   Once a TCP or TCP/TLS connection is opened by ICE for the purpose of
   connectivity checks, its life cycle depends on how it is used.  If
   that candidate pair is selected by ICE for usage for media, an agent
   SHOULD keep the connection open until:

   o  the session terminates,

   o  the media stream is removed, or

   o  an ICE restart takes place, resulting in the selection of a
      different candidate pair.

   In any of these cases, the agent SHOULD close the connection when
   that event occurs.  This applies to both agents in a session, in
   which case one of the agents will usually end up closing the
   connection first.

   If a connection has been selected by ICE, an agent MAY close it
   anyway.  As described in the next paragraph, this will cause it to be
   reopened almost immediately, and in the interim, media cannot be
   sent.  Consequently, such closures have a negative effect and are NOT
   RECOMMENDED.  However, there may be cases where an agent needs to
   close a connection for some reason.





<span class="grey">Rosenberg, et al.            Standards Track                   [Page 20]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-21"></span>
<span class="grey"><a href="./rfc6544">RFC 6544</a>                         ICE TCP                      March 2012</span>


   If an agent needs to send media on the selected candidate pair, and
   its TCP connection has closed, then:

   o  If the agent's local candidate is tcp-active or tcp-so, it MUST
      reopen a connection to the remote candidate of the selected pair.

   o  If the agent's local candidate is tcp-passive, the agent MUST
      await an incoming connection request and, consequently, will not
      be able to send media until it has been opened.

   If the TCP connection is established, the framing of <a href="./rfc4571">RFC 4571</a> is
   utilized.  If the agent opened the connection and is a full agent, it
   MUST send a STUN connectivity check.  An agent MUST be prepared to
   receive a connectivity check over a connection it opened or accepted
   (note that this is true in general; ICE requires that an agent be
   prepared to receive a connectivity check at any time, even after ICE
   processing completes).  If a full agent receives a connectivity check
   after re-establishment of the connection, it MUST generate a
   triggered check over that connection in response if it has not
   already sent a check.  Once an agent has sent a check and received a
   successful response, the connection is considered Valid, and media
   can be sent (which includes a TLS or DTLS-SRTP session resumption or
   restart).

   If the TCP connection cannot be established, the controlling agent
   SHOULD restart ICE for this media stream.  This will happen in cases
   where one of the agents is behind a NAT with connection-dependent
   mapping properties [<a href="./rfc5382" title='"NAT Behavioral Requirements for TCP"'>RFC5382</a>].

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/11.2.%20%20Connections%20Formed%20for%20Gathering%20Candidates"></a><a class="selflink" href="#section-11.2" id="section-11.2">11.2</a>.  Connections Formed for Gathering Candidates</span>

   If the agent opened a connection to a STUN server, or another similar
   server, for the purposes of gathering a server reflexive candidate,
   that connection SHOULD be closed by the client once ICE processing
   has completed.  This happens regardless of whether the candidate
   learned from the server was selected by ICE.

   If the agent opened a connection to a TURN server for the purposes of
   gathering a relayed candidate, that connection MUST be kept open by
   the client for the duration of the media session if a relayed
   candidate from the TURN server was selected by ICE.  Otherwise, the
   connection to the TURN server SHOULD be closed once ICE processing
   completes.

   If, despite efforts of the client, a TCP connection to a TURN server
   fails during the lifetime of the media session utilizing a transport
   address allocated by that server, the client SHOULD reconnect to the
   TURN server, obtain a new allocation, and restart ICE for that media



<span class="grey">Rosenberg, et al.            Standards Track                   [Page 21]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-22"></span>
<span class="grey"><a href="./rfc6544">RFC 6544</a>                         ICE TCP                      March 2012</span>


   stream.  Similar measures SHOULD apply also to other types of
   relaying servers.

<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/12.%20%20Security%20Considerations"></a><a class="selflink" href="#section-12" id="section-12">12</a>.  Security Considerations</span>

   The main threat in ICE is hijacking of connections for the purposes
   of directing media streams to denial-of-service (DoS) targets or to
   malicious users.  When full implementations are used, ICE TCP
   prevents that by only using TCP connections that have been validated.
   Validation requires a STUN transaction to take place over the
   connection.  This transaction cannot complete without both
   participants knowing a shared secret exchanged in the rendezvous
   protocol used with ICE, such as SIP [<a href="./rfc3261" title='"SIP: Session Initiation Protocol"'>RFC3261</a>].  This shared secret,
   in turn, is protected by that protocol exchange.  In the case of SIP,
   the usage of the SIP Secure (SIPS) [<a href="./rfc3261" title='"SIP: Session Initiation Protocol"'>RFC3261</a>] mechanism is
   RECOMMENDED.  When this is done, an attacker, even if it knows or can
   guess the port on which an agent is listening for incoming TCP
   connections, will not be able to open a connection and send media to
   the agent.

   If the rendezvous protocol exchange is compromised, the shared secret
   can be learned by an attacker, and the attacker may be able to fake
   the connectivity check validation and open a TCP connection to the
   target.  Hence, using additional security mechanisms (e.g.,
   application-layer security) that mitigate these risks is RECOMMENDED.

   A STUN amplification attack is described in <a href="./rfc5245#section-18.5.2">Section 18.5.2 of
   [RFC5245]</a>.  The same considerations apply to TCP, but the
   amplification effect with TCP is larger due to need for establishing
   a TCP connection before any checks are performed.  Therefore, an ICE
   agent SHOULD NOT have more than 5 outstanding TCP connection attempts
   with the same peer to the same IP address.

   If both agents use the lite mode, no connectivity checks are sent,
   and additional procedures (e.g., media-level security) are needed to
   validate the connection.  The lack of connectivity checks is
   especially problematic if one of the hosts is behind a NAT and has an
   address from a private address space: the peer may accidentally
   connect to a host in a different subnet that uses the same private
   address space.  This is one of the reasons why the lite mode is not
   appropriate for an ICE agent located behind a NAT.

   A more detailed analysis of different attacks and the various ways
   ICE prevents them are described in [<a href="./rfc5245" title='"Interactive Connectivity Establishment (ICE): A Protocol for Network Address Translator (NAT) Traversal for Offer/Answer Protocols"'>RFC5245</a>].  Those considerations
   apply to this specification.






<span class="grey">Rosenberg, et al.            Standards Track                   [Page 22]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-23"></span>
<span class="grey"><a href="./rfc6544">RFC 6544</a>                         ICE TCP                      March 2012</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/13.%20%20IANA%20Considerations"></a><a class="selflink" href="#section-13" id="section-13">13</a>.  IANA Considerations</span>

   IANA has created a new sub-registry "ICE Transport Protocols" in the
   "Interactive Connectivity Establishment (ICE)" registry for ICE
   candidate-attribute transport extensions.  Initial values are given
   below; future assignments are to be made through IETF Review or IESG
   Approval [<a href="./rfc5226" title="">RFC5226</a>].  Assignments consist of an extension token (as
   defined in <a href="./rfc5245#section-15.1">Section 15.1 of [RFC5245]</a>) and a reference to the document
   defining the extension.

   Token   Reference
   -----   ---------
   UDP     <a href="./rfc5245#section-15.1">RFC 5245, Section 15.1</a>
   TCP     <a href="./rfc6544#section-4.5">RFC 6544, Section 4.5</a>

<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/14.%20%20Acknowledgements"></a><a class="selflink" href="#section-14" id="section-14">14</a>.  Acknowledgements</span>

   The authors would like to thank Tim Moore, Saikat Guha, Francois
   Audet, Roni Even, Simon Perreault, Alfred Heggestad, Hadriel Kaplan,
   Jonathan Lennox, Flemming Andreasen, Dan Wing, and Vijay Gurbani for
   the reviews and input on this document.  Special thanks to Marc
   Petit-Huguenin for providing the SDP examples.

<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/15.%20%20References"></a><a class="selflink" href="#section-15" id="section-15">15</a>.  References</span>

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/15.1.%20%20Normative%20References"></a><a class="selflink" href="#section-15.1" id="section-15.1">15.1</a>.  Normative References</span>

   [<a id="ref-RFC2119">RFC2119</a>]   Bradner, S., "Key words for use in RFCs to Indicate
               Requirement Levels", <a href="https://www.rfc-editor.org/bcp/bcp14">BCP 14</a>, <a href="./rfc2119">RFC 2119</a>, March 1997.

   [<a id="ref-RFC3261">RFC3261</a>]   Rosenberg, J., Schulzrinne, H., Camarillo, G., Johnston,
               A., Peterson, J., Sparks, R., Handley, M., and E.
               Schooler, "SIP: Session Initiation Protocol", <a href="./rfc3261">RFC 3261</a>,
               June 2002.

   [<a id="ref-RFC3264">RFC3264</a>]   Rosenberg, J. and H. Schulzrinne, "An Offer/Answer Model
               with Session Description Protocol (SDP)", <a href="./rfc3264">RFC 3264</a>,
               June 2002.

   [<a id="ref-RFC3711">RFC3711</a>]   Baugher, M., McGrew, D., Naslund, M., Carrara, E., and K.
               Norrman, "The Secure Real-time Transport Protocol
               (SRTP)", <a href="./rfc3711">RFC 3711</a>, March 2004.

   [<a id="ref-RFC4145">RFC4145</a>]   Yon, D. and G. Camarillo, "TCP-Based Media Transport in
               the Session Description Protocol (SDP)", <a href="./rfc4145">RFC 4145</a>,
               September 2005.





<span class="grey">Rosenberg, et al.            Standards Track                   [Page 23]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-24"></span>
<span class="grey"><a href="./rfc6544">RFC 6544</a>                         ICE TCP                      March 2012</span>


   [<a id="ref-RFC4571">RFC4571</a>]   Lazzaro, J., "Framing Real-time Transport Protocol (RTP)
               and RTP Control Protocol (RTCP) Packets over Connection-
               Oriented Transport", <a href="./rfc4571">RFC 4571</a>, July 2006.

   [<a id="ref-RFC4572">RFC4572</a>]   Lennox, J., "Connection-Oriented Media Transport over the
               Transport Layer Security (TLS) Protocol in the Session
               Description Protocol (SDP)", <a href="./rfc4572">RFC 4572</a>, July 2006.

   [<a id="ref-RFC5226">RFC5226</a>]   Narten, T. and H. Alvestrand, "Guidelines for Writing an
               IANA Considerations Section in RFCs", <a href="https://www.rfc-editor.org/bcp/bcp26">BCP 26</a>, <a href="./rfc5226">RFC 5226</a>,
               May 2008.

   [<a id="ref-RFC5234">RFC5234</a>]   Crocker, D. and P. Overell, "Augmented BNF for Syntax
               Specifications: ABNF", STD 68, <a href="./rfc5234">RFC 5234</a>, January 2008.

   [<a id="ref-RFC5245">RFC5245</a>]   Rosenberg, J., "Interactive Connectivity Establishment
               (ICE): A Protocol for Network Address Translator (NAT)
               Traversal for Offer/Answer Protocols", <a href="./rfc5245">RFC 5245</a>,
               April 2010.

   [<a id="ref-RFC5389">RFC5389</a>]   Rosenberg, J., Mahy, R., Matthews, P., and D. Wing,
               "Session Traversal Utilities for NAT (STUN)", <a href="./rfc5389">RFC 5389</a>,
               October 2008.

   [<a id="ref-RFC5764">RFC5764</a>]   McGrew, D. and E. Rescorla, "Datagram Transport Layer
               Security (DTLS) Extension to Establish Keys for the
               Secure Real-time Transport Protocol (SRTP)", <a href="./rfc5764">RFC 5764</a>,
               May 2010.

   [<a id="ref-RFC5766">RFC5766</a>]   Mahy, R., Matthews, P., and J. Rosenberg, "Traversal
               Using Relays around NAT (TURN): Relay Extensions to
               Session Traversal Utilities for NAT (STUN)", <a href="./rfc5766">RFC 5766</a>,
               April 2010.

<span class="h3"><a class="dashAnchor" name="//apple_ref/cpp/Section/15.2.%20%20Informative%20References"></a><a class="selflink" href="#section-15.2" id="section-15.2">15.2</a>.  Informative References</span>

   [<a id="ref-IMC05">IMC05</a>]     Guha, S. and P. Francis, "Characterization and
               Measurement of TCP Traversal through NATs and Firewalls",
               Proceedings of the 5th ACM SIGCOMM Conference on Internet
               Measurement, 2005.

   [<a id="ref-NAT-PMP">NAT-PMP</a>]   Cheshire, S., Krochmal, M., and K. Sekar, "NAT Port
               Mapping Protocol (NAT-PMP)", Work in Progress,
               April 2008.

   [<a id="ref-PCP-BASE">PCP-BASE</a>]  Wing, D., Cheshire, S., Boucadair, M., Penno, R., and P.
               Selkirk, "Port Control Protocol (PCP)", Work in Progress,
               March 2012.



<span class="grey">Rosenberg, et al.            Standards Track                   [Page 24]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-25"></span>
<span class="grey"><a href="./rfc6544">RFC 6544</a>                         ICE TCP                      March 2012</span>


   [<a id="ref-RFC1928">RFC1928</a>]   Leech, M., Ganis, M., Lee, Y., Kuris, R., Koblas, D., and
               L. Jones, "SOCKS Protocol Version 5", <a href="./rfc1928">RFC 1928</a>,
               March 1996.

   [<a id="ref-RFC3089">RFC3089</a>]   Kitamura, H., "A SOCKS-based IPv6/IPv4 Gateway
               Mechanism", <a href="./rfc3089">RFC 3089</a>, April 2001.

   [<a id="ref-RFC3103">RFC3103</a>]   Borella, M., Grabelsky, D., Lo, J., and K. Taniguchi,
               "Realm Specific IP: Protocol Specification", <a href="./rfc3103">RFC 3103</a>,
               October 2001.

   [<a id="ref-RFC4251">RFC4251</a>]   Ylonen, T. and C. Lonvick, "The Secure Shell (SSH)
               Protocol Architecture", <a href="./rfc4251">RFC 4251</a>, January 2006.

   [<a id="ref-RFC4380">RFC4380</a>]   Huitema, C., "Teredo: Tunneling IPv6 over UDP through
               Network Address Translations (NATs)", <a href="./rfc4380">RFC 4380</a>,
               February 2006.

   [<a id="ref-RFC4540">RFC4540</a>]   Stiemerling, M., Quittek, J., and C. Cadar, "NEC's Simple
               Middlebox Configuration (SIMCO) Protocol Version 3.0",
               <a href="./rfc4540">RFC 4540</a>, May 2006.

   [<a id="ref-RFC4975">RFC4975</a>]   Campbell, B., Mahy, R., and C. Jennings, "The Message
               Session Relay Protocol (MSRP)", <a href="./rfc4975">RFC 4975</a>, September 2007.

   [<a id="ref-RFC5190">RFC5190</a>]   Quittek, J., Stiemerling, M., and P. Srisuresh,
               "Definitions of Managed Objects for Middlebox
               Communication", <a href="./rfc5190">RFC 5190</a>, March 2008.

   [<a id="ref-RFC5382">RFC5382</a>]   Guha, S., Biswas, K., Ford, B., Sivakumar, S., and P.
               Srisuresh, "NAT Behavioral Requirements for TCP",
               <a href="https://www.rfc-editor.org/bcp/bcp142">BCP 142</a>, <a href="./rfc5382">RFC 5382</a>, October 2008.

   [<a id="ref-RFC6062">RFC6062</a>]   Perreault, S. and J. Rosenberg, "Traversal Using Relays
               around NAT (TURN) Extensions for TCP Allocations",
               <a href="./rfc6062">RFC 6062</a>, November 2010.

   [<a id="ref-RFC6081">RFC6081</a>]   Thaler, D., "Teredo Extensions", <a href="./rfc6081">RFC 6081</a>, January 2011.

   [<a id="ref-RFC6156">RFC6156</a>]   Camarillo, G., Novo, O., and S. Perreault, "Traversal
               Using Relays around NAT (TURN) Extension for IPv6",
               <a href="./rfc6156">RFC 6156</a>, April 2011.

   [<a id="ref-UPnP-IGD">UPnP-IGD</a>]  Warrier, U., Iyer, P., Pennerath, F., Marynissen, G.,
               Schmitz, M., Siddiqi, W., and M. Blaszczak, "Internet
               Gateway Device (IGD) Standardized Device Control Protocol
               V 1.0", November 2001.




<span class="grey">Rosenberg, et al.            Standards Track                   [Page 25]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-26"></span>
<span class="grey"><a href="./rfc6544">RFC 6544</a>                         ICE TCP                      March 2012</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/Appendix%20A.%20%20Limitations%20of%20ICE%20TCP"></a><a class="selflink" href="#appendix-A" id="appendix-A">Appendix A</a>.  Limitations of ICE TCP</span>

   Compared to UDP-based ICE, ICE TCP has, in general, lower success
   probability for enabling connectivity without a relay if both of the
   hosts are behind a NAT.  This happens because many of the currently
   deployed NATs have endpoint-dependent mapping behavior, or they do
   not support the flow of TCP handshake packets seen in the case of TCP
   simultaneous-open, e.g., some NATs do not allow incoming TCP SYN
   packets from an address where a SYN packet has been sent to recently
   or the subsequent SYN-ACK is not processed properly.

   It has been reported in [<a href="#ref-IMC05" title='"Characterization and Measurement of TCP Traversal through NATs and Firewalls"'>IMC05</a>] that with the population of NATs
   deployed at the time of the measurements (2005), one of the NAT
   traversal techniques described here, TCP simultaneous-open, worked in
   roughly 45% of the cases.  Also, not all operating systems implement
   TCP simultaneous-open properly and thus are not able to use such
   candidates.  However, when more NATs comply with the requirements set
   by [<a href="./rfc5382" title='"NAT Behavioral Requirements for TCP"'>RFC5382</a>] and operating system TCP stacks are fixed, the success
   probability of simultaneous-open is likely to increase.  Also, it is
   important to implement additional techniques with higher success
   ratios, such as Teredo, whose success in different scenarios is
   described in Figure 1 of [<a href="./rfc6081" title='"Teredo Extensions"'>RFC6081</a>].

   Finally, it should be noted that implementing various techniques
   listed in <a href="#section-5">Section 5</a> should increase the success probability, but many
   of these techniques require support from the endpoints and/or from
   some network elements (e.g., from the NATs).  Without comprehensive
   experimental data on how well different techniques are supported, the
   actual increase of success probability is hard to evaluate.






















<span class="grey">Rosenberg, et al.            Standards Track                   [Page 26]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-27"></span>
<span class="grey"><a href="./rfc6544">RFC 6544</a>                         ICE TCP                      March 2012</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/Appendix%20B.%20%20Implementation%20Considerations%20for%20BSD%20Sockets"></a><a class="selflink" href="#appendix-B" id="appendix-B">Appendix B</a>.  Implementation Considerations for BSD Sockets</span>

   This specification requires unusual handling of TCP connections, the
   implementation of which is non-trivial in traditional BSD socket
   APIs.

   In particular, ICE requires an agent to obtain a local TCP candidate,
   bound to a local IP and port, then initiate a TCP connection from
   that local port (e.g., to the STUN server in order to obtain server
   reflexive candidates, to the TURN server to obtain a relayed
   candidate, or to the peer as part of a connectivity check), and be
   prepared to receive incoming TCP connections (for passive and
   simultaneous-open candidates).  A "typical" BSD socket is used either
   for initiating or receiving connections, and not for both.  The code
   required to allow incoming and outgoing connections on the same local
   IP and port is non-obvious.  The following pseudocode, contributed by
   Saikat Guha, has been found to work on many platforms:

   for i in 0 to MAX
      sock_i = socket()
      set(sock_i, SO_REUSEADDR)
      bind(sock_i, local)

   listen(sock_0)
   connect(sock_1, stun)
   connect(sock_2, remote_a)
   connect(sock_3, remote_b)

   The key here is that, prior to the listen() call, the full set of
   sockets that need to be utilized for outgoing connections must be
   allocated and bound to the local IP address and port.  This number,
   MAX, represents the maximum number of TCP connections to different
   destinations that might need to be established from the same local
   candidate.  This number can be potentially large for simultaneous-
   open candidates.  If a request forks, ICE procedures may take place
   with multiple peers.  Furthermore, for each peer, connections would
   need to be established to each passive or simultaneous-open candidate
   for the same component.  If we assume a worst case of 5 forked
   branches, and for each peer, five simultaneous-open candidates, that
   results in MAX=25.











<span class="grey">Rosenberg, et al.            Standards Track                   [Page 27]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-28"></span>
<span class="grey"><a href="./rfc6544">RFC 6544</a>                         ICE TCP                      March 2012</span>


<span class="h2"><a class="dashAnchor" name="//apple_ref/cpp/Section/Appendix%20C.%20%20SDP%20Examples"></a><a class="selflink" href="#appendix-C" id="appendix-C">Appendix C</a>.  SDP Examples</span>

  This section shows two examples of SDP offer and answer when the ICE
  TCP extension is used.  Both examples are based on the simplified
  topology of Figure 8 in [<a href="./rfc5245" title='"Interactive Connectivity Establishment (ICE): A Protocol for Network Address Translator (NAT) Traversal for Offer/Answer Protocols"'>RFC5245</a>], with the same IP addresses.  The
  examples shown here should be considered strictly informative.

  In the first example, the offer contains only TCP candidates (lines
  are folded in examples to satisfy RFC formatting rules):

  v=0
  o=jdoe 2890844526 2890842807 IN IP4 10.0.1.1
  s=
  c=IN IP4 192.0.2.3
  t=0 0
  a=ice-pwd:asd88fgpdd777uzjYhagZg
  a=ice-ufrag:8hhY
  m=audio 45664 TCP/RTP/AVP 0
  b=RS:0
  b=RR:0
  a=rtpmap:0 PCMU/8000
  a=setup:active
  a=connection:new
  a=candidate:1 1 TCP 2128609279 10.0.1.1 9 typ host tcptype active
  a=candidate:2 1 TCP 2124414975 10.0.1.1 8998 typ host tcptype passive
  a=candidate:3 1 TCP 2120220671 10.0.1.1 8999 typ host tcptype so
  a=candidate:4 1 TCP 1688207359 192.0.2.3 9 typ srflx raddr 10.0.1.1
    rport 9 tcptype active
  a=candidate:5 1 TCP 1684013055 192.0.2.3 45664 typ srflx raddr
    10.0.1.1 rport 8998 tcptype passive
  a=candidate:6 1 TCP 1692401663 192.0.2.3 45687 typ srflx raddr
    10.0.1.1 rport 8999 tcptype so



















<span class="grey">Rosenberg, et al.            Standards Track                   [Page 28]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-29"></span>
<span class="grey"><a href="./rfc6544">RFC 6544</a>                         ICE TCP                      March 2012</span>


  The answer to that offer could look like this:

  v=0
  o=bob 2808844564 2808844564 IN IP4 192.0.2.1
  s=
  c=IN IP4 192.0.2.1
  t=0 0
  a=ice-pwd:YH75Fviy6338Vbrhrlp8Yh
  a=ice-ufrag:9uB6
  m=audio 3478 TCP/RTP/AVP 0
  b=RS:0
  b=RR:0
  a=setup:passive
  a=connection:new
  a=rtpmap:0 PCMU/8000
  a=candidate:1 1 TCP 2128609279 192.0.2.1 9 typ host tcptype active
  a=candidate:2 1 TCP 2124414975 192.0.2.1 3478 typ host tcptype passive
  a=candidate:3 1 TCP 2120220671 192.0.2.1 3482 typ host tcptype so

  In the second example, UDP and TCP media streams are mixed, but S-O
  candidates are omitted due to hosts not supporting TCP simultaneous-
  open, and UDP candidates are preferred (but preference order for
  candidate types is kept the same) by decreasing the TCP candidate type
  preferences by one (i.e., using type preference 125 for the host
  candidates and 99 for the server reflexive candidates):

  v=0
  o=jdoe 2890844526 2890842807 IN IP4 10.0.1.1
  s=
  c=IN IP4 192.0.2.3
  t=0 0
  a=ice-pwd:asd88fgpdd777uzjYhagZg
  a=ice-ufrag:8hhY
  m=audio 45664 RTP/AVP 0
  b=RS:0
  b=RR:0
  a=rtpmap:0 PCMU/8000
  a=candidate:1 1 TCP 2111832063 10.0.1.1 9 typ host tcptype active
  a=candidate:2 1 TCP 2107637759 10.0.1.1 9012 typ host tcptype passive
  a=candidate:3 1 TCP 1671430143 192.0.2.3 9 typ srflx raddr 10.0.1.1
    rport 9 tcptype active
  a=candidate:4 1 TCP 1667235839 192.0.2.3 44642 typ srflx raddr
    10.0.1.1 rport 9012 tcptype passive
  a=candidate:5 1 UDP 2130706431 10.0.1.1 8998 typ host
  a=candidate:6 1 UDP 1694498815 192.0.2.3 45664 typ srflx raddr
    10.0.1.1 rport 8998





<span class="grey">Rosenberg, et al.            Standards Track                   [Page 29]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-30"></span>
<span class="grey"><a href="./rfc6544">RFC 6544</a>                         ICE TCP                      March 2012</span>


  The corresponding answer could look like this:

  v=0
  o=bob 2808844564 2808844564 IN IP4 192.0.2.1
  s=
  c=IN IP4 192.0.2.1
  t=0 0
  a=ice-pwd:YH75Fviy6338Vbrhrlp8Yh
  a=ice-ufrag:9uB6
  m=audio 3478 RTP/AVP 0
  b=RS:0
  b=RR:0
  a=rtpmap:0 PCMU/8000
  a=candidate:1 1 TCP 2111832063 192.0.2.1 9 typ host tcptype active
  a=candidate:2 1 TCP 2107637759 192.0.2.1 3478 typ host tcptype passive
  a=candidate:3 1 UDP 2130706431 192.0.2.1 3478 typ host



































<span class="grey">Rosenberg, et al.            Standards Track                   [Page 30]</span></pre>
<hr class="noprint"/><!--NewPage--><pre class="newpage"><span id="page-31"></span>
<span class="grey"><a href="./rfc6544">RFC 6544</a>                         ICE TCP                      March 2012</span>


Authors' Addresses

   Jonathan Rosenberg
   jdrosen.net

   EMail: jdrosen@jdrosen.net
   URI:   <a href="http://www.jdrosen.net">http://www.jdrosen.net</a>


   Ari Keranen
   Ericsson
   Hirsalantie 11
   02420 Jorvas
   Finland

   EMail: ari.keranen@ericsson.com


   Bruce B. Lowekamp
   Skype

   EMail: bbl@lowekamp.net


   Adam Roach
   Tekelec
   17210 Campbell Rd., Suite 250
   Dallas, TX 75252
   US

   EMail: adam@nostrum.com




















Rosenberg, et al.            Standards Track                   [Page 31]
</pre>
</body></html>